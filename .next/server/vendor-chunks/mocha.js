/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mocha";
exports.ids = ["vendor-chunks/mocha"];
exports.modules = {

/***/ "(ssr)/./node_modules/mocha/node_modules/brace-expansion/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/mocha/node_modules/brace-expansion/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var balanced = __webpack_require__(/*! balanced-match */ \"(ssr)/./node_modules/balanced-match/index.js\");\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m) return [str];\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  if (/\\$$/.test(m.pre)) {    \n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre+ '{' + m.body + '}' + post[k];\n      expansions.push(expansion);\n    }\n  } else {\n    var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isSequence = isNumericSequence || isAlphaSequence;\n    var isOptions = m.body.indexOf(',') >= 0;\n    if (!isSequence && !isOptions) {\n      // {a},b}\n      if (m.post.match(/,.*\\}/)) {\n        str = m.pre + '{' + m.body + escClose + m.post;\n        return expand(str);\n      }\n      return [str];\n    }\n\n    var n;\n    if (isSequence) {\n      n = m.body.split(/\\.\\./);\n    } else {\n      n = parseCommaParts(m.body);\n      if (n.length === 1) {\n        // x{{a,b}}y ==> x{a}y x{b}y\n        n = expand(n[0], false).map(embrace);\n        if (n.length === 1) {\n          return post.map(function(p) {\n            return m.pre + n[0] + p;\n          });\n        }\n      }\n    }\n\n    // at this point, n is the parts, and we know it's not a comma set\n    // with a single entry.\n    var N;\n\n    if (isSequence) {\n      var x = numeric(n[0]);\n      var y = numeric(n[1]);\n      var width = Math.max(n[0].length, n[1].length)\n      var incr = n.length == 3\n        ? Math.abs(numeric(n[2]))\n        : 1;\n      var test = lte;\n      var reverse = y < x;\n      if (reverse) {\n        incr *= -1;\n        test = gte;\n      }\n      var pad = n.some(isPadded);\n\n      N = [];\n\n      for (var i = x; test(i, y); i += incr) {\n        var c;\n        if (isAlphaSequence) {\n          c = String.fromCharCode(i);\n          if (c === '\\\\')\n            c = '';\n        } else {\n          c = String(i);\n          if (pad) {\n            var need = width - c.length;\n            if (need > 0) {\n              var z = new Array(need + 1).join('0');\n              if (i < 0)\n                c = '-' + z + c.slice(1);\n              else\n                c = z + c;\n            }\n          }\n        }\n        N.push(c);\n      }\n    } else {\n      N = [];\n\n      for (var j = 0; j < n.length; j++) {\n        N.push.apply(N, expand(n[j], false));\n      }\n    }\n\n    for (var j = 0; j < N.length; j++) {\n      for (var k = 0; k < post.length; k++) {\n        var expansion = pre + N[j] + post[k];\n        if (!isTop || isSequence || expansion)\n          expansions.push(expansion);\n      }\n    }\n  }\n\n  return expansions;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2JyYWNlLWV4cGFuc2lvbi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsb0VBQWdCOztBQUV2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHdDQUF3QyxHQUFHLElBQUk7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLEtBQUs7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQix1Q0FBdUMsR0FBRztBQUMxQyxZQUFZLEdBQUcseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsY0FBYyxHQUFHO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLEtBQUs7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckMsNkJBQTZCLGVBQWU7QUFDNUM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxFQUFFO0FBQ1osNkJBQTZCO0FBQzdCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGNBQWMsS0FBSyxRQUFRLEVBQUUsSUFBSSxFQUFFO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUEsc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixjQUFjO0FBQ2xDLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL21vY2hhL25vZGVfbW9kdWxlcy9icmFjZS1leHBhbnNpb24vaW5kZXguanM/MjVlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYmFsYW5jZWQgPSByZXF1aXJlKCdiYWxhbmNlZC1tYXRjaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cGFuZFRvcDtcblxudmFyIGVzY1NsYXNoID0gJ1xcMFNMQVNIJytNYXRoLnJhbmRvbSgpKydcXDAnO1xudmFyIGVzY09wZW4gPSAnXFwwT1BFTicrTWF0aC5yYW5kb20oKSsnXFwwJztcbnZhciBlc2NDbG9zZSA9ICdcXDBDTE9TRScrTWF0aC5yYW5kb20oKSsnXFwwJztcbnZhciBlc2NDb21tYSA9ICdcXDBDT01NQScrTWF0aC5yYW5kb20oKSsnXFwwJztcbnZhciBlc2NQZXJpb2QgPSAnXFwwUEVSSU9EJytNYXRoLnJhbmRvbSgpKydcXDAnO1xuXG5mdW5jdGlvbiBudW1lcmljKHN0cikge1xuICByZXR1cm4gcGFyc2VJbnQoc3RyLCAxMCkgPT0gc3RyXG4gICAgPyBwYXJzZUludChzdHIsIDEwKVxuICAgIDogc3RyLmNoYXJDb2RlQXQoMCk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUJyYWNlcyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgnXFxcXFxcXFwnKS5qb2luKGVzY1NsYXNoKVxuICAgICAgICAgICAgLnNwbGl0KCdcXFxceycpLmpvaW4oZXNjT3BlbilcbiAgICAgICAgICAgIC5zcGxpdCgnXFxcXH0nKS5qb2luKGVzY0Nsb3NlKVxuICAgICAgICAgICAgLnNwbGl0KCdcXFxcLCcpLmpvaW4oZXNjQ29tbWEpXG4gICAgICAgICAgICAuc3BsaXQoJ1xcXFwuJykuam9pbihlc2NQZXJpb2QpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZUJyYWNlcyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdChlc2NTbGFzaCkuam9pbignXFxcXCcpXG4gICAgICAgICAgICAuc3BsaXQoZXNjT3Blbikuam9pbigneycpXG4gICAgICAgICAgICAuc3BsaXQoZXNjQ2xvc2UpLmpvaW4oJ30nKVxuICAgICAgICAgICAgLnNwbGl0KGVzY0NvbW1hKS5qb2luKCcsJylcbiAgICAgICAgICAgIC5zcGxpdChlc2NQZXJpb2QpLmpvaW4oJy4nKTtcbn1cblxuXG4vLyBCYXNpY2FsbHkganVzdCBzdHIuc3BsaXQoXCIsXCIpLCBidXQgaGFuZGxpbmcgY2FzZXNcbi8vIHdoZXJlIHdlIGhhdmUgbmVzdGVkIGJyYWNlZCBzZWN0aW9ucywgd2hpY2ggc2hvdWxkIGJlXG4vLyB0cmVhdGVkIGFzIGluZGl2aWR1YWwgbWVtYmVycywgbGlrZSB7YSx7YixjfSxkfVxuZnVuY3Rpb24gcGFyc2VDb21tYVBhcnRzKHN0cikge1xuICBpZiAoIXN0cilcbiAgICByZXR1cm4gWycnXTtcblxuICB2YXIgcGFydHMgPSBbXTtcbiAgdmFyIG0gPSBiYWxhbmNlZCgneycsICd9Jywgc3RyKTtcblxuICBpZiAoIW0pXG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnLCcpO1xuXG4gIHZhciBwcmUgPSBtLnByZTtcbiAgdmFyIGJvZHkgPSBtLmJvZHk7XG4gIHZhciBwb3N0ID0gbS5wb3N0O1xuICB2YXIgcCA9IHByZS5zcGxpdCgnLCcpO1xuXG4gIHBbcC5sZW5ndGgtMV0gKz0gJ3snICsgYm9keSArICd9JztcbiAgdmFyIHBvc3RQYXJ0cyA9IHBhcnNlQ29tbWFQYXJ0cyhwb3N0KTtcbiAgaWYgKHBvc3QubGVuZ3RoKSB7XG4gICAgcFtwLmxlbmd0aC0xXSArPSBwb3N0UGFydHMuc2hpZnQoKTtcbiAgICBwLnB1c2guYXBwbHkocCwgcG9zdFBhcnRzKTtcbiAgfVxuXG4gIHBhcnRzLnB1c2guYXBwbHkocGFydHMsIHApO1xuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuZnVuY3Rpb24gZXhwYW5kVG9wKHN0cikge1xuICBpZiAoIXN0cilcbiAgICByZXR1cm4gW107XG5cbiAgLy8gSSBkb24ndCBrbm93IHdoeSBCYXNoIDQuMyBkb2VzIHRoaXMsIGJ1dCBpdCBkb2VzLlxuICAvLyBBbnl0aGluZyBzdGFydGluZyB3aXRoIHt9IHdpbGwgaGF2ZSB0aGUgZmlyc3QgdHdvIGJ5dGVzIHByZXNlcnZlZFxuICAvLyBidXQgKm9ubHkqIGF0IHRoZSB0b3AgbGV2ZWwsIHNvIHt9LGF9YiB3aWxsIG5vdCBleHBhbmQgdG8gYW55dGhpbmcsXG4gIC8vIGJ1dCBhe30sYn1jIHdpbGwgYmUgZXhwYW5kZWQgdG8gW2F9YyxhYmNdLlxuICAvLyBPbmUgY291bGQgYXJndWUgdGhhdCB0aGlzIGlzIGEgYnVnIGluIEJhc2gsIGJ1dCBzaW5jZSB0aGUgZ29hbCBvZlxuICAvLyB0aGlzIG1vZHVsZSBpcyB0byBtYXRjaCBCYXNoJ3MgcnVsZXMsIHdlIGVzY2FwZSBhIGxlYWRpbmcge31cbiAgaWYgKHN0ci5zdWJzdHIoMCwgMikgPT09ICd7fScpIHtcbiAgICBzdHIgPSAnXFxcXHtcXFxcfScgKyBzdHIuc3Vic3RyKDIpO1xuICB9XG5cbiAgcmV0dXJuIGV4cGFuZChlc2NhcGVCcmFjZXMoc3RyKSwgdHJ1ZSkubWFwKHVuZXNjYXBlQnJhY2VzKTtcbn1cblxuZnVuY3Rpb24gZW1icmFjZShzdHIpIHtcbiAgcmV0dXJuICd7JyArIHN0ciArICd9Jztcbn1cbmZ1bmN0aW9uIGlzUGFkZGVkKGVsKSB7XG4gIHJldHVybiAvXi0/MFxcZC8udGVzdChlbCk7XG59XG5cbmZ1bmN0aW9uIGx0ZShpLCB5KSB7XG4gIHJldHVybiBpIDw9IHk7XG59XG5mdW5jdGlvbiBndGUoaSwgeSkge1xuICByZXR1cm4gaSA+PSB5O1xufVxuXG5mdW5jdGlvbiBleHBhbmQoc3RyLCBpc1RvcCkge1xuICB2YXIgZXhwYW5zaW9ucyA9IFtdO1xuXG4gIHZhciBtID0gYmFsYW5jZWQoJ3snLCAnfScsIHN0cik7XG4gIGlmICghbSkgcmV0dXJuIFtzdHJdO1xuXG4gIC8vIG5vIG5lZWQgdG8gZXhwYW5kIHByZSwgc2luY2UgaXQgaXMgZ3VhcmFudGVlZCB0byBiZSBmcmVlIG9mIGJyYWNlLXNldHNcbiAgdmFyIHByZSA9IG0ucHJlO1xuICB2YXIgcG9zdCA9IG0ucG9zdC5sZW5ndGhcbiAgICA/IGV4cGFuZChtLnBvc3QsIGZhbHNlKVxuICAgIDogWycnXTtcblxuICBpZiAoL1xcJCQvLnRlc3QobS5wcmUpKSB7ICAgIFxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcG9zdC5sZW5ndGg7IGsrKykge1xuICAgICAgdmFyIGV4cGFuc2lvbiA9IHByZSsgJ3snICsgbS5ib2R5ICsgJ30nICsgcG9zdFtrXTtcbiAgICAgIGV4cGFuc2lvbnMucHVzaChleHBhbnNpb24pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXNOdW1lcmljU2VxdWVuY2UgPSAvXi0/XFxkK1xcLlxcLi0/XFxkKyg/OlxcLlxcLi0/XFxkKyk/JC8udGVzdChtLmJvZHkpO1xuICAgIHZhciBpc0FscGhhU2VxdWVuY2UgPSAvXlthLXpBLVpdXFwuXFwuW2EtekEtWl0oPzpcXC5cXC4tP1xcZCspPyQvLnRlc3QobS5ib2R5KTtcbiAgICB2YXIgaXNTZXF1ZW5jZSA9IGlzTnVtZXJpY1NlcXVlbmNlIHx8IGlzQWxwaGFTZXF1ZW5jZTtcbiAgICB2YXIgaXNPcHRpb25zID0gbS5ib2R5LmluZGV4T2YoJywnKSA+PSAwO1xuICAgIGlmICghaXNTZXF1ZW5jZSAmJiAhaXNPcHRpb25zKSB7XG4gICAgICAvLyB7YX0sYn1cbiAgICAgIGlmIChtLnBvc3QubWF0Y2goLywuKlxcfS8pKSB7XG4gICAgICAgIHN0ciA9IG0ucHJlICsgJ3snICsgbS5ib2R5ICsgZXNjQ2xvc2UgKyBtLnBvc3Q7XG4gICAgICAgIHJldHVybiBleHBhbmQoc3RyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbc3RyXTtcbiAgICB9XG5cbiAgICB2YXIgbjtcbiAgICBpZiAoaXNTZXF1ZW5jZSkge1xuICAgICAgbiA9IG0uYm9keS5zcGxpdCgvXFwuXFwuLyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBwYXJzZUNvbW1hUGFydHMobS5ib2R5KTtcbiAgICAgIGlmIChuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyB4e3thLGJ9fXkgPT0+IHh7YX15IHh7Yn15XG4gICAgICAgIG4gPSBleHBhbmQoblswXSwgZmFsc2UpLm1hcChlbWJyYWNlKTtcbiAgICAgICAgaWYgKG4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHBvc3QubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBtLnByZSArIG5bMF0gKyBwO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgbiBpcyB0aGUgcGFydHMsIGFuZCB3ZSBrbm93IGl0J3Mgbm90IGEgY29tbWEgc2V0XG4gICAgLy8gd2l0aCBhIHNpbmdsZSBlbnRyeS5cbiAgICB2YXIgTjtcblxuICAgIGlmIChpc1NlcXVlbmNlKSB7XG4gICAgICB2YXIgeCA9IG51bWVyaWMoblswXSk7XG4gICAgICB2YXIgeSA9IG51bWVyaWMoblsxXSk7XG4gICAgICB2YXIgd2lkdGggPSBNYXRoLm1heChuWzBdLmxlbmd0aCwgblsxXS5sZW5ndGgpXG4gICAgICB2YXIgaW5jciA9IG4ubGVuZ3RoID09IDNcbiAgICAgICAgPyBNYXRoLmFicyhudW1lcmljKG5bMl0pKVxuICAgICAgICA6IDE7XG4gICAgICB2YXIgdGVzdCA9IGx0ZTtcbiAgICAgIHZhciByZXZlcnNlID0geSA8IHg7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICBpbmNyICo9IC0xO1xuICAgICAgICB0ZXN0ID0gZ3RlO1xuICAgICAgfVxuICAgICAgdmFyIHBhZCA9IG4uc29tZShpc1BhZGRlZCk7XG5cbiAgICAgIE4gPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IHg7IHRlc3QoaSwgeSk7IGkgKz0gaW5jcikge1xuICAgICAgICB2YXIgYztcbiAgICAgICAgaWYgKGlzQWxwaGFTZXF1ZW5jZSkge1xuICAgICAgICAgIGMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgICAgICAgIGlmIChjID09PSAnXFxcXCcpXG4gICAgICAgICAgICBjID0gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYyA9IFN0cmluZyhpKTtcbiAgICAgICAgICBpZiAocGFkKSB7XG4gICAgICAgICAgICB2YXIgbmVlZCA9IHdpZHRoIC0gYy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobmVlZCA+IDApIHtcbiAgICAgICAgICAgICAgdmFyIHogPSBuZXcgQXJyYXkobmVlZCArIDEpLmpvaW4oJzAnKTtcbiAgICAgICAgICAgICAgaWYgKGkgPCAwKVxuICAgICAgICAgICAgICAgIGMgPSAnLScgKyB6ICsgYy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGMgPSB6ICsgYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgTi5wdXNoKGMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBOID0gW107XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbi5sZW5ndGg7IGorKykge1xuICAgICAgICBOLnB1c2guYXBwbHkoTiwgZXhwYW5kKG5bal0sIGZhbHNlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBOLmxlbmd0aDsgaisrKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHBvc3QubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGV4cGFuc2lvbiA9IHByZSArIE5bal0gKyBwb3N0W2tdO1xuICAgICAgICBpZiAoIWlzVG9wIHx8IGlzU2VxdWVuY2UgfHwgZXhwYW5zaW9uKVxuICAgICAgICAgIGV4cGFuc2lvbnMucHVzaChleHBhbnNpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHBhbnNpb25zO1xufVxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/brace-expansion/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/diff/lib/convert/dmp.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mocha/node_modules/diff/lib/convert/dmp.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/*istanbul ignore start*/\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.convertChangesToDMP = convertChangesToDMP;\n\n/*istanbul ignore end*/\n// See: http://code.google.com/p/google-diff-match-patch/wiki/API\nfunction convertChangesToDMP(changes) {\n  var ret = [],\n      change,\n      operation;\n\n  for (var i = 0; i < changes.length; i++) {\n    change = changes[i];\n\n    if (change.added) {\n      operation = 1;\n    } else if (change.removed) {\n      operation = -1;\n    } else {\n      operation = 0;\n    }\n\n    ret.push([operation, change.value]);\n  }\n\n  return ret;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb252ZXJ0L2RtcC5qcyJdLCJuYW1lcyI6WyJjb252ZXJ0Q2hhbmdlc1RvRE1QIiwiY2hhbmdlcyIsInJldCIsImNoYW5nZSIsIm9wZXJhdGlvbiIsImkiLCJsZW5ndGgiLCJhZGRlZCIsInJlbW92ZWQiLCJwdXNoIiwidmFsdWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ08sU0FBU0EsbUJBQVQsQ0FBNkJDLE9BQTdCLEVBQXNDO0FBQzNDLE1BQUlDLEdBQUcsR0FBRyxFQUFWO0FBQUEsTUFDSUMsTUFESjtBQUFBLE1BRUlDLFNBRko7O0FBR0EsT0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHSixPQUFPLENBQUNLLE1BQTVCLEVBQW9DRCxDQUFDLEVBQXJDLEVBQXlDO0FBQ3ZDRixJQUFBQSxNQUFNLEdBQUdGLE9BQU8sQ0FBQ0ksQ0FBRCxDQUFoQjs7QUFDQSxRQUFJRixNQUFNLENBQUNJLEtBQVgsRUFBa0I7QUFDaEJILE1BQUFBLFNBQVMsR0FBRyxDQUFaO0FBQ0QsS0FGRCxNQUVPLElBQUlELE1BQU0sQ0FBQ0ssT0FBWCxFQUFvQjtBQUN6QkosTUFBQUEsU0FBUyxHQUFHLENBQUMsQ0FBYjtBQUNELEtBRk0sTUFFQTtBQUNMQSxNQUFBQSxTQUFTLEdBQUcsQ0FBWjtBQUNEOztBQUVERixJQUFBQSxHQUFHLENBQUNPLElBQUosQ0FBUyxDQUFDTCxTQUFELEVBQVlELE1BQU0sQ0FBQ08sS0FBbkIsQ0FBVDtBQUNEOztBQUNELFNBQU9SLEdBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIFNlZTogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1kaWZmLW1hdGNoLXBhdGNoL3dpa2kvQVBJXG5leHBvcnQgZnVuY3Rpb24gY29udmVydENoYW5nZXNUb0RNUChjaGFuZ2VzKSB7XG4gIGxldCByZXQgPSBbXSxcbiAgICAgIGNoYW5nZSxcbiAgICAgIG9wZXJhdGlvbjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2hhbmdlID0gY2hhbmdlc1tpXTtcbiAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XG4gICAgICBvcGVyYXRpb24gPSAxO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcbiAgICAgIG9wZXJhdGlvbiA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcGVyYXRpb24gPSAwO1xuICAgIH1cblxuICAgIHJldC5wdXNoKFtvcGVyYXRpb24sIGNoYW5nZS52YWx1ZV0pO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG4iXX0=\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL2NvbnZlcnQvZG1wLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG9CQUFvQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL21vY2hhL25vZGVfbW9kdWxlcy9kaWZmL2xpYi9jb252ZXJ0L2RtcC5qcz80ZGNmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jb252ZXJ0Q2hhbmdlc1RvRE1QID0gY29udmVydENoYW5nZXNUb0RNUDtcblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbi8vIFNlZTogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1kaWZmLW1hdGNoLXBhdGNoL3dpa2kvQVBJXG5mdW5jdGlvbiBjb252ZXJ0Q2hhbmdlc1RvRE1QKGNoYW5nZXMpIHtcbiAgdmFyIHJldCA9IFtdLFxuICAgICAgY2hhbmdlLFxuICAgICAgb3BlcmF0aW9uO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgIGNoYW5nZSA9IGNoYW5nZXNbaV07XG5cbiAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XG4gICAgICBvcGVyYXRpb24gPSAxO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcbiAgICAgIG9wZXJhdGlvbiA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcGVyYXRpb24gPSAwO1xuICAgIH1cblxuICAgIHJldC5wdXNoKFtvcGVyYXRpb24sIGNoYW5nZS52YWx1ZV0pO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWpiMjUyWlhKMEwyUnRjQzVxY3lKZExDSnVZVzFsY3lJNld5SmpiMjUyWlhKMFEyaGhibWRsYzFSdlJFMVFJaXdpWTJoaGJtZGxjeUlzSW5KbGRDSXNJbU5vWVc1blpTSXNJbTl3WlhKaGRHbHZiaUlzSW1raUxDSnNaVzVuZEdnaUxDSmhaR1JsWkNJc0luSmxiVzkyWldRaUxDSndkWE5vSWl3aWRtRnNkV1VpWFN3aWJXRndjR2x1WjNNaU9pSTdPenM3T3pzN096dEJRVUZCTzBGQlEwOHNVMEZCVTBFc2JVSkJRVlFzUTBGQk5rSkRMRTlCUVRkQ0xFVkJRWE5ETzBGQlF6TkRMRTFCUVVsRExFZEJRVWNzUjBGQlJ5eEZRVUZXTzBGQlFVRXNUVUZEU1VNc1RVRkVTanRCUVVGQkxFMUJSVWxETEZOQlJrbzdPMEZCUjBFc1QwRkJTeXhKUVVGSlF5eERRVUZETEVkQlFVY3NRMEZCWWl4RlFVRm5Ra0VzUTBGQlF5eEhRVUZIU2l4UFFVRlBMRU5CUVVOTExFMUJRVFZDTEVWQlFXOURSQ3hEUVVGRExFVkJRWEpETEVWQlFYbERPMEZCUTNaRFJpeEpRVUZCUVN4TlFVRk5MRWRCUVVkR0xFOUJRVThzUTBGQlEwa3NRMEZCUkN4RFFVRm9RanM3UVVGRFFTeFJRVUZKUml4TlFVRk5MRU5CUVVOSkxFdEJRVmdzUlVGQmEwSTdRVUZEYUVKSUxFMUJRVUZCTEZOQlFWTXNSMEZCUnl4RFFVRmFPMEZCUTBRc1MwRkdSQ3hOUVVWUExFbEJRVWxFTEUxQlFVMHNRMEZCUTBzc1QwRkJXQ3hGUVVGdlFqdEJRVU42UWtvc1RVRkJRVUVzVTBGQlV5eEhRVUZITEVOQlFVTXNRMEZCWWp0QlFVTkVMRXRCUmswc1RVRkZRVHRCUVVOTVFTeE5RVUZCUVN4VFFVRlRMRWRCUVVjc1EwRkJXanRCUVVORU96dEJRVVZFUml4SlFVRkJRU3hIUVVGSExFTkJRVU5QTEVsQlFVb3NRMEZCVXl4RFFVRkRUQ3hUUVVGRUxFVkJRVmxFTEUxQlFVMHNRMEZCUTA4c1MwRkJia0lzUTBGQlZEdEJRVU5FT3p0QlFVTkVMRk5CUVU5U0xFZEJRVkE3UVVGRFJDSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJaTh2SUZObFpUb2dhSFIwY0RvdkwyTnZaR1V1WjI5dloyeGxMbU52YlM5d0wyZHZiMmRzWlMxa2FXWm1MVzFoZEdOb0xYQmhkR05vTDNkcGEya3ZRVkJKWEc1bGVIQnZjblFnWm5WdVkzUnBiMjRnWTI5dWRtVnlkRU5vWVc1blpYTlViMFJOVUNoamFHRnVaMlZ6S1NCN1hHNGdJR3hsZENCeVpYUWdQU0JiWFN4Y2JpQWdJQ0FnSUdOb1lXNW5aU3hjYmlBZ0lDQWdJRzl3WlhKaGRHbHZianRjYmlBZ1ptOXlJQ2hzWlhRZ2FTQTlJREE3SUdrZ1BDQmphR0Z1WjJWekxteGxibWQwYURzZ2FTc3JLU0I3WEc0Z0lDQWdZMmhoYm1kbElEMGdZMmhoYm1kbGMxdHBYVHRjYmlBZ0lDQnBaaUFvWTJoaGJtZGxMbUZrWkdWa0tTQjdYRzRnSUNBZ0lDQnZjR1Z5WVhScGIyNGdQU0F4TzF4dUlDQWdJSDBnWld4elpTQnBaaUFvWTJoaGJtZGxMbkpsYlc5MlpXUXBJSHRjYmlBZ0lDQWdJRzl3WlhKaGRHbHZiaUE5SUMweE8xeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0J2Y0dWeVlYUnBiMjRnUFNBd08xeHVJQ0FnSUgxY2JseHVJQ0FnSUhKbGRDNXdkWE5vS0Z0dmNHVnlZWFJwYjI0c0lHTm9ZVzVuWlM1MllXeDFaVjBwTzF4dUlDQjlYRzRnSUhKbGRIVnliaUJ5WlhRN1hHNTlYRzRpWFgwPVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/diff/lib/convert/dmp.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/diff/lib/convert/xml.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mocha/node_modules/diff/lib/convert/xml.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/*istanbul ignore start*/\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.convertChangesToXML = convertChangesToXML;\n\n/*istanbul ignore end*/\nfunction convertChangesToXML(changes) {\n  var ret = [];\n\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n\n    if (change.added) {\n      ret.push('<ins>');\n    } else if (change.removed) {\n      ret.push('<del>');\n    }\n\n    ret.push(escapeHTML(change.value));\n\n    if (change.added) {\n      ret.push('</ins>');\n    } else if (change.removed) {\n      ret.push('</del>');\n    }\n  }\n\n  return ret.join('');\n}\n\nfunction escapeHTML(s) {\n  var n = s;\n  n = n.replace(/&/g, '&amp;');\n  n = n.replace(/</g, '&lt;');\n  n = n.replace(/>/g, '&gt;');\n  n = n.replace(/\"/g, '&quot;');\n  return n;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb252ZXJ0L3htbC5qcyJdLCJuYW1lcyI6WyJjb252ZXJ0Q2hhbmdlc1RvWE1MIiwiY2hhbmdlcyIsInJldCIsImkiLCJsZW5ndGgiLCJjaGFuZ2UiLCJhZGRlZCIsInB1c2giLCJyZW1vdmVkIiwiZXNjYXBlSFRNTCIsInZhbHVlIiwiam9pbiIsInMiLCJuIiwicmVwbGFjZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQU8sU0FBU0EsbUJBQVQsQ0FBNkJDLE9BQTdCLEVBQXNDO0FBQzNDLE1BQUlDLEdBQUcsR0FBRyxFQUFWOztBQUNBLE9BQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0YsT0FBTyxDQUFDRyxNQUE1QixFQUFvQ0QsQ0FBQyxFQUFyQyxFQUF5QztBQUN2QyxRQUFJRSxNQUFNLEdBQUdKLE9BQU8sQ0FBQ0UsQ0FBRCxDQUFwQjs7QUFDQSxRQUFJRSxNQUFNLENBQUNDLEtBQVgsRUFBa0I7QUFDaEJKLE1BQUFBLEdBQUcsQ0FBQ0ssSUFBSixDQUFTLE9BQVQ7QUFDRCxLQUZELE1BRU8sSUFBSUYsTUFBTSxDQUFDRyxPQUFYLEVBQW9CO0FBQ3pCTixNQUFBQSxHQUFHLENBQUNLLElBQUosQ0FBUyxPQUFUO0FBQ0Q7O0FBRURMLElBQUFBLEdBQUcsQ0FBQ0ssSUFBSixDQUFTRSxVQUFVLENBQUNKLE1BQU0sQ0FBQ0ssS0FBUixDQUFuQjs7QUFFQSxRQUFJTCxNQUFNLENBQUNDLEtBQVgsRUFBa0I7QUFDaEJKLE1BQUFBLEdBQUcsQ0FBQ0ssSUFBSixDQUFTLFFBQVQ7QUFDRCxLQUZELE1BRU8sSUFBSUYsTUFBTSxDQUFDRyxPQUFYLEVBQW9CO0FBQ3pCTixNQUFBQSxHQUFHLENBQUNLLElBQUosQ0FBUyxRQUFUO0FBQ0Q7QUFDRjs7QUFDRCxTQUFPTCxHQUFHLENBQUNTLElBQUosQ0FBUyxFQUFULENBQVA7QUFDRDs7QUFFRCxTQUFTRixVQUFULENBQW9CRyxDQUFwQixFQUF1QjtBQUNyQixNQUFJQyxDQUFDLEdBQUdELENBQVI7QUFDQUMsRUFBQUEsQ0FBQyxHQUFHQSxDQUFDLENBQUNDLE9BQUYsQ0FBVSxJQUFWLEVBQWdCLE9BQWhCLENBQUo7QUFDQUQsRUFBQUEsQ0FBQyxHQUFHQSxDQUFDLENBQUNDLE9BQUYsQ0FBVSxJQUFWLEVBQWdCLE1BQWhCLENBQUo7QUFDQUQsRUFBQUEsQ0FBQyxHQUFHQSxDQUFDLENBQUNDLE9BQUYsQ0FBVSxJQUFWLEVBQWdCLE1BQWhCLENBQUo7QUFDQUQsRUFBQUEsQ0FBQyxHQUFHQSxDQUFDLENBQUNDLE9BQUYsQ0FBVSxJQUFWLEVBQWdCLFFBQWhCLENBQUo7QUFFQSxTQUFPRCxDQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gY29udmVydENoYW5nZXNUb1hNTChjaGFuZ2VzKSB7XG4gIGxldCByZXQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGNoYW5nZSA9IGNoYW5nZXNbaV07XG4gICAgaWYgKGNoYW5nZS5hZGRlZCkge1xuICAgICAgcmV0LnB1c2goJzxpbnM+Jyk7XG4gICAgfSBlbHNlIGlmIChjaGFuZ2UucmVtb3ZlZCkge1xuICAgICAgcmV0LnB1c2goJzxkZWw+Jyk7XG4gICAgfVxuXG4gICAgcmV0LnB1c2goZXNjYXBlSFRNTChjaGFuZ2UudmFsdWUpKTtcblxuICAgIGlmIChjaGFuZ2UuYWRkZWQpIHtcbiAgICAgIHJldC5wdXNoKCc8L2lucz4nKTtcbiAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XG4gICAgICByZXQucHVzaCgnPC9kZWw+Jyk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUhUTUwocykge1xuICBsZXQgbiA9IHM7XG4gIG4gPSBuLnJlcGxhY2UoLyYvZywgJyZhbXA7Jyk7XG4gIG4gPSBuLnJlcGxhY2UoLzwvZywgJyZsdDsnKTtcbiAgbiA9IG4ucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICBuID0gbi5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG5cbiAgcmV0dXJuIG47XG59XG4iXX0=\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL2NvbnZlcnQveG1sLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG9CQUFvQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL2NvbnZlcnQveG1sLmpzP2I5M2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNvbnZlcnRDaGFuZ2VzVG9YTUwgPSBjb252ZXJ0Q2hhbmdlc1RvWE1MO1xuXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuZnVuY3Rpb24gY29udmVydENoYW5nZXNUb1hNTChjaGFuZ2VzKSB7XG4gIHZhciByZXQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1tpXTtcblxuICAgIGlmIChjaGFuZ2UuYWRkZWQpIHtcbiAgICAgIHJldC5wdXNoKCc8aW5zPicpO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcbiAgICAgIHJldC5wdXNoKCc8ZGVsPicpO1xuICAgIH1cblxuICAgIHJldC5wdXNoKGVzY2FwZUhUTUwoY2hhbmdlLnZhbHVlKSk7XG5cbiAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XG4gICAgICByZXQucHVzaCgnPC9pbnM+Jyk7XG4gICAgfSBlbHNlIGlmIChjaGFuZ2UucmVtb3ZlZCkge1xuICAgICAgcmV0LnB1c2goJzwvZGVsPicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUhUTUwocykge1xuICB2YXIgbiA9IHM7XG4gIG4gPSBuLnJlcGxhY2UoLyYvZywgJyZhbXA7Jyk7XG4gIG4gPSBuLnJlcGxhY2UoLzwvZywgJyZsdDsnKTtcbiAgbiA9IG4ucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICBuID0gbi5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG4gIHJldHVybiBuO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5amIyNTJaWEowTDNodGJDNXFjeUpkTENKdVlXMWxjeUk2V3lKamIyNTJaWEowUTJoaGJtZGxjMVJ2V0UxTUlpd2lZMmhoYm1kbGN5SXNJbkpsZENJc0lta2lMQ0pzWlc1bmRHZ2lMQ0pqYUdGdVoyVWlMQ0poWkdSbFpDSXNJbkIxYzJnaUxDSnlaVzF2ZG1Wa0lpd2laWE5qWVhCbFNGUk5UQ0lzSW5aaGJIVmxJaXdpYW05cGJpSXNJbk1pTENKdUlpd2ljbVZ3YkdGalpTSmRMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3TzBGQlFVOHNVMEZCVTBFc2JVSkJRVlFzUTBGQk5rSkRMRTlCUVRkQ0xFVkJRWE5ETzBGQlF6TkRMRTFCUVVsRExFZEJRVWNzUjBGQlJ5eEZRVUZXT3p0QlFVTkJMRTlCUVVzc1NVRkJTVU1zUTBGQlF5eEhRVUZITEVOQlFXSXNSVUZCWjBKQkxFTkJRVU1zUjBGQlIwWXNUMEZCVHl4RFFVRkRSeXhOUVVFMVFpeEZRVUZ2UTBRc1EwRkJReXhGUVVGeVF5eEZRVUY1UXp0QlFVTjJReXhSUVVGSlJTeE5RVUZOTEVkQlFVZEtMRTlCUVU4c1EwRkJRMFVzUTBGQlJDeERRVUZ3UWpzN1FVRkRRU3hSUVVGSlJTeE5RVUZOTEVOQlFVTkRMRXRCUVZnc1JVRkJhMEk3UVVGRGFFSktMRTFCUVVGQkxFZEJRVWNzUTBGQlEwc3NTVUZCU2l4RFFVRlRMRTlCUVZRN1FVRkRSQ3hMUVVaRUxFMUJSVThzU1VGQlNVWXNUVUZCVFN4RFFVRkRSeXhQUVVGWUxFVkJRVzlDTzBGQlEzcENUaXhOUVVGQlFTeEhRVUZITEVOQlFVTkxMRWxCUVVvc1EwRkJVeXhQUVVGVU8wRkJRMFE3TzBGQlJVUk1MRWxCUVVGQkxFZEJRVWNzUTBGQlEwc3NTVUZCU2l4RFFVRlRSU3hWUVVGVkxFTkJRVU5LTEUxQlFVMHNRMEZCUTBzc1MwRkJVaXhEUVVGdVFqczdRVUZGUVN4UlFVRkpUQ3hOUVVGTkxFTkJRVU5ETEV0QlFWZ3NSVUZCYTBJN1FVRkRhRUpLTEUxQlFVRkJMRWRCUVVjc1EwRkJRMHNzU1VGQlNpeERRVUZUTEZGQlFWUTdRVUZEUkN4TFFVWkVMRTFCUlU4c1NVRkJTVVlzVFVGQlRTeERRVUZEUnl4UFFVRllMRVZCUVc5Q08wRkJRM3BDVGl4TlFVRkJRU3hIUVVGSExFTkJRVU5MTEVsQlFVb3NRMEZCVXl4UlFVRlVPMEZCUTBRN1FVRkRSanM3UVVGRFJDeFRRVUZQVEN4SFFVRkhMRU5CUVVOVExFbEJRVW9zUTBGQlV5eEZRVUZVTEVOQlFWQTdRVUZEUkRzN1FVRkZSQ3hUUVVGVFJpeFZRVUZVTEVOQlFXOUNSeXhEUVVGd1FpeEZRVUYxUWp0QlFVTnlRaXhOUVVGSlF5eERRVUZETEVkQlFVZEVMRU5CUVZJN1FVRkRRVU1zUlVGQlFVRXNRMEZCUXl4SFFVRkhRU3hEUVVGRExFTkJRVU5ETEU5QlFVWXNRMEZCVlN4SlFVRldMRVZCUVdkQ0xFOUJRV2hDTEVOQlFVbzdRVUZEUVVRc1JVRkJRVUVzUTBGQlF5eEhRVUZIUVN4RFFVRkRMRU5CUVVORExFOUJRVVlzUTBGQlZTeEpRVUZXTEVWQlFXZENMRTFCUVdoQ0xFTkJRVW83UVVGRFFVUXNSVUZCUVVFc1EwRkJReXhIUVVGSFFTeERRVUZETEVOQlFVTkRMRTlCUVVZc1EwRkJWU3hKUVVGV0xFVkJRV2RDTEUxQlFXaENMRU5CUVVvN1FVRkRRVVFzUlVGQlFVRXNRMEZCUXl4SFFVRkhRU3hEUVVGRExFTkJRVU5ETEU5QlFVWXNRMEZCVlN4SlFVRldMRVZCUVdkQ0xGRkJRV2hDTEVOQlFVbzdRVUZGUVN4VFFVRlBSQ3hEUVVGUU8wRkJRMFFpTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKbGVIQnZjblFnWm5WdVkzUnBiMjRnWTI5dWRtVnlkRU5vWVc1blpYTlViMWhOVENoamFHRnVaMlZ6S1NCN1hHNGdJR3hsZENCeVpYUWdQU0JiWFR0Y2JpQWdabTl5SUNoc1pYUWdhU0E5SURBN0lHa2dQQ0JqYUdGdVoyVnpMbXhsYm1kMGFEc2dhU3NyS1NCN1hHNGdJQ0FnYkdWMElHTm9ZVzVuWlNBOUlHTm9ZVzVuWlhOYmFWMDdYRzRnSUNBZ2FXWWdLR05vWVc1blpTNWhaR1JsWkNrZ2UxeHVJQ0FnSUNBZ2NtVjBMbkIxYzJnb0p6eHBibk0rSnlrN1hHNGdJQ0FnZlNCbGJITmxJR2xtSUNoamFHRnVaMlV1Y21WdGIzWmxaQ2tnZTF4dUlDQWdJQ0FnY21WMExuQjFjMmdvSnp4a1pXdytKeWs3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdjbVYwTG5CMWMyZ29aWE5qWVhCbFNGUk5UQ2hqYUdGdVoyVXVkbUZzZFdVcEtUdGNibHh1SUNBZ0lHbG1JQ2hqYUdGdVoyVXVZV1JrWldRcElIdGNiaUFnSUNBZ0lISmxkQzV3ZFhOb0tDYzhMMmx1Y3o0bktUdGNiaUFnSUNCOUlHVnNjMlVnYVdZZ0tHTm9ZVzVuWlM1eVpXMXZkbVZrS1NCN1hHNGdJQ0FnSUNCeVpYUXVjSFZ6YUNnblBDOWtaV3crSnlrN1hHNGdJQ0FnZlZ4dUlDQjlYRzRnSUhKbGRIVnliaUJ5WlhRdWFtOXBiaWduSnlrN1hHNTlYRzVjYm1aMWJtTjBhVzl1SUdWelkyRndaVWhVVFV3b2N5a2dlMXh1SUNCc1pYUWdiaUE5SUhNN1hHNGdJRzRnUFNCdUxuSmxjR3hoWTJVb0x5WXZaeXdnSnlaaGJYQTdKeWs3WEc0Z0lHNGdQU0J1TG5KbGNHeGhZMlVvTHp3dlp5d2dKeVpzZERzbktUdGNiaUFnYmlBOUlHNHVjbVZ3YkdGalpTZ3ZQaTluTENBbkptZDBPeWNwTzF4dUlDQnVJRDBnYmk1eVpYQnNZV05sS0M5Y0lpOW5MQ0FuSm5GMWIzUTdKeWs3WEc1Y2JpQWdjbVYwZFhKdUlHNDdYRzU5WEc0aVhYMD1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/diff/lib/convert/xml.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/array.js":
/*!****************************************************************!*\
  !*** ./node_modules/mocha/node_modules/diff/lib/diff/array.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*istanbul ignore start*/\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.diffArrays = diffArrays;\nexports.arrayDiff = void 0;\n\n/*istanbul ignore end*/\nvar\n/*istanbul ignore start*/\n_base = _interopRequireDefault(__webpack_require__(/*! ./base */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/base.js\"))\n/*istanbul ignore end*/\n;\n\n/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/*istanbul ignore end*/\nvar arrayDiff = new\n/*istanbul ignore start*/\n_base\n/*istanbul ignore end*/\n[\n/*istanbul ignore start*/\n\"default\"\n/*istanbul ignore end*/\n]();\n\n/*istanbul ignore start*/\nexports.arrayDiff = arrayDiff;\n\n/*istanbul ignore end*/\narrayDiff.tokenize = function (value) {\n  return value.slice();\n};\n\narrayDiff.join = arrayDiff.removeEmpty = function (value) {\n  return value;\n};\n\nfunction diffArrays(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2FycmF5LmpzIl0sIm5hbWVzIjpbImFycmF5RGlmZiIsIkRpZmYiLCJ0b2tlbml6ZSIsInZhbHVlIiwic2xpY2UiLCJqb2luIiwicmVtb3ZlRW1wdHkiLCJkaWZmQXJyYXlzIiwib2xkQXJyIiwibmV3QXJyIiwiY2FsbGJhY2siLCJkaWZmIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7QUFFTyxJQUFNQSxTQUFTLEdBQUc7QUFBSUM7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUEsQ0FBSixFQUFsQjs7Ozs7O0FBQ1BELFNBQVMsQ0FBQ0UsUUFBVixHQUFxQixVQUFTQyxLQUFULEVBQWdCO0FBQ25DLFNBQU9BLEtBQUssQ0FBQ0MsS0FBTixFQUFQO0FBQ0QsQ0FGRDs7QUFHQUosU0FBUyxDQUFDSyxJQUFWLEdBQWlCTCxTQUFTLENBQUNNLFdBQVYsR0FBd0IsVUFBU0gsS0FBVCxFQUFnQjtBQUN2RCxTQUFPQSxLQUFQO0FBQ0QsQ0FGRDs7QUFJTyxTQUFTSSxVQUFULENBQW9CQyxNQUFwQixFQUE0QkMsTUFBNUIsRUFBb0NDLFFBQXBDLEVBQThDO0FBQUUsU0FBT1YsU0FBUyxDQUFDVyxJQUFWLENBQWVILE1BQWYsRUFBdUJDLE1BQXZCLEVBQStCQyxRQUEvQixDQUFQO0FBQWtEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERpZmYgZnJvbSAnLi9iYXNlJztcblxuZXhwb3J0IGNvbnN0IGFycmF5RGlmZiA9IG5ldyBEaWZmKCk7XG5hcnJheURpZmYudG9rZW5pemUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcbn07XG5hcnJheURpZmYuam9pbiA9IGFycmF5RGlmZi5yZW1vdmVFbXB0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmQXJyYXlzKG9sZEFyciwgbmV3QXJyLCBjYWxsYmFjaykgeyByZXR1cm4gYXJyYXlEaWZmLmRpZmYob2xkQXJyLCBuZXdBcnIsIGNhbGxiYWNrKTsgfVxuIl19\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL2RpZmYvYXJyYXkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7QUFDbEIsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyw2RUFBUTtBQUMvQztBQUNBOztBQUVBLGlFQUFpRSx1Q0FBdUM7O0FBRXhHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL21vY2hhL25vZGVfbW9kdWxlcy9kaWZmL2xpYi9kaWZmL2FycmF5LmpzP2U0NDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRpZmZBcnJheXMgPSBkaWZmQXJyYXlzO1xuZXhwb3J0cy5hcnJheURpZmYgPSB2b2lkIDA7XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG52YXJcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9iYXNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9iYXNlXCIpKVxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbjtcblxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbnZhciBhcnJheURpZmYgPSBuZXdcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9iYXNlXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuW1xuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXCJkZWZhdWx0XCJcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5dKCk7XG5cbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbmV4cG9ydHMuYXJyYXlEaWZmID0gYXJyYXlEaWZmO1xuXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuYXJyYXlEaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5zbGljZSgpO1xufTtcblxuYXJyYXlEaWZmLmpvaW4gPSBhcnJheURpZmYucmVtb3ZlRW1wdHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuZnVuY3Rpb24gZGlmZkFycmF5cyhvbGRBcnIsIG5ld0FyciwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGFycmF5RGlmZi5kaWZmKG9sZEFyciwgbmV3QXJyLCBjYWxsYmFjayk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTlrYVdabUwyRnljbUY1TG1weklsMHNJbTVoYldWeklqcGJJbUZ5Y21GNVJHbG1aaUlzSWtScFptWWlMQ0owYjJ0bGJtbDZaU0lzSW5aaGJIVmxJaXdpYzJ4cFkyVWlMQ0pxYjJsdUlpd2ljbVZ0YjNabFJXMXdkSGtpTENKa2FXWm1RWEp5WVhseklpd2liMnhrUVhKeUlpd2libVYzUVhKeUlpd2lZMkZzYkdKaFkyc2lMQ0prYVdabUlsMHNJbTFoY0hCcGJtZHpJam9pT3pzN096czdPenM3TzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHM3T3pzN1FVRkZUeXhKUVVGTlFTeFRRVUZUTEVkQlFVYzdRVUZCU1VNN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUVzUTBGQlNpeEZRVUZzUWpzN096czdPMEZCUTFCRUxGTkJRVk1zUTBGQlEwVXNVVUZCVml4SFFVRnhRaXhWUVVGVFF5eExRVUZVTEVWQlFXZENPMEZCUTI1RExGTkJRVTlCTEV0QlFVc3NRMEZCUTBNc1MwRkJUaXhGUVVGUU8wRkJRMFFzUTBGR1JEczdRVUZIUVVvc1UwRkJVeXhEUVVGRFN5eEpRVUZXTEVkQlFXbENUQ3hUUVVGVExFTkJRVU5OTEZkQlFWWXNSMEZCZDBJc1ZVRkJVMGdzUzBGQlZDeEZRVUZuUWp0QlFVTjJSQ3hUUVVGUFFTeExRVUZRTzBGQlEwUXNRMEZHUkRzN1FVRkpUeXhUUVVGVFNTeFZRVUZVTEVOQlFXOUNReXhOUVVGd1FpeEZRVUUwUWtNc1RVRkJOVUlzUlVGQmIwTkRMRkZCUVhCRExFVkJRVGhETzBGQlFVVXNVMEZCVDFZc1UwRkJVeXhEUVVGRFZ5eEpRVUZXTEVOQlFXVklMRTFCUVdZc1JVRkJkVUpETEUxQlFYWkNMRVZCUVN0Q1F5eFJRVUV2UWl4RFFVRlFPMEZCUVd0RUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lhVzF3YjNKMElFUnBabVlnWm5KdmJTQW5MaTlpWVhObEp6dGNibHh1Wlhod2IzSjBJR052Ym5OMElHRnljbUY1UkdsbVppQTlJRzVsZHlCRWFXWm1LQ2s3WEc1aGNuSmhlVVJwWm1ZdWRHOXJaVzVwZW1VZ1BTQm1kVzVqZEdsdmJpaDJZV3gxWlNrZ2UxeHVJQ0J5WlhSMWNtNGdkbUZzZFdVdWMyeHBZMlVvS1R0Y2JuMDdYRzVoY25KaGVVUnBabVl1YW05cGJpQTlJR0Z5Y21GNVJHbG1aaTV5WlcxdmRtVkZiWEIwZVNBOUlHWjFibU4wYVc5dUtIWmhiSFZsS1NCN1hHNGdJSEpsZEhWeWJpQjJZV3gxWlR0Y2JuMDdYRzVjYm1WNGNHOXlkQ0JtZFc1amRHbHZiaUJrYVdabVFYSnlZWGx6S0c5c1pFRnljaXdnYm1WM1FYSnlMQ0JqWVd4c1ltRmpheWtnZXlCeVpYUjFjbTRnWVhKeVlYbEVhV1ptTG1ScFptWW9iMnhrUVhKeUxDQnVaWGRCY25Jc0lHTmhiR3hpWVdOcktUc2dmVnh1SWwxOVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/array.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/base.js":
/*!***************************************************************!*\
  !*** ./node_modules/mocha/node_modules/diff/lib/diff/base.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/*istanbul ignore start*/\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = Diff;\n\n/*istanbul ignore end*/\nfunction Diff() {}\n\nDiff.prototype = {\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  diff: function diff(oldString, newString) {\n    /*istanbul ignore start*/\n    var _options$timeout;\n\n    var\n    /*istanbul ignore end*/\n    options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var callback = options.callback;\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    this.options = options;\n    var self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function () {\n          callback(undefined, value);\n        }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    } // Allow subclasses to massage the input prior to running\n\n\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n    var newLen = newString.length,\n        oldLen = oldString.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n\n    if (options.maxEditLength) {\n      maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n    }\n\n    var maxExecutionTime =\n    /*istanbul ignore start*/\n    (_options$timeout =\n    /*istanbul ignore end*/\n    options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;\n    var abortAfterTimestamp = Date.now() + maxExecutionTime;\n    var bestPath = [{\n      oldPos: -1,\n      lastComponent: undefined\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var newPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\n    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n      // Identity per the equality and tokenizer\n      return done([{\n        value: this.join(newString),\n        count: newString.length\n      }]);\n    } // Once we hit the right edge of the edit graph on some diagonal k, we can\n    // definitely reach the end of the edit graph in no more than k edits, so\n    // there's no point in considering any moves to diagonal k+1 any more (from\n    // which we're guaranteed to need at least k+1 more edits).\n    // Similarly, once we've reached the bottom of the edit graph, there's no\n    // point considering moves to lower diagonals.\n    // We record this fact by setting minDiagonalToConsider and\n    // maxDiagonalToConsider to some finite value once we've hit the edge of\n    // the edit graph.\n    // This optimization is not faithful to the original algorithm presented in\n    // Myers's paper, which instead pointlessly extends D-paths off the end of\n    // the edit graph - see page 7 of Myers's paper which notes this point\n    // explicitly and illustrates it with a diagram. This has major performance\n    // implications for some common scenarios. For instance, to compute a diff\n    // where the new text simply appends d characters on the end of the\n    // original text of length n, the true Myers algorithm will take O(n+d^2)\n    // time while this optimization needs only O(n+d) time.\n\n\n    var minDiagonalToConsider = -Infinity,\n        maxDiagonalToConsider = Infinity; // Main worker method. checks all permutations of a given edit length for acceptance.\n\n    function execEditLength() {\n      for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {\n        var basePath =\n        /*istanbul ignore start*/\n        void 0\n        /*istanbul ignore end*/\n        ;\n        var removePath = bestPath[diagonalPath - 1],\n            addPath = bestPath[diagonalPath + 1];\n\n        if (removePath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = false;\n\n        if (addPath) {\n          // what newPos will be after we do an insertion:\n          var addPathNewPos = addPath.oldPos - diagonalPath;\n          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;\n        }\n\n        var canRemove = removePath && removePath.oldPos + 1 < oldLen;\n\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the old string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        // TODO: Remove the `+ 1` here to make behavior match Myers algorithm\n        //       and prefer to order removals before insertions.\n\n\n        if (!canRemove || canAdd && removePath.oldPos + 1 < addPath.oldPos) {\n          basePath = self.addToPath(addPath, true, undefined, 0);\n        } else {\n          basePath = self.addToPath(removePath, undefined, true, 1);\n        }\n\n        newPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n\n        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n          // If we have hit the end of both strings, then we are done\n          return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));\n        } else {\n          bestPath[diagonalPath] = basePath;\n\n          if (basePath.oldPos + 1 >= oldLen) {\n            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);\n          }\n\n          if (newPos + 1 >= newLen) {\n            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);\n          }\n        }\n      }\n\n      editLength++;\n    } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced, or until the edit length exceeds options.maxEditLength (if given),\n    // in which case it will return undefined.\n\n\n    if (callback) {\n      (function exec() {\n        setTimeout(function () {\n          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      })();\n    } else {\n      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {\n        var ret = execEditLength();\n\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  addToPath: function addToPath(path, added, removed, oldPosInc) {\n    var last = path.lastComponent;\n\n    if (last && last.added === added && last.removed === removed) {\n      return {\n        oldPos: path.oldPos + oldPosInc,\n        lastComponent: {\n          count: last.count + 1,\n          added: added,\n          removed: removed,\n          previousComponent: last.previousComponent\n        }\n      };\n    } else {\n      return {\n        oldPos: path.oldPos + oldPosInc,\n        lastComponent: {\n          count: 1,\n          added: added,\n          removed: removed,\n          previousComponent: last\n        }\n      };\n    }\n  },\n\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n    var newLen = newString.length,\n        oldLen = oldString.length,\n        oldPos = basePath.oldPos,\n        newPos = oldPos - diagonalPath,\n        commonCount = 0;\n\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.lastComponent = {\n        count: commonCount,\n        previousComponent: basePath.lastComponent\n      };\n    }\n\n    basePath.oldPos = oldPos;\n    return newPos;\n  },\n\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  equals: function equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n    }\n  },\n\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  removeEmpty: function removeEmpty(array) {\n    var ret = [];\n\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n\n    return ret;\n  },\n\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  castInput: function castInput(value) {\n    return value;\n  },\n\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  tokenize: function tokenize(value) {\n    return value.split('');\n  },\n\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  join: function join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, lastComponent, newString, oldString, useLongestToken) {\n  // First we convert our linked list of components in reverse order to an\n  // array in the right order:\n  var components = [];\n  var nextComponent;\n\n  while (lastComponent) {\n    components.push(lastComponent);\n    nextComponent = lastComponent.previousComponent;\n    delete lastComponent.previousComponent;\n    lastComponent = nextComponent;\n  }\n\n  components.reverse();\n  var componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        var value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function (value, i) {\n          var oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n\n      if (componentPos && components[componentPos - 1].added) {\n        var tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  } // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n\n\n  var finalComponent = components[componentLen - 1];\n\n  if (componentLen > 1 && typeof finalComponent.value === 'string' && (finalComponent.added || finalComponent.removed) && diff.equals('', finalComponent.value)) {\n    components[componentLen - 2].value += finalComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2Jhc2UuanMiXSwibmFtZXMiOlsiRGlmZiIsInByb3RvdHlwZSIsImRpZmYiLCJvbGRTdHJpbmciLCJuZXdTdHJpbmciLCJvcHRpb25zIiwiY2FsbGJhY2siLCJzZWxmIiwiZG9uZSIsInZhbHVlIiwic2V0VGltZW91dCIsInVuZGVmaW5lZCIsImNhc3RJbnB1dCIsInJlbW92ZUVtcHR5IiwidG9rZW5pemUiLCJuZXdMZW4iLCJsZW5ndGgiLCJvbGRMZW4iLCJlZGl0TGVuZ3RoIiwibWF4RWRpdExlbmd0aCIsIk1hdGgiLCJtaW4iLCJtYXhFeGVjdXRpb25UaW1lIiwidGltZW91dCIsIkluZmluaXR5IiwiYWJvcnRBZnRlclRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJiZXN0UGF0aCIsIm9sZFBvcyIsImxhc3RDb21wb25lbnQiLCJuZXdQb3MiLCJleHRyYWN0Q29tbW9uIiwiam9pbiIsImNvdW50IiwibWluRGlhZ29uYWxUb0NvbnNpZGVyIiwibWF4RGlhZ29uYWxUb0NvbnNpZGVyIiwiZXhlY0VkaXRMZW5ndGgiLCJkaWFnb25hbFBhdGgiLCJtYXgiLCJiYXNlUGF0aCIsInJlbW92ZVBhdGgiLCJhZGRQYXRoIiwiY2FuQWRkIiwiYWRkUGF0aE5ld1BvcyIsImNhblJlbW92ZSIsImFkZFRvUGF0aCIsImJ1aWxkVmFsdWVzIiwidXNlTG9uZ2VzdFRva2VuIiwiZXhlYyIsInJldCIsInBhdGgiLCJhZGRlZCIsInJlbW92ZWQiLCJvbGRQb3NJbmMiLCJsYXN0IiwicHJldmlvdXNDb21wb25lbnQiLCJjb21tb25Db3VudCIsImVxdWFscyIsImxlZnQiLCJyaWdodCIsImNvbXBhcmF0b3IiLCJpZ25vcmVDYXNlIiwidG9Mb3dlckNhc2UiLCJhcnJheSIsImkiLCJwdXNoIiwic3BsaXQiLCJjaGFycyIsImNvbXBvbmVudHMiLCJuZXh0Q29tcG9uZW50IiwicmV2ZXJzZSIsImNvbXBvbmVudFBvcyIsImNvbXBvbmVudExlbiIsImNvbXBv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IERpZmYoKSB7fVxuXG5EaWZmLnByb3RvdHlwZSA9IHtcbiAgZGlmZihvbGRTdHJpbmcsIG5ld1N0cmluZywgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIGxldCBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGRvbmUodmFsdWUpIHtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayh1bmRlZmluZWQsIHZhbHVlKTsgfSwgMCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFsbG93IHN1YmNsYXNzZXMgdG8gbWFzc2FnZSB0aGUgaW5wdXQgcHJpb3IgdG8gcnVubmluZ1xuICAgIG9sZFN0cmluZyA9IHRoaXMuY2FzdElucHV0KG9sZFN0cmluZyk7XG4gICAgbmV3U3RyaW5nID0gdGhpcy5jYXN0SW5wdXQobmV3U3RyaW5nKTtcblxuICAgIG9sZFN0cmluZyA9IHRoaXMucmVtb3ZlRW1wdHkodGhpcy50b2tlbml6ZShvbGRTdHJpbmcpKTtcbiAgICBuZXdTdHJpbmcgPSB0aGlzLnJlbW92ZUVtcHR5KHRoaXMudG9rZW5pemUobmV3U3RyaW5nKSk7XG5cbiAgICBsZXQgbmV3TGVuID0gbmV3U3RyaW5nLmxlbmd0aCwgb2xkTGVuID0gb2xkU3RyaW5nLmxlbmd0aDtcbiAgICBsZXQgZWRpdExlbmd0aCA9IDE7XG4gICAgbGV0IG1heEVkaXRMZW5ndGggPSBuZXdMZW4gKyBvbGRMZW47XG4gICAgaWYob3B0aW9ucy5tYXhFZGl0TGVuZ3RoKSB7XG4gICAgICBtYXhFZGl0TGVuZ3RoID0gTWF0aC5taW4obWF4RWRpdExlbmd0aCwgb3B0aW9ucy5tYXhFZGl0TGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgbWF4RXhlY3V0aW9uVGltZSA9IG9wdGlvbnMudGltZW91dCA/PyBJbmZpbml0eTtcbiAgICBjb25zdCBhYm9ydEFmdGVyVGltZXN0YW1wID0gRGF0ZS5ub3coKSArIG1heEV4ZWN1dGlvblRpbWU7XG5cbiAgICBsZXQgYmVzdFBhdGggPSBbeyBvbGRQb3M6IC0xLCBsYXN0Q29tcG9uZW50OiB1bmRlZmluZWQgfV07XG5cbiAgICAvLyBTZWVkIGVkaXRMZW5ndGggPSAwLCBpLmUuIHRoZSBjb250ZW50IHN0YXJ0cyB3aXRoIHRoZSBzYW1lIHZhbHVlc1xuICAgIGxldCBuZXdQb3MgPSB0aGlzLmV4dHJhY3RDb21tb24oYmVzdFBhdGhbMF0sIG5ld1N0cmluZywgb2xkU3RyaW5nLCAwKTtcbiAgICBpZiAoYmVzdFBhdGhbMF0ub2xkUG9zICsgMSA+PSBvbGRMZW4gJiYgbmV3UG9zICsgMSA+PSBuZXdMZW4pIHtcbiAgICAgIC8vIElkZW50aXR5IHBlciB0aGUgZXF1YWxpdHkgYW5kIHRva2VuaXplclxuICAgICAgcmV0dXJuIGRvbmUoW3t2YWx1ZTogdGhpcy5qb2luKG5ld1N0cmluZyksIGNvdW50OiBuZXdTdHJpbmcubGVuZ3RofV0pO1xuICAgIH1cblxuICAgIC8vIE9uY2Ugd2UgaGl0IHRoZSByaWdodCBlZGdlIG9mIHRoZSBlZGl0IGdyYXBoIG9uIHNvbWUgZGlhZ29uYWwgaywgd2UgY2FuXG4gICAgLy8gZGVmaW5pdGVseSByZWFjaCB0aGUgZW5kIG9mIHRoZSBlZGl0IGdyYXBoIGluIG5vIG1vcmUgdGhhbiBrIGVkaXRzLCBzb1xuICAgIC8vIHRoZXJlJ3Mgbm8gcG9pbnQgaW4gY29uc2lkZXJpbmcgYW55IG1vdmVzIHRvIGRpYWdvbmFsIGsrMSBhbnkgbW9yZSAoZnJvbVxuICAgIC8vIHdoaWNoIHdlJ3JlIGd1YXJhbnRlZWQgdG8gbmVlZCBhdCBsZWFzdCBrKzEgbW9yZSBlZGl0cykuXG4gICAgLy8gU2ltaWxhcmx5LCBvbmNlIHdlJ3ZlIHJlYWNoZWQgdGhlIGJvdHRvbSBvZiB0aGUgZWRpdCBncmFwaCwgdGhlcmUncyBub1xuICAgIC8vIHBvaW50IGNvbnNpZGVyaW5nIG1vdmVzIHRvIGxvd2VyIGRpYWdvbmFscy5cbiAgICAvLyBXZSByZWNvcmQgdGhpcyBmYWN0IGJ5IHNldHRpbmcgbWluRGlhZ29uYWxUb0NvbnNpZGVyIGFuZFxuICAgIC8vIG1heERpYWdvbmFsVG9Db25zaWRlciB0byBzb21lIGZpbml0ZSB2YWx1ZSBvbmNlIHdlJ3ZlIGhpdCB0aGUgZWRnZSBvZlxuICAgIC8vIHRoZSBlZGl0IGdyYXBoLlxuICAgIC8vIFRoaXMgb3B0aW1pemF0aW9uIGlzIG5vdCBmYWl0aGZ1bCB0byB0aGUgb3JpZ2luYWwgYWxnb3JpdGhtIHByZXNlbnRlZCBpblxuICAgIC8vIE15ZXJzJ3MgcGFwZXIsIHdoaWNoIGluc3RlYWQgcG9pbnRsZXNzbHkgZXh0ZW5kcyBELXBhdGhzIG9mZiB0aGUgZW5kIG9mXG4gICAgLy8gdGhlIGVkaXQgZ3JhcGggLSBzZWUgcGFnZSA3IG9mIE15ZXJzJ3MgcGFwZXIgd2hpY2ggbm90ZXMgdGhpcyBwb2ludFxuICAgIC8vIGV4cGxpY2l0bHkgYW5kIGlsbHVzdHJhdGVzIGl0IHdpdGggYSBkaWFncmFtLiBUaGlzIGhhcyBtYWpvciBwZXJmb3JtYW5jZVxuICAgIC8vIGltcGxpY2F0aW9ucyBmb3Igc29tZSBjb21tb24gc2NlbmFyaW9zLiBGb3IgaW5zdGFuY2UsIHRvIGNvbXB1dGUgYSBkaWZmXG4gICAgLy8gd2hlcmUgdGhlIG5ldyB0ZXh0IHNpbXBseSBhcHBlbmRzIGQgY2hhcmFjdGVycyBvbiB0aGUgZW5kIG9mIHRoZVxuICAgIC8vIG9yaWdpbmFsIHRleHQgb2YgbGVuZ3RoIG4sIHRoZSB0cnVlIE15ZXJzIGFsZ29yaXRobSB3aWxsIHRha2UgTyhuK2ReMilcbiAgICAvLyB0aW1lIHdoaWxlIHRoaXMgb3B0aW1pemF0aW9uIG5lZWRzIG9ubHkgTyhuK2QpIHRpbWUuXG4gICAgbGV0IG1pbkRpYWdvbmFsVG9Db25zaWRlciA9IC1JbmZpbml0eSwgbWF4RGlhZ29uYWxUb0NvbnNpZGVyID0gSW5maW5pdHk7XG5cbiAgICAvLyBNYWluIHdvcmtlciBtZXRob2QuIGNoZWNrcyBhbGwgcGVybXV0YXRpb25zIG9mIGEgZ2l2ZW4gZWRpdCBsZW5ndGggZm9yIGFjY2VwdGFuY2UuXG4gICAgZnVuY3Rpb24gZXhlY0VkaXRMZW5ndGgoKSB7XG4gICAgICBmb3IgKFxuICAgICAgICBsZXQgZGlhZ29uYWxQYXRoID0gTWF0aC5tYXgobWluRGlhZ29uYWxUb0NvbnNpZGVyLCAtZWRpdExlbmd0aCk7XG4gICAgICAgIGRpYWdvbmFsUGF0aCA8PSBNYXRoLm1pbihtYXhEaWFnb25hbFRvQ29uc2lkZXIsIGVkaXRMZW5ndGgpO1xuICAgICAgICBkaWFnb25hbFBhdGggKz0gMlxuICAgICAgKSB7XG4gICAgICAgIGxldCBiYXNlUGF0aDtcbiAgICAgICAgbGV0IHJlbW92ZVBhdGggPSBiZXN0UGF0aFtkaWFnb25hbFBhdGggLSAxXSxcbiAgICAgICAgICAgIGFkZFBhdGggPSBiZXN0UGF0aFtkaWFnb25hbFBhdGggKyAxXTtcbiAgICAgICAgaWYgKHJlbW92ZVBhdGgpIHtcbiAgICAgICAgICAvLyBObyBvbmUgZWxzZSBpcyBnb2luZyB0byBhdHRlbXB0IHRvIHVzZSB0aGlzIHZhbHVlLCBjbGVhciBpdFxuICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aCAtIDFdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNhbkFkZCA9IGZhbHNlO1xuICAgICAgICBpZiAoYWRkUGF0aCkge1xuICAgICAgICAgIC8vIHdoYXQgbmV3UG9zIHdpbGwgYmUgYWZ0ZXIgd2UgZG8gYW4gaW5zZXJ0aW9uOlxuICAgICAgICAgIGNvbnN0IGFkZFBhdGhOZXdQb3MgPSBhZGRQYXRoLm9sZFBvcyAtIGRpYWdvbmFsUGF0aDtcbiAgICAgICAgICBjYW5BZGQgPSBhZGRQYXRoICYmIDAgPD0gYWRkUGF0aE5ld1BvcyAmJiBhZGRQYXRoTmV3UG9zIDwgbmV3TGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNhblJlbW92ZSA9IHJlbW92ZVBhdGggJiYgcmVtb3ZlUGF0aC5vbGRQb3MgKyAxIDwgb2xkTGVuO1xuICAgICAgICBpZiAoIWNhbkFkZCAmJiAhY2FuUmVtb3ZlKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBwYXRoIGlzIGEgdGVybWluYWwgdGhlbiBwcnVuZVxuICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZWxlY3QgdGhlIGRpYWdvbmFsIHRoYXQgd2Ugd2FudCB0byBicmFuY2ggZnJvbS4gV2Ugc2VsZWN0IHRoZSBwcmlvclxuICAgICAgICAvLyBwYXRoIHdob3NlIHBvc2l0aW9uIGluIHRoZSBvbGQgc3RyaW5nIGlzIHRoZSBmYXJ0aGVzdCBmcm9tIHRoZSBvcmlnaW5cbiAgICAgICAgLy8gYW5kIGRvZXMgbm90IHBhc3MgdGhlIGJvdW5kcyBvZiB0aGUgZGlmZiBncmFwaFxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgdGhlIGArIDFgIGhlcmUgdG8gbWFrZSBiZWhhdmlvciBtYXRjaCBNeWVycyBhbGdvcml0aG1cbiAgICAgICAgLy8gICAgICAgYW5kIHByZWZlciB0byBvcmRlciByZW1vdmFscyBiZWZvcmUgaW5zZXJ0aW9ucy5cbiAgICAgICAgaWYgKCFjYW5SZW1vdmUgfHwgKGNhbkFkZCAmJiByZW1vdmVQYXRoLm9sZFBvcyArIDEgPCBhZGRQYXRoLm9sZFBvcykpIHtcbiAgICAgICAgICBiYXNlUGF0aCA9IHNlbGYuYWRkVG9QYXRoKGFkZFBhdGgsIHRydWUsIHVuZGVmaW5lZCwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZVBhdGggPSBzZWxmLmFkZFRvUGF0aChyZW1vdmVQYXRoLCB1bmRlZmluZWQsIHRydWUsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3UG9zID0gc2VsZi5leHRyYWN0Q29tbW9uKGJhc2VQYXRoLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgZGlhZ29uYWxQYXRoKTtcblxuICAgICAgICBpZiAoYmFzZVBhdGgub2xkUG9zICsgMSA+PSBvbGRMZW4gJiYgbmV3UG9zICsgMSA+PSBuZXdMZW4pIHtcbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGhpdCB0aGUgZW5kIG9mIGJvdGggc3RyaW5ncywgdGhlbiB3ZSBhcmUgZG9uZVxuICAgICAgICAgIHJldHVybiBkb25lKGJ1aWxkVmFsdWVzKHNlbGYsIGJhc2VQYXRoLmxhc3RDb21wb25lbnQsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBzZWxmLnVzZUxvbmdlc3RUb2tlbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSBiYXNlUGF0aDtcbiAgICAgICAgICBpZiAoYmFzZVBhdGgub2xkUG9zICsgMSA+PSBvbGRMZW4pIHtcbiAgICAgICAgICAgIG1heERpYWdvbmFsVG9Db25zaWRlciA9IE1hdGgubWluKG1heERpYWdvbmFsVG9Db25zaWRlciwgZGlhZ29uYWxQYXRoIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXdQb3MgKyAxID49IG5ld0xlbikge1xuICAgICAgICAgICAgbWluRGlhZ29uYWxUb0NvbnNpZGVyID0gTWF0aC5tYXgobWluRGlhZ29uYWxUb0NvbnNpZGVyLCBkaWFnb25hbFBhdGggKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWRpdExlbmd0aCsrO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm1zIHRoZSBsZW5ndGggb2YgZWRpdCBpdGVyYXRpb24uIElzIGEgYml0IGZ1Z2x5IGFzIHRoaXMgaGFzIHRvIHN1cHBvcnQgdGhlXG4gICAgLy8gc3luYyBhbmQgYXN5bmMgbW9kZSB3aGljaCBpcyBuZXZlciBmdW4uIExvb3BzIG92ZXIgZXhlY0VkaXRMZW5ndGggdW50aWwgYSB2YWx1ZVxuICAgIC8vIGlzIHByb2R1Y2VkLCBvciB1bnRpbCB0aGUgZWRpdCBsZW5ndGggZXhjZWVkcyBvcHRpb25zLm1heEVkaXRMZW5ndGggKGlmIGdpdmVuKSxcbiAgICAvLyBpbiB3aGljaCBjYXNlIGl0IHdpbGwgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIChmdW5jdGlvbiBleGVjKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChlZGl0TGVuZ3RoID4gbWF4RWRpdExlbmd0aCB8fCBEYXRlLm5vdygpID4gYWJvcnRBZnRlclRpbWVzdGFtcCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFleGVjRWRpdExlbmd0aCgpKSB7XG4gICAgICAgICAgICBleGVjKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH0oKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChlZGl0TGVuZ3RoIDw9IG1heEVkaXRMZW5ndGggJiYgRGF0ZS5ub3coKSA8PSBhYm9ydEFmdGVyVGltZXN0YW1wKSB7XG4gICAgICAgIGxldCByZXQgPSBleGVjRWRpdExlbmd0aCgpO1xuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBhZGRUb1BhdGgocGF0aCwgYWRkZWQsIHJlbW92ZWQsIG9sZFBvc0luYykge1xuICAgIGxldCBsYXN0ID0gcGF0aC5sYXN0Q29tcG9uZW50O1xuICAgIGlmIChsYXN0ICYmIGxhc3QuYWRkZWQgPT09IGFkZGVkICYmIGxhc3QucmVtb3ZlZCA9PT0gcmVtb3ZlZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2xkUG9zOiBwYXRoLm9sZFBvcyArIG9sZFBvc0luYyxcbiAgICAgICAgbGFzdENvbXBvbmVudDoge2NvdW50OiBsYXN0LmNvdW50ICsgMSwgYWRkZWQ6IGFkZGVkLCByZW1vdmVkOiByZW1vdmVkLCBwcmV2aW91c0NvbXBvbmVudDogbGFzdC5wcmV2aW91c0NvbXBvbmVudCB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvbGRQb3M6IHBhdGgub2xkUG9zICsgb2xkUG9zSW5jLFxuICAgICAgICBsYXN0Q29tcG9uZW50OiB7Y291bnQ6IDEsIGFkZGVkOiBhZGRlZCwgcmVtb3ZlZDogcmVtb3ZlZCwgcHJldmlvdXNDb21wb25lbnQ6IGxhc3QgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIGV4dHJhY3RDb21tb24oYmFzZVBhdGgsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBkaWFnb25hbFBhdGgpIHtcbiAgICBsZXQgbmV3TGVuID0gbmV3U3RyaW5nLmxlbmd0aCxcbiAgICAgICAgb2xkTGVuID0gb2xkU3RyaW5nLmxlbmd0aCxcbiAgICAgICAgb2xkUG9zID0gYmFzZVBhdGgub2xkUG9zLFxuICAgICAgICBuZXdQb3MgPSBvbGRQb3MgLSBkaWFnb25hbFBhdGgsXG5cbiAgICAgICAgY29tbW9uQ291bnQgPSAwO1xuICAgIHdoaWxlIChuZXdQb3MgKyAxIDwgbmV3TGVuICYmIG9sZFBvcyArIDEgPCBvbGRMZW4gJiYgdGhpcy5lcXVhbHMobmV3U3RyaW5nW25ld1BvcyArIDFdLCBvbGRTdHJpbmdbb2xkUG9zICsgMV0pKSB7XG4gICAgICBuZXdQb3MrKztcbiAgICAgIG9sZFBvcysrO1xuICAgICAgY29tbW9uQ291bnQrKztcbiAgICB9XG5cbiAgICBpZiAoY29tbW9uQ291bnQpIHtcbiAgICAgIGJhc2VQYXRoLmxhc3RDb21wb25lbnQgPSB7Y291bnQ6IGNvbW1vbkNvdW50LCBwcmV2aW91c0NvbXBvbmVudDogYmFzZVBhdGgubGFzdENvbXBvbmVudH07XG4gICAgfVxuXG4gICAgYmFzZVBhdGgub2xkUG9zID0gb2xkUG9zO1xuICAgIHJldHVybiBuZXdQb3M7XG4gIH0sXG5cbiAgZXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNvbXBhcmF0b3IobGVmdCwgcmlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHRcbiAgICAgICAgfHwgKHRoaXMub3B0aW9ucy5pZ25vcmVDYXNlICYmIGxlZnQudG9Mb3dlckNhc2UoKSA9PT0gcmlnaHQudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICB9LFxuICByZW1vdmVFbXB0eShhcnJheSkge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyYXlbaV0pIHtcbiAgICAgICAgcmV0LnB1c2goYXJyYXlbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuICBjYXN0SW5wdXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIHRva2VuaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNwbGl0KCcnKTtcbiAgfSxcbiAgam9pbihjaGFycykge1xuICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYnVpbGRWYWx1ZXMoZGlmZiwgbGFzdENvbXBvbmVudCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIHVzZUxvbmdlc3RUb2tlbikge1xuICAvLyBGaXJzdCB3ZSBjb252ZXJ0IG91ciBsaW5rZWQgbGlzdCBvZiBjb21wb25lbnRzIGluIHJldmVyc2Ugb3JkZXIgdG8gYW5cbiAgLy8gYXJyYXkgaW4gdGhlIHJpZ2h0IG9yZGVyOlxuICBjb25zdCBjb21wb25lbnRzID0gW107XG4gIGxldCBuZXh0Q29tcG9uZW50O1xuICB3aGlsZSAobGFzdENvbXBvbmVudCkge1xuICAgIGNvbXBvbmVudHMucHVzaChsYXN0Q29tcG9uZW50KTtcbiAgICBuZXh0Q29tcG9uZW50ID0gbGFzdENvbXBvbmVudC5wcmV2aW91c0NvbXBvbmVudDtcbiAgICBkZWxldGUgbGFzdENvbXBvbmVudC5wcmV2aW91c0NvbXBvbmVudDtcbiAgICBsYXN0Q29tcG9uZW50ID0gbmV4dENvbXBvbmVudDtcbiAgfVxuICBjb21wb25lbnRzLnJldmVyc2UoKTtcblxuICBsZXQgY29tcG9uZW50UG9zID0gMCxcbiAgICAgIGNvbXBvbmVudExlbiA9IGNvbXBvbmVudHMubGVuZ3RoLFxuICAgICAgbmV3UG9zID0gMCxcbiAgICAgIG9sZFBvcyA9IDA7XG5cbiAgZm9yICg7IGNvbXBvbmVudFBvcyA8IGNvbXBvbmVudExlbjsgY29tcG9uZW50UG9zKyspIHtcbiAgICBsZXQgY29tcG9uZW50ID0gY29tcG9uZW50c1tjb21wb25lbnRQb3NdO1xuICAgIGlmICghY29tcG9uZW50LnJlbW92ZWQpIHtcbiAgICAgIGlmICghY29tcG9uZW50LmFkZGVkICYmIHVzZUxvbmdlc3RUb2tlbikge1xuICAgICAgICBsZXQgdmFsdWUgPSBuZXdTdHJpbmcuc2xpY2UobmV3UG9zLCBuZXdQb3MgKyBjb21wb25lbnQuY291bnQpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcChmdW5jdGlvbih2YWx1ZSwgaSkge1xuICAgICAgICAgIGxldCBvbGRWYWx1ZSA9IG9sZFN0cmluZ1tvbGRQb3MgKyBpXTtcbiAgICAgICAgICByZXR1cm4gb2xkVmFsdWUubGVuZ3RoID4gdmFsdWUubGVuZ3RoID8gb2xkVmFsdWUgOiB2YWx1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGRpZmYuam9pbihuZXdTdHJpbmcuc2xpY2UobmV3UG9zLCBuZXdQb3MgKyBjb21wb25lbnQuY291bnQpKTtcbiAgICAgIH1cbiAgICAgIG5ld1BvcyArPSBjb21wb25lbnQuY291bnQ7XG5cbiAgICAgIC8vIENvbW1vbiBjYXNlXG4gICAgICBpZiAoIWNvbXBvbmVudC5hZGRlZCkge1xuICAgICAgICBvbGRQb3MgKz0gY29tcG9uZW50LmNvdW50O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnQudmFsdWUgPSBkaWZmLmpvaW4ob2xkU3RyaW5nLnNsaWNlKG9sZFBvcywgb2xkUG9zICsgY29tcG9uZW50LmNvdW50KSk7XG4gICAgICBvbGRQb3MgKz0gY29tcG9uZW50LmNvdW50O1xuXG4gICAgICAvLyBSZXZlcnNlIGFkZCBhbmQgcmVtb3ZlIHNvIHJlbW92ZXMgYXJlIG91dHB1dCBmaXJzdCB0byBtYXRjaCBjb21tb24gY29udmVudGlvblxuICAgICAgLy8gVGhlIGRpZmZpbmcgYWxnb3JpdGhtIGlzIHRpZWQgdG8gYWRkIHRoZW4gcmVtb3ZlIG91dHB1dCBhbmQgdGhpcyBpcyB0aGUgc2ltcGxlc3RcbiAgICAgIC8vIHJvdXRlIHRvIGdldCB0aGUgZGVzaXJlZCBvdXRwdXQgd2l0aCBtaW5pbWFsIG92ZXJoZWFkLlxuICAgICAgaWYgKGNvbXBvbmVudFBvcyAmJiBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdLmFkZGVkKSB7XG4gICAgICAgIGxldCB0bXAgPSBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdO1xuICAgICAgICBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdID0gY29tcG9uZW50c1tjb21wb25lbnRQb3NdO1xuICAgICAgICBjb21wb25lbnRzW2NvbXBvbmVudFBvc10gPSB0bXA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU3BlY2lhbCBjYXNlIGhhbmRsZSBmb3Igd2hlbiBvbmUgdGVybWluYWwgaXMgaWdub3JlZCAoaS5lLiB3aGl0ZXNwYWNlKS5cbiAgLy8gRm9yIHRoaXMgY2FzZSB3ZSBtZXJnZSB0aGUgdGVybWluYWwgaW50byB0aGUgcHJpb3Igc3RyaW5nIGFuZCBkcm9wIHRoZSBjaGFuZ2UuXG4gIC8vIFRoaXMgaXMgb25seSBhdmFpbGFibGUgZm9yIHN0cmluZyBtb2RlLlxuICBsZXQgZmluYWxDb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudExlbiAtIDFdO1xuICBpZiAoY29tcG9uZW50TGVuID4gMVxuICAgICAgJiYgdHlwZW9mIGZpbmFsQ29tcG9uZW50LnZhbHVlID09PSAnc3RyaW5nJ1xuICAgICAgJiYgKGZpbmFsQ29tcG9uZW50LmFkZGVkIHx8IGZpbmFsQ29tcG9uZW50LnJlbW92ZWQpXG4gICAgICAmJiBkaWZmLmVxdWFscygnJywgZmluYWxDb21wb25lbnQudmFsdWUpKSB7XG4gICAgY29tcG9uZW50c1tjb21wb25lbnRMZW4gLSAyXS52YWx1ZSArPSBmaW5hbENvbXBvbmVudC52YWx1ZTtcbiAgICBjb21wb25lbnRzLnBvcCgpO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBvbmVudHM7XG59XG4iXX0=\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL2RpZmYvYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFrQjs7QUFFbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0EsNEVBQTRFLDZEQUE2RDtBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDZCQUE2QjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL21vY2hhL25vZGVfbW9kdWxlcy9kaWZmL2xpYi9kaWZmL2Jhc2UuanM/ZDdhZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gRGlmZjtcblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbmZ1bmN0aW9uIERpZmYoKSB7fVxuXG5EaWZmLnByb3RvdHlwZSA9IHtcbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXG4gIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gIGRpZmY6IGZ1bmN0aW9uIGRpZmYob2xkU3RyaW5nLCBuZXdTdHJpbmcpIHtcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgdmFyIF9vcHRpb25zJHRpbWVvdXQ7XG5cbiAgICB2YXJcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGRvbmUodmFsdWUpIHtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQsIHZhbHVlKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH0gLy8gQWxsb3cgc3ViY2xhc3NlcyB0byBtYXNzYWdlIHRoZSBpbnB1dCBwcmlvciB0byBydW5uaW5nXG5cblxuICAgIG9sZFN0cmluZyA9IHRoaXMuY2FzdElucHV0KG9sZFN0cmluZyk7XG4gICAgbmV3U3RyaW5nID0gdGhpcy5jYXN0SW5wdXQobmV3U3RyaW5nKTtcbiAgICBvbGRTdHJpbmcgPSB0aGlzLnJlbW92ZUVtcHR5KHRoaXMudG9rZW5pemUob2xkU3RyaW5nKSk7XG4gICAgbmV3U3RyaW5nID0gdGhpcy5yZW1vdmVFbXB0eSh0aGlzLnRva2VuaXplKG5ld1N0cmluZykpO1xuICAgIHZhciBuZXdMZW4gPSBuZXdTdHJpbmcubGVuZ3RoLFxuICAgICAgICBvbGRMZW4gPSBvbGRTdHJpbmcubGVuZ3RoO1xuICAgIHZhciBlZGl0TGVuZ3RoID0gMTtcbiAgICB2YXIgbWF4RWRpdExlbmd0aCA9IG5ld0xlbiArIG9sZExlbjtcblxuICAgIGlmIChvcHRpb25zLm1heEVkaXRMZW5ndGgpIHtcbiAgICAgIG1heEVkaXRMZW5ndGggPSBNYXRoLm1pbihtYXhFZGl0TGVuZ3RoLCBvcHRpb25zLm1heEVkaXRMZW5ndGgpO1xuICAgIH1cblxuICAgIHZhciBtYXhFeGVjdXRpb25UaW1lID1cbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgKF9vcHRpb25zJHRpbWVvdXQgPVxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgb3B0aW9ucy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfb3B0aW9ucyR0aW1lb3V0ICE9PSB2b2lkIDAgPyBfb3B0aW9ucyR0aW1lb3V0IDogSW5maW5pdHk7XG4gICAgdmFyIGFib3J0QWZ0ZXJUaW1lc3RhbXAgPSBEYXRlLm5vdygpICsgbWF4RXhlY3V0aW9uVGltZTtcbiAgICB2YXIgYmVzdFBhdGggPSBbe1xuICAgICAgb2xkUG9zOiAtMSxcbiAgICAgIGxhc3RDb21wb25lbnQ6IHVuZGVmaW5lZFxuICAgIH1dOyAvLyBTZWVkIGVkaXRMZW5ndGggPSAwLCBpLmUuIHRoZSBjb250ZW50IHN0YXJ0cyB3aXRoIHRoZSBzYW1lIHZhbHVlc1xuXG4gICAgdmFyIG5ld1BvcyA9IHRoaXMuZXh0cmFjdENvbW1vbihiZXN0UGF0aFswXSwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIDApO1xuXG4gICAgaWYgKGJlc3RQYXRoWzBdLm9sZFBvcyArIDEgPj0gb2xkTGVuICYmIG5ld1BvcyArIDEgPj0gbmV3TGVuKSB7XG4gICAgICAvLyBJZGVudGl0eSBwZXIgdGhlIGVxdWFsaXR5IGFuZCB0b2tlbml6ZXJcbiAgICAgIHJldHVybiBkb25lKFt7XG4gICAgICAgIHZhbHVlOiB0aGlzLmpvaW4obmV3U3RyaW5nKSxcbiAgICAgICAgY291bnQ6IG5ld1N0cmluZy5sZW5ndGhcbiAgICAgIH1dKTtcbiAgICB9IC8vIE9uY2Ugd2UgaGl0IHRoZSByaWdodCBlZGdlIG9mIHRoZSBlZGl0IGdyYXBoIG9uIHNvbWUgZGlhZ29uYWwgaywgd2UgY2FuXG4gICAgLy8gZGVmaW5pdGVseSByZWFjaCB0aGUgZW5kIG9mIHRoZSBlZGl0IGdyYXBoIGluIG5vIG1vcmUgdGhhbiBrIGVkaXRzLCBzb1xuICAgIC8vIHRoZXJlJ3Mgbm8gcG9pbnQgaW4gY29uc2lkZXJpbmcgYW55IG1vdmVzIHRvIGRpYWdvbmFsIGsrMSBhbnkgbW9yZSAoZnJvbVxuICAgIC8vIHdoaWNoIHdlJ3JlIGd1YXJhbnRlZWQgdG8gbmVlZCBhdCBsZWFzdCBrKzEgbW9yZSBlZGl0cykuXG4gICAgLy8gU2ltaWxhcmx5LCBvbmNlIHdlJ3ZlIHJlYWNoZWQgdGhlIGJvdHRvbSBvZiB0aGUgZWRpdCBncmFwaCwgdGhlcmUncyBub1xuICAgIC8vIHBvaW50IGNvbnNpZGVyaW5nIG1vdmVzIHRvIGxvd2VyIGRpYWdvbmFscy5cbiAgICAvLyBXZSByZWNvcmQgdGhpcyBmYWN0IGJ5IHNldHRpbmcgbWluRGlhZ29uYWxUb0NvbnNpZGVyIGFuZFxuICAgIC8vIG1heERpYWdvbmFsVG9Db25zaWRlciB0byBzb21lIGZpbml0ZSB2YWx1ZSBvbmNlIHdlJ3ZlIGhpdCB0aGUgZWRnZSBvZlxuICAgIC8vIHRoZSBlZGl0IGdyYXBoLlxuICAgIC8vIFRoaXMgb3B0aW1pemF0aW9uIGlzIG5vdCBmYWl0aGZ1bCB0byB0aGUgb3JpZ2luYWwgYWxnb3JpdGhtIHByZXNlbnRlZCBpblxuICAgIC8vIE15ZXJzJ3MgcGFwZXIsIHdoaWNoIGluc3RlYWQgcG9pbnRsZXNzbHkgZXh0ZW5kcyBELXBhdGhzIG9mZiB0aGUgZW5kIG9mXG4gICAgLy8gdGhlIGVkaXQgZ3JhcGggLSBzZWUgcGFnZSA3IG9mIE15ZXJzJ3MgcGFwZXIgd2hpY2ggbm90ZXMgdGhpcyBwb2ludFxuICAgIC8vIGV4cGxpY2l0bHkgYW5kIGlsbHVzdHJhdGVzIGl0IHdpdGggYSBkaWFncmFtLiBUaGlzIGhhcyBtYWpvciBwZXJmb3JtYW5jZVxuICAgIC8vIGltcGxpY2F0aW9ucyBmb3Igc29tZSBjb21tb24gc2NlbmFyaW9zLiBGb3IgaW5zdGFuY2UsIHRvIGNvbXB1dGUgYSBkaWZmXG4gICAgLy8gd2hlcmUgdGhlIG5ldyB0ZXh0IHNpbXBseSBhcHBlbmRzIGQgY2hhcmFjdGVycyBvbiB0aGUgZW5kIG9mIHRoZVxuICAgIC8vIG9yaWdpbmFsIHRleHQgb2YgbGVuZ3RoIG4sIHRoZSB0cnVlIE15ZXJzIGFsZ29yaXRobSB3aWxsIHRha2UgTyhuK2ReMilcbiAgICAvLyB0aW1lIHdoaWxlIHRoaXMgb3B0aW1pemF0aW9uIG5lZWRzIG9ubHkgTyhuK2QpIHRpbWUuXG5cblxuICAgIHZhciBtaW5EaWFnb25hbFRvQ29uc2lkZXIgPSAtSW5maW5pdHksXG4gICAgICAgIG1heERpYWdvbmFsVG9Db25zaWRlciA9IEluZmluaXR5OyAvLyBNYWluIHdvcmtlciBtZXRob2QuIGNoZWNrcyBhbGwgcGVybXV0YXRpb25zIG9mIGEgZ2l2ZW4gZWRpdCBsZW5ndGggZm9yIGFjY2VwdGFuY2UuXG5cbiAgICBmdW5jdGlvbiBleGVjRWRpdExlbmd0aCgpIHtcbiAgICAgIGZvciAodmFyIGRpYWdvbmFsUGF0aCA9IE1hdGgubWF4KG1pbkRpYWdvbmFsVG9Db25zaWRlciwgLWVkaXRMZW5ndGgpOyBkaWFnb25hbFBhdGggPD0gTWF0aC5taW4obWF4RGlhZ29uYWxUb0NvbnNpZGVyLCBlZGl0TGVuZ3RoKTsgZGlhZ29uYWxQYXRoICs9IDIpIHtcbiAgICAgICAgdmFyIGJhc2VQYXRoID1cbiAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICAgICB2b2lkIDBcbiAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAgICAgO1xuICAgICAgICB2YXIgcmVtb3ZlUGF0aCA9IGJlc3RQYXRoW2RpYWdvbmFsUGF0aCAtIDFdLFxuICAgICAgICAgICAgYWRkUGF0aCA9IGJlc3RQYXRoW2RpYWdvbmFsUGF0aCArIDFdO1xuXG4gICAgICAgIGlmIChyZW1vdmVQYXRoKSB7XG4gICAgICAgICAgLy8gTm8gb25lIGVsc2UgaXMgZ29pbmcgdG8gYXR0ZW1wdCB0byB1c2UgdGhpcyB2YWx1ZSwgY2xlYXIgaXRcbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGggLSAxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW5BZGQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoYWRkUGF0aCkge1xuICAgICAgICAgIC8vIHdoYXQgbmV3UG9zIHdpbGwgYmUgYWZ0ZXIgd2UgZG8gYW4gaW5zZXJ0aW9uOlxuICAgICAgICAgIHZhciBhZGRQYXRoTmV3UG9zID0gYWRkUGF0aC5vbGRQb3MgLSBkaWFnb25hbFBhdGg7XG4gICAgICAgICAgY2FuQWRkID0gYWRkUGF0aCAmJiAwIDw9IGFkZFBhdGhOZXdQb3MgJiYgYWRkUGF0aE5ld1BvcyA8IG5ld0xlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW5SZW1vdmUgPSByZW1vdmVQYXRoICYmIHJlbW92ZVBhdGgub2xkUG9zICsgMSA8IG9sZExlbjtcblxuICAgICAgICBpZiAoIWNhbkFkZCAmJiAhY2FuUmVtb3ZlKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBwYXRoIGlzIGEgdGVybWluYWwgdGhlbiBwcnVuZVxuICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gU2VsZWN0IHRoZSBkaWFnb25hbCB0aGF0IHdlIHdhbnQgdG8gYnJhbmNoIGZyb20uIFdlIHNlbGVjdCB0aGUgcHJpb3JcbiAgICAgICAgLy8gcGF0aCB3aG9zZSBwb3NpdGlvbiBpbiB0aGUgb2xkIHN0cmluZyBpcyB0aGUgZmFydGhlc3QgZnJvbSB0aGUgb3JpZ2luXG4gICAgICAgIC8vIGFuZCBkb2VzIG5vdCBwYXNzIHRoZSBib3VuZHMgb2YgdGhlIGRpZmYgZ3JhcGhcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoZSBgKyAxYCBoZXJlIHRvIG1ha2UgYmVoYXZpb3IgbWF0Y2ggTXllcnMgYWxnb3JpdGhtXG4gICAgICAgIC8vICAgICAgIGFuZCBwcmVmZXIgdG8gb3JkZXIgcmVtb3ZhbHMgYmVmb3JlIGluc2VydGlvbnMuXG5cblxuICAgICAgICBpZiAoIWNhblJlbW92ZSB8fCBjYW5BZGQgJiYgcmVtb3ZlUGF0aC5vbGRQb3MgKyAxIDwgYWRkUGF0aC5vbGRQb3MpIHtcbiAgICAgICAgICBiYXNlUGF0aCA9IHNlbGYuYWRkVG9QYXRoKGFkZFBhdGgsIHRydWUsIHVuZGVmaW5lZCwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZVBhdGggPSBzZWxmLmFkZFRvUGF0aChyZW1vdmVQYXRoLCB1bmRlZmluZWQsIHRydWUsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3UG9zID0gc2VsZi5leHRyYWN0Q29tbW9uKGJhc2VQYXRoLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgZGlhZ29uYWxQYXRoKTtcblxuICAgICAgICBpZiAoYmFzZVBhdGgub2xkUG9zICsgMSA+PSBvbGRMZW4gJiYgbmV3UG9zICsgMSA+PSBuZXdMZW4pIHtcbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGhpdCB0aGUgZW5kIG9mIGJvdGggc3RyaW5ncywgdGhlbiB3ZSBhcmUgZG9uZVxuICAgICAgICAgIHJldHVybiBkb25lKGJ1aWxkVmFsdWVzKHNlbGYsIGJhc2VQYXRoLmxhc3RDb21wb25lbnQsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBzZWxmLnVzZUxvbmdlc3RUb2tlbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSBiYXNlUGF0aDtcblxuICAgICAgICAgIGlmIChiYXNlUGF0aC5vbGRQb3MgKyAxID49IG9sZExlbikge1xuICAgICAgICAgICAgbWF4RGlhZ29uYWxUb0NvbnNpZGVyID0gTWF0aC5taW4obWF4RGlhZ29uYWxUb0NvbnNpZGVyLCBkaWFnb25hbFBhdGggLSAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmV3UG9zICsgMSA+PSBuZXdMZW4pIHtcbiAgICAgICAgICAgIG1pbkRpYWdvbmFsVG9Db25zaWRlciA9IE1hdGgubWF4KG1pbkRpYWdvbmFsVG9Db25zaWRlciwgZGlhZ29uYWxQYXRoICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVkaXRMZW5ndGgrKztcbiAgICB9IC8vIFBlcmZvcm1zIHRoZSBsZW5ndGggb2YgZWRpdCBpdGVyYXRpb24uIElzIGEgYml0IGZ1Z2x5IGFzIHRoaXMgaGFzIHRvIHN1cHBvcnQgdGhlXG4gICAgLy8gc3luYyBhbmQgYXN5bmMgbW9kZSB3aGljaCBpcyBuZXZlciBmdW4uIExvb3BzIG92ZXIgZXhlY0VkaXRMZW5ndGggdW50aWwgYSB2YWx1ZVxuICAgIC8vIGlzIHByb2R1Y2VkLCBvciB1bnRpbCB0aGUgZWRpdCBsZW5ndGggZXhjZWVkcyBvcHRpb25zLm1heEVkaXRMZW5ndGggKGlmIGdpdmVuKSxcbiAgICAvLyBpbiB3aGljaCBjYXNlIGl0IHdpbGwgcmV0dXJuIHVuZGVmaW5lZC5cblxuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAoZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGVkaXRMZW5ndGggPiBtYXhFZGl0TGVuZ3RoIHx8IERhdGUubm93KCkgPiBhYm9ydEFmdGVyVGltZXN0YW1wKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWV4ZWNFZGl0TGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIGV4ZWMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgfSkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKGVkaXRMZW5ndGggPD0gbWF4RWRpdExlbmd0aCAmJiBEYXRlLm5vdygpIDw9IGFib3J0QWZ0ZXJUaW1lc3RhbXApIHtcbiAgICAgICAgdmFyIHJldCA9IGV4ZWNFZGl0TGVuZ3RoKCk7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXG4gIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gIGFkZFRvUGF0aDogZnVuY3Rpb24gYWRkVG9QYXRoKHBhdGgsIGFkZGVkLCByZW1vdmVkLCBvbGRQb3NJbmMpIHtcbiAgICB2YXIgbGFzdCA9IHBhdGgubGFzdENvbXBvbmVudDtcblxuICAgIGlmIChsYXN0ICYmIGxhc3QuYWRkZWQgPT09IGFkZGVkICYmIGxhc3QucmVtb3ZlZCA9PT0gcmVtb3ZlZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2xkUG9zOiBwYXRoLm9sZFBvcyArIG9sZFBvc0luYyxcbiAgICAgICAgbGFzdENvbXBvbmVudDoge1xuICAgICAgICAgIGNvdW50OiBsYXN0LmNvdW50ICsgMSxcbiAgICAgICAgICBhZGRlZDogYWRkZWQsXG4gICAgICAgICAgcmVtb3ZlZDogcmVtb3ZlZCxcbiAgICAgICAgICBwcmV2aW91c0NvbXBvbmVudDogbGFzdC5wcmV2aW91c0NvbXBvbmVudFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvbGRQb3M6IHBhdGgub2xkUG9zICsgb2xkUG9zSW5jLFxuICAgICAgICBsYXN0Q29tcG9uZW50OiB7XG4gICAgICAgICAgY291bnQ6IDEsXG4gICAgICAgICAgYWRkZWQ6IGFkZGVkLFxuICAgICAgICAgIHJlbW92ZWQ6IHJlbW92ZWQsXG4gICAgICAgICAgcHJldmlvdXNDb21wb25lbnQ6IGxhc3RcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXG4gIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gIGV4dHJhY3RDb21tb246IGZ1bmN0aW9uIGV4dHJhY3RDb21tb24oYmFzZVBhdGgsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBkaWFnb25hbFBhdGgpIHtcbiAgICB2YXIgbmV3TGVuID0gbmV3U3RyaW5nLmxlbmd0aCxcbiAgICAgICAgb2xkTGVuID0gb2xkU3RyaW5nLmxlbmd0aCxcbiAgICAgICAgb2xkUG9zID0gYmFzZVBhdGgub2xkUG9zLFxuICAgICAgICBuZXdQb3MgPSBvbGRQb3MgLSBkaWFnb25hbFBhdGgsXG4gICAgICAgIGNvbW1vbkNvdW50ID0gMDtcblxuICAgIHdoaWxlIChuZXdQb3MgKyAxIDwgbmV3TGVuICYmIG9sZFBvcyArIDEgPCBvbGRMZW4gJiYgdGhpcy5lcXVhbHMobmV3U3RyaW5nW25ld1BvcyArIDFdLCBvbGRTdHJpbmdbb2xkUG9zICsgMV0pKSB7XG4gICAgICBuZXdQb3MrKztcbiAgICAgIG9sZFBvcysrO1xuICAgICAgY29tbW9uQ291bnQrKztcbiAgICB9XG5cbiAgICBpZiAoY29tbW9uQ291bnQpIHtcbiAgICAgIGJhc2VQYXRoLmxhc3RDb21wb25lbnQgPSB7XG4gICAgICAgIGNvdW50OiBjb21tb25Db3VudCxcbiAgICAgICAgcHJldmlvdXNDb21wb25lbnQ6IGJhc2VQYXRoLmxhc3RDb21wb25lbnRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgYmFzZVBhdGgub2xkUG9zID0gb2xkUG9zO1xuICAgIHJldHVybiBuZXdQb3M7XG4gIH0sXG5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXG4gIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNvbXBhcmF0b3IobGVmdCwgcmlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQgfHwgdGhpcy5vcHRpb25zLmlnbm9yZUNhc2UgJiYgbGVmdC50b0xvd2VyQ2FzZSgpID09PSByaWdodC50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfSxcblxuICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgcmVtb3ZlRW1wdHk6IGZ1bmN0aW9uIHJlbW92ZUVtcHR5KGFycmF5KSB7XG4gICAgdmFyIHJldCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFycmF5W2ldKSB7XG4gICAgICAgIHJldC5wdXNoKGFycmF5W2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblxuICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICBjYXN0SW5wdXQ6IGZ1bmN0aW9uIGNhc3RJbnB1dCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcblxuICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgdG9rZW5pemU6IGZ1bmN0aW9uIHRva2VuaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNwbGl0KCcnKTtcbiAgfSxcblxuICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgam9pbjogZnVuY3Rpb24gam9pbihjaGFycykge1xuICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYnVpbGRWYWx1ZXMoZGlmZiwgbGFzdENvbXBvbmVudCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIHVzZUxvbmdlc3RUb2tlbikge1xuICAvLyBGaXJzdCB3ZSBjb252ZXJ0IG91ciBsaW5rZWQgbGlzdCBvZiBjb21wb25lbnRzIGluIHJldmVyc2Ugb3JkZXIgdG8gYW5cbiAgLy8gYXJyYXkgaW4gdGhlIHJpZ2h0IG9yZGVyOlxuICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICB2YXIgbmV4dENvbXBvbmVudDtcblxuICB3aGlsZSAobGFzdENvbXBvbmVudCkge1xuICAgIGNvbXBvbmVudHMucHVzaChsYXN0Q29tcG9uZW50KTtcbiAgICBuZXh0Q29tcG9uZW50ID0gbGFzdENvbXBvbmVudC5wcmV2aW91c0NvbXBvbmVudDtcbiAgICBkZWxldGUgbGFzdENvbXBvbmVudC5wcmV2aW91c0NvbXBvbmVudDtcbiAgICBsYXN0Q29tcG9uZW50ID0gbmV4dENvbXBvbmVudDtcbiAgfVxuXG4gIGNvbXBvbmVudHMucmV2ZXJzZSgpO1xuICB2YXIgY29tcG9uZW50UG9zID0gMCxcbiAgICAgIGNvbXBvbmVudExlbiA9IGNvbXBvbmVudHMubGVuZ3RoLFxuICAgICAgbmV3UG9zID0gMCxcbiAgICAgIG9sZFBvcyA9IDA7XG5cbiAgZm9yICg7IGNvbXBvbmVudFBvcyA8IGNvbXBvbmVudExlbjsgY29tcG9uZW50UG9zKyspIHtcbiAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tjb21wb25lbnRQb3NdO1xuXG4gICAgaWYgKCFjb21wb25lbnQucmVtb3ZlZCkge1xuICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQgJiYgdXNlTG9uZ2VzdFRva2VuKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5ld1N0cmluZy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IG9sZFN0cmluZ1tvbGRQb3MgKyBpXTtcbiAgICAgICAgICByZXR1cm4gb2xkVmFsdWUubGVuZ3RoID4gdmFsdWUubGVuZ3RoID8gb2xkVmFsdWUgOiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGRpZmYuam9pbih2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb25lbnQudmFsdWUgPSBkaWZmLmpvaW4obmV3U3RyaW5nLnNsaWNlKG5ld1BvcywgbmV3UG9zICsgY29tcG9uZW50LmNvdW50KSk7XG4gICAgICB9XG5cbiAgICAgIG5ld1BvcyArPSBjb21wb25lbnQuY291bnQ7IC8vIENvbW1vbiBjYXNlXG5cbiAgICAgIGlmICghY29tcG9uZW50LmFkZGVkKSB7XG4gICAgICAgIG9sZFBvcyArPSBjb21wb25lbnQuY291bnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGRpZmYuam9pbihvbGRTdHJpbmcuc2xpY2Uob2xkUG9zLCBvbGRQb3MgKyBjb21wb25lbnQuY291bnQpKTtcbiAgICAgIG9sZFBvcyArPSBjb21wb25lbnQuY291bnQ7IC8vIFJldmVyc2UgYWRkIGFuZCByZW1vdmUgc28gcmVtb3ZlcyBhcmUgb3V0cHV0IGZpcnN0IHRvIG1hdGNoIGNvbW1vbiBjb252ZW50aW9uXG4gICAgICAvLyBUaGUgZGlmZmluZyBhbGdvcml0aG0gaXMgdGllZCB0byBhZGQgdGhlbiByZW1vdmUgb3V0cHV0IGFuZCB0aGlzIGlzIHRoZSBzaW1wbGVzdFxuICAgICAgLy8gcm91dGUgdG8gZ2V0IHRoZSBkZXNpcmVkIG91dHB1dCB3aXRoIG1pbmltYWwgb3ZlcmhlYWQuXG5cbiAgICAgIGlmIChjb21wb25lbnRQb3MgJiYgY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXS5hZGRlZCkge1xuICAgICAgICB2YXIgdG1wID0gY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXTtcbiAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXSA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zXTtcbiAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnRQb3NdID0gdG1wO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBTcGVjaWFsIGNhc2UgaGFuZGxlIGZvciB3aGVuIG9uZSB0ZXJtaW5hbCBpcyBpZ25vcmVkIChpLmUuIHdoaXRlc3BhY2UpLlxuICAvLyBGb3IgdGhpcyBjYXNlIHdlIG1lcmdlIHRoZSB0ZXJtaW5hbCBpbnRvIHRoZSBwcmlvciBzdHJpbmcgYW5kIGRyb3AgdGhlIGNoYW5nZS5cbiAgLy8gVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBmb3Igc3RyaW5nIG1vZGUuXG5cblxuICB2YXIgZmluYWxDb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudExlbiAtIDFdO1xuXG4gIGlmIChjb21wb25lbnRMZW4gPiAxICYmIHR5cGVvZiBmaW5hbENvbXBvbmVudC52YWx1ZSA9PT0gJ3N0cmluZycgJiYgKGZpbmFsQ29tcG9uZW50LmFkZGVkIHx8IGZpbmFsQ29tcG9uZW50LnJlbW92ZWQpICYmIGRpZmYuZXF1YWxzKCcnLCBmaW5hbENvbXBvbmVudC52YWx1ZSkpIHtcbiAgICBjb21wb25lbnRzW2NvbXBvbmVudExlbiAtIDJdLnZhbHVlICs9IGZpbmFsQ29tcG9uZW50LnZhbHVlO1xuICAgIGNvbXBvbmVudHMucG9wKCk7XG4gIH1cblxuICByZXR1cm4gY29tcG9uZW50cztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWthV1ptTDJKaGMyVXVhbk1pWFN3aWJtRnRaWE1pT2xzaVJHbG1aaUlzSW5CeWIzUnZkSGx3WlNJc0ltUnBabVlpTENKdmJHUlRkSEpwYm1jaUxDSnVaWGRUZEhKcGJtY2lMQ0p2Y0hScGIyNXpJaXdpWTJGc2JHSmhZMnNpTENKelpXeG1JaXdpWkc5dVpTSXNJblpoYkhWbElpd2ljMlYwVkdsdFpXOTFkQ0lzSW5WdVpHVm1hVzVsWkNJc0ltTmhjM1JKYm5CMWRDSXNJbkpsYlc5MlpVVnRjSFI1SWl3aWRHOXJaVzVwZW1VaUxDSnVaWGRNWlc0aUxDSnNaVzVuZEdnaUxDSnZiR1JNWlc0aUxDSmxaR2wwVEdWdVozUm9JaXdpYldGNFJXUnBkRXhsYm1kMGFDSXNJazFoZEdnaUxDSnRhVzRpTENKdFlYaEZlR1ZqZFhScGIyNVVhVzFsSWl3aWRHbHRaVzkxZENJc0lrbHVabWx1YVhSNUlpd2lZV0p2Y25SQlpuUmxjbFJwYldWemRHRnRjQ0lzSWtSaGRHVWlMQ0p1YjNjaUxDSmlaWE4wVUdGMGFDSXNJbTlzWkZCdmN5SXNJbXhoYzNSRGIyMXdiMjVsYm5RaUxDSnVaWGRRYjNNaUxDSmxlSFJ5WVdOMFEyOXRiVzl1SWl3aWFtOXBiaUlzSW1OdmRXNTBJaXdpYldsdVJHbGhaMjl1WVd4VWIwTnZibk5wWkdWeUlpd2liV0Y0UkdsaFoyOXVZV3hVYjBOdmJuTnBaR1Z5SWl3aVpYaGxZMFZrYVhSTVpXNW5kR2dpTENKa2FXRm5iMjVoYkZCaGRHZ2lMQ0p0WVhnaUxDSmlZWE5sVUdGMGFDSXNJbkpsYlc5MlpWQmhkR2dpTENKaFpHUlFZWFJvSWl3aVkyRnVRV1JrSWl3aVlXUmtVR0YwYUU1bGQxQnZjeUlzSW1OaGJsSmxiVzkyWlNJc0ltRmtaRlJ2VUdGMGFDSXNJbUoxYVd4a1ZtRnNkV1Z6SWl3aWRYTmxURzl1WjJWemRGUnZhMlZ1SWl3aVpYaGxZeUlzSW5KbGRDSXNJbkJoZEdnaUxDSmhaR1JsWkNJc0luSmxiVzkyWldRaUxDSnZiR1JRYjNOSmJtTWlMQ0pzWVhOMElpd2ljSEpsZG1sdmRYTkRiMjF3YjI1bGJuUWlMQ0pqYjIxdGIyNURiM1Z1ZENJc0ltVnhkV0ZzY3lJc0lteGxablFpTENKeWFXZG9kQ0lzSW1OdmJYQmhjbUYwYjNJaUxDSnBaMjV2Y21WRFlYTmxJaXdpZEc5TWIzZGxja05oYzJVaUxDSmhjbkpoZVNJc0lta2lMQ0p3ZFhOb0lpd2ljM0JzYVhRaUxDSmphR0Z5Y3lJc0ltTnZiWEJ2Ym1WdWRITWlMQ0p1WlhoMFEyOXRjRzl1Wlc1MElpd2ljbVYyWlhKelpTSXNJbU52YlhCdmJtVnVkRkJ2Y3lJc0ltTnZiWEJ2Ym1WdWRFeGxiaUlzSW1OdmJYQnZibVZ1ZENJc0luTnNhV05sSWl3aWJXRndJaXdpYjJ4a1ZtRnNkV1VpTENKMGJYQWlMQ0ptYVc1aGJFTnZiWEJ2Ym1WdWRDSXNJbkJ2Y0NKZExDSnRZWEJ3YVc1bmN5STZJanM3T3pzN096czdPMEZCUVdVc1UwRkJVMEVzU1VGQlZDeEhRVUZuUWl4RFFVRkZPenRCUVVWcVEwRXNTVUZCU1N4RFFVRkRReXhUUVVGTUxFZEJRV2xDTzBGQlFVRTdPMEZCUVVFN1FVRkRaa01zUlVGQlFVRXNTVUZFWlN4blFrRkRWa01zVTBGRVZTeEZRVU5EUXl4VFFVUkVMRVZCUXpCQ08wRkJRVUU3UVVGQlFUczdRVUZCUVR0QlFVRkJPMEZCUVdSRExFbEJRVUZCTEU5QlFXTXNkVVZCUVVvc1JVRkJTVHRCUVVOMlF5eFJRVUZKUXl4UlFVRlJMRWRCUVVkRUxFOUJRVThzUTBGQlEwTXNVVUZCZGtJN08wRkJRMEVzVVVGQlNTeFBRVUZQUkN4UFFVRlFMRXRCUVcxQ0xGVkJRWFpDTEVWQlFXMURPMEZCUTJwRFF5eE5RVUZCUVN4UlFVRlJMRWRCUVVkRUxFOUJRVmc3UVVGRFFVRXNUVUZCUVVFc1QwRkJUeXhIUVVGSExFVkJRVlk3UVVGRFJEczdRVUZEUkN4VFFVRkxRU3hQUVVGTUxFZEJRV1ZCTEU5QlFXWTdRVUZGUVN4UlFVRkpSU3hKUVVGSkxFZEJRVWNzU1VGQldEczdRVUZGUVN4aFFVRlRReXhKUVVGVUxFTkJRV05ETEV0QlFXUXNSVUZCY1VJN1FVRkRia0lzVlVGQlNVZ3NVVUZCU2l4RlFVRmpPMEZCUTFwSkxGRkJRVUZCTEZWQlFWVXNRMEZCUXl4WlFVRlhPMEZCUVVWS0xGVkJRVUZCTEZGQlFWRXNRMEZCUTBzc1UwRkJSQ3hGUVVGWlJpeExRVUZhTEVOQlFWSTdRVUZCTmtJc1UwRkJNME1zUlVGQk5rTXNRMEZCTjBNc1EwRkJWanRCUVVOQkxHVkJRVThzU1VGQlVEdEJRVU5FTEU5QlNFUXNUVUZIVHp0QlFVTk1MR1ZCUVU5QkxFdEJRVkE3UVVGRFJEdEJRVU5HTEV0QmFrSnpReXhEUVcxQ2RrTTdPenRCUVVOQlRpeEpRVUZCUVN4VFFVRlRMRWRCUVVjc1MwRkJTMU1zVTBGQlRDeERRVUZsVkN4VFFVRm1MRU5CUVZvN1FVRkRRVU1zU1VGQlFVRXNVMEZCVXl4SFFVRkhMRXRCUVV0UkxGTkJRVXdzUTBGQlpWSXNVMEZCWml4RFFVRmFPMEZCUlVGRUxFbEJRVUZCTEZOQlFWTXNSMEZCUnl4TFFVRkxWU3hYUVVGTUxFTkJRV2xDTEV0QlFVdERMRkZCUVV3c1EwRkJZMWdzVTBGQlpDeERRVUZxUWl4RFFVRmFPMEZCUTBGRExFbEJRVUZCTEZOQlFWTXNSMEZCUnl4TFFVRkxVeXhYUVVGTUxFTkJRV2xDTEV0QlFVdERMRkZCUVV3c1EwRkJZMVlzVTBGQlpDeERRVUZxUWl4RFFVRmFPMEZCUlVFc1VVRkJTVmNzVFVGQlRTeEhRVUZIV0N4VFFVRlRMRU5CUVVOWkxFMUJRWFpDTzBGQlFVRXNVVUZCSzBKRExFMUJRVTBzUjBGQlIyUXNVMEZCVXl4RFFVRkRZU3hOUVVGc1JEdEJRVU5CTEZGQlFVbEZMRlZCUVZVc1IwRkJSeXhEUVVGcVFqdEJRVU5CTEZGQlFVbERMR0ZCUVdFc1IwRkJSMG9zVFVGQlRTeEhRVUZIUlN4TlFVRTNRanM3UVVGRFFTeFJRVUZIV2l4UFFVRlBMRU5CUVVOakxHRkJRVmdzUlVGQk1FSTdRVUZEZUVKQkxFMUJRVUZCTEdGQlFXRXNSMEZCUjBNc1NVRkJTU3hEUVVGRFF5eEhRVUZNTEVOQlFWTkdMR0ZCUVZRc1JVRkJkMEprTEU5QlFVOHNRMEZCUTJNc1lVRkJhRU1zUTBGQmFFSTdRVUZEUkRzN1FVRkRSQ3hSUVVGTlJ5eG5Ra0ZCWjBJN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlIycENMRWxCUVVGQkxFOUJRVThzUTBGQlEydENMRTlCUVZnc0swUkJRWE5DUXl4UlFVRTFRenRCUVVOQkxGRkJRVTFETEcxQ1FVRnRRaXhIUVVGSFF5eEpRVUZKTEVOQlFVTkRMRWRCUVV3c1MwRkJZVXdzWjBKQlFYcERPMEZCUlVFc1VVRkJTVTBzVVVGQlVTeEhRVUZITEVOQlFVTTdRVUZCUlVNc1RVRkJRVUVzVFVGQlRTeEZRVUZGTEVOQlFVTXNRMEZCV0R0QlFVRmpReXhOUVVGQlFTeGhRVUZoTEVWQlFVVnVRanRCUVVFM1FpeExRVUZFTEVOQlFXWXNRMEZ1UTNWRExFTkJjVU4yUXpzN1FVRkRRU3hSUVVGSmIwSXNUVUZCVFN4SFFVRkhMRXRCUVV0RExHRkJRVXdzUTBGQmJVSktMRkZCUVZFc1EwRkJReXhEUVVGRUxFTkJRVE5DTEVWQlFXZERlRUlzVTBGQmFFTXNSVUZCTWtORUxGTkJRVE5ETEVWQlFYTkVMRU5CUVhSRUxFTkJRV0k3TzBGQlEwRXNVVUZCU1hsQ0xGRkJRVkVzUTBGQlF5eERRVUZFTEVOQlFWSXNRMEZCV1VNc1RVRkJXaXhIUVVGeFFpeERRVUZ5UWl4SlFVRXdRbG9zVFVGQk1VSXNTVUZCYjBOakxFMUJRVTBzUjBGQlJ5eERRVUZVTEVsQlFXTm9RaXhOUVVGMFJDeEZRVUU0UkR0QlFVTTFSRHRCUVVOQkxHRkJRVTlRTEVsQlFVa3NRMEZCUXl4RFFVRkRPMEZCUVVORExGRkJRVUZCTEV0QlFVc3NSVUZCUlN4TFFVRkxkMElzU1VGQlRDeERRVUZWTjBJc1UwRkJWaXhEUVVGU08wRkJRVGhDT0VJc1VVRkJRVUVzUzBGQlN5eEZRVUZGT1VJc1UwRkJVeXhEUVVGRFdUdEJRVUV2UXl4UFFVRkVMRU5CUVVRc1EwRkJXRHRCUVVORUxFdEJNVU56UXl4RFFUUkRka003UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3TzBGQlEwRXNVVUZCU1cxQ0xIRkNRVUZ4UWl4SFFVRkhMRU5CUVVOWUxGRkJRVGRDTzBGQlFVRXNVVUZCZFVOWkxIRkNRVUZ4UWl4SFFVRkhXaXhSUVVFdlJDeERRVGRFZFVNc1EwRXJSSFpET3p0QlFVTkJMR0ZCUVZOaExHTkJRVlFzUjBGQk1FSTdRVUZEZUVJc1YwRkRSU3hKUVVGSlF5eFpRVUZaTEVkQlFVZHNRaXhKUVVGSkxFTkJRVU50UWl4SFFVRk1MRU5CUVZOS0xIRkNRVUZVTEVWQlFXZERMRU5CUVVOcVFpeFZRVUZxUXl4RFFVUnlRaXhGUVVWRmIwSXNXVUZCV1N4SlFVRkpiRUlzU1VGQlNTeERRVUZEUXl4SFFVRk1MRU5CUVZObExIRkNRVUZVTEVWQlFXZERiRUlzVlVGQmFFTXNRMEZHYkVJc1JVRkhSVzlDTEZsQlFWa3NTVUZCU1N4RFFVaHNRaXhGUVVsRk8wRkJRMEVzV1VGQlNVVXNVVUZCVVR0QlFVRkJPMEZCUVVFN1FVRkJXanRCUVVGQk8wRkJRMEVzV1VGQlNVTXNWVUZCVlN4SFFVRkhZaXhSUVVGUkxFTkJRVU5WTEZsQlFWa3NSMEZCUnl4RFFVRm9RaXhEUVVGNlFqdEJRVUZCTEZsQlEwbEpMRTlCUVU4c1IwRkJSMlFzVVVGQlVTeERRVUZEVlN4WlFVRlpMRWRCUVVjc1EwRkJhRUlzUTBGRWRFSTdPMEZCUlVFc1dVRkJTVWNzVlVGQlNpeEZRVUZuUWp0QlFVTmtPMEZCUTBGaUxGVkJRVUZCTEZGQlFWRXNRMEZCUTFVc1dVRkJXU3hIUVVGSExFTkJRV2hDTEVOQlFWSXNSMEZCTmtJelFpeFRRVUUzUWp0QlFVTkVPenRCUVVWRUxGbEJRVWxuUXl4TlFVRk5MRWRCUVVjc1MwRkJZanM3UVVGRFFTeFpRVUZKUkN4UFFVRktMRVZCUVdFN1FVRkRXRHRCUVVOQkxHTkJRVTFGTEdGQlFXRXNSMEZCUjBZc1QwRkJUeXhEUVVGRFlpeE5RVUZTTEVkQlFXbENVeXhaUVVGMlF6dEJRVU5CU3l4VlFVRkJRU3hOUVVGTkxFZEJRVWRFTEU5QlFVOHNTVUZCU1N4TFFVRkxSU3hoUVVGb1FpeEpRVUZwUTBFc1lVRkJZU3hIUVVGSE4wSXNUVUZCTVVRN1FVRkRSRHM3UVVGRlJDeFpRVUZKT0VJc1UwRkJVeXhIUVVGSFNpeFZRVUZWTEVsQlFVbEJMRlZCUVZVc1EwRkJRMW9zVFVGQldDeEhRVUZ2UWl4RFFVRndRaXhIUVVGM1Fsb3NUVUZCZEVRN08wRkJRMEVzV1VGQlNTeERRVUZETUVJc1RVRkJSQ3hKUVVGWExFTkJRVU5GTEZOQlFXaENMRVZCUVRKQ08wRkJRM3BDTzBGQlEwRnFRaXhWUVVGQlFTeFJRVUZSTEVOQlFVTlZMRmxCUVVRc1EwRkJVaXhIUVVGNVFqTkNMRk5CUVhwQ08wRkJRMEU3UVVGRFJDeFRRWEpDUkN4RFFYVkNRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3pzN1FVRkRRU3haUVVGSkxFTkJRVU5yUXl4VFFVRkVMRWxCUVdWR0xFMUJRVTBzU1VGQlNVWXNWVUZCVlN4RFFVRkRXaXhOUVVGWUxFZEJRVzlDTEVOQlFYQkNMRWRCUVhkQ1lTeFBRVUZQTEVOQlFVTmlMRTFCUVRkRUxFVkJRWE5GTzBGQlEzQkZWeXhWUVVGQlFTeFJRVUZSTEVkQlFVZHFReXhKUVVGSkxFTkJRVU4xUXl4VFFVRk1MRU5CUVdWS0xFOUJRV1lzUlVGQmQwSXNTVUZCZUVJc1JVRkJPRUl2UWl4VFFVRTVRaXhGUVVGNVF5eERRVUY2UXl4RFFVRllPMEZCUTBRc1UwRkdSQ3hOUVVWUE8wRkJRMHcyUWl4VlFVRkJRU3hSUVVGUkxFZEJRVWRxUXl4SlFVRkpMRU5CUVVOMVF5eFRRVUZNTEVOQlFXVk1MRlZCUVdZc1JVRkJNa0k1UWl4VFFVRXpRaXhGUVVGelF5eEpRVUYwUXl4RlFVRTBReXhEUVVFMVF5eERRVUZZTzBGQlEwUTdPMEZCUlVSdlFpeFJRVUZCUVN4TlFVRk5MRWRCUVVkNFFpeEpRVUZKTEVOQlFVTjVRaXhoUVVGTUxFTkJRVzFDVVN4UlFVRnVRaXhGUVVFMlFuQkRMRk5CUVRkQ0xFVkJRWGREUkN4VFFVRjRReXhGUVVGdFJHMURMRmxCUVc1RUxFTkJRVlE3TzBGQlJVRXNXVUZCU1VVc1VVRkJVU3hEUVVGRFdDeE5RVUZVTEVkQlFXdENMRU5CUVd4Q0xFbEJRWFZDV2l4TlFVRjJRaXhKUVVGcFEyTXNUVUZCVFN4SFFVRkhMRU5CUVZRc1NVRkJZMmhDTEUxQlFXNUVMRVZCUVRKRU8wRkJRM3BFTzBGQlEwRXNhVUpCUVU5UUxFbEJRVWtzUTBGQlEzVkRMRmRCUVZjc1EwRkJRM2hETEVsQlFVUXNSVUZCVDJsRExGRkJRVkVzUTBGQlExWXNZVUZCYUVJc1JVRkJLMEl4UWl4VFFVRXZRaXhGUVVFd1EwUXNVMEZCTVVNc1JVRkJjVVJKTEVsQlFVa3NRMEZCUTNsRExHVkJRVEZFTEVOQlFWb3NRMEZCV0R0QlFVTkVMRk5CU0VRc1RVRkhUenRCUVVOTWNFSXNWVUZCUVVFc1VVRkJVU3hEUVVGRFZTeFpRVUZFTEVOQlFWSXNSMEZCZVVKRkxGRkJRWHBDT3p0QlFVTkJMR05CUVVsQkxGRkJRVkVzUTBGQlExZ3NUVUZCVkN4SFFVRnJRaXhEUVVGc1FpeEpRVUYxUWxvc1RVRkJNMElzUlVGQmJVTTdRVUZEYWtOdFFpeFpRVUZCUVN4eFFrRkJjVUlzUjBGQlIyaENMRWxCUVVrc1EwRkJRME1zUjBGQlRDeERRVUZUWlN4eFFrRkJWQ3hGUVVGblEwVXNXVUZCV1N4SFFVRkhMRU5CUVM5RExFTkJRWGhDTzBGQlEwUTdPMEZCUTBRc1kwRkJTVkFzVFVGQlRTeEhRVUZITEVOQlFWUXNTVUZCWTJoQ0xFMUJRV3hDTEVWQlFUQkNPMEZCUTNoQ2IwSXNXVUZCUVVFc2NVSkJRWEZDTEVkQlFVZG1MRWxCUVVrc1EwRkJRMjFDTEVkQlFVd3NRMEZCVTBvc2NVSkJRVlFzUlVGQlowTkhMRmxCUVZrc1IwRkJSeXhEUVVFdlF5eERRVUY0UWp0QlFVTkVPMEZCUTBZN1FVRkRSanM3UVVGRlJIQkNMRTFCUVVGQkxGVkJRVlU3UVVGRFdDeExRWGhJYzBNc1EwRXdTSFpETzBGQlEwRTdRVUZEUVR0QlFVTkJPenM3UVVGRFFTeFJRVUZKV2l4UlFVRktMRVZCUVdNN1FVRkRXQ3huUWtGQlV6SkRMRWxCUVZRc1IwRkJaMEk3UVVGRFpuWkRMRkZCUVVGQkxGVkJRVlVzUTBGQlF5eFpRVUZYTzBGQlEzQkNMR05CUVVsUkxGVkJRVlVzUjBGQlIwTXNZVUZCWWl4SlFVRTRRazhzU1VGQlNTeERRVUZEUXl4SFFVRk1MRXRCUVdGR0xHMUNRVUV2UXl4RlFVRnZSVHRCUVVOc1JTeHRRa0ZCVDI1Q0xGRkJRVkVzUlVGQlpqdEJRVU5FT3p0QlFVVkVMR05CUVVrc1EwRkJReXRDTEdOQlFXTXNSVUZCYmtJc1JVRkJkVUk3UVVGRGNrSlpMRmxCUVVGQkxFbEJRVWs3UVVGRFREdEJRVU5HTEZOQlVsTXNSVUZSVUN4RFFWSlBMRU5CUVZZN1FVRlRSQ3hQUVZaQkxFZEJRVVE3UVVGWFJDeExRVnBFTEUxQldVODdRVUZEVEN4aFFVRlBMMElzVlVGQlZTeEpRVUZKUXl4aFFVRmtMRWxCUVN0Q1R5eEpRVUZKTEVOQlFVTkRMRWRCUVV3c1RVRkJZMFlzYlVKQlFYQkVMRVZCUVhsRk8wRkJRM1pGTEZsQlFVbDVRaXhIUVVGSExFZEJRVWRpTEdOQlFXTXNSVUZCZUVJN08wRkJRMEVzV1VGQlNXRXNSMEZCU2l4RlFVRlRPMEZCUTFBc2FVSkJRVTlCTEVkQlFWQTdRVUZEUkR0QlFVTkdPMEZCUTBZN1FVRkRSaXhIUVc1S1l6czdRVUZCUVRzN1FVRkJRVHRCUVhGS1prb3NSVUZCUVVFc1UwRnlTbVVzY1VKQmNVcE1TeXhKUVhKS1N5eEZRWEZLUTBNc1MwRnlTa1FzUlVGeFNsRkRMRTlCY2twU0xFVkJjVXBwUWtNc1UwRnlTbXBDTEVWQmNVbzBRanRCUVVONlF5eFJRVUZKUXl4SlFVRkpMRWRCUVVkS0xFbEJRVWtzUTBGQlEzSkNMR0ZCUVdoQ096dEJRVU5CTEZGQlFVbDVRaXhKUVVGSkxFbEJRVWxCTEVsQlFVa3NRMEZCUTBnc1MwRkJUQ3hMUVVGbFFTeExRVUYyUWl4SlFVRm5RMGNzU1VGQlNTeERRVUZEUml4UFFVRk1MRXRCUVdsQ1FTeFBRVUZ5UkN4RlFVRTRSRHRCUVVNMVJDeGhRVUZQTzBGQlEweDRRaXhSUVVGQlFTeE5RVUZOTEVWQlFVVnpRaXhKUVVGSkxFTkJRVU4wUWl4TlFVRk1MRWRCUVdONVFpeFRRVVJxUWp0QlFVVk1lRUlzVVVGQlFVRXNZVUZCWVN4RlFVRkZPMEZCUVVOSkxGVkJRVUZCTEV0QlFVc3NSVUZCUlhGQ0xFbEJRVWtzUTBGQlEzSkNMRXRCUVV3c1IwRkJZU3hEUVVGeVFqdEJRVUYzUW10Q0xGVkJRVUZCTEV0QlFVc3NSVUZCUlVFc1MwRkJMMEk3UVVGQmMwTkRMRlZCUVVGQkxFOUJRVThzUlVGQlJVRXNUMEZCTDBNN1FVRkJkMFJITEZWQlFVRkJMR2xDUVVGcFFpeEZRVUZGUkN4SlFVRkpMRU5CUVVORE8wRkJRV2hHTzBGQlJsWXNUMEZCVUR0QlFVbEVMRXRCVEVRc1RVRkxUenRCUVVOTUxHRkJRVTg3UVVGRFRETkNMRkZCUVVGQkxFMUJRVTBzUlVGQlJYTkNMRWxCUVVrc1EwRkJRM1JDTEUxQlFVd3NSMEZCWTNsQ0xGTkJSR3BDTzBGQlJVeDRRaXhSUVVGQlFTeGhRVUZoTEVWQlFVVTdRVUZCUTBrc1ZVRkJRVUVzUzBGQlN5eEZRVUZGTEVOQlFWSTdRVUZCVjJ0Q0xGVkJRVUZCTEV0QlFVc3NSVUZCUlVFc1MwRkJiRUk3UVVGQmVVSkRMRlZCUVVGQkxFOUJRVThzUlVGQlJVRXNUMEZCYkVNN1FVRkJNa05ITEZWQlFVRkJMR2xDUVVGcFFpeEZRVUZGUkR0QlFVRTVSRHRCUVVaV0xFOUJRVkE3UVVGSlJEdEJRVU5HTEVkQmJFdGpPenRCUVVGQk96dEJRVUZCTzBGQmJVdG1ka0lzUlVGQlFVRXNZVUZ1UzJVc2VVSkJiVXRFVVN4UlFXNUxReXhGUVcxTFUzQkRMRk5CYmt0VUxFVkJiVXR2UWtRc1UwRnVTM0JDTEVWQmJVc3JRbTFETEZsQmJrc3ZRaXhGUVcxTE5rTTdRVUZETVVRc1VVRkJTWFpDTEUxQlFVMHNSMEZCUjFnc1UwRkJVeXhEUVVGRFdTeE5RVUYyUWp0QlFVRkJMRkZCUTBsRExFMUJRVTBzUjBGQlIyUXNVMEZCVXl4RFFVRkRZU3hOUVVSMlFqdEJRVUZCTEZGQlJVbGhMRTFCUVUwc1IwRkJSMWNzVVVGQlVTeERRVUZEV0N4TlFVWjBRanRCUVVGQkxGRkJSMGxGTEUxQlFVMHNSMEZCUjBZc1RVRkJUU3hIUVVGSFV5eFpRVWgwUWp0QlFVRkJMRkZCUzBsdFFpeFhRVUZYTEVkQlFVY3NRMEZNYkVJN08wRkJUVUVzVjBGQlR6RkNMRTFCUVUwc1IwRkJSeXhEUVVGVUxFZEJRV0ZvUWl4TlFVRmlMRWxCUVhWQ1l5eE5RVUZOTEVkQlFVY3NRMEZCVkN4SFFVRmhXaXhOUVVGd1F5eEpRVUU0UXl4TFFVRkxlVU1zVFVGQlRDeERRVUZaZEVRc1UwRkJVeXhEUVVGRE1rSXNUVUZCVFN4SFFVRkhMRU5CUVZZc1EwRkJja0lzUlVGQmJVTTFRaXhUUVVGVExFTkJRVU13UWl4TlFVRk5MRWRCUVVjc1EwRkJWaXhEUVVFMVF5eERRVUZ5UkN4RlFVRm5TRHRCUVVNNVIwVXNUVUZCUVVFc1RVRkJUVHRCUVVOT1JpeE5RVUZCUVN4TlFVRk5PMEZCUTA0MFFpeE5RVUZCUVN4WFFVRlhPMEZCUTFvN08wRkJSVVFzVVVGQlNVRXNWMEZCU2l4RlFVRnBRanRCUVVObWFrSXNUVUZCUVVFc1VVRkJVU3hEUVVGRFZpeGhRVUZVTEVkQlFYbENPMEZCUVVOSkxGRkJRVUZCTEV0QlFVc3NSVUZCUlhWQ0xGZEJRVkk3UVVGQmNVSkVMRkZCUVVGQkxHbENRVUZwUWl4RlFVRkZhRUlzVVVGQlVTeERRVUZEVmp0QlFVRnFSQ3hQUVVGNlFqdEJRVU5FT3p0QlFVVkVWU3hKUVVGQlFTeFJRVUZSTEVOQlFVTllMRTFCUVZRc1IwRkJhMEpCTEUxQlFXeENPMEZCUTBFc1YwRkJUMFVzVFVGQlVEdEJRVU5FTEVkQmRFeGpPenRCUVVGQk96dEJRVUZCTzBGQmQweG1Na0lzUlVGQlFVRXNUVUY0VEdVc2EwSkJkMHhTUXl4SlFYaE1VU3hGUVhkTVJrTXNTMEY0VEVVc1JVRjNURXM3UVVGRGJFSXNVVUZCU1N4TFFVRkxka1FzVDBGQlRDeERRVUZoZDBRc1ZVRkJha0lzUlVGQk5rSTdRVUZETTBJc1lVRkJUeXhMUVVGTGVFUXNUMEZCVEN4RFFVRmhkMFFzVlVGQllpeERRVUYzUWtZc1NVRkJlRUlzUlVGQk9FSkRMRXRCUVRsQ0xFTkJRVkE3UVVGRFJDeExRVVpFTEUxQlJVODdRVUZEVEN4aFFVRlBSQ3hKUVVGSkxFdEJRVXRETEV0QlFWUXNTVUZEUkN4TFFVRkxka1FzVDBGQlRDeERRVUZoZVVRc1ZVRkJZaXhKUVVFeVFrZ3NTVUZCU1N4RFFVRkRTU3hYUVVGTUxFOUJRWFZDU0N4TFFVRkxMRU5CUVVOSExGZEJRVTRzUlVGRWVFUTdRVUZGUkR0QlFVTkdMRWRCTDB4ak96dEJRVUZCT3p0QlFVRkJPMEZCWjAxbWJFUXNSVUZCUVVFc1YwRm9UV1VzZFVKQlowMUliVVFzUzBGb1RVY3NSVUZuVFVrN1FVRkRha0lzVVVGQlNXUXNSMEZCUnl4SFFVRkhMRVZCUVZZN08wRkJRMEVzVTBGQlN5eEpRVUZKWlN4RFFVRkRMRWRCUVVjc1EwRkJZaXhGUVVGblFrRXNRMEZCUXl4SFFVRkhSQ3hMUVVGTExFTkJRVU5vUkN4TlFVRXhRaXhGUVVGclEybEVMRU5CUVVNc1JVRkJia01zUlVGQmRVTTdRVUZEY2tNc1ZVRkJTVVFzUzBGQlN5eERRVUZEUXl4RFFVRkVMRU5CUVZRc1JVRkJZenRCUVVOYVppeFJRVUZCUVN4SFFVRkhMRU5CUVVOblFpeEpRVUZLTEVOQlFWTkdMRXRCUVVzc1EwRkJRME1zUTBGQlJDeERRVUZrTzBGQlEwUTdRVUZEUmpzN1FVRkRSQ3hYUVVGUFppeEhRVUZRTzBGQlEwUXNSMEY0VFdNN08wRkJRVUU3TzBGQlFVRTdRVUY1VFdaMFF5eEZRVUZCUVN4VFFYcE5aU3h4UWtGNVRVeElMRXRCZWsxTExFVkJlVTFGTzBGQlEyWXNWMEZCVDBFc1MwRkJVRHRCUVVORUxFZEJNMDFqT3p0QlFVRkJPenRCUVVGQk8wRkJORTFtU3l4RlFVRkJRU3hSUVRWTlpTeHZRa0UwVFU1TUxFdEJOVTFOTEVWQk5FMURPMEZCUTJRc1YwRkJUMEVzUzBGQlN5eERRVUZETUVRc1MwRkJUaXhEUVVGWkxFVkJRVm9zUTBGQlVEdEJRVU5FTEVkQk9VMWpPenRCUVVGQk96dEJRVUZCTzBGQkswMW1iRU1zUlVGQlFVRXNTVUV2VFdVc1owSkJLMDFXYlVNc1MwRXZUVlVzUlVFclRVZzdRVUZEVml4WFFVRlBRU3hMUVVGTExFTkJRVU51UXl4SlFVRk9MRU5CUVZjc1JVRkJXQ3hEUVVGUU8wRkJRMFE3UVVGcVRtTXNRMEZCYWtJN08wRkJiMDVCTEZOQlFWTmpMRmRCUVZRc1EwRkJjVUkzUXl4SlFVRnlRaXhGUVVFeVFqUkNMR0ZCUVROQ0xFVkJRVEJETVVJc1UwRkJNVU1zUlVGQmNVUkVMRk5CUVhKRUxFVkJRV2RGTmtNc1pVRkJhRVVzUlVGQmFVWTdRVUZETDBVN1FVRkRRVHRCUVVOQkxFMUJRVTF4UWl4VlFVRlZMRWRCUVVjc1JVRkJia0k3UVVGRFFTeE5RVUZKUXl4aFFVRktPenRCUVVOQkxGTkJRVTk0UXl4aFFVRlFMRVZCUVhOQ08wRkJRM0JDZFVNc1NVRkJRVUVzVlVGQlZTeERRVUZEU0N4SlFVRllMRU5CUVdkQ2NFTXNZVUZCYUVJN1FVRkRRWGRETEVsQlFVRkJMR0ZCUVdFc1IwRkJSM2hETEdGQlFXRXNRMEZCUXpCQ0xHbENRVUU1UWp0QlFVTkJMRmRCUVU4eFFpeGhRVUZoTEVOQlFVTXdRaXhwUWtGQmNrSTdRVUZEUVRGQ0xFbEJRVUZCTEdGQlFXRXNSMEZCUjNkRExHRkJRV2hDTzBGQlEwUTdPMEZCUTBSRUxFVkJRVUZCTEZWQlFWVXNRMEZCUTBVc1QwRkJXRHRCUVVWQkxFMUJRVWxETEZsQlFWa3NSMEZCUnl4RFFVRnVRanRCUVVGQkxFMUJRMGxETEZsQlFWa3NSMEZCUjBvc1ZVRkJWU3hEUVVGRGNrUXNUVUZFT1VJN1FVRkJRU3hOUVVWSlpTeE5RVUZOTEVkQlFVY3NRMEZHWWp0QlFVRkJMRTFCUjBsR0xFMUJRVTBzUjBGQlJ5eERRVWhpT3p0QlFVdEJMRk5CUVU4eVF5eFpRVUZaTEVkQlFVZERMRmxCUVhSQ0xFVkJRVzlEUkN4WlFVRlpMRVZCUVdoRUxFVkJRVzlFTzBGQlEyeEVMRkZCUVVsRkxGTkJRVk1zUjBGQlIwd3NWVUZCVlN4RFFVRkRSeXhaUVVGRUxFTkJRVEZDT3p0QlFVTkJMRkZCUVVrc1EwRkJRMFVzVTBGQlV5eERRVUZEY2tJc1QwRkJaaXhGUVVGM1FqdEJRVU4wUWl4VlFVRkpMRU5CUVVOeFFpeFRRVUZUTEVOQlFVTjBRaXhMUVVGWUxFbEJRVzlDU2l4bFFVRjRRaXhGUVVGNVF6dEJRVU4yUXl4WlFVRkpka01zUzBGQlN5eEhRVUZIVEN4VFFVRlRMRU5CUVVOMVJTeExRVUZXTEVOQlFXZENOVU1zVFVGQmFFSXNSVUZCZDBKQkxFMUJRVTBzUjBGQlJ6SkRMRk5CUVZNc1EwRkJRM2hETEV0QlFUTkRMRU5CUVZvN1FVRkRRWHBDTEZGQlFVRkJMRXRCUVVzc1IwRkJSMEVzUzBGQlN5eERRVUZEYlVVc1IwRkJUaXhEUVVGVkxGVkJRVk51UlN4TFFVRlVMRVZCUVdkQ2QwUXNRMEZCYUVJc1JVRkJiVUk3UVVGRGJrTXNZMEZCU1Zrc1VVRkJVU3hIUVVGSE1VVXNVMEZCVXl4RFFVRkRNRUlzVFVGQlRTeEhRVUZIYjBNc1EwRkJWaXhEUVVGNFFqdEJRVU5CTEdsQ1FVRlBXU3hSUVVGUkxFTkJRVU0zUkN4TlFVRlVMRWRCUVd0Q1VDeExRVUZMTEVOQlFVTlBMRTFCUVhoQ0xFZEJRV2xETmtRc1VVRkJha01zUjBGQk5FTndSU3hMUVVGdVJEdEJRVU5FTEZOQlNFOHNRMEZCVWp0QlFVdEJhVVVzVVVGQlFVRXNVMEZCVXl4RFFVRkRha1VzUzBGQlZpeEhRVUZyUWxBc1NVRkJTU3hEUVVGREswSXNTVUZCVEN4RFFVRlZlRUlzUzBGQlZpeERRVUZzUWp0QlFVTkVMRTlCVWtRc1RVRlJUenRCUVVOTWFVVXNVVUZCUVVFc1UwRkJVeXhEUVVGRGFrVXNTMEZCVml4SFFVRnJRbEFzU1VGQlNTeERRVUZESzBJc1NVRkJUQ3hEUVVGVk4wSXNVMEZCVXl4RFFVRkRkVVVzUzBGQlZpeERRVUZuUWpWRExFMUJRV2hDTEVWQlFYZENRU3hOUVVGTkxFZEJRVWN5UXl4VFFVRlRMRU5CUVVONFF5eExRVUV6UXl4RFFVRldMRU5CUVd4Q08wRkJRMFE3TzBGQlEwUklMRTFCUVVGQkxFMUJRVTBzU1VGQlNUSkRMRk5CUVZNc1EwRkJRM2hETEV0QlFYQkNMRU5CV25OQ0xFTkJZM1JDT3p0QlFVTkJMRlZCUVVrc1EwRkJRM2RETEZOQlFWTXNRMEZCUTNSQ0xFdEJRV1lzUlVGQmMwSTdRVUZEY0VKMlFpeFJRVUZCUVN4TlFVRk5MRWxCUVVrMlF5eFRRVUZUTEVOQlFVTjRReXhMUVVGd1FqdEJRVU5FTzBGQlEwWXNTMEZzUWtRc1RVRnJRazg3UVVGRFRIZERMRTFCUVVGQkxGTkJRVk1zUTBGQlEycEZMRXRCUVZZc1IwRkJhMEpRTEVsQlFVa3NRMEZCUXl0Q0xFbEJRVXdzUTBGQlZUbENMRk5CUVZNc1EwRkJRM2RGTEV0QlFWWXNRMEZCWjBJNVF5eE5RVUZvUWl4RlFVRjNRa0VzVFVGQlRTeEhRVUZITmtNc1UwRkJVeXhEUVVGRGVFTXNTMEZCTTBNc1EwRkJWaXhEUVVGc1FqdEJRVU5CVEN4TlFVRkJRU3hOUVVGTkxFbEJRVWsyUXl4VFFVRlRMRU5CUVVONFF5eExRVUZ3UWl4RFFVWkxMRU5CU1V3N1FVRkRRVHRCUVVOQk96dEJRVU5CTEZWQlFVbHpReXhaUVVGWkxFbEJRVWxJTEZWQlFWVXNRMEZCUTBjc1dVRkJXU3hIUVVGSExFTkJRV2hDTEVOQlFWWXNRMEZCTmtKd1FpeExRVUZxUkN4RlFVRjNSRHRCUVVOMFJDeFpRVUZKTUVJc1IwRkJSeXhIUVVGSFZDeFZRVUZWTEVOQlFVTkhMRmxCUVZrc1IwRkJSeXhEUVVGb1FpeERRVUZ3UWp0QlFVTkJTQ3hSUVVGQlFTeFZRVUZWTEVOQlFVTkhMRmxCUVZrc1IwRkJSeXhEUVVGb1FpeERRVUZXTEVkQlFTdENTQ3hWUVVGVkxFTkJRVU5ITEZsQlFVUXNRMEZCZWtNN1FVRkRRVWdzVVVGQlFVRXNWVUZCVlN4RFFVRkRSeXhaUVVGRUxFTkJRVllzUjBGQk1rSk5MRWRCUVROQ08wRkJRMFE3UVVGRFJqdEJRVU5HTEVkQmJrUTRSU3hEUVhGRUwwVTdRVUZEUVR0QlFVTkJPenM3UVVGRFFTeE5RVUZKUXl4alFVRmpMRWRCUVVkV0xGVkJRVlVzUTBGQlEwa3NXVUZCV1N4SFFVRkhMRU5CUVdoQ0xFTkJRUzlDT3p0QlFVTkJMRTFCUVVsQkxGbEJRVmtzUjBGQlJ5eERRVUZtTEVsQlEwY3NUMEZCVDAwc1kwRkJZeXhEUVVGRGRFVXNTMEZCZEVJc1MwRkJaME1zVVVGRWJrTXNTMEZGU1hORkxHTkJRV01zUTBGQlF6TkNMRXRCUVdZc1NVRkJkMEl5UWl4alFVRmpMRU5CUVVNeFFpeFBRVVl6UXl4TFFVZEhia1FzU1VGQlNTeERRVUZEZDBRc1RVRkJUQ3hEUVVGWkxFVkJRVm9zUlVGQlowSnhRaXhqUVVGakxFTkJRVU4wUlN4TFFVRXZRaXhEUVVoUUxFVkJSemhETzBGQlF6VkRORVFzU1VGQlFVRXNWVUZCVlN4RFFVRkRTU3haUVVGWkxFZEJRVWNzUTBGQmFFSXNRMEZCVml4RFFVRTJRbWhGTEV0QlFUZENMRWxCUVhORGMwVXNZMEZCWXl4RFFVRkRkRVVzUzBGQmNrUTdRVUZEUVRSRUxFbEJRVUZCTEZWQlFWVXNRMEZCUTFjc1IwRkJXRHRCUVVORU96dEJRVVZFTEZOQlFVOVlMRlZCUVZBN1FVRkRSQ0lzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSW1WNGNHOXlkQ0JrWldaaGRXeDBJR1oxYm1OMGFXOXVJRVJwWm1Zb0tTQjdmVnh1WEc1RWFXWm1MbkJ5YjNSdmRIbHdaU0E5SUh0Y2JpQWdaR2xtWmlodmJHUlRkSEpwYm1jc0lHNWxkMU4wY21sdVp5d2diM0IwYVc5dWN5QTlJSHQ5S1NCN1hHNGdJQ0FnYkdWMElHTmhiR3hpWVdOcklEMGdiM0IwYVc5dWN5NWpZV3hzWW1GamF6dGNiaUFnSUNCcFppQW9kSGx3Wlc5bUlHOXdkR2x2Ym5NZ1BUMDlJQ2RtZFc1amRHbHZiaWNwSUh0Y2JpQWdJQ0FnSUdOaGJHeGlZV05ySUQwZ2IzQjBhVzl1Y3p0Y2JpQWdJQ0FnSUc5d2RHbHZibk1nUFNCN2ZUdGNiaUFnSUNCOVhHNGdJQ0FnZEdocGN5NXZjSFJwYjI1eklEMGdiM0IwYVc5dWN6dGNibHh1SUNBZ0lHeGxkQ0J6Wld4bUlEMGdkR2hwY3p0Y2JseHVJQ0FnSUdaMWJtTjBhVzl1SUdSdmJtVW9kbUZzZFdVcElIdGNiaUFnSUNBZ0lHbG1JQ2hqWVd4c1ltRmpheWtnZTF4dUlDQWdJQ0FnSUNCelpYUlVhVzFsYjNWMEtHWjFibU4wYVc5dUtDa2dleUJqWVd4c1ltRmpheWgxYm1SbFptbHVaV1FzSUhaaGJIVmxLVHNnZlN3Z01DazdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjBjblZsTzF4dUlDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSFpoYkhWbE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JseHVJQ0FnSUM4dklFRnNiRzkzSUhOMVltTnNZWE56WlhNZ2RHOGdiV0Z6YzJGblpTQjBhR1VnYVc1d2RYUWdjSEpwYjNJZ2RHOGdjblZ1Ym1sdVoxeHVJQ0FnSUc5c1pGTjBjbWx1WnlBOUlIUm9hWE11WTJGemRFbHVjSFYwS0c5c1pGTjBjbWx1WnlrN1hHNGdJQ0FnYm1WM1UzUnlhVzVuSUQwZ2RHaHBjeTVqWVhOMFNXNXdkWFFvYm1WM1UzUnlhVzVuS1R0Y2JseHVJQ0FnSUc5c1pGTjBjbWx1WnlBOUlIUm9hWE11Y21WdGIzWmxSVzF3ZEhrb2RHaHBjeTUwYjJ0bGJtbDZaU2h2YkdSVGRISnBibWNwS1R0Y2JpQWdJQ0J1WlhkVGRISnBibWNnUFNCMGFHbHpMbkpsYlc5MlpVVnRjSFI1S0hSb2FYTXVkRzlyWlc1cGVtVW9ibVYzVTNSeWFXNW5LU2s3WEc1Y2JpQWdJQ0JzWlhRZ2JtVjNUR1Z1SUQwZ2JtVjNVM1J5YVc1bkxteGxibWQwYUN3Z2IyeGtUR1Z1SUQwZ2IyeGtVM1J5YVc1bkxteGxibWQwYUR0Y2JpQWdJQ0JzWlhRZ1pXUnBkRXhsYm1kMGFDQTlJREU3WEc0Z0lDQWdiR1YwSUcxaGVFVmthWFJNWlc1bmRHZ2dQU0J1WlhkTVpXNGdLeUJ2YkdSTVpXNDdYRzRnSUNBZ2FXWW9iM0IwYVc5dWN5NXRZWGhGWkdsMFRHVnVaM1JvS1NCN1hHNGdJQ0FnSUNCdFlYaEZaR2wwVEdWdVozUm9JRDBnVFdGMGFDNXRhVzRvYldGNFJXUnBkRXhsYm1kMGFDd2diM0IwYVc5dWN5NXRZWGhGWkdsMFRHVnVaM1JvS1R0Y2JpQWdJQ0I5WEc0Z0lDQWdZMjl1YzNRZ2JXRjRSWGhsWTNWMGFXOXVWR2x0WlNBOUlHOXdkR2x2Ym5NdWRHbHRaVzkxZENBL1B5QkpibVpwYm1sMGVUdGNiaUFnSUNCamIyNXpkQ0JoWW05eWRFRm1kR1Z5VkdsdFpYTjBZVzF3SUQwZ1JHRjBaUzV1YjNjb0tTQXJJRzFoZUVWNFpXTjFkR2x2YmxScGJXVTdYRzVjYmlBZ0lDQnNaWFFnWW1WemRGQmhkR2dnUFNCYmV5QnZiR1JRYjNNNklDMHhMQ0JzWVhOMFEyOXRjRzl1Wlc1ME9pQjFibVJsWm1sdVpXUWdmVjA3WEc1Y2JpQWdJQ0F2THlCVFpXVmtJR1ZrYVhSTVpXNW5kR2dnUFNBd0xDQnBMbVV1SUhSb1pTQmpiMjUwWlc1MElITjBZWEowY3lCM2FYUm9JSFJvWlNCellXMWxJSFpoYkhWbGMxeHVJQ0FnSUd4bGRDQnVaWGRRYjNNZ1BTQjBhR2x6TG1WNGRISmhZM1JEYjIxdGIyNG9ZbVZ6ZEZCaGRHaGJNRjBzSUc1bGQxTjBjbWx1Wnl3Z2IyeGtVM1J5YVc1bkxDQXdLVHRjYmlBZ0lDQnBaaUFvWW1WemRGQmhkR2hiTUYwdWIyeGtVRzl6SUNzZ01TQStQU0J2YkdSTVpXNGdKaVlnYm1WM1VHOXpJQ3NnTVNBK1BTQnVaWGRNWlc0cElIdGNiaUFnSUNBZ0lDOHZJRWxrWlc1MGFYUjVJSEJsY2lCMGFHVWdaWEYxWVd4cGRIa2dZVzVrSUhSdmEyVnVhWHBsY2x4dUlDQWdJQ0FnY21WMGRYSnVJR1J2Ym1Vb1czdDJZV3gxWlRvZ2RHaHBjeTVxYjJsdUtHNWxkMU4wY21sdVp5a3NJR052ZFc1ME9pQnVaWGRUZEhKcGJtY3ViR1Z1WjNSb2ZWMHBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lDOHZJRTl1WTJVZ2QyVWdhR2wwSUhSb1pTQnlhV2RvZENCbFpHZGxJRzltSUhSb1pTQmxaR2wwSUdkeVlYQm9JRzl1SUhOdmJXVWdaR2xoWjI5dVlXd2dheXdnZDJVZ1kyRnVYRzRnSUNBZ0x5OGdaR1ZtYVc1cGRHVnNlU0J5WldGamFDQjBhR1VnWlc1a0lHOW1JSFJvWlNCbFpHbDBJR2R5WVhCb0lHbHVJRzV2SUcxdmNtVWdkR2hoYmlCcklHVmthWFJ6TENCemIxeHVJQ0FnSUM4dklIUm9aWEpsSjNNZ2JtOGdjRzlwYm5RZ2FXNGdZMjl1YzJsa1pYSnBibWNnWVc1NUlHMXZkbVZ6SUhSdklHUnBZV2R2Ym1Gc0lHc3JNU0JoYm5rZ2JXOXlaU0FvWm5KdmJWeHVJQ0FnSUM4dklIZG9hV05vSUhkbEozSmxJR2QxWVhKaGJuUmxaV1FnZEc4Z2JtVmxaQ0JoZENCc1pXRnpkQ0JyS3pFZ2JXOXlaU0JsWkdsMGN5a3VYRzRnSUNBZ0x5OGdVMmx0YVd4aGNteDVMQ0J2Ym1ObElIZGxKM1psSUhKbFlXTm9aV1FnZEdobElHSnZkSFJ2YlNCdlppQjBhR1VnWldScGRDQm5jbUZ3YUN3Z2RHaGxjbVVuY3lCdWIxeHVJQ0FnSUM4dklIQnZhVzUwSUdOdmJuTnBaR1Z5YVc1bklHMXZkbVZ6SUhSdklHeHZkMlZ5SUdScFlXZHZibUZzY3k1Y2JpQWdJQ0F2THlCWFpTQnlaV052Y21RZ2RHaHBjeUJtWVdOMElHSjVJSE5sZEhScGJtY2diV2x1UkdsaFoyOXVZV3hVYjBOdmJuTnBaR1Z5SUdGdVpGeHVJQ0FnSUM4dklHMWhlRVJwWVdkdmJtRnNWRzlEYjI1emFXUmxjaUIwYnlCemIyMWxJR1pwYm1sMFpTQjJZV3gxWlNCdmJtTmxJSGRsSjNabElHaHBkQ0IwYUdVZ1pXUm5aU0J2Wmx4dUlDQWdJQzh2SUhSb1pTQmxaR2wwSUdkeVlYQm9MbHh1SUNBZ0lDOHZJRlJvYVhNZ2IzQjBhVzFwZW1GMGFXOXVJR2x6SUc1dmRDQm1ZV2wwYUdaMWJDQjBieUIwYUdVZ2IzSnBaMmx1WVd3Z1lXeG5iM0pwZEdodElIQnlaWE5sYm5SbFpDQnBibHh1SUNBZ0lDOHZJRTE1WlhKekozTWdjR0Z3WlhJc0lIZG9hV05vSUdsdWMzUmxZV1FnY0c5cGJuUnNaWE56YkhrZ1pYaDBaVzVrY3lCRUxYQmhkR2h6SUc5bVppQjBhR1VnWlc1a0lHOW1YRzRnSUNBZ0x5OGdkR2hsSUdWa2FYUWdaM0poY0dnZ0xTQnpaV1VnY0dGblpTQTNJRzltSUUxNVpYSnpKM01nY0dGd1pYSWdkMmhwWTJnZ2JtOTBaWE1nZEdocGN5QndiMmx1ZEZ4dUlDQWdJQzh2SUdWNGNHeHBZMmwwYkhrZ1lXNWtJR2xzYkhWemRISmhkR1Z6SUdsMElIZHBkR2dnWVNCa2FXRm5jbUZ0TGlCVWFHbHpJR2hoY3lCdFlXcHZjaUJ3WlhKbWIzSnRZVzVqWlZ4dUlDQWdJQzh2SUdsdGNHeHBZMkYwYVc5dWN5Qm1iM0lnYzI5dFpTQmpiMjF0YjI0Z2MyTmxibUZ5YVc5ekxpQkdiM0lnYVc1emRHRnVZMlVzSUhSdklHTnZiWEIxZEdVZ1lTQmthV1ptWEc0Z0lDQWdMeThnZDJobGNtVWdkR2hsSUc1bGR5QjBaWGgwSUhOcGJYQnNlU0JoY0hCbGJtUnpJR1FnWTJoaGNtRmpkR1Z5Y3lCdmJpQjBhR1VnWlc1a0lHOW1JSFJvWlZ4dUlDQWdJQzh2SUc5eWFXZHBibUZzSUhSbGVIUWdiMllnYkdWdVozUm9JRzRzSUhSb1pTQjBjblZsSUUxNVpYSnpJR0ZzWjI5eWFYUm9iU0IzYVd4c0lIUmhhMlVnVHlodUsyUmVNaWxjYmlBZ0lDQXZMeUIwYVcxbElIZG9hV3hsSUhSb2FYTWdiM0IwYVcxcGVtRjBhVzl1SUc1bFpXUnpJRzl1YkhrZ1R5aHVLMlFwSUhScGJXVXVYRzRnSUNBZ2JHVjBJRzFwYmtScFlXZHZibUZzVkc5RGIyNXphV1JsY2lBOUlDMUpibVpwYm1sMGVTd2diV0Y0UkdsaFoyOXVZV3hVYjBOdmJuTnBaR1Z5SUQwZ1NXNW1hVzVwZEhrN1hHNWNiaUFnSUNBdkx5Qk5ZV2x1SUhkdmNtdGxjaUJ0WlhSb2IyUXVJR05vWldOcmN5QmhiR3dnY0dWeWJYVjBZWFJwYjI1eklHOW1JR0VnWjJsMlpXNGdaV1JwZENCc1pXNW5kR2dnWm05eUlHRmpZMlZ3ZEdGdVkyVXVYRzRnSUNBZ1puVnVZM1JwYjI0Z1pYaGxZMFZrYVhSTVpXNW5kR2dvS1NCN1hHNGdJQ0FnSUNCbWIzSWdLRnh1SUNBZ0lDQWdJQ0JzWlhRZ1pHbGhaMjl1WVd4UVlYUm9JRDBnVFdGMGFDNXRZWGdvYldsdVJHbGhaMjl1WVd4VWIwTnZibk5wWkdWeUxDQXRaV1JwZEV4bGJtZDBhQ2s3WEc0Z0lDQWdJQ0FnSUdScFlXZHZibUZzVUdGMGFDQThQU0JOWVhSb0xtMXBiaWh0WVhoRWFXRm5iMjVoYkZSdlEyOXVjMmxrWlhJc0lHVmthWFJNWlc1bmRHZ3BPMXh1SUNBZ0lDQWdJQ0JrYVdGbmIyNWhiRkJoZEdnZ0t6MGdNbHh1SUNBZ0lDQWdLU0I3WEc0Z0lDQWdJQ0FnSUd4bGRDQmlZWE5sVUdGMGFEdGNiaUFnSUNBZ0lDQWdiR1YwSUhKbGJXOTJaVkJoZEdnZ1BTQmlaWE4wVUdGMGFGdGthV0ZuYjI1aGJGQmhkR2dnTFNBeFhTeGNiaUFnSUNBZ0lDQWdJQ0FnSUdGa1pGQmhkR2dnUFNCaVpYTjBVR0YwYUZ0a2FXRm5iMjVoYkZCaGRHZ2dLeUF4WFR0Y2JpQWdJQ0FnSUNBZ2FXWWdLSEpsYlc5MlpWQmhkR2dwSUh0Y2JpQWdJQ0FnSUNBZ0lDQXZMeUJPYnlCdmJtVWdaV3h6WlNCcGN5Qm5iMmx1WnlCMGJ5QmhkSFJsYlhCMElIUnZJSFZ6WlNCMGFHbHpJSFpoYkhWbExDQmpiR1ZoY2lCcGRGeHVJQ0FnSUNBZ0lDQWdJR0psYzNSUVlYUm9XMlJwWVdkdmJtRnNVR0YwYUNBdElERmRJRDBnZFc1a1pXWnBibVZrTzF4dUlDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdiR1YwSUdOaGJrRmtaQ0E5SUdaaGJITmxPMXh1SUNBZ0lDQWdJQ0JwWmlBb1lXUmtVR0YwYUNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQzh2SUhkb1lYUWdibVYzVUc5eklIZHBiR3dnWW1VZ1lXWjBaWElnZDJVZ1pHOGdZVzRnYVc1elpYSjBhVzl1T2x4dUlDQWdJQ0FnSUNBZ0lHTnZibk4wSUdGa1pGQmhkR2hPWlhkUWIzTWdQU0JoWkdSUVlYUm9MbTlzWkZCdmN5QXRJR1JwWVdkdmJtRnNVR0YwYUR0Y2JpQWdJQ0FnSUNBZ0lDQmpZVzVCWkdRZ1BTQmhaR1JRWVhSb0lDWW1JREFnUEQwZ1lXUmtVR0YwYUU1bGQxQnZjeUFtSmlCaFpHUlFZWFJvVG1WM1VHOXpJRHdnYm1WM1RHVnVPMXh1SUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ2JHVjBJR05oYmxKbGJXOTJaU0E5SUhKbGJXOTJaVkJoZEdnZ0ppWWdjbVZ0YjNabFVHRjBhQzV2YkdSUWIzTWdLeUF4SUR3Z2IyeGtUR1Z1TzF4dUlDQWdJQ0FnSUNCcFppQW9JV05oYmtGa1pDQW1KaUFoWTJGdVVtVnRiM1psS1NCN1hHNGdJQ0FnSUNBZ0lDQWdMeThnU1dZZ2RHaHBjeUJ3WVhSb0lHbHpJR0VnZEdWeWJXbHVZV3dnZEdobGJpQndjblZ1WlZ4dUlDQWdJQ0FnSUNBZ0lHSmxjM1JRWVhSb1cyUnBZV2R2Ym1Gc1VHRjBhRjBnUFNCMWJtUmxabWx1WldRN1hHNGdJQ0FnSUNBZ0lDQWdZMjl1ZEdsdWRXVTdYRzRnSUNBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnSUNBdkx5QlRaV3hsWTNRZ2RHaGxJR1JwWVdkdmJtRnNJSFJvWVhRZ2QyVWdkMkZ1ZENCMGJ5QmljbUZ1WTJnZ1puSnZiUzRnVjJVZ2MyVnNaV04wSUhSb1pTQndjbWx2Y2x4dUlDQWdJQ0FnSUNBdkx5QndZWFJvSUhkb2IzTmxJSEJ2YzJsMGFXOXVJR2x1SUhSb1pTQnZiR1FnYzNSeWFXNW5JR2x6SUhSb1pTQm1ZWEowYUdWemRDQm1jbTl0SUhSb1pTQnZjbWxuYVc1Y2JpQWdJQ0FnSUNBZ0x5OGdZVzVrSUdSdlpYTWdibTkwSUhCaGMzTWdkR2hsSUdKdmRXNWtjeUJ2WmlCMGFHVWdaR2xtWmlCbmNtRndhRnh1SUNBZ0lDQWdJQ0F2THlCVVQwUlBPaUJTWlcxdmRtVWdkR2hsSUdBcklERmdJR2hsY21VZ2RHOGdiV0ZyWlNCaVpXaGhkbWx2Y2lCdFlYUmphQ0JOZVdWeWN5QmhiR2R2Y21sMGFHMWNiaUFnSUNBZ0lDQWdMeThnSUNBZ0lDQWdZVzVrSUhCeVpXWmxjaUIwYnlCdmNtUmxjaUJ5WlcxdmRtRnNjeUJpWldadmNtVWdhVzV6WlhKMGFXOXVjeTVjYmlBZ0lDQWdJQ0FnYVdZZ0tDRmpZVzVTWlcxdmRtVWdmSHdnS0dOaGJrRmtaQ0FtSmlCeVpXMXZkbVZRWVhSb0xtOXNaRkJ2Y3lBcklERWdQQ0JoWkdSUVlYUm9MbTlzWkZCdmN5a3BJSHRjYmlBZ0lDQWdJQ0FnSUNCaVlYTmxVR0YwYUNBOUlITmxiR1l1WVdSa1ZHOVFZWFJvS0dGa1pGQmhkR2dzSUhSeWRXVXNJSFZ1WkdWbWFXNWxaQ3dnTUNrN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdZbUZ6WlZCaGRHZ2dQU0J6Wld4bUxtRmtaRlJ2VUdGMGFDaHlaVzF2ZG1WUVlYUm9MQ0IxYm1SbFptbHVaV1FzSUhSeWRXVXNJREVwTzF4dUlDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdibVYzVUc5eklEMGdjMlZzWmk1bGVIUnlZV04wUTI5dGJXOXVLR0poYzJWUVlYUm9MQ0J1WlhkVGRISnBibWNzSUc5c1pGTjBjbWx1Wnl3Z1pHbGhaMjl1WVd4UVlYUm9LVHRjYmx4dUlDQWdJQ0FnSUNCcFppQW9ZbUZ6WlZCaGRHZ3ViMnhrVUc5eklDc2dNU0ErUFNCdmJHUk1aVzRnSmlZZ2JtVjNVRzl6SUNzZ01TQStQU0J1WlhkTVpXNHBJSHRjYmlBZ0lDQWdJQ0FnSUNBdkx5QkpaaUIzWlNCb1lYWmxJR2hwZENCMGFHVWdaVzVrSUc5bUlHSnZkR2dnYzNSeWFXNW5jeXdnZEdobGJpQjNaU0JoY21VZ1pHOXVaVnh1SUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUJrYjI1bEtHSjFhV3hrVm1Gc2RXVnpLSE5sYkdZc0lHSmhjMlZRWVhSb0xteGhjM1JEYjIxd2IyNWxiblFzSUc1bGQxTjBjbWx1Wnl3Z2IyeGtVM1J5YVc1bkxDQnpaV3htTG5WelpVeHZibWRsYzNSVWIydGxiaWtwTzF4dUlDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNBZ0lHSmxjM1JRWVhSb1cyUnBZV2R2Ym1Gc1VHRjBhRjBnUFNCaVlYTmxVR0YwYUR0Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvWW1GelpWQmhkR2d1YjJ4a1VHOXpJQ3NnTVNBK1BTQnZiR1JNWlc0cElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUcxaGVFUnBZV2R2Ym1Gc1ZHOURiMjV6YVdSbGNpQTlJRTFoZEdndWJXbHVLRzFoZUVScFlXZHZibUZzVkc5RGIyNXphV1JsY2l3Z1pHbGhaMjl1WVd4UVlYUm9JQzBnTVNrN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0FnSUdsbUlDaHVaWGRRYjNNZ0t5QXhJRDQ5SUc1bGQweGxiaWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdiV2x1UkdsaFoyOXVZV3hVYjBOdmJuTnBaR1Z5SUQwZ1RXRjBhQzV0WVhnb2JXbHVSR2xoWjI5dVlXeFViME52Ym5OcFpHVnlMQ0JrYVdGbmIyNWhiRkJoZEdnZ0t5QXhLVHRjYmlBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMWNibHh1SUNBZ0lDQWdaV1JwZEV4bGJtZDBhQ3NyTzF4dUlDQWdJSDFjYmx4dUlDQWdJQzh2SUZCbGNtWnZjbTF6SUhSb1pTQnNaVzVuZEdnZ2IyWWdaV1JwZENCcGRHVnlZWFJwYjI0dUlFbHpJR0VnWW1sMElHWjFaMng1SUdGeklIUm9hWE1nYUdGeklIUnZJSE4xY0hCdmNuUWdkR2hsWEc0Z0lDQWdMeThnYzNsdVl5QmhibVFnWVhONWJtTWdiVzlrWlNCM2FHbGphQ0JwY3lCdVpYWmxjaUJtZFc0dUlFeHZiM0J6SUc5MlpYSWdaWGhsWTBWa2FYUk1aVzVuZEdnZ2RXNTBhV3dnWVNCMllXeDFaVnh1SUNBZ0lDOHZJR2x6SUhCeWIyUjFZMlZrTENCdmNpQjFiblJwYkNCMGFHVWdaV1JwZENCc1pXNW5kR2dnWlhoalpXVmtjeUJ2Y0hScGIyNXpMbTFoZUVWa2FYUk1aVzVuZEdnZ0tHbG1JR2RwZG1WdUtTeGNiaUFnSUNBdkx5QnBiaUIzYUdsamFDQmpZWE5sSUdsMElIZHBiR3dnY21WMGRYSnVJSFZ1WkdWbWFXNWxaQzVjYmlBZ0lDQnBaaUFvWTJGc2JHSmhZMnNwSUh0Y2JpQWdJQ0FnSUNobWRXNWpkR2x2YmlCbGVHVmpLQ2tnZTF4dUlDQWdJQ0FnSUNCelpYUlVhVzFsYjNWMEtHWjFibU4wYVc5dUtDa2dlMXh1SUNBZ0lDQWdJQ0FnSUdsbUlDaGxaR2wwVEdWdVozUm9JRDRnYldGNFJXUnBkRXhsYm1kMGFDQjhmQ0JFWVhSbExtNXZkeWdwSUQ0Z1lXSnZjblJCWm5SbGNsUnBiV1Z6ZEdGdGNDa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUdOaGJHeGlZV05yS0NrN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLQ0ZsZUdWalJXUnBkRXhsYm1kMGFDZ3BLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmxlR1ZqS0NrN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0I5TENBd0tUdGNiaUFnSUNBZ0lIMG9LU2s3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lIZG9hV3hsSUNobFpHbDBUR1Z1WjNSb0lEdzlJRzFoZUVWa2FYUk1aVzVuZEdnZ0ppWWdSR0YwWlM1dWIzY29LU0E4UFNCaFltOXlkRUZtZEdWeVZHbHRaWE4wWVcxd0tTQjdYRzRnSUNBZ0lDQWdJR3hsZENCeVpYUWdQU0JsZUdWalJXUnBkRXhsYm1kMGFDZ3BPMXh1SUNBZ0lDQWdJQ0JwWmlBb2NtVjBLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUhKbGREdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmVnh1SUNBZ0lIMWNiaUFnZlN4Y2JseHVJQ0JoWkdSVWIxQmhkR2dvY0dGMGFDd2dZV1JrWldRc0lISmxiVzkyWldRc0lHOXNaRkJ2YzBsdVl5a2dlMXh1SUNBZ0lHeGxkQ0JzWVhOMElEMGdjR0YwYUM1c1lYTjBRMjl0Y0c5dVpXNTBPMXh1SUNBZ0lHbG1JQ2hzWVhOMElDWW1JR3hoYzNRdVlXUmtaV1FnUFQwOUlHRmtaR1ZrSUNZbUlHeGhjM1F1Y21WdGIzWmxaQ0E5UFQwZ2NtVnRiM1psWkNrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUh0Y2JpQWdJQ0FnSUNBZ2IyeGtVRzl6T2lCd1lYUm9MbTlzWkZCdmN5QXJJRzlzWkZCdmMwbHVZeXhjYmlBZ0lDQWdJQ0FnYkdGemRFTnZiWEJ2Ym1WdWREb2dlMk52ZFc1ME9pQnNZWE4wTG1OdmRXNTBJQ3NnTVN3Z1lXUmtaV1E2SUdGa1pHVmtMQ0J5WlcxdmRtVmtPaUJ5WlcxdmRtVmtMQ0J3Y21WMmFXOTFjME52YlhCdmJtVnVkRG9nYkdGemRDNXdjbVYyYVc5MWMwTnZiWEJ2Ym1WdWRDQjlYRzRnSUNBZ0lDQjlPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnZTF4dUlDQWdJQ0FnSUNCdmJHUlFiM002SUhCaGRHZ3ViMnhrVUc5eklDc2diMnhrVUc5elNXNWpMRnh1SUNBZ0lDQWdJQ0JzWVhOMFEyOXRjRzl1Wlc1ME9pQjdZMjkxYm5RNklERXNJR0ZrWkdWa09pQmhaR1JsWkN3Z2NtVnRiM1psWkRvZ2NtVnRiM1psWkN3Z2NISmxkbWx2ZFhORGIyMXdiMjVsYm5RNklHeGhjM1FnZlZ4dUlDQWdJQ0FnZlR0Y2JpQWdJQ0I5WEc0Z0lIMHNYRzRnSUdWNGRISmhZM1JEYjIxdGIyNG9ZbUZ6WlZCaGRHZ3NJRzVsZDFOMGNtbHVaeXdnYjJ4a1UzUnlhVzVuTENCa2FXRm5iMjVoYkZCaGRHZ3BJSHRjYmlBZ0lDQnNaWFFnYm1WM1RHVnVJRDBnYm1WM1UzUnlhVzVuTG14bGJtZDBhQ3hjYmlBZ0lDQWdJQ0FnYjJ4a1RHVnVJRDBnYjJ4a1UzUnlhVzVuTG14bGJtZDBhQ3hjYmlBZ0lDQWdJQ0FnYjJ4a1VHOXpJRDBnWW1GelpWQmhkR2d1YjJ4a1VHOXpMRnh1SUNBZ0lDQWdJQ0J1WlhkUWIzTWdQU0J2YkdSUWIzTWdMU0JrYVdGbmIyNWhiRkJoZEdnc1hHNWNiaUFnSUNBZ0lDQWdZMjl0Ylc5dVEyOTFiblFnUFNBd08xeHVJQ0FnSUhkb2FXeGxJQ2h1WlhkUWIzTWdLeUF4SUR3Z2JtVjNUR1Z1SUNZbUlHOXNaRkJ2Y3lBcklERWdQQ0J2YkdSTVpXNGdKaVlnZEdocGN5NWxjWFZoYkhNb2JtVjNVM1J5YVc1blcyNWxkMUJ2Y3lBcklERmRMQ0J2YkdSVGRISnBibWRiYjJ4a1VHOXpJQ3NnTVYwcEtTQjdYRzRnSUNBZ0lDQnVaWGRRYjNNckt6dGNiaUFnSUNBZ0lHOXNaRkJ2Y3lzck8xeHVJQ0FnSUNBZ1kyOXRiVzl1UTI5MWJuUXJLenRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnBaaUFvWTI5dGJXOXVRMjkxYm5RcElIdGNiaUFnSUNBZ0lHSmhjMlZRWVhSb0xteGhjM1JEYjIxd2IyNWxiblFnUFNCN1kyOTFiblE2SUdOdmJXMXZia052ZFc1MExDQndjbVYyYVc5MWMwTnZiWEJ2Ym1WdWREb2dZbUZ6WlZCaGRHZ3ViR0Z6ZEVOdmJYQnZibVZ1ZEgwN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnWW1GelpWQmhkR2d1YjJ4a1VHOXpJRDBnYjJ4a1VHOXpPMXh1SUNBZ0lISmxkSFZ5YmlCdVpYZFFiM003WEc0Z0lIMHNYRzVjYmlBZ1pYRjFZV3h6S0d4bFpuUXNJSEpwWjJoMEtTQjdYRzRnSUNBZ2FXWWdLSFJvYVhNdWIzQjBhVzl1Y3k1amIyMXdZWEpoZEc5eUtTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z2RHaHBjeTV2Y0hScGIyNXpMbU52YlhCaGNtRjBiM0lvYkdWbWRDd2djbWxuYUhRcE8xeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdiR1ZtZENBOVBUMGdjbWxuYUhSY2JpQWdJQ0FnSUNBZ2ZId2dLSFJvYVhNdWIzQjBhVzl1Y3k1cFoyNXZjbVZEWVhObElDWW1JR3hsWm5RdWRHOU1iM2RsY2tOaGMyVW9LU0E5UFQwZ2NtbG5hSFF1ZEc5TWIzZGxja05oYzJVb0tTazdYRzRnSUNBZ2ZWeHVJQ0I5TEZ4dUlDQnlaVzF2ZG1WRmJYQjBlU2hoY25KaGVTa2dlMXh1SUNBZ0lHeGxkQ0J5WlhRZ1BTQmJYVHRjYmlBZ0lDQm1iM0lnS0d4bGRDQnBJRDBnTURzZ2FTQThJR0Z5Y21GNUxteGxibWQwYURzZ2FTc3JLU0I3WEc0Z0lDQWdJQ0JwWmlBb1lYSnlZWGxiYVYwcElIdGNiaUFnSUNBZ0lDQWdjbVYwTG5CMWMyZ29ZWEp5WVhsYmFWMHBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMWNiaUFnSUNCeVpYUjFjbTRnY21WME8xeHVJQ0I5TEZ4dUlDQmpZWE4wU1c1d2RYUW9kbUZzZFdVcElIdGNiaUFnSUNCeVpYUjFjbTRnZG1Gc2RXVTdYRzRnSUgwc1hHNGdJSFJ2YTJWdWFYcGxLSFpoYkhWbEtTQjdYRzRnSUNBZ2NtVjBkWEp1SUhaaGJIVmxMbk53YkdsMEtDY25LVHRjYmlBZ2ZTeGNiaUFnYW05cGJpaGphR0Z5Y3lrZ2UxeHVJQ0FnSUhKbGRIVnliaUJqYUdGeWN5NXFiMmx1S0NjbktUdGNiaUFnZlZ4dWZUdGNibHh1Wm5WdVkzUnBiMjRnWW5WcGJHUldZV3gxWlhNb1pHbG1aaXdnYkdGemRFTnZiWEJ2Ym1WdWRDd2dibVYzVTNSeWFXNW5MQ0J2YkdSVGRISnBibWNzSUhWelpVeHZibWRsYzNSVWIydGxiaWtnZTF4dUlDQXZMeUJHYVhKemRDQjNaU0JqYjI1MlpYSjBJRzkxY2lCc2FXNXJaV1FnYkdsemRDQnZaaUJqYjIxd2IyNWxiblJ6SUdsdUlISmxkbVZ5YzJVZ2IzSmtaWElnZEc4Z1lXNWNiaUFnTHk4Z1lYSnlZWGtnYVc0Z2RHaGxJSEpwWjJoMElHOXlaR1Z5T2x4dUlDQmpiMjV6ZENCamIyMXdiMjVsYm5SeklEMGdXMTA3WEc0Z0lHeGxkQ0J1WlhoMFEyOXRjRzl1Wlc1ME8xeHVJQ0IzYUdsc1pTQW9iR0Z6ZEVOdmJYQnZibVZ1ZENrZ2UxeHVJQ0FnSUdOdmJYQnZibVZ1ZEhNdWNIVnphQ2hzWVhOMFEyOXRjRzl1Wlc1MEtUdGNiaUFnSUNCdVpYaDBRMjl0Y0c5dVpXNTBJRDBnYkdGemRFTnZiWEJ2Ym1WdWRDNXdjbVYyYVc5MWMwTnZiWEJ2Ym1WdWREdGNiaUFnSUNCa1pXeGxkR1VnYkdGemRFTnZiWEJ2Ym1WdWRDNXdjbVYyYVc5MWMwTnZiWEJ2Ym1WdWREdGNiaUFnSUNCc1lYTjBRMjl0Y0c5dVpXNTBJRDBnYm1WNGRFTnZiWEJ2Ym1WdWREdGNiaUFnZlZ4dUlDQmpiMjF3YjI1bGJuUnpMbkpsZG1WeWMyVW9LVHRjYmx4dUlDQnNaWFFnWTI5dGNHOXVaVzUwVUc5eklEMGdNQ3hjYmlBZ0lDQWdJR052YlhCdmJtVnVkRXhsYmlBOUlHTnZiWEJ2Ym1WdWRITXViR1Z1WjNSb0xGeHVJQ0FnSUNBZ2JtVjNVRzl6SUQwZ01DeGNiaUFnSUNBZ0lHOXNaRkJ2Y3lBOUlEQTdYRzVjYmlBZ1ptOXlJQ2c3SUdOdmJYQnZibVZ1ZEZCdmN5QThJR052YlhCdmJtVnVkRXhsYmpzZ1kyOXRjRzl1Wlc1MFVHOXpLeXNwSUh0Y2JpQWdJQ0JzWlhRZ1kyOXRjRzl1Wlc1MElEMGdZMjl0Y0c5dVpXNTBjMXRqYjIxd2IyNWxiblJRYjNOZE8xeHVJQ0FnSUdsbUlDZ2hZMjl0Y0c5dVpXNTBMbkpsYlc5MlpXUXBJSHRjYmlBZ0lDQWdJR2xtSUNnaFkyOXRjRzl1Wlc1MExtRmtaR1ZrSUNZbUlIVnpaVXh2Ym1kbGMzUlViMnRsYmlrZ2UxeHVJQ0FnSUNBZ0lDQnNaWFFnZG1Gc2RXVWdQU0J1WlhkVGRISnBibWN1YzJ4cFkyVW9ibVYzVUc5ekxDQnVaWGRRYjNNZ0t5QmpiMjF3YjI1bGJuUXVZMjkxYm5RcE8xeHVJQ0FnSUNBZ0lDQjJZV3gxWlNBOUlIWmhiSFZsTG0xaGNDaG1kVzVqZEdsdmJpaDJZV3gxWlN3Z2FTa2dlMXh1SUNBZ0lDQWdJQ0FnSUd4bGRDQnZiR1JXWVd4MVpTQTlJRzlzWkZOMGNtbHVaMXR2YkdSUWIzTWdLeUJwWFR0Y2JpQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z2IyeGtWbUZzZFdVdWJHVnVaM1JvSUQ0Z2RtRnNkV1V1YkdWdVozUm9JRDhnYjJ4a1ZtRnNkV1VnT2lCMllXeDFaVHRjYmlBZ0lDQWdJQ0FnZlNrN1hHNWNiaUFnSUNBZ0lDQWdZMjl0Y0c5dVpXNTBMblpoYkhWbElEMGdaR2xtWmk1cWIybHVLSFpoYkhWbEtUdGNiaUFnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lHTnZiWEJ2Ym1WdWRDNTJZV3gxWlNBOUlHUnBabVl1YW05cGJpaHVaWGRUZEhKcGJtY3VjMnhwWTJVb2JtVjNVRzl6TENCdVpYZFFiM01nS3lCamIyMXdiMjVsYm5RdVkyOTFiblFwS1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUc1bGQxQnZjeUFyUFNCamIyMXdiMjVsYm5RdVkyOTFiblE3WEc1Y2JpQWdJQ0FnSUM4dklFTnZiVzF2YmlCallYTmxYRzRnSUNBZ0lDQnBaaUFvSVdOdmJYQnZibVZ1ZEM1aFpHUmxaQ2tnZTF4dUlDQWdJQ0FnSUNCdmJHUlFiM01nS3owZ1kyOXRjRzl1Wlc1MExtTnZkVzUwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQmpiMjF3YjI1bGJuUXVkbUZzZFdVZ1BTQmthV1ptTG1wdmFXNG9iMnhrVTNSeWFXNW5Mbk5zYVdObEtHOXNaRkJ2Y3l3Z2IyeGtVRzl6SUNzZ1kyOXRjRzl1Wlc1MExtTnZkVzUwS1NrN1hHNGdJQ0FnSUNCdmJHUlFiM01nS3owZ1kyOXRjRzl1Wlc1MExtTnZkVzUwTzF4dVhHNGdJQ0FnSUNBdkx5QlNaWFpsY25ObElHRmtaQ0JoYm1RZ2NtVnRiM1psSUhOdklISmxiVzkyWlhNZ1lYSmxJRzkxZEhCMWRDQm1hWEp6ZENCMGJ5QnRZWFJqYUNCamIyMXRiMjRnWTI5dWRtVnVkR2x2Ymx4dUlDQWdJQ0FnTHk4Z1ZHaGxJR1JwWm1acGJtY2dZV3huYjNKcGRHaHRJR2x6SUhScFpXUWdkRzhnWVdSa0lIUm9aVzRnY21WdGIzWmxJRzkxZEhCMWRDQmhibVFnZEdocGN5QnBjeUIwYUdVZ2MybHRjR3hsYzNSY2JpQWdJQ0FnSUM4dklISnZkWFJsSUhSdklHZGxkQ0IwYUdVZ1pHVnphWEpsWkNCdmRYUndkWFFnZDJsMGFDQnRhVzVwYldGc0lHOTJaWEpvWldGa0xseHVJQ0FnSUNBZ2FXWWdLR052YlhCdmJtVnVkRkJ2Y3lBbUppQmpiMjF3YjI1bGJuUnpXMk52YlhCdmJtVnVkRkJ2Y3lBdElERmRMbUZrWkdWa0tTQjdYRzRnSUNBZ0lDQWdJR3hsZENCMGJYQWdQU0JqYjIxd2IyNWxiblJ6VzJOdmJYQnZibVZ1ZEZCdmN5QXRJREZkTzF4dUlDQWdJQ0FnSUNCamIyMXdiMjVsYm5SelcyTnZiWEJ2Ym1WdWRGQnZjeUF0SURGZElEMGdZMjl0Y0c5dVpXNTBjMXRqYjIxd2IyNWxiblJRYjNOZE8xeHVJQ0FnSUNBZ0lDQmpiMjF3YjI1bGJuUnpXMk52YlhCdmJtVnVkRkJ2YzEwZ1BTQjBiWEE3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmVnh1SUNCOVhHNWNiaUFnTHk4Z1UzQmxZMmxoYkNCallYTmxJR2hoYm1Sc1pTQm1iM0lnZDJobGJpQnZibVVnZEdWeWJXbHVZV3dnYVhNZ2FXZHViM0psWkNBb2FTNWxMaUIzYUdsMFpYTndZV05sS1M1Y2JpQWdMeThnUm05eUlIUm9hWE1nWTJGelpTQjNaU0J0WlhKblpTQjBhR1VnZEdWeWJXbHVZV3dnYVc1MGJ5QjBhR1VnY0hKcGIzSWdjM1J5YVc1bklHRnVaQ0JrY205d0lIUm9aU0JqYUdGdVoyVXVYRzRnSUM4dklGUm9hWE1nYVhNZ2IyNXNlU0JoZG1GcGJHRmliR1VnWm05eUlITjBjbWx1WnlCdGIyUmxMbHh1SUNCc1pYUWdabWx1WVd4RGIyMXdiMjVsYm5RZ1BTQmpiMjF3YjI1bGJuUnpXMk52YlhCdmJtVnVkRXhsYmlBdElERmRPMXh1SUNCcFppQW9ZMjl0Y0c5dVpXNTBUR1Z1SUQ0Z01WeHVJQ0FnSUNBZ0ppWWdkSGx3Wlc5bUlHWnBibUZzUTI5dGNHOXVaVzUwTG5aaGJIVmxJRDA5UFNBbmMzUnlhVzVuSjF4dUlDQWdJQ0FnSmlZZ0tHWnBibUZzUTI5dGNHOXVaVzUwTG1Ga1pHVmtJSHg4SUdacGJtRnNRMjl0Y0c5dVpXNTBMbkpsYlc5MlpXUXBYRzRnSUNBZ0lDQW1KaUJrYVdabUxtVnhkV0ZzY3lnbkp5d2dabWx1WVd4RGIyMXdiMjVsYm5RdWRtRnNkV1VwS1NCN1hHNGdJQ0FnWTI5dGNHOXVaVzUwYzF0amIyMXdiMjVsYm5STVpXNGdMU0F5WFM1MllXeDFaU0FyUFNCbWFXNWhiRU52YlhCdmJtVnVkQzUyWVd4MVpUdGNiaUFnSUNCamIyMXdiMjVsYm5SekxuQnZjQ2dwTzF4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUdOdmJYQnZibVZ1ZEhNN1hHNTlYRzRpWFgwPVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/character.js":
/*!********************************************************************!*\
  !*** ./node_modules/mocha/node_modules/diff/lib/diff/character.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*istanbul ignore start*/\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.diffChars = diffChars;\nexports.characterDiff = void 0;\n\n/*istanbul ignore end*/\nvar\n/*istanbul ignore start*/\n_base = _interopRequireDefault(__webpack_require__(/*! ./base */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/base.js\"))\n/*istanbul ignore end*/\n;\n\n/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/*istanbul ignore end*/\nvar characterDiff = new\n/*istanbul ignore start*/\n_base\n/*istanbul ignore end*/\n[\n/*istanbul ignore start*/\n\"default\"\n/*istanbul ignore end*/\n]();\n\n/*istanbul ignore start*/\nexports.characterDiff = characterDiff;\n\n/*istanbul ignore end*/\nfunction diffChars(oldStr, newStr, options) {\n  return characterDiff.diff(oldStr, newStr, options);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2NoYXJhY3Rlci5qcyJdLCJuYW1lcyI6WyJjaGFyYWN0ZXJEaWZmIiwiRGlmZiIsImRpZmZDaGFycyIsIm9sZFN0ciIsIm5ld1N0ciIsIm9wdGlvbnMiLCJkaWZmIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7QUFFTyxJQUFNQSxhQUFhLEdBQUc7QUFBSUM7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUEsQ0FBSixFQUF0Qjs7Ozs7O0FBQ0EsU0FBU0MsU0FBVCxDQUFtQkMsTUFBbkIsRUFBMkJDLE1BQTNCLEVBQW1DQyxPQUFuQyxFQUE0QztBQUFFLFNBQU9MLGFBQWEsQ0FBQ00sSUFBZCxDQUFtQkgsTUFBbkIsRUFBMkJDLE1BQTNCLEVBQW1DQyxPQUFuQyxDQUFQO0FBQXFEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERpZmYgZnJvbSAnLi9iYXNlJztcblxuZXhwb3J0IGNvbnN0IGNoYXJhY3RlckRpZmYgPSBuZXcgRGlmZigpO1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmZDaGFycyhvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykgeyByZXR1cm4gY2hhcmFjdGVyRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTsgfVxuIl19\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL2RpZmYvY2hhcmFjdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaUJBQWlCO0FBQ2pCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMsNkVBQVE7QUFDL0M7QUFDQTs7QUFFQSxpRUFBaUUsdUNBQXVDOztBQUV4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL2RpZmYvY2hhcmFjdGVyLmpzP2MwYzEiXSwic291cmNlc0NvbnRlbnQiOlsiLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRpZmZDaGFycyA9IGRpZmZDaGFycztcbmV4cG9ydHMuY2hhcmFjdGVyRGlmZiA9IHZvaWQgMDtcblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2Jhc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Jhc2VcIikpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xudmFyIGNoYXJhY3RlckRpZmYgPSBuZXdcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9iYXNlXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuW1xuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXCJkZWZhdWx0XCJcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5dKCk7XG5cbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbmV4cG9ydHMuY2hhcmFjdGVyRGlmZiA9IGNoYXJhY3RlckRpZmY7XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5mdW5jdGlvbiBkaWZmQ2hhcnMob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNoYXJhY3RlckRpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTlrYVdabUwyTm9ZWEpoWTNSbGNpNXFjeUpkTENKdVlXMWxjeUk2V3lKamFHRnlZV04wWlhKRWFXWm1JaXdpUkdsbVppSXNJbVJwWm1aRGFHRnljeUlzSW05c1pGTjBjaUlzSW01bGQxTjBjaUlzSW05d2RHbHZibk1pTENKa2FXWm1JbDBzSW0xaGNIQnBibWR6SWpvaU96czdPenM3T3pzN08wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVRzN096czdRVUZGVHl4SlFVRk5RU3hoUVVGaExFZEJRVWM3UVVGQlNVTTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFc1EwRkJTaXhGUVVGMFFqczdPenM3TzBGQlEwRXNVMEZCVTBNc1UwRkJWQ3hEUVVGdFFrTXNUVUZCYmtJc1JVRkJNa0pETEUxQlFUTkNMRVZCUVcxRFF5eFBRVUZ1UXl4RlFVRTBRenRCUVVGRkxGTkJRVTlNTEdGQlFXRXNRMEZCUTAwc1NVRkJaQ3hEUVVGdFFrZ3NUVUZCYmtJc1JVRkJNa0pETEUxQlFUTkNMRVZCUVcxRFF5eFBRVUZ1UXl4RFFVRlFPMEZCUVhGRUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lhVzF3YjNKMElFUnBabVlnWm5KdmJTQW5MaTlpWVhObEp6dGNibHh1Wlhod2IzSjBJR052Ym5OMElHTm9ZWEpoWTNSbGNrUnBabVlnUFNCdVpYY2dSR2xtWmlncE8xeHVaWGh3YjNKMElHWjFibU4wYVc5dUlHUnBabVpEYUdGeWN5aHZiR1JUZEhJc0lHNWxkMU4wY2l3Z2IzQjBhVzl1Y3lrZ2V5QnlaWFIxY200Z1kyaGhjbUZqZEdWeVJHbG1aaTVrYVdabUtHOXNaRk4wY2l3Z2JtVjNVM1J5TENCdmNIUnBiMjV6S1RzZ2ZWeHVJbDE5XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/character.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/css.js":
/*!**************************************************************!*\
  !*** ./node_modules/mocha/node_modules/diff/lib/diff/css.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*istanbul ignore start*/\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.diffCss = diffCss;\nexports.cssDiff = void 0;\n\n/*istanbul ignore end*/\nvar\n/*istanbul ignore start*/\n_base = _interopRequireDefault(__webpack_require__(/*! ./base */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/base.js\"))\n/*istanbul ignore end*/\n;\n\n/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/*istanbul ignore end*/\nvar cssDiff = new\n/*istanbul ignore start*/\n_base\n/*istanbul ignore end*/\n[\n/*istanbul ignore start*/\n\"default\"\n/*istanbul ignore end*/\n]();\n\n/*istanbul ignore start*/\nexports.cssDiff = cssDiff;\n\n/*istanbul ignore end*/\ncssDiff.tokenize = function (value) {\n  return value.split(/([{}:;,]|\\s+)/);\n};\n\nfunction diffCss(oldStr, newStr, callback) {\n  return cssDiff.diff(oldStr, newStr, callback);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2Nzcy5qcyJdLCJuYW1lcyI6WyJjc3NEaWZmIiwiRGlmZiIsInRva2VuaXplIiwidmFsdWUiLCJzcGxpdCIsImRpZmZDc3MiLCJvbGRTdHIiLCJuZXdTdHIiLCJjYWxsYmFjayIsImRpZmYiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7OztBQUVPLElBQU1BLE9BQU8sR0FBRztBQUFJQztBQUFBQTtBQUFBQTtBQUFBQTtBQUFBQTtBQUFBQTtBQUFBQTtBQUFBQSxDQUFKLEVBQWhCOzs7Ozs7QUFDUEQsT0FBTyxDQUFDRSxRQUFSLEdBQW1CLFVBQVNDLEtBQVQsRUFBZ0I7QUFDakMsU0FBT0EsS0FBSyxDQUFDQyxLQUFOLENBQVksZUFBWixDQUFQO0FBQ0QsQ0FGRDs7QUFJTyxTQUFTQyxPQUFULENBQWlCQyxNQUFqQixFQUF5QkMsTUFBekIsRUFBaUNDLFFBQWpDLEVBQTJDO0FBQUUsU0FBT1IsT0FBTyxDQUFDUyxJQUFSLENBQWFILE1BQWIsRUFBcUJDLE1BQXJCLEVBQTZCQyxRQUE3QixDQUFQO0FBQWdEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERpZmYgZnJvbSAnLi9iYXNlJztcblxuZXhwb3J0IGNvbnN0IGNzc0RpZmYgPSBuZXcgRGlmZigpO1xuY3NzRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5zcGxpdCgvKFt7fTo7LF18XFxzKykvKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmQ3NzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykgeyByZXR1cm4gY3NzRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7IH1cbiJdfQ==\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL2RpZmYvY3NzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZUFBZTtBQUNmLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMsNkVBQVE7QUFDL0M7QUFDQTs7QUFFQSxpRUFBaUUsdUNBQXVDOztBQUV4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBLDBCQUEwQixFQUFFO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9ub2RlX21vZHVsZXMvZGlmZi9saWIvZGlmZi9jc3MuanM/ZTEwMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGlmZkNzcyA9IGRpZmZDc3M7XG5leHBvcnRzLmNzc0RpZmYgPSB2b2lkIDA7XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG52YXJcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9iYXNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9iYXNlXCIpKVxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbjtcblxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbnZhciBjc3NEaWZmID0gbmV3XG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5fYmFzZVxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbltcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblwiZGVmYXVsdFwiXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuXSgpO1xuXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5leHBvcnRzLmNzc0RpZmYgPSBjc3NEaWZmO1xuXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuY3NzRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuc3BsaXQoLyhbe306OyxdfFxccyspLyk7XG59O1xuXG5mdW5jdGlvbiBkaWZmQ3NzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xuICByZXR1cm4gY3NzRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTlrYVdabUwyTnpjeTVxY3lKZExDSnVZVzFsY3lJNld5SmpjM05FYVdabUlpd2lSR2xtWmlJc0luUnZhMlZ1YVhwbElpd2lkbUZzZFdVaUxDSnpjR3hwZENJc0ltUnBabVpEYzNNaUxDSnZiR1JUZEhJaUxDSnVaWGRUZEhJaUxDSmpZV3hzWW1GamF5SXNJbVJwWm1ZaVhTd2liV0Z3Y0dsdVozTWlPaUk3T3pzN096czdPenM3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPenM3T3p0QlFVVlBMRWxCUVUxQkxFOUJRVThzUjBGQlJ6dEJRVUZKUXp0QlFVRkJRVHRCUVVGQlFUdEJRVUZCUVR0QlFVRkJRVHRCUVVGQlFUdEJRVUZCUVR0QlFVRkJRU3hEUVVGS0xFVkJRV2hDT3pzN096czdRVUZEVUVRc1QwRkJUeXhEUVVGRFJTeFJRVUZTTEVkQlFXMUNMRlZCUVZORExFdEJRVlFzUlVGQlowSTdRVUZEYWtNc1UwRkJUMEVzUzBGQlN5eERRVUZEUXl4TFFVRk9MRU5CUVZrc1pVRkJXaXhEUVVGUU8wRkJRMFFzUTBGR1JEczdRVUZKVHl4VFFVRlRReXhQUVVGVUxFTkJRV2xDUXl4TlFVRnFRaXhGUVVGNVFrTXNUVUZCZWtJc1JVRkJhVU5ETEZGQlFXcERMRVZCUVRKRE8wRkJRVVVzVTBGQlQxSXNUMEZCVHl4RFFVRkRVeXhKUVVGU0xFTkJRV0ZJTEUxQlFXSXNSVUZCY1VKRExFMUJRWEpDTEVWQlFUWkNReXhSUVVFM1FpeERRVUZRTzBGQlFXZEVJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpYVcxd2IzSjBJRVJwWm1ZZ1puSnZiU0FuTGk5aVlYTmxKenRjYmx4dVpYaHdiM0owSUdOdmJuTjBJR056YzBScFptWWdQU0J1WlhjZ1JHbG1aaWdwTzF4dVkzTnpSR2xtWmk1MGIydGxibWw2WlNBOUlHWjFibU4wYVc5dUtIWmhiSFZsS1NCN1hHNGdJSEpsZEhWeWJpQjJZV3gxWlM1emNHeHBkQ2d2S0Z0N2ZUbzdMRjE4WEZ4ekt5a3ZLVHRjYm4wN1hHNWNibVY0Y0c5eWRDQm1kVzVqZEdsdmJpQmthV1ptUTNOektHOXNaRk4wY2l3Z2JtVjNVM1J5TENCallXeHNZbUZqYXlrZ2V5QnlaWFIxY200Z1kzTnpSR2xtWmk1a2FXWm1LRzlzWkZOMGNpd2dibVYzVTNSeUxDQmpZV3hzWW1GamF5azdJSDFjYmlKZGZRPT1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/css.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/json.js":
/*!***************************************************************!*\
  !*** ./node_modules/mocha/node_modules/diff/lib/diff/json.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*istanbul ignore start*/\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.diffJson = diffJson;\nexports.canonicalize = canonicalize;\nexports.jsonDiff = void 0;\n\n/*istanbul ignore end*/\nvar\n/*istanbul ignore start*/\n_base = _interopRequireDefault(__webpack_require__(/*! ./base */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/base.js\"))\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_line = __webpack_require__(/*! ./line */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/line.js\")\n/*istanbul ignore end*/\n;\n\n/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*istanbul ignore end*/\nvar objectPrototypeToString = Object.prototype.toString;\nvar jsonDiff = new\n/*istanbul ignore start*/\n_base\n/*istanbul ignore end*/\n[\n/*istanbul ignore start*/\n\"default\"\n/*istanbul ignore end*/\n](); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\n/*istanbul ignore start*/\nexports.jsonDiff = jsonDiff;\n\n/*istanbul ignore end*/\njsonDiff.useLongestToken = true;\njsonDiff.tokenize =\n/*istanbul ignore start*/\n_line\n/*istanbul ignore end*/\n.\n/*istanbul ignore start*/\nlineDiff\n/*istanbul ignore end*/\n.tokenize;\n\njsonDiff.castInput = function (value) {\n  /*istanbul ignore start*/\n  var _this$options =\n  /*istanbul ignore end*/\n  this.options,\n      undefinedReplacement = _this$options.undefinedReplacement,\n      _this$options$stringi = _this$options.stringifyReplacer,\n      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v)\n  /*istanbul ignore start*/\n  {\n    return (\n      /*istanbul ignore end*/\n      typeof v === 'undefined' ? undefinedReplacement : v\n    );\n  } : _this$options$stringi;\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\n\njsonDiff.equals = function (left, right) {\n  return (\n    /*istanbul ignore start*/\n    _base\n    /*istanbul ignore end*/\n    [\n    /*istanbul ignore start*/\n    \"default\"\n    /*istanbul ignore end*/\n    ].prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'))\n  );\n};\n\nfunction diffJson(oldObj, newObj, options) {\n  return jsonDiff.diff(oldObj, newObj, options);\n} // This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\n\nfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n\n  var i;\n\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n\n  var canonicalizedObj;\n\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n\n  if (\n  /*istanbul ignore start*/\n  _typeof(\n  /*istanbul ignore end*/\n  obj) === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n\n    var sortedKeys = [],\n        _key;\n\n    for (_key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(_key)) {\n        sortedKeys.push(_key);\n      }\n    }\n\n    sortedKeys.sort();\n\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      _key = sortedKeys[i];\n      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n\n  return canonicalizedObj;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2pzb24uanMiXSwibmFtZXMiOlsib2JqZWN0UHJvdG90eXBlVG9TdHJpbmciLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImpzb25EaWZmIiwiRGlmZiIsInVzZUxvbmdlc3RUb2tlbiIsInRva2VuaXplIiwibGluZURpZmYiLCJjYXN0SW5wdXQiLCJ2YWx1ZSIsIm9wdGlvbnMiLCJ1bmRlZmluZWRSZXBsYWNlbWVudCIsInN0cmluZ2lmeVJlcGxhY2VyIiwiayIsInYiLCJKU09OIiwic3RyaW5naWZ5IiwiY2Fub25pY2FsaXplIiwiZXF1YWxzIiwibGVmdCIsInJpZ2h0IiwiY2FsbCIsInJlcGxhY2UiLCJkaWZmSnNvbiIsIm9sZE9iaiIsIm5ld09iaiIsImRpZmYiLCJvYmoiLCJzdGFjayIsInJlcGxhY2VtZW50U3RhY2siLCJyZXBsYWNlciIsImtleSIsImkiLCJsZW5ndGgiLCJjYW5vbmljYWxpemVkT2JqIiwicHVzaCIsIkFycmF5IiwicG9wIiwidG9KU09OIiwic29ydGVkS2V5cyIsImhhc093blByb3BlcnR5Iiwic29ydCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7QUFFQSxJQUFNQSx1QkFBdUIsR0FBR0MsTUFBTSxDQUFDQyxTQUFQLENBQWlCQyxRQUFqRDtBQUdPLElBQU1DLFFBQVEsR0FBRztBQUFJQztBQUFBQTtBQUFBQTtBQUFBQTtBQUFBQTtBQUFBQTtBQUFBQTtBQUFBQSxDQUFKLEVBQWpCLEMsQ0FDUDtBQUNBOzs7Ozs7QUFDQUQsUUFBUSxDQUFDRSxlQUFULEdBQTJCLElBQTNCO0FBRUFGLFFBQVEsQ0FBQ0csUUFBVDtBQUFvQkM7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQTtBQUFBLENBQVNELFFBQTdCOztBQUNBSCxRQUFRLENBQUNLLFNBQVQsR0FBcUIsVUFBU0MsS0FB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Z0IsR0FBR1AsR0FBbkI7QUFDRDs7QUFDRCxTQUFPTyxnQkFBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERpZmYgZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7bGluZURpZmZ9IGZyb20gJy4vbGluZSc7XG5cbmNvbnN0IG9iamVjdFByb3RvdHlwZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuXG5leHBvcnQgY29uc3QganNvbkRpZmYgPSBuZXcgRGlmZigpO1xuLy8gRGlzY3JpbWluYXRlIGJldHdlZW4gdHdvIGxpbmVzIG9mIHByZXR0eS1wcmludGVkLCBzZXJpYWxpemVkIEpTT04gd2hlcmUgb25lIG9mIHRoZW0gaGFzIGFcbi8vIGRhbmdsaW5nIGNvbW1hIGFuZCB0aGUgb3RoZXIgZG9lc24ndC4gVHVybnMgb3V0IGluY2x1ZGluZyB0aGUgZGFuZ2xpbmcgY29tbWEgeWllbGRzIHRoZSBuaWNlc3Qgb3V0cHV0OlxuanNvbkRpZmYudXNlTG9uZ2VzdFRva2VuID0gdHJ1ZTtcblxuanNvbkRpZmYudG9rZW5pemUgPSBsaW5lRGlmZi50b2tlbml6ZTtcbmpzb25EaWZmLmNhc3RJbnB1dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGNvbnN0IHt1bmRlZmluZWRSZXBsYWNlbWVudCwgc3RyaW5naWZ5UmVwbGFjZXIgPSAoaywgdikgPT4gdHlwZW9mIHYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkUmVwbGFjZW1lbnQgOiB2fSA9IHRoaXMub3B0aW9ucztcblxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogSlNPTi5zdHJpbmdpZnkoY2Fub25pY2FsaXplKHZhbHVlLCBudWxsLCBudWxsLCBzdHJpbmdpZnlSZXBsYWNlciksIHN0cmluZ2lmeVJlcGxhY2VyLCAnICAnKTtcbn07XG5qc29uRGlmZi5lcXVhbHMgPSBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICByZXR1cm4gRGlmZi5wcm90b3R5cGUuZXF1YWxzLmNhbGwoanNvbkRpZmYsIGxlZnQucmVwbGFjZSgvLChbXFxyXFxuXSkvZywgJyQxJyksIHJpZ2h0LnJlcGxhY2UoLywoW1xcclxcbl0pL2csICckMScpKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmSnNvbihvbGRPYmosIG5ld09iaiwgb3B0aW9ucykgeyByZXR1cm4ganNvbkRpZmYuZGlmZihvbGRPYmosIG5ld09iaiwgb3B0aW9ucyk7IH1cblxuLy8gVGhpcyBmdW5jdGlvbiBoYW5kbGVzIHRoZSBwcmVzZW5jZSBvZiBjaXJjdWxhciByZWZlcmVuY2VzIGJ5IGJhaWxpbmcgb3V0IHdoZW4gZW5jb3VudGVyaW5nIGFuXG4vLyBvYmplY3QgdGhhdCBpcyBhbHJlYWR5IG9uIHRoZSBcInN0YWNrXCIgb2YgaXRlbXMgYmVpbmcgcHJvY2Vzc2VkLiBBY2NlcHRzIGFuIG9wdGlvbmFsIHJlcGxhY2VyXG5leHBvcnQgZnVuY3Rpb24gY2Fub25pY2FsaXplKG9iaiwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBrZXkpIHtcbiAgc3RhY2sgPSBzdGFjayB8fCBbXTtcbiAgcmVwbGFjZW1lbnRTdGFjayA9IHJlcGxhY2VtZW50U3RhY2sgfHwgW107XG5cbiAgaWYgKHJlcGxhY2VyKSB7XG4gICAgb2JqID0gcmVwbGFjZXIoa2V5LCBvYmopO1xuICB9XG5cbiAgbGV0IGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKHN0YWNrW2ldID09PSBvYmopIHtcbiAgICAgIHJldHVybiByZXBsYWNlbWVudFN0YWNrW2ldO1xuICAgIH1cbiAgfVxuXG4gIGxldCBjYW5vbmljYWxpemVkT2JqO1xuXG4gIGlmICgnW29iamVjdCBBcnJheV0nID09PSBvYmplY3RQcm90b3R5cGVUb1N0cmluZy5jYWxsKG9iaikpIHtcbiAgICBzdGFjay5wdXNoKG9iaik7XG4gICAgY2Fub25pY2FsaXplZE9iaiA9IG5ldyBBcnJheShvYmoubGVuZ3RoKTtcbiAgICByZXBsYWNlbWVudFN0YWNrLnB1c2goY2Fub25pY2FsaXplZE9iaik7XG4gICAgZm9yIChpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY2Fub25pY2FsaXplZE9ialtpXSA9IGNhbm9uaWNhbGl6ZShvYmpbaV0sIHN0YWNrLCByZXBsYWNlbWVudFN0YWNrLCByZXBsYWNlciwga2V5KTtcbiAgICB9XG4gICAgc3RhY2sucG9wKCk7XG4gICAgcmVwbGFjZW1lbnRTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcbiAgfVxuXG4gIGlmIChvYmogJiYgb2JqLnRvSlNPTikge1xuICAgIG9iaiA9IG9iai50b0pTT04oKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcbiAgICBzdGFjay5wdXNoKG9iaik7XG4gICAgY2Fub25pY2FsaXplZE9iaiA9IHt9O1xuICAgIHJlcGxhY2VtZW50U3RhY2sucHVzaChjYW5vbmljYWxpemVkT2JqKTtcbiAgICBsZXQgc29ydGVkS2V5cyA9IFtdLFxuICAgICAgICBrZXk7XG4gICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHNvcnRlZEtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3J0ZWRLZXlzLnNvcnQoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc29ydGVkS2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAga2V5ID0gc29ydGVkS2V5c1tpXTtcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmpba2V5XSA9IGNhbm9uaWNhbGl6ZShvYmpba2V5XSwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBrZXkpO1xuICAgIH1cbiAgICBzdGFjay5wb3AoKTtcbiAgICByZXBsYWNlbWVudFN0YWNrLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBvYmo7XG4gIH1cbiAgcmV0dXJuIGNhbm9uaWNhbGl6ZWRPYmo7XG59XG4iXX0=\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL2RpZmYvanNvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEIsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyw2RUFBUTtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLG1CQUFPLENBQUMsNkVBQVE7QUFDeEI7QUFDQTs7QUFFQSxpRUFBaUUsdUNBQXVDOztBQUV4Ryx3QkFBd0IsMkJBQTJCLDJFQUEyRSxrQ0FBa0Msd0JBQXdCLE9BQU8sa0NBQWtDLG1JQUFtSTs7QUFFcFc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9ub2RlX21vZHVsZXMvZGlmZi9saWIvZGlmZi9qc29uLmpzPzMzMWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRpZmZKc29uID0gZGlmZkpzb247XG5leHBvcnRzLmNhbm9uaWNhbGl6ZSA9IGNhbm9uaWNhbGl6ZTtcbmV4cG9ydHMuanNvbkRpZmYgPSB2b2lkIDA7XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG52YXJcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9iYXNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9iYXNlXCIpKVxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbjtcblxudmFyXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5fbGluZSA9IHJlcXVpcmUoXCIuL2xpbmVcIilcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbnZhciBvYmplY3RQcm90b3R5cGVUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIganNvbkRpZmYgPSBuZXdcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9iYXNlXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuW1xuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXCJkZWZhdWx0XCJcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5dKCk7IC8vIERpc2NyaW1pbmF0ZSBiZXR3ZWVuIHR3byBsaW5lcyBvZiBwcmV0dHktcHJpbnRlZCwgc2VyaWFsaXplZCBKU09OIHdoZXJlIG9uZSBvZiB0aGVtIGhhcyBhXG4vLyBkYW5nbGluZyBjb21tYSBhbmQgdGhlIG90aGVyIGRvZXNuJ3QuIFR1cm5zIG91dCBpbmNsdWRpbmcgdGhlIGRhbmdsaW5nIGNvbW1hIHlpZWxkcyB0aGUgbmljZXN0IG91dHB1dDpcblxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuZXhwb3J0cy5qc29uRGlmZiA9IGpzb25EaWZmO1xuXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuanNvbkRpZmYudXNlTG9uZ2VzdFRva2VuID0gdHJ1ZTtcbmpzb25EaWZmLnRva2VuaXplID1cbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9saW5lXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuLlxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xubGluZURpZmZcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4udG9rZW5pemU7XG5cbmpzb25EaWZmLmNhc3RJbnB1dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gIHZhciBfdGhpcyRvcHRpb25zID1cbiAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgdGhpcy5vcHRpb25zLFxuICAgICAgdW5kZWZpbmVkUmVwbGFjZW1lbnQgPSBfdGhpcyRvcHRpb25zLnVuZGVmaW5lZFJlcGxhY2VtZW50LFxuICAgICAgX3RoaXMkb3B0aW9ucyRzdHJpbmdpID0gX3RoaXMkb3B0aW9ucy5zdHJpbmdpZnlSZXBsYWNlcixcbiAgICAgIHN0cmluZ2lmeVJlcGxhY2VyID0gX3RoaXMkb3B0aW9ucyRzdHJpbmdpID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoaywgdilcbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICB0eXBlb2YgdiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWRSZXBsYWNlbWVudCA6IHZcbiAgICApO1xuICB9IDogX3RoaXMkb3B0aW9ucyRzdHJpbmdpO1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogSlNPTi5zdHJpbmdpZnkoY2Fub25pY2FsaXplKHZhbHVlLCBudWxsLCBudWxsLCBzdHJpbmdpZnlSZXBsYWNlciksIHN0cmluZ2lmeVJlcGxhY2VyLCAnICAnKTtcbn07XG5cbmpzb25EaWZmLmVxdWFscyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICByZXR1cm4gKFxuICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICBfYmFzZVxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgW1xuICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICBcImRlZmF1bHRcIlxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgXS5wcm90b3R5cGUuZXF1YWxzLmNhbGwoanNvbkRpZmYsIGxlZnQucmVwbGFjZSgvLChbXFxyXFxuXSkvZywgJyQxJyksIHJpZ2h0LnJlcGxhY2UoLywoW1xcclxcbl0pL2csICckMScpKVxuICApO1xufTtcblxuZnVuY3Rpb24gZGlmZkpzb24ob2xkT2JqLCBuZXdPYmosIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGpzb25EaWZmLmRpZmYob2xkT2JqLCBuZXdPYmosIG9wdGlvbnMpO1xufSAvLyBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgdGhlIHByZXNlbmNlIG9mIGNpcmN1bGFyIHJlZmVyZW5jZXMgYnkgYmFpbGluZyBvdXQgd2hlbiBlbmNvdW50ZXJpbmcgYW5cbi8vIG9iamVjdCB0aGF0IGlzIGFscmVhZHkgb24gdGhlIFwic3RhY2tcIiBvZiBpdGVtcyBiZWluZyBwcm9jZXNzZWQuIEFjY2VwdHMgYW4gb3B0aW9uYWwgcmVwbGFjZXJcblxuXG5mdW5jdGlvbiBjYW5vbmljYWxpemUob2JqLCBzdGFjaywgcmVwbGFjZW1lbnRTdGFjaywgcmVwbGFjZXIsIGtleSkge1xuICBzdGFjayA9IHN0YWNrIHx8IFtdO1xuICByZXBsYWNlbWVudFN0YWNrID0gcmVwbGFjZW1lbnRTdGFjayB8fCBbXTtcblxuICBpZiAocmVwbGFjZXIpIHtcbiAgICBvYmogPSByZXBsYWNlcihrZXksIG9iaik7XG4gIH1cblxuICB2YXIgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoc3RhY2tbaV0gPT09IG9iaikge1xuICAgICAgcmV0dXJuIHJlcGxhY2VtZW50U3RhY2tbaV07XG4gICAgfVxuICB9XG5cbiAgdmFyIGNhbm9uaWNhbGl6ZWRPYmo7XG5cbiAgaWYgKCdbb2JqZWN0IEFycmF5XScgPT09IG9iamVjdFByb3RvdHlwZVRvU3RyaW5nLmNhbGwob2JqKSkge1xuICAgIHN0YWNrLnB1c2gob2JqKTtcbiAgICBjYW5vbmljYWxpemVkT2JqID0gbmV3IEFycmF5KG9iai5sZW5ndGgpO1xuICAgIHJlcGxhY2VtZW50U3RhY2sucHVzaChjYW5vbmljYWxpemVkT2JqKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmpbaV0gPSBjYW5vbmljYWxpemUob2JqW2ldLCBzdGFjaywgcmVwbGFjZW1lbnRTdGFjaywgcmVwbGFjZXIsIGtleSk7XG4gICAgfVxuXG4gICAgc3RhY2sucG9wKCk7XG4gICAgcmVwbGFjZW1lbnRTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcbiAgfVxuXG4gIGlmIChvYmogJiYgb2JqLnRvSlNPTikge1xuICAgIG9iaiA9IG9iai50b0pTT04oKTtcbiAgfVxuXG4gIGlmIChcbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICBfdHlwZW9mKFxuICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICBvYmopID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcbiAgICBzdGFjay5wdXNoKG9iaik7XG4gICAgY2Fub25pY2FsaXplZE9iaiA9IHt9O1xuICAgIHJlcGxhY2VtZW50U3RhY2sucHVzaChjYW5vbmljYWxpemVkT2JqKTtcblxuICAgIHZhciBzb3J0ZWRLZXlzID0gW10sXG4gICAgICAgIF9rZXk7XG5cbiAgICBmb3IgKF9rZXkgaW4gb2JqKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShfa2V5KSkge1xuICAgICAgICBzb3J0ZWRLZXlzLnB1c2goX2tleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc29ydGVkS2V5cy5zb3J0KCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc29ydGVkS2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgX2tleSA9IHNvcnRlZEtleXNbaV07XG4gICAgICBjYW5vbmljYWxpemVkT2JqW19rZXldID0gY2Fub25pY2FsaXplKG9ialtfa2V5XSwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBfa2V5KTtcbiAgICB9XG5cbiAgICBzdGFjay5wb3AoKTtcbiAgICByZXBsYWNlbWVudFN0YWNrLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBvYmo7XG4gIH1cblxuICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWthV1ptTDJwemIyNHVhbk1pWFN3aWJtRnRaWE1pT2xzaWIySnFaV04wVUhKdmRHOTBlWEJsVkc5VGRISnBibWNpTENKUFltcGxZM1FpTENKd2NtOTBiM1I1Y0dVaUxDSjBiMU4wY21sdVp5SXNJbXB6YjI1RWFXWm1JaXdpUkdsbVppSXNJblZ6WlV4dmJtZGxjM1JVYjJ0bGJpSXNJblJ2YTJWdWFYcGxJaXdpYkdsdVpVUnBabVlpTENKallYTjBTVzV3ZFhRaUxDSjJZV3gxWlNJc0ltOXdkR2x2Ym5NaUxDSjFibVJsWm1sdVpXUlNaWEJzWVdObGJXVnVkQ0lzSW5OMGNtbHVaMmxtZVZKbGNHeGhZMlZ5SWl3aWF5SXNJbllpTENKS1UwOU9JaXdpYzNSeWFXNW5hV1o1SWl3aVkyRnViMjVwWTJGc2FYcGxJaXdpWlhGMVlXeHpJaXdpYkdWbWRDSXNJbkpwWjJoMElpd2lZMkZzYkNJc0luSmxjR3hoWTJVaUxDSmthV1ptU25OdmJpSXNJbTlzWkU5aWFpSXNJbTVsZDA5aWFpSXNJbVJwWm1ZaUxDSnZZbW9pTENKemRHRmpheUlzSW5KbGNHeGhZMlZ0Wlc1MFUzUmhZMnNpTENKeVpYQnNZV05sY2lJc0ltdGxlU0lzSW1raUxDSnNaVzVuZEdnaUxDSmpZVzV2Ym1sallXeHBlbVZrVDJKcUlpd2ljSFZ6YUNJc0lrRnljbUY1SWl3aWNHOXdJaXdpZEc5S1UwOU9JaXdpYzI5eWRHVmtTMlY1Y3lJc0ltaGhjMDkzYmxCeWIzQmxjblI1SWl3aWMyOXlkQ0pkTENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN096czdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk96dEJRVU5CTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN096czdPenM3UVVGRlFTeEpRVUZOUVN4MVFrRkJkVUlzUjBGQlIwTXNUVUZCVFN4RFFVRkRReXhUUVVGUUxFTkJRV2xDUXl4UlFVRnFSRHRCUVVkUExFbEJRVTFETEZGQlFWRXNSMEZCUnp0QlFVRkpRenRCUVVGQlFUdEJRVUZCUVR0QlFVRkJRVHRCUVVGQlFUdEJRVUZCUVR0QlFVRkJRVHRCUVVGQlFTeERRVUZLTEVWQlFXcENMRU1zUTBGRFVEdEJRVU5CT3pzN096czdRVUZEUVVRc1VVRkJVU3hEUVVGRFJTeGxRVUZVTEVkQlFUSkNMRWxCUVROQ08wRkJSVUZHTEZGQlFWRXNRMEZCUTBjc1VVRkJWRHRCUVVGdlFrTTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFUdEJRVUZCTEVOQlFWTkVMRkZCUVRkQ096dEJRVU5CU0N4UlFVRlJMRU5CUVVOTExGTkJRVlFzUjBGQmNVSXNWVUZCVTBNc1MwRkJWQ3hGUVVGblFqdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVTXJSU3hQUVVGTFF5eFBRVVJ3Ump0QlFVRkJMRTFCUXpWQ1F5eHZRa0ZFTkVJc2FVSkJRelZDUVN4dlFrRkVORUk3UVVGQlFTdzBRMEZEVGtNc2FVSkJSRTA3UVVGQlFTeE5RVU5PUVN4cFFrRkVUU3h6UTBGRFl5eFZRVUZEUXl4RFFVRkVMRVZCUVVsRExFTkJRVW83UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRlZMR0ZCUVU5QkxFTkJRVkFzUzBGQllTeFhRVUZpTEVkQlFUSkNTQ3h2UWtGQk0wSXNSMEZCYTBSSE8wRkJRVFZFTzBGQlFVRXNSMEZFWkR0QlFVZHVReXhUUVVGUExFOUJRVTlNTEV0QlFWQXNTMEZCYVVJc1VVRkJha0lzUjBGQk5FSkJMRXRCUVRWQ0xFZEJRVzlEVFN4SlFVRkpMRU5CUVVORExGTkJRVXdzUTBGQlpVTXNXVUZCV1N4RFFVRkRVaXhMUVVGRUxFVkJRVkVzU1VGQlVpeEZRVUZqTEVsQlFXUXNSVUZCYjBKSExHbENRVUZ3UWl4RFFVRXpRaXhGUVVGdFJVRXNhVUpCUVc1RkxFVkJRWE5HTEVsQlFYUkdMRU5CUVRORE8wRkJRMFFzUTBGS1JEczdRVUZMUVZRc1VVRkJVU3hEUVVGRFpTeE5RVUZVTEVkQlFXdENMRlZCUVZORExFbEJRVlFzUlVGQlpVTXNTMEZCWml4RlFVRnpRanRCUVVOMFF5eFRRVUZQYUVJN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRXNUVUZCUzBnc1UwRkJUQ3hEUVVGbGFVSXNUVUZCWml4RFFVRnpRa2NzU1VGQmRFSXNRMEZCTWtKc1FpeFJRVUV6UWl4RlFVRnhRMmRDTEVsQlFVa3NRMEZCUTBjc1QwRkJUQ3hEUVVGaExGbEJRV0lzUlVGQk1rSXNTVUZCTTBJc1EwRkJja01zUlVGQmRVVkdMRXRCUVVzc1EwRkJRMFVzVDBGQlRpeERRVUZqTEZsQlFXUXNSVUZCTkVJc1NVRkJOVUlzUTBGQmRrVTdRVUZCVUR0QlFVTkVMRU5CUmtRN08wRkJTVThzVTBGQlUwTXNVVUZCVkN4RFFVRnJRa01zVFVGQmJFSXNSVUZCTUVKRExFMUJRVEZDTEVWQlFXdERaaXhQUVVGc1F5eEZRVUV5UXp0QlFVRkZMRk5CUVU5UUxGRkJRVkVzUTBGQlEzVkNMRWxCUVZRc1EwRkJZMFlzVFVGQlpDeEZRVUZ6UWtNc1RVRkJkRUlzUlVGQk9FSm1MRTlCUVRsQ0xFTkJRVkE3UVVGQlowUXNReXhEUVVWd1J6dEJRVU5CT3pzN1FVRkRUeXhUUVVGVFR5eFpRVUZVTEVOQlFYTkNWU3hIUVVGMFFpeEZRVUV5UWtNc1MwRkJNMElzUlVGQmEwTkRMR2RDUVVGc1F5eEZRVUZ2UkVNc1VVRkJjRVFzUlVGQk9FUkRMRWRCUVRsRUxFVkJRVzFGTzBGQlEzaEZTQ3hGUVVGQlFTeExRVUZMTEVkQlFVZEJMRXRCUVVzc1NVRkJTU3hGUVVGcVFqdEJRVU5CUXl4RlFVRkJRU3huUWtGQlowSXNSMEZCUjBFc1owSkJRV2RDTEVsQlFVa3NSVUZCZGtNN08wRkJSVUVzVFVGQlNVTXNVVUZCU2l4RlFVRmpPMEZCUTFwSUxFbEJRVUZCTEVkQlFVY3NSMEZCUjBjc1VVRkJVU3hEUVVGRFF5eEhRVUZFTEVWQlFVMUtMRWRCUVU0c1EwRkJaRHRCUVVORU96dEJRVVZFTEUxQlFVbExMRU5CUVVvN08wRkJSVUVzVDBGQlMwRXNRMEZCUXl4SFFVRkhMRU5CUVZRc1JVRkJXVUVzUTBGQlF5eEhRVUZIU2l4TFFVRkxMRU5CUVVOTExFMUJRWFJDTEVWQlFUaENSQ3hEUVVGRExFbEJRVWtzUTBGQmJrTXNSVUZCYzBNN1FVRkRjRU1zVVVGQlNVb3NTMEZCU3l4RFFVRkRTU3hEUVVGRUxFTkJRVXdzUzBGQllVd3NSMEZCYWtJc1JVRkJjMEk3UVVGRGNFSXNZVUZCVDBVc1owSkJRV2RDTEVOQlFVTkhMRU5CUVVRc1EwRkJka0k3UVVGRFJEdEJRVU5HT3p0QlFVVkVMRTFCUVVsRkxHZENRVUZLT3p0QlFVVkJMRTFCUVVrc2NVSkJRWEZDYmtNc2RVSkJRWFZDTEVOQlFVTnpRaXhKUVVGNFFpeERRVUUyUWswc1IwRkJOMElzUTBGQmVrSXNSVUZCTkVRN1FVRkRNVVJETEVsQlFVRkJMRXRCUVVzc1EwRkJRMDhzU1VGQlRpeERRVUZYVWl4SFFVRllPMEZCUTBGUExFbEJRVUZCTEdkQ1FVRm5RaXhIUVVGSExFbEJRVWxGTEV0QlFVb3NRMEZCVlZRc1IwRkJSeXhEUVVGRFRTeE5RVUZrTEVOQlFXNUNPMEZCUTBGS0xFbEJRVUZCTEdkQ1FVRm5RaXhEUVVGRFRTeEpRVUZxUWl4RFFVRnpRa1FzWjBKQlFYUkNPenRCUVVOQkxGTkJRVXRHTEVOQlFVTXNSMEZCUnl4RFFVRlVMRVZCUVZsQkxFTkJRVU1zUjBGQlIwd3NSMEZCUnl4RFFVRkRUU3hOUVVGd1FpeEZRVUUwUWtRc1EwRkJReXhKUVVGSkxFTkJRV3BETEVWQlFXOURPMEZCUTJ4RFJTeE5RVUZCUVN4blFrRkJaMElzUTBGQlEwWXNRMEZCUkN4RFFVRm9RaXhIUVVGelFtWXNXVUZCV1N4RFFVRkRWU3hIUVVGSExFTkJRVU5MTEVOQlFVUXNRMEZCU2l4RlFVRlRTaXhMUVVGVUxFVkJRV2RDUXl4blFrRkJhRUlzUlVGQmEwTkRMRkZCUVd4RExFVkJRVFJEUXl4SFFVRTFReXhEUVVGc1F6dEJRVU5FT3p0QlFVTkVTQ3hKUVVGQlFTeExRVUZMTEVOQlFVTlRMRWRCUVU0N1FVRkRRVklzU1VGQlFVRXNaMEpCUVdkQ0xFTkJRVU5STEVkQlFXcENPMEZCUTBFc1YwRkJUMGdzWjBKQlFWQTdRVUZEUkRzN1FVRkZSQ3hOUVVGSlVDeEhRVUZITEVsQlFVbEJMRWRCUVVjc1EwRkJRMWNzVFVGQlppeEZRVUYxUWp0QlFVTnlRbGdzU1VGQlFVRXNSMEZCUnl4SFFVRkhRU3hIUVVGSExFTkJRVU5YTEUxQlFVb3NSVUZCVGp0QlFVTkVPenRCUVVWRU8wRkJRVWs3UVVGQlFUdEJRVUZCTzBGQlFVOVlMRVZCUVVGQkxFZEJRVkFzVFVGQlpTeFJRVUZtTEVsQlFUSkNRU3hIUVVGSExFdEJRVXNzU1VGQmRrTXNSVUZCTmtNN1FVRkRNME5ETEVsQlFVRkJMRXRCUVVzc1EwRkJRMDhzU1VGQlRpeERRVUZYVWl4SFFVRllPMEZCUTBGUExFbEJRVUZCTEdkQ1FVRm5RaXhIUVVGSExFVkJRVzVDTzBGQlEwRk1MRWxCUVVGQkxHZENRVUZuUWl4RFFVRkRUU3hKUVVGcVFpeERRVUZ6UWtRc1owSkJRWFJDT3p0QlFVTkJMRkZCUVVsTExGVkJRVlVzUjBGQlJ5eEZRVUZxUWp0QlFVRkJMRkZCUTBsU0xFbEJSRW83TzBGQlJVRXNVMEZCUzBFc1NVRkJUQ3hKUVVGWlNpeEhRVUZhTEVWQlFXbENPMEZCUTJZN1FVRkRRU3hWUVVGSlFTeEhRVUZITEVOQlFVTmhMR05CUVVvc1EwRkJiVUpVTEVsQlFXNUNMRU5CUVVvc1JVRkJOa0k3UVVGRE0wSlJMRkZCUVVGQkxGVkJRVlVzUTBGQlEwb3NTVUZCV0N4RFFVRm5Ra29zU1VGQmFFSTdRVUZEUkR0QlFVTkdPenRCUVVORVVTeEpRVUZCUVN4VlFVRlZMRU5CUVVORkxFbEJRVmc3TzBGQlEwRXNVMEZCUzFRc1EwRkJReXhIUVVGSExFTkJRVlFzUlVGQldVRXNRMEZCUXl4SFFVRkhUeXhWUVVGVkxFTkJRVU5PTEUxQlFUTkNMRVZCUVcxRFJDeERRVUZETEVsQlFVa3NRMEZCZUVNc1JVRkJNa003UVVGRGVrTkVMRTFCUVVGQkxFbEJRVWNzUjBGQlIxRXNWVUZCVlN4RFFVRkRVQ3hEUVVGRUxFTkJRV2hDTzBGQlEwRkZMRTFCUVVGQkxHZENRVUZuUWl4RFFVRkRTQ3hKUVVGRUxFTkJRV2hDTEVkQlFYZENaQ3haUVVGWkxFTkJRVU5WTEVkQlFVY3NRMEZCUTBrc1NVRkJSQ3hEUVVGS0xFVkJRVmRJTEV0QlFWZ3NSVUZCYTBKRExHZENRVUZzUWl4RlFVRnZRME1zVVVGQmNFTXNSVUZCT0VORExFbEJRVGxETEVOQlFYQkRPMEZCUTBRN08wRkJRMFJJTEVsQlFVRkJMRXRCUVVzc1EwRkJRMU1zUjBGQlRqdEJRVU5CVWl4SlFVRkJRU3huUWtGQlowSXNRMEZCUTFFc1IwRkJha0k3UVVGRFJDeEhRVzVDUkN4TlFXMUNUenRCUVVOTVNDeEpRVUZCUVN4blFrRkJaMElzUjBGQlIxQXNSMEZCYmtJN1FVRkRSRHM3UVVGRFJDeFRRVUZQVHl4blFrRkJVRHRCUVVORUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lhVzF3YjNKMElFUnBabVlnWm5KdmJTQW5MaTlpWVhObEp6dGNibWx0Y0c5eWRDQjdiR2x1WlVScFptWjlJR1p5YjIwZ0p5NHZiR2x1WlNjN1hHNWNibU52Ym5OMElHOWlhbVZqZEZCeWIzUnZkSGx3WlZSdlUzUnlhVzVuSUQwZ1QySnFaV04wTG5CeWIzUnZkSGx3WlM1MGIxTjBjbWx1Wnp0Y2JseHVYRzVsZUhCdmNuUWdZMjl1YzNRZ2FuTnZia1JwWm1ZZ1BTQnVaWGNnUkdsbVppZ3BPMXh1THk4Z1JHbHpZM0pwYldsdVlYUmxJR0psZEhkbFpXNGdkSGR2SUd4cGJtVnpJRzltSUhCeVpYUjBlUzF3Y21sdWRHVmtMQ0J6WlhKcFlXeHBlbVZrSUVwVFQwNGdkMmhsY21VZ2IyNWxJRzltSUhSb1pXMGdhR0Z6SUdGY2JpOHZJR1JoYm1kc2FXNW5JR052YlcxaElHRnVaQ0IwYUdVZ2IzUm9aWElnWkc5bGMyNG5kQzRnVkhWeWJuTWdiM1YwSUdsdVkyeDFaR2x1WnlCMGFHVWdaR0Z1WjJ4cGJtY2dZMjl0YldFZ2VXbGxiR1J6SUhSb1pTQnVhV05sYzNRZ2IzVjBjSFYwT2x4dWFuTnZia1JwWm1ZdWRYTmxURzl1WjJWemRGUnZhMlZ1SUQwZ2RISjFaVHRjYmx4dWFuTnZia1JwWm1ZdWRHOXJaVzVwZW1VZ1BTQnNhVzVsUkdsbVppNTBiMnRsYm1sNlpUdGNibXB6YjI1RWFXWm1MbU5oYzNSSmJuQjFkQ0E5SUdaMWJtTjBhVzl1S0haaGJIVmxLU0I3WEc0Z0lHTnZibk4wSUh0MWJtUmxabWx1WldSU1pYQnNZV05sYldWdWRDd2djM1J5YVc1bmFXWjVVbVZ3YkdGalpYSWdQU0FvYXl3Z2Rpa2dQVDRnZEhsd1pXOW1JSFlnUFQwOUlDZDFibVJsWm1sdVpXUW5JRDhnZFc1a1pXWnBibVZrVW1Wd2JHRmpaVzFsYm5RZ09pQjJmU0E5SUhSb2FYTXViM0IwYVc5dWN6dGNibHh1SUNCeVpYUjFjbTRnZEhsd1pXOW1JSFpoYkhWbElEMDlQU0FuYzNSeWFXNW5KeUEvSUhaaGJIVmxJRG9nU2xOUFRpNXpkSEpwYm1kcFpua29ZMkZ1YjI1cFkyRnNhWHBsS0haaGJIVmxMQ0J1ZFd4c0xDQnVkV3hzTENCemRISnBibWRwWm5sU1pYQnNZV05sY2lrc0lITjBjbWx1WjJsbWVWSmxjR3hoWTJWeUxDQW5JQ0FuS1R0Y2JuMDdYRzVxYzI5dVJHbG1aaTVsY1hWaGJITWdQU0JtZFc1amRHbHZiaWhzWldaMExDQnlhV2RvZENrZ2UxeHVJQ0J5WlhSMWNtNGdSR2xtWmk1d2NtOTBiM1I1Y0dVdVpYRjFZV3h6TG1OaGJHd29hbk52YmtScFptWXNJR3hsWm5RdWNtVndiR0ZqWlNndkxDaGJYRnh5WEZ4dVhTa3ZaeXdnSnlReEp5a3NJSEpwWjJoMExuSmxjR3hoWTJVb0x5d29XMXhjY2x4Y2JsMHBMMmNzSUNja01TY3BLVHRjYm4wN1hHNWNibVY0Y0c5eWRDQm1kVzVqZEdsdmJpQmthV1ptU25OdmJpaHZiR1JQWW1vc0lHNWxkMDlpYWl3Z2IzQjBhVzl1Y3lrZ2V5QnlaWFIxY200Z2FuTnZia1JwWm1ZdVpHbG1aaWh2YkdSUFltb3NJRzVsZDA5aWFpd2diM0IwYVc5dWN5azdJSDFjYmx4dUx5OGdWR2hwY3lCbWRXNWpkR2x2YmlCb1lXNWtiR1Z6SUhSb1pTQndjbVZ6Wlc1alpTQnZaaUJqYVhKamRXeGhjaUJ5WldabGNtVnVZMlZ6SUdKNUlHSmhhV3hwYm1jZ2IzVjBJSGRvWlc0Z1pXNWpiM1Z1ZEdWeWFXNW5JR0Z1WEc0dkx5QnZZbXBsWTNRZ2RHaGhkQ0JwY3lCaGJISmxZV1I1SUc5dUlIUm9aU0JjSW5OMFlXTnJYQ0lnYjJZZ2FYUmxiWE1nWW1WcGJtY2djSEp2WTJWemMyVmtMaUJCWTJObGNIUnpJR0Z1SUc5d2RHbHZibUZzSUhKbGNHeGhZMlZ5WEc1bGVIQnZjblFnWm5WdVkzUnBiMjRnWTJGdWIyNXBZMkZzYVhwbEtHOWlhaXdnYzNSaFkyc3NJSEpsY0d4aFkyVnRaVzUwVTNSaFkyc3NJSEpsY0d4aFkyVnlMQ0JyWlhrcElIdGNiaUFnYzNSaFkyc2dQU0J6ZEdGamF5QjhmQ0JiWFR0Y2JpQWdjbVZ3YkdGalpXMWxiblJUZEdGamF5QTlJSEpsY0d4aFkyVnRaVzUwVTNSaFkyc2dmSHdnVzEwN1hHNWNiaUFnYVdZZ0tISmxjR3hoWTJWeUtTQjdYRzRnSUNBZ2IySnFJRDBnY21Wd2JHRmpaWElvYTJWNUxDQnZZbW9wTzF4dUlDQjlYRzVjYmlBZ2JHVjBJR2s3WEc1Y2JpQWdabTl5SUNocElEMGdNRHNnYVNBOElITjBZV05yTG14bGJtZDBhRHNnYVNBclBTQXhLU0I3WEc0Z0lDQWdhV1lnS0hOMFlXTnJXMmxkSUQwOVBTQnZZbW9wSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJ5WlhCc1lXTmxiV1Z1ZEZOMFlXTnJXMmxkTzF4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUd4bGRDQmpZVzV2Ym1sallXeHBlbVZrVDJKcU8xeHVYRzRnSUdsbUlDZ25XMjlpYW1WamRDQkJjbkpoZVYwbklEMDlQU0J2WW1wbFkzUlFjbTkwYjNSNWNHVlViMU4wY21sdVp5NWpZV3hzS0c5aWFpa3BJSHRjYmlBZ0lDQnpkR0ZqYXk1d2RYTm9LRzlpYWlrN1hHNGdJQ0FnWTJGdWIyNXBZMkZzYVhwbFpFOWlhaUE5SUc1bGR5QkJjbkpoZVNodlltb3ViR1Z1WjNSb0tUdGNiaUFnSUNCeVpYQnNZV05sYldWdWRGTjBZV05yTG5CMWMyZ29ZMkZ1YjI1cFkyRnNhWHBsWkU5aWFpazdYRzRnSUNBZ1ptOXlJQ2hwSUQwZ01Ec2dhU0E4SUc5aWFpNXNaVzVuZEdnN0lHa2dLejBnTVNrZ2UxeHVJQ0FnSUNBZ1kyRnViMjVwWTJGc2FYcGxaRTlpYWx0cFhTQTlJR05oYm05dWFXTmhiR2w2WlNodlltcGJhVjBzSUhOMFlXTnJMQ0J5WlhCc1lXTmxiV1Z1ZEZOMFlXTnJMQ0J5WlhCc1lXTmxjaXdnYTJWNUtUdGNiaUFnSUNCOVhHNGdJQ0FnYzNSaFkyc3VjRzl3S0NrN1hHNGdJQ0FnY21Wd2JHRmpaVzFsYm5SVGRHRmpheTV3YjNBb0tUdGNiaUFnSUNCeVpYUjFjbTRnWTJGdWIyNXBZMkZzYVhwbFpFOWlhanRjYmlBZ2ZWeHVYRzRnSUdsbUlDaHZZbW9nSmlZZ2IySnFMblJ2U2xOUFRpa2dlMXh1SUNBZ0lHOWlhaUE5SUc5aWFpNTBiMHBUVDA0b0tUdGNiaUFnZlZ4dVhHNGdJR2xtSUNoMGVYQmxiMllnYjJKcUlEMDlQU0FuYjJKcVpXTjBKeUFtSmlCdlltb2dJVDA5SUc1MWJHd3BJSHRjYmlBZ0lDQnpkR0ZqYXk1d2RYTm9LRzlpYWlrN1hHNGdJQ0FnWTJGdWIyNXBZMkZzYVhwbFpFOWlhaUE5SUh0OU8xeHVJQ0FnSUhKbGNHeGhZMlZ0Wlc1MFUzUmhZMnN1Y0hWemFDaGpZVzV2Ym1sallXeHBlbVZrVDJKcUtUdGNiaUFnSUNCc1pYUWdjMjl5ZEdWa1MyVjVjeUE5SUZ0ZExGeHVJQ0FnSUNBZ0lDQnJaWGs3WEc0Z0lDQWdabTl5SUNoclpYa2dhVzRnYjJKcUtTQjdYRzRnSUNBZ0lDQXZLaUJwYzNSaGJtSjFiQ0JwWjI1dmNtVWdaV3h6WlNBcUwxeHVJQ0FnSUNBZ2FXWWdLRzlpYWk1b1lYTlBkMjVRY205d1pYSjBlU2hyWlhrcEtTQjdYRzRnSUNBZ0lDQWdJSE52Y25SbFpFdGxlWE11Y0hWemFDaHJaWGtwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmlBZ0lDQnpiM0owWldSTFpYbHpMbk52Y25Rb0tUdGNiaUFnSUNCbWIzSWdLR2tnUFNBd095QnBJRHdnYzI5eWRHVmtTMlY1Y3k1c1pXNW5kR2c3SUdrZ0t6MGdNU2tnZTF4dUlDQWdJQ0FnYTJWNUlEMGdjMjl5ZEdWa1MyVjVjMXRwWFR0Y2JpQWdJQ0FnSUdOaGJtOXVhV05oYkdsNlpXUlBZbXBiYTJWNVhTQTlJR05oYm05dWFXTmhiR2w2WlNodlltcGJhMlY1WFN3Z2MzUmhZMnNzSUhKbGNHeGhZMlZ0Wlc1MFUzUmhZMnNzSUhKbGNHeGhZMlZ5TENCclpYa3BPMXh1SUNBZ0lIMWNiaUFnSUNCemRHRmpheTV3YjNBb0tUdGNiaUFnSUNCeVpYQnNZV05sYldWdWRGTjBZV05yTG5CdmNDZ3BPMXh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJR05oYm05dWFXTmhiR2w2WldSUFltb2dQU0J2WW1vN1hHNGdJSDFjYmlBZ2NtVjBkWEp1SUdOaGJtOXVhV05oYkdsNlpXUlBZbW83WEc1OVhHNGlYWDA9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/line.js":
/*!***************************************************************!*\
  !*** ./node_modules/mocha/node_modules/diff/lib/diff/line.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*istanbul ignore start*/\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.diffLines = diffLines;\nexports.diffTrimmedLines = diffTrimmedLines;\nexports.lineDiff = void 0;\n\n/*istanbul ignore end*/\nvar\n/*istanbul ignore start*/\n_base = _interopRequireDefault(__webpack_require__(/*! ./base */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/base.js\"))\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_params = __webpack_require__(/*! ../util/params */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/util/params.js\")\n/*istanbul ignore end*/\n;\n\n/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/*istanbul ignore end*/\nvar lineDiff = new\n/*istanbul ignore start*/\n_base\n/*istanbul ignore end*/\n[\n/*istanbul ignore start*/\n\"default\"\n/*istanbul ignore end*/\n]();\n\n/*istanbul ignore start*/\nexports.lineDiff = lineDiff;\n\n/*istanbul ignore end*/\nlineDiff.tokenize = function (value) {\n  if (this.options.stripTrailingCr) {\n    // remove one \\r before \\n to match GNU diff's --strip-trailing-cr behavior\n    value = value.replace(/\\r\\n/g, '\\n');\n  }\n\n  var retLines = [],\n      linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  } // Merge the content and line separators into single tokens\n\n\n  for (var i = 0; i < linesAndNewlines.length; i++) {\n    var line = linesAndNewlines[i];\n\n    if (i % 2 && !this.options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      if (this.options.ignoreWhitespace) {\n        line = line.trim();\n      }\n\n      retLines.push(line);\n    }\n  }\n\n  return retLines;\n};\n\nfunction diffLines(oldStr, newStr, callback) {\n  return lineDiff.diff(oldStr, newStr, callback);\n}\n\nfunction diffTrimmedLines(oldStr, newStr, callback) {\n  var options =\n  /*istanbul ignore start*/\n  (0,\n  /*istanbul ignore end*/\n\n  /*istanbul ignore start*/\n  _params\n  /*istanbul ignore end*/\n  .\n  /*istanbul ignore start*/\n  generateOptions)\n  /*istanbul ignore end*/\n  (callback, {\n    ignoreWhitespace: true\n  });\n  return lineDiff.diff(oldStr, newStr, options);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2xpbmUuanMiXSwibmFtZXMiOlsibGluZURpZmYiLCJEaWZmIiwidG9rZW5pemUiLCJ2YWx1ZSIsIm9wdGlvbnMiLCJzdHJpcFRyYWlsaW5nQ3IiLCJyZXBsYWNlIiwicmV0TGluZXMiLCJsaW5lc0FuZE5ld2xpbmVzIiwic3BsaXQiLCJsZW5ndGgiLCJwb3AiLCJpIiwibGluZSIsIm5ld2xpbmVJc1Rva2VuIiwiaWdub3JlV2hpdGVzcGFjZSIsInRyaW0iLCJwdXNoIiwiZGlmZkxpbmVzIiwib2xkU3RyIiwibmV3U3RyIiwiY2FsbGJhY2siLCJkaWZmIiwiZGlmZlRyaW1tZWRMaW5lcyIsImdlbmVyYXRlT3B0aW9ucyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7O0FBRU8sSUFBTUEsUUFBUSxHQUFHO0FBQUlDO0FBQUFBO0FBQUFBO0FBQUFBO0FBQUFBO0FBQUFBO0FBQUFBO0FBQUFBLENBQUosRUFBakI7Ozs7OztBQUNQRCxRQUFRLENBQUNFLFFBQVQsR0FBb0IsVUFBU0MsS0FBVCxFQUFnQjtBQUNsQyxNQUFHLEtBQUtDLE9BQUwsQ0FBYUMsZUFBaEIsRUFBaUM7QUFDL0I7QUFDQUYsSUFBQUEsS0FBSyxHQUFHQSxLQUFLLENBQUNHLE9BQU4sQ0FBYyxPQUFkLEVBQXVCLElBQXZCLENBQVI7QUFDRDs7QUFFRCxNQUFJQyxRQUFRLEdBQUcsRUFBZjtBQUFBLE1BQ0lDLGdCQUFnQixHQUFHTCxLQUFLLENBQUNNLEtBQU4sQ0FBWSxXQUFaLENBRHZCLENBTmtDLENBU2xDOztBQUNBLE1BQUksQ0FBQ0QsZ0JBQWdCLENBQUNBLGdCQUFnQixDQUFDRSxNQUFqQixHQUEwQixDQUEzQixDQUFyQixFQUFvRDtBQUNsREYsSUFBQUEsZ0JBQWdCLENBQUNHLEdBQWpCO0FBQ0QsR0FaaUMsQ0FjbEM7OztBQUNBLE9BQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0osZ0JBQWdCLENBQUNFLE1BQXJDLEVBQTZDRSxDQUFDLEVBQTlDLEVBQWtEO0FBQ2hELFFBQUlDLElBQUksR0FBR0wsZ0JBQWdCLENBQUNJLENBQUQsQ0FBM0I7O0FBRUEsUUFBSUEsQ0FBQyxHQUFHLENBQUosSUFBUyxDQUFDLEtBQUtSLE9BQUwsQ0FBYVUsY0FBM0IsRUFBMkM7QUFDekNQLE1BQUFBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDRyxNQUFULEdBQWtCLENBQW5CLENBQVIsSUFBaUNHLElBQWpDO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsVUFBSSxLQUFLVCxPQUFMLENBQWFXLGdCQUFqQixFQUFtQztBQUNqQ0YsUUFBQUEsSUFBSSxHQUFHQSxJQUFJLENBQUNHLElBQUwsRUFBUDtBQUNEOztBQUNEVCxNQUFBQSxRQUFRLENBQUNVLElBQVQsQ0FBY0osSUFBZDtBQUNEO0FBQ0Y7O0FBRUQsU0FBT04sUUFBUDtBQUNELENBN0JEOztBQStCTyxTQUFTVyxTQUFULENBQW1CQyxNQUFuQixFQUEyQkMsTUFBM0IsRUFBbUNDLFFBQW5DLEVBQTZDO0FBQUUsU0FBT3JCLFFBQVEsQ0FBQ3NCLElBQVQsQ0FBY0gsTUFBZCxFQUFzQkMsTUFBdEIsRUFBOEJDLFFBQTlCLENBQVA7QUFBaUQ7O0FBQ2hHLFNBQVNFLGdCQUFULENBQTBCSixNQUExQixFQUFrQ0MsTUFBbEMsRUFBMENDLFFBQTFDLEVBQW9EO0FBQ3pELE1BQUlqQixPQUFPO0FBQUc7QUFBQTtBQUFBOztBQUFBb0I7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQTtBQUFBLEdBQWdCSCxRQUFoQixFQUEwQjtBQUFDTixJQUFBQSxnQkFBZ0IsRUFBRTtBQUFuQixHQUExQixDQUFkO0FBQ0EsU0FBT2YsUUFBUSxDQUFDc0IsSUFBVCxDQUFjSCxNQUFkLEVBQXNCQyxNQUF0QixFQUE4QmhCLE9BQTlCLENBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEaWZmIGZyb20gJy4vYmFzZSc7XG5pbXBvcnQge2dlbmVyYXRlT3B0aW9uc30gZnJvbSAnLi4vdXRpbC9wYXJhbXMnO1xuXG5leHBvcnQgY29uc3QgbGluZURpZmYgPSBuZXcgRGlmZigpO1xubGluZURpZmYudG9rZW5pemUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZih0aGlzLm9wdGlvbnMuc3RyaXBUcmFpbGluZ0NyKSB7XG4gICAgLy8gcmVtb3ZlIG9uZSBcXHIgYmVmb3JlIFxcbiB0byBtYXRjaCBHTlUgZGlmZidzIC0tc3RyaXAtdHJhaWxpbmctY3IgYmVoYXZpb3JcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJyk7XG4gIH1cblxuICBsZXQgcmV0TGluZXMgPSBbXSxcbiAgICAgIGxpbmVzQW5kTmV3bGluZXMgPSB2YWx1ZS5zcGxpdCgvKFxcbnxcXHJcXG4pLyk7XG5cbiAgLy8gSWdub3JlIHRoZSBmaW5hbCBlbXB0eSB0b2tlbiB0aGF0IG9jY3VycyBpZiB0aGUgc3RyaW5nIGVuZHMgd2l0aCBhIG5ldyBsaW5lXG4gIGlmICghbGluZXNBbmROZXdsaW5lc1tsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aCAtIDFdKSB7XG4gICAgbGluZXNBbmROZXdsaW5lcy5wb3AoKTtcbiAgfVxuXG4gIC8vIE1lcmdlIHRoZSBjb250ZW50IGFuZCBsaW5lIHNlcGFyYXRvcnMgaW50byBzaW5nbGUgdG9rZW5zXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXNBbmROZXdsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBsaW5lID0gbGluZXNBbmROZXdsaW5lc1tpXTtcblxuICAgIGlmIChpICUgMiAmJiAhdGhpcy5vcHRpb25zLm5ld2xpbmVJc1Rva2VuKSB7XG4gICAgICByZXRMaW5lc1tyZXRMaW5lcy5sZW5ndGggLSAxXSArPSBsaW5lO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZVdoaXRlc3BhY2UpIHtcbiAgICAgICAgbGluZSA9IGxpbmUudHJpbSgpO1xuICAgICAgfVxuICAgICAgcmV0TGluZXMucHVzaChsaW5lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0TGluZXM7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZGlmZkxpbmVzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykgeyByZXR1cm4gbGluZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spOyB9XG5leHBvcnQgZnVuY3Rpb24gZGlmZlRyaW1tZWRMaW5lcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHtcbiAgbGV0IG9wdGlvbnMgPSBnZW5lcmF0ZU9wdGlvbnMoY2FsbGJhY2ssIHtpZ25vcmVXaGl0ZXNwYWNlOiB0cnVlfSk7XG4gIHJldHVybiBsaW5lRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbn1cbiJdfQ==\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL2RpZmYvbGluZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGlCQUFpQjtBQUNqQix3QkFBd0I7QUFDeEIsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyw2RUFBUTtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLG1CQUFPLENBQUMsdUZBQWdCO0FBQ2xDO0FBQ0E7O0FBRUEsaUVBQWlFLHVDQUF1Qzs7QUFFeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBLElBQUk7OztBQUdKLGtCQUFrQiw2QkFBNkI7QUFDL0M7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL2RpZmYvbGluZS5qcz84MmFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kaWZmTGluZXMgPSBkaWZmTGluZXM7XG5leHBvcnRzLmRpZmZUcmltbWVkTGluZXMgPSBkaWZmVHJpbW1lZExpbmVzO1xuZXhwb3J0cy5saW5lRGlmZiA9IHZvaWQgMDtcblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2Jhc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Jhc2VcIikpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG52YXJcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9wYXJhbXMgPSByZXF1aXJlKFwiLi4vdXRpbC9wYXJhbXNcIilcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG52YXIgbGluZURpZmYgPSBuZXdcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9iYXNlXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuW1xuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXCJkZWZhdWx0XCJcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5dKCk7XG5cbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbmV4cG9ydHMubGluZURpZmYgPSBsaW5lRGlmZjtcblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbmxpbmVEaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuc3RyaXBUcmFpbGluZ0NyKSB7XG4gICAgLy8gcmVtb3ZlIG9uZSBcXHIgYmVmb3JlIFxcbiB0byBtYXRjaCBHTlUgZGlmZidzIC0tc3RyaXAtdHJhaWxpbmctY3IgYmVoYXZpb3JcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJyk7XG4gIH1cblxuICB2YXIgcmV0TGluZXMgPSBbXSxcbiAgICAgIGxpbmVzQW5kTmV3bGluZXMgPSB2YWx1ZS5zcGxpdCgvKFxcbnxcXHJcXG4pLyk7IC8vIElnbm9yZSB0aGUgZmluYWwgZW1wdHkgdG9rZW4gdGhhdCBvY2N1cnMgaWYgdGhlIHN0cmluZyBlbmRzIHdpdGggYSBuZXcgbGluZVxuXG4gIGlmICghbGluZXNBbmROZXdsaW5lc1tsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aCAtIDFdKSB7XG4gICAgbGluZXNBbmROZXdsaW5lcy5wb3AoKTtcbiAgfSAvLyBNZXJnZSB0aGUgY29udGVudCBhbmQgbGluZSBzZXBhcmF0b3JzIGludG8gc2luZ2xlIHRva2Vuc1xuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxpbmUgPSBsaW5lc0FuZE5ld2xpbmVzW2ldO1xuXG4gICAgaWYgKGkgJSAyICYmICF0aGlzLm9wdGlvbnMubmV3bGluZUlzVG9rZW4pIHtcbiAgICAgIHJldExpbmVzW3JldExpbmVzLmxlbmd0aCAtIDFdICs9IGxpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWdub3JlV2hpdGVzcGFjZSkge1xuICAgICAgICBsaW5lID0gbGluZS50cmltKCk7XG4gICAgICB9XG5cbiAgICAgIHJldExpbmVzLnB1c2gobGluZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldExpbmVzO1xufTtcblxuZnVuY3Rpb24gZGlmZkxpbmVzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xuICByZXR1cm4gbGluZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBkaWZmVHJpbW1lZExpbmVzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xuICB2YXIgb3B0aW9ucyA9XG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgKDAsXG4gIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICBfcGFyYW1zXG4gIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gIC5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICBnZW5lcmF0ZU9wdGlvbnMpXG4gIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gIChjYWxsYmFjaywge1xuICAgIGlnbm9yZVdoaXRlc3BhY2U6IHRydWVcbiAgfSk7XG4gIHJldHVybiBsaW5lRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWthV1ptTDJ4cGJtVXVhbk1pWFN3aWJtRnRaWE1pT2xzaWJHbHVaVVJwWm1ZaUxDSkVhV1ptSWl3aWRHOXJaVzVwZW1VaUxDSjJZV3gxWlNJc0ltOXdkR2x2Ym5NaUxDSnpkSEpwY0ZSeVlXbHNhVzVuUTNJaUxDSnlaWEJzWVdObElpd2ljbVYwVEdsdVpYTWlMQ0pzYVc1bGMwRnVaRTVsZDJ4cGJtVnpJaXdpYzNCc2FYUWlMQ0pzWlc1bmRHZ2lMQ0p3YjNBaUxDSnBJaXdpYkdsdVpTSXNJbTVsZDJ4cGJtVkpjMVJ2YTJWdUlpd2lhV2R1YjNKbFYyaHBkR1Z6Y0dGalpTSXNJblJ5YVcwaUxDSndkWE5vSWl3aVpHbG1aa3hwYm1Weklpd2liMnhrVTNSeUlpd2libVYzVTNSeUlpd2lZMkZzYkdKaFkyc2lMQ0prYVdabUlpd2laR2xtWmxSeWFXMXRaV1JNYVc1bGN5SXNJbWRsYm1WeVlYUmxUM0IwYVc5dWN5SmRMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3pzN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCT3p0QlFVTkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3T3pzN08wRkJSVThzU1VGQlRVRXNVVUZCVVN4SFFVRkhPMEZCUVVsRE8wRkJRVUZCTzBGQlFVRkJPMEZCUVVGQk8wRkJRVUZCTzBGQlFVRkJPMEZCUVVGQk8wRkJRVUZCTEVOQlFVb3NSVUZCYWtJN096czdPenRCUVVOUVJDeFJRVUZSTEVOQlFVTkZMRkZCUVZRc1IwRkJiMElzVlVGQlUwTXNTMEZCVkN4RlFVRm5RanRCUVVOc1F5eE5RVUZITEV0QlFVdERMRTlCUVV3c1EwRkJZVU1zWlVGQmFFSXNSVUZCYVVNN1FVRkRMMEk3UVVGRFFVWXNTVUZCUVVFc1MwRkJTeXhIUVVGSFFTeExRVUZMTEVOQlFVTkhMRTlCUVU0c1EwRkJZeXhQUVVGa0xFVkJRWFZDTEVsQlFYWkNMRU5CUVZJN1FVRkRSRHM3UVVGRlJDeE5RVUZKUXl4UlFVRlJMRWRCUVVjc1JVRkJaanRCUVVGQkxFMUJRMGxETEdkQ1FVRm5RaXhIUVVGSFRDeExRVUZMTEVOQlFVTk5MRXRCUVU0c1EwRkJXU3hYUVVGYUxFTkJSSFpDTEVOQlRtdERMRU5CVTJ4RE96dEJRVU5CTEUxQlFVa3NRMEZCUTBRc1owSkJRV2RDTEVOQlFVTkJMR2RDUVVGblFpeERRVUZEUlN4TlFVRnFRaXhIUVVFd1FpeERRVUV6UWl4RFFVRnlRaXhGUVVGdlJEdEJRVU5zUkVZc1NVRkJRVUVzWjBKQlFXZENMRU5CUVVOSExFZEJRV3BDTzBGQlEwUXNSMEZhYVVNc1EwRmpiRU03T3p0QlFVTkJMRTlCUVVzc1NVRkJTVU1zUTBGQlF5eEhRVUZITEVOQlFXSXNSVUZCWjBKQkxFTkJRVU1zUjBGQlIwb3NaMEpCUVdkQ0xFTkJRVU5GTEUxQlFYSkRMRVZCUVRaRFJTeERRVUZETEVWQlFUbERMRVZCUVd0RU8wRkJRMmhFTEZGQlFVbERMRWxCUVVrc1IwRkJSMHdzWjBKQlFXZENMRU5CUVVOSkxFTkJRVVFzUTBGQk0wSTdPMEZCUlVFc1VVRkJTVUVzUTBGQlF5eEhRVUZITEVOQlFVb3NTVUZCVXl4RFFVRkRMRXRCUVV0U0xFOUJRVXdzUTBGQllWVXNZMEZCTTBJc1JVRkJNa003UVVGRGVrTlFMRTFCUVVGQkxGRkJRVkVzUTBGQlEwRXNVVUZCVVN4RFFVRkRSeXhOUVVGVUxFZEJRV3RDTEVOQlFXNUNMRU5CUVZJc1NVRkJhVU5ITEVsQlFXcERPMEZCUTBRc1MwRkdSQ3hOUVVWUE8wRkJRMHdzVlVGQlNTeExRVUZMVkN4UFFVRk1MRU5CUVdGWExHZENRVUZxUWl4RlFVRnRRenRCUVVOcVEwWXNVVUZCUVVFc1NVRkJTU3hIUVVGSFFTeEpRVUZKTEVOQlFVTkhMRWxCUVV3c1JVRkJVRHRCUVVORU96dEJRVU5FVkN4TlFVRkJRU3hSUVVGUkxFTkJRVU5WTEVsQlFWUXNRMEZCWTBvc1NVRkJaRHRCUVVORU8wRkJRMFk3TzBGQlJVUXNVMEZCVDA0c1VVRkJVRHRCUVVORUxFTkJOMEpFT3p0QlFTdENUeXhUUVVGVFZ5eFRRVUZVTEVOQlFXMUNReXhOUVVGdVFpeEZRVUV5UWtNc1RVRkJNMElzUlVGQmJVTkRMRkZCUVc1RExFVkJRVFpETzBGQlFVVXNVMEZCVDNKQ0xGRkJRVkVzUTBGQlEzTkNMRWxCUVZRc1EwRkJZMGdzVFVGQlpDeEZRVUZ6UWtNc1RVRkJkRUlzUlVGQk9FSkRMRkZCUVRsQ0xFTkJRVkE3UVVGQmFVUTdPMEZCUTJoSExGTkJRVk5GTEdkQ1FVRlVMRU5CUVRCQ1NpeE5RVUV4UWl4RlFVRnJRME1zVFVGQmJFTXNSVUZCTUVORExGRkJRVEZETEVWQlFXOUVPMEZCUTNwRUxFMUJRVWxxUWl4UFFVRlBPMEZCUVVjN1FVRkJRVHRCUVVGQk96dEJRVUZCYjBJN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVR0QlFVRkJMRWRCUVdkQ1NDeFJRVUZvUWl4RlFVRXdRanRCUVVGRFRpeEpRVUZCUVN4blFrRkJaMElzUlVGQlJUdEJRVUZ1UWl4SFFVRXhRaXhEUVVGa08wRkJRMEVzVTBGQlQyWXNVVUZCVVN4RFFVRkRjMElzU1VGQlZDeERRVUZqU0N4TlFVRmtMRVZCUVhOQ1F5eE5RVUYwUWl4RlFVRTRRbWhDTEU5QlFUbENMRU5CUVZBN1FVRkRSQ0lzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSW1sdGNHOXlkQ0JFYVdabUlHWnliMjBnSnk0dlltRnpaU2M3WEc1cGJYQnZjblFnZTJkbGJtVnlZWFJsVDNCMGFXOXVjMzBnWm5KdmJTQW5MaTR2ZFhScGJDOXdZWEpoYlhNbk8xeHVYRzVsZUhCdmNuUWdZMjl1YzNRZ2JHbHVaVVJwWm1ZZ1BTQnVaWGNnUkdsbVppZ3BPMXh1YkdsdVpVUnBabVl1ZEc5clpXNXBlbVVnUFNCbWRXNWpkR2x2YmloMllXeDFaU2tnZTF4dUlDQnBaaWgwYUdsekxtOXdkR2x2Ym5NdWMzUnlhWEJVY21GcGJHbHVaME55S1NCN1hHNGdJQ0FnTHk4Z2NtVnRiM1psSUc5dVpTQmNYSElnWW1WbWIzSmxJRnhjYmlCMGJ5QnRZWFJqYUNCSFRsVWdaR2xtWmlkeklDMHRjM1J5YVhBdGRISmhhV3hwYm1jdFkzSWdZbVZvWVhacGIzSmNiaUFnSUNCMllXeDFaU0E5SUhaaGJIVmxMbkpsY0d4aFkyVW9MMXhjY2x4Y2JpOW5MQ0FuWEZ4dUp5azdYRzRnSUgxY2JseHVJQ0JzWlhRZ2NtVjBUR2x1WlhNZ1BTQmJYU3hjYmlBZ0lDQWdJR3hwYm1WelFXNWtUbVYzYkdsdVpYTWdQU0IyWVd4MVpTNXpjR3hwZENndktGeGNibnhjWEhKY1hHNHBMeWs3WEc1Y2JpQWdMeThnU1dkdWIzSmxJSFJvWlNCbWFXNWhiQ0JsYlhCMGVTQjBiMnRsYmlCMGFHRjBJRzlqWTNWeWN5QnBaaUIwYUdVZ2MzUnlhVzVuSUdWdVpITWdkMmwwYUNCaElHNWxkeUJzYVc1bFhHNGdJR2xtSUNnaGJHbHVaWE5CYm1ST1pYZHNhVzVsYzF0c2FXNWxjMEZ1WkU1bGQyeHBibVZ6TG14bGJtZDBhQ0F0SURGZEtTQjdYRzRnSUNBZ2JHbHVaWE5CYm1ST1pYZHNhVzVsY3k1d2IzQW9LVHRjYmlBZ2ZWeHVYRzRnSUM4dklFMWxjbWRsSUhSb1pTQmpiMjUwWlc1MElHRnVaQ0JzYVc1bElITmxjR0Z5WVhSdmNuTWdhVzUwYnlCemFXNW5iR1VnZEc5clpXNXpYRzRnSUdadmNpQW9iR1YwSUdrZ1BTQXdPeUJwSUR3Z2JHbHVaWE5CYm1ST1pYZHNhVzVsY3k1c1pXNW5kR2c3SUdrckt5a2dlMXh1SUNBZ0lHeGxkQ0JzYVc1bElEMGdiR2x1WlhOQmJtUk9aWGRzYVc1bGMxdHBYVHRjYmx4dUlDQWdJR2xtSUNocElDVWdNaUFtSmlBaGRHaHBjeTV2Y0hScGIyNXpMbTVsZDJ4cGJtVkpjMVJ2YTJWdUtTQjdYRzRnSUNBZ0lDQnlaWFJNYVc1bGMxdHlaWFJNYVc1bGN5NXNaVzVuZEdnZ0xTQXhYU0FyUFNCc2FXNWxPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCcFppQW9kR2hwY3k1dmNIUnBiMjV6TG1sbmJtOXlaVmRvYVhSbGMzQmhZMlVwSUh0Y2JpQWdJQ0FnSUNBZ2JHbHVaU0E5SUd4cGJtVXVkSEpwYlNncE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2NtVjBUR2x1WlhNdWNIVnphQ2hzYVc1bEtUdGNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQnlaWFIxY200Z2NtVjBUR2x1WlhNN1hHNTlPMXh1WEc1bGVIQnZjblFnWm5WdVkzUnBiMjRnWkdsbVpreHBibVZ6S0c5c1pGTjBjaXdnYm1WM1UzUnlMQ0JqWVd4c1ltRmpheWtnZXlCeVpYUjFjbTRnYkdsdVpVUnBabVl1WkdsbVppaHZiR1JUZEhJc0lHNWxkMU4wY2l3Z1kyRnNiR0poWTJzcE95QjlYRzVsZUhCdmNuUWdablZ1WTNScGIyNGdaR2xtWmxSeWFXMXRaV1JNYVc1bGN5aHZiR1JUZEhJc0lHNWxkMU4wY2l3Z1kyRnNiR0poWTJzcElIdGNiaUFnYkdWMElHOXdkR2x2Ym5NZ1BTQm5aVzVsY21GMFpVOXdkR2x2Ym5Nb1kyRnNiR0poWTJzc0lIdHBaMjV2Y21WWGFHbDBaWE53WVdObE9pQjBjblZsZlNrN1hHNGdJSEpsZEhWeWJpQnNhVzVsUkdsbVppNWthV1ptS0c5c1pGTjBjaXdnYm1WM1UzUnlMQ0J2Y0hScGIyNXpLVHRjYm4xY2JpSmRmUT09XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/line.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/sentence.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mocha/node_modules/diff/lib/diff/sentence.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*istanbul ignore start*/\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.diffSentences = diffSentences;\nexports.sentenceDiff = void 0;\n\n/*istanbul ignore end*/\nvar\n/*istanbul ignore start*/\n_base = _interopRequireDefault(__webpack_require__(/*! ./base */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/base.js\"))\n/*istanbul ignore end*/\n;\n\n/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/*istanbul ignore end*/\nvar sentenceDiff = new\n/*istanbul ignore start*/\n_base\n/*istanbul ignore end*/\n[\n/*istanbul ignore start*/\n\"default\"\n/*istanbul ignore end*/\n]();\n\n/*istanbul ignore start*/\nexports.sentenceDiff = sentenceDiff;\n\n/*istanbul ignore end*/\nsentenceDiff.tokenize = function (value) {\n  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n};\n\nfunction diffSentences(oldStr, newStr, callback) {\n  return sentenceDiff.diff(oldStr, newStr, callback);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL3NlbnRlbmNlLmpzIl0sIm5hbWVzIjpbInNlbnRlbmNlRGlmZiIsIkRpZmYiLCJ0b2tlbml6ZSIsInZhbHVlIiwic3BsaXQiLCJkaWZmU2VudGVuY2VzIiwib2xkU3RyIiwibmV3U3RyIiwiY2FsbGJhY2siLCJkaWZmIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7QUFHTyxJQUFNQSxZQUFZLEdBQUc7QUFBSUM7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUEsQ0FBSixFQUFyQjs7Ozs7O0FBQ1BELFlBQVksQ0FBQ0UsUUFBYixHQUF3QixVQUFTQyxLQUFULEVBQWdCO0FBQ3RDLFNBQU9BLEtBQUssQ0FBQ0MsS0FBTixDQUFZLHVCQUFaLENBQVA7QUFDRCxDQUZEOztBQUlPLFNBQVNDLGFBQVQsQ0FBdUJDLE1BQXZCLEVBQStCQyxNQUEvQixFQUF1Q0MsUUFBdkMsRUFBaUQ7QUFBRSxTQUFPUixZQUFZLENBQUNTLElBQWIsQ0FBa0JILE1BQWxCLEVBQTBCQyxNQUExQixFQUFrQ0MsUUFBbEMsQ0FBUDtBQUFxRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEaWZmIGZyb20gJy4vYmFzZSc7XG5cblxuZXhwb3J0IGNvbnN0IHNlbnRlbmNlRGlmZiA9IG5ldyBEaWZmKCk7XG5zZW50ZW5jZURpZmYudG9rZW5pemUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuc3BsaXQoLyhcXFMuKz9bLiE/XSkoPz1cXHMrfCQpLyk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZGlmZlNlbnRlbmNlcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHsgcmV0dXJuIHNlbnRlbmNlRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7IH1cbiJdfQ==\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL2RpZmYvc2VudGVuY2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixxQkFBcUI7QUFDckIsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyw2RUFBUTtBQUMvQztBQUNBOztBQUVBLGlFQUFpRSx1Q0FBdUM7O0FBRXhHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL2RpZmYvc2VudGVuY2UuanM/M2NjMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGlmZlNlbnRlbmNlcyA9IGRpZmZTZW50ZW5jZXM7XG5leHBvcnRzLnNlbnRlbmNlRGlmZiA9IHZvaWQgMDtcblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2Jhc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Jhc2VcIikpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xudmFyIHNlbnRlbmNlRGlmZiA9IG5ld1xuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2Jhc2Vcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5bXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cImRlZmF1bHRcIlxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbl0oKTtcblxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuZXhwb3J0cy5zZW50ZW5jZURpZmYgPSBzZW50ZW5jZURpZmY7XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5zZW50ZW5jZURpZmYudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnNwbGl0KC8oXFxTLis/Wy4hP10pKD89XFxzK3wkKS8pO1xufTtcblxuZnVuY3Rpb24gZGlmZlNlbnRlbmNlcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHNlbnRlbmNlRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTlrYVdabUwzTmxiblJsYm1ObExtcHpJbDBzSW01aGJXVnpJanBiSW5ObGJuUmxibU5sUkdsbVppSXNJa1JwWm1ZaUxDSjBiMnRsYm1sNlpTSXNJblpoYkhWbElpd2ljM0JzYVhRaUxDSmthV1ptVTJWdWRHVnVZMlZ6SWl3aWIyeGtVM1J5SWl3aWJtVjNVM1J5SWl3aVkyRnNiR0poWTJzaUxDSmthV1ptSWwwc0ltMWhjSEJwYm1keklqb2lPenM3T3pzN096czdPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUczdPenM3UVVGSFR5eEpRVUZOUVN4WlFVRlpMRWRCUVVjN1FVRkJTVU03UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRXNRMEZCU2l4RlFVRnlRanM3T3pzN08wRkJRMUJFTEZsQlFWa3NRMEZCUTBVc1VVRkJZaXhIUVVGM1FpeFZRVUZUUXl4TFFVRlVMRVZCUVdkQ08wRkJRM1JETEZOQlFVOUJMRXRCUVVzc1EwRkJRME1zUzBGQlRpeERRVUZaTEhWQ1FVRmFMRU5CUVZBN1FVRkRSQ3hEUVVaRU96dEJRVWxQTEZOQlFWTkRMR0ZCUVZRc1EwRkJkVUpETEUxQlFYWkNMRVZCUVN0Q1F5eE5RVUV2UWl4RlFVRjFRME1zVVVGQmRrTXNSVUZCYVVRN1FVRkJSU3hUUVVGUFVpeFpRVUZaTEVOQlFVTlRMRWxCUVdJc1EwRkJhMEpJTEUxQlFXeENMRVZCUVRCQ1F5eE5RVUV4UWl4RlFVRnJRME1zVVVGQmJFTXNRMEZCVUR0QlFVRnhSQ0lzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSW1sdGNHOXlkQ0JFYVdabUlHWnliMjBnSnk0dlltRnpaU2M3WEc1Y2JseHVaWGh3YjNKMElHTnZibk4wSUhObGJuUmxibU5sUkdsbVppQTlJRzVsZHlCRWFXWm1LQ2s3WEc1elpXNTBaVzVqWlVScFptWXVkRzlyWlc1cGVtVWdQU0JtZFc1amRHbHZiaWgyWVd4MVpTa2dlMXh1SUNCeVpYUjFjbTRnZG1Gc2RXVXVjM0JzYVhRb0x5aGNYRk11S3o5YkxpRS9YU2tvUHoxY1hITXJmQ1FwTHlrN1hHNTlPMXh1WEc1bGVIQnZjblFnWm5WdVkzUnBiMjRnWkdsbVpsTmxiblJsYm1ObGN5aHZiR1JUZEhJc0lHNWxkMU4wY2l3Z1kyRnNiR0poWTJzcElIc2djbVYwZFhKdUlITmxiblJsYm1ObFJHbG1aaTVrYVdabUtHOXNaRk4wY2l3Z2JtVjNVM1J5TENCallXeHNZbUZqYXlrN0lIMWNiaUpkZlE9PVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/sentence.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/word.js":
/*!***************************************************************!*\
  !*** ./node_modules/mocha/node_modules/diff/lib/diff/word.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*istanbul ignore start*/\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.diffWords = diffWords;\nexports.diffWordsWithSpace = diffWordsWithSpace;\nexports.wordDiff = void 0;\n\n/*istanbul ignore end*/\nvar\n/*istanbul ignore start*/\n_base = _interopRequireDefault(__webpack_require__(/*! ./base */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/base.js\"))\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_params = __webpack_require__(/*! ../util/params */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/util/params.js\")\n/*istanbul ignore end*/\n;\n\n/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/*istanbul ignore end*/\n// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 008000FF\n//  - U+00D7   Multiplication sign\n//  - U+00F7   Division sign\n// Latin Extended-A, 0100017F\n// Latin Extended-B, 0180024F\n// IPA Extensions, 025002AF\n// Spacing Modifier Letters, 02B002FF\n//  - U+02C7   &#711;  Caron\n//  - U+02D8   &#728;  Breve\n//  - U+02D9   &#729;  Dot Above\n//  - U+02DA   &#730;  Ring Above\n//  - U+02DB   &#731;  Ogonek\n//  - U+02DC   &#732;  Small Tilde\n//  - U+02DD   &#733;  Double Acute Accent\n// Latin Extended Additional, 1E001EFF\nvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\nvar reWhitespace = /\\S/;\nvar wordDiff = new\n/*istanbul ignore start*/\n_base\n/*istanbul ignore end*/\n[\n/*istanbul ignore start*/\n\"default\"\n/*istanbul ignore end*/\n]();\n\n/*istanbul ignore start*/\nexports.wordDiff = wordDiff;\n\n/*istanbul ignore end*/\nwordDiff.equals = function (left, right) {\n  if (this.options.ignoreCase) {\n    left = left.toLowerCase();\n    right = right.toLowerCase();\n  }\n\n  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n};\n\nwordDiff.tokenize = function (value) {\n  // All whitespace symbols except newline group into one token, each newline - in separate token\n  var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\n  for (var i = 0; i < tokens.length - 1; i++) {\n    // If we have an empty string in the next field and we have only word chars before and after, merge\n    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n      tokens[i] += tokens[i + 2];\n      tokens.splice(i + 1, 2);\n      i--;\n    }\n  }\n\n  return tokens;\n};\n\nfunction diffWords(oldStr, newStr, options) {\n  options =\n  /*istanbul ignore start*/\n  (0,\n  /*istanbul ignore end*/\n\n  /*istanbul ignore start*/\n  _params\n  /*istanbul ignore end*/\n  .\n  /*istanbul ignore start*/\n  generateOptions)\n  /*istanbul ignore end*/\n  (options, {\n    ignoreWhitespace: true\n  });\n  return wordDiff.diff(oldStr, newStr, options);\n}\n\nfunction diffWordsWithSpace(oldStr, newStr, options) {\n  return wordDiff.diff(oldStr, newStr, options);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL3dvcmQuanMiXSwibmFtZXMiOlsiZXh0ZW5kZWRXb3JkQ2hhcnMiLCJyZVdoaXRlc3BhY2UiLCJ3b3JkRGlmZiIsIkRpZmYiLCJlcXVhbHMiLCJsZWZ0IiwicmlnaHQiLCJvcHRpb25zIiwiaWdub3JlQ2FzZSIsInRvTG93ZXJDYXNlIiwiaWdub3JlV2hpdGVzcGFjZSIsInRlc3QiLCJ0b2tlbml6ZSIsInZhbHVlIiwidG9rZW5zIiwic3BsaXQiLCJpIiwibGVuZ3RoIiwic3BsaWNlIiwiZGlmZldvcmRzIiwib2xkU3RyIiwibmV3U3RyIiwiZ2VuZXJhdGVPcHRpb25zIiwiZGlmZiIsImRpZmZXb3Jkc1dpdGhTcGFjZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTUEsaUJBQWlCLEdBQUcsK0RBQTFCO0FBRUEsSUFBTUMsWUFBWSxHQUFHLElBQXJCO0FBRU8sSUFBTUMsUUFBUSxHQUFHO0FBQUlDO0FBQUFBO0FBQUFBO0FBQUFBO0FBQUFBO0FBQUFBO0FBQUFBO0FBQUFBLENBQUosRUFBakI7Ozs7OztBQUNQRCxRQUFRLENBQUNFLE1BQVQsR0FBa0IsVUFBU0MsSUFBVCxFQUFlQyxLQUFmLEVBQXNCO0FBQ3RDLE1BQUksS0FBS0MsT0FBTCxDQUFhQyxVQUFqQixFQUE2QjtBQUMzQkgsSUFBQUEsSUFBSSxHQUFHQSxJQUFJLENBQUNJLFdBQUwsRUFBUDtBQUNBSCxJQUFBQSxLQUFLLEdBQUdBLEtBQUssQ0FBQ0csV0FBTixFQUFSO0FBQ0Q7O0FBQ0QsU0FBT0osSUFBSSxLQUFLQyxLQUFULElBQW1CLEtBQUtDLE9BQUwsQ0FBYUcsZ0JBQWIsSUFBaUMsQ0FBQ1QsWUFBWSxDQUFDVSxJQUFiLENBQWtCTixJQUFsQixDQUFsQyxJQUE2RCxDQUFDSixZQUFZLENBQUNVLElBQWIsQ0FBa0JMLEtBQWxCLENBQXhGO0FBQ0QsQ0FORDs7QUFPQUosUUFBUSxDQUFDVSxRQUFULEdBQW9CLFVBQVNDLEtBQVQsRUFBZ0I7QUFDbEM7QUFDQSxNQUFJQyxNQUFNLEdBQUdELEtBQUssQ0FBQ0UsS0FBTixDQUFZLGlDQUFaLENBQWIsQ0FGa0MsQ0FJbEM7O0FBQ0EsT0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHRixNQUFNLENBQUNHLE1BQVAsR0FBZ0IsQ0FBcEMsRUFBdUNELENBQUMsRUFBeEMsRUFBNEM7QUFDMUM7QUFDQSxRQUFJLENBQUNGLE1BQU0sQ0FBQ0UsQ0FBQyxHQUFHLENBQUwsQ0FBUCxJQUFrQkYsTUFBTSxDQUFDRSxDQUFDLEdBQUcsQ0FBTCxDQUF4QixJQUNLaEIsaUJBQWlCLENBQUNXLElBQWxCLENBQXVCRyxNQUFNLENBQUNFLENBQUQsQ0FBN0IsQ0FETCxJQUVLaEIsaUJBQWlCLENBQUNXLElBQWxCLENBQXVCRyxNQUFNLENBQUNFLENBQUMsR0FBRyxDQUFMLENBQTdCLENBRlQsRUFFZ0Q7QUFDOUNGLE1BQUFBLE1BQU0sQ0FBQ0UsQ0FBRCxDQUFOLElBQWFGLE1BQU0sQ0FBQ0UsQ0FBQyxHQUFHLENBQUwsQ0FBbkI7QUFDQUYsTUFBQUEsTUFBTSxDQUFDSSxNQUFQLENBQWNGLENBQUMsR0FBRyxDQUFsQixFQUFxQixDQUFyQjtBQUNBQSxNQUFBQSxDQUFDO0FBQ0Y7QUFDRjs7QUFFRCxTQUFPRixNQUFQO0FBQ0QsQ0FqQkQ7O0FBbUJPLFNBQVNLLFNBQVQsQ0FBbUJDLE1BQW5CLEVBQTJCQyxNQUEzQixFQUFtQ2QsT0FBbkMsRUFBNEM7QUFDakRBLEVBQUFBLE9BQU87QUFBRztBQUFBO0FBQUE7O0FBQUFlO0FBQUFBO0FBQUFBO0FBQUFBO0FBQUFBO0FBQUFBO0FBQUE7QUFBQSxHQUFnQmYsT0FBaEIsRUFBeUI7QUFBQ0csSUFBQUEsZ0JBQWdCLEVBQUU7QUFBbkIsR0FBekIsQ0FBVjtBQUNBLFNBQU9SLFFBQVEsQ0FBQ3FCLElBQVQsQ0FBY0gsTUFBZCxFQUFzQkMsTUFBdEIsRUFBOEJkLE9BQTlCLENBQVA7QUFDRDs7QUFFTSxTQUFTaUIsa0JBQVQsQ0FBNEJKLE1BQTVCLEVBQW9DQyxNQUFwQyxFQUE0Q2QsT0FBNUMsRUFBcUQ7QUFDMUQsU0FBT0wsUUFBUSxDQUFDcUIsSUFBVCxDQUFjSCxNQUFkLEVBQXNCQyxNQUF0QixFQUE4QmQsT0FBOUIsQ0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERpZmYgZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7Z2VuZXJhdGVPcHRpb25zfSBmcm9tICcuLi91dGlsL3BhcmFtcyc7XG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX3NjcmlwdF9pbl9Vbmljb2RlXG4vL1xuLy8gUmFuZ2VzIGFuZCBleGNlcHRpb25zOlxuLy8gTGF0aW4tMSBTdXBwbGVtZW50LCAwMDgw4oCTMDBGRlxuLy8gIC0gVSswMEQ3ICDDlyBNdWx0aXBsaWNhdGlvbiBzaWduXG4vLyAgLSBVKzAwRjcgIMO3IERpdmlzaW9uIHNpZ25cbi8vIExhdGluIEV4dGVuZGVkLUEsIDAxMDDigJMwMTdGXG4vLyBMYXRpbiBFeHRlbmRlZC1CLCAwMTgw4oCTMDI0RlxuLy8gSVBBIEV4dGVuc2lvbnMsIDAyNTDigJMwMkFGXG4vLyBTcGFjaW5nIE1vZGlmaWVyIExldHRlcnMsIDAyQjDigJMwMkZGXG4vLyAgLSBVKzAyQzcgIMuHICYjNzExOyAgQ2Fyb25cbi8vICAtIFUrMDJEOCAgy5ggJiM3Mjg7ICBCcmV2ZVxuLy8gIC0gVSswMkQ5ICDLmSAmIzcyOTsgIERvdCBBYm92ZVxuLy8gIC0gVSswMkRBICDLmiAmIzczMDsgIFJpbmcgQWJvdmVcbi8vICAtIFUrMDJEQiAgy5sgJiM3MzE7ICBPZ29uZWtcbi8vICAtIFUrMDJEQyAgy5wgJiM3MzI7ICBTbWFsbCBUaWxkZVxuLy8gIC0gVSswMkREICDLnSAmIzczMzsgIERvdWJsZSBBY3V0ZSBBY2NlbnRcbi8vIExhdGluIEV4dGVuZGVkIEFkZGl0aW9uYWwsIDFFMDDigJMxRUZGXG5jb25zdCBleHRlbmRlZFdvcmRDaGFycyA9IC9eW2EtekEtWlxcdXtDMH0tXFx1e0ZGfVxcdXtEOH0tXFx1e0Y2fVxcdXtGOH0tXFx1ezJDNn1cXHV7MkM4fS1cXHV7MkQ3fVxcdXsyREV9LVxcdXsyRkZ9XFx1ezFFMDB9LVxcdXsxRUZGfV0rJC91O1xuXG5jb25zdCByZVdoaXRlc3BhY2UgPSAvXFxTLztcblxuZXhwb3J0IGNvbnN0IHdvcmREaWZmID0gbmV3IERpZmYoKTtcbndvcmREaWZmLmVxdWFscyA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuaWdub3JlQ2FzZSkge1xuICAgIGxlZnQgPSBsZWZ0LnRvTG93ZXJDYXNlKCk7XG4gICAgcmlnaHQgPSByaWdodC50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCAodGhpcy5vcHRpb25zLmlnbm9yZVdoaXRlc3BhY2UgJiYgIXJlV2hpdGVzcGFjZS50ZXN0KGxlZnQpICYmICFyZVdoaXRlc3BhY2UudGVzdChyaWdodCkpO1xufTtcbndvcmREaWZmLnRva2VuaXplID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gQWxsIHdoaXRlc3BhY2Ugc3ltYm9scyBleGNlcHQgbmV3bGluZSBncm91cCBpbnRvIG9uZSB0b2tlbiwgZWFjaCBuZXdsaW5lIC0gaW4gc2VwYXJhdGUgdG9rZW5cbiAgbGV0IHRva2VucyA9IHZhbHVlLnNwbGl0KC8oW15cXFNcXHJcXG5dK3xbKClbXFxde30nXCJcXHJcXG5dfFxcYikvKTtcblxuICAvLyBKb2luIHRoZSBib3VuZGFyeSBzcGxpdHMgdGhhdCB3ZSBkbyBub3QgY29uc2lkZXIgdG8gYmUgYm91bmRhcmllcy4gVGhpcyBpcyBwcmltYXJpbHkgdGhlIGV4dGVuZGVkIExhdGluIGNoYXJhY3RlciBzZXQuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIC8vIElmIHdlIGhhdmUgYW4gZW1wdHkgc3RyaW5nIGluIHRoZSBuZXh0IGZpZWxkIGFuZCB3ZSBoYXZlIG9ubHkgd29yZCBjaGFycyBiZWZvcmUgYW5kIGFmdGVyLCBtZXJnZVxuICAgIGlmICghdG9rZW5zW2kgKyAxXSAmJiB0b2tlbnNbaSArIDJdXG4gICAgICAgICAgJiYgZXh0ZW5kZWRXb3JkQ2hhcnMudGVzdCh0b2tlbnNbaV0pXG4gICAgICAgICAgJiYgZXh0ZW5kZWRXb3JkQ2hhcnMudGVzdCh0b2tlbnNbaSArIDJdKSkge1xuICAgICAgdG9rZW5zW2ldICs9IHRva2Vuc1tpICsgMl07XG4gICAgICB0b2tlbnMuc3BsaWNlKGkgKyAxLCAyKTtcbiAgICAgIGktLTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG9rZW5zO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZXb3JkcyhvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xuICBvcHRpb25zID0gZ2VuZXJhdGVPcHRpb25zKG9wdGlvbnMsIHtpZ25vcmVXaGl0ZXNwYWNlOiB0cnVlfSk7XG4gIHJldHVybiB3b3JkRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZXb3Jkc1dpdGhTcGFjZShvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xuICByZXR1cm4gd29yZERpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG59XG4iXX0=\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL2RpZmYvd29yZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGlCQUFpQjtBQUNqQiwwQkFBMEI7QUFDMUIsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyw2RUFBUTtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLG1CQUFPLENBQUMsdUZBQWdCO0FBQ2xDO0FBQ0E7O0FBRUEsaUVBQWlFLHVDQUF1Qzs7QUFFeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsZUFBZTs7QUFFL0Qsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL21vY2hhL25vZGVfbW9kdWxlcy9kaWZmL2xpYi9kaWZmL3dvcmQuanM/OTRhMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGlmZldvcmRzID0gZGlmZldvcmRzO1xuZXhwb3J0cy5kaWZmV29yZHNXaXRoU3BhY2UgPSBkaWZmV29yZHNXaXRoU3BhY2U7XG5leHBvcnRzLndvcmREaWZmID0gdm9pZCAwO1xuXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xudmFyXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5fYmFzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYmFzZVwiKSlcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX3BhcmFtcyA9IHJlcXVpcmUoXCIuLi91dGlsL3BhcmFtc1wiKVxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbjtcblxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX3NjcmlwdF9pbl9Vbmljb2RlXG4vL1xuLy8gUmFuZ2VzIGFuZCBleGNlcHRpb25zOlxuLy8gTGF0aW4tMSBTdXBwbGVtZW50LCAwMDgw4oCTMDBGRlxuLy8gIC0gVSswMEQ3ICDDlyBNdWx0aXBsaWNhdGlvbiBzaWduXG4vLyAgLSBVKzAwRjcgIMO3IERpdmlzaW9uIHNpZ25cbi8vIExhdGluIEV4dGVuZGVkLUEsIDAxMDDigJMwMTdGXG4vLyBMYXRpbiBFeHRlbmRlZC1CLCAwMTgw4oCTMDI0RlxuLy8gSVBBIEV4dGVuc2lvbnMsIDAyNTDigJMwMkFGXG4vLyBTcGFjaW5nIE1vZGlmaWVyIExldHRlcnMsIDAyQjDigJMwMkZGXG4vLyAgLSBVKzAyQzcgIMuHICYjNzExOyAgQ2Fyb25cbi8vICAtIFUrMDJEOCAgy5ggJiM3Mjg7ICBCcmV2ZVxuLy8gIC0gVSswMkQ5ICDLmSAmIzcyOTsgIERvdCBBYm92ZVxuLy8gIC0gVSswMkRBICDLmiAmIzczMDsgIFJpbmcgQWJvdmVcbi8vICAtIFUrMDJEQiAgy5sgJiM3MzE7ICBPZ29uZWtcbi8vICAtIFUrMDJEQyAgy5wgJiM3MzI7ICBTbWFsbCBUaWxkZVxuLy8gIC0gVSswMkREICDLnSAmIzczMzsgIERvdWJsZSBBY3V0ZSBBY2NlbnRcbi8vIExhdGluIEV4dGVuZGVkIEFkZGl0aW9uYWwsIDFFMDDigJMxRUZGXG52YXIgZXh0ZW5kZWRXb3JkQ2hhcnMgPSAvXltBLVphLXpcXHhDMC1cXHUwMkM2XFx1MDJDOC1cXHUwMkQ3XFx1MDJERS1cXHUwMkZGXFx1MUUwMC1cXHUxRUZGXSskLztcbnZhciByZVdoaXRlc3BhY2UgPSAvXFxTLztcbnZhciB3b3JkRGlmZiA9IG5ld1xuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2Jhc2Vcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5bXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cImRlZmF1bHRcIlxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbl0oKTtcblxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuZXhwb3J0cy53b3JkRGlmZiA9IHdvcmREaWZmO1xuXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xud29yZERpZmYuZXF1YWxzID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuaWdub3JlQ2FzZSkge1xuICAgIGxlZnQgPSBsZWZ0LnRvTG93ZXJDYXNlKCk7XG4gICAgcmlnaHQgPSByaWdodC50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0IHx8IHRoaXMub3B0aW9ucy5pZ25vcmVXaGl0ZXNwYWNlICYmICFyZVdoaXRlc3BhY2UudGVzdChsZWZ0KSAmJiAhcmVXaGl0ZXNwYWNlLnRlc3QocmlnaHQpO1xufTtcblxud29yZERpZmYudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgLy8gQWxsIHdoaXRlc3BhY2Ugc3ltYm9scyBleGNlcHQgbmV3bGluZSBncm91cCBpbnRvIG9uZSB0b2tlbiwgZWFjaCBuZXdsaW5lIC0gaW4gc2VwYXJhdGUgdG9rZW5cbiAgdmFyIHRva2VucyA9IHZhbHVlLnNwbGl0KC8oW15cXFNcXHJcXG5dK3xbKClbXFxde30nXCJcXHJcXG5dfFxcYikvKTsgLy8gSm9pbiB0aGUgYm91bmRhcnkgc3BsaXRzIHRoYXQgd2UgZG8gbm90IGNvbnNpZGVyIHRvIGJlIGJvdW5kYXJpZXMuIFRoaXMgaXMgcHJpbWFyaWx5IHRoZSBleHRlbmRlZCBMYXRpbiBjaGFyYWN0ZXIgc2V0LlxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIC8vIElmIHdlIGhhdmUgYW4gZW1wdHkgc3RyaW5nIGluIHRoZSBuZXh0IGZpZWxkIGFuZCB3ZSBoYXZlIG9ubHkgd29yZCBjaGFycyBiZWZvcmUgYW5kIGFmdGVyLCBtZXJnZVxuICAgIGlmICghdG9rZW5zW2kgKyAxXSAmJiB0b2tlbnNbaSArIDJdICYmIGV4dGVuZGVkV29yZENoYXJzLnRlc3QodG9rZW5zW2ldKSAmJiBleHRlbmRlZFdvcmRDaGFycy50ZXN0KHRva2Vuc1tpICsgMl0pKSB7XG4gICAgICB0b2tlbnNbaV0gKz0gdG9rZW5zW2kgKyAyXTtcbiAgICAgIHRva2Vucy5zcGxpY2UoaSArIDEsIDIpO1xuICAgICAgaS0tO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59O1xuXG5mdW5jdGlvbiBkaWZmV29yZHMob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9XG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgKDAsXG4gIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICBfcGFyYW1zXG4gIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gIC5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICBnZW5lcmF0ZU9wdGlvbnMpXG4gIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gIChvcHRpb25zLCB7XG4gICAgaWdub3JlV2hpdGVzcGFjZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIHdvcmREaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBkaWZmV29yZHNXaXRoU3BhY2Uob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHdvcmREaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5a2FXWm1MM2R2Y21RdWFuTWlYU3dpYm1GdFpYTWlPbHNpWlhoMFpXNWtaV1JYYjNKa1EyaGhjbk1pTENKeVpWZG9hWFJsYzNCaFkyVWlMQ0ozYjNKa1JHbG1aaUlzSWtScFptWWlMQ0psY1hWaGJITWlMQ0pzWldaMElpd2ljbWxuYUhRaUxDSnZjSFJwYjI1eklpd2lhV2R1YjNKbFEyRnpaU0lzSW5SdlRHOTNaWEpEWVhObElpd2lhV2R1YjNKbFYyaHBkR1Z6Y0dGalpTSXNJblJsYzNRaUxDSjBiMnRsYm1sNlpTSXNJblpoYkhWbElpd2lkRzlyWlc1eklpd2ljM0JzYVhRaUxDSnBJaXdpYkdWdVozUm9JaXdpYzNCc2FXTmxJaXdpWkdsbVpsZHZjbVJ6SWl3aWIyeGtVM1J5SWl3aWJtVjNVM1J5SWl3aVoyVnVaWEpoZEdWUGNIUnBiMjV6SWl3aVpHbG1aaUlzSW1ScFptWlhiM0prYzFkcGRHaFRjR0ZqWlNKZExDSnRZWEJ3YVc1bmN5STZJanM3T3pzN096czdPenM3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPenRCUVVOQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdPenM3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTVUZCVFVFc2FVSkJRV2xDTEVkQlFVY3NLMFJCUVRGQ08wRkJSVUVzU1VGQlRVTXNXVUZCV1N4SFFVRkhMRWxCUVhKQ08wRkJSVThzU1VGQlRVTXNVVUZCVVN4SFFVRkhPMEZCUVVsRE8wRkJRVUZCTzBGQlFVRkJPMEZCUVVGQk8wRkJRVUZCTzBGQlFVRkJPMEZCUVVGQk8wRkJRVUZCTEVOQlFVb3NSVUZCYWtJN096czdPenRCUVVOUVJDeFJRVUZSTEVOQlFVTkZMRTFCUVZRc1IwRkJhMElzVlVGQlUwTXNTVUZCVkN4RlFVRmxReXhMUVVGbUxFVkJRWE5DTzBGQlEzUkRMRTFCUVVrc1MwRkJTME1zVDBGQlRDeERRVUZoUXl4VlFVRnFRaXhGUVVFMlFqdEJRVU16UWtnc1NVRkJRVUVzU1VGQlNTeEhRVUZIUVN4SlFVRkpMRU5CUVVOSkxGZEJRVXdzUlVGQlVEdEJRVU5CU0N4SlFVRkJRU3hMUVVGTExFZEJRVWRCTEV0QlFVc3NRMEZCUTBjc1YwRkJUaXhGUVVGU08wRkJRMFE3TzBGQlEwUXNVMEZCVDBvc1NVRkJTU3hMUVVGTFF5eExRVUZVTEVsQlFXMUNMRXRCUVV0RExFOUJRVXdzUTBGQllVY3NaMEpCUVdJc1NVRkJhVU1zUTBGQlExUXNXVUZCV1N4RFFVRkRWU3hKUVVGaUxFTkJRV3RDVGl4SlFVRnNRaXhEUVVGc1F5eEpRVUUyUkN4RFFVRkRTaXhaUVVGWkxFTkJRVU5WTEVsQlFXSXNRMEZCYTBKTUxFdEJRV3hDTEVOQlFYaEdPMEZCUTBRc1EwRk9SRHM3UVVGUFFVb3NVVUZCVVN4RFFVRkRWU3hSUVVGVUxFZEJRVzlDTEZWQlFWTkRMRXRCUVZRc1JVRkJaMEk3UVVGRGJFTTdRVUZEUVN4TlFVRkpReXhOUVVGTkxFZEJRVWRFTEV0QlFVc3NRMEZCUTBVc1MwRkJUaXhEUVVGWkxHbERRVUZhTEVOQlFXSXNRMEZHYTBNc1EwRkpiRU03TzBGQlEwRXNUMEZCU3l4SlFVRkpReXhEUVVGRExFZEJRVWNzUTBGQllpeEZRVUZuUWtFc1EwRkJReXhIUVVGSFJpeE5RVUZOTEVOQlFVTkhMRTFCUVZBc1IwRkJaMElzUTBGQmNFTXNSVUZCZFVORUxFTkJRVU1zUlVGQmVFTXNSVUZCTkVNN1FVRkRNVU03UVVGRFFTeFJRVUZKTEVOQlFVTkdMRTFCUVUwc1EwRkJRMFVzUTBGQlF5eEhRVUZITEVOQlFVd3NRMEZCVUN4SlFVRnJRa1lzVFVGQlRTeERRVUZEUlN4RFFVRkRMRWRCUVVjc1EwRkJUQ3hEUVVGNFFpeEpRVU5MYUVJc2FVSkJRV2xDTEVOQlFVTlhMRWxCUVd4Q0xFTkJRWFZDUnl4TlFVRk5MRU5CUVVORkxFTkJRVVFzUTBGQk4wSXNRMEZFVEN4SlFVVkxhRUlzYVVKQlFXbENMRU5CUVVOWExFbEJRV3hDTEVOQlFYVkNSeXhOUVVGTkxFTkJRVU5GTEVOQlFVTXNSMEZCUnl4RFFVRk1MRU5CUVRkQ0xFTkJSbFFzUlVGRlowUTdRVUZET1VOR0xFMUJRVUZCTEUxQlFVMHNRMEZCUTBVc1EwRkJSQ3hEUVVGT0xFbEJRV0ZHTEUxQlFVMHNRMEZCUTBVc1EwRkJReXhIUVVGSExFTkJRVXdzUTBGQmJrSTdRVUZEUVVZc1RVRkJRVUVzVFVGQlRTeERRVUZEU1N4TlFVRlFMRU5CUVdOR0xFTkJRVU1zUjBGQlJ5eERRVUZzUWl4RlFVRnhRaXhEUVVGeVFqdEJRVU5CUVN4TlFVRkJRU3hEUVVGRE8wRkJRMFk3UVVGRFJqczdRVUZGUkN4VFFVRlBSaXhOUVVGUU8wRkJRMFFzUTBGcVFrUTdPMEZCYlVKUExGTkJRVk5MTEZOQlFWUXNRMEZCYlVKRExFMUJRVzVDTEVWQlFUSkNReXhOUVVFelFpeEZRVUZ0UTJRc1QwRkJia01zUlVGQk5FTTdRVUZEYWtSQkxFVkJRVUZCTEU5QlFVODdRVUZCUnp0QlFVRkJPMEZCUVVFN08wRkJRVUZsTzBGQlFVRkJPMEZCUVVGQk8wRkJRVUZCTzBGQlFVRkJPMEZCUVVGQk8wRkJRVUU3UVVGQlFTeEhRVUZuUW1Zc1QwRkJhRUlzUlVGQmVVSTdRVUZCUTBjc1NVRkJRVUVzWjBKQlFXZENMRVZCUVVVN1FVRkJia0lzUjBGQmVrSXNRMEZCVmp0QlFVTkJMRk5CUVU5U0xGRkJRVkVzUTBGQlEzRkNMRWxCUVZRc1EwRkJZMGdzVFVGQlpDeEZRVUZ6UWtNc1RVRkJkRUlzUlVGQk9FSmtMRTlCUVRsQ0xFTkJRVkE3UVVGRFJEczdRVUZGVFN4VFFVRlRhVUlzYTBKQlFWUXNRMEZCTkVKS0xFMUJRVFZDTEVWQlFXOURReXhOUVVGd1F5eEZRVUUwUTJRc1QwRkJOVU1zUlVGQmNVUTdRVUZETVVRc1UwRkJUMHdzVVVGQlVTeERRVUZEY1VJc1NVRkJWQ3hEUVVGalNDeE5RVUZrTEVWQlFYTkNReXhOUVVGMFFpeEZRVUU0UW1Rc1QwRkJPVUlzUTBGQlVEdEJRVU5FSWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaWFXMXdiM0owSUVScFptWWdabkp2YlNBbkxpOWlZWE5sSnp0Y2JtbHRjRzl5ZENCN1oyVnVaWEpoZEdWUGNIUnBiMjV6ZlNCbWNtOXRJQ2N1TGk5MWRHbHNMM0JoY21GdGN5YzdYRzVjYmk4dklFSmhjMlZrSUc5dUlHaDBkSEJ6T2k4dlpXNHVkMmxyYVhCbFpHbGhMbTl5Wnk5M2FXdHBMMHhoZEdsdVgzTmpjbWx3ZEY5cGJsOVZibWxqYjJSbFhHNHZMMXh1THk4Z1VtRnVaMlZ6SUdGdVpDQmxlR05sY0hScGIyNXpPbHh1THk4Z1RHRjBhVzR0TVNCVGRYQndiR1Z0Wlc1MExDQXdNRGd3NG9DVE1EQkdSbHh1THk4Z0lDMGdWU3N3TUVRM0lDRERseUJOZFd4MGFYQnNhV05oZEdsdmJpQnphV2R1WEc0dkx5QWdMU0JWS3pBd1JqY2dJTU8zSUVScGRtbHphVzl1SUhOcFoyNWNiaTh2SUV4aGRHbHVJRVY0ZEdWdVpHVmtMVUVzSURBeE1ERGlnSk13TVRkR1hHNHZMeUJNWVhScGJpQkZlSFJsYm1SbFpDMUNMQ0F3TVRndzRvQ1RNREkwUmx4dUx5OGdTVkJCSUVWNGRHVnVjMmx2Ym5Nc0lEQXlOVERpZ0pNd01rRkdYRzR2THlCVGNHRmphVzVuSUUxdlpHbG1hV1Z5SUV4bGRIUmxjbk1zSURBeVFqRGlnSk13TWtaR1hHNHZMeUFnTFNCVkt6QXlRemNnSU11SElDWWpOekV4T3lBZ1EyRnliMjVjYmk4dklDQXRJRlVyTURKRU9DQWd5NWdnSmlNM01qZzdJQ0JDY21WMlpWeHVMeThnSUMwZ1ZTc3dNa1E1SUNETG1TQW1JemN5T1RzZ0lFUnZkQ0JCWW05MlpWeHVMeThnSUMwZ1ZTc3dNa1JCSUNETG1pQW1JemN6TURzZ0lGSnBibWNnUVdKdmRtVmNiaTh2SUNBdElGVXJNREpFUWlBZ3k1c2dKaU0zTXpFN0lDQlBaMjl1Wld0Y2JpOHZJQ0F0SUZVck1ESkVReUFneTV3Z0ppTTNNekk3SUNCVGJXRnNiQ0JVYVd4a1pWeHVMeThnSUMwZ1ZTc3dNa1JFSUNETG5TQW1JemN6TXpzZ0lFUnZkV0pzWlNCQlkzVjBaU0JCWTJObGJuUmNiaTh2SUV4aGRHbHVJRVY0ZEdWdVpHVmtJRUZrWkdsMGFXOXVZV3dzSURGRk1ERGlnSk14UlVaR1hHNWpiMjV6ZENCbGVIUmxibVJsWkZkdmNtUkRhR0Z5Y3lBOUlDOWVXMkV0ZWtFdFdseGNkWHRETUgwdFhGeDFlMFpHZlZ4Y2RYdEVPSDB0WEZ4MWUwWTJmVnhjZFh0R09IMHRYRngxZXpKRE5uMWNYSFY3TWtNNGZTMWNYSFY3TWtRM2ZWeGNkWHN5UkVWOUxWeGNkWHN5UmtaOVhGeDFlekZGTURCOUxWeGNkWHN4UlVaR2ZWMHJKQzkxTzF4dVhHNWpiMjV6ZENCeVpWZG9hWFJsYzNCaFkyVWdQU0F2WEZ4VEx6dGNibHh1Wlhod2IzSjBJR052Ym5OMElIZHZjbVJFYVdabUlEMGdibVYzSUVScFptWW9LVHRjYm5kdmNtUkVhV1ptTG1WeGRXRnNjeUE5SUdaMWJtTjBhVzl1S0d4bFpuUXNJSEpwWjJoMEtTQjdYRzRnSUdsbUlDaDBhR2x6TG05d2RHbHZibk11YVdkdWIzSmxRMkZ6WlNrZ2UxeHVJQ0FnSUd4bFpuUWdQU0JzWldaMExuUnZURzkzWlhKRFlYTmxLQ2s3WEc0Z0lDQWdjbWxuYUhRZ1BTQnlhV2RvZEM1MGIweHZkMlZ5UTJGelpTZ3BPMXh1SUNCOVhHNGdJSEpsZEhWeWJpQnNaV1owSUQwOVBTQnlhV2RvZENCOGZDQW9kR2hwY3k1dmNIUnBiMjV6TG1sbmJtOXlaVmRvYVhSbGMzQmhZMlVnSmlZZ0lYSmxWMmhwZEdWemNHRmpaUzUwWlhOMEtHeGxablFwSUNZbUlDRnlaVmRvYVhSbGMzQmhZMlV1ZEdWemRDaHlhV2RvZENrcE8xeHVmVHRjYm5kdmNtUkVhV1ptTG5SdmEyVnVhWHBsSUQwZ1puVnVZM1JwYjI0b2RtRnNkV1VwSUh0Y2JpQWdMeThnUVd4c0lIZG9hWFJsYzNCaFkyVWdjM2x0WW05c2N5QmxlR05sY0hRZ2JtVjNiR2x1WlNCbmNtOTFjQ0JwYm5SdklHOXVaU0IwYjJ0bGJpd2daV0ZqYUNCdVpYZHNhVzVsSUMwZ2FXNGdjMlZ3WVhKaGRHVWdkRzlyWlc1Y2JpQWdiR1YwSUhSdmEyVnVjeUE5SUhaaGJIVmxMbk53YkdsMEtDOG9XMTVjWEZOY1hISmNYRzVkSzN4YktDbGJYRnhkZTMwblhDSmNYSEpjWEc1ZGZGeGNZaWt2S1R0Y2JseHVJQ0F2THlCS2IybHVJSFJvWlNCaWIzVnVaR0Z5ZVNCemNHeHBkSE1nZEdoaGRDQjNaU0JrYnlCdWIzUWdZMjl1YzJsa1pYSWdkRzhnWW1VZ1ltOTFibVJoY21sbGN5NGdWR2hwY3lCcGN5QndjbWx0WVhKcGJIa2dkR2hsSUdWNGRHVnVaR1ZrSUV4aGRHbHVJR05vWVhKaFkzUmxjaUJ6WlhRdVhHNGdJR1p2Y2lBb2JHVjBJR2tnUFNBd095QnBJRHdnZEc5clpXNXpMbXhsYm1kMGFDQXRJREU3SUdrckt5a2dlMXh1SUNBZ0lDOHZJRWxtSUhkbElHaGhkbVVnWVc0Z1pXMXdkSGtnYzNSeWFXNW5JR2x1SUhSb1pTQnVaWGgwSUdacFpXeGtJR0Z1WkNCM1pTQm9ZWFpsSUc5dWJIa2dkMjl5WkNCamFHRnljeUJpWldadmNtVWdZVzVrSUdGbWRHVnlMQ0J0WlhKblpWeHVJQ0FnSUdsbUlDZ2hkRzlyWlc1elcya2dLeUF4WFNBbUppQjBiMnRsYm5OYmFTQXJJREpkWEc0Z0lDQWdJQ0FnSUNBZ0ppWWdaWGgwWlc1a1pXUlhiM0prUTJoaGNuTXVkR1Z6ZENoMGIydGxibk5iYVYwcFhHNGdJQ0FnSUNBZ0lDQWdKaVlnWlhoMFpXNWtaV1JYYjNKa1EyaGhjbk11ZEdWemRDaDBiMnRsYm5OYmFTQXJJREpkS1NrZ2UxeHVJQ0FnSUNBZ2RHOXJaVzV6VzJsZElDczlJSFJ2YTJWdWMxdHBJQ3NnTWwwN1hHNGdJQ0FnSUNCMGIydGxibk11YzNCc2FXTmxLR2tnS3lBeExDQXlLVHRjYmlBZ0lDQWdJR2t0TFR0Y2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnZEc5clpXNXpPMXh1ZlR0Y2JseHVaWGh3YjNKMElHWjFibU4wYVc5dUlHUnBabVpYYjNKa2N5aHZiR1JUZEhJc0lHNWxkMU4wY2l3Z2IzQjBhVzl1Y3lrZ2UxeHVJQ0J2Y0hScGIyNXpJRDBnWjJWdVpYSmhkR1ZQY0hScGIyNXpLRzl3ZEdsdmJuTXNJSHRwWjI1dmNtVlhhR2wwWlhOd1lXTmxPaUIwY25WbGZTazdYRzRnSUhKbGRIVnliaUIzYjNKa1JHbG1aaTVrYVdabUtHOXNaRk4wY2l3Z2JtVjNVM1J5TENCdmNIUnBiMjV6S1R0Y2JuMWNibHh1Wlhod2IzSjBJR1oxYm1OMGFXOXVJR1JwWm1aWGIzSmtjMWRwZEdoVGNHRmpaU2h2YkdSVGRISXNJRzVsZDFOMGNpd2diM0IwYVc5dWN5a2dlMXh1SUNCeVpYUjFjbTRnZDI5eVpFUnBabVl1WkdsbVppaHZiR1JUZEhJc0lHNWxkMU4wY2l3Z2IzQjBhVzl1Y3lrN1hHNTlYRzRpWFgwPVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/word.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/diff/lib/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/mocha/node_modules/diff/lib/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*istanbul ignore start*/\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"Diff\", ({\n  enumerable: true,\n  get: function get() {\n    return _base[\"default\"];\n  }\n}));\nObject.defineProperty(exports, \"diffChars\", ({\n  enumerable: true,\n  get: function get() {\n    return _character.diffChars;\n  }\n}));\nObject.defineProperty(exports, \"diffWords\", ({\n  enumerable: true,\n  get: function get() {\n    return _word.diffWords;\n  }\n}));\nObject.defineProperty(exports, \"diffWordsWithSpace\", ({\n  enumerable: true,\n  get: function get() {\n    return _word.diffWordsWithSpace;\n  }\n}));\nObject.defineProperty(exports, \"diffLines\", ({\n  enumerable: true,\n  get: function get() {\n    return _line.diffLines;\n  }\n}));\nObject.defineProperty(exports, \"diffTrimmedLines\", ({\n  enumerable: true,\n  get: function get() {\n    return _line.diffTrimmedLines;\n  }\n}));\nObject.defineProperty(exports, \"diffSentences\", ({\n  enumerable: true,\n  get: function get() {\n    return _sentence.diffSentences;\n  }\n}));\nObject.defineProperty(exports, \"diffCss\", ({\n  enumerable: true,\n  get: function get() {\n    return _css.diffCss;\n  }\n}));\nObject.defineProperty(exports, \"diffJson\", ({\n  enumerable: true,\n  get: function get() {\n    return _json.diffJson;\n  }\n}));\nObject.defineProperty(exports, \"canonicalize\", ({\n  enumerable: true,\n  get: function get() {\n    return _json.canonicalize;\n  }\n}));\nObject.defineProperty(exports, \"diffArrays\", ({\n  enumerable: true,\n  get: function get() {\n    return _array.diffArrays;\n  }\n}));\nObject.defineProperty(exports, \"applyPatch\", ({\n  enumerable: true,\n  get: function get() {\n    return _apply.applyPatch;\n  }\n}));\nObject.defineProperty(exports, \"applyPatches\", ({\n  enumerable: true,\n  get: function get() {\n    return _apply.applyPatches;\n  }\n}));\nObject.defineProperty(exports, \"parsePatch\", ({\n  enumerable: true,\n  get: function get() {\n    return _parse.parsePatch;\n  }\n}));\nObject.defineProperty(exports, \"merge\", ({\n  enumerable: true,\n  get: function get() {\n    return _merge.merge;\n  }\n}));\nObject.defineProperty(exports, \"reversePatch\", ({\n  enumerable: true,\n  get: function get() {\n    return _reverse.reversePatch;\n  }\n}));\nObject.defineProperty(exports, \"structuredPatch\", ({\n  enumerable: true,\n  get: function get() {\n    return _create.structuredPatch;\n  }\n}));\nObject.defineProperty(exports, \"createTwoFilesPatch\", ({\n  enumerable: true,\n  get: function get() {\n    return _create.createTwoFilesPatch;\n  }\n}));\nObject.defineProperty(exports, \"createPatch\", ({\n  enumerable: true,\n  get: function get() {\n    return _create.createPatch;\n  }\n}));\nObject.defineProperty(exports, \"formatPatch\", ({\n  enumerable: true,\n  get: function get() {\n    return _create.formatPatch;\n  }\n}));\nObject.defineProperty(exports, \"convertChangesToDMP\", ({\n  enumerable: true,\n  get: function get() {\n    return _dmp.convertChangesToDMP;\n  }\n}));\nObject.defineProperty(exports, \"convertChangesToXML\", ({\n  enumerable: true,\n  get: function get() {\n    return _xml.convertChangesToXML;\n  }\n}));\n\n/*istanbul ignore end*/\nvar\n/*istanbul ignore start*/\n_base = _interopRequireDefault(__webpack_require__(/*! ./diff/base */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/base.js\"))\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_character = __webpack_require__(/*! ./diff/character */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/character.js\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_word = __webpack_require__(/*! ./diff/word */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/word.js\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_line = __webpack_require__(/*! ./diff/line */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/line.js\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_sentence = __webpack_require__(/*! ./diff/sentence */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/sentence.js\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_css = __webpack_require__(/*! ./diff/css */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/css.js\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_json = __webpack_require__(/*! ./diff/json */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/json.js\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_array = __webpack_require__(/*! ./diff/array */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/array.js\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_apply = __webpack_require__(/*! ./patch/apply */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/patch/apply.js\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_parse = __webpack_require__(/*! ./patch/parse */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/patch/parse.js\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_merge = __webpack_require__(/*! ./patch/merge */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/patch/merge.js\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_reverse = __webpack_require__(/*! ./patch/reverse */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/patch/reverse.js\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_create = __webpack_require__(/*! ./patch/create */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/patch/create.js\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_dmp = __webpack_require__(/*! ./convert/dmp */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/convert/dmp.js\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_xml = __webpack_require__(/*! ./convert/xml */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/convert/xml.js\")\n/*istanbul ignore end*/\n;\n\n/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/*istanbul ignore end*/\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZXNDb250ZW50IjpbIi8qIFNlZSBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zIG9mIHVzZSAqL1xuXG4vKlxuICogVGV4dCBkaWZmIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFRoaXMgbGlicmFyeSBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIEFQSXM6XG4gKiBEaWZmLmRpZmZDaGFyczogQ2hhcmFjdGVyIGJ5IGNoYXJhY3RlciBkaWZmXG4gKiBEaWZmLmRpZmZXb3JkczogV29yZCAoYXMgZGVmaW5lZCBieSBcXGIgcmVnZXgpIGRpZmYgd2hpY2ggaWdub3JlcyB3aGl0ZXNwYWNlXG4gKiBEaWZmLmRpZmZMaW5lczogTGluZSBiYXNlZCBkaWZmXG4gKlxuICogRGlmZi5kaWZmQ3NzOiBEaWZmIHRhcmdldGVkIGF0IENTUyBjb250ZW50XG4gKlxuICogVGhlc2UgbWV0aG9kcyBhcmUgYmFzZWQgb24gdGhlIGltcGxlbWVudGF0aW9uIHByb3Bvc2VkIGluXG4gKiBcIkFuIE8oTkQpIERpZmZlcmVuY2UgQWxnb3JpdGhtIGFuZCBpdHMgVmFyaWF0aW9uc1wiIChNeWVycywgMTk4NikuXG4gKiBodHRwOi8vY2l0ZXNlZXJ4LmlzdC5wc3UuZWR1L3ZpZXdkb2Mvc3VtbWFyeT9kb2k9MTAuMS4xLjQuNjkyN1xuICovXG5pbXBvcnQgRGlmZiBmcm9tICcuL2RpZmYvYmFzZSc7XG5pbXBvcnQge2RpZmZDaGFyc30gZnJvbSAnLi9kaWZmL2NoYXJhY3Rlcic7XG5pbXBvcnQge2RpZmZXb3JkcywgZGlmZldvcmRzV2l0aFNwYWNlfSBmcm9tICcuL2RpZmYvd29yZCc7XG5pbXBvcnQge2RpZmZMaW5lcywgZGlmZlRyaW1tZWRMaW5lc30gZnJvbSAnLi9kaWZmL2xpbmUnO1xuaW1wb3J0IHtkaWZmU2VudGVuY2VzfSBmcm9tICcuL2RpZmYvc2VudGVuY2UnO1xuXG5pbXBvcnQge2RpZmZDc3N9IGZyb20gJy4vZGlmZi9jc3MnO1xuaW1wb3J0IHtkaWZmSnNvbiwgY2Fub25pY2FsaXplfSBmcm9tICcuL2RpZmYvanNvbic7XG5cbmltcG9ydCB7ZGlmZkFycmF5c30gZnJvbSAnLi9kaWZmL2FycmF5JztcblxuaW1wb3J0IHthcHBseVBhdGNoLCBhcHBseVBhdGNoZXN9IGZyb20gJy4vcGF0Y2gvYXBwbHknO1xuaW1wb3J0IHtwYXJzZVBhdGNofSBmcm9tICcuL3BhdGNoL3BhcnNlJztcbmltcG9ydCB7bWVyZ2V9IGZyb20gJy4vcGF0Y2gvbWVyZ2UnO1xuaW1wb3J0IHtyZXZlcnNlUGF0Y2h9IGZyb20gJy4vcGF0Y2gvcmV2ZXJzZSc7XG5pbXBvcnQge3N0cnVjdHVyZWRQYXRjaCwgY3JlYXRlVHdvRmlsZXNQYXRjaCwgY3JlYXRlUGF0Y2gsIGZvcm1hdFBhdGNofSBmcm9tICcuL3BhdGNoL2NyZWF0ZSc7XG5cbmltcG9ydCB7Y29udmVydENoYW5nZXNUb0RNUH0gZnJvbSAnLi9jb252ZXJ0L2RtcCc7XG5pbXBvcnQge2NvbnZlcnRDaGFuZ2VzVG9YTUx9IGZyb20gJy4vY29udmVydC94bWwnO1xuXG5leHBvcnQge1xuICBEaWZmLFxuXG4gIGRpZmZDaGFycyxcbiAgZGlmZldvcmRzLFxuICBkaWZmV29yZHNXaXRoU3BhY2UsXG4gIGRpZmZMaW5lcyxcbiAgZGlmZlRyaW1tZWRMaW5lcyxcbiAgZGlmZlNlbnRlbmNlcyxcblxuICBkaWZmQ3NzLFxuICBkaWZmSnNvbixcblxuICBkaWZmQXJyYXlzLFxuXG4gIHN0cnVjdHVyZWRQYXRjaCxcbiAgY3JlYXRlVHdvRmlsZXNQYXRjaCxcbiAgY3JlYXRlUGF0Y2gsXG4gIGZvcm1hdFBhdGNoLFxuICBhcHBseVBhdGNoLFxuICBhcHBseVBhdGNoZXMsXG4gIHBhcnNlUGF0Y2gsXG4gIG1lcmdlLFxuICByZXZlcnNlUGF0Y2gsXG4gIGNvbnZlcnRDaGFuZ2VzVG9ETVAsXG4gIGNvbnZlcnRDaGFuZ2VzVG9YTUwsXG4gIGNhbm9uaWNhbGl6ZVxufTtcbiJdfQ==\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0NBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMkNBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNENBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YseUNBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDOztBQUVGO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBTyxDQUFDLGtGQUFhO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyw0RkFBa0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxtQkFBTyxDQUFDLGtGQUFhO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsbUJBQU8sQ0FBQyxrRkFBYTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLG1CQUFPLENBQUMsMEZBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8sbUJBQU8sQ0FBQyxnRkFBWTtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLG1CQUFPLENBQUMsa0ZBQWE7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxtQkFBTyxDQUFDLG9GQUFjO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsbUJBQU8sQ0FBQyxzRkFBZTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLG1CQUFPLENBQUMsc0ZBQWU7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxtQkFBTyxDQUFDLHNGQUFlO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQywwRkFBaUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLHdGQUFnQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLG1CQUFPLENBQUMsc0ZBQWU7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTyxtQkFBTyxDQUFDLHNGQUFlO0FBQzlCO0FBQ0E7O0FBRUEsaUVBQWlFLHVDQUF1Qzs7QUFFeEc7QUFDQSwyQ0FBMkMsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL2luZGV4LmpzPzAwN2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWZmXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9iYXNlW1wiZGVmYXVsdFwiXTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkaWZmQ2hhcnNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2NoYXJhY3Rlci5kaWZmQ2hhcnM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGlmZldvcmRzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF93b3JkLmRpZmZXb3JkcztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkaWZmV29yZHNXaXRoU3BhY2VcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3dvcmQuZGlmZldvcmRzV2l0aFNwYWNlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRpZmZMaW5lc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbGluZS5kaWZmTGluZXM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGlmZlRyaW1tZWRMaW5lc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbGluZS5kaWZmVHJpbW1lZExpbmVzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRpZmZTZW50ZW5jZXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NlbnRlbmNlLmRpZmZTZW50ZW5jZXM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGlmZkNzc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY3NzLmRpZmZDc3M7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGlmZkpzb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2pzb24uZGlmZkpzb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2Fub25pY2FsaXplXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9qc29uLmNhbm9uaWNhbGl6ZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkaWZmQXJyYXlzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hcnJheS5kaWZmQXJyYXlzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFwcGx5UGF0Y2hcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FwcGx5LmFwcGx5UGF0Y2g7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXBwbHlQYXRjaGVzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hcHBseS5hcHBseVBhdGNoZXM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VQYXRjaFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcGFyc2UucGFyc2VQYXRjaDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtZXJnZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbWVyZ2UubWVyZ2U7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmV2ZXJzZVBhdGNoXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9yZXZlcnNlLnJldmVyc2VQYXRjaDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJ1Y3R1cmVkUGF0Y2hcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2NyZWF0ZS5zdHJ1Y3R1cmVkUGF0Y2g7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlVHdvRmlsZXNQYXRjaFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY3JlYXRlLmNyZWF0ZVR3b0ZpbGVzUGF0Y2g7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlUGF0Y2hcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2NyZWF0ZS5jcmVhdGVQYXRjaDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmb3JtYXRQYXRjaFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY3JlYXRlLmZvcm1hdFBhdGNoO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbnZlcnRDaGFuZ2VzVG9ETVBcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2RtcC5jb252ZXJ0Q2hhbmdlc1RvRE1QO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbnZlcnRDaGFuZ2VzVG9YTUxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3htbC5jb252ZXJ0Q2hhbmdlc1RvWE1MO1xuICB9XG59KTtcblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2Jhc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2RpZmYvYmFzZVwiKSlcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2NoYXJhY3RlciA9IHJlcXVpcmUoXCIuL2RpZmYvY2hhcmFjdGVyXCIpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG52YXJcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl93b3JkID0gcmVxdWlyZShcIi4vZGlmZi93b3JkXCIpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG52YXJcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9saW5lID0gcmVxdWlyZShcIi4vZGlmZi9saW5lXCIpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG52YXJcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9zZW50ZW5jZSA9IHJlcXVpcmUoXCIuL2RpZmYvc2VudGVuY2VcIilcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2NzcyA9IHJlcXVpcmUoXCIuL2RpZmYvY3NzXCIpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG52YXJcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9qc29uID0gcmVxdWlyZShcIi4vZGlmZi9qc29uXCIpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG52YXJcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9hcnJheSA9IHJlcXVpcmUoXCIuL2RpZmYvYXJyYXlcIilcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2FwcGx5ID0gcmVxdWlyZShcIi4vcGF0Y2gvYXBwbHlcIilcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX3BhcnNlID0gcmVxdWlyZShcIi4vcGF0Y2gvcGFyc2VcIilcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX21lcmdlID0gcmVxdWlyZShcIi4vcGF0Y2gvbWVyZ2VcIilcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX3JldmVyc2UgPSByZXF1aXJlKFwiLi9wYXRjaC9yZXZlcnNlXCIpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG52YXJcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9jcmVhdGUgPSByZXF1aXJlKFwiLi9wYXRjaC9jcmVhdGVcIilcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2RtcCA9IHJlcXVpcmUoXCIuL2NvbnZlcnQvZG1wXCIpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG52YXJcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl94bWwgPSByZXF1aXJlKFwiLi9jb252ZXJ0L3htbFwiKVxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbjtcblxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMM055WXk5cGJtUmxlQzVxY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096dEJRV2RDUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk96dEJRVU5CTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN08wRkJRMEU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVRzN1FVRkRRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCT3p0QlFVTkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3TzBGQlJVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHM3UVVGRFFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPenRCUVVWQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdPMEZCUlVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUczdRVUZEUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk96dEJRVU5CTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN08wRkJRMEU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVRzN1FVRkRRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCT3p0QlFVVkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3TzBGQlEwRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRU0lzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWk4cUlGTmxaU0JNU1VORlRsTkZJR1pwYkdVZ1ptOXlJSFJsY20xeklHOW1JSFZ6WlNBcUwxeHVYRzR2S2x4dUlDb2dWR1Y0ZENCa2FXWm1JR2x0Y0d4bGJXVnVkR0YwYVc5dUxseHVJQ3BjYmlBcUlGUm9hWE1nYkdsaWNtRnllU0J6ZFhCd2IzSjBjeUIwYUdVZ1ptOXNiRzkzYVc1bklFRlFTWE02WEc0Z0tpQkVhV1ptTG1ScFptWkRhR0Z5Y3pvZ1EyaGhjbUZqZEdWeUlHSjVJR05vWVhKaFkzUmxjaUJrYVdabVhHNGdLaUJFYVdabUxtUnBabVpYYjNKa2N6b2dWMjl5WkNBb1lYTWdaR1ZtYVc1bFpDQmllU0JjWEdJZ2NtVm5aWGdwSUdScFptWWdkMmhwWTJnZ2FXZHViM0psY3lCM2FHbDBaWE53WVdObFhHNGdLaUJFYVdabUxtUnBabVpNYVc1bGN6b2dUR2x1WlNCaVlYTmxaQ0JrYVdabVhHNGdLbHh1SUNvZ1JHbG1aaTVrYVdabVEzTnpPaUJFYVdabUlIUmhjbWRsZEdWa0lHRjBJRU5UVXlCamIyNTBaVzUwWEc0Z0tseHVJQ29nVkdobGMyVWdiV1YwYUc5a2N5QmhjbVVnWW1GelpXUWdiMjRnZEdobElHbHRjR3hsYldWdWRHRjBhVzl1SUhCeWIzQnZjMlZrSUdsdVhHNGdLaUJjSWtGdUlFOG9Ua1FwSUVScFptWmxjbVZ1WTJVZ1FXeG5iM0pwZEdodElHRnVaQ0JwZEhNZ1ZtRnlhV0YwYVc5dWMxd2lJQ2hOZVdWeWN5d2dNVGs0TmlrdVhHNGdLaUJvZEhSd09pOHZZMmwwWlhObFpYSjRMbWx6ZEM1d2MzVXVaV1IxTDNacFpYZGtiMk12YzNWdGJXRnllVDlrYjJrOU1UQXVNUzR4TGpRdU5qa3lOMXh1SUNvdlhHNXBiWEJ2Y25RZ1JHbG1aaUJtY205dElDY3VMMlJwWm1ZdlltRnpaU2M3WEc1cGJYQnZjblFnZTJScFptWkRhR0Z5YzMwZ1puSnZiU0FuTGk5a2FXWm1MMk5vWVhKaFkzUmxjaWM3WEc1cGJYQnZjblFnZTJScFptWlhiM0prY3l3Z1pHbG1abGR2Y21SelYybDBhRk53WVdObGZTQm1jbTl0SUNjdUwyUnBabVl2ZDI5eVpDYzdYRzVwYlhCdmNuUWdlMlJwWm1aTWFXNWxjeXdnWkdsbVpsUnlhVzF0WldSTWFXNWxjMzBnWm5KdmJTQW5MaTlrYVdabUwyeHBibVVuTzF4dWFXMXdiM0owSUh0a2FXWm1VMlZ1ZEdWdVkyVnpmU0JtY205dElDY3VMMlJwWm1ZdmMyVnVkR1Z1WTJVbk8xeHVYRzVwYlhCdmNuUWdlMlJwWm1aRGMzTjlJR1p5YjIwZ0p5NHZaR2xtWmk5amMzTW5PMXh1YVcxd2IzSjBJSHRrYVdabVNuTnZiaXdnWTJGdWIyNXBZMkZzYVhwbGZTQm1jbTl0SUNjdUwyUnBabVl2YW5OdmJpYzdYRzVjYm1sdGNHOXlkQ0I3WkdsbVprRnljbUY1YzMwZ1puSnZiU0FuTGk5a2FXWm1MMkZ5Y21GNUp6dGNibHh1YVcxd2IzSjBJSHRoY0hCc2VWQmhkR05vTENCaGNIQnNlVkJoZEdOb1pYTjlJR1p5YjIwZ0p5NHZjR0YwWTJndllYQndiSGtuTzF4dWFXMXdiM0owSUh0d1lYSnpaVkJoZEdOb2ZTQm1jbTl0SUNjdUwzQmhkR05vTDNCaGNuTmxKenRjYm1sdGNHOXlkQ0I3YldWeVoyVjlJR1p5YjIwZ0p5NHZjR0YwWTJndmJXVnlaMlVuTzF4dWFXMXdiM0owSUh0eVpYWmxjbk5sVUdGMFkyaDlJR1p5YjIwZ0p5NHZjR0YwWTJndmNtVjJaWEp6WlNjN1hHNXBiWEJ2Y25RZ2UzTjBjblZqZEhWeVpXUlFZWFJqYUN3Z1kzSmxZWFJsVkhkdlJtbHNaWE5RWVhSamFDd2dZM0psWVhSbFVHRjBZMmdzSUdadmNtMWhkRkJoZEdOb2ZTQm1jbTl0SUNjdUwzQmhkR05vTDJOeVpXRjBaU2M3WEc1Y2JtbHRjRzl5ZENCN1kyOXVkbVZ5ZEVOb1lXNW5aWE5VYjBSTlVIMGdabkp2YlNBbkxpOWpiMjUyWlhKMEwyUnRjQ2M3WEc1cGJYQnZjblFnZTJOdmJuWmxjblJEYUdGdVoyVnpWRzlZVFV4OUlHWnliMjBnSnk0dlkyOXVkbVZ5ZEM5NGJXd25PMXh1WEc1bGVIQnZjblFnZTF4dUlDQkVhV1ptTEZ4dVhHNGdJR1JwWm1aRGFHRnljeXhjYmlBZ1pHbG1abGR2Y21SekxGeHVJQ0JrYVdabVYyOXlaSE5YYVhSb1UzQmhZMlVzWEc0Z0lHUnBabVpNYVc1bGN5eGNiaUFnWkdsbVpsUnlhVzF0WldSTWFXNWxjeXhjYmlBZ1pHbG1abE5sYm5SbGJtTmxjeXhjYmx4dUlDQmthV1ptUTNOekxGeHVJQ0JrYVdabVNuTnZiaXhjYmx4dUlDQmthV1ptUVhKeVlYbHpMRnh1WEc0Z0lITjBjblZqZEhWeVpXUlFZWFJqYUN4Y2JpQWdZM0psWVhSbFZIZHZSbWxzWlhOUVlYUmphQ3hjYmlBZ1kzSmxZWFJsVUdGMFkyZ3NYRzRnSUdadmNtMWhkRkJoZEdOb0xGeHVJQ0JoY0hCc2VWQmhkR05vTEZ4dUlDQmhjSEJzZVZCaGRHTm9aWE1zWEc0Z0lIQmhjbk5sVUdGMFkyZ3NYRzRnSUcxbGNtZGxMRnh1SUNCeVpYWmxjbk5sVUdGMFkyZ3NYRzRnSUdOdmJuWmxjblJEYUdGdVoyVnpWRzlFVFZBc1hHNGdJR052Ym5abGNuUkRhR0Z1WjJWelZHOVlUVXdzWEc0Z0lHTmhibTl1YVdOaGJHbDZaVnh1ZlR0Y2JpSmRmUT09XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/diff/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/diff/lib/patch/apply.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mocha/node_modules/diff/lib/patch/apply.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*istanbul ignore start*/\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.applyPatch = applyPatch;\nexports.applyPatches = applyPatches;\n\n/*istanbul ignore end*/\nvar\n/*istanbul ignore start*/\n_parse = __webpack_require__(/*! ./parse */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/patch/parse.js\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_distanceIterator = _interopRequireDefault(__webpack_require__(/*! ../util/distance-iterator */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/util/distance-iterator.js\"))\n/*istanbul ignore end*/\n;\n\n/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/*istanbul ignore end*/\nfunction applyPatch(source, uniDiff) {\n  /*istanbul ignore start*/\n  var\n  /*istanbul ignore end*/\n  options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (typeof uniDiff === 'string') {\n    uniDiff =\n    /*istanbul ignore start*/\n    (0,\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _parse\n    /*istanbul ignore end*/\n    .\n    /*istanbul ignore start*/\n    parsePatch)\n    /*istanbul ignore end*/\n    (uniDiff);\n  }\n\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n\n    uniDiff = uniDiff[0];\n  } // Apply the diff to the input\n\n\n  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      hunks = uniDiff.hunks,\n      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent)\n  /*istanbul ignore start*/\n  {\n    return (\n      /*istanbul ignore end*/\n      line === patchContent\n    );\n  },\n      errorCount = 0,\n      fuzzFactor = options.fuzzFactor || 0,\n      minLine = 0,\n      offset = 0,\n      removeEOFNL,\n      addEOFNL;\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n\n\n  function hunkFits(hunk, toPos) {\n    for (var j = 0; j < hunk.lines.length; j++) {\n      var line = hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line;\n\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n\n        toPos++;\n      }\n    }\n\n    return true;\n  } // Search best fit offsets for each hunk based on the previous ones\n\n\n  for (var i = 0; i < hunks.length; i++) {\n    var hunk = hunks[i],\n        maxLine = lines.length - hunk.oldLines,\n        localOffset = 0,\n        toPos = offset + hunk.oldStart - 1;\n    var iterator =\n    /*istanbul ignore start*/\n    (0,\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _distanceIterator\n    /*istanbul ignore end*/\n    [\n    /*istanbul ignore start*/\n    \"default\"\n    /*istanbul ignore end*/\n    ])(toPos, minLine, maxLine);\n\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n\n    if (localOffset === undefined) {\n      return false;\n    } // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n\n\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  } // Apply patch hunks\n\n\n  var diffOffset = 0;\n\n  for (var _i = 0; _i < hunks.length; _i++) {\n    var _hunk = hunks[_i],\n        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\n    diffOffset += _hunk.newLines - _hunk.oldLines;\n\n    for (var j = 0; j < _hunk.lines.length; j++) {\n      var line = _hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line,\n          delimiter = _hunk.linedelimiters && _hunk.linedelimiters[j] || '\\n';\n\n      if (operation === ' ') {\n        _toPos++;\n      } else if (operation === '-') {\n        lines.splice(_toPos, 1);\n        delimiters.splice(_toPos, 1);\n        /* istanbul ignore else */\n      } else if (operation === '+') {\n        lines.splice(_toPos, 0, content);\n        delimiters.splice(_toPos, 0, delimiter);\n        _toPos++;\n      } else if (operation === '\\\\') {\n        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\n        if (previousOperation === '+') {\n          removeEOFNL = true;\n        } else if (previousOperation === '-') {\n          addEOFNL = true;\n        }\n      }\n    }\n  } // Handle EOFNL insertion/removal\n\n\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n\n  for (var _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n\n  return lines.join('');\n} // Wrapper that supports multiple file patches via callbacks.\n\n\nfunction applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff =\n    /*istanbul ignore start*/\n    (0,\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _parse\n    /*istanbul ignore end*/\n    .\n    /*istanbul ignore start*/\n    parsePatch)\n    /*istanbul ignore end*/\n    (uniDiff);\n  }\n\n  var currentIndex = 0;\n\n  function processIndex() {\n    var index = uniDiff[currentIndex++];\n\n    if (!index) {\n      return options.complete();\n    }\n\n    options.loadFile(index, function (err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n\n      var updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function (err) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        processIndex();\n      });\n    });\n  }\n\n  processIndex();\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXRjaC9hcHBseS5qcyJdLCJuYW1lcyI6WyJhcHBseVBhdGNoIiwic291cmNlIiwidW5pRGlmZiIsIm9wdGlvbnMiLCJwYXJzZVBhdGNoIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwiRXJyb3IiLCJsaW5lcyIsInNwbGl0IiwiZGVsaW1pdGVycyIsIm1hdGNoIiwiaHVua3MiLCJjb21wYXJlTGluZSIsImxpbmVOdW1iZXIiLCJsaW5lIiwib3BlcmF0aW9uIiwicGF0Y2hDb250ZW50IiwiZXJyb3JDb3VudCIsImZ1enpGYWN0b3IiLCJtaW5MaW5lIiwib2Zmc2V0IiwicmVtb3ZlRU9GTkwiLCJhZGRFT0ZOTCIsImh1bmtGaXRzIiwiaHVuayIsInRvUG9zIiwiaiIsImNvbnRlbnQiLCJzdWJzdHIiLCJpIiwibWF4TGluZSIsIm9sZExpbmVzIiwibG9jYWxPZmZzZXQiLCJvbGRTdGFydCIsIml0ZXJhdG9yIiwiZGlzdGFuY2VJdGVyYXRvciIsInVuZGVmaW5lZCIsImRpZmZPZmZzZXQiLCJuZXdMaW5lcyIsImRlbGltaXRlciIsImxpbmVkZWxpbWl0ZXJzIiwic3BsaWNlIiwicHJldmlvdXNPcGVyYXRpb24iLCJwb3AiLCJwdXNoIiwiX2siLCJqb2luIiwiYXBwbHlQYXRjaGVzIiwiY3VycmVudEluZGV4IiwicHJvY2Vzc0luZGV4IiwiaW5kZXgiLCJjb21wbGV0ZSIsImxvYWRGaWxlIiwiZXJyIiwiZGF0YSIsInVwZGF0ZWRDb250ZW50IiwicGF0Y2hlZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7QUFFTyxTQUFTQSxVQUFULENBQW9CQyxNQUFwQixFQUE0QkMsT0FBNUIsRUFBbUQ7QUFBQTtBQUFBO0FBQUE7QUFBZEMsRUFBQUEsT0FBYyx1RUFBSixFQUFJOztBQUN4RCxNQUFJLE9BQU9ELE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7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QUFBO0FBQUFBO0FBQUE7QUFBQSxLQUFXRixPQUFYLENBQVY7QUFDRDs7QUFFRCxNQUFJZ0QsWUFBWSxHQUFHLENBQW5COztBQUNBLFdBQVNDLFlBQVQsR0FBd0I7QUFDdEIsUUFBSUMsS0FBSyxHQUFHbEQsT0FBTyxDQUFDZ0QsWUFBWSxFQUFiLENBQW5COztBQUNBLFFBQUksQ0FBQ0UsS0FBTCxFQUFZO0FBQ1YsYUFBT2pELE9BQU8sQ0FBQ2tELFFBQVIsRUFBUDtBQUNEOztBQUVEbEQsSUFBQUEsT0FBTyxDQUFDbUQsUUFBUixDQUFpQkYsS0FBakIsRUFBd0IsVUFBU0csR0FBVCxFQUFjQyxJQUFkLEVBQW9CO0FBQzFDLFVBQUlELEdBQUosRUFBUztBQUNQLGVBQU9wRCxPQUFPLENBQUNrRCxRQUFSLENBQWlCRSxHQUFqQixDQUFQO0FBQ0Q7O0FBRUQsVUFBSUUsY0FBYyxHQUFHekQsVUFBVSxDQUFDd0QsSUFBRCxFQUFPSixLQUFQLEVBQWNqRCxPQUFkLENBQS9CO0FBQ0FBLE1BQUFBLE9BQU8sQ0FBQ3VELE9BQVIsQ0FBZ0JOLEtBQWhCLEVBQXVCSyxjQUF2QixFQUF1QyxVQUFTRixHQUFULEVBQWM7QUFDbkQsWUFBSUEsR0FBSixFQUFTO0FBQ1AsaUJBQU9wRCxPQUFPLENBQUNrRCxRQUFSLENBQWlCRSxHQUFqQixDQUFQO0FBQ0Q7O0FBRURKLFFBQUFBLFlBQVk7QUFDYixPQU5EO0FBT0QsS0FiRDtBQWNEOztBQUNEQSxFQUFBQSxZQUFZO0FBQ2IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3BhcnNlUGF0Y2h9IGZyb20gJy4vcGFyc2UnO1xuaW1wb3J0IGRpc3RhbmNlSXRlcmF0b3IgZnJvbSAnLi4vdXRpbC9kaXN0YW5jZS1pdGVyYXRvcic7XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhdGNoKHNvdXJjZSwgdW5pRGlmZiwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICh0eXBlb2YgdW5pRGlmZiA9PT0gJ3N0cmluZycpIHtcbiAgICB1bmlEaWZmID0gcGFyc2VQYXRjaCh1bmlEaWZmKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHVuaURpZmYpKSB7XG4gICAgaWYgKHVuaURpZmYubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcHBseVBhdGNoIG9ubHkgd29ya3Mgd2l0aCBhIHNpbmdsZSBpbnB1dC4nKTtcbiAgICB9XG5cbiAgICB1bmlEaWZmID0gdW5pRGlmZlswXTtcbiAgfVxuXG4gIC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBpbnB1dFxuICBsZXQgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xcclxcbnxbXFxuXFx2XFxmXFxyXFx4ODVdLyksXG4gICAgICBkZWxpbWl0ZXJzID0gc291cmNlLm1hdGNoKC9cXHJcXG58W1xcblxcdlxcZlxcclxceDg1XS9nKSB8fCBbXSxcbiAgICAgIGh1bmtzID0gdW5pRGlmZi5odW5rcyxcblxuICAgICAgY29tcGFyZUxpbmUgPSBvcHRpb25zLmNvbXBhcmVMaW5lIHx8ICgobGluZU51bWJlciwgbGluZSwgb3BlcmF0aW9uLCBwYXRjaENvbnRlbnQpID0+IGxpbmUgPT09IHBhdGNoQ29udGVudCksXG4gICAgICBlcnJvckNvdW50ID0gMCxcbiAgICAgIGZ1enpGYWN0b3IgPSBvcHRpb25zLmZ1enpGYWN0b3IgfHwgMCxcbiAgICAgIG1pbkxpbmUgPSAwLFxuICAgICAgb2Zmc2V0ID0gMCxcblxuICAgICAgcmVtb3ZlRU9GTkwsXG4gICAgICBhZGRFT0ZOTDtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBodW5rIGV4YWN0bHkgZml0cyBvbiB0aGUgcHJvdmlkZWQgbG9jYXRpb25cbiAgICovXG4gIGZ1bmN0aW9uIGh1bmtGaXRzKGh1bmssIHRvUG9zKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBodW5rLmxpbmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICBsZXQgbGluZSA9IGh1bmsubGluZXNbal0sXG4gICAgICAgICAgb3BlcmF0aW9uID0gKGxpbmUubGVuZ3RoID4gMCA/IGxpbmVbMF0gOiAnICcpLFxuICAgICAgICAgIGNvbnRlbnQgPSAobGluZS5sZW5ndGggPiAwID8gbGluZS5zdWJzdHIoMSkgOiBsaW5lKTtcblxuICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJyAnIHx8IG9wZXJhdGlvbiA9PT0gJy0nKSB7XG4gICAgICAgIC8vIENvbnRleHQgc2FuaXR5IGNoZWNrXG4gICAgICAgIGlmICghY29tcGFyZUxpbmUodG9Qb3MgKyAxLCBsaW5lc1t0b1Bvc10sIG9wZXJhdGlvbiwgY29udGVudCkpIHtcbiAgICAgICAgICBlcnJvckNvdW50Kys7XG5cbiAgICAgICAgICBpZiAoZXJyb3JDb3VudCA+IGZ1enpGYWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdG9Qb3MrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFNlYXJjaCBiZXN0IGZpdCBvZmZzZXRzIGZvciBlYWNoIGh1bmsgYmFzZWQgb24gdGhlIHByZXZpb3VzIG9uZXNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBodW5rID0gaHVua3NbaV0sXG4gICAgICAgIG1heExpbmUgPSBsaW5lcy5sZW5ndGggLSBodW5rLm9sZExpbmVzLFxuICAgICAgICBsb2NhbE9mZnNldCA9IDAsXG4gICAgICAgIHRvUG9zID0gb2Zmc2V0ICsgaHVuay5vbGRTdGFydCAtIDE7XG5cbiAgICBsZXQgaXRlcmF0b3IgPSBkaXN0YW5jZUl0ZXJhdG9yKHRvUG9zLCBtaW5MaW5lLCBtYXhMaW5lKTtcblxuICAgIGZvciAoOyBsb2NhbE9mZnNldCAhPT0gdW5kZWZpbmVkOyBsb2NhbE9mZnNldCA9IGl0ZXJhdG9yKCkpIHtcbiAgICAgIGlmIChodW5rRml0cyhodW5rLCB0b1BvcyArIGxvY2FsT2Zmc2V0KSkge1xuICAgICAgICBodW5rLm9mZnNldCA9IG9mZnNldCArPSBsb2NhbE9mZnNldDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxvY2FsT2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTZXQgbG93ZXIgdGV4dCBsaW1pdCB0byBlbmQgb2YgdGhlIGN1cnJlbnQgaHVuaywgc28gbmV4dCBvbmVzIGRvbid0IHRyeVxuICAgIC8vIHRvIGZpdCBvdmVyIGFscmVhZHkgcGF0Y2hlZCB0ZXh0XG4gICAgbWluTGluZSA9IGh1bmsub2Zmc2V0ICsgaHVuay5vbGRTdGFydCArIGh1bmsub2xkTGluZXM7XG4gIH1cblxuICAvLyBBcHBseSBwYXRjaCBodW5rc1xuICBsZXQgZGlmZk9mZnNldCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgaHVuayA9IGh1bmtzW2ldLFxuICAgICAgICB0b1BvcyA9IGh1bmsub2xkU3RhcnQgKyBodW5rLm9mZnNldCArIGRpZmZPZmZzZXQgLSAxO1xuICAgIGRpZmZPZmZzZXQgKz0gaHVuay5uZXdMaW5lcyAtIGh1bmsub2xkTGluZXM7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGh1bmsubGluZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGxldCBsaW5lID0gaHVuay5saW5lc1tqXSxcbiAgICAgICAgICBvcGVyYXRpb24gPSAobGluZS5sZW5ndGggPiAwID8gbGluZVswXSA6ICcgJyksXG4gICAgICAgICAgY29udGVudCA9IChsaW5lLmxlbmd0aCA+IDAgPyBsaW5lLnN1YnN0cigxKSA6IGxpbmUpLFxuICAgICAgICAgIGRlbGltaXRlciA9IGh1bmsubGluZWRlbGltaXRlcnMgJiYgaHVuay5saW5lZGVsaW1pdGVyc1tqXSB8fCAnXFxuJztcblxuICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJyAnKSB7XG4gICAgICAgIHRvUG9zKys7XG4gICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJy0nKSB7XG4gICAgICAgIGxpbmVzLnNwbGljZSh0b1BvcywgMSk7XG4gICAgICAgIGRlbGltaXRlcnMuc3BsaWNlKHRvUG9zLCAxKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJysnKSB7XG4gICAgICAgIGxpbmVzLnNwbGljZSh0b1BvcywgMCwgY29udGVudCk7XG4gICAgICAgIGRlbGltaXRlcnMuc3BsaWNlKHRvUG9zLCAwLCBkZWxpbWl0ZXIpO1xuICAgICAgICB0b1BvcysrO1xuICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICdcXFxcJykge1xuICAgICAgICBsZXQgcHJldmlvdXNPcGVyYXRpb24gPSBodW5rLmxpbmVzW2ogLSAxXSA/IGh1bmsubGluZXNbaiAtIDFdWzBdIDogbnVsbDtcbiAgICAgICAgaWYgKHByZXZpb3VzT3BlcmF0aW9uID09PSAnKycpIHtcbiAgICAgICAgICByZW1vdmVFT0ZOTCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNPcGVyYXRpb24gPT09ICctJykge1xuICAgICAgICAgIGFkZEVPRk5MID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSBFT0ZOTCBpbnNlcnRpb24vcmVtb3ZhbFxuICBpZiAocmVtb3ZlRU9GTkwpIHtcbiAgICB3aGlsZSAoIWxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdKSB7XG4gICAgICBsaW5lcy5wb3AoKTtcbiAgICAgIGRlbGltaXRlcnMucG9wKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFkZEVPRk5MKSB7XG4gICAgbGluZXMucHVzaCgnJyk7XG4gICAgZGVsaW1pdGVycy5wdXNoKCdcXG4nKTtcbiAgfVxuICBmb3IgKGxldCBfayA9IDA7IF9rIDwgbGluZXMubGVuZ3RoIC0gMTsgX2srKykge1xuICAgIGxpbmVzW19rXSA9IGxpbmVzW19rXSArIGRlbGltaXRlcnNbX2tdO1xuICB9XG4gIHJldHVybiBsaW5lcy5qb2luKCcnKTtcbn1cblxuLy8gV3JhcHBlciB0aGF0IHN1cHBvcnRzIG11bHRpcGxlIGZpbGUgcGF0Y2hlcyB2aWEgY2FsbGJhY2tzLlxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UGF0Y2hlcyh1bmlEaWZmLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgdW5pRGlmZiA9PT0gJ3N0cmluZycpIHtcbiAgICB1bmlEaWZmID0gcGFyc2VQYXRjaCh1bmlEaWZmKTtcbiAgfVxuXG4gIGxldCBjdXJyZW50SW5kZXggPSAwO1xuICBmdW5jdGlvbiBwcm9jZXNzSW5kZXgoKSB7XG4gICAgbGV0IGluZGV4ID0gdW5pRGlmZltjdXJyZW50SW5kZXgrK107XG4gICAgaWYgKCFpbmRleCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmxvYWRGaWxlKGluZGV4LCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoZXJyKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHVwZGF0ZWRDb250ZW50ID0gYXBwbHlQYXRjaChkYXRhLCBpbmRleCwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLnBhdGNoZWQoaW5kZXgsIHVwZGF0ZWRDb250ZW50LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzSW5kZXgoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHByb2Nlc3NJbmRleCgpO1xufVxuIl19\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL3BhdGNoL2FwcGx5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCO0FBQ2xCLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtQkFBTyxDQUFDLGdGQUFTO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyxtQkFBTyxDQUFDLDZHQUEyQjtBQUM5RTtBQUNBOztBQUVBLGlFQUFpRSx1Q0FBdUM7O0FBRXhHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSixrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLDJCQUEyQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUEsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBOztBQUVBOztBQUVBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL3BhdGNoL2FwcGx5LmpzPzM0NzciXSwic291cmNlc0NvbnRlbnQiOlsiLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFwcGx5UGF0Y2ggPSBhcHBseVBhdGNoO1xuZXhwb3J0cy5hcHBseVBhdGNoZXMgPSBhcHBseVBhdGNoZXM7XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG52YXJcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9wYXJzZSA9IHJlcXVpcmUoXCIuL3BhcnNlXCIpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG52YXJcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9kaXN0YW5jZUl0ZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbC9kaXN0YW5jZS1pdGVyYXRvclwiKSlcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5mdW5jdGlvbiBhcHBseVBhdGNoKHNvdXJjZSwgdW5pRGlmZikge1xuICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gIHZhclxuICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICBpZiAodHlwZW9mIHVuaURpZmYgPT09ICdzdHJpbmcnKSB7XG4gICAgdW5pRGlmZiA9XG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICgwLFxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5cbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgX3BhcnNlXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAuXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgIHBhcnNlUGF0Y2gpXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAodW5pRGlmZik7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh1bmlEaWZmKSkge1xuICAgIGlmICh1bmlEaWZmLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYXBwbHlQYXRjaCBvbmx5IHdvcmtzIHdpdGggYSBzaW5nbGUgaW5wdXQuJyk7XG4gICAgfVxuXG4gICAgdW5pRGlmZiA9IHVuaURpZmZbMF07XG4gIH0gLy8gQXBwbHkgdGhlIGRpZmYgdG8gdGhlIGlucHV0XG5cblxuICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xcclxcbnxbXFxuXFx2XFxmXFxyXFx4ODVdLyksXG4gICAgICBkZWxpbWl0ZXJzID0gc291cmNlLm1hdGNoKC9cXHJcXG58W1xcblxcdlxcZlxcclxceDg1XS9nKSB8fCBbXSxcbiAgICAgIGh1bmtzID0gdW5pRGlmZi5odW5rcyxcbiAgICAgIGNvbXBhcmVMaW5lID0gb3B0aW9ucy5jb21wYXJlTGluZSB8fCBmdW5jdGlvbiAobGluZU51bWJlciwgbGluZSwgb3BlcmF0aW9uLCBwYXRjaENvbnRlbnQpXG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAge1xuICAgIHJldHVybiAoXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICAgbGluZSA9PT0gcGF0Y2hDb250ZW50XG4gICAgKTtcbiAgfSxcbiAgICAgIGVycm9yQ291bnQgPSAwLFxuICAgICAgZnV6ekZhY3RvciA9IG9wdGlvbnMuZnV6ekZhY3RvciB8fCAwLFxuICAgICAgbWluTGluZSA9IDAsXG4gICAgICBvZmZzZXQgPSAwLFxuICAgICAgcmVtb3ZlRU9GTkwsXG4gICAgICBhZGRFT0ZOTDtcbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgaHVuayBleGFjdGx5IGZpdHMgb24gdGhlIHByb3ZpZGVkIGxvY2F0aW9uXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaHVua0ZpdHMoaHVuaywgdG9Qb3MpIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGh1bmsubGluZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBsaW5lID0gaHVuay5saW5lc1tqXSxcbiAgICAgICAgICBvcGVyYXRpb24gPSBsaW5lLmxlbmd0aCA+IDAgPyBsaW5lWzBdIDogJyAnLFxuICAgICAgICAgIGNvbnRlbnQgPSBsaW5lLmxlbmd0aCA+IDAgPyBsaW5lLnN1YnN0cigxKSA6IGxpbmU7XG5cbiAgICAgIGlmIChvcGVyYXRpb24gPT09ICcgJyB8fCBvcGVyYXRpb24gPT09ICctJykge1xuICAgICAgICAvLyBDb250ZXh0IHNhbml0eSBjaGVja1xuICAgICAgICBpZiAoIWNvbXBhcmVMaW5lKHRvUG9zICsgMSwgbGluZXNbdG9Qb3NdLCBvcGVyYXRpb24sIGNvbnRlbnQpKSB7XG4gICAgICAgICAgZXJyb3JDb3VudCsrO1xuXG4gICAgICAgICAgaWYgKGVycm9yQ291bnQgPiBmdXp6RmFjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdG9Qb3MrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBTZWFyY2ggYmVzdCBmaXQgb2Zmc2V0cyBmb3IgZWFjaCBodW5rIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBvbmVzXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGh1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGh1bmsgPSBodW5rc1tpXSxcbiAgICAgICAgbWF4TGluZSA9IGxpbmVzLmxlbmd0aCAtIGh1bmsub2xkTGluZXMsXG4gICAgICAgIGxvY2FsT2Zmc2V0ID0gMCxcbiAgICAgICAgdG9Qb3MgPSBvZmZzZXQgKyBodW5rLm9sZFN0YXJ0IC0gMTtcbiAgICB2YXIgaXRlcmF0b3IgPVxuICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAoMCxcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgIF9kaXN0YW5jZUl0ZXJhdG9yXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICBbXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgIFwiZGVmYXVsdFwiXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICBdKSh0b1BvcywgbWluTGluZSwgbWF4TGluZSk7XG5cbiAgICBmb3IgKDsgbG9jYWxPZmZzZXQgIT09IHVuZGVmaW5lZDsgbG9jYWxPZmZzZXQgPSBpdGVyYXRvcigpKSB7XG4gICAgICBpZiAoaHVua0ZpdHMoaHVuaywgdG9Qb3MgKyBsb2NhbE9mZnNldCkpIHtcbiAgICAgICAgaHVuay5vZmZzZXQgPSBvZmZzZXQgKz0gbG9jYWxPZmZzZXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsb2NhbE9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBTZXQgbG93ZXIgdGV4dCBsaW1pdCB0byBlbmQgb2YgdGhlIGN1cnJlbnQgaHVuaywgc28gbmV4dCBvbmVzIGRvbid0IHRyeVxuICAgIC8vIHRvIGZpdCBvdmVyIGFscmVhZHkgcGF0Y2hlZCB0ZXh0XG5cblxuICAgIG1pbkxpbmUgPSBodW5rLm9mZnNldCArIGh1bmsub2xkU3RhcnQgKyBodW5rLm9sZExpbmVzO1xuICB9IC8vIEFwcGx5IHBhdGNoIGh1bmtzXG5cblxuICB2YXIgZGlmZk9mZnNldCA9IDA7XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGh1bmtzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBfaHVuayA9IGh1bmtzW19pXSxcbiAgICAgICAgX3RvUG9zID0gX2h1bmsub2xkU3RhcnQgKyBfaHVuay5vZmZzZXQgKyBkaWZmT2Zmc2V0IC0gMTtcblxuICAgIGRpZmZPZmZzZXQgKz0gX2h1bmsubmV3TGluZXMgLSBfaHVuay5vbGRMaW5lcztcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgX2h1bmsubGluZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBsaW5lID0gX2h1bmsubGluZXNbal0sXG4gICAgICAgICAgb3BlcmF0aW9uID0gbGluZS5sZW5ndGggPiAwID8gbGluZVswXSA6ICcgJyxcbiAgICAgICAgICBjb250ZW50ID0gbGluZS5sZW5ndGggPiAwID8gbGluZS5zdWJzdHIoMSkgOiBsaW5lLFxuICAgICAgICAgIGRlbGltaXRlciA9IF9odW5rLmxpbmVkZWxpbWl0ZXJzICYmIF9odW5rLmxpbmVkZWxpbWl0ZXJzW2pdIHx8ICdcXG4nO1xuXG4gICAgICBpZiAob3BlcmF0aW9uID09PSAnICcpIHtcbiAgICAgICAgX3RvUG9zKys7XG4gICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJy0nKSB7XG4gICAgICAgIGxpbmVzLnNwbGljZShfdG9Qb3MsIDEpO1xuICAgICAgICBkZWxpbWl0ZXJzLnNwbGljZShfdG9Qb3MsIDEpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICcrJykge1xuICAgICAgICBsaW5lcy5zcGxpY2UoX3RvUG9zLCAwLCBjb250ZW50KTtcbiAgICAgICAgZGVsaW1pdGVycy5zcGxpY2UoX3RvUG9zLCAwLCBkZWxpbWl0ZXIpO1xuICAgICAgICBfdG9Qb3MrKztcbiAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnXFxcXCcpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzT3BlcmF0aW9uID0gX2h1bmsubGluZXNbaiAtIDFdID8gX2h1bmsubGluZXNbaiAtIDFdWzBdIDogbnVsbDtcblxuICAgICAgICBpZiAocHJldmlvdXNPcGVyYXRpb24gPT09ICcrJykge1xuICAgICAgICAgIHJlbW92ZUVPRk5MID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c09wZXJhdGlvbiA9PT0gJy0nKSB7XG4gICAgICAgICAgYWRkRU9GTkwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEhhbmRsZSBFT0ZOTCBpbnNlcnRpb24vcmVtb3ZhbFxuXG5cbiAgaWYgKHJlbW92ZUVPRk5MKSB7XG4gICAgd2hpbGUgKCFsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSkge1xuICAgICAgbGluZXMucG9wKCk7XG4gICAgICBkZWxpbWl0ZXJzLnBvcCgpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhZGRFT0ZOTCkge1xuICAgIGxpbmVzLnB1c2goJycpO1xuICAgIGRlbGltaXRlcnMucHVzaCgnXFxuJyk7XG4gIH1cblxuICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbGluZXMubGVuZ3RoIC0gMTsgX2srKykge1xuICAgIGxpbmVzW19rXSA9IGxpbmVzW19rXSArIGRlbGltaXRlcnNbX2tdO1xuICB9XG5cbiAgcmV0dXJuIGxpbmVzLmpvaW4oJycpO1xufSAvLyBXcmFwcGVyIHRoYXQgc3VwcG9ydHMgbXVsdGlwbGUgZmlsZSBwYXRjaGVzIHZpYSBjYWxsYmFja3MuXG5cblxuZnVuY3Rpb24gYXBwbHlQYXRjaGVzKHVuaURpZmYsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiB1bmlEaWZmID09PSAnc3RyaW5nJykge1xuICAgIHVuaURpZmYgPVxuICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAoMCxcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgIF9wYXJzZVxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgLlxuICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICBwYXJzZVBhdGNoKVxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgKHVuaURpZmYpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRJbmRleCA9IDA7XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0luZGV4KCkge1xuICAgIHZhciBpbmRleCA9IHVuaURpZmZbY3VycmVudEluZGV4KytdO1xuXG4gICAgaWYgKCFpbmRleCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmxvYWRGaWxlKGluZGV4LCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKGVycik7XG4gICAgICB9XG5cbiAgICAgIHZhciB1cGRhdGVkQ29udGVudCA9IGFwcGx5UGF0Y2goZGF0YSwgaW5kZXgsIG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5wYXRjaGVkKGluZGV4LCB1cGRhdGVkQ29udGVudCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb2Nlc3NJbmRleCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBwcm9jZXNzSW5kZXgoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXdZWFJqYUM5aGNIQnNlUzVxY3lKZExDSnVZVzFsY3lJNld5SmhjSEJzZVZCaGRHTm9JaXdpYzI5MWNtTmxJaXdpZFc1cFJHbG1aaUlzSW05d2RHbHZibk1pTENKd1lYSnpaVkJoZEdOb0lpd2lRWEp5WVhraUxDSnBjMEZ5Y21GNUlpd2liR1Z1WjNSb0lpd2lSWEp5YjNJaUxDSnNhVzVsY3lJc0luTndiR2wwSWl3aVpHVnNhVzFwZEdWeWN5SXNJbTFoZEdOb0lpd2lhSFZ1YTNNaUxDSmpiMjF3WVhKbFRHbHVaU0lzSW14cGJtVk9kVzFpWlhJaUxDSnNhVzVsSWl3aWIzQmxjbUYwYVc5dUlpd2ljR0YwWTJoRGIyNTBaVzUwSWl3aVpYSnliM0pEYjNWdWRDSXNJbVoxZW5wR1lXTjBiM0lpTENKdGFXNU1hVzVsSWl3aWIyWm1jMlYwSWl3aWNtVnRiM1psUlU5R1Rrd2lMQ0poWkdSRlQwWk9UQ0lzSW1oMWJtdEdhWFJ6SWl3aWFIVnVheUlzSW5SdlVHOXpJaXdpYWlJc0ltTnZiblJsYm5RaUxDSnpkV0p6ZEhJaUxDSnBJaXdpYldGNFRHbHVaU0lzSW05c1pFeHBibVZ6SWl3aWJHOWpZV3hQWm1aelpYUWlMQ0p2YkdSVGRHRnlkQ0lzSW1sMFpYSmhkRzl5SWl3aVpHbHpkR0Z1WTJWSmRHVnlZWFJ2Y2lJc0luVnVaR1ZtYVc1bFpDSXNJbVJwWm1aUFptWnpaWFFpTENKdVpYZE1hVzVsY3lJc0ltUmxiR2x0YVhSbGNpSXNJbXhwYm1Wa1pXeHBiV2wwWlhKeklpd2ljM0JzYVdObElpd2ljSEpsZG1sdmRYTlBjR1Z5WVhScGIyNGlMQ0p3YjNBaUxDSndkWE5vSWl3aVgyc2lMQ0pxYjJsdUlpd2lZWEJ3YkhsUVlYUmphR1Z6SWl3aVkzVnljbVZ1ZEVsdVpHVjRJaXdpY0hKdlkyVnpjMGx1WkdWNElpd2lhVzVrWlhnaUxDSmpiMjF3YkdWMFpTSXNJbXh2WVdSR2FXeGxJaXdpWlhKeUlpd2laR0YwWVNJc0luVndaR0YwWldSRGIyNTBaVzUwSWl3aWNHRjBZMmhsWkNKZExDSnRZWEJ3YVc1bmN5STZJanM3T3pzN096czdPenRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdPMEZCUTBFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUczdPenM3UVVGRlR5eFRRVUZUUVN4VlFVRlVMRU5CUVc5Q1F5eE5RVUZ3UWl4RlFVRTBRa01zVDBGQk5VSXNSVUZCYlVRN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlpFTXNSVUZCUVVFc1QwRkJZeXgxUlVGQlNpeEZRVUZKT3p0QlFVTjRSQ3hOUVVGSkxFOUJRVTlFTEU5QlFWQXNTMEZCYlVJc1VVRkJka0lzUlVGQmFVTTdRVUZETDBKQkxFbEJRVUZCTEU5QlFVODdRVUZCUnp0QlFVRkJPMEZCUVVFN08wRkJRVUZGTzBGQlFVRkJPMEZCUVVGQk8wRkJRVUZCTzBGQlFVRkJPMEZCUVVGQk8wRkJRVUU3UVVGQlFTeExRVUZYUml4UFFVRllMRU5CUVZZN1FVRkRSRHM3UVVGRlJDeE5RVUZKUnl4TFFVRkxMRU5CUVVORExFOUJRVTRzUTBGQlkwb3NUMEZCWkN4RFFVRktMRVZCUVRSQ08wRkJRekZDTEZGQlFVbEJMRTlCUVU4c1EwRkJRMHNzVFVGQlVpeEhRVUZwUWl4RFFVRnlRaXhGUVVGM1FqdEJRVU4wUWl4WlFVRk5MRWxCUVVsRExFdEJRVW9zUTBGQlZTdzBRMEZCVml4RFFVRk9PMEZCUTBRN08wRkJSVVJPTEVsQlFVRkJMRTlCUVU4c1IwRkJSMEVzVDBGQlR5eERRVUZETEVOQlFVUXNRMEZCYWtJN1FVRkRSQ3hIUVZoMVJDeERRV0Y0UkRzN08wRkJRMEVzVFVGQlNVOHNTMEZCU3l4SFFVRkhVaXhOUVVGTkxFTkJRVU5UTEV0QlFWQXNRMEZCWVN4eFFrRkJZaXhEUVVGYU8wRkJRVUVzVFVGRFNVTXNWVUZCVlN4SFFVRkhWaXhOUVVGTkxFTkJRVU5YTEV0QlFWQXNRMEZCWVN4elFrRkJZaXhMUVVGM1F5eEZRVVI2UkR0QlFVRkJMRTFCUlVsRExFdEJRVXNzUjBGQlIxZ3NUMEZCVHl4RFFVRkRWeXhMUVVad1FqdEJRVUZCTEUxQlNVbERMRmRCUVZjc1IwRkJSMWdzVDBGQlR5eERRVUZEVnl4WFFVRlNMRWxCUVhkQ0xGVkJRVU5ETEZWQlFVUXNSVUZCWVVNc1NVRkJZaXhGUVVGdFFrTXNVMEZCYmtJc1JVRkJPRUpETEZsQlFUbENPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQkswTkdMRTFCUVVGQkxFbEJRVWtzUzBGQlMwVTdRVUZCZUVRN1FVRkJRU3hIUVVveFF6dEJRVUZCTEUxQlMwbERMRlZCUVZVc1IwRkJSeXhEUVV4cVFqdEJRVUZCTEUxQlRVbERMRlZCUVZVc1IwRkJSMnBDTEU5QlFVOHNRMEZCUTJsQ0xGVkJRVklzU1VGQmMwSXNRMEZPZGtNN1FVRkJRU3hOUVU5SlF5eFBRVUZQTEVkQlFVY3NRMEZRWkR0QlFVRkJMRTFCVVVsRExFMUJRVTBzUjBGQlJ5eERRVkppTzBGQlFVRXNUVUZWU1VNc1YwRldTanRCUVVGQkxFMUJWMGxETEZGQldFbzdRVUZoUVRzN096czdRVUZIUVN4WFFVRlRReXhSUVVGVUxFTkJRV3RDUXl4SlFVRnNRaXhGUVVGM1FrTXNTMEZCZUVJc1JVRkJLMEk3UVVGRE4wSXNVMEZCU3l4SlFVRkpReXhEUVVGRExFZEJRVWNzUTBGQllpeEZRVUZuUWtFc1EwRkJReXhIUVVGSFJpeEpRVUZKTEVOQlFVTnFRaXhMUVVGTUxFTkJRVmRHTEUxQlFTOUNMRVZCUVhWRGNVSXNRMEZCUXl4RlFVRjRReXhGUVVFMFF6dEJRVU14UXl4VlFVRkpXaXhKUVVGSkxFZEJRVWRWTEVsQlFVa3NRMEZCUTJwQ0xFdEJRVXdzUTBGQlYyMUNMRU5CUVZnc1EwRkJXRHRCUVVGQkxGVkJRMGxZTEZOQlFWTXNSMEZCU1VRc1NVRkJTU3hEUVVGRFZDeE5RVUZNTEVkQlFXTXNRMEZCWkN4SFFVRnJRbE1zU1VGQlNTeERRVUZETEVOQlFVUXNRMEZCZEVJc1IwRkJORUlzUjBGRU4wTTdRVUZCUVN4VlFVVkpZU3hQUVVGUExFZEJRVWxpTEVsQlFVa3NRMEZCUTFRc1RVRkJUQ3hIUVVGakxFTkJRV1FzUjBGQmEwSlRMRWxCUVVrc1EwRkJRMk1zVFVGQlRDeERRVUZaTEVOQlFWb3NRMEZCYkVJc1IwRkJiVU5rTEVsQlJteEVPenRCUVVsQkxGVkJRVWxETEZOQlFWTXNTMEZCU3l4SFFVRmtMRWxCUVhGQ1FTeFRRVUZUTEV0QlFVc3NSMEZCZGtNc1JVRkJORU03UVVGRE1VTTdRVUZEUVN4WlFVRkpMRU5CUVVOSUxGZEJRVmNzUTBGQlEyRXNTMEZCU3l4SFFVRkhMRU5CUVZRc1JVRkJXV3hDTEV0QlFVc3NRMEZCUTJ0Q0xFdEJRVVFzUTBGQmFrSXNSVUZCTUVKV0xGTkJRVEZDTEVWQlFYRkRXU3hQUVVGeVF5eERRVUZvUWl4RlFVRXJSRHRCUVVNM1JGWXNWVUZCUVVFc1ZVRkJWVHM3UVVGRlZpeGpRVUZKUVN4VlFVRlZMRWRCUVVkRExGVkJRV3BDTEVWQlFUWkNPMEZCUXpOQ0xHMUNRVUZQTEV0QlFWQTdRVUZEUkR0QlFVTkdPenRCUVVORVR5eFJRVUZCUVN4TFFVRkxPMEZCUTA0N1FVRkRSanM3UVVGRlJDeFhRVUZQTEVsQlFWQTdRVUZEUkN4SFFXeEVkVVFzUTBGdlJIaEVPenM3UVVGRFFTeFBRVUZMTEVsQlFVbEpMRU5CUVVNc1IwRkJSeXhEUVVGaUxFVkJRV2RDUVN4RFFVRkRMRWRCUVVkc1FpeExRVUZMTEVOQlFVTk9MRTFCUVRGQ0xFVkJRV3REZDBJc1EwRkJReXhGUVVGdVF5eEZRVUYxUXp0QlFVTnlReXhSUVVGSlRDeEpRVUZKTEVkQlFVZGlMRXRCUVVzc1EwRkJRMnRDTEVOQlFVUXNRMEZCYUVJN1FVRkJRU3hSUVVOSlF5eFBRVUZQTEVkQlFVZDJRaXhMUVVGTExFTkJRVU5HTEUxQlFVNHNSMEZCWlcxQ0xFbEJRVWtzUTBGQlEwOHNVVUZFYkVNN1FVRkJRU3hSUVVWSlF5eFhRVUZYTEVkQlFVY3NRMEZHYkVJN1FVRkJRU3hSUVVkSlVDeExRVUZMTEVkQlFVZE1MRTFCUVUwc1IwRkJSMGtzU1VGQlNTeERRVUZEVXl4UlFVRmtMRWRCUVhsQ0xFTkJTSEpETzBGQlMwRXNVVUZCU1VNc1VVRkJVVHRCUVVGSE8wRkJRVUU3UVVGQlFUczdRVUZCUVVNN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUVzVDBGQmFVSldMRXRCUVdwQ0xFVkJRWGRDVGl4UFFVRjRRaXhGUVVGcFExY3NUMEZCYWtNc1EwRkJaanM3UVVGRlFTeFhRVUZQUlN4WFFVRlhMRXRCUVV0SkxGTkJRWFpDTEVWQlFXdERTaXhYUVVGWExFZEJRVWRGTEZGQlFWRXNSVUZCZUVRc1JVRkJORVE3UVVGRE1VUXNWVUZCU1Znc1VVRkJVU3hEUVVGRFF5eEpRVUZFTEVWQlFVOURMRXRCUVVzc1IwRkJSMDhzVjBGQlppeERRVUZhTEVWQlFYbERPMEZCUTNaRFVpeFJRVUZCUVN4SlFVRkpMRU5CUVVOS0xFMUJRVXdzUjBGQlkwRXNUVUZCVFN4SlFVRkpXU3hYUVVGNFFqdEJRVU5CTzBGQlEwUTdRVUZEUmpzN1FVRkZSQ3hSUVVGSlFTeFhRVUZYTEV0QlFVdEpMRk5CUVhCQ0xFVkJRU3RDTzBGQlF6ZENMR0ZCUVU4c1MwRkJVRHRCUVVORUxFdEJha0p2UXl4RFFXMUNja003UVVGRFFUczdPMEZCUTBGcVFpeEpRVUZCUVN4UFFVRlBMRWRCUVVkTExFbEJRVWtzUTBGQlEwb3NUVUZCVEN4SFFVRmpTU3hKUVVGSkxFTkJRVU5UTEZGQlFXNUNMRWRCUVRoQ1ZDeEpRVUZKTEVOQlFVTlBMRkZCUVRkRE8wRkJRMFFzUjBFelJYVkVMRU5CTmtWNFJEczdPMEZCUTBFc1RVRkJTVTBzVlVGQlZTeEhRVUZITEVOQlFXcENPenRCUVVOQkxFOUJRVXNzU1VGQlNWSXNSVUZCUXl4SFFVRkhMRU5CUVdJc1JVRkJaMEpCTEVWQlFVTXNSMEZCUjJ4Q0xFdEJRVXNzUTBGQlEwNHNUVUZCTVVJc1JVRkJhME4zUWl4RlFVRkRMRVZCUVc1RExFVkJRWFZETzBGQlEzSkRMRkZCUVVsTUxFdEJRVWtzUjBGQlIySXNTMEZCU3l4RFFVRkRhMElzUlVGQlJDeERRVUZvUWp0QlFVRkJMRkZCUTBsS0xFMUJRVXNzUjBGQlIwUXNTMEZCU1N4RFFVRkRVeXhSUVVGTUxFZEJRV2RDVkN4TFFVRkpMRU5CUVVOS0xFMUJRWEpDTEVkQlFUaENhVUlzVlVGQk9VSXNSMEZCTWtNc1EwRkVka1E3TzBGQlJVRkJMRWxCUVVGQkxGVkJRVlVzU1VGQlNXSXNTMEZCU1N4RFFVRkRZeXhSUVVGTUxFZEJRV2RDWkN4TFFVRkpMRU5CUVVOUExGRkJRVzVET3p0QlFVVkJMRk5CUVVzc1NVRkJTVXdzUTBGQlF5eEhRVUZITEVOQlFXSXNSVUZCWjBKQkxFTkJRVU1zUjBGQlIwWXNTMEZCU1N4RFFVRkRha0lzUzBGQlRDeERRVUZYUml4TlFVRXZRaXhGUVVGMVEzRkNMRU5CUVVNc1JVRkJlRU1zUlVGQk5FTTdRVUZETVVNc1ZVRkJTVm9zU1VGQlNTeEhRVUZIVlN4TFFVRkpMRU5CUVVOcVFpeExRVUZNTEVOQlFWZHRRaXhEUVVGWUxFTkJRVmc3UVVGQlFTeFZRVU5KV0N4VFFVRlRMRWRCUVVsRUxFbEJRVWtzUTBGQlExUXNUVUZCVEN4SFFVRmpMRU5CUVdRc1IwRkJhMEpUTEVsQlFVa3NRMEZCUXl4RFFVRkVMRU5CUVhSQ0xFZEJRVFJDTEVkQlJEZERPMEZCUVVFc1ZVRkZTV0VzVDBGQlR5eEhRVUZKWWl4SlFVRkpMRU5CUVVOVUxFMUJRVXdzUjBGQll5eERRVUZrTEVkQlFXdENVeXhKUVVGSkxFTkJRVU5qTEUxQlFVd3NRMEZCV1N4RFFVRmFMRU5CUVd4Q0xFZEJRVzFEWkN4SlFVWnNSRHRCUVVGQkxGVkJSMGw1UWl4VFFVRlRMRWRCUVVkbUxFdEJRVWtzUTBGQlEyZENMR05CUVV3c1NVRkJkVUpvUWl4TFFVRkpMRU5CUVVOblFpeGpRVUZNTEVOQlFXOUNaQ3hEUVVGd1FpeERRVUYyUWl4SlFVRnBSQ3hKUVVocVJUczdRVUZMUVN4VlFVRkpXQ3hUUVVGVExFdEJRVXNzUjBGQmJFSXNSVUZCZFVJN1FVRkRja0pWTEZGQlFVRkJMRTFCUVVzN1FVRkRUaXhQUVVaRUxFMUJSVThzU1VGQlNWWXNVMEZCVXl4TFFVRkxMRWRCUVd4Q0xFVkJRWFZDTzBGQlF6VkNVaXhSUVVGQlFTeExRVUZMTEVOQlFVTnJReXhOUVVGT0xFTkJRV0ZvUWl4TlFVRmlMRVZCUVc5Q0xFTkJRWEJDTzBGQlEwRm9RaXhSUVVGQlFTeFZRVUZWTEVOQlFVTm5ReXhOUVVGWUxFTkJRV3RDYUVJc1RVRkJiRUlzUlVGQmVVSXNRMEZCZWtJN1FVRkRSanRCUVVORExFOUJTazBzVFVGSlFTeEpRVUZKVml4VFFVRlRMRXRCUVVzc1IwRkJiRUlzUlVGQmRVSTdRVUZETlVKU0xGRkJRVUZCTEV0QlFVc3NRMEZCUTJ0RExFMUJRVTRzUTBGQllXaENMRTFCUVdJc1JVRkJiMElzUTBGQmNFSXNSVUZCZFVKRkxFOUJRWFpDTzBGQlEwRnNRaXhSUVVGQlFTeFZRVUZWTEVOQlFVTm5ReXhOUVVGWUxFTkJRV3RDYUVJc1RVRkJiRUlzUlVGQmVVSXNRMEZCZWtJc1JVRkJORUpqTEZOQlFUVkNPMEZCUTBGa0xGRkJRVUZCTEUxQlFVczdRVUZEVGl4UFFVcE5MRTFCU1VFc1NVRkJTVllzVTBGQlV5eExRVUZMTEVsQlFXeENMRVZCUVhkQ08wRkJRemRDTEZsQlFVa3lRaXhwUWtGQmFVSXNSMEZCUjJ4Q0xFdEJRVWtzUTBGQlEycENMRXRCUVV3c1EwRkJWMjFDTEVOQlFVTXNSMEZCUnl4RFFVRm1MRWxCUVc5Q1JpeExRVUZKTEVOQlFVTnFRaXhMUVVGTUxFTkJRVmR0UWl4RFFVRkRMRWRCUVVjc1EwRkJaaXhGUVVGclFpeERRVUZzUWl4RFFVRndRaXhIUVVFeVF5eEpRVUZ1UlRzN1FVRkRRU3haUVVGSlowSXNhVUpCUVdsQ0xFdEJRVXNzUjBGQk1VSXNSVUZCSzBJN1FVRkROMEp5UWl4VlFVRkJRU3hYUVVGWExFZEJRVWNzU1VGQlpEdEJRVU5FTEZOQlJrUXNUVUZGVHl4SlFVRkpjVUlzYVVKQlFXbENMRXRCUVVzc1IwRkJNVUlzUlVGQkswSTdRVUZEY0VOd1FpeFZRVUZCUVN4UlFVRlJMRWRCUVVjc1NVRkJXRHRCUVVORU8wRkJRMFk3UVVGRFJqdEJRVU5HTEVkQk4wZDFSQ3hEUVN0SGVFUTdPenRCUVVOQkxFMUJRVWxFTEZkQlFVb3NSVUZCYVVJN1FVRkRaaXhYUVVGUExFTkJRVU5rTEV0QlFVc3NRMEZCUTBFc1MwRkJTeXhEUVVGRFJpeE5RVUZPTEVkQlFXVXNRMEZCYUVJc1EwRkJZaXhGUVVGcFF6dEJRVU12UWtVc1RVRkJRVUVzUzBGQlN5eERRVUZEYjBNc1IwRkJUanRCUVVOQmJFTXNUVUZCUVVFc1ZVRkJWU3hEUVVGRGEwTXNSMEZCV0R0QlFVTkVPMEZCUTBZc1IwRk1SQ3hOUVV0UExFbEJRVWx5UWl4UlFVRktMRVZCUVdNN1FVRkRia0ptTEVsQlFVRkJMRXRCUVVzc1EwRkJRM0ZETEVsQlFVNHNRMEZCVnl4RlFVRllPMEZCUTBGdVF5eEpRVUZCUVN4VlFVRlZMRU5CUVVOdFF5eEpRVUZZTEVOQlFXZENMRWxCUVdoQ08wRkJRMFE3TzBGQlEwUXNUMEZCU3l4SlFVRkpReXhGUVVGRkxFZEJRVWNzUTBGQlpDeEZRVUZwUWtFc1JVRkJSU3hIUVVGSGRFTXNTMEZCU3l4RFFVRkRSaXhOUVVGT0xFZEJRV1VzUTBGQmNrTXNSVUZCZDBOM1F5eEZRVUZGTEVWQlFURkRMRVZCUVRoRE8wRkJRelZEZEVNc1NVRkJRVUVzUzBGQlN5eERRVUZEYzBNc1JVRkJSQ3hEUVVGTUxFZEJRVmwwUXl4TFFVRkxMRU5CUVVOelF5eEZRVUZFTEVOQlFVd3NSMEZCV1hCRExGVkJRVlVzUTBGQlEyOURMRVZCUVVRc1EwRkJiRU03UVVGRFJEczdRVUZEUkN4VFFVRlBkRU1zUzBGQlN5eERRVUZEZFVNc1NVRkJUaXhEUVVGWExFVkJRVmdzUTBGQlVEdEJRVU5FTEVNc1EwRkZSRHM3TzBGQlEwOHNVMEZCVTBNc1dVRkJWQ3hEUVVGelFpOURMRTlCUVhSQ0xFVkJRU3RDUXl4UFFVRXZRaXhGUVVGM1F6dEJRVU0zUXl4TlFVRkpMRTlCUVU5RUxFOUJRVkFzUzBGQmJVSXNVVUZCZGtJc1JVRkJhVU03UVVGREwwSkJMRWxCUVVGQkxFOUJRVTg3UVVGQlJ6dEJRVUZCTzBGQlFVRTdPMEZCUVVGRk8wRkJRVUZCTzBGQlFVRkJPMEZCUVVGQk8wRkJRVUZCTzBGQlFVRkJPMEZCUVVFN1FVRkJRU3hMUVVGWFJpeFBRVUZZTEVOQlFWWTdRVUZEUkRzN1FVRkZSQ3hOUVVGSlowUXNXVUZCV1N4SFFVRkhMRU5CUVc1Q096dEJRVU5CTEZkQlFWTkRMRmxCUVZRc1IwRkJkMEk3UVVGRGRFSXNVVUZCU1VNc1MwRkJTeXhIUVVGSGJFUXNUMEZCVHl4RFFVRkRaMFFzV1VGQldTeEZRVUZpTEVOQlFXNUNPenRCUVVOQkxGRkJRVWtzUTBGQlEwVXNTMEZCVEN4RlFVRlpPMEZCUTFZc1lVRkJUMnBFTEU5QlFVOHNRMEZCUTJ0RUxGRkJRVklzUlVGQlVEdEJRVU5FT3p0QlFVVkViRVFzU1VGQlFVRXNUMEZCVHl4RFFVRkRiVVFzVVVGQlVpeERRVUZwUWtZc1MwRkJha0lzUlVGQmQwSXNWVUZCVTBjc1IwRkJWQ3hGUVVGalF5eEpRVUZrTEVWQlFXOUNPMEZCUXpGRExGVkJRVWxFTEVkQlFVb3NSVUZCVXp0QlFVTlFMR1ZCUVU5d1JDeFBRVUZQTEVOQlFVTnJSQ3hSUVVGU0xFTkJRV2xDUlN4SFFVRnFRaXhEUVVGUU8wRkJRMFE3TzBGQlJVUXNWVUZCU1VVc1kwRkJZeXhIUVVGSGVrUXNWVUZCVlN4RFFVRkRkMFFzU1VGQlJDeEZRVUZQU2l4TFFVRlFMRVZCUVdOcVJDeFBRVUZrTEVOQlFTOUNPMEZCUTBGQkxFMUJRVUZCTEU5QlFVOHNRMEZCUTNWRUxFOUJRVklzUTBGQlowSk9MRXRCUVdoQ0xFVkJRWFZDU3l4alFVRjJRaXhGUVVGMVF5eFZRVUZUUml4SFFVRlVMRVZCUVdNN1FVRkRia1FzV1VGQlNVRXNSMEZCU2l4RlFVRlRPMEZCUTFBc2FVSkJRVTl3UkN4UFFVRlBMRU5CUVVOclJDeFJRVUZTTEVOQlFXbENSU3hIUVVGcVFpeERRVUZRTzBGQlEwUTdPMEZCUlVSS0xGRkJRVUZCTEZsQlFWazdRVUZEWWl4UFFVNUVPMEZCVDBRc1MwRmlSRHRCUVdORU96dEJRVU5FUVN4RlFVRkJRU3haUVVGWk8wRkJRMklpTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKcGJYQnZjblFnZTNCaGNuTmxVR0YwWTJoOUlHWnliMjBnSnk0dmNHRnljMlVuTzF4dWFXMXdiM0owSUdScGMzUmhibU5sU1hSbGNtRjBiM0lnWm5KdmJTQW5MaTR2ZFhScGJDOWthWE4wWVc1alpTMXBkR1Z5WVhSdmNpYzdYRzVjYm1WNGNHOXlkQ0JtZFc1amRHbHZiaUJoY0hCc2VWQmhkR05vS0hOdmRYSmpaU3dnZFc1cFJHbG1aaXdnYjNCMGFXOXVjeUE5SUh0OUtTQjdYRzRnSUdsbUlDaDBlWEJsYjJZZ2RXNXBSR2xtWmlBOVBUMGdKM04wY21sdVp5Y3BJSHRjYmlBZ0lDQjFibWxFYVdabUlEMGdjR0Z5YzJWUVlYUmphQ2gxYm1sRWFXWm1LVHRjYmlBZ2ZWeHVYRzRnSUdsbUlDaEJjbkpoZVM1cGMwRnljbUY1S0hWdWFVUnBabVlwS1NCN1hHNGdJQ0FnYVdZZ0tIVnVhVVJwWm1ZdWJHVnVaM1JvSUQ0Z01Ta2dlMXh1SUNBZ0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtDZGhjSEJzZVZCaGRHTm9JRzl1YkhrZ2QyOXlhM01nZDJsMGFDQmhJSE5wYm1kc1pTQnBibkIxZEM0bktUdGNiaUFnSUNCOVhHNWNiaUFnSUNCMWJtbEVhV1ptSUQwZ2RXNXBSR2xtWmxzd1hUdGNiaUFnZlZ4dVhHNGdJQzh2SUVGd2NHeDVJSFJvWlNCa2FXWm1JSFJ2SUhSb1pTQnBibkIxZEZ4dUlDQnNaWFFnYkdsdVpYTWdQU0J6YjNWeVkyVXVjM0JzYVhRb0wxeGNjbHhjYm54YlhGeHVYRngyWEZ4bVhGeHlYRng0T0RWZEx5a3NYRzRnSUNBZ0lDQmtaV3hwYldsMFpYSnpJRDBnYzI5MWNtTmxMbTFoZEdOb0tDOWNYSEpjWEc1OFcxeGNibHhjZGx4Y1pseGNjbHhjZURnMVhTOW5LU0I4ZkNCYlhTeGNiaUFnSUNBZ0lHaDFibXR6SUQwZ2RXNXBSR2xtWmk1b2RXNXJjeXhjYmx4dUlDQWdJQ0FnWTI5dGNHRnlaVXhwYm1VZ1BTQnZjSFJwYjI1ekxtTnZiWEJoY21WTWFXNWxJSHg4SUNnb2JHbHVaVTUxYldKbGNpd2diR2x1WlN3Z2IzQmxjbUYwYVc5dUxDQndZWFJqYUVOdmJuUmxiblFwSUQwK0lHeHBibVVnUFQwOUlIQmhkR05vUTI5dWRHVnVkQ2tzWEc0Z0lDQWdJQ0JsY25KdmNrTnZkVzUwSUQwZ01DeGNiaUFnSUNBZ0lHWjFlbnBHWVdOMGIzSWdQU0J2Y0hScGIyNXpMbVoxZW5wR1lXTjBiM0lnZkh3Z01DeGNiaUFnSUNBZ0lHMXBia3hwYm1VZ1BTQXdMRnh1SUNBZ0lDQWdiMlptYzJWMElEMGdNQ3hjYmx4dUlDQWdJQ0FnY21WdGIzWmxSVTlHVGt3c1hHNGdJQ0FnSUNCaFpHUkZUMFpPVER0Y2JseHVJQ0F2S2lwY2JpQWdJQ29nUTJobFkydHpJR2xtSUhSb1pTQm9kVzVySUdWNFlXTjBiSGtnWm1sMGN5QnZiaUIwYUdVZ2NISnZkbWxrWldRZ2JHOWpZWFJwYjI1Y2JpQWdJQ292WEc0Z0lHWjFibU4wYVc5dUlHaDFibXRHYVhSektHaDFibXNzSUhSdlVHOXpLU0I3WEc0Z0lDQWdabTl5SUNoc1pYUWdhaUE5SURBN0lHb2dQQ0JvZFc1ckxteHBibVZ6TG14bGJtZDBhRHNnYWlzcktTQjdYRzRnSUNBZ0lDQnNaWFFnYkdsdVpTQTlJR2gxYm1zdWJHbHVaWE5iYWwwc1hHNGdJQ0FnSUNBZ0lDQWdiM0JsY21GMGFXOXVJRDBnS0d4cGJtVXViR1Z1WjNSb0lENGdNQ0EvSUd4cGJtVmJNRjBnT2lBbklDY3BMRnh1SUNBZ0lDQWdJQ0FnSUdOdmJuUmxiblFnUFNBb2JHbHVaUzVzWlc1bmRHZ2dQaUF3SUQ4Z2JHbHVaUzV6ZFdKemRISW9NU2tnT2lCc2FXNWxLVHRjYmx4dUlDQWdJQ0FnYVdZZ0tHOXdaWEpoZEdsdmJpQTlQVDBnSnlBbklIeDhJRzl3WlhKaGRHbHZiaUE5UFQwZ0p5MG5LU0I3WEc0Z0lDQWdJQ0FnSUM4dklFTnZiblJsZUhRZ2MyRnVhWFI1SUdOb1pXTnJYRzRnSUNBZ0lDQWdJR2xtSUNnaFkyOXRjR0Z5WlV4cGJtVW9kRzlRYjNNZ0t5QXhMQ0JzYVc1bGMxdDBiMUJ2YzEwc0lHOXdaWEpoZEdsdmJpd2dZMjl1ZEdWdWRDa3BJSHRjYmlBZ0lDQWdJQ0FnSUNCbGNuSnZja052ZFc1MEt5czdYRzVjYmlBZ0lDQWdJQ0FnSUNCcFppQW9aWEp5YjNKRGIzVnVkQ0ErSUdaMWVucEdZV04wYjNJcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUJtWVd4elpUdGNiaUFnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ2RHOVFiM01yS3p0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc1Y2JpQWdJQ0J5WlhSMWNtNGdkSEoxWlR0Y2JpQWdmVnh1WEc0Z0lDOHZJRk5sWVhKamFDQmlaWE4wSUdacGRDQnZabVp6WlhSeklHWnZjaUJsWVdOb0lHaDFibXNnWW1GelpXUWdiMjRnZEdobElIQnlaWFpwYjNWeklHOXVaWE5jYmlBZ1ptOXlJQ2hzWlhRZ2FTQTlJREE3SUdrZ1BDQm9kVzVyY3k1c1pXNW5kR2c3SUdrckt5a2dlMXh1SUNBZ0lHeGxkQ0JvZFc1cklEMGdhSFZ1YTNOYmFWMHNYRzRnSUNBZ0lDQWdJRzFoZUV4cGJtVWdQU0JzYVc1bGN5NXNaVzVuZEdnZ0xTQm9kVzVyTG05c1pFeHBibVZ6TEZ4dUlDQWdJQ0FnSUNCc2IyTmhiRTltWm5ObGRDQTlJREFzWEc0Z0lDQWdJQ0FnSUhSdlVHOXpJRDBnYjJabWMyVjBJQ3NnYUhWdWF5NXZiR1JUZEdGeWRDQXRJREU3WEc1Y2JpQWdJQ0JzWlhRZ2FYUmxjbUYwYjNJZ1BTQmthWE4wWVc1alpVbDBaWEpoZEc5eUtIUnZVRzl6TENCdGFXNU1hVzVsTENCdFlYaE1hVzVsS1R0Y2JseHVJQ0FnSUdadmNpQW9PeUJzYjJOaGJFOW1abk5sZENBaFBUMGdkVzVrWldacGJtVmtPeUJzYjJOaGJFOW1abk5sZENBOUlHbDBaWEpoZEc5eUtDa3BJSHRjYmlBZ0lDQWdJR2xtSUNob2RXNXJSbWwwY3lob2RXNXJMQ0IwYjFCdmN5QXJJR3h2WTJGc1QyWm1jMlYwS1NrZ2UxeHVJQ0FnSUNBZ0lDQm9kVzVyTG05bVpuTmxkQ0E5SUc5bVpuTmxkQ0FyUFNCc2IyTmhiRTltWm5ObGREdGNiaUFnSUNBZ0lDQWdZbkpsWVdzN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dVhHNGdJQ0FnYVdZZ0tHeHZZMkZzVDJabWMyVjBJRDA5UFNCMWJtUmxabWx1WldRcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQXZMeUJUWlhRZ2JHOTNaWElnZEdWNGRDQnNhVzFwZENCMGJ5QmxibVFnYjJZZ2RHaGxJR04xY25KbGJuUWdhSFZ1YXl3Z2MyOGdibVY0ZENCdmJtVnpJR1J2YmlkMElIUnllVnh1SUNBZ0lDOHZJSFJ2SUdacGRDQnZkbVZ5SUdGc2NtVmhaSGtnY0dGMFkyaGxaQ0IwWlhoMFhHNGdJQ0FnYldsdVRHbHVaU0E5SUdoMWJtc3ViMlptYzJWMElDc2dhSFZ1YXk1dmJHUlRkR0Z5ZENBcklHaDFibXN1YjJ4a1RHbHVaWE03WEc0Z0lIMWNibHh1SUNBdkx5QkJjSEJzZVNCd1lYUmphQ0JvZFc1cmMxeHVJQ0JzWlhRZ1pHbG1aazltWm5ObGRDQTlJREE3WEc0Z0lHWnZjaUFvYkdWMElHa2dQU0F3T3lCcElEd2dhSFZ1YTNNdWJHVnVaM1JvT3lCcEt5c3BJSHRjYmlBZ0lDQnNaWFFnYUhWdWF5QTlJR2gxYm10elcybGRMRnh1SUNBZ0lDQWdJQ0IwYjFCdmN5QTlJR2gxYm1zdWIyeGtVM1JoY25RZ0t5Qm9kVzVyTG05bVpuTmxkQ0FySUdScFptWlBabVp6WlhRZ0xTQXhPMXh1SUNBZ0lHUnBabVpQWm1aelpYUWdLejBnYUhWdWF5NXVaWGRNYVc1bGN5QXRJR2gxYm1zdWIyeGtUR2x1WlhNN1hHNWNiaUFnSUNCbWIzSWdLR3hsZENCcUlEMGdNRHNnYWlBOElHaDFibXN1YkdsdVpYTXViR1Z1WjNSb095QnFLeXNwSUh0Y2JpQWdJQ0FnSUd4bGRDQnNhVzVsSUQwZ2FIVnVheTVzYVc1bGMxdHFYU3hjYmlBZ0lDQWdJQ0FnSUNCdmNHVnlZWFJwYjI0Z1BTQW9iR2x1WlM1c1pXNW5kR2dnUGlBd0lEOGdiR2x1WlZzd1hTQTZJQ2NnSnlrc1hHNGdJQ0FnSUNBZ0lDQWdZMjl1ZEdWdWRDQTlJQ2hzYVc1bExteGxibWQwYUNBK0lEQWdQeUJzYVc1bExuTjFZbk4wY2lneEtTQTZJR3hwYm1VcExGeHVJQ0FnSUNBZ0lDQWdJR1JsYkdsdGFYUmxjaUE5SUdoMWJtc3ViR2x1WldSbGJHbHRhWFJsY25NZ0ppWWdhSFZ1YXk1c2FXNWxaR1ZzYVcxcGRHVnljMXRxWFNCOGZDQW5YRnh1Snp0Y2JseHVJQ0FnSUNBZ2FXWWdLRzl3WlhKaGRHbHZiaUE5UFQwZ0p5QW5LU0I3WEc0Z0lDQWdJQ0FnSUhSdlVHOXpLeXM3WEc0Z0lDQWdJQ0I5SUdWc2MyVWdhV1lnS0c5d1pYSmhkR2x2YmlBOVBUMGdKeTBuS1NCN1hHNGdJQ0FnSUNBZ0lHeHBibVZ6TG5Od2JHbGpaU2gwYjFCdmN5d2dNU2s3WEc0Z0lDQWdJQ0FnSUdSbGJHbHRhWFJsY25NdWMzQnNhV05sS0hSdlVHOXpMQ0F4S1R0Y2JpQWdJQ0FnSUM4cUlHbHpkR0Z1WW5Wc0lHbG5ibTl5WlNCbGJITmxJQ292WEc0Z0lDQWdJQ0I5SUdWc2MyVWdhV1lnS0c5d1pYSmhkR2x2YmlBOVBUMGdKeXNuS1NCN1hHNGdJQ0FnSUNBZ0lHeHBibVZ6TG5Od2JHbGpaU2gwYjFCdmN5d2dNQ3dnWTI5dWRHVnVkQ2s3WEc0Z0lDQWdJQ0FnSUdSbGJHbHRhWFJsY25NdWMzQnNhV05sS0hSdlVHOXpMQ0F3TENCa1pXeHBiV2wwWlhJcE8xeHVJQ0FnSUNBZ0lDQjBiMUJ2Y3lzck8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaHZjR1Z5WVhScGIyNGdQVDA5SUNkY1hGeGNKeWtnZTF4dUlDQWdJQ0FnSUNCc1pYUWdjSEpsZG1sdmRYTlBjR1Z5WVhScGIyNGdQU0JvZFc1ckxteHBibVZ6VzJvZ0xTQXhYU0EvSUdoMWJtc3ViR2x1WlhOYmFpQXRJREZkV3pCZElEb2diblZzYkR0Y2JpQWdJQ0FnSUNBZ2FXWWdLSEJ5WlhacGIzVnpUM0JsY21GMGFXOXVJRDA5UFNBbkt5Y3BJSHRjYmlBZ0lDQWdJQ0FnSUNCeVpXMXZkbVZGVDBaT1RDQTlJSFJ5ZFdVN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCcFppQW9jSEpsZG1sdmRYTlBjR1Z5WVhScGIyNGdQVDA5SUNjdEp5a2dlMXh1SUNBZ0lDQWdJQ0FnSUdGa1pFVlBSazVNSUQwZ2RISjFaVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUM4dklFaGhibVJzWlNCRlQwWk9UQ0JwYm5ObGNuUnBiMjR2Y21WdGIzWmhiRnh1SUNCcFppQW9jbVZ0YjNabFJVOUdUa3dwSUh0Y2JpQWdJQ0IzYUdsc1pTQW9JV3hwYm1WelcyeHBibVZ6TG14bGJtZDBhQ0F0SURGZEtTQjdYRzRnSUNBZ0lDQnNhVzVsY3k1d2IzQW9LVHRjYmlBZ0lDQWdJR1JsYkdsdGFYUmxjbk11Y0c5d0tDazdYRzRnSUNBZ2ZWeHVJQ0I5SUdWc2MyVWdhV1lnS0dGa1pFVlBSazVNS1NCN1hHNGdJQ0FnYkdsdVpYTXVjSFZ6YUNnbkp5azdYRzRnSUNBZ1pHVnNhVzFwZEdWeWN5NXdkWE5vS0NkY1hHNG5LVHRjYmlBZ2ZWeHVJQ0JtYjNJZ0tHeGxkQ0JmYXlBOUlEQTdJRjlySUR3Z2JHbHVaWE11YkdWdVozUm9JQzBnTVRzZ1gyc3JLeWtnZTF4dUlDQWdJR3hwYm1WelcxOXJYU0E5SUd4cGJtVnpXMTlyWFNBcklHUmxiR2x0YVhSbGNuTmJYMnRkTzF4dUlDQjlYRzRnSUhKbGRIVnliaUJzYVc1bGN5NXFiMmx1S0NjbktUdGNibjFjYmx4dUx5OGdWM0poY0hCbGNpQjBhR0YwSUhOMWNIQnZjblJ6SUcxMWJIUnBjR3hsSUdacGJHVWdjR0YwWTJobGN5QjJhV0VnWTJGc2JHSmhZMnR6TGx4dVpYaHdiM0owSUdaMWJtTjBhVzl1SUdGd2NHeDVVR0YwWTJobGN5aDFibWxFYVdabUxDQnZjSFJwYjI1ektTQjdYRzRnSUdsbUlDaDBlWEJsYjJZZ2RXNXBSR2xtWmlBOVBUMGdKM04wY21sdVp5Y3BJSHRjYmlBZ0lDQjFibWxFYVdabUlEMGdjR0Z5YzJWUVlYUmphQ2gxYm1sRWFXWm1LVHRjYmlBZ2ZWeHVYRzRnSUd4bGRDQmpkWEp5Wlc1MFNXNWtaWGdnUFNBd08xeHVJQ0JtZFc1amRHbHZiaUJ3Y205alpYTnpTVzVrWlhnb0tTQjdYRzRnSUNBZ2JHVjBJR2x1WkdWNElEMGdkVzVwUkdsbVpsdGpkWEp5Wlc1MFNXNWtaWGdySzEwN1hHNGdJQ0FnYVdZZ0tDRnBibVJsZUNrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUc5d2RHbHZibk11WTI5dGNHeGxkR1VvS1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0J2Y0hScGIyNXpMbXh2WVdSR2FXeGxLR2x1WkdWNExDQm1kVzVqZEdsdmJpaGxjbklzSUdSaGRHRXBJSHRjYmlBZ0lDQWdJR2xtSUNobGNuSXBJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJRzl3ZEdsdmJuTXVZMjl0Y0d4bGRHVW9aWEp5S1R0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ2JHVjBJSFZ3WkdGMFpXUkRiMjUwWlc1MElEMGdZWEJ3YkhsUVlYUmphQ2hrWVhSaExDQnBibVJsZUN3Z2IzQjBhVzl1Y3lrN1hHNGdJQ0FnSUNCdmNIUnBiMjV6TG5CaGRHTm9aV1FvYVc1a1pYZ3NJSFZ3WkdGMFpXUkRiMjUwWlc1MExDQm1kVzVqZEdsdmJpaGxjbklwSUh0Y2JpQWdJQ0FnSUNBZ2FXWWdLR1Z5Y2lrZ2UxeHVJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQnZjSFJwYjI1ekxtTnZiWEJzWlhSbEtHVnljaWs3WEc0Z0lDQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ0lDQndjbTlqWlhOelNXNWtaWGdvS1R0Y2JpQWdJQ0FnSUgwcE8xeHVJQ0FnSUgwcE8xeHVJQ0I5WEc0Z0lIQnliMk5sYzNOSmJtUmxlQ2dwTzF4dWZWeHVJbDE5XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/diff/lib/patch/apply.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/diff/lib/patch/create.js":
/*!******************************************************************!*\
  !*** ./node_modules/mocha/node_modules/diff/lib/patch/create.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*istanbul ignore start*/\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.structuredPatch = structuredPatch;\nexports.formatPatch = formatPatch;\nexports.createTwoFilesPatch = createTwoFilesPatch;\nexports.createPatch = createPatch;\n\n/*istanbul ignore end*/\nvar\n/*istanbul ignore start*/\n_line = __webpack_require__(/*! ../diff/line */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/diff/line.js\")\n/*istanbul ignore end*/\n;\n\n/*istanbul ignore start*/ function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*istanbul ignore end*/\nfunction structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n\n  var diff =\n  /*istanbul ignore start*/\n  (0,\n  /*istanbul ignore end*/\n\n  /*istanbul ignore start*/\n  _line\n  /*istanbul ignore end*/\n  .\n  /*istanbul ignore start*/\n  diffLines)\n  /*istanbul ignore end*/\n  (oldStr, newStr, options);\n\n  if (!diff) {\n    return;\n  }\n\n  diff.push({\n    value: '',\n    lines: []\n  }); // Append an empty value to make cleanup easier\n\n  function contextLines(lines) {\n    return lines.map(function (entry) {\n      return ' ' + entry;\n    });\n  }\n\n  var hunks = [];\n  var oldRangeStart = 0,\n      newRangeStart = 0,\n      curRange = [],\n      oldLine = 1,\n      newLine = 1;\n\n  /*istanbul ignore start*/\n  var _loop = function _loop(\n  /*istanbul ignore end*/\n  i) {\n    var current = diff[i],\n        lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n    current.lines = lines;\n\n    if (current.added || current.removed) {\n      /*istanbul ignore start*/\n      var _curRange;\n\n      /*istanbul ignore end*/\n      // If we have previous context, start with that\n      if (!oldRangeStart) {\n        var prev = diff[i - 1];\n        oldRangeStart = oldLine;\n        newRangeStart = newLine;\n\n        if (prev) {\n          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n          oldRangeStart -= curRange.length;\n          newRangeStart -= curRange.length;\n        }\n      } // Output our changes\n\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n      (_curRange =\n      /*istanbul ignore end*/\n      curRange).push.apply(\n      /*istanbul ignore start*/\n      _curRange\n      /*istanbul ignore end*/\n      ,\n      /*istanbul ignore start*/\n      _toConsumableArray(\n      /*istanbul ignore end*/\n      lines.map(function (entry) {\n        return (current.added ? '+' : '-') + entry;\n      }))); // Track the updated file position\n\n\n      if (current.added) {\n        newLine += lines.length;\n      } else {\n        oldLine += lines.length;\n      }\n    } else {\n      // Identical context lines. Track line changes\n      if (oldRangeStart) {\n        // Close out any changes that have been output (or join overlapping)\n        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n          /*istanbul ignore start*/\n          var _curRange2;\n\n          /*istanbul ignore end*/\n          // Overlapping\n\n          /*istanbul ignore start*/\n\n          /*istanbul ignore end*/\n\n          /*istanbul ignore start*/\n          (_curRange2 =\n          /*istanbul ignore end*/\n          curRange).push.apply(\n          /*istanbul ignore start*/\n          _curRange2\n          /*istanbul ignore end*/\n          ,\n          /*istanbul ignore start*/\n          _toConsumableArray(\n          /*istanbul ignore end*/\n          contextLines(lines)));\n        } else {\n          /*istanbul ignore start*/\n          var _curRange3;\n\n          /*istanbul ignore end*/\n          // end the range and output\n          var contextSize = Math.min(lines.length, options.context);\n\n          /*istanbul ignore start*/\n\n          /*istanbul ignore end*/\n\n          /*istanbul ignore start*/\n          (_curRange3 =\n          /*istanbul ignore end*/\n          curRange).push.apply(\n          /*istanbul ignore start*/\n          _curRange3\n          /*istanbul ignore end*/\n          ,\n          /*istanbul ignore start*/\n          _toConsumableArray(\n          /*istanbul ignore end*/\n          contextLines(lines.slice(0, contextSize))));\n\n          var hunk = {\n            oldStart: oldRangeStart,\n            oldLines: oldLine - oldRangeStart + contextSize,\n            newStart: newRangeStart,\n            newLines: newLine - newRangeStart + contextSize,\n            lines: curRange\n          };\n\n          if (i >= diff.length - 2 && lines.length <= options.context) {\n            // EOF is inside this hunk\n            var oldEOFNewline = /\\n$/.test(oldStr);\n            var newEOFNewline = /\\n$/.test(newStr);\n            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n\n            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n              // special case: old has no eol and no trailing context; no-nl can end up before adds\n              // however, if the old file is empty, do not output the no-nl line\n              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n            }\n\n            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n              curRange.push('\\\\ No newline at end of file');\n            }\n          }\n\n          hunks.push(hunk);\n          oldRangeStart = 0;\n          newRangeStart = 0;\n          curRange = [];\n        }\n      }\n\n      oldLine += lines.length;\n      newLine += lines.length;\n    }\n  };\n\n  for (var i = 0; i < diff.length; i++) {\n    /*istanbul ignore start*/\n    _loop(\n    /*istanbul ignore end*/\n    i);\n  }\n\n  return {\n    oldFileName: oldFileName,\n    newFileName: newFileName,\n    oldHeader: oldHeader,\n    newHeader: newHeader,\n    hunks: hunks\n  };\n}\n\nfunction formatPatch(diff) {\n  if (Array.isArray(diff)) {\n    return diff.map(formatPatch).join('\\n');\n  }\n\n  var ret = [];\n\n  if (diff.oldFileName == diff.newFileName) {\n    ret.push('Index: ' + diff.oldFileName);\n  }\n\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n  for (var i = 0; i < diff.hunks.length; i++) {\n    var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart -= 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart -= 1;\n    }\n\n    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n    ret.push.apply(ret, hunk.lines);\n  }\n\n  return ret.join('\\n') + '\\n';\n}\n\nfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n}\n\nfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXRjaC9jcmVhdGUuanMiXSwibmFtZXMiOlsic3RydWN0dXJlZFBhdGNoIiwib2xkRmlsZU5hbWUiLCJuZXdGaWxlTmFtZSIsIm9sZFN0ciIsIm5ld1N0ciIsIm9sZEhlYWRlciIsIm5ld0hlYWRlciIsIm9wdGlvbnMiLCJjb250ZXh0IiwiZGlmZiIsImRpZmZMaW5lcyIsInB1c2giLCJ2YWx1ZSIsImxpbmVzIiwiY29udGV4dExpbmVzIiwibWFwIiwiZW50cnkiLCJodW5rcyIsIm9sZFJhbmdlU3RhcnQiLCJuZXdSYW5nZVN0YXJ0IiwiY3VyUmFuZ2UiLCJvbGRMaW5lIiwibmV3TGluZSIsImkiLCJjdXJyZW50IiwicmVwbGFjZSIsInNwbGl0IiwiYWRkZWQiLCJyZW1vdmVkIiwicHJldiIsInNsaWNlIiwibGVuZ3RoIiwiY29udGV4dFNpemUiLCJNYXRoIiwibWluIiwiaHVuayIsIm9sZFN0YXJ0Iiwib2xkTGluZXMiLCJuZXdTdGFydCIsIm5ld0xpbmVzIiwib2xkRU9GTmV3bGluZSIsInRlc3QiLCJuZXdFT0ZOZXdsaW5lIiwibm9ObEJlZm9yZUFkZHMiLCJzcGxpY2UiLCJmb3JtYXRQYXRjaCIsIkFycmF5IiwiaXNBcnJheSIsImpvaW4iLCJyZXQiLCJhcHBseSIsImNyZWF0ZVR3b0ZpbGVzUGF0Y2giLCJjcmVhdGVQYXRjaCIsImZpbGVOYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7QUFFTyxTQUFTQSxlQUFULENBQXlCQyxXQUF6QixFQUFzQ0MsV0FBdEMsRUFBbURDLE1BQW5ELEVBQTJEQyxNQUEzRCxFQUFtRUMsU0FBbkUsRUFBOEVDLFNBQTlFLEVBQXlGQyxPQUF6RixFQUFrRztBQUN2RyxNQUFJLENBQUNBLE9BQUwsRUFBYztBQUNaQSxJQUFBQSxPQUFPLEdBQUcsRUFBVjtBQUNEOztBQUNELE1BQUksT0FBT0EsT0FBTyxDQUFDQyxPQUFmLEtB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QUNuRixTQUFPNEMsbUJBQW1CLENBQUNFLFFBQUQsRUFBV0EsUUFBWCxFQUFxQmxELE1BQXJCLEVBQTZCQyxNQUE3QixFQUFxQ0MsU0FBckMsRUFBZ0RDLFNBQWhELEVBQTJEQyxPQUEzRCxDQUExQjtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtkaWZmTGluZXN9IGZyb20gJy4uL2RpZmYvbGluZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJ1Y3R1cmVkUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5jb250ZXh0ID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMuY29udGV4dCA9IDQ7XG4gIH1cblxuICBjb25zdCBkaWZmID0gZGlmZkxpbmVzKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbiAgaWYoIWRpZmYpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBkaWZmLnB1c2goe3ZhbHVlOiAnJywgbGluZXM6IFtdfSk7IC8vIEFwcGVuZCBhbiBlbXB0eSB2YWx1ZSB0byBtYWtlIGNsZWFudXAgZWFzaWVyXG5cbiAgZnVuY3Rpb24gY29udGV4dExpbmVzKGxpbmVzKSB7XG4gICAgcmV0dXJuIGxpbmVzLm1hcChmdW5jdGlvbihlbnRyeSkgeyByZXR1cm4gJyAnICsgZW50cnk7IH0pO1xuICB9XG5cbiAgbGV0IGh1bmtzID0gW107XG4gIGxldCBvbGRSYW5nZVN0YXJ0ID0gMCwgbmV3UmFuZ2VTdGFydCA9IDAsIGN1clJhbmdlID0gW10sXG4gICAgICBvbGRMaW5lID0gMSwgbmV3TGluZSA9IDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBkaWZmW2ldLFxuICAgICAgICAgIGxpbmVzID0gY3VycmVudC5saW5lcyB8fCBjdXJyZW50LnZhbHVlLnJlcGxhY2UoL1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpO1xuICAgIGN1cnJlbnQubGluZXMgPSBsaW5lcztcblxuICAgIGlmIChjdXJyZW50LmFkZGVkIHx8IGN1cnJlbnQucmVtb3ZlZCkge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBwcmV2aW91cyBjb250ZXh0LCBzdGFydCB3aXRoIHRoYXRcbiAgICAgIGlmICghb2xkUmFuZ2VTdGFydCkge1xuICAgICAgICBjb25zdCBwcmV2ID0gZGlmZltpIC0gMV07XG4gICAgICAgIG9sZFJhbmdlU3RhcnQgPSBvbGRMaW5lO1xuICAgICAgICBuZXdSYW5nZVN0YXJ0ID0gbmV3TGluZTtcblxuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgIGN1clJhbmdlID0gb3B0aW9ucy5jb250ZXh0ID4gMCA/IGNvbnRleHRMaW5lcyhwcmV2LmxpbmVzLnNsaWNlKC1vcHRpb25zLmNvbnRleHQpKSA6IFtdO1xuICAgICAgICAgIG9sZFJhbmdlU3RhcnQgLT0gY3VyUmFuZ2UubGVuZ3RoO1xuICAgICAgICAgIG5ld1JhbmdlU3RhcnQgLT0gY3VyUmFuZ2UubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE91dHB1dCBvdXIgY2hhbmdlc1xuICAgICAgY3VyUmFuZ2UucHVzaCguLi4gbGluZXMubWFwKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgIHJldHVybiAoY3VycmVudC5hZGRlZCA/ICcrJyA6ICctJykgKyBlbnRyeTtcbiAgICAgIH0pKTtcblxuICAgICAgLy8gVHJhY2sgdGhlIHVwZGF0ZWQgZmlsZSBwb3NpdGlvblxuICAgICAgaWYgKGN1cnJlbnQuYWRkZWQpIHtcbiAgICAgICAgbmV3TGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbGRMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWRlbnRpY2FsIGNvbnRleHQgbGluZXMuIFRyYWNrIGxpbmUgY2hhbmdlc1xuICAgICAgaWYgKG9sZFJhbmdlU3RhcnQpIHtcbiAgICAgICAgLy8gQ2xvc2Ugb3V0IGFueSBjaGFuZ2VzIHRoYXQgaGF2ZSBiZWVuIG91dHB1dCAob3Igam9pbiBvdmVybGFwcGluZylcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA8PSBvcHRpb25zLmNvbnRleHQgKiAyICYmIGkgPCBkaWZmLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAvLyBPdmVybGFwcGluZ1xuICAgICAgICAgIGN1clJhbmdlLnB1c2goLi4uIGNvbnRleHRMaW5lcyhsaW5lcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVuZCB0aGUgcmFuZ2UgYW5kIG91dHB1dFxuICAgICAgICAgIGxldCBjb250ZXh0U2l6ZSA9IE1hdGgubWluKGxpbmVzLmxlbmd0aCwgb3B0aW9ucy5jb250ZXh0KTtcbiAgICAgICAgICBjdXJSYW5nZS5wdXNoKC4uLiBjb250ZXh0TGluZXMobGluZXMuc2xpY2UoMCwgY29udGV4dFNpemUpKSk7XG5cbiAgICAgICAgICBsZXQgaHVuayA9IHtcbiAgICAgICAgICAgIG9sZFN0YXJ0OiBvbGRSYW5nZVN0YXJ0LFxuICAgICAgICAgICAgb2xkTGluZXM6IChvbGRMaW5lIC0gb2xkUmFuZ2VTdGFydCArIGNvbnRleHRTaXplKSxcbiAgICAgICAgICAgIG5ld1N0YXJ0OiBuZXdSYW5nZVN0YXJ0LFxuICAgICAgICAgICAgbmV3TGluZXM6IChuZXdMaW5lIC0gbmV3UmFuZ2VTdGFydCArIGNvbnRleHRTaXplKSxcbiAgICAgICAgICAgIGxpbmVzOiBjdXJSYW5nZVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGkgPj0gZGlmZi5sZW5ndGggLSAyICYmIGxpbmVzLmxlbmd0aCA8PSBvcHRpb25zLmNvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIEVPRiBpcyBpbnNpZGUgdGhpcyBodW5rXG4gICAgICAgICAgICBsZXQgb2xkRU9GTmV3bGluZSA9ICgoL1xcbiQvKS50ZXN0KG9sZFN0cikpO1xuICAgICAgICAgICAgbGV0IG5ld0VPRk5ld2xpbmUgPSAoKC9cXG4kLykudGVzdChuZXdTdHIpKTtcbiAgICAgICAgICAgIGxldCBub05sQmVmb3JlQWRkcyA9IGxpbmVzLmxlbmd0aCA9PSAwICYmIGN1clJhbmdlLmxlbmd0aCA+IGh1bmsub2xkTGluZXM7XG4gICAgICAgICAgICBpZiAoIW9sZEVPRk5ld2xpbmUgJiYgbm9ObEJlZm9yZUFkZHMgJiYgb2xkU3RyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlOiBvbGQgaGFzIG5vIGVvbCBhbmQgbm8gdHJhaWxpbmcgY29udGV4dDsgbm8tbmwgY2FuIGVuZCB1cCBiZWZvcmUgYWRkc1xuICAgICAgICAgICAgICAvLyBob3dldmVyLCBpZiB0aGUgb2xkIGZpbGUgaXMgZW1wdHksIGRvIG5vdCBvdXRwdXQgdGhlIG5vLW5sIGxpbmVcbiAgICAgICAgICAgICAgY3VyUmFuZ2Uuc3BsaWNlKGh1bmsub2xkTGluZXMsIDAsICdcXFxcIE5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoIW9sZEVPRk5ld2xpbmUgJiYgIW5vTmxCZWZvcmVBZGRzKSB8fCAhbmV3RU9GTmV3bGluZSkge1xuICAgICAgICAgICAgICBjdXJSYW5nZS5wdXNoKCdcXFxcIE5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaHVua3MucHVzaChodW5rKTtcblxuICAgICAgICAgIG9sZFJhbmdlU3RhcnQgPSAwO1xuICAgICAgICAgIG5ld1JhbmdlU3RhcnQgPSAwO1xuICAgICAgICAgIGN1clJhbmdlID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9sZExpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgbmV3TGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvbGRGaWxlTmFtZTogb2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lOiBuZXdGaWxlTmFtZSxcbiAgICBvbGRIZWFkZXI6IG9sZEhlYWRlciwgbmV3SGVhZGVyOiBuZXdIZWFkZXIsXG4gICAgaHVua3M6IGh1bmtzXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRQYXRjaChkaWZmKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRpZmYpKSB7XG4gICAgcmV0dXJuIGRpZmYubWFwKGZvcm1hdFBhdGNoKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIGNvbnN0IHJldCA9IFtdO1xuICBpZiAoZGlmZi5vbGRGaWxlTmFtZSA9PSBkaWZmLm5ld0ZpbGVOYW1lKSB7XG4gICAgcmV0LnB1c2goJ0luZGV4OiAnICsgZGlmZi5vbGRGaWxlTmFtZSk7XG4gIH1cbiAgcmV0LnB1c2goJz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0nKTtcbiAgcmV0LnB1c2goJy0tLSAnICsgZGlmZi5vbGRGaWxlTmFtZSArICh0eXBlb2YgZGlmZi5vbGRIZWFkZXIgPT09ICd1bmRlZmluZWQnID8gJycgOiAnXFx0JyArIGRpZmYub2xkSGVhZGVyKSk7XG4gIHJldC5wdXNoKCcrKysgJyArIGRpZmYubmV3RmlsZU5hbWUgKyAodHlwZW9mIGRpZmYubmV3SGVhZGVyID09PSAndW5kZWZpbmVkJyA/ICcnIDogJ1xcdCcgKyBkaWZmLm5ld0hlYWRlcikpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZi5odW5rcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGh1bmsgPSBkaWZmLmh1bmtzW2ldO1xuICAgIC8vIFVuaWZpZWQgRGlmZiBGb3JtYXQgcXVpcms6IElmIHRoZSBjaHVuayBzaXplIGlzIDAsXG4gICAgLy8gdGhlIGZpcnN0IG51bWJlciBpcyBvbmUgbG93ZXIgdGhhbiBvbmUgd291bGQgZXhwZWN0LlxuICAgIC8vIGh0dHBzOi8vd3d3LmFydGltYS5jb20vd2VibG9ncy92aWV3cG9zdC5qc3A/dGhyZWFkPTE2NDI5M1xuICAgIGlmIChodW5rLm9sZExpbmVzID09PSAwKSB7XG4gICAgICBodW5rLm9sZFN0YXJ0IC09IDE7XG4gICAgfVxuICAgIGlmIChodW5rLm5ld0xpbmVzID09PSAwKSB7XG4gICAgICBodW5rLm5ld1N0YXJ0IC09IDE7XG4gICAgfVxuICAgIHJldC5wdXNoKFxuICAgICAgJ0BAIC0nICsgaHVuay5vbGRTdGFydCArICcsJyArIGh1bmsub2xkTGluZXNcbiAgICAgICsgJyArJyArIGh1bmsubmV3U3RhcnQgKyAnLCcgKyBodW5rLm5ld0xpbmVzXG4gICAgICArICcgQEAnXG4gICAgKTtcbiAgICByZXQucHVzaC5hcHBseShyZXQsIGh1bmsubGluZXMpO1xuICB9XG5cbiAgcmV0dXJuIHJldC5qb2luKCdcXG4nKSArICdcXG4nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVHdvRmlsZXNQYXRjaChvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucykge1xuICByZXR1cm4gZm9ybWF0UGF0Y2goc3RydWN0dXJlZFBhdGNoKG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQYXRjaChmaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBjcmVhdGVUd29GaWxlc1BhdGNoKGZpbGVOYW1lLCBmaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKTtcbn1cbiJdfQ==\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL3BhdGNoL2NyZWF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLHVCQUF1QjtBQUN2QixtQkFBbUI7QUFDbkIsMkJBQTJCO0FBQzNCLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtQkFBTyxDQUFDLG1GQUFjO0FBQzlCO0FBQ0E7O0FBRUEsNkRBQTZEOztBQUU3RCxnQ0FBZ0M7O0FBRWhDLGtEQUFrRCxnQkFBZ0IsZ0VBQWdFLHdEQUF3RCw2REFBNkQsc0RBQXNEOztBQUU3UyxrQ0FBa0M7O0FBRWxDLG1DQUFtQzs7QUFFbkMsdUNBQXVDLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLG9CQUFvQjs7QUFFeks7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEtBQUs7OztBQUdaO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQix1QkFBdUI7QUFDekMsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL21vY2hhL25vZGVfbW9kdWxlcy9kaWZmL2xpYi9wYXRjaC9jcmVhdGUuanM/OWVlYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3RydWN0dXJlZFBhdGNoID0gc3RydWN0dXJlZFBhdGNoO1xuZXhwb3J0cy5mb3JtYXRQYXRjaCA9IGZvcm1hdFBhdGNoO1xuZXhwb3J0cy5jcmVhdGVUd29GaWxlc1BhdGNoID0gY3JlYXRlVHdvRmlsZXNQYXRjaDtcbmV4cG9ydHMuY3JlYXRlUGF0Y2ggPSBjcmVhdGVQYXRjaDtcblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2xpbmUgPSByZXF1aXJlKFwiLi4vZGlmZi9saW5lXCIpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbmZ1bmN0aW9uIHN0cnVjdHVyZWRQYXRjaChvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMuY29udGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zLmNvbnRleHQgPSA0O1xuICB9XG5cbiAgdmFyIGRpZmYgPVxuICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICgwLFxuICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuXG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgX2xpbmVcbiAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgLlxuICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gIGRpZmZMaW5lcylcbiAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcblxuICBpZiAoIWRpZmYpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBkaWZmLnB1c2goe1xuICAgIHZhbHVlOiAnJyxcbiAgICBsaW5lczogW11cbiAgfSk7IC8vIEFwcGVuZCBhbiBlbXB0eSB2YWx1ZSB0byBtYWtlIGNsZWFudXAgZWFzaWVyXG5cbiAgZnVuY3Rpb24gY29udGV4dExpbmVzKGxpbmVzKSB7XG4gICAgcmV0dXJuIGxpbmVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgIHJldHVybiAnICcgKyBlbnRyeTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBodW5rcyA9IFtdO1xuICB2YXIgb2xkUmFuZ2VTdGFydCA9IDAsXG4gICAgICBuZXdSYW5nZVN0YXJ0ID0gMCxcbiAgICAgIGN1clJhbmdlID0gW10sXG4gICAgICBvbGRMaW5lID0gMSxcbiAgICAgIG5ld0xpbmUgPSAxO1xuXG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoXG4gIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gIGkpIHtcbiAgICB2YXIgY3VycmVudCA9IGRpZmZbaV0sXG4gICAgICAgIGxpbmVzID0gY3VycmVudC5saW5lcyB8fCBjdXJyZW50LnZhbHVlLnJlcGxhY2UoL1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpO1xuICAgIGN1cnJlbnQubGluZXMgPSBsaW5lcztcblxuICAgIGlmIChjdXJyZW50LmFkZGVkIHx8IGN1cnJlbnQucmVtb3ZlZCkge1xuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICAgdmFyIF9jdXJSYW5nZTtcblxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAgIC8vIElmIHdlIGhhdmUgcHJldmlvdXMgY29udGV4dCwgc3RhcnQgd2l0aCB0aGF0XG4gICAgICBpZiAoIW9sZFJhbmdlU3RhcnQpIHtcbiAgICAgICAgdmFyIHByZXYgPSBkaWZmW2kgLSAxXTtcbiAgICAgICAgb2xkUmFuZ2VTdGFydCA9IG9sZExpbmU7XG4gICAgICAgIG5ld1JhbmdlU3RhcnQgPSBuZXdMaW5lO1xuXG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgY3VyUmFuZ2UgPSBvcHRpb25zLmNvbnRleHQgPiAwID8gY29udGV4dExpbmVzKHByZXYubGluZXMuc2xpY2UoLW9wdGlvbnMuY29udGV4dCkpIDogW107XG4gICAgICAgICAgb2xkUmFuZ2VTdGFydCAtPSBjdXJSYW5nZS5sZW5ndGg7XG4gICAgICAgICAgbmV3UmFuZ2VTdGFydCAtPSBjdXJSYW5nZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gT3V0cHV0IG91ciBjaGFuZ2VzXG5cblxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICAoX2N1clJhbmdlID1cbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICBjdXJSYW5nZSkucHVzaC5hcHBseShcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgIF9jdXJSYW5nZVxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAgICxcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgIF90b0NvbnN1bWFibGVBcnJheShcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICBsaW5lcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIHJldHVybiAoY3VycmVudC5hZGRlZCA/ICcrJyA6ICctJykgKyBlbnRyeTtcbiAgICAgIH0pKSk7IC8vIFRyYWNrIHRoZSB1cGRhdGVkIGZpbGUgcG9zaXRpb25cblxuXG4gICAgICBpZiAoY3VycmVudC5hZGRlZCkge1xuICAgICAgICBuZXdMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9sZExpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZGVudGljYWwgY29udGV4dCBsaW5lcy4gVHJhY2sgbGluZSBjaGFuZ2VzXG4gICAgICBpZiAob2xkUmFuZ2VTdGFydCkge1xuICAgICAgICAvLyBDbG9zZSBvdXQgYW55IGNoYW5nZXMgdGhhdCBoYXZlIGJlZW4gb3V0cHV0IChvciBqb2luIG92ZXJsYXBwaW5nKVxuICAgICAgICBpZiAobGluZXMubGVuZ3RoIDw9IG9wdGlvbnMuY29udGV4dCAqIDIgJiYgaSA8IGRpZmYubGVuZ3RoIC0gMikge1xuICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgICAgICB2YXIgX2N1clJhbmdlMjtcblxuICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICAgICAgLy8gT3ZlcmxhcHBpbmdcblxuICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblxuICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5cbiAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICAgICAgKF9jdXJSYW5nZTIgPVxuICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICAgICAgY3VyUmFuZ2UpLnB1c2guYXBwbHkoXG4gICAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICAgICAgIF9jdXJSYW5nZTJcbiAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICAgICAgICxcbiAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICAgICAgX3RvQ29uc3VtYWJsZUFycmF5KFxuICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICAgICAgY29udGV4dExpbmVzKGxpbmVzKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgICAgICB2YXIgX2N1clJhbmdlMztcblxuICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICAgICAgLy8gZW5kIHRoZSByYW5nZSBhbmQgb3V0cHV0XG4gICAgICAgICAgdmFyIGNvbnRleHRTaXplID0gTWF0aC5taW4obGluZXMubGVuZ3RoLCBvcHRpb25zLmNvbnRleHQpO1xuXG4gICAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXG4gICAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cblxuICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgICAgICAoX2N1clJhbmdlMyA9XG4gICAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAgICAgICBjdXJSYW5nZSkucHVzaC5hcHBseShcbiAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICAgICAgX2N1clJhbmdlM1xuICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICAgICAgLFxuICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgICAgICBfdG9Db25zdW1hYmxlQXJyYXkoXG4gICAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAgICAgICBjb250ZXh0TGluZXMobGluZXMuc2xpY2UoMCwgY29udGV4dFNpemUpKSkpO1xuXG4gICAgICAgICAgdmFyIGh1bmsgPSB7XG4gICAgICAgICAgICBvbGRTdGFydDogb2xkUmFuZ2VTdGFydCxcbiAgICAgICAgICAgIG9sZExpbmVzOiBvbGRMaW5lIC0gb2xkUmFuZ2VTdGFydCArIGNvbnRleHRTaXplLFxuICAgICAgICAgICAgbmV3U3RhcnQ6IG5ld1JhbmdlU3RhcnQsXG4gICAgICAgICAgICBuZXdMaW5lczogbmV3TGluZSAtIG5ld1JhbmdlU3RhcnQgKyBjb250ZXh0U2l6ZSxcbiAgICAgICAgICAgIGxpbmVzOiBjdXJSYW5nZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoaSA+PSBkaWZmLmxlbmd0aCAtIDIgJiYgbGluZXMubGVuZ3RoIDw9IG9wdGlvbnMuY29udGV4dCkge1xuICAgICAgICAgICAgLy8gRU9GIGlzIGluc2lkZSB0aGlzIGh1bmtcbiAgICAgICAgICAgIHZhciBvbGRFT0ZOZXdsaW5lID0gL1xcbiQvLnRlc3Qob2xkU3RyKTtcbiAgICAgICAgICAgIHZhciBuZXdFT0ZOZXdsaW5lID0gL1xcbiQvLnRlc3QobmV3U3RyKTtcbiAgICAgICAgICAgIHZhciBub05sQmVmb3JlQWRkcyA9IGxpbmVzLmxlbmd0aCA9PSAwICYmIGN1clJhbmdlLmxlbmd0aCA+IGh1bmsub2xkTGluZXM7XG5cbiAgICAgICAgICAgIGlmICghb2xkRU9GTmV3bGluZSAmJiBub05sQmVmb3JlQWRkcyAmJiBvbGRTdHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IG9sZCBoYXMgbm8gZW9sIGFuZCBubyB0cmFpbGluZyBjb250ZXh0OyBuby1ubCBjYW4gZW5kIHVwIGJlZm9yZSBhZGRzXG4gICAgICAgICAgICAgIC8vIGhvd2V2ZXIsIGlmIHRoZSBvbGQgZmlsZSBpcyBlbXB0eSwgZG8gbm90IG91dHB1dCB0aGUgbm8tbmwgbGluZVxuICAgICAgICAgICAgICBjdXJSYW5nZS5zcGxpY2UoaHVuay5vbGRMaW5lcywgMCwgJ1xcXFwgTm8gbmV3bGluZSBhdCBlbmQgb2YgZmlsZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW9sZEVPRk5ld2xpbmUgJiYgIW5vTmxCZWZvcmVBZGRzIHx8ICFuZXdFT0ZOZXdsaW5lKSB7XG4gICAgICAgICAgICAgIGN1clJhbmdlLnB1c2goJ1xcXFwgTm8gbmV3bGluZSBhdCBlbmQgb2YgZmlsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGh1bmtzLnB1c2goaHVuayk7XG4gICAgICAgICAgb2xkUmFuZ2VTdGFydCA9IDA7XG4gICAgICAgICAgbmV3UmFuZ2VTdGFydCA9IDA7XG4gICAgICAgICAgY3VyUmFuZ2UgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvbGRMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgIG5ld0xpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmYubGVuZ3RoOyBpKyspIHtcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgX2xvb3AoXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICBpKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb2xkRmlsZU5hbWU6IG9sZEZpbGVOYW1lLFxuICAgIG5ld0ZpbGVOYW1lOiBuZXdGaWxlTmFtZSxcbiAgICBvbGRIZWFkZXI6IG9sZEhlYWRlcixcbiAgICBuZXdIZWFkZXI6IG5ld0hlYWRlcixcbiAgICBodW5rczogaHVua3NcbiAgfTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0UGF0Y2goZGlmZikge1xuICBpZiAoQXJyYXkuaXNBcnJheShkaWZmKSkge1xuICAgIHJldHVybiBkaWZmLm1hcChmb3JtYXRQYXRjaCkuam9pbignXFxuJyk7XG4gIH1cblxuICB2YXIgcmV0ID0gW107XG5cbiAgaWYgKGRpZmYub2xkRmlsZU5hbWUgPT0gZGlmZi5uZXdGaWxlTmFtZSkge1xuICAgIHJldC5wdXNoKCdJbmRleDogJyArIGRpZmYub2xkRmlsZU5hbWUpO1xuICB9XG5cbiAgcmV0LnB1c2goJz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0nKTtcbiAgcmV0LnB1c2goJy0tLSAnICsgZGlmZi5vbGRGaWxlTmFtZSArICh0eXBlb2YgZGlmZi5vbGRIZWFkZXIgPT09ICd1bmRlZmluZWQnID8gJycgOiAnXFx0JyArIGRpZmYub2xkSGVhZGVyKSk7XG4gIHJldC5wdXNoKCcrKysgJyArIGRpZmYubmV3RmlsZU5hbWUgKyAodHlwZW9mIGRpZmYubmV3SGVhZGVyID09PSAndW5kZWZpbmVkJyA/ICcnIDogJ1xcdCcgKyBkaWZmLm5ld0hlYWRlcikpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZi5odW5rcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBodW5rID0gZGlmZi5odW5rc1tpXTsgLy8gVW5pZmllZCBEaWZmIEZvcm1hdCBxdWlyazogSWYgdGhlIGNodW5rIHNpemUgaXMgMCxcbiAgICAvLyB0aGUgZmlyc3QgbnVtYmVyIGlzIG9uZSBsb3dlciB0aGFuIG9uZSB3b3VsZCBleHBlY3QuXG4gICAgLy8gaHR0cHM6Ly93d3cuYXJ0aW1hLmNvbS93ZWJsb2dzL3ZpZXdwb3N0LmpzcD90aHJlYWQ9MTY0MjkzXG5cbiAgICBpZiAoaHVuay5vbGRMaW5lcyA9PT0gMCkge1xuICAgICAgaHVuay5vbGRTdGFydCAtPSAxO1xuICAgIH1cblxuICAgIGlmIChodW5rLm5ld0xpbmVzID09PSAwKSB7XG4gICAgICBodW5rLm5ld1N0YXJ0IC09IDE7XG4gICAgfVxuXG4gICAgcmV0LnB1c2goJ0BAIC0nICsgaHVuay5vbGRTdGFydCArICcsJyArIGh1bmsub2xkTGluZXMgKyAnICsnICsgaHVuay5uZXdTdGFydCArICcsJyArIGh1bmsubmV3TGluZXMgKyAnIEBAJyk7XG4gICAgcmV0LnB1c2guYXBwbHkocmV0LCBodW5rLmxpbmVzKTtcbiAgfVxuXG4gIHJldHVybiByZXQuam9pbignXFxuJykgKyAnXFxuJztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdvRmlsZXNQYXRjaChvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucykge1xuICByZXR1cm4gZm9ybWF0UGF0Y2goc3RydWN0dXJlZFBhdGNoKG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoKGZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNyZWF0ZVR3b0ZpbGVzUGF0Y2goZmlsZU5hbWUsIGZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5d1lYUmphQzlqY21WaGRHVXVhbk1pWFN3aWJtRnRaWE1pT2xzaWMzUnlkV04wZFhKbFpGQmhkR05vSWl3aWIyeGtSbWxzWlU1aGJXVWlMQ0p1WlhkR2FXeGxUbUZ0WlNJc0ltOXNaRk4wY2lJc0ltNWxkMU4wY2lJc0ltOXNaRWhsWVdSbGNpSXNJbTVsZDBobFlXUmxjaUlzSW05d2RHbHZibk1pTENKamIyNTBaWGgwSWl3aVpHbG1aaUlzSW1ScFptWk1hVzVsY3lJc0luQjFjMmdpTENKMllXeDFaU0lzSW14cGJtVnpJaXdpWTI5dWRHVjRkRXhwYm1Weklpd2liV0Z3SWl3aVpXNTBjbmtpTENKb2RXNXJjeUlzSW05c1pGSmhibWRsVTNSaGNuUWlMQ0p1WlhkU1lXNW5aVk4wWVhKMElpd2lZM1Z5VW1GdVoyVWlMQ0p2YkdSTWFXNWxJaXdpYm1WM1RHbHVaU0lzSW1raUxDSmpkWEp5Wlc1MElpd2ljbVZ3YkdGalpTSXNJbk53YkdsMElpd2lZV1JrWldRaUxDSnlaVzF2ZG1Wa0lpd2ljSEpsZGlJc0luTnNhV05sSWl3aWJHVnVaM1JvSWl3aVkyOXVkR1Y0ZEZOcGVtVWlMQ0pOWVhSb0lpd2liV2x1SWl3aWFIVnVheUlzSW05c1pGTjBZWEowSWl3aWIyeGtUR2x1WlhNaUxDSnVaWGRUZEdGeWRDSXNJbTVsZDB4cGJtVnpJaXdpYjJ4a1JVOUdUbVYzYkdsdVpTSXNJblJsYzNRaUxDSnVaWGRGVDBaT1pYZHNhVzVsSWl3aWJtOU9iRUpsWm05eVpVRmtaSE1pTENKemNHeHBZMlVpTENKbWIzSnRZWFJRWVhSamFDSXNJa0Z5Y21GNUlpd2lhWE5CY25KaGVTSXNJbXB2YVc0aUxDSnlaWFFpTENKaGNIQnNlU0lzSW1OeVpXRjBaVlIzYjBacGJHVnpVR0YwWTJnaUxDSmpjbVZoZEdWUVlYUmphQ0lzSW1acGJHVk9ZVzFsSWwwc0ltMWhjSEJwYm1keklqb2lPenM3T3pzN096czdPenM3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPenM3T3pzN096czdPenM3T3pzN1FVRkZUeXhUUVVGVFFTeGxRVUZVTEVOQlFYbENReXhYUVVGNlFpeEZRVUZ6UTBNc1YwRkJkRU1zUlVGQmJVUkRMRTFCUVc1RUxFVkJRVEpFUXl4TlFVRXpSQ3hGUVVGdFJVTXNVMEZCYmtVc1JVRkJPRVZETEZOQlFUbEZMRVZCUVhsR1F5eFBRVUY2Uml4RlFVRnJSenRCUVVOMlJ5eE5RVUZKTEVOQlFVTkJMRTlCUVV3c1JVRkJZenRCUVVOYVFTeEpRVUZCUVN4UFFVRlBMRWRCUVVjc1JVRkJWanRCUVVORU96dEJRVU5FTEUxQlFVa3NUMEZCVDBFc1QwRkJUeXhEUVVGRFF5eFBRVUZtTEV0QlFUSkNMRmRCUVM5Q0xFVkJRVFJETzBGQlF6RkRSQ3hKUVVGQlFTeFBRVUZQTEVOQlFVTkRMRTlCUVZJc1IwRkJhMElzUTBGQmJFSTdRVUZEUkRzN1FVRkZSQ3hOUVVGTlF5eEpRVUZKTzBGQlFVYzdRVUZCUVR0QlFVRkJPenRCUVVGQlF6dEJRVUZCUVR0QlFVRkJRVHRCUVVGQlFUdEJRVUZCUVR0QlFVRkJRVHRCUVVGQk8wRkJRVUVzUjBGQlZWQXNUVUZCVml4RlFVRnJRa01zVFVGQmJFSXNSVUZCTUVKSExFOUJRVEZDTEVOQlFXSTdPMEZCUTBFc1RVRkJSeXhEUVVGRFJTeEpRVUZLTEVWQlFWVTdRVUZEVWp0QlFVTkVPenRCUVVWRVFTeEZRVUZCUVN4SlFVRkpMRU5CUVVORkxFbEJRVXdzUTBGQlZUdEJRVUZEUXl4SlFVRkJRU3hMUVVGTExFVkJRVVVzUlVGQlVqdEJRVUZaUXl4SlFVRkJRU3hMUVVGTExFVkJRVVU3UVVGQmJrSXNSMEZCVml4RlFXSjFSeXhEUVdGd1JUczdRVUZGYmtNc1YwRkJVME1zV1VGQlZDeERRVUZ6UWtRc1MwRkJkRUlzUlVGQk5rSTdRVUZETTBJc1YwRkJUMEVzUzBGQlN5eERRVUZEUlN4SFFVRk9MRU5CUVZVc1ZVRkJVME1zUzBGQlZDeEZRVUZuUWp0QlFVRkZMR0ZCUVU4c1RVRkJUVUVzUzBGQllqdEJRVUZ4UWl4TFFVRnFSQ3hEUVVGUU8wRkJRMFE3TzBGQlJVUXNUVUZCU1VNc1MwRkJTeXhIUVVGSExFVkJRVm83UVVGRFFTeE5RVUZKUXl4aFFVRmhMRWRCUVVjc1EwRkJjRUk3UVVGQlFTeE5RVUYxUWtNc1lVRkJZU3hIUVVGSExFTkJRWFpETzBGQlFVRXNUVUZCTUVORExGRkJRVkVzUjBGQlJ5eEZRVUZ5UkR0QlFVRkJMRTFCUTBsRExFOUJRVThzUjBGQlJ5eERRVVJrTzBGQlFVRXNUVUZEYVVKRExFOUJRVThzUjBGQlJ5eERRVVF6UWpzN1FVRndRblZITzBGQlFVRTdRVUZCUVR0QlFYTkNPVVpETEVWQlFVRkJMRU5CZEVJNFJqdEJRWFZDY2tjc1VVRkJUVU1zVDBGQlR5eEhRVUZIWml4SlFVRkpMRU5CUVVOakxFTkJRVVFzUTBGQmNFSTdRVUZCUVN4UlFVTk5WaXhMUVVGTExFZEJRVWRYTEU5QlFVOHNRMEZCUTFnc1MwRkJVaXhKUVVGcFFsY3NUMEZCVHl4RFFVRkRXaXhMUVVGU0xFTkJRV05oTEU5QlFXUXNRMEZCYzBJc1MwRkJkRUlzUlVGQk5rSXNSVUZCTjBJc1JVRkJhVU5ETEV0QlFXcERMRU5CUVhWRExFbEJRWFpETEVOQlJDOUNPMEZCUlVGR0xFbEJRVUZCTEU5QlFVOHNRMEZCUTFnc1MwRkJVaXhIUVVGblFrRXNTMEZCYUVJN08wRkJSVUVzVVVGQlNWY3NUMEZCVHl4RFFVRkRSeXhMUVVGU0xFbEJRV2xDU0N4UFFVRlBMRU5CUVVOSkxFOUJRVGRDTEVWQlFYTkRPMEZCUVVFN1FVRkJRVHM3UVVGQlFUdEJRVU53UXp0QlFVTkJMRlZCUVVrc1EwRkJRMVlzWVVGQlRDeEZRVUZ2UWp0QlFVTnNRaXhaUVVGTlZ5eEpRVUZKTEVkQlFVZHdRaXhKUVVGSkxFTkJRVU5qTEVOQlFVTXNSMEZCUnl4RFFVRk1MRU5CUVdwQ08wRkJRMEZNTEZGQlFVRkJMR0ZCUVdFc1IwRkJSMGNzVDBGQmFFSTdRVUZEUVVZc1VVRkJRVUVzWVVGQllTeEhRVUZIUnl4UFFVRm9RanM3UVVGRlFTeFpRVUZKVHl4SlFVRktMRVZCUVZVN1FVRkRVbFFzVlVGQlFVRXNVVUZCVVN4SFFVRkhZaXhQUVVGUExFTkJRVU5ETEU5QlFWSXNSMEZCYTBJc1EwRkJiRUlzUjBGQmMwSk5MRmxCUVZrc1EwRkJRMlVzU1VGQlNTeERRVUZEYUVJc1MwRkJUQ3hEUVVGWGFVSXNTMEZCV0N4RFFVRnBRaXhEUVVGRGRrSXNUMEZCVHl4RFFVRkRReXhQUVVFeFFpeERRVUZFTEVOQlFXeERMRWRCUVhsRkxFVkJRWEJHTzBGQlEwRlZMRlZCUVVGQkxHRkJRV0VzU1VGQlNVVXNVVUZCVVN4RFFVRkRWeXhOUVVFeFFqdEJRVU5CV2l4VlFVRkJRU3hoUVVGaExFbEJRVWxETEZGQlFWRXNRMEZCUTFjc1RVRkJNVUk3UVVGRFJEdEJRVU5HTEU5QldtMURMRU5CWTNCRE96czdRVUZEUVRzN1FVRkJRVHM3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVZnc1RVRkJRVUVzVVVGQlVTeEZRVUZEVkN4SlFVRlVPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCYTBKRkxFMUJRVUZCTEV0QlFVc3NRMEZCUTBVc1IwRkJUaXhEUVVGVkxGVkJRVk5ETEV0QlFWUXNSVUZCWjBJN1FVRkRNVU1zWlVGQlR5eERRVUZEVVN4UFFVRlBMRU5CUVVOSExFdEJRVklzUjBGQlowSXNSMEZCYUVJc1IwRkJjMElzUjBGQmRrSXNTVUZCT0VKWUxFdEJRWEpETzBGQlEwUXNUMEZHYVVJc1EwRkJiRUlzUjBGbWIwTXNRMEZ0UW5CRE96czdRVUZEUVN4VlFVRkpVU3hQUVVGUExFTkJRVU5ITEV0QlFWb3NSVUZCYlVJN1FVRkRha0pNTEZGQlFVRkJMRTlCUVU4c1NVRkJTVlFzUzBGQlN5eERRVUZEYTBJc1RVRkJha0k3UVVGRFJDeFBRVVpFTEUxQlJVODdRVUZEVEZZc1VVRkJRVUVzVDBGQlR5eEpRVUZKVWl4TFFVRkxMRU5CUVVOclFpeE5RVUZxUWp0QlFVTkVPMEZCUTBZc1MwRjZRa1FzVFVGNVFrODdRVUZEVER0QlFVTkJMRlZCUVVsaUxHRkJRVW9zUlVGQmJVSTdRVUZEYWtJN1FVRkRRU3haUVVGSlRDeExRVUZMTEVOQlFVTnJRaXhOUVVGT0xFbEJRV2RDZUVJc1QwRkJUeXhEUVVGRFF5eFBRVUZTTEVkQlFXdENMRU5CUVd4RExFbEJRWFZEWlN4RFFVRkRMRWRCUVVka0xFbEJRVWtzUTBGQlEzTkNMRTFCUVV3c1IwRkJZeXhEUVVFM1JDeEZRVUZuUlR0QlFVRkJPMEZCUVVFN08wRkJRVUU3UVVGRE9VUTdPMEZCUTBFN08wRkJRVUU3TzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVGWUxGVkJRVUZCTEZGQlFWRXNSVUZCUTFRc1NVRkJWRHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVd0Q1J5eFZRVUZCUVN4WlFVRlpMRU5CUVVORUxFdEJRVVFzUTBGQk9VSTdRVUZEUkN4VFFVaEVMRTFCUjA4N1FVRkJRVHRCUVVGQk96dEJRVUZCTzBGQlEwdzdRVUZEUVN4alFVRkpiVUlzVjBGQlZ5eEhRVUZIUXl4SlFVRkpMRU5CUVVORExFZEJRVXdzUTBGQlUzSkNMRXRCUVVzc1EwRkJRMnRDTEUxQlFXWXNSVUZCZFVKNFFpeFBRVUZQTEVOQlFVTkRMRTlCUVM5Q0xFTkJRV3hDT3p0QlFVTkJPenRCUVVGQk96dEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJXU3hWUVVGQlFTeFJRVUZSTEVWQlFVTlVMRWxCUVZRN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRnJRa2NzVlVGQlFVRXNXVUZCV1N4RFFVRkRSQ3hMUVVGTExFTkJRVU5wUWl4TFFVRk9MRU5CUVZrc1EwRkJXaXhGUVVGbFJTeFhRVUZtTEVOQlFVUXNRMEZCT1VJN08wRkJSVUVzWTBGQlNVY3NTVUZCU1N4SFFVRkhPMEZCUTFSRExGbEJRVUZCTEZGQlFWRXNSVUZCUld4Q0xHRkJSRVE3UVVGRlZHMUNMRmxCUVVGQkxGRkJRVkVzUlVGQlIyaENMRTlCUVU4c1IwRkJSMGdzWVVGQlZpeEhRVUV3UW1Nc1YwRkdOVUk3UVVGSFZFMHNXVUZCUVVFc1VVRkJVU3hGUVVGRmJrSXNZVUZJUkR0QlFVbFViMElzV1VGQlFVRXNVVUZCVVN4RlFVRkhha0lzVDBGQlR5eEhRVUZIU0N4aFFVRldMRWRCUVRCQ1lTeFhRVW8xUWp0QlFVdFVia0lzV1VGQlFVRXNTMEZCU3l4RlFVRkZUenRCUVV4RkxGZEJRVmc3TzBGQlQwRXNZMEZCU1Vjc1EwRkJReXhKUVVGSlpDeEpRVUZKTEVOQlFVTnpRaXhOUVVGTUxFZEJRV01zUTBGQmJrSXNTVUZCZDBKc1FpeExRVUZMTEVOQlFVTnJRaXhOUVVGT0xFbEJRV2RDZUVJc1QwRkJUeXhEUVVGRFF5eFBRVUZ3UkN4RlFVRTJSRHRCUVVNelJEdEJRVU5CTEdkQ1FVRkpaME1zWVVGQllTeEhRVUZMTEV0QlFVUXNRMEZCVVVNc1NVRkJVaXhEUVVGaGRFTXNUVUZCWWl4RFFVRnlRanRCUVVOQkxHZENRVUZKZFVNc1lVRkJZU3hIUVVGTExFdEJRVVFzUTBGQlVVUXNTVUZCVWl4RFFVRmhja01zVFVGQllpeERRVUZ5UWp0QlFVTkJMR2RDUVVGSmRVTXNZMEZCWXl4SFFVRkhPVUlzUzBGQlN5eERRVUZEYTBJc1RVRkJUaXhKUVVGblFpeERRVUZvUWl4SlFVRnhRbGdzVVVGQlVTeERRVUZEVnl4TlFVRlVMRWRCUVd0Q1NTeEpRVUZKTEVOQlFVTkZMRkZCUVdwRk96dEJRVU5CTEdkQ1FVRkpMRU5CUVVOSExHRkJRVVFzU1VGQmEwSkhMR05CUVd4Q0xFbEJRVzlEZUVNc1RVRkJUU3hEUVVGRE5FSXNUVUZCVUN4SFFVRm5RaXhEUVVGNFJDeEZRVUV5UkR0QlFVTjZSRHRCUVVOQk8wRkJRMEZZTEdOQlFVRkJMRkZCUVZFc1EwRkJRM2RDTEUxQlFWUXNRMEZCWjBKVUxFbEJRVWtzUTBGQlEwVXNVVUZCY2tJc1JVRkJLMElzUTBGQkwwSXNSVUZCYTBNc09FSkJRV3hETzBGQlEwUTdPMEZCUTBRc1owSkJRVXNzUTBGQlEwY3NZVUZCUkN4SlFVRnJRaXhEUVVGRFJ5eGpRVUZ3UWl4SlFVRjFReXhEUVVGRFJDeGhRVUUxUXl4RlFVRXlSRHRCUVVONlJIUkNMR05CUVVGQkxGRkJRVkVzUTBGQlExUXNTVUZCVkN4RFFVRmpMRGhDUVVGa08wRkJRMFE3UVVGRFJqczdRVUZEUkUwc1ZVRkJRVUVzUzBGQlN5eERRVUZEVGl4SlFVRk9MRU5CUVZkM1FpeEpRVUZZTzBGQlJVRnFRaXhWUVVGQlFTeGhRVUZoTEVkQlFVY3NRMEZCYUVJN1FVRkRRVU1zVlVGQlFVRXNZVUZCWVN4SFFVRkhMRU5CUVdoQ08wRkJRMEZETEZWQlFVRkJMRkZCUVZFc1IwRkJSeXhGUVVGWU8wRkJRMFE3UVVGRFJqczdRVUZEUkVNc1RVRkJRVUVzVDBGQlR5eEpRVUZKVWl4TFFVRkxMRU5CUVVOclFpeE5RVUZxUWp0QlFVTkJWQ3hOUVVGQlFTeFBRVUZQTEVsQlFVbFVMRXRCUVVzc1EwRkJRMnRDTEUxQlFXcENPMEZCUTBRN1FVRTVSbTlIT3p0QlFYTkNka2NzVDBGQlN5eEpRVUZKVWl4RFFVRkRMRWRCUVVjc1EwRkJZaXhGUVVGblFrRXNRMEZCUXl4SFFVRkhaQ3hKUVVGSkxFTkJRVU56UWl4TlFVRjZRaXhGUVVGcFExSXNRMEZCUXl4RlFVRnNReXhGUVVGelF6dEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRTNRa0VzU1VGQlFVRXNRMEZCTmtJN1FVRjVSWEpET3p0QlFVVkVMRk5CUVU4N1FVRkRUSFJDTEVsQlFVRkJMRmRCUVZjc1JVRkJSVUVzVjBGRVVqdEJRVU54UWtNc1NVRkJRVUVzVjBGQlZ5eEZRVUZGUVN4WFFVUnNRenRCUVVWTVJ5eEpRVUZCUVN4VFFVRlRMRVZCUVVWQkxGTkJSazQ3UVVGRmFVSkRMRWxCUVVGQkxGTkJRVk1zUlVGQlJVRXNVMEZHTlVJN1FVRkhURmNzU1VGQlFVRXNTMEZCU3l4RlFVRkZRVHRCUVVoR0xFZEJRVkE3UVVGTFJEczdRVUZGVFN4VFFVRlRORUlzVjBGQlZDeERRVUZ4UW5CRExFbEJRWEpDTEVWQlFUSkNPMEZCUTJoRExFMUJRVWx4UXl4TFFVRkxMRU5CUVVORExFOUJRVTRzUTBGQlkzUkRMRWxCUVdRc1EwRkJTaXhGUVVGNVFqdEJRVU4yUWl4WFFVRlBRU3hKUVVGSkxFTkJRVU5OTEVkQlFVd3NRMEZCVXpoQ0xGZEJRVlFzUlVGQmMwSkhMRWxCUVhSQ0xFTkJRVEpDTEVsQlFUTkNMRU5CUVZBN1FVRkRSRHM3UVVGRlJDeE5RVUZOUXl4SFFVRkhMRWRCUVVjc1JVRkJXanM3UVVGRFFTeE5RVUZKZUVNc1NVRkJTU3hEUVVGRFVpeFhRVUZNTEVsQlFXOUNVU3hKUVVGSkxFTkJRVU5RTEZkQlFUZENMRVZCUVRCRE8wRkJRM2hESzBNc1NVRkJRVUVzUjBGQlJ5eERRVUZEZEVNc1NVRkJTaXhEUVVGVExGbEJRVmxHTEVsQlFVa3NRMEZCUTFJc1YwRkJNVUk3UVVGRFJEczdRVUZEUkdkRUxFVkJRVUZCTEVkQlFVY3NRMEZCUTNSRExFbEJRVW9zUTBGQlV5eHhSVUZCVkR0QlFVTkJjME1zUlVGQlFVRXNSMEZCUnl4RFFVRkRkRU1zU1VGQlNpeERRVUZUTEZOQlFWTkdMRWxCUVVrc1EwRkJRMUlzVjBGQlpDeEpRVUUyUWl4UFFVRlBVU3hKUVVGSkxFTkJRVU5LTEZOQlFWb3NTMEZCTUVJc1YwRkJNVUlzUjBGQmQwTXNSVUZCZUVNc1IwRkJOa01zVDBGQlQwa3NTVUZCU1N4RFFVRkRTaXhUUVVGMFJpeERRVUZVTzBGQlEwRTBReXhGUVVGQlFTeEhRVUZITEVOQlFVTjBReXhKUVVGS0xFTkJRVk1zVTBGQlUwWXNTVUZCU1N4RFFVRkRVQ3hYUVVGa0xFbEJRVFpDTEU5QlFVOVBMRWxCUVVrc1EwRkJRMGdzVTBGQldpeExRVUV3UWl4WFFVRXhRaXhIUVVGM1F5eEZRVUY0UXl4SFFVRTJReXhQUVVGUFJ5eEpRVUZKTEVOQlFVTklMRk5CUVhSR0xFTkJRVlE3TzBGQlJVRXNUMEZCU3l4SlFVRkphVUlzUTBGQlF5eEhRVUZITEVOQlFXSXNSVUZCWjBKQkxFTkJRVU1zUjBGQlIyUXNTVUZCU1N4RFFVRkRVU3hMUVVGTUxFTkJRVmRqTEUxQlFTOUNMRVZCUVhWRFVpeERRVUZETEVWQlFYaERMRVZCUVRSRE8wRkJRekZETEZGQlFVMVpMRWxCUVVrc1IwRkJSekZDTEVsQlFVa3NRMEZCUTFFc1MwRkJUQ3hEUVVGWFRTeERRVUZZTEVOQlFXSXNRMEZFTUVNc1EwRkZNVU03UVVGRFFUdEJRVU5CT3p0QlFVTkJMRkZCUVVsWkxFbEJRVWtzUTBGQlEwVXNVVUZCVEN4TFFVRnJRaXhEUVVGMFFpeEZRVUY1UWp0QlFVTjJRa1lzVFVGQlFVRXNTVUZCU1N4RFFVRkRReXhSUVVGTUxFbEJRV2xDTEVOQlFXcENPMEZCUTBRN08wRkJRMFFzVVVGQlNVUXNTVUZCU1N4RFFVRkRTU3hSUVVGTUxFdEJRV3RDTEVOQlFYUkNMRVZCUVhsQ08wRkJRM1pDU2l4TlFVRkJRU3hKUVVGSkxFTkJRVU5ITEZGQlFVd3NTVUZCYVVJc1EwRkJha0k3UVVGRFJEczdRVUZEUkZjc1NVRkJRVUVzUjBGQlJ5eERRVUZEZEVNc1NVRkJTaXhEUVVORkxGTkJRVk4zUWl4SlFVRkpMRU5CUVVORExGRkJRV1FzUjBGQmVVSXNSMEZCZWtJc1IwRkJLMEpFTEVsQlFVa3NRMEZCUTBVc1VVRkJjRU1zUjBGRFJTeEpRVVJHTEVkQlExTkdMRWxCUVVrc1EwRkJRMGNzVVVGRVpDeEhRVU41UWl4SFFVUjZRaXhIUVVNclFrZ3NTVUZCU1N4RFFVRkRTU3hSUVVSd1F5eEhRVVZGTEV0QlNFbzdRVUZMUVZVc1NVRkJRVUVzUjBGQlJ5eERRVUZEZEVNc1NVRkJTaXhEUVVGVGRVTXNTMEZCVkN4RFFVRmxSQ3hIUVVGbUxFVkJRVzlDWkN4SlFVRkpMRU5CUVVOMFFpeExRVUY2UWp0QlFVTkVPenRCUVVWRUxGTkJRVTl2UXl4SFFVRkhMRU5CUVVORUxFbEJRVW9zUTBGQlV5eEpRVUZVTEVsQlFXbENMRWxCUVhoQ08wRkJRMFE3TzBGQlJVMHNVMEZCVTBjc2JVSkJRVlFzUTBGQk5rSnNSQ3hYUVVFM1FpeEZRVUV3UTBNc1YwRkJNVU1zUlVGQmRVUkRMRTFCUVhaRUxFVkJRU3RFUXl4TlFVRXZSQ3hGUVVGMVJVTXNVMEZCZGtVc1JVRkJhMFpETEZOQlFXeEdMRVZCUVRaR1F5eFBRVUUzUml4RlFVRnpSenRCUVVNelJ5eFRRVUZQYzBNc1YwRkJWeXhEUVVGRE4wTXNaVUZCWlN4RFFVRkRReXhYUVVGRUxFVkJRV05ETEZkQlFXUXNSVUZCTWtKRExFMUJRVE5DTEVWQlFXMURReXhOUVVGdVF5eEZRVUV5UTBNc1UwRkJNME1zUlVGQmMwUkRMRk5CUVhSRUxFVkJRV2xGUXl4UFFVRnFSU3hEUVVGb1FpeERRVUZzUWp0QlFVTkVPenRCUVVWTkxGTkJRVk0yUXl4WFFVRlVMRU5CUVhGQ1F5eFJRVUZ5UWl4RlFVRXJRbXhFTEUxQlFTOUNMRVZCUVhWRFF5eE5RVUYyUXl4RlFVRXJRME1zVTBGQkwwTXNSVUZCTUVSRExGTkJRVEZFTEVWQlFYRkZReXhQUVVGeVJTeEZRVUU0UlR0QlFVTnVSaXhUUVVGUE5FTXNiVUpCUVcxQ0xFTkJRVU5GTEZGQlFVUXNSVUZCVjBFc1VVRkJXQ3hGUVVGeFFteEVMRTFCUVhKQ0xFVkJRVFpDUXl4TlFVRTNRaXhGUVVGeFEwTXNVMEZCY2tNc1JVRkJaMFJETEZOQlFXaEVMRVZCUVRKRVF5eFBRVUV6UkN4RFFVRXhRanRCUVVORUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lhVzF3YjNKMElIdGthV1ptVEdsdVpYTjlJR1p5YjIwZ0p5NHVMMlJwWm1ZdmJHbHVaU2M3WEc1Y2JtVjRjRzl5ZENCbWRXNWpkR2x2YmlCemRISjFZM1IxY21Wa1VHRjBZMmdvYjJ4a1JtbHNaVTVoYldVc0lHNWxkMFpwYkdWT1lXMWxMQ0J2YkdSVGRISXNJRzVsZDFOMGNpd2diMnhrU0dWaFpHVnlMQ0J1WlhkSVpXRmtaWElzSUc5d2RHbHZibk1wSUh0Y2JpQWdhV1lnS0NGdmNIUnBiMjV6S1NCN1hHNGdJQ0FnYjNCMGFXOXVjeUE5SUh0OU8xeHVJQ0I5WEc0Z0lHbG1JQ2gwZVhCbGIyWWdiM0IwYVc5dWN5NWpiMjUwWlhoMElEMDlQU0FuZFc1a1pXWnBibVZrSnlrZ2UxeHVJQ0FnSUc5d2RHbHZibk11WTI5dWRHVjRkQ0E5SURRN1hHNGdJSDFjYmx4dUlDQmpiMjV6ZENCa2FXWm1JRDBnWkdsbVpreHBibVZ6S0c5c1pGTjBjaXdnYm1WM1UzUnlMQ0J2Y0hScGIyNXpLVHRjYmlBZ2FXWW9JV1JwWm1ZcElIdGNiaUFnSUNCeVpYUjFjbTQ3WEc0Z0lIMWNibHh1SUNCa2FXWm1MbkIxYzJnb2UzWmhiSFZsT2lBbkp5d2diR2x1WlhNNklGdGRmU2s3SUM4dklFRndjR1Z1WkNCaGJpQmxiWEIwZVNCMllXeDFaU0IwYnlCdFlXdGxJR05zWldGdWRYQWdaV0Z6YVdWeVhHNWNiaUFnWm5WdVkzUnBiMjRnWTI5dWRHVjRkRXhwYm1WektHeHBibVZ6S1NCN1hHNGdJQ0FnY21WMGRYSnVJR3hwYm1WekxtMWhjQ2htZFc1amRHbHZiaWhsYm5SeWVTa2dleUJ5WlhSMWNtNGdKeUFuSUNzZ1pXNTBjbms3SUgwcE8xeHVJQ0I5WEc1Y2JpQWdiR1YwSUdoMWJtdHpJRDBnVzEwN1hHNGdJR3hsZENCdmJHUlNZVzVuWlZOMFlYSjBJRDBnTUN3Z2JtVjNVbUZ1WjJWVGRHRnlkQ0E5SURBc0lHTjFjbEpoYm1kbElEMGdXMTBzWEc0Z0lDQWdJQ0J2YkdSTWFXNWxJRDBnTVN3Z2JtVjNUR2x1WlNBOUlERTdYRzRnSUdadmNpQW9iR1YwSUdrZ1BTQXdPeUJwSUR3Z1pHbG1aaTVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUdOdmJuTjBJR04xY25KbGJuUWdQU0JrYVdabVcybGRMRnh1SUNBZ0lDQWdJQ0FnSUd4cGJtVnpJRDBnWTNWeWNtVnVkQzVzYVc1bGN5QjhmQ0JqZFhKeVpXNTBMblpoYkhWbExuSmxjR3hoWTJVb0wxeGNiaVF2TENBbkp5a3VjM0JzYVhRb0oxeGNiaWNwTzF4dUlDQWdJR04xY25KbGJuUXViR2x1WlhNZ1BTQnNhVzVsY3p0Y2JseHVJQ0FnSUdsbUlDaGpkWEp5Wlc1MExtRmtaR1ZrSUh4OElHTjFjbkpsYm5RdWNtVnRiM1psWkNrZ2UxeHVJQ0FnSUNBZ0x5OGdTV1lnZDJVZ2FHRjJaU0J3Y21WMmFXOTFjeUJqYjI1MFpYaDBMQ0J6ZEdGeWRDQjNhWFJvSUhSb1lYUmNiaUFnSUNBZ0lHbG1JQ2doYjJ4a1VtRnVaMlZUZEdGeWRDa2dlMXh1SUNBZ0lDQWdJQ0JqYjI1emRDQndjbVYySUQwZ1pHbG1abHRwSUMwZ01WMDdYRzRnSUNBZ0lDQWdJRzlzWkZKaGJtZGxVM1JoY25RZ1BTQnZiR1JNYVc1bE8xeHVJQ0FnSUNBZ0lDQnVaWGRTWVc1blpWTjBZWEowSUQwZ2JtVjNUR2x1WlR0Y2JseHVJQ0FnSUNBZ0lDQnBaaUFvY0hKbGRpa2dlMXh1SUNBZ0lDQWdJQ0FnSUdOMWNsSmhibWRsSUQwZ2IzQjBhVzl1Y3k1amIyNTBaWGgwSUQ0Z01DQS9JR052Ym5SbGVIUk1hVzVsY3lod2NtVjJMbXhwYm1WekxuTnNhV05sS0MxdmNIUnBiMjV6TG1OdmJuUmxlSFFwS1NBNklGdGRPMXh1SUNBZ0lDQWdJQ0FnSUc5c1pGSmhibWRsVTNSaGNuUWdMVDBnWTNWeVVtRnVaMlV1YkdWdVozUm9PMXh1SUNBZ0lDQWdJQ0FnSUc1bGQxSmhibWRsVTNSaGNuUWdMVDBnWTNWeVVtRnVaMlV1YkdWdVozUm9PMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUM4dklFOTFkSEIxZENCdmRYSWdZMmhoYm1kbGMxeHVJQ0FnSUNBZ1kzVnlVbUZ1WjJVdWNIVnphQ2d1TGk0Z2JHbHVaWE11YldGd0tHWjFibU4wYVc5dUtHVnVkSEo1S1NCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlBb1kzVnljbVZ1ZEM1aFpHUmxaQ0EvSUNjckp5QTZJQ2N0SnlrZ0t5QmxiblJ5ZVR0Y2JpQWdJQ0FnSUgwcEtUdGNibHh1SUNBZ0lDQWdMeThnVkhKaFkyc2dkR2hsSUhWd1pHRjBaV1FnWm1sc1pTQndiM05wZEdsdmJseHVJQ0FnSUNBZ2FXWWdLR04xY25KbGJuUXVZV1JrWldRcElIdGNiaUFnSUNBZ0lDQWdibVYzVEdsdVpTQXJQU0JzYVc1bGN5NXNaVzVuZEdnN1hHNGdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNCdmJHUk1hVzVsSUNzOUlHeHBibVZ6TG14bGJtZDBhRHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0x5OGdTV1JsYm5ScFkyRnNJR052Ym5SbGVIUWdiR2x1WlhNdUlGUnlZV05ySUd4cGJtVWdZMmhoYm1kbGMxeHVJQ0FnSUNBZ2FXWWdLRzlzWkZKaGJtZGxVM1JoY25RcElIdGNiaUFnSUNBZ0lDQWdMeThnUTJ4dmMyVWdiM1YwSUdGdWVTQmphR0Z1WjJWeklIUm9ZWFFnYUdGMlpTQmlaV1Z1SUc5MWRIQjFkQ0FvYjNJZ2FtOXBiaUJ2ZG1WeWJHRndjR2x1WnlsY2JpQWdJQ0FnSUNBZ2FXWWdLR3hwYm1WekxteGxibWQwYUNBOFBTQnZjSFJwYjI1ekxtTnZiblJsZUhRZ0tpQXlJQ1ltSUdrZ1BDQmthV1ptTG14bGJtZDBhQ0F0SURJcElIdGNiaUFnSUNBZ0lDQWdJQ0F2THlCUGRtVnliR0Z3Y0dsdVoxeHVJQ0FnSUNBZ0lDQWdJR04xY2xKaGJtZGxMbkIxYzJnb0xpNHVJR052Ym5SbGVIUk1hVzVsY3loc2FXNWxjeWtwTzF4dUlDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNBZ0lDOHZJR1Z1WkNCMGFHVWdjbUZ1WjJVZ1lXNWtJRzkxZEhCMWRGeHVJQ0FnSUNBZ0lDQWdJR3hsZENCamIyNTBaWGgwVTJsNlpTQTlJRTFoZEdndWJXbHVLR3hwYm1WekxteGxibWQwYUN3Z2IzQjBhVzl1Y3k1amIyNTBaWGgwS1R0Y2JpQWdJQ0FnSUNBZ0lDQmpkWEpTWVc1blpTNXdkWE5vS0M0dUxpQmpiMjUwWlhoMFRHbHVaWE1vYkdsdVpYTXVjMnhwWTJVb01Dd2dZMjl1ZEdWNGRGTnBlbVVwS1NrN1hHNWNiaUFnSUNBZ0lDQWdJQ0JzWlhRZ2FIVnVheUE5SUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJRzlzWkZOMFlYSjBPaUJ2YkdSU1lXNW5aVk4wWVhKMExGeHVJQ0FnSUNBZ0lDQWdJQ0FnYjJ4a1RHbHVaWE02SUNodmJHUk1hVzVsSUMwZ2IyeGtVbUZ1WjJWVGRHRnlkQ0FySUdOdmJuUmxlSFJUYVhwbEtTeGNiaUFnSUNBZ0lDQWdJQ0FnSUc1bGQxTjBZWEowT2lCdVpYZFNZVzVuWlZOMFlYSjBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2JtVjNUR2x1WlhNNklDaHVaWGRNYVc1bElDMGdibVYzVW1GdVoyVlRkR0Z5ZENBcklHTnZiblJsZUhSVGFYcGxLU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lHeHBibVZ6T2lCamRYSlNZVzVuWlZ4dUlDQWdJQ0FnSUNBZ0lIMDdYRzRnSUNBZ0lDQWdJQ0FnYVdZZ0tHa2dQajBnWkdsbVppNXNaVzVuZEdnZ0xTQXlJQ1ltSUd4cGJtVnpMbXhsYm1kMGFDQThQU0J2Y0hScGIyNXpMbU52Ym5SbGVIUXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDOHZJRVZQUmlCcGN5QnBibk5wWkdVZ2RHaHBjeUJvZFc1clhHNGdJQ0FnSUNBZ0lDQWdJQ0JzWlhRZ2IyeGtSVTlHVG1WM2JHbHVaU0E5SUNnb0wxeGNiaVF2S1M1MFpYTjBLRzlzWkZOMGNpa3BPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2JHVjBJRzVsZDBWUFJrNWxkMnhwYm1VZ1BTQW9LQzljWEc0a0x5a3VkR1Z6ZENodVpYZFRkSElwS1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJR3hsZENCdWIwNXNRbVZtYjNKbFFXUmtjeUE5SUd4cGJtVnpMbXhsYm1kMGFDQTlQU0F3SUNZbUlHTjFjbEpoYm1kbExteGxibWQwYUNBK0lHaDFibXN1YjJ4a1RHbHVaWE03WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBaaUFvSVc5c1pFVlBSazVsZDJ4cGJtVWdKaVlnYm05T2JFSmxabTl5WlVGa1pITWdKaVlnYjJ4a1UzUnlMbXhsYm1kMGFDQStJREFwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnTHk4Z2MzQmxZMmxoYkNCallYTmxPaUJ2YkdRZ2FHRnpJRzV2SUdWdmJDQmhibVFnYm04Z2RISmhhV3hwYm1jZ1kyOXVkR1Y0ZERzZ2JtOHRibXdnWTJGdUlHVnVaQ0IxY0NCaVpXWnZjbVVnWVdSa2MxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBdkx5Qm9iM2RsZG1WeUxDQnBaaUIwYUdVZ2IyeGtJR1pwYkdVZ2FYTWdaVzF3ZEhrc0lHUnZJRzV2ZENCdmRYUndkWFFnZEdobElHNXZMVzVzSUd4cGJtVmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ1kzVnlVbUZ1WjJVdWMzQnNhV05sS0doMWJtc3ViMnhrVEdsdVpYTXNJREFzSUNkY1hGeGNJRTV2SUc1bGQyeHBibVVnWVhRZ1pXNWtJRzltSUdacGJHVW5LVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdJQ0FnSUdsbUlDZ29JVzlzWkVWUFJrNWxkMnhwYm1VZ0ppWWdJVzV2VG14Q1pXWnZjbVZCWkdSektTQjhmQ0FoYm1WM1JVOUdUbVYzYkdsdVpTa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQmpkWEpTWVc1blpTNXdkWE5vS0NkY1hGeGNJRTV2SUc1bGQyeHBibVVnWVhRZ1pXNWtJRzltSUdacGJHVW5LVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUNBZ2FIVnVhM011Y0hWemFDaG9kVzVyS1R0Y2JseHVJQ0FnSUNBZ0lDQWdJRzlzWkZKaGJtZGxVM1JoY25RZ1BTQXdPMXh1SUNBZ0lDQWdJQ0FnSUc1bGQxSmhibWRsVTNSaGNuUWdQU0F3TzF4dUlDQWdJQ0FnSUNBZ0lHTjFjbEpoYm1kbElEMGdXMTA3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUc5c1pFeHBibVVnS3owZ2JHbHVaWE11YkdWdVozUm9PMXh1SUNBZ0lDQWdibVYzVEdsdVpTQXJQU0JzYVc1bGN5NXNaVzVuZEdnN1hHNGdJQ0FnZlZ4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUh0Y2JpQWdJQ0J2YkdSR2FXeGxUbUZ0WlRvZ2IyeGtSbWxzWlU1aGJXVXNJRzVsZDBacGJHVk9ZVzFsT2lCdVpYZEdhV3hsVG1GdFpTeGNiaUFnSUNCdmJHUklaV0ZrWlhJNklHOXNaRWhsWVdSbGNpd2dibVYzU0dWaFpHVnlPaUJ1WlhkSVpXRmtaWElzWEc0Z0lDQWdhSFZ1YTNNNklHaDFibXR6WEc0Z0lIMDdYRzU5WEc1Y2JtVjRjRzl5ZENCbWRXNWpkR2x2YmlCbWIzSnRZWFJRWVhSamFDaGthV1ptS1NCN1hHNGdJR2xtSUNoQmNuSmhlUzVwYzBGeWNtRjVLR1JwWm1ZcEtTQjdYRzRnSUNBZ2NtVjBkWEp1SUdScFptWXViV0Z3S0dadmNtMWhkRkJoZEdOb0tTNXFiMmx1S0NkY1hHNG5LVHRjYmlBZ2ZWeHVYRzRnSUdOdmJuTjBJSEpsZENBOUlGdGRPMXh1SUNCcFppQW9aR2xtWmk1dmJHUkdhV3hsVG1GdFpTQTlQU0JrYVdabUxtNWxkMFpwYkdWT1lXMWxLU0I3WEc0Z0lDQWdjbVYwTG5CMWMyZ29KMGx1WkdWNE9pQW5JQ3NnWkdsbVppNXZiR1JHYVd4bFRtRnRaU2s3WEc0Z0lIMWNiaUFnY21WMExuQjFjMmdvSnowOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMG5LVHRjYmlBZ2NtVjBMbkIxYzJnb0p5MHRMU0FuSUNzZ1pHbG1aaTV2YkdSR2FXeGxUbUZ0WlNBcklDaDBlWEJsYjJZZ1pHbG1aaTV2YkdSSVpXRmtaWElnUFQwOUlDZDFibVJsWm1sdVpXUW5JRDhnSnljZ09pQW5YRngwSnlBcklHUnBabVl1YjJ4a1NHVmhaR1Z5S1NrN1hHNGdJSEpsZEM1d2RYTm9LQ2NyS3lzZ0p5QXJJR1JwWm1ZdWJtVjNSbWxzWlU1aGJXVWdLeUFvZEhsd1pXOW1JR1JwWm1ZdWJtVjNTR1ZoWkdWeUlEMDlQU0FuZFc1a1pXWnBibVZrSnlBL0lDY25JRG9nSjF4Y2RDY2dLeUJrYVdabUxtNWxkMGhsWVdSbGNpa3BPMXh1WEc0Z0lHWnZjaUFvYkdWMElHa2dQU0F3T3lCcElEd2daR2xtWmk1b2RXNXJjeTVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUdOdmJuTjBJR2gxYm1zZ1BTQmthV1ptTG1oMWJtdHpXMmxkTzF4dUlDQWdJQzh2SUZWdWFXWnBaV1FnUkdsbVppQkdiM0p0WVhRZ2NYVnBjbXM2SUVsbUlIUm9aU0JqYUhWdWF5QnphWHBsSUdseklEQXNYRzRnSUNBZ0x5OGdkR2hsSUdacGNuTjBJRzUxYldKbGNpQnBjeUJ2Ym1VZ2JHOTNaWElnZEdoaGJpQnZibVVnZDI5MWJHUWdaWGh3WldOMExseHVJQ0FnSUM4dklHaDBkSEJ6T2k4dmQzZDNMbUZ5ZEdsdFlTNWpiMjB2ZDJWaWJHOW5jeTkyYVdWM2NHOXpkQzVxYzNBL2RHaHlaV0ZrUFRFMk5ESTVNMXh1SUNBZ0lHbG1JQ2hvZFc1ckxtOXNaRXhwYm1WeklEMDlQU0F3S1NCN1hHNGdJQ0FnSUNCb2RXNXJMbTlzWkZOMFlYSjBJQzA5SURFN1hHNGdJQ0FnZlZ4dUlDQWdJR2xtSUNob2RXNXJMbTVsZDB4cGJtVnpJRDA5UFNBd0tTQjdYRzRnSUNBZ0lDQm9kVzVyTG01bGQxTjBZWEowSUMwOUlERTdYRzRnSUNBZ2ZWeHVJQ0FnSUhKbGRDNXdkWE5vS0Z4dUlDQWdJQ0FnSjBCQUlDMG5JQ3NnYUhWdWF5NXZiR1JUZEdGeWRDQXJJQ2NzSnlBcklHaDFibXN1YjJ4a1RHbHVaWE5jYmlBZ0lDQWdJQ3NnSnlBckp5QXJJR2gxYm1zdWJtVjNVM1JoY25RZ0t5QW5MQ2NnS3lCb2RXNXJMbTVsZDB4cGJtVnpYRzRnSUNBZ0lDQXJJQ2NnUUVBblhHNGdJQ0FnS1R0Y2JpQWdJQ0J5WlhRdWNIVnphQzVoY0hCc2VTaHlaWFFzSUdoMWJtc3ViR2x1WlhNcE8xeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlISmxkQzVxYjJsdUtDZGNYRzRuS1NBcklDZGNYRzRuTzF4dWZWeHVYRzVsZUhCdmNuUWdablZ1WTNScGIyNGdZM0psWVhSbFZIZHZSbWxzWlhOUVlYUmphQ2h2YkdSR2FXeGxUbUZ0WlN3Z2JtVjNSbWxzWlU1aGJXVXNJRzlzWkZOMGNpd2dibVYzVTNSeUxDQnZiR1JJWldGa1pYSXNJRzVsZDBobFlXUmxjaXdnYjNCMGFXOXVjeWtnZTF4dUlDQnlaWFIxY200Z1ptOXliV0YwVUdGMFkyZ29jM1J5ZFdOMGRYSmxaRkJoZEdOb0tHOXNaRVpwYkdWT1lXMWxMQ0J1WlhkR2FXeGxUbUZ0WlN3Z2IyeGtVM1J5TENCdVpYZFRkSElzSUc5c1pFaGxZV1JsY2l3Z2JtVjNTR1ZoWkdWeUxDQnZjSFJwYjI1ektTazdYRzU5WEc1Y2JtVjRjRzl5ZENCbWRXNWpkR2x2YmlCamNtVmhkR1ZRWVhSamFDaG1hV3hsVG1GdFpTd2diMnhrVTNSeUxDQnVaWGRUZEhJc0lHOXNaRWhsWVdSbGNpd2dibVYzU0dWaFpHVnlMQ0J2Y0hScGIyNXpLU0I3WEc0Z0lISmxkSFZ5YmlCamNtVmhkR1ZVZDI5R2FXeGxjMUJoZEdOb0tHWnBiR1ZPWVcxbExDQm1hV3hsVG1GdFpTd2diMnhrVTNSeUxDQnVaWGRUZEhJc0lHOXNaRWhsWVdSbGNpd2dibVYzU0dWaFpHVnlMQ0J2Y0hScGIyNXpLVHRjYm4xY2JpSmRmUT09XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/diff/lib/patch/create.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/diff/lib/patch/merge.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mocha/node_modules/diff/lib/patch/merge.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*istanbul ignore start*/\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.calcLineCount = calcLineCount;\nexports.merge = merge;\n\n/*istanbul ignore end*/\nvar\n/*istanbul ignore start*/\n_create = __webpack_require__(/*! ./create */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/patch/create.js\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_parse = __webpack_require__(/*! ./parse */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/patch/parse.js\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_array = __webpack_require__(/*! ../util/array */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/util/array.js\")\n/*istanbul ignore end*/\n;\n\n/*istanbul ignore start*/ function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*istanbul ignore end*/\nfunction calcLineCount(hunk) {\n  /*istanbul ignore start*/\n  var _calcOldNewLineCount =\n  /*istanbul ignore end*/\n  calcOldNewLineCount(hunk.lines),\n      oldLines = _calcOldNewLineCount.oldLines,\n      newLines = _calcOldNewLineCount.newLines;\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\n\nfunction merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n  var mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    var mineCurrent = mine.hunks[mineIndex] || {\n      oldStart: Infinity\n    },\n        theirsCurrent = theirs.hunks[theirsIndex] || {\n      oldStart: Infinity\n    };\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      var mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n      return (\n        /*istanbul ignore start*/\n        (0,\n        /*istanbul ignore end*/\n\n        /*istanbul ignore start*/\n        _parse\n        /*istanbul ignore end*/\n        .\n        /*istanbul ignore start*/\n        parsePatch)\n        /*istanbul ignore end*/\n        (param)[0]\n      );\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n\n    return (\n      /*istanbul ignore start*/\n      (0,\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n      _create\n      /*istanbul ignore end*/\n      .\n      /*istanbul ignore start*/\n      structuredPatch)\n      /*istanbul ignore end*/\n      (undefined, undefined, base, param)\n    );\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {\n      mine: mine,\n      theirs: theirs\n    };\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart,\n    oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset,\n    newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  var mine = {\n    offset: mineOffset,\n    lines: mineLines,\n    index: 0\n  },\n      their = {\n    offset: theirOffset,\n    lines: theirLines,\n    index: 0\n  }; // Handle any leading content\n\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    var mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      /*istanbul ignore start*/\n      var _hunk$lines;\n\n      /*istanbul ignore end*/\n      // Mine inserted\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n      (_hunk$lines =\n      /*istanbul ignore end*/\n      hunk.lines).push.apply(\n      /*istanbul ignore start*/\n      _hunk$lines\n      /*istanbul ignore end*/\n      ,\n      /*istanbul ignore start*/\n      _toConsumableArray(\n      /*istanbul ignore end*/\n      collectChange(mine)));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      /*istanbul ignore start*/\n      var _hunk$lines2;\n\n      /*istanbul ignore end*/\n      // Theirs inserted\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n      (_hunk$lines2 =\n      /*istanbul ignore end*/\n      hunk.lines).push.apply(\n      /*istanbul ignore start*/\n      _hunk$lines2\n      /*istanbul ignore end*/\n      ,\n      /*istanbul ignore start*/\n      _toConsumableArray(\n      /*istanbul ignore end*/\n      collectChange(their)));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  } // Now push anything that may be remaining\n\n\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (\n    /*istanbul ignore start*/\n    (0,\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _array\n    /*istanbul ignore end*/\n    .\n    /*istanbul ignore start*/\n    arrayStartsWith)\n    /*istanbul ignore end*/\n    (myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      /*istanbul ignore start*/\n      var _hunk$lines3;\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n      (_hunk$lines3 =\n      /*istanbul ignore end*/\n      hunk.lines).push.apply(\n      /*istanbul ignore start*/\n      _hunk$lines3\n      /*istanbul ignore end*/\n      ,\n      /*istanbul ignore start*/\n      _toConsumableArray(\n      /*istanbul ignore end*/\n      myChanges));\n\n      return;\n    } else if (\n    /*istanbul ignore start*/\n    (0,\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _array\n    /*istanbul ignore end*/\n    .\n    /*istanbul ignore start*/\n    arrayStartsWith)\n    /*istanbul ignore end*/\n    (theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      /*istanbul ignore start*/\n      var _hunk$lines4;\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n      (_hunk$lines4 =\n      /*istanbul ignore end*/\n      hunk.lines).push.apply(\n      /*istanbul ignore start*/\n      _hunk$lines4\n      /*istanbul ignore end*/\n      ,\n      /*istanbul ignore start*/\n      _toConsumableArray(\n      /*istanbul ignore end*/\n      theirChanges));\n\n      return;\n    }\n  } else if (\n  /*istanbul ignore start*/\n  (0,\n  /*istanbul ignore end*/\n\n  /*istanbul ignore start*/\n  _array\n  /*istanbul ignore end*/\n  .\n  /*istanbul ignore start*/\n  arrayEqual)\n  /*istanbul ignore end*/\n  (myChanges, theirChanges)) {\n    /*istanbul ignore start*/\n    var _hunk$lines5;\n\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    (_hunk$lines5 =\n    /*istanbul ignore end*/\n    hunk.lines).push.apply(\n    /*istanbul ignore start*/\n    _hunk$lines5\n    /*istanbul ignore end*/\n    ,\n    /*istanbul ignore start*/\n    _toConsumableArray(\n    /*istanbul ignore end*/\n    myChanges));\n\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n\n  if (theirChanges.merged) {\n    /*istanbul ignore start*/\n    var _hunk$lines6;\n\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    (_hunk$lines6 =\n    /*istanbul ignore end*/\n    hunk.lines).push.apply(\n    /*istanbul ignore start*/\n    _hunk$lines6\n    /*istanbul ignore end*/\n    ,\n    /*istanbul ignore start*/\n    _toConsumableArray(\n    /*istanbul ignore end*/\n    theirChanges.merged));\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\n\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  var ret = [],\n      operation = state.lines[state.index][0];\n\n  while (state.index < state.lines.length) {\n    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\n\nfunction collectContext(state, matchChanges) {\n  var changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n\n  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n    var change = state.lines[state.index],\n        match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n    merged.push(match);\n    matchIndex++; // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged: merged,\n    changes: changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function (prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\n\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (var i = 0; i < delta; i++) {\n    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  var oldLines = 0;\n  var newLines = 0;\n  lines.forEach(function (line) {\n    if (typeof line !== 'string') {\n      var myCount = calcOldNewLineCount(line.mine);\n      var theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n  return {\n    oldLines: oldLines,\n    newLines: newLines\n  };\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXRjaC9tZXJnZS5qcyJdLCJuYW1lcyI6WyJjYWxjTGluZUNvdW50IiwiaHVuayIsImNhbGNPbGROZXdMaW5lQ291bnQiLCJsaW5lcyIsIm9sZExpbmVzIiwibmV3TGluZXMiLCJ1bmRlZmluZWQiLCJtZXJnZSIsIm1pbmUiLCJ0aGVpcnMiLCJiYXNlIiwibG9hZFBhdGNoIiwicmV0IiwiaW5kZXgiLCJuZXdGaWxlTmFtZSIsImZpbGVOYW1lQ2hhbmdlZCIsIm9sZEZpbGVOYW1lIiwib2xkSGVhZGVyIiwibmV3SGVhZGVyIiwic2VsZWN0RmllbGQiLCJodW5rcyIsIm1pbmVJbmRleCIsInRoZWlyc0luZGV4IiwibWluZU9mZnNldCIsInRoZWlyc09mZnNldCIsImxlbmd0aCIsIm1pbmVDdXJyZW50Iiwib2xkU3RhcnQiLCJJbmZpbml0eSIsInRoZWlyc0N1cnJlbnQiLCJodW5rQmVmb3JlIiwicHVzaCIsImNsb25lSHVuayIsIm1lcmdlZEh1bmsiLCJNYXRoIiwibWluIiwibmV3U3RhcnQiLCJtZXJnZUxpbmVzIiwicGFyYW0iLCJ0ZXN0IiwicGFyc2VQYXRjaCIsIkVycm9yIiwic3RydWN0dXJlZFBhdGNoIiwicGF0Y2giLCJjb25mbGljdCIsImNoZWNrIiwib2Zmc2V0IiwibWluZUxpbmVzIiwidGhlaXJPZmZzZXQiLCJ0aGVpckxpbmVzIiwidGhlaXIiLCJpbnNlcnRMZWFkaW5nIiwidGhlaXJDdXJyZW50IiwibXV0dWFsQ2hhbmdlIiwiY29sbGVjdENoYW5nZSIsInJlbW92YWwiLCJpbnNlcnRUcmFpbGluZyIsIm15Q2hhbmdlcyIsInRoZWlyQ2hhbmdlcyIsImFsbFJlbW92ZXMiLCJhcnJheVN0YXJ0c1dpdGgiLCJza2lwUmVtb3ZlU3VwZXJzZXQiLCJhcnJheUVxdWFsIiwic3dhcCIsImNvbGxlY3RDb250ZXh0IiwibWVyZ2VkIiwiaW5zZXJ0IiwibGluZSIsInN0YXRlIiwib3BlcmF0aW9uIiwibWF0Y2hDaGFuZ2VzIiwiY2hhbmdlcyIsIm1hdGNoSW5kZXgiLCJjb250ZXh0Q2hhbmdlcyIsImNvbmZsaWN0ZWQiLCJjaGFuZ2UiLCJtYXRjaCIsInN1YnN0ciIsInJlZHVjZSIsInByZXYiLCJyZW1vdmVDaGFuZ2VzIiwiZGVsdGEiLCJpIiwiY2hhbmdlQ29udGVudCIsImZvckVhY2giLCJteUNvdW50IiwidGhlaXJDb3VudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7QUFFTyxTQUFTQSxhQUFULENBQXVCQyxJQUF2QixFQUE2QjtBQUFBO0FBQUE7QUFBQTtBQUNMQyxFQUFBQSxtQkFBbUIsQ0FBQ0QsSUFBSSxDQUFDRSxLQUFOLENBRGQ7QUFBQSxNQUMzQkMsUUFEMkIsd0JBQzNCQSxRQUQyQjtBQUFBLE1BQ2pCQyxRQURpQix3QkFDakJBLFFBRGlCOztBQUdsQyxNQUFJRCxRQUFRLEtBQUtFLFNBQWpCLEVBQTRCO0FBQzFCTCxJQUFBQSxJQUFJLENBQUNHLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsV0FBT0gsSUFBSSxDQUFDRyxRQUFaO0FBQ0Q7O0FBRUQsTUFBSUMsUUFBUSxLQUFLQyxTQUFqQixFQUE0QjtBQUMxQkwsSUFBQUEsSUFBSSxDQUFDSSxRQUFMLEdBQWdCQSxRQUFoQjtBQUNELEdBRkQsTUFFTztBQUNMLFdBQU9KLElBQUksQ0FBQ0ksUUFBWjtBQUNEO0FBQ0Y7O0FBRU0sU0FBU0UsS0FBVCxDQUFlQyxJQUFmLEVBQXFCQyxNQUFyQixFQUE2QkMsSUFBN0IsRUFBbUM7QUFDeENGLEVBQUFBLElBQUksR0FBR0csU0FBUyxDQUFDSCxJQUFELEVBQU9FLElBQVAsQ0FBaEI7QUFDQUQsRUFBQUEsTUFBTSxHQUFHRSxTQUFTLENBQUNGLE1BQUQsRUFBU0MsSUFBVCxDQUFsQjtBQUVBLE1BQUlFLEdBQUcsR0FBRyxFQUFWLENBSndD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QUFKLEVBQW9FO0FBQ2xFL0QsUUFBQUEsUUFBUTtBQUNUO0FBQ0Y7QUFDRixHQTVCRDtBQThCQSxTQUFPO0FBQUNBLElBQUFBLFFBQVEsRUFBUkEsUUFBRDtBQUFXQyxJQUFBQSxRQUFRLEVBQVJBO0FBQVgsR0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtzdHJ1Y3R1cmVkUGF0Y2h9IGZyb20gJy4vY3JlYXRlJztcbmltcG9ydCB7cGFyc2VQYXRjaH0gZnJvbSAnLi9wYXJzZSc7XG5cbmltcG9ydCB7YXJyYXlFcXVhbCwgYXJyYXlTdGFydHNXaXRofSBmcm9tICcuLi91dGlsL2FycmF5JztcblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGNMaW5lQ291bnQoaHVuaykge1xuICBjb25zdCB7b2xkTGluZXMsIG5ld0xpbmVzfSA9IGNhbGNPbGROZXdMaW5lQ291bnQoaHVuay5saW5lcyk7XG5cbiAgaWYgKG9sZExpbmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBodW5rLm9sZExpbmVzID0gb2xkTGluZXM7XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIGh1bmsub2xkTGluZXM7XG4gIH1cblxuICBpZiAobmV3TGluZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGh1bmsubmV3TGluZXMgPSBuZXdMaW5lcztcbiAgfSBlbHNlIHtcbiAgICBkZWxldGUgaHVuay5uZXdMaW5lcztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2UobWluZSwgdGhlaXJzLCBiYXNlKSB7XG4gIG1pbmUgPSBsb2FkUGF0Y2gobWluZSwgYmFzZSk7XG4gIHRoZWlycyA9IGxvYWRQYXRjaCh0aGVpcnMsIGJhc2UpO1xuXG4gIGxldCByZXQgPSB7fTtcblxuICAvLyBGb3IgaW5kZXggd2UganVzdCBsZXQgaXQgcGFzcyB0aHJvdWdoIGFzIGl0IGRvZXNuJ3QgaGF2ZSBhbnkgbmVjZXNzYXJ5IG1lYW5pbmcuXG4gIC8vIExlYXZpbmcgc2FuaXR5IGNoZWNrcyBvbiB0aGlzIHRvIHRoZSBBUEkgY29uc3VtZXIgdGhhdCBtYXkga25vdyBtb3JlIGFib3V0IHRoZVxuICAvLyBtZWFuaW5nIGluIHRoZWlyIG93biBjb250ZXh0LlxuICBpZiAobWluZS5pbmRleCB8fCB0aGVpcnMuaW5kZXgpIHtcbiAgICByZXQuaW5kZXggPSBtaW5lLmluZGV4IHx8IHRoZWlycy5pbmRleDtcbiAgfVxuXG4gIGlmIChtaW5lLm5ld0ZpbGVOYW1lIHx8IHRoZWlycy5uZXdGaWxlTmFtZSkge1xuICAgIGlmICghZmlsZU5hbWVDaGFuZ2VkKG1pbmUpKSB7XG4gICAgICAvLyBObyBoZWFkZXIgb3Igbm8gY2hhbmdlIGluIG91cnMsIHVzZSB0aGVpcnMgKGFuZCBvdXJzIGlmIHRoZWlycyBkb2VzIG5vdCBleGlzdClcbiAgICAgIHJldC5vbGRGaWxlTmFtZSA9IHRoZWlycy5vbGRGaWxlTmFtZSB8fCBtaW5lLm9sZEZpbGVOYW1lO1xuICAgICAgcmV0Lm5ld0ZpbGVOYW1lID0gdGhlaXJzLm5ld0ZpbGVOYW1lIHx8IG1pbmUubmV3RmlsZU5hbWU7XG4gICAgICByZXQub2xkSGVhZGVyID0gdGhlaXJzLm9sZEhlYWRlciB8fCBtaW5lLm9sZEhlYWRlcjtcbiAgICAgIHJldC5uZXdIZWFkZXIgPSB0aGVpcnMubmV3SGVhZGVyIHx8IG1pbmUubmV3SGVhZGVyO1xuICAgIH0gZWxzZSBpZiAoIWZpbGVOYW1lQ2hhbmdlZCh0aGVpcnMpKSB7XG4gICAgICAvLyBObyBoZWFkZXIgb3Igbm8gY2hhbmdlIGluIHRoZWlycywgdXNlIG91cnNcbiAgICAgIHJldC5vbGRGaWxlTmFtZSA9IG1pbmUub2xkRmlsZU5hbWU7XG4gICAgICByZXQubmV3RmlsZU5hbWUgPSBtaW5lLm5ld0ZpbGVOYW1lO1xuICAgICAgcmV0Lm9sZEhlYWRlciA9IG1pbmUub2xkSGVhZGVyO1xuICAgICAgcmV0Lm5ld0hlYWRlciA9IG1pbmUubmV3SGVhZGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCb3RoIGNoYW5nZWQuLi4gZmlndXJlIGl0IG91dFxuICAgICAgcmV0Lm9sZEZpbGVOYW1lID0gc2VsZWN0RmllbGQocmV0LCBtaW5lLm9sZEZpbGVOYW1lLCB0aGVpcnMub2xkRmlsZU5hbWUpO1xuICAgICAgcmV0Lm5ld0ZpbGVOYW1lID0gc2VsZWN0RmllbGQocmV0LCBtaW5lLm5ld0ZpbGVOYW1lLCB0aGVpcnMubmV3RmlsZU5hbWUpO1xuICAgICAgcmV0Lm9sZEhlYWRlciA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5vbGRIZWFkZXIsIHRoZWlycy5vbGRIZWFkZXIpO1xuICAgICAgcmV0Lm5ld0hlYWRlciA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5uZXdIZWFkZXIsIHRoZWlycy5uZXdIZWFkZXIpO1xuICAgIH1cbiAgfVxuXG4gIHJldC5odW5rcyA9IFtdO1xuXG4gIGxldCBtaW5lSW5kZXggPSAwLFxuICAgICAgdGhlaXJzSW5kZXggPSAwLFxuICAgICAgbWluZU9mZnNldCA9IDAsXG4gICAgICB0aGVpcnNPZmZzZXQgPSAwO1xuXG4gIHdoaWxlIChtaW5lSW5kZXggPCBtaW5lLmh1bmtzLmxlbmd0aCB8fCB0aGVpcnNJbmRleCA8IHRoZWlycy5odW5rcy5sZW5ndGgpIHtcbiAgICBsZXQgbWluZUN1cnJlbnQgPSBtaW5lLmh1bmtzW21pbmVJbmRleF0gfHwge29sZFN0YXJ0OiBJbmZpbml0eX0sXG4gICAgICAgIHRoZWlyc0N1cnJlbnQgPSB0aGVpcnMuaHVua3NbdGhlaXJzSW5kZXhdIHx8IHtvbGRTdGFydDogSW5maW5pdHl9O1xuXG4gICAgaWYgKGh1bmtCZWZvcmUobWluZUN1cnJlbnQsIHRoZWlyc0N1cnJlbnQpKSB7XG4gICAgICAvLyBUaGlzIHBhdGNoIGRvZXMgbm90IG92ZXJsYXAgd2l0aCBhbnkgb2YgdGhlIG90aGVycywgeWF5LlxuICAgICAgcmV0Lmh1bmtzLnB1c2goY2xvbmVIdW5rKG1pbmVDdXJyZW50LCBtaW5lT2Zmc2V0KSk7XG4gICAgICBtaW5lSW5kZXgrKztcbiAgICAgIHRoZWlyc09mZnNldCArPSBtaW5lQ3VycmVudC5uZXdMaW5lcyAtIG1pbmVDdXJyZW50Lm9sZExpbmVzO1xuICAgIH0gZWxzZSBpZiAoaHVua0JlZm9yZSh0aGVpcnNDdXJyZW50LCBtaW5lQ3VycmVudCkpIHtcbiAgICAgIC8vIFRoaXMgcGF0Y2ggZG9lcyBub3Qgb3ZlcmxhcCB3aXRoIGFueSBvZiB0aGUgb3RoZXJzLCB5YXkuXG4gICAgICByZXQuaHVua3MucHVzaChjbG9uZUh1bmsodGhlaXJzQ3VycmVudCwgdGhlaXJzT2Zmc2V0KSk7XG4gICAgICB0aGVpcnNJbmRleCsrO1xuICAgICAgbWluZU9mZnNldCArPSB0aGVpcnNDdXJyZW50Lm5ld0xpbmVzIC0gdGhlaXJzQ3VycmVudC5vbGRMaW5lcztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3ZlcmxhcCwgbWVyZ2UgYXMgYmVzdCB3ZSBjYW5cbiAgICAgIGxldCBtZXJnZWRIdW5rID0ge1xuICAgICAgICBvbGRTdGFydDogTWF0aC5taW4obWluZUN1cnJlbnQub2xkU3RhcnQsIHRoZWlyc0N1cnJlbnQub2xkU3RhcnQpLFxuICAgICAgICBvbGRMaW5lczogMCxcbiAgICAgICAgbmV3U3RhcnQ6IE1hdGgubWluKG1pbmVDdXJyZW50Lm5ld1N0YXJ0ICsgbWluZU9mZnNldCwgdGhlaXJzQ3VycmVudC5vbGRTdGFydCArIHRoZWlyc09mZnNldCksXG4gICAgICAgIG5ld0xpbmVzOiAwLFxuICAgICAgICBsaW5lczogW11cbiAgICAgIH07XG4gICAgICBtZXJnZUxpbmVzKG1lcmdlZEh1bmssIG1pbmVDdXJyZW50Lm9sZFN0YXJ0LCBtaW5lQ3VycmVudC5saW5lcywgdGhlaXJzQ3VycmVudC5vbGRTdGFydCwgdGhlaXJzQ3VycmVudC5saW5lcyk7XG4gICAgICB0aGVpcnNJbmRleCsrO1xuICAgICAgbWluZUluZGV4Kys7XG5cbiAgICAgIHJldC5odW5rcy5wdXNoKG1lcmdlZEh1bmspO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGxvYWRQYXRjaChwYXJhbSwgYmFzZSkge1xuICBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJykge1xuICAgIGlmICgoL15AQC9tKS50ZXN0KHBhcmFtKSB8fCAoKC9eSW5kZXg6L20pLnRlc3QocGFyYW0pKSkge1xuICAgICAgcmV0dXJuIHBhcnNlUGF0Y2gocGFyYW0pWzBdO1xuICAgIH1cblxuICAgIGlmICghYmFzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgYSBiYXNlIHJlZmVyZW5jZSBvciBwYXNzIGluIGEgcGF0Y2gnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cnVjdHVyZWRQYXRjaCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgYmFzZSwgcGFyYW0pO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtO1xufVxuXG5mdW5jdGlvbiBmaWxlTmFtZUNoYW5nZWQocGF0Y2gpIHtcbiAgcmV0dXJuIHBhdGNoLm5ld0ZpbGVOYW1lICYmIHBhdGNoLm5ld0ZpbGVOYW1lICE9PSBwYXRjaC5vbGRGaWxlTmFtZTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0RmllbGQoaW5kZXgsIG1pbmUsIHRoZWlycykge1xuICBpZiAobWluZSA9PT0gdGhlaXJzKSB7XG4gICAgcmV0dXJuIG1pbmU7XG4gIH0gZWxzZSB7XG4gICAgaW5kZXguY29uZmxpY3QgPSB0cnVlO1xuICAgIHJldHVybiB7bWluZSwgdGhlaXJzfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBodW5rQmVmb3JlKHRlc3QsIGNoZWNrKSB7XG4gIHJldHVybiB0ZXN0Lm9sZFN0YXJ0IDwgY2hlY2sub2xkU3RhcnRcbiAgICAmJiAodGVzdC5vbGRTdGFydCArIHRlc3Qub2xkTGluZXMpIDwgY2hlY2sub2xkU3RhcnQ7XG59XG5cbmZ1bmN0aW9uIGNsb25lSHVuayhodW5rLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHtcbiAgICBvbGRTdGFydDogaHVuay5vbGRTdGFydCwgb2xkTGluZXM6IGh1bmsub2xkTGluZXMsXG4gICAgbmV3U3RhcnQ6IGh1bmsubmV3U3RhcnQgKyBvZmZzZXQsIG5ld0xpbmVzOiBodW5rLm5ld0xpbmVzLFxuICAgIGxpbmVzOiBodW5rLmxpbmVzXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1lcmdlTGluZXMoaHVuaywgbWluZU9mZnNldCwgbWluZUxpbmVzLCB0aGVpck9mZnNldCwgdGhlaXJMaW5lcykge1xuICAvLyBUaGlzIHdpbGwgZ2VuZXJhbGx5IHJlc3VsdCBpbiBhIGNvbmZsaWN0ZWQgaHVuaywgYnV0IHRoZXJlIGFyZSBjYXNlcyB3aGVyZSB0aGUgY29udGV4dFxuICAvLyBpcyB0aGUgb25seSBvdmVybGFwIHdoZXJlIHdlIGNhbiBzdWNjZXNzZnVsbHkgbWVyZ2UgdGhlIGNvbnRlbnQgaGVyZS5cbiAgbGV0IG1pbmUgPSB7b2Zmc2V0OiBtaW5lT2Zmc2V0LCBsaW5lczogbWluZUxpbmVzLCBpbmRleDogMH0sXG4gICAgICB0aGVpciA9IHtvZmZzZXQ6IHRoZWlyT2Zmc2V0LCBsaW5lczogdGhlaXJMaW5lcywgaW5kZXg6IDB9O1xuXG4gIC8vIEhhbmRsZSBhbnkgbGVhZGluZyBjb250ZW50XG4gIGluc2VydExlYWRpbmcoaHVuaywgbWluZSwgdGhlaXIpO1xuICBpbnNlcnRMZWFkaW5nKGh1bmssIHRoZWlyLCBtaW5lKTtcblxuICAvLyBOb3cgaW4gdGhlIG92ZXJsYXAgY29udGVudC4gU2NhbiB0aHJvdWdoIGFuZCBzZWxlY3QgdGhlIGJlc3QgY2hhbmdlcyBmcm9tIGVhY2guXG4gIHdoaWxlIChtaW5lLmluZGV4IDwgbWluZS5saW5lcy5sZW5ndGggJiYgdGhlaXIuaW5kZXggPCB0aGVpci5saW5lcy5sZW5ndGgpIHtcbiAgICBsZXQgbWluZUN1cnJlbnQgPSBtaW5lLmxpbmVzW21pbmUuaW5kZXhdLFxuICAgICAgICB0aGVpckN1cnJlbnQgPSB0aGVpci5saW5lc1t0aGVpci5pbmRleF07XG5cbiAgICBpZiAoKG1pbmVDdXJyZW50WzBdID09PSAnLScgfHwgbWluZUN1cnJlbnRbMF0gPT09ICcrJylcbiAgICAgICAgJiYgKHRoZWlyQ3VycmVudFswXSA9PT0gJy0nIHx8IHRoZWlyQ3VycmVudFswXSA9PT0gJysnKSkge1xuICAgICAgLy8gQm90aCBtb2RpZmllZCAuLi5cbiAgICAgIG11dHVhbENoYW5nZShodW5rLCBtaW5lLCB0aGVpcik7XG4gICAgfSBlbHNlIGlmIChtaW5lQ3VycmVudFswXSA9PT0gJysnICYmIHRoZWlyQ3VycmVudFswXSA9PT0gJyAnKSB7XG4gICAgICAvLyBNaW5lIGluc2VydGVkXG4gICAgICBodW5rLmxpbmVzLnB1c2goLi4uIGNvbGxlY3RDaGFuZ2UobWluZSkpO1xuICAgIH0gZWxzZSBpZiAodGhlaXJDdXJyZW50WzBdID09PSAnKycgJiYgbWluZUN1cnJlbnRbMF0gPT09ICcgJykge1xuICAgICAgLy8gVGhlaXJzIGluc2VydGVkXG4gICAgICBodW5rLmxpbmVzLnB1c2goLi4uIGNvbGxlY3RDaGFuZ2UodGhlaXIpKTtcbiAgICB9IGVsc2UgaWYgKG1pbmVDdXJyZW50WzBdID09PSAnLScgJiYgdGhlaXJDdXJyZW50WzBdID09PSAnICcpIHtcbiAgICAgIC8vIE1pbmUgcmVtb3ZlZCBvciBlZGl0ZWRcbiAgICAgIHJlbW92YWwoaHVuaywgbWluZSwgdGhlaXIpO1xuICAgIH0gZWxzZSBpZiAodGhlaXJDdXJyZW50WzBdID09PSAnLScgJiYgbWluZUN1cnJlbnRbMF0gPT09ICcgJykge1xuICAgICAgLy8gVGhlaXIgcmVtb3ZlZCBvciBlZGl0ZWRcbiAgICAgIHJlbW92YWwoaHVuaywgdGhlaXIsIG1pbmUsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAobWluZUN1cnJlbnQgPT09IHRoZWlyQ3VycmVudCkge1xuICAgICAgLy8gQ29udGV4dCBpZGVudGl0eVxuICAgICAgaHVuay5saW5lcy5wdXNoKG1pbmVDdXJyZW50KTtcbiAgICAgIG1pbmUuaW5kZXgrKztcbiAgICAgIHRoZWlyLmluZGV4Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRleHQgbWlzbWF0Y2hcbiAgICAgIGNvbmZsaWN0KGh1bmssIGNvbGxlY3RDaGFuZ2UobWluZSksIGNvbGxlY3RDaGFuZ2UodGhlaXIpKTtcbiAgICB9XG4gIH1cblxuICAvLyBOb3cgcHVzaCBhbnl0aGluZyB0aGF0IG1heSBiZSByZW1haW5pbmdcbiAgaW5zZXJ0VHJhaWxpbmcoaHVuaywgbWluZSk7XG4gIGluc2VydFRyYWlsaW5nKGh1bmssIHRoZWlyKTtcblxuICBjYWxjTGluZUNvdW50KGh1bmspO1xufVxuXG5mdW5jdGlvbiBtdXR1YWxDaGFuZ2UoaHVuaywgbWluZSwgdGhlaXIpIHtcbiAgbGV0IG15Q2hhbmdlcyA9IGNvbGxlY3RDaGFuZ2UobWluZSksXG4gICAgICB0aGVpckNoYW5nZXMgPSBjb2xsZWN0Q2hhbmdlKHRoZWlyKTtcblxuICBpZiAoYWxsUmVtb3ZlcyhteUNoYW5nZXMpICYmIGFsbFJlbW92ZXModGhlaXJDaGFuZ2VzKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgcmVtb3ZlIGNoYW5nZXMgdGhhdCBhcmUgc3VwZXJzZXRzIG9mIG9uZSBhbm90aGVyXG4gICAgaWYgKGFycmF5U3RhcnRzV2l0aChteUNoYW5nZXMsIHRoZWlyQ2hhbmdlcylcbiAgICAgICAgJiYgc2tpcFJlbW92ZVN1cGVyc2V0KHRoZWlyLCBteUNoYW5nZXMsIG15Q2hhbmdlcy5sZW5ndGggLSB0aGVpckNoYW5nZXMubGVuZ3RoKSkge1xuICAgICAgaHVuay5saW5lcy5wdXNoKC4uLiBteUNoYW5nZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoYXJyYXlTdGFydHNXaXRoKHRoZWlyQ2hhbmdlcywgbXlDaGFuZ2VzKVxuICAgICAgICAmJiBza2lwUmVtb3ZlU3VwZXJzZXQobWluZSwgdGhlaXJDaGFuZ2VzLCB0aGVpckNoYW5nZXMubGVuZ3RoIC0gbXlDaGFuZ2VzLmxlbmd0aCkpIHtcbiAgICAgIGh1bmsubGluZXMucHVzaCguLi4gdGhlaXJDaGFuZ2VzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJyYXlFcXVhbChteUNoYW5nZXMsIHRoZWlyQ2hhbmdlcykpIHtcbiAgICBodW5rLmxpbmVzLnB1c2goLi4uIG15Q2hhbmdlcyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uZmxpY3QoaHVuaywgbXlDaGFuZ2VzLCB0aGVpckNoYW5nZXMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmFsKGh1bmssIG1pbmUsIHRoZWlyLCBzd2FwKSB7XG4gIGxldCBteUNoYW5nZXMgPSBjb2xsZWN0Q2hhbmdlKG1pbmUpLFxuICAgICAgdGhlaXJDaGFuZ2VzID0gY29sbGVjdENvbnRleHQodGhlaXIsIG15Q2hhbmdlcyk7XG4gIGlmICh0aGVpckNoYW5nZXMubWVyZ2VkKSB7XG4gICAgaHVuay5saW5lcy5wdXNoKC4uLiB0aGVpckNoYW5nZXMubWVyZ2VkKTtcbiAgfSBlbHNlIHtcbiAgICBjb25mbGljdChodW5rLCBzd2FwID8gdGhlaXJDaGFuZ2VzIDogbXlDaGFuZ2VzLCBzd2FwID8gbXlDaGFuZ2VzIDogdGhlaXJDaGFuZ2VzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb25mbGljdChodW5rLCBtaW5lLCB0aGVpcikge1xuICBodW5rLmNvbmZsaWN0ID0gdHJ1ZTtcbiAgaHVuay5saW5lcy5wdXNoKHtcbiAgICBjb25mbGljdDogdHJ1ZSxcbiAgICBtaW5lOiBtaW5lLFxuICAgIHRoZWlyczogdGhlaXJcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluc2VydExlYWRpbmcoaHVuaywgaW5zZXJ0LCB0aGVpcikge1xuICB3aGlsZSAoaW5zZXJ0Lm9mZnNldCA8IHRoZWlyLm9mZnNldCAmJiBpbnNlcnQuaW5kZXggPCBpbnNlcnQubGluZXMubGVuZ3RoKSB7XG4gICAgbGV0IGxpbmUgPSBpbnNlcnQubGluZXNbaW5zZXJ0LmluZGV4KytdO1xuICAgIGh1bmsubGluZXMucHVzaChsaW5lKTtcbiAgICBpbnNlcnQub2Zmc2V0Kys7XG4gIH1cbn1cbmZ1bmN0aW9uIGluc2VydFRyYWlsaW5nKGh1bmssIGluc2VydCkge1xuICB3aGlsZSAoaW5zZXJ0LmluZGV4IDwgaW5zZXJ0LmxpbmVzLmxlbmd0aCkge1xuICAgIGxldCBsaW5lID0gaW5zZXJ0LmxpbmVzW2luc2VydC5pbmRleCsrXTtcbiAgICBodW5rLmxpbmVzLnB1c2gobGluZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29sbGVjdENoYW5nZShzdGF0ZSkge1xuICBsZXQgcmV0ID0gW10sXG4gICAgICBvcGVyYXRpb24gPSBzdGF0ZS5saW5lc1tzdGF0ZS5pbmRleF1bMF07XG4gIHdoaWxlIChzdGF0ZS5pbmRleCA8IHN0YXRlLmxpbmVzLmxlbmd0aCkge1xuICAgIGxldCBsaW5lID0gc3RhdGUubGluZXNbc3RhdGUuaW5kZXhdO1xuXG4gICAgLy8gR3JvdXAgYWRkaXRpb25zIHRoYXQgYXJlIGltbWVkaWF0ZWx5IGFmdGVyIHN1YnRyYWN0aW9ucyBhbmQgdHJlYXQgdGhlbSBhcyBvbmUgXCJhdG9taWNcIiBtb2RpZnkgY2hhbmdlLlxuICAgIGlmIChvcGVyYXRpb24gPT09ICctJyAmJiBsaW5lWzBdID09PSAnKycpIHtcbiAgICAgIG9wZXJhdGlvbiA9ICcrJztcbiAgICB9XG5cbiAgICBpZiAob3BlcmF0aW9uID09PSBsaW5lWzBdKSB7XG4gICAgICByZXQucHVzaChsaW5lKTtcbiAgICAgIHN0YXRlLmluZGV4Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBjb2xsZWN0Q29udGV4dChzdGF0ZSwgbWF0Y2hDaGFuZ2VzKSB7XG4gIGxldCBjaGFuZ2VzID0gW10sXG4gICAgICBtZXJnZWQgPSBbXSxcbiAgICAgIG1hdGNoSW5kZXggPSAwLFxuICAgICAgY29udGV4dENoYW5nZXMgPSBmYWxzZSxcbiAgICAgIGNvbmZsaWN0ZWQgPSBmYWxzZTtcbiAgd2hpbGUgKG1hdGNoSW5kZXggPCBtYXRjaENoYW5nZXMubGVuZ3RoXG4gICAgICAgICYmIHN0YXRlLmluZGV4IDwgc3RhdGUubGluZXMubGVuZ3RoKSB7XG4gICAgbGV0IGNoYW5nZSA9IHN0YXRlLmxpbmVzW3N0YXRlLmluZGV4XSxcbiAgICAgICAgbWF0Y2ggPSBtYXRjaENoYW5nZXNbbWF0Y2hJbmRleF07XG5cbiAgICAvLyBPbmNlIHdlJ3ZlIGhpdCBvdXIgYWRkLCB0aGVuIHdlIGFyZSBkb25lXG4gICAgaWYgKG1hdGNoWzBdID09PSAnKycpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNvbnRleHRDaGFuZ2VzID0gY29udGV4dENoYW5nZXMgfHwgY2hhbmdlWzBdICE9PSAnICc7XG5cbiAgICBtZXJnZWQucHVzaChtYXRjaCk7XG4gICAgbWF0Y2hJbmRleCsrO1xuXG4gICAgLy8gQ29uc3VtZSBhbnkgYWRkaXRpb25zIGluIHRoZSBvdGhlciBibG9jayBhcyBhIGNvbmZsaWN0IHRvIGF0dGVtcHRcbiAgICAvLyB0byBwdWxsIGluIHRoZSByZW1haW5pbmcgY29udGV4dCBhZnRlciB0aGlzXG4gICAgaWYgKGNoYW5nZVswXSA9PT0gJysnKSB7XG4gICAgICBjb25mbGljdGVkID0gdHJ1ZTtcblxuICAgICAgd2hpbGUgKGNoYW5nZVswXSA9PT0gJysnKSB7XG4gICAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICBjaGFuZ2UgPSBzdGF0ZS5saW5lc1srK3N0YXRlLmluZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF0Y2guc3Vic3RyKDEpID09PSBjaGFuZ2Uuc3Vic3RyKDEpKSB7XG4gICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgIHN0YXRlLmluZGV4Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZsaWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICgobWF0Y2hDaGFuZ2VzW21hdGNoSW5kZXhdIHx8ICcnKVswXSA9PT0gJysnXG4gICAgICAmJiBjb250ZXh0Q2hhbmdlcykge1xuICAgIGNvbmZsaWN0ZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKGNvbmZsaWN0ZWQpIHtcbiAgICByZXR1cm4gY2hhbmdlcztcbiAgfVxuXG4gIHdoaWxlIChtYXRjaEluZGV4IDwgbWF0Y2hDaGFuZ2VzLmxlbmd0aCkge1xuICAgIG1lcmdlZC5wdXNoKG1hdGNoQ2hhbmdlc1ttYXRjaEluZGV4KytdKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWVyZ2VkLFxuICAgIGNoYW5nZXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWxsUmVtb3ZlcyhjaGFuZ2VzKSB7XG4gIHJldHVybiBjaGFuZ2VzLnJlZHVjZShmdW5jdGlvbihwcmV2LCBjaGFuZ2UpIHtcbiAgICByZXR1cm4gcHJldiAmJiBjaGFuZ2VbMF0gPT09ICctJztcbiAgfSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBza2lwUmVtb3ZlU3VwZXJzZXQoc3RhdGUsIHJlbW92ZUNoYW5nZXMsIGRlbHRhKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsdGE7IGkrKykge1xuICAgIGxldCBjaGFuZ2VDb250ZW50ID0gcmVtb3ZlQ2hhbmdlc1tyZW1vdmVDaGFuZ2VzLmxlbmd0aCAtIGRlbHRhICsgaV0uc3Vic3RyKDEpO1xuICAgIGlmIChzdGF0ZS5saW5lc1tzdGF0ZS5pbmRleCArIGldICE9PSAnICcgKyBjaGFuZ2VDb250ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuaW5kZXggKz0gZGVsdGE7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjYWxjT2xkTmV3TGluZUNvdW50KGxpbmVzKSB7XG4gIGxldCBvbGRMaW5lcyA9IDA7XG4gIGxldCBuZXdMaW5lcyA9IDA7XG5cbiAgbGluZXMuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgaWYgKHR5cGVvZiBsaW5lICE9PSAnc3RyaW5nJykge1xuICAgICAgbGV0IG15Q291bnQgPSBjYWxjT2xkTmV3TGluZUNvdW50KGxpbmUubWluZSk7XG4gICAgICBsZXQgdGhlaXJDb3VudCA9IGNhbGNPbGROZXdMaW5lQ291bnQobGluZS50aGVpcnMpO1xuXG4gICAgICBpZiAob2xkTGluZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobXlDb3VudC5vbGRMaW5lcyA9PT0gdGhlaXJDb3VudC5vbGRMaW5lcykge1xuICAgICAgICAgIG9sZExpbmVzICs9IG15Q291bnQub2xkTGluZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2xkTGluZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0xpbmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG15Q291bnQubmV3TGluZXMgPT09IHRoZWlyQ291bnQubmV3TGluZXMpIHtcbiAgICAgICAgICBuZXdMaW5lcyArPSBteUNvdW50Lm5ld0xpbmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0xpbmVzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXdMaW5lcyAhPT0gdW5kZWZpbmVkICYmIChsaW5lWzBdID09PSAnKycgfHwgbGluZVswXSA9PT0gJyAnKSkge1xuICAgICAgICBuZXdMaW5lcysrO1xuICAgICAgfVxuICAgICAgaWYgKG9sZExpbmVzICE9PSB1bmRlZmluZWQgJiYgKGxpbmVbMF0gPT09ICctJyB8fCBsaW5lWzBdID09PSAnICcpKSB7XG4gICAgICAgIG9sZExpbmVzKys7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge29sZExpbmVzLCBuZXdMaW5lc307XG59XG4iXX0=\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL3BhdGNoL21lcmdlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscUJBQXFCO0FBQ3JCLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLGtGQUFVO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsbUJBQU8sQ0FBQyxnRkFBUztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLG1CQUFPLENBQUMscUZBQWU7QUFDaEM7QUFDQTs7QUFFQSw2REFBNkQ7O0FBRTdELGdDQUFnQzs7QUFFaEMsa0RBQWtELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Q7O0FBRTdTLGtDQUFrQzs7QUFFbEMsbUNBQW1DOztBQUVuQyx1Q0FBdUMsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sb0JBQW9COztBQUV6SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9ub2RlX21vZHVsZXMvZGlmZi9saWIvcGF0Y2gvbWVyZ2UuanM/OWE5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY2FsY0xpbmVDb3VudCA9IGNhbGNMaW5lQ291bnQ7XG5leHBvcnRzLm1lcmdlID0gbWVyZ2U7XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG52YXJcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9jcmVhdGUgPSByZXF1aXJlKFwiLi9jcmVhdGVcIilcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX3BhcnNlID0gcmVxdWlyZShcIi4vcGFyc2VcIilcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2FycmF5ID0gcmVxdWlyZShcIi4uL3V0aWwvYXJyYXlcIilcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuZnVuY3Rpb24gY2FsY0xpbmVDb3VudChodW5rKSB7XG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgdmFyIF9jYWxjT2xkTmV3TGluZUNvdW50ID1cbiAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgY2FsY09sZE5ld0xpbmVDb3VudChodW5rLmxpbmVzKSxcbiAgICAgIG9sZExpbmVzID0gX2NhbGNPbGROZXdMaW5lQ291bnQub2xkTGluZXMsXG4gICAgICBuZXdMaW5lcyA9IF9jYWxjT2xkTmV3TGluZUNvdW50Lm5ld0xpbmVzO1xuXG4gIGlmIChvbGRMaW5lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaHVuay5vbGRMaW5lcyA9IG9sZExpbmVzO1xuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBodW5rLm9sZExpbmVzO1xuICB9XG5cbiAgaWYgKG5ld0xpbmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBodW5rLm5ld0xpbmVzID0gbmV3TGluZXM7XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIGh1bmsubmV3TGluZXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2UobWluZSwgdGhlaXJzLCBiYXNlKSB7XG4gIG1pbmUgPSBsb2FkUGF0Y2gobWluZSwgYmFzZSk7XG4gIHRoZWlycyA9IGxvYWRQYXRjaCh0aGVpcnMsIGJhc2UpO1xuICB2YXIgcmV0ID0ge307IC8vIEZvciBpbmRleCB3ZSBqdXN0IGxldCBpdCBwYXNzIHRocm91Z2ggYXMgaXQgZG9lc24ndCBoYXZlIGFueSBuZWNlc3NhcnkgbWVhbmluZy5cbiAgLy8gTGVhdmluZyBzYW5pdHkgY2hlY2tzIG9uIHRoaXMgdG8gdGhlIEFQSSBjb25zdW1lciB0aGF0IG1heSBrbm93IG1vcmUgYWJvdXQgdGhlXG4gIC8vIG1lYW5pbmcgaW4gdGhlaXIgb3duIGNvbnRleHQuXG5cbiAgaWYgKG1pbmUuaW5kZXggfHwgdGhlaXJzLmluZGV4KSB7XG4gICAgcmV0LmluZGV4ID0gbWluZS5pbmRleCB8fCB0aGVpcnMuaW5kZXg7XG4gIH1cblxuICBpZiAobWluZS5uZXdGaWxlTmFtZSB8fCB0aGVpcnMubmV3RmlsZU5hbWUpIHtcbiAgICBpZiAoIWZpbGVOYW1lQ2hhbmdlZChtaW5lKSkge1xuICAgICAgLy8gTm8gaGVhZGVyIG9yIG5vIGNoYW5nZSBpbiBvdXJzLCB1c2UgdGhlaXJzIChhbmQgb3VycyBpZiB0aGVpcnMgZG9lcyBub3QgZXhpc3QpXG4gICAgICByZXQub2xkRmlsZU5hbWUgPSB0aGVpcnMub2xkRmlsZU5hbWUgfHwgbWluZS5vbGRGaWxlTmFtZTtcbiAgICAgIHJldC5uZXdGaWxlTmFtZSA9IHRoZWlycy5uZXdGaWxlTmFtZSB8fCBtaW5lLm5ld0ZpbGVOYW1lO1xuICAgICAgcmV0Lm9sZEhlYWRlciA9IHRoZWlycy5vbGRIZWFkZXIgfHwgbWluZS5vbGRIZWFkZXI7XG4gICAgICByZXQubmV3SGVhZGVyID0gdGhlaXJzLm5ld0hlYWRlciB8fCBtaW5lLm5ld0hlYWRlcjtcbiAgICB9IGVsc2UgaWYgKCFmaWxlTmFtZUNoYW5nZWQodGhlaXJzKSkge1xuICAgICAgLy8gTm8gaGVhZGVyIG9yIG5vIGNoYW5nZSBpbiB0aGVpcnMsIHVzZSBvdXJzXG4gICAgICByZXQub2xkRmlsZU5hbWUgPSBtaW5lLm9sZEZpbGVOYW1lO1xuICAgICAgcmV0Lm5ld0ZpbGVOYW1lID0gbWluZS5uZXdGaWxlTmFtZTtcbiAgICAgIHJldC5vbGRIZWFkZXIgPSBtaW5lLm9sZEhlYWRlcjtcbiAgICAgIHJldC5uZXdIZWFkZXIgPSBtaW5lLm5ld0hlYWRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQm90aCBjaGFuZ2VkLi4uIGZpZ3VyZSBpdCBvdXRcbiAgICAgIHJldC5vbGRGaWxlTmFtZSA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5vbGRGaWxlTmFtZSwgdGhlaXJzLm9sZEZpbGVOYW1lKTtcbiAgICAgIHJldC5uZXdGaWxlTmFtZSA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5uZXdGaWxlTmFtZSwgdGhlaXJzLm5ld0ZpbGVOYW1lKTtcbiAgICAgIHJldC5vbGRIZWFkZXIgPSBzZWxlY3RGaWVsZChyZXQsIG1pbmUub2xkSGVhZGVyLCB0aGVpcnMub2xkSGVhZGVyKTtcbiAgICAgIHJldC5uZXdIZWFkZXIgPSBzZWxlY3RGaWVsZChyZXQsIG1pbmUubmV3SGVhZGVyLCB0aGVpcnMubmV3SGVhZGVyKTtcbiAgICB9XG4gIH1cblxuICByZXQuaHVua3MgPSBbXTtcbiAgdmFyIG1pbmVJbmRleCA9IDAsXG4gICAgICB0aGVpcnNJbmRleCA9IDAsXG4gICAgICBtaW5lT2Zmc2V0ID0gMCxcbiAgICAgIHRoZWlyc09mZnNldCA9IDA7XG5cbiAgd2hpbGUgKG1pbmVJbmRleCA8IG1pbmUuaHVua3MubGVuZ3RoIHx8IHRoZWlyc0luZGV4IDwgdGhlaXJzLmh1bmtzLmxlbmd0aCkge1xuICAgIHZhciBtaW5lQ3VycmVudCA9IG1pbmUuaHVua3NbbWluZUluZGV4XSB8fCB7XG4gICAgICBvbGRTdGFydDogSW5maW5pdHlcbiAgICB9LFxuICAgICAgICB0aGVpcnNDdXJyZW50ID0gdGhlaXJzLmh1bmtzW3RoZWlyc0luZGV4XSB8fCB7XG4gICAgICBvbGRTdGFydDogSW5maW5pdHlcbiAgICB9O1xuXG4gICAgaWYgKGh1bmtCZWZvcmUobWluZUN1cnJlbnQsIHRoZWlyc0N1cnJlbnQpKSB7XG4gICAgICAvLyBUaGlzIHBhdGNoIGRvZXMgbm90IG92ZXJsYXAgd2l0aCBhbnkgb2YgdGhlIG90aGVycywgeWF5LlxuICAgICAgcmV0Lmh1bmtzLnB1c2goY2xvbmVIdW5rKG1pbmVDdXJyZW50LCBtaW5lT2Zmc2V0KSk7XG4gICAgICBtaW5lSW5kZXgrKztcbiAgICAgIHRoZWlyc09mZnNldCArPSBtaW5lQ3VycmVudC5uZXdMaW5lcyAtIG1pbmVDdXJyZW50Lm9sZExpbmVzO1xuICAgIH0gZWxzZSBpZiAoaHVua0JlZm9yZSh0aGVpcnNDdXJyZW50LCBtaW5lQ3VycmVudCkpIHtcbiAgICAgIC8vIFRoaXMgcGF0Y2ggZG9lcyBub3Qgb3ZlcmxhcCB3aXRoIGFueSBvZiB0aGUgb3RoZXJzLCB5YXkuXG4gICAgICByZXQuaHVua3MucHVzaChjbG9uZUh1bmsodGhlaXJzQ3VycmVudCwgdGhlaXJzT2Zmc2V0KSk7XG4gICAgICB0aGVpcnNJbmRleCsrO1xuICAgICAgbWluZU9mZnNldCArPSB0aGVpcnNDdXJyZW50Lm5ld0xpbmVzIC0gdGhlaXJzQ3VycmVudC5vbGRMaW5lcztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3ZlcmxhcCwgbWVyZ2UgYXMgYmVzdCB3ZSBjYW5cbiAgICAgIHZhciBtZXJnZWRIdW5rID0ge1xuICAgICAgICBvbGRTdGFydDogTWF0aC5taW4obWluZUN1cnJlbnQub2xkU3RhcnQsIHRoZWlyc0N1cnJlbnQub2xkU3RhcnQpLFxuICAgICAgICBvbGRMaW5lczogMCxcbiAgICAgICAgbmV3U3RhcnQ6IE1hdGgubWluKG1pbmVDdXJyZW50Lm5ld1N0YXJ0ICsgbWluZU9mZnNldCwgdGhlaXJzQ3VycmVudC5vbGRTdGFydCArIHRoZWlyc09mZnNldCksXG4gICAgICAgIG5ld0xpbmVzOiAwLFxuICAgICAgICBsaW5lczogW11cbiAgICAgIH07XG4gICAgICBtZXJnZUxpbmVzKG1lcmdlZEh1bmssIG1pbmVDdXJyZW50Lm9sZFN0YXJ0LCBtaW5lQ3VycmVudC5saW5lcywgdGhlaXJzQ3VycmVudC5vbGRTdGFydCwgdGhlaXJzQ3VycmVudC5saW5lcyk7XG4gICAgICB0aGVpcnNJbmRleCsrO1xuICAgICAgbWluZUluZGV4Kys7XG4gICAgICByZXQuaHVua3MucHVzaChtZXJnZWRIdW5rKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBsb2FkUGF0Y2gocGFyYW0sIGJhc2UpIHtcbiAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoL15AQC9tLnRlc3QocGFyYW0pIHx8IC9eSW5kZXg6L20udGVzdChwYXJhbSkpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgICAgKDAsXG4gICAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5cbiAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICAgICBfcGFyc2VcbiAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAgICAgLlxuICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICAgIHBhcnNlUGF0Y2gpXG4gICAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICAgIChwYXJhbSlbMF1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFiYXNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhIGJhc2UgcmVmZXJlbmNlIG9yIHBhc3MgaW4gYSBwYXRjaCcpO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICAoMCxcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5cbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgIF9jcmVhdGVcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICAuXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICBzdHJ1Y3R1cmVkUGF0Y2gpXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICAgKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBiYXNlLCBwYXJhbSlcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtO1xufVxuXG5mdW5jdGlvbiBmaWxlTmFtZUNoYW5nZWQocGF0Y2gpIHtcbiAgcmV0dXJuIHBhdGNoLm5ld0ZpbGVOYW1lICYmIHBhdGNoLm5ld0ZpbGVOYW1lICE9PSBwYXRjaC5vbGRGaWxlTmFtZTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0RmllbGQoaW5kZXgsIG1pbmUsIHRoZWlycykge1xuICBpZiAobWluZSA9PT0gdGhlaXJzKSB7XG4gICAgcmV0dXJuIG1pbmU7XG4gIH0gZWxzZSB7XG4gICAgaW5kZXguY29uZmxpY3QgPSB0cnVlO1xuICAgIHJldHVybiB7XG4gICAgICBtaW5lOiBtaW5lLFxuICAgICAgdGhlaXJzOiB0aGVpcnNcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGh1bmtCZWZvcmUodGVzdCwgY2hlY2spIHtcbiAgcmV0dXJuIHRlc3Qub2xkU3RhcnQgPCBjaGVjay5vbGRTdGFydCAmJiB0ZXN0Lm9sZFN0YXJ0ICsgdGVzdC5vbGRMaW5lcyA8IGNoZWNrLm9sZFN0YXJ0O1xufVxuXG5mdW5jdGlvbiBjbG9uZUh1bmsoaHVuaywgb2Zmc2V0KSB7XG4gIHJldHVybiB7XG4gICAgb2xkU3RhcnQ6IGh1bmsub2xkU3RhcnQsXG4gICAgb2xkTGluZXM6IGh1bmsub2xkTGluZXMsXG4gICAgbmV3U3RhcnQ6IGh1bmsubmV3U3RhcnQgKyBvZmZzZXQsXG4gICAgbmV3TGluZXM6IGh1bmsubmV3TGluZXMsXG4gICAgbGluZXM6IGh1bmsubGluZXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VMaW5lcyhodW5rLCBtaW5lT2Zmc2V0LCBtaW5lTGluZXMsIHRoZWlyT2Zmc2V0LCB0aGVpckxpbmVzKSB7XG4gIC8vIFRoaXMgd2lsbCBnZW5lcmFsbHkgcmVzdWx0IGluIGEgY29uZmxpY3RlZCBodW5rLCBidXQgdGhlcmUgYXJlIGNhc2VzIHdoZXJlIHRoZSBjb250ZXh0XG4gIC8vIGlzIHRoZSBvbmx5IG92ZXJsYXAgd2hlcmUgd2UgY2FuIHN1Y2Nlc3NmdWxseSBtZXJnZSB0aGUgY29udGVudCBoZXJlLlxuICB2YXIgbWluZSA9IHtcbiAgICBvZmZzZXQ6IG1pbmVPZmZzZXQsXG4gICAgbGluZXM6IG1pbmVMaW5lcyxcbiAgICBpbmRleDogMFxuICB9LFxuICAgICAgdGhlaXIgPSB7XG4gICAgb2Zmc2V0OiB0aGVpck9mZnNldCxcbiAgICBsaW5lczogdGhlaXJMaW5lcyxcbiAgICBpbmRleDogMFxuICB9OyAvLyBIYW5kbGUgYW55IGxlYWRpbmcgY29udGVudFxuXG4gIGluc2VydExlYWRpbmcoaHVuaywgbWluZSwgdGhlaXIpO1xuICBpbnNlcnRMZWFkaW5nKGh1bmssIHRoZWlyLCBtaW5lKTsgLy8gTm93IGluIHRoZSBvdmVybGFwIGNvbnRlbnQuIFNjYW4gdGhyb3VnaCBhbmQgc2VsZWN0IHRoZSBiZXN0IGNoYW5nZXMgZnJvbSBlYWNoLlxuXG4gIHdoaWxlIChtaW5lLmluZGV4IDwgbWluZS5saW5lcy5sZW5ndGggJiYgdGhlaXIuaW5kZXggPCB0aGVpci5saW5lcy5sZW5ndGgpIHtcbiAgICB2YXIgbWluZUN1cnJlbnQgPSBtaW5lLmxpbmVzW21pbmUuaW5kZXhdLFxuICAgICAgICB0aGVpckN1cnJlbnQgPSB0aGVpci5saW5lc1t0aGVpci5pbmRleF07XG5cbiAgICBpZiAoKG1pbmVDdXJyZW50WzBdID09PSAnLScgfHwgbWluZUN1cnJlbnRbMF0gPT09ICcrJykgJiYgKHRoZWlyQ3VycmVudFswXSA9PT0gJy0nIHx8IHRoZWlyQ3VycmVudFswXSA9PT0gJysnKSkge1xuICAgICAgLy8gQm90aCBtb2RpZmllZCAuLi5cbiAgICAgIG11dHVhbENoYW5nZShodW5rLCBtaW5lLCB0aGVpcik7XG4gICAgfSBlbHNlIGlmIChtaW5lQ3VycmVudFswXSA9PT0gJysnICYmIHRoZWlyQ3VycmVudFswXSA9PT0gJyAnKSB7XG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICB2YXIgX2h1bmskbGluZXM7XG5cbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICAvLyBNaW5lIGluc2VydGVkXG5cbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cblxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICAgKF9odW5rJGxpbmVzID1cbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICBodW5rLmxpbmVzKS5wdXNoLmFwcGx5KFxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICAgX2h1bmskbGluZXNcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICAsXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICBfdG9Db25zdW1hYmxlQXJyYXkoXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICAgY29sbGVjdENoYW5nZShtaW5lKSkpO1xuICAgIH0gZWxzZSBpZiAodGhlaXJDdXJyZW50WzBdID09PSAnKycgJiYgbWluZUN1cnJlbnRbMF0gPT09ICcgJykge1xuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICAgdmFyIF9odW5rJGxpbmVzMjtcblxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAgIC8vIFRoZWlycyBpbnNlcnRlZFxuXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5cbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgIChfaHVuayRsaW5lczIgPVxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAgIGh1bmsubGluZXMpLnB1c2guYXBwbHkoXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICBfaHVuayRsaW5lczJcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICAsXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICBfdG9Db25zdW1hYmxlQXJyYXkoXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICAgY29sbGVjdENoYW5nZSh0aGVpcikpKTtcbiAgICB9IGVsc2UgaWYgKG1pbmVDdXJyZW50WzBdID09PSAnLScgJiYgdGhlaXJDdXJyZW50WzBdID09PSAnICcpIHtcbiAgICAgIC8vIE1pbmUgcmVtb3ZlZCBvciBlZGl0ZWRcbiAgICAgIHJlbW92YWwoaHVuaywgbWluZSwgdGhlaXIpO1xuICAgIH0gZWxzZSBpZiAodGhlaXJDdXJyZW50WzBdID09PSAnLScgJiYgbWluZUN1cnJlbnRbMF0gPT09ICcgJykge1xuICAgICAgLy8gVGhlaXIgcmVtb3ZlZCBvciBlZGl0ZWRcbiAgICAgIHJlbW92YWwoaHVuaywgdGhlaXIsIG1pbmUsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAobWluZUN1cnJlbnQgPT09IHRoZWlyQ3VycmVudCkge1xuICAgICAgLy8gQ29udGV4dCBpZGVudGl0eVxuICAgICAgaHVuay5saW5lcy5wdXNoKG1pbmVDdXJyZW50KTtcbiAgICAgIG1pbmUuaW5kZXgrKztcbiAgICAgIHRoZWlyLmluZGV4Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRleHQgbWlzbWF0Y2hcbiAgICAgIGNvbmZsaWN0KGh1bmssIGNvbGxlY3RDaGFuZ2UobWluZSksIGNvbGxlY3RDaGFuZ2UodGhlaXIpKTtcbiAgICB9XG4gIH0gLy8gTm93IHB1c2ggYW55dGhpbmcgdGhhdCBtYXkgYmUgcmVtYWluaW5nXG5cblxuICBpbnNlcnRUcmFpbGluZyhodW5rLCBtaW5lKTtcbiAgaW5zZXJ0VHJhaWxpbmcoaHVuaywgdGhlaXIpO1xuICBjYWxjTGluZUNvdW50KGh1bmspO1xufVxuXG5mdW5jdGlvbiBtdXR1YWxDaGFuZ2UoaHVuaywgbWluZSwgdGhlaXIpIHtcbiAgdmFyIG15Q2hhbmdlcyA9IGNvbGxlY3RDaGFuZ2UobWluZSksXG4gICAgICB0aGVpckNoYW5nZXMgPSBjb2xsZWN0Q2hhbmdlKHRoZWlyKTtcblxuICBpZiAoYWxsUmVtb3ZlcyhteUNoYW5nZXMpICYmIGFsbFJlbW92ZXModGhlaXJDaGFuZ2VzKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgcmVtb3ZlIGNoYW5nZXMgdGhhdCBhcmUgc3VwZXJzZXRzIG9mIG9uZSBhbm90aGVyXG4gICAgaWYgKFxuICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAoMCxcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgIF9hcnJheVxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgLlxuICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICBhcnJheVN0YXJ0c1dpdGgpXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAobXlDaGFuZ2VzLCB0aGVpckNoYW5nZXMpICYmIHNraXBSZW1vdmVTdXBlcnNldCh0aGVpciwgbXlDaGFuZ2VzLCBteUNoYW5nZXMubGVuZ3RoIC0gdGhlaXJDaGFuZ2VzLmxlbmd0aCkpIHtcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgIHZhciBfaHVuayRsaW5lczM7XG5cbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5cbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cblxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICAgKF9odW5rJGxpbmVzMyA9XG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICAgaHVuay5saW5lcykucHVzaC5hcHBseShcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgIF9odW5rJGxpbmVzM1xuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAgICxcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgIF90b0NvbnN1bWFibGVBcnJheShcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICBteUNoYW5nZXMpKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICgwLFxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5cbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgX2FycmF5XG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAuXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgIGFycmF5U3RhcnRzV2l0aClcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICh0aGVpckNoYW5nZXMsIG15Q2hhbmdlcykgJiYgc2tpcFJlbW92ZVN1cGVyc2V0KG1pbmUsIHRoZWlyQ2hhbmdlcywgdGhlaXJDaGFuZ2VzLmxlbmd0aCAtIG15Q2hhbmdlcy5sZW5ndGgpKSB7XG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICB2YXIgX2h1bmskbGluZXM0O1xuXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5cbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgIChfaHVuayRsaW5lczQgPVxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAgIGh1bmsubGluZXMpLnB1c2guYXBwbHkoXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICBfaHVuayRsaW5lczRcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICAsXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICBfdG9Db25zdW1hYmxlQXJyYXkoXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICAgdGhlaXJDaGFuZ2VzKSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoXG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgKDAsXG4gIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICBfYXJyYXlcbiAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgLlxuICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gIGFycmF5RXF1YWwpXG4gIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gIChteUNoYW5nZXMsIHRoZWlyQ2hhbmdlcykpIHtcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgdmFyIF9odW5rJGxpbmVzNTtcblxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5cbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgIChfaHVuayRsaW5lczUgPVxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgaHVuay5saW5lcykucHVzaC5hcHBseShcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgX2h1bmskbGluZXM1XG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAsXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgIF90b0NvbnN1bWFibGVBcnJheShcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgIG15Q2hhbmdlcykpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uZmxpY3QoaHVuaywgbXlDaGFuZ2VzLCB0aGVpckNoYW5nZXMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmFsKGh1bmssIG1pbmUsIHRoZWlyLCBzd2FwKSB7XG4gIHZhciBteUNoYW5nZXMgPSBjb2xsZWN0Q2hhbmdlKG1pbmUpLFxuICAgICAgdGhlaXJDaGFuZ2VzID0gY29sbGVjdENvbnRleHQodGhlaXIsIG15Q2hhbmdlcyk7XG5cbiAgaWYgKHRoZWlyQ2hhbmdlcy5tZXJnZWQpIHtcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgdmFyIF9odW5rJGxpbmVzNjtcblxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5cbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgIChfaHVuayRsaW5lczYgPVxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgaHVuay5saW5lcykucHVzaC5hcHBseShcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgX2h1bmskbGluZXM2XG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAsXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgIF90b0NvbnN1bWFibGVBcnJheShcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgIHRoZWlyQ2hhbmdlcy5tZXJnZWQpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25mbGljdChodW5rLCBzd2FwID8gdGhlaXJDaGFuZ2VzIDogbXlDaGFuZ2VzLCBzd2FwID8gbXlDaGFuZ2VzIDogdGhlaXJDaGFuZ2VzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb25mbGljdChodW5rLCBtaW5lLCB0aGVpcikge1xuICBodW5rLmNvbmZsaWN0ID0gdHJ1ZTtcbiAgaHVuay5saW5lcy5wdXNoKHtcbiAgICBjb25mbGljdDogdHJ1ZSxcbiAgICBtaW5lOiBtaW5lLFxuICAgIHRoZWlyczogdGhlaXJcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluc2VydExlYWRpbmcoaHVuaywgaW5zZXJ0LCB0aGVpcikge1xuICB3aGlsZSAoaW5zZXJ0Lm9mZnNldCA8IHRoZWlyLm9mZnNldCAmJiBpbnNlcnQuaW5kZXggPCBpbnNlcnQubGluZXMubGVuZ3RoKSB7XG4gICAgdmFyIGxpbmUgPSBpbnNlcnQubGluZXNbaW5zZXJ0LmluZGV4KytdO1xuICAgIGh1bmsubGluZXMucHVzaChsaW5lKTtcbiAgICBpbnNlcnQub2Zmc2V0Kys7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0VHJhaWxpbmcoaHVuaywgaW5zZXJ0KSB7XG4gIHdoaWxlIChpbnNlcnQuaW5kZXggPCBpbnNlcnQubGluZXMubGVuZ3RoKSB7XG4gICAgdmFyIGxpbmUgPSBpbnNlcnQubGluZXNbaW5zZXJ0LmluZGV4KytdO1xuICAgIGh1bmsubGluZXMucHVzaChsaW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb2xsZWN0Q2hhbmdlKHN0YXRlKSB7XG4gIHZhciByZXQgPSBbXSxcbiAgICAgIG9wZXJhdGlvbiA9IHN0YXRlLmxpbmVzW3N0YXRlLmluZGV4XVswXTtcblxuICB3aGlsZSAoc3RhdGUuaW5kZXggPCBzdGF0ZS5saW5lcy5sZW5ndGgpIHtcbiAgICB2YXIgbGluZSA9IHN0YXRlLmxpbmVzW3N0YXRlLmluZGV4XTsgLy8gR3JvdXAgYWRkaXRpb25zIHRoYXQgYXJlIGltbWVkaWF0ZWx5IGFmdGVyIHN1YnRyYWN0aW9ucyBhbmQgdHJlYXQgdGhlbSBhcyBvbmUgXCJhdG9taWNcIiBtb2RpZnkgY2hhbmdlLlxuXG4gICAgaWYgKG9wZXJhdGlvbiA9PT0gJy0nICYmIGxpbmVbMF0gPT09ICcrJykge1xuICAgICAgb3BlcmF0aW9uID0gJysnO1xuICAgIH1cblxuICAgIGlmIChvcGVyYXRpb24gPT09IGxpbmVbMF0pIHtcbiAgICAgIHJldC5wdXNoKGxpbmUpO1xuICAgICAgc3RhdGUuaW5kZXgrKztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gY29sbGVjdENvbnRleHQoc3RhdGUsIG1hdGNoQ2hhbmdlcykge1xuICB2YXIgY2hhbmdlcyA9IFtdLFxuICAgICAgbWVyZ2VkID0gW10sXG4gICAgICBtYXRjaEluZGV4ID0gMCxcbiAgICAgIGNvbnRleHRDaGFuZ2VzID0gZmFsc2UsXG4gICAgICBjb25mbGljdGVkID0gZmFsc2U7XG5cbiAgd2hpbGUgKG1hdGNoSW5kZXggPCBtYXRjaENoYW5nZXMubGVuZ3RoICYmIHN0YXRlLmluZGV4IDwgc3RhdGUubGluZXMubGVuZ3RoKSB7XG4gICAgdmFyIGNoYW5nZSA9IHN0YXRlLmxpbmVzW3N0YXRlLmluZGV4XSxcbiAgICAgICAgbWF0Y2ggPSBtYXRjaENoYW5nZXNbbWF0Y2hJbmRleF07IC8vIE9uY2Ugd2UndmUgaGl0IG91ciBhZGQsIHRoZW4gd2UgYXJlIGRvbmVcblxuICAgIGlmIChtYXRjaFswXSA9PT0gJysnKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb250ZXh0Q2hhbmdlcyA9IGNvbnRleHRDaGFuZ2VzIHx8IGNoYW5nZVswXSAhPT0gJyAnO1xuICAgIG1lcmdlZC5wdXNoKG1hdGNoKTtcbiAgICBtYXRjaEluZGV4Kys7IC8vIENvbnN1bWUgYW55IGFkZGl0aW9ucyBpbiB0aGUgb3RoZXIgYmxvY2sgYXMgYSBjb25mbGljdCB0byBhdHRlbXB0XG4gICAgLy8gdG8gcHVsbCBpbiB0aGUgcmVtYWluaW5nIGNvbnRleHQgYWZ0ZXIgdGhpc1xuXG4gICAgaWYgKGNoYW5nZVswXSA9PT0gJysnKSB7XG4gICAgICBjb25mbGljdGVkID0gdHJ1ZTtcblxuICAgICAgd2hpbGUgKGNoYW5nZVswXSA9PT0gJysnKSB7XG4gICAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICBjaGFuZ2UgPSBzdGF0ZS5saW5lc1srK3N0YXRlLmluZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF0Y2guc3Vic3RyKDEpID09PSBjaGFuZ2Uuc3Vic3RyKDEpKSB7XG4gICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgIHN0YXRlLmluZGV4Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZsaWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICgobWF0Y2hDaGFuZ2VzW21hdGNoSW5kZXhdIHx8ICcnKVswXSA9PT0gJysnICYmIGNvbnRleHRDaGFuZ2VzKSB7XG4gICAgY29uZmxpY3RlZCA9IHRydWU7XG4gIH1cblxuICBpZiAoY29uZmxpY3RlZCkge1xuICAgIHJldHVybiBjaGFuZ2VzO1xuICB9XG5cbiAgd2hpbGUgKG1hdGNoSW5kZXggPCBtYXRjaENoYW5nZXMubGVuZ3RoKSB7XG4gICAgbWVyZ2VkLnB1c2gobWF0Y2hDaGFuZ2VzW21hdGNoSW5kZXgrK10pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtZXJnZWQ6IG1lcmdlZCxcbiAgICBjaGFuZ2VzOiBjaGFuZ2VzXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFsbFJlbW92ZXMoY2hhbmdlcykge1xuICByZXR1cm4gY2hhbmdlcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGNoYW5nZSkge1xuICAgIHJldHVybiBwcmV2ICYmIGNoYW5nZVswXSA9PT0gJy0nO1xuICB9LCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gc2tpcFJlbW92ZVN1cGVyc2V0KHN0YXRlLCByZW1vdmVDaGFuZ2VzLCBkZWx0YSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbHRhOyBpKyspIHtcbiAgICB2YXIgY2hhbmdlQ29udGVudCA9IHJlbW92ZUNoYW5nZXNbcmVtb3ZlQ2hhbmdlcy5sZW5ndGggLSBkZWx0YSArIGldLnN1YnN0cigxKTtcblxuICAgIGlmIChzdGF0ZS5saW5lc1tzdGF0ZS5pbmRleCArIGldICE9PSAnICcgKyBjaGFuZ2VDb250ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuaW5kZXggKz0gZGVsdGE7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjYWxjT2xkTmV3TGluZUNvdW50KGxpbmVzKSB7XG4gIHZhciBvbGRMaW5lcyA9IDA7XG4gIHZhciBuZXdMaW5lcyA9IDA7XG4gIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICBpZiAodHlwZW9mIGxpbmUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgbXlDb3VudCA9IGNhbGNPbGROZXdMaW5lQ291bnQobGluZS5taW5lKTtcbiAgICAgIHZhciB0aGVpckNvdW50ID0gY2FsY09sZE5ld0xpbmVDb3VudChsaW5lLnRoZWlycyk7XG5cbiAgICAgIGlmIChvbGRMaW5lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChteUNvdW50Lm9sZExpbmVzID09PSB0aGVpckNvdW50Lm9sZExpbmVzKSB7XG4gICAgICAgICAgb2xkTGluZXMgKz0gbXlDb3VudC5vbGRMaW5lcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbGRMaW5lcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV3TGluZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobXlDb3VudC5uZXdMaW5lcyA9PT0gdGhlaXJDb3VudC5uZXdMaW5lcykge1xuICAgICAgICAgIG5ld0xpbmVzICs9IG15Q291bnQubmV3TGluZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3TGluZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5ld0xpbmVzICE9PSB1bmRlZmluZWQgJiYgKGxpbmVbMF0gPT09ICcrJyB8fCBsaW5lWzBdID09PSAnICcpKSB7XG4gICAgICAgIG5ld0xpbmVzKys7XG4gICAgICB9XG5cbiAgICAgIGlmIChvbGRMaW5lcyAhPT0gdW5kZWZpbmVkICYmIChsaW5lWzBdID09PSAnLScgfHwgbGluZVswXSA9PT0gJyAnKSkge1xuICAgICAgICBvbGRMaW5lcysrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgb2xkTGluZXM6IG9sZExpbmVzLFxuICAgIG5ld0xpbmVzOiBuZXdMaW5lc1xuICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5d1lYUmphQzl0WlhKblpTNXFjeUpkTENKdVlXMWxjeUk2V3lKallXeGpUR2x1WlVOdmRXNTBJaXdpYUhWdWF5SXNJbU5oYkdOUGJHUk9aWGRNYVc1bFEyOTFiblFpTENKc2FXNWxjeUlzSW05c1pFeHBibVZ6SWl3aWJtVjNUR2x1WlhNaUxDSjFibVJsWm1sdVpXUWlMQ0p0WlhKblpTSXNJbTFwYm1VaUxDSjBhR1ZwY25NaUxDSmlZWE5sSWl3aWJHOWhaRkJoZEdOb0lpd2ljbVYwSWl3aWFXNWtaWGdpTENKdVpYZEdhV3hsVG1GdFpTSXNJbVpwYkdWT1lXMWxRMmhoYm1kbFpDSXNJbTlzWkVacGJHVk9ZVzFsSWl3aWIyeGtTR1ZoWkdWeUlpd2libVYzU0dWaFpHVnlJaXdpYzJWc1pXTjBSbWxsYkdRaUxDSm9kVzVyY3lJc0ltMXBibVZKYm1SbGVDSXNJblJvWldseWMwbHVaR1Y0SWl3aWJXbHVaVTltWm5ObGRDSXNJblJvWldseWMwOW1abk5sZENJc0lteGxibWQwYUNJc0ltMXBibVZEZFhKeVpXNTBJaXdpYjJ4a1UzUmhjblFpTENKSmJtWnBibWwwZVNJc0luUm9aV2x5YzBOMWNuSmxiblFpTENKb2RXNXJRbVZtYjNKbElpd2ljSFZ6YUNJc0ltTnNiMjVsU0hWdWF5SXNJbTFsY21kbFpFaDFibXNpTENKTllYUm9JaXdpYldsdUlpd2libVYzVTNSaGNuUWlMQ0p0WlhKblpVeHBibVZ6SWl3aWNHRnlZVzBpTENKMFpYTjBJaXdpY0dGeWMyVlFZWFJqYUNJc0lrVnljbTl5SWl3aWMzUnlkV04wZFhKbFpGQmhkR05vSWl3aWNHRjBZMmdpTENKamIyNW1iR2xqZENJc0ltTm9aV05ySWl3aWIyWm1jMlYwSWl3aWJXbHVaVXhwYm1Weklpd2lkR2hsYVhKUFptWnpaWFFpTENKMGFHVnBja3hwYm1Weklpd2lkR2hsYVhJaUxDSnBibk5sY25STVpXRmthVzVuSWl3aWRHaGxhWEpEZFhKeVpXNTBJaXdpYlhWMGRXRnNRMmhoYm1kbElpd2lZMjlzYkdWamRFTm9ZVzVuWlNJc0luSmxiVzkyWVd3aUxDSnBibk5sY25SVWNtRnBiR2x1WnlJc0ltMTVRMmhoYm1kbGN5SXNJblJvWldseVEyaGhibWRsY3lJc0ltRnNiRkpsYlc5MlpYTWlMQ0poY25KaGVWTjBZWEowYzFkcGRHZ2lMQ0p6YTJsd1VtVnRiM1psVTNWd1pYSnpaWFFpTENKaGNuSmhlVVZ4ZFdGc0lpd2ljM2RoY0NJc0ltTnZiR3hsWTNSRGIyNTBaWGgwSWl3aWJXVnlaMlZrSWl3aWFXNXpaWEowSWl3aWJHbHVaU0lzSW5OMFlYUmxJaXdpYjNCbGNtRjBhVzl1SWl3aWJXRjBZMmhEYUdGdVoyVnpJaXdpWTJoaGJtZGxjeUlzSW0xaGRHTm9TVzVrWlhnaUxDSmpiMjUwWlhoMFEyaGhibWRsY3lJc0ltTnZibVpzYVdOMFpXUWlMQ0pqYUdGdVoyVWlMQ0p0WVhSamFDSXNJbk4xWW5OMGNpSXNJbkpsWkhWalpTSXNJbkJ5WlhZaUxDSnlaVzF2ZG1WRGFHRnVaMlZ6SWl3aVpHVnNkR0VpTENKcElpd2lZMmhoYm1kbFEyOXVkR1Z1ZENJc0ltWnZja1ZoWTJnaUxDSnRlVU52ZFc1MElpd2lkR2hsYVhKRGIzVnVkQ0pkTENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN096dEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN08wRkJRMEU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVRzN1FVRkZRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCT3pzN096czdPenM3T3pzN096czdRVUZGVHl4VFFVRlRRU3hoUVVGVUxFTkJRWFZDUXl4SlFVRjJRaXhGUVVFMlFqdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVTk1ReXhGUVVGQlFTeHRRa0ZCYlVJc1EwRkJRMFFzU1VGQlNTeERRVUZEUlN4TFFVRk9MRU5CUkdRN1FVRkJRU3hOUVVNelFrTXNVVUZFTWtJc2QwSkJRek5DUVN4UlFVUXlRanRCUVVGQkxFMUJRMnBDUXl4UlFVUnBRaXgzUWtGRGFrSkJMRkZCUkdsQ096dEJRVWRzUXl4TlFVRkpSQ3hSUVVGUkxFdEJRVXRGTEZOQlFXcENMRVZCUVRSQ08wRkJRekZDVEN4SlFVRkJRU3hKUVVGSkxFTkJRVU5ITEZGQlFVd3NSMEZCWjBKQkxGRkJRV2hDTzBGQlEwUXNSMEZHUkN4TlFVVlBPMEZCUTB3c1YwRkJUMGdzU1VGQlNTeERRVUZEUnl4UlFVRmFPMEZCUTBRN08wRkJSVVFzVFVGQlNVTXNVVUZCVVN4TFFVRkxReXhUUVVGcVFpeEZRVUUwUWp0QlFVTXhRa3dzU1VGQlFVRXNTVUZCU1N4RFFVRkRTU3hSUVVGTUxFZEJRV2RDUVN4UlFVRm9RanRCUVVORUxFZEJSa1FzVFVGRlR6dEJRVU5NTEZkQlFVOUtMRWxCUVVrc1EwRkJRMGtzVVVGQldqdEJRVU5FTzBGQlEwWTdPMEZCUlUwc1UwRkJVMFVzUzBGQlZDeERRVUZsUXl4SlFVRm1MRVZCUVhGQ1F5eE5RVUZ5UWl4RlFVRTJRa01zU1VGQk4wSXNSVUZCYlVNN1FVRkRlRU5HTEVWQlFVRkJMRWxCUVVrc1IwRkJSMGNzVTBGQlV5eERRVUZEU0N4SlFVRkVMRVZCUVU5RkxFbEJRVkFzUTBGQmFFSTdRVUZEUVVRc1JVRkJRVUVzVFVGQlRTeEhRVUZIUlN4VFFVRlRMRU5CUVVOR0xFMUJRVVFzUlVGQlUwTXNTVUZCVkN4RFFVRnNRanRCUVVWQkxFMUJRVWxGTEVkQlFVY3NSMEZCUnl4RlFVRldMRU5CU25kRExFTkJUWGhETzBGQlEwRTdRVUZEUVRzN1FVRkRRU3hOUVVGSlNpeEpRVUZKTEVOQlFVTkxMRXRCUVV3c1NVRkJZMG9zVFVGQlRTeERRVUZEU1N4TFFVRjZRaXhGUVVGblF6dEJRVU01UWtRc1NVRkJRVUVzUjBGQlJ5eERRVUZEUXl4TFFVRktMRWRCUVZsTUxFbEJRVWtzUTBGQlEwc3NTMEZCVEN4SlFVRmpTaXhOUVVGTkxFTkJRVU5KTEV0QlFXcERPMEZCUTBRN08wRkJSVVFzVFVGQlNVd3NTVUZCU1N4RFFVRkRUU3hYUVVGTUxFbEJRVzlDVEN4TlFVRk5MRU5CUVVOTExGZEJRUzlDTEVWQlFUUkRPMEZCUXpGRExGRkJRVWtzUTBGQlEwTXNaVUZCWlN4RFFVRkRVQ3hKUVVGRUxFTkJRWEJDTEVWQlFUUkNPMEZCUXpGQ08wRkJRMEZKTEUxQlFVRkJMRWRCUVVjc1EwRkJRMGtzVjBGQlNpeEhRVUZyUWxBc1RVRkJUU3hEUVVGRFR5eFhRVUZRTEVsQlFYTkNVaXhKUVVGSkxFTkJRVU5STEZkQlFUZERPMEZCUTBGS0xFMUJRVUZCTEVkQlFVY3NRMEZCUTBVc1YwRkJTaXhIUVVGclFrd3NUVUZCVFN4RFFVRkRTeXhYUVVGUUxFbEJRWE5DVGl4SlFVRkpMRU5CUVVOTkxGZEJRVGRETzBGQlEwRkdMRTFCUVVGQkxFZEJRVWNzUTBGQlEwc3NVMEZCU2l4SFFVRm5RbElzVFVGQlRTeERRVUZEVVN4VFFVRlFMRWxCUVc5Q1ZDeEpRVUZKTEVOQlFVTlRMRk5CUVhwRE8wRkJRMEZNTEUxQlFVRkJMRWRCUVVjc1EwRkJRMDBzVTBGQlNpeEhRVUZuUWxRc1RVRkJUU3hEUVVGRFV5eFRRVUZRTEVsQlFXOUNWaXhKUVVGSkxFTkJRVU5WTEZOQlFYcERPMEZCUTBRc1MwRk9SQ3hOUVUxUExFbEJRVWtzUTBGQlEwZ3NaVUZCWlN4RFFVRkRUaXhOUVVGRUxFTkJRWEJDTEVWQlFUaENPMEZCUTI1RE8wRkJRMEZITEUxQlFVRkJMRWRCUVVjc1EwRkJRMGtzVjBGQlNpeEhRVUZyUWxJc1NVRkJTU3hEUVVGRFVTeFhRVUYyUWp0QlFVTkJTaXhOUVVGQlFTeEhRVUZITEVOQlFVTkZMRmRCUVVvc1IwRkJhMEpPTEVsQlFVa3NRMEZCUTAwc1YwRkJka0k3UVVGRFFVWXNUVUZCUVVFc1IwRkJSeXhEUVVGRFN5eFRRVUZLTEVkQlFXZENWQ3hKUVVGSkxFTkJRVU5UTEZOQlFYSkNPMEZCUTBGTUxFMUJRVUZCTEVkQlFVY3NRMEZCUTAwc1UwRkJTaXhIUVVGblFsWXNTVUZCU1N4RFFVRkRWU3hUUVVGeVFqdEJRVU5FTEV0QlRrMHNUVUZOUVR0QlFVTk1PMEZCUTBGT0xFMUJRVUZCTEVkQlFVY3NRMEZCUTBrc1YwRkJTaXhIUVVGclFrY3NWMEZCVnl4RFFVRkRVQ3hIUVVGRUxFVkJRVTFLTEVsQlFVa3NRMEZCUTFFc1YwRkJXQ3hGUVVGM1FsQXNUVUZCVFN4RFFVRkRUeXhYUVVFdlFpeERRVUUzUWp0QlFVTkJTaXhOUVVGQlFTeEhRVUZITEVOQlFVTkZMRmRCUVVvc1IwRkJhMEpMTEZkQlFWY3NRMEZCUTFBc1IwRkJSQ3hGUVVGTlNpeEpRVUZKTEVOQlFVTk5MRmRCUVZnc1JVRkJkMEpNTEUxQlFVMHNRMEZCUTBzc1YwRkJMMElzUTBGQk4wSTdRVUZEUVVZc1RVRkJRVUVzUjBGQlJ5eERRVUZEU3l4VFFVRktMRWRCUVdkQ1JTeFhRVUZYTEVOQlFVTlFMRWRCUVVRc1JVRkJUVW9zU1VGQlNTeERRVUZEVXl4VFFVRllMRVZCUVhOQ1VpeE5RVUZOTEVOQlFVTlJMRk5CUVRkQ0xFTkJRVE5DTzBGQlEwRk1MRTFCUVVGQkxFZEJRVWNzUTBGQlEwMHNVMEZCU2l4SFFVRm5Ra01zVjBGQlZ5eERRVUZEVUN4SFFVRkVMRVZCUVUxS0xFbEJRVWtzUTBGQlExVXNVMEZCV0N4RlFVRnpRbFFzVFVGQlRTeERRVUZEVXl4VFFVRTNRaXhEUVVFelFqdEJRVU5FTzBGQlEwWTdPMEZCUlVST0xFVkJRVUZCTEVkQlFVY3NRMEZCUTFFc1MwRkJTaXhIUVVGWkxFVkJRVm83UVVGRlFTeE5RVUZKUXl4VFFVRlRMRWRCUVVjc1EwRkJhRUk3UVVGQlFTeE5RVU5KUXl4WFFVRlhMRWRCUVVjc1EwRkViRUk3UVVGQlFTeE5RVVZKUXl4VlFVRlZMRWRCUVVjc1EwRkdha0k3UVVGQlFTeE5RVWRKUXl4WlFVRlpMRWRCUVVjc1EwRklia0k3TzBGQlMwRXNVMEZCVDBnc1UwRkJVeXhIUVVGSFlpeEpRVUZKTEVOQlFVTlpMRXRCUVV3c1EwRkJWMHNzVFVGQmRrSXNTVUZCYVVOSUxGZEJRVmNzUjBGQlIySXNUVUZCVFN4RFFVRkRWeXhMUVVGUUxFTkJRV0ZMTEUxQlFXNUZMRVZCUVRKRk8wRkJRM3BGTEZGQlFVbERMRmRCUVZjc1IwRkJSMnhDTEVsQlFVa3NRMEZCUTFrc1MwRkJUQ3hEUVVGWFF5eFRRVUZZTEV0QlFYbENPMEZCUVVOTkxFMUJRVUZCTEZGQlFWRXNSVUZCUlVNN1FVRkJXQ3hMUVVFelF6dEJRVUZCTEZGQlEwbERMR0ZCUVdFc1IwRkJSM0JDTEUxQlFVMHNRMEZCUTFjc1MwRkJVQ3hEUVVGaFJTeFhRVUZpTEV0QlFUWkNPMEZCUVVOTExFMUJRVUZCTEZGQlFWRXNSVUZCUlVNN1FVRkJXQ3hMUVVScVJEczdRVUZIUVN4UlFVRkpSU3hWUVVGVkxFTkJRVU5LTEZkQlFVUXNSVUZCWTBjc1lVRkJaQ3hEUVVGa0xFVkJRVFJETzBGQlF6RkRPMEZCUTBGcVFpeE5RVUZCUVN4SFFVRkhMRU5CUVVOUkxFdEJRVW9zUTBGQlZWY3NTVUZCVml4RFFVRmxReXhUUVVGVExFTkJRVU5PTEZkQlFVUXNSVUZCWTBnc1ZVRkJaQ3hEUVVGNFFqdEJRVU5CUml4TlFVRkJRU3hUUVVGVE8wRkJRMVJITEUxQlFVRkJMRmxCUVZrc1NVRkJTVVVzVjBGQlZ5eERRVUZEY2tJc1VVRkJXaXhIUVVGMVFuRkNMRmRCUVZjc1EwRkJRM1JDTEZGQlFXNUVPMEZCUTBRc1MwRk1SQ3hOUVV0UExFbEJRVWt3UWl4VlFVRlZMRU5CUVVORUxHRkJRVVFzUlVGQlowSklMRmRCUVdoQ0xFTkJRV1FzUlVGQk5FTTdRVUZEYWtRN1FVRkRRV1FzVFVGQlFVRXNSMEZCUnl4RFFVRkRVU3hMUVVGS0xFTkJRVlZYTEVsQlFWWXNRMEZCWlVNc1UwRkJVeXhEUVVGRFNDeGhRVUZFTEVWQlFXZENUQ3haUVVGb1FpeERRVUY0UWp0QlFVTkJSaXhOUVVGQlFTeFhRVUZYTzBGQlExaERMRTFCUVVGQkxGVkJRVlVzU1VGQlNVMHNZVUZCWVN4RFFVRkRlRUlzVVVGQlpDeEhRVUY1UW5kQ0xHRkJRV0VzUTBGQlEzcENMRkZCUVhKRU8wRkJRMFFzUzBGTVRTeE5RVXRCTzBGQlEwdzdRVUZEUVN4VlFVRkpOa0lzVlVGQlZTeEhRVUZITzBGQlEyWk9MRkZCUVVGQkxGRkJRVkVzUlVGQlJVOHNTVUZCU1N4RFFVRkRReXhIUVVGTUxFTkJRVk5VTEZkQlFWY3NRMEZCUTBNc1VVRkJja0lzUlVGQkswSkZMR0ZCUVdFc1EwRkJRMFlzVVVGQk4wTXNRMEZFU3p0QlFVVm1ka0lzVVVGQlFVRXNVVUZCVVN4RlFVRkZMRU5CUmtzN1FVRkhabWRETEZGQlFVRkJMRkZCUVZFc1JVRkJSVVlzU1VGQlNTeERRVUZEUXl4SFFVRk1MRU5CUVZOVUxGZEJRVmNzUTBGQlExVXNVVUZCV2l4SFFVRjFRbUlzVlVGQmFFTXNSVUZCTkVOTkxHRkJRV0VzUTBGQlEwWXNVVUZCWkN4SFFVRjVRa2dzV1VGQmNrVXNRMEZJU3p0QlFVbG1ia0lzVVVGQlFVRXNVVUZCVVN4RlFVRkZMRU5CU2tzN1FVRkxaa1lzVVVGQlFVRXNTMEZCU3l4RlFVRkZPMEZCVEZFc1QwRkJha0k3UVVGUFFXdERMRTFCUVVGQkxGVkJRVlVzUTBGQlEwb3NWVUZCUkN4RlFVRmhVQ3hYUVVGWExFTkJRVU5ETEZGQlFYcENMRVZCUVcxRFJDeFhRVUZYTEVOQlFVTjJRaXhMUVVFdlF5eEZRVUZ6UkRCQ0xHRkJRV0VzUTBGQlEwWXNVVUZCY0VVc1JVRkJPRVZGTEdGQlFXRXNRMEZCUXpGQ0xFdEJRVFZHTEVOQlFWWTdRVUZEUVcxQ0xFMUJRVUZCTEZkQlFWYzdRVUZEV0VRc1RVRkJRVUVzVTBGQlV6dEJRVVZVVkN4TlFVRkJRU3hIUVVGSExFTkJRVU5STEV0QlFVb3NRMEZCVlZjc1NVRkJWaXhEUVVGbFJTeFZRVUZtTzBGQlEwUTdRVUZEUmpzN1FVRkZSQ3hUUVVGUGNrSXNSMEZCVUR0QlFVTkVPenRCUVVWRUxGTkJRVk5FTEZOQlFWUXNRMEZCYlVJeVFpeExRVUZ1UWl4RlFVRXdRalZDTEVsQlFURkNMRVZCUVdkRE8wRkJRemxDTEUxQlFVa3NUMEZCVHpSQ0xFdEJRVkFzUzBGQmFVSXNVVUZCY2tJc1JVRkJLMEk3UVVGRE4wSXNVVUZCU3l4TlFVRkVMRU5CUVZORExFbEJRVlFzUTBGQlkwUXNTMEZCWkN4TFFVRXdRaXhWUVVGRUxFTkJRV0ZETEVsQlFXSXNRMEZCYTBKRUxFdEJRV3hDTEVOQlFUZENMRVZCUVhkRU8wRkJRM1JFTEdGQlFVODdRVUZCUVR0QlFVRkJPMEZCUVVFN08wRkJRVUZGTzBGQlFVRkJPMEZCUVVGQk8wRkJRVUZCTzBGQlFVRkJPMEZCUVVGQk8wRkJRVUU3UVVGQlFTeFRRVUZYUml4TFFVRllMRVZCUVd0Q0xFTkJRV3hDTzBGQlFWQTdRVUZEUkRzN1FVRkZSQ3hSUVVGSkxFTkJRVU0xUWl4SlFVRk1MRVZCUVZjN1FVRkRWQ3haUVVGTkxFbEJRVWtyUWl4TFFVRktMRU5CUVZVc2EwUkJRVllzUTBGQlRqdEJRVU5FT3p0QlFVTkVMRmRCUVU4N1FVRkJRVHRCUVVGQk8wRkJRVUU3TzBGQlFVRkRPMEZCUVVGQk8wRkJRVUZCTzBGQlFVRkJPMEZCUVVGQk8wRkJRVUZCTzBGQlFVRTdRVUZCUVN4UFFVRm5RbkJETEZOQlFXaENMRVZCUVRKQ1FTeFRRVUV6UWl4RlFVRnpRMGtzU1VGQmRFTXNSVUZCTkVNMFFpeExRVUUxUXp0QlFVRlFPMEZCUTBRN08wRkJSVVFzVTBGQlQwRXNTMEZCVUR0QlFVTkVPenRCUVVWRUxGTkJRVk4yUWl4bFFVRlVMRU5CUVhsQ05FSXNTMEZCZWtJc1JVRkJaME03UVVGRE9VSXNVMEZCVDBFc1MwRkJTeXhEUVVGRE4wSXNWMEZCVGl4SlFVRnhRalpDTEV0QlFVc3NRMEZCUXpkQ0xGZEJRVTRzUzBGQmMwSTJRaXhMUVVGTExFTkJRVU16UWl4WFFVRjRSRHRCUVVORU96dEJRVVZFTEZOQlFWTkhMRmRCUVZRc1EwRkJjVUpPTEV0QlFYSkNMRVZCUVRSQ1RDeEpRVUUxUWl4RlFVRnJRME1zVFVGQmJFTXNSVUZCTUVNN1FVRkRlRU1zVFVGQlNVUXNTVUZCU1N4TFFVRkxReXhOUVVGaUxFVkJRWEZDTzBGQlEyNUNMRmRCUVU5RUxFbEJRVkE3UVVGRFJDeEhRVVpFTEUxQlJVODdRVUZEVEVzc1NVRkJRVUVzUzBGQlN5eERRVUZESzBJc1VVRkJUaXhIUVVGcFFpeEpRVUZxUWp0QlFVTkJMRmRCUVU4N1FVRkJRM0JETEUxQlFVRkJMRWxCUVVrc1JVRkJTa0VzU1VGQlJEdEJRVUZQUXl4TlFVRkJRU3hOUVVGTkxFVkJRVTVCTzBGQlFWQXNTMEZCVUR0QlFVTkVPMEZCUTBZN08wRkJSVVFzVTBGQlUzRkNMRlZCUVZRc1EwRkJiMEpUTEVsQlFYQkNMRVZCUVRCQ1RTeExRVUV4UWl4RlFVRnBRenRCUVVNdlFpeFRRVUZQVGl4SlFVRkpMRU5CUVVOYUxGRkJRVXdzUjBGQlowSnJRaXhMUVVGTExFTkJRVU5zUWl4UlFVRjBRaXhKUVVORVdTeEpRVUZKTEVOQlFVTmFMRkZCUVV3c1IwRkJaMEpaTEVsQlFVa3NRMEZCUTI1RExGRkJRWFJDTEVkQlFXdERlVU1zUzBGQlN5eERRVUZEYkVJc1VVRkVOME03UVVGRlJEczdRVUZGUkN4VFFVRlRTeXhUUVVGVUxFTkJRVzFDTDBJc1NVRkJia0lzUlVGQmVVSTJReXhOUVVGNlFpeEZRVUZwUXp0QlFVTXZRaXhUUVVGUE8wRkJRMHh1UWl4SlFVRkJRU3hSUVVGUkxFVkJRVVV4UWl4SlFVRkpMRU5CUVVNd1FpeFJRVVJXTzBGQlEyOUNka0lzU1VGQlFVRXNVVUZCVVN4RlFVRkZTQ3hKUVVGSkxFTkJRVU5ITEZGQlJHNURPMEZCUlV4blF5eEpRVUZCUVN4UlFVRlJMRVZCUVVWdVF5eEpRVUZKTEVOQlFVTnRReXhSUVVGTUxFZEJRV2RDVlN4TlFVWnlRanRCUVVVMlFucERMRWxCUVVGQkxGRkJRVkVzUlVGQlJVb3NTVUZCU1N4RFFVRkRTU3hSUVVZMVF6dEJRVWRNUml4SlFVRkJRU3hMUVVGTExFVkJRVVZHTEVsQlFVa3NRMEZCUTBVN1FVRklVQ3hIUVVGUU8wRkJTMFE3TzBGQlJVUXNVMEZCVTJ0RExGVkJRVlFzUTBGQmIwSndReXhKUVVGd1FpeEZRVUV3UW5OQ0xGVkJRVEZDTEVWQlFYTkRkMElzVTBGQmRFTXNSVUZCYVVSRExGZEJRV3BFTEVWQlFUaEVReXhWUVVFNVJDeEZRVUV3UlR0QlFVTjRSVHRCUVVOQk8wRkJRMEVzVFVGQlNYcERMRWxCUVVrc1IwRkJSenRCUVVGRGMwTXNTVUZCUVVFc1RVRkJUU3hGUVVGRmRrSXNWVUZCVkR0QlFVRnhRbkJDTEVsQlFVRkJMRXRCUVVzc1JVRkJSVFJETEZOQlFUVkNPMEZCUVhWRGJFTXNTVUZCUVVFc1MwRkJTeXhGUVVGRk8wRkJRVGxETEVkQlFWZzdRVUZCUVN4TlFVTkpjVU1zUzBGQlN5eEhRVUZITzBGQlFVTktMRWxCUVVGQkxFMUJRVTBzUlVGQlJVVXNWMEZCVkR0QlFVRnpRamRETEVsQlFVRkJMRXRCUVVzc1JVRkJSVGhETEZWQlFUZENPMEZCUVhsRGNFTXNTVUZCUVVFc1MwRkJTeXhGUVVGRk8wRkJRV2hFTEVkQlJGb3NRMEZJZDBVc1EwRk5lRVU3TzBGQlEwRnpReXhGUVVGQlFTeGhRVUZoTEVOQlFVTnNSQ3hKUVVGRUxFVkJRVTlQTEVsQlFWQXNSVUZCWVRCRExFdEJRV0lzUTBGQllqdEJRVU5CUXl4RlFVRkJRU3hoUVVGaExFTkJRVU5zUkN4SlFVRkVMRVZCUVU5cFJDeExRVUZRTEVWQlFXTXhReXhKUVVGa0xFTkJRV0lzUTBGU2QwVXNRMEZWZUVVN08wRkJRMEVzVTBGQlQwRXNTVUZCU1N4RFFVRkRTeXhMUVVGTUxFZEJRV0ZNTEVsQlFVa3NRMEZCUTB3c1MwRkJUQ3hEUVVGWGMwSXNUVUZCZUVJc1NVRkJhME41UWl4TFFVRkxMRU5CUVVOeVF5eExRVUZPTEVkQlFXTnhReXhMUVVGTExFTkJRVU12UXl4TFFVRk9MRU5CUVZselFpeE5RVUZ1UlN4RlFVRXlSVHRCUVVONlJTeFJRVUZKUXl4WFFVRlhMRWRCUVVkc1FpeEpRVUZKTEVOQlFVTk1MRXRCUVV3c1EwRkJWMHNzU1VGQlNTeERRVUZEU3l4TFFVRm9RaXhEUVVGc1FqdEJRVUZCTEZGQlEwbDFReXhaUVVGWkxFZEJRVWRHTEV0QlFVc3NRMEZCUXk5RExFdEJRVTRzUTBGQldTdERMRXRCUVVzc1EwRkJRM0pETEV0QlFXeENMRU5CUkc1Q096dEJRVWRCTEZGQlFVa3NRMEZCUTJFc1YwRkJWeXhEUVVGRExFTkJRVVFzUTBGQldDeExRVUZ0UWl4SFFVRnVRaXhKUVVFd1FrRXNWMEZCVnl4RFFVRkRMRU5CUVVRc1EwRkJXQ3hMUVVGdFFpeEhRVUU1UXl4TlFVTkpNRUlzV1VGQldTeERRVUZETEVOQlFVUXNRMEZCV2l4TFFVRnZRaXhIUVVGd1FpeEpRVUV5UWtFc1dVRkJXU3hEUVVGRExFTkJRVVFzUTBGQldpeExRVUZ2UWl4SFFVUnVSQ3hEUVVGS0xFVkJRelpFTzBGQlF6TkVPMEZCUTBGRExFMUJRVUZCTEZsQlFWa3NRMEZCUTNCRUxFbEJRVVFzUlVGQlQwOHNTVUZCVUN4RlFVRmhNRU1zUzBGQllpeERRVUZhTzBGQlEwUXNTMEZLUkN4TlFVbFBMRWxCUVVsNFFpeFhRVUZYTEVOQlFVTXNRMEZCUkN4RFFVRllMRXRCUVcxQ0xFZEJRVzVDTEVsQlFUQkNNRUlzV1VGQldTeERRVUZETEVOQlFVUXNRMEZCV2l4TFFVRnZRaXhIUVVGc1JDeEZRVUYxUkR0QlFVRkJPMEZCUVVFN08wRkJRVUU3UVVGRE5VUTdPMEZCUTBFN08wRkJRVUU3TzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVGdVJDeE5RVUZCUVN4SlFVRkpMRU5CUVVORkxFdEJRVXdzUlVGQlZ6UkNMRWxCUVZnN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRnZRblZDTEUxQlFVRkJMR0ZCUVdFc1EwRkJRemxETEVsQlFVUXNRMEZCYWtNN1FVRkRSQ3hMUVVoTkxFMUJSMEVzU1VGQlNUUkRMRmxCUVZrc1EwRkJReXhEUVVGRUxFTkJRVm9zUzBGQmIwSXNSMEZCY0VJc1NVRkJNa0l4UWl4WFFVRlhMRU5CUVVNc1EwRkJSQ3hEUVVGWUxFdEJRVzFDTEVkQlFXeEVMRVZCUVhWRU8wRkJRVUU3UVVGQlFUczdRVUZCUVR0QlFVTTFSRHM3UVVGRFFUczdRVUZCUVRzN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFYcENMRTFCUVVGQkxFbEJRVWtzUTBGQlEwVXNTMEZCVEN4RlFVRlhORUlzU1VGQldEdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVzlDZFVJc1RVRkJRVUVzWVVGQllTeERRVUZEU2l4TFFVRkVMRU5CUVdwRE8wRkJRMFFzUzBGSVRTeE5RVWRCTEVsQlFVbDRRaXhYUVVGWExFTkJRVU1zUTBGQlJDeERRVUZZTEV0QlFXMUNMRWRCUVc1Q0xFbEJRVEJDTUVJc1dVRkJXU3hEUVVGRExFTkJRVVFzUTBGQldpeExRVUZ2UWl4SFFVRnNSQ3hGUVVGMVJEdEJRVU0xUkR0QlFVTkJSeXhOUVVGQlFTeFBRVUZQTEVOQlFVTjBSQ3hKUVVGRUxFVkJRVTlQTEVsQlFWQXNSVUZCWVRCRExFdEJRV0lzUTBGQlVEdEJRVU5FTEV0QlNFMHNUVUZIUVN4SlFVRkpSU3haUVVGWkxFTkJRVU1zUTBGQlJDeERRVUZhTEV0QlFXOUNMRWRCUVhCQ0xFbEJRVEpDTVVJc1YwRkJWeXhEUVVGRExFTkJRVVFzUTBGQldDeExRVUZ0UWl4SFFVRnNSQ3hGUVVGMVJEdEJRVU0xUkR0QlFVTkJOa0lzVFVGQlFVRXNUMEZCVHl4RFFVRkRkRVFzU1VGQlJDeEZRVUZQYVVRc1MwRkJVQ3hGUVVGak1VTXNTVUZCWkN4RlFVRnZRaXhKUVVGd1FpeERRVUZRTzBGQlEwUXNTMEZJVFN4TlFVZEJMRWxCUVVsclFpeFhRVUZYTEV0QlFVc3dRaXhaUVVGd1FpeEZRVUZyUXp0QlFVTjJRenRCUVVOQmJrUXNUVUZCUVVFc1NVRkJTU3hEUVVGRFJTeExRVUZNTEVOQlFWYzBRaXhKUVVGWUxFTkJRV2RDVEN4WFFVRm9RanRCUVVOQmJFSXNUVUZCUVVFc1NVRkJTU3hEUVVGRFN5eExRVUZNTzBGQlEwRnhReXhOUVVGQlFTeExRVUZMTEVOQlFVTnlReXhMUVVGT08wRkJRMFFzUzBGTVRTeE5RVXRCTzBGQlEwdzdRVUZEUVN0Q0xFMUJRVUZCTEZGQlFWRXNRMEZCUXpORExFbEJRVVFzUlVGQlQzRkVMR0ZCUVdFc1EwRkJRemxETEVsQlFVUXNRMEZCY0VJc1JVRkJORUk0UXl4aFFVRmhMRU5CUVVOS0xFdEJRVVFzUTBGQmVrTXNRMEZCVWp0QlFVTkVPMEZCUTBZc1IwRjRRM1ZGTEVOQk1FTjRSVHM3TzBGQlEwRk5MRVZCUVVGQkxHTkJRV01zUTBGQlEzWkVMRWxCUVVRc1JVRkJUMDhzU1VGQlVDeERRVUZrTzBGQlEwRm5SQ3hGUVVGQlFTeGpRVUZqTEVOQlFVTjJSQ3hKUVVGRUxFVkJRVTlwUkN4TFFVRlFMRU5CUVdRN1FVRkZRV3hFTEVWQlFVRkJMR0ZCUVdFc1EwRkJRME1zU1VGQlJDeERRVUZpTzBGQlEwUTdPMEZCUlVRc1UwRkJVMjlFTEZsQlFWUXNRMEZCYzBKd1JDeEpRVUYwUWl4RlFVRTBRazhzU1VGQk5VSXNSVUZCYTBNd1F5eExRVUZzUXl4RlFVRjVRenRCUVVOMlF5eE5RVUZKVHl4VFFVRlRMRWRCUVVkSUxHRkJRV0VzUTBGQlF6bERMRWxCUVVRc1EwRkJOMEk3UVVGQlFTeE5RVU5KYTBRc1dVRkJXU3hIUVVGSFNpeGhRVUZoTEVOQlFVTktMRXRCUVVRc1EwRkVhRU03TzBGQlIwRXNUVUZCU1ZNc1ZVRkJWU3hEUVVGRFJpeFRRVUZFTEVOQlFWWXNTVUZCZVVKRkxGVkJRVlVzUTBGQlEwUXNXVUZCUkN4RFFVRjJReXhGUVVGMVJEdEJRVU55UkR0QlFVTkJPMEZCUVVrN1FVRkJRVHRCUVVGQk96dEJRVUZCUlR0QlFVRkJRVHRCUVVGQlFUdEJRVUZCUVR0QlFVRkJRVHRCUVVGQlFUdEJRVUZCTzBGQlFVRXNTMEZCWjBKSUxGTkJRV2hDTEVWQlFUSkNReXhaUVVFelFpeExRVU5IUnl4clFrRkJhMElzUTBGQlExZ3NTMEZCUkN4RlFVRlJUeXhUUVVGU0xFVkJRVzFDUVN4VFFVRlRMRU5CUVVOb1F5eE5RVUZXTEVkQlFXMUNhVU1zV1VGQldTeERRVUZEYWtNc1RVRkJia1FzUTBGRWVrSXNSVUZEY1VZN1FVRkJRVHRCUVVGQk96dEJRVUZCT3p0QlFVTnVSanM3UVVGQlFUczdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRWGhDTEUxQlFVRkJMRWxCUVVrc1EwRkJRMFVzUzBGQlRDeEZRVUZYTkVJc1NVRkJXRHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVc5Q01FSXNUVUZCUVVFc1UwRkJjRUk3TzBGQlEwRTdRVUZEUkN4TFFVcEVMRTFCU1U4N1FVRkJTVHRCUVVGQk8wRkJRVUU3TzBGQlFVRkhPMEZCUVVGQk8wRkJRVUZCTzBGQlFVRkJPMEZCUVVGQk8wRkJRVUZCTzBGQlFVRTdRVUZCUVN4TFFVRm5Ra1lzV1VGQmFFSXNSVUZCT0VKRUxGTkJRVGxDTEV0QlEwcEpMR3RDUVVGclFpeERRVUZEY2tRc1NVRkJSQ3hGUVVGUGEwUXNXVUZCVUN4RlFVRnhRa0VzV1VGQldTeERRVUZEYWtNc1RVRkJZaXhIUVVGelFtZERMRk5CUVZNc1EwRkJRMmhETEUxQlFYSkVMRU5CUkd4Q0xFVkJRMmRHTzBGQlFVRTdRVUZCUVRzN1FVRkJRVHM3UVVGRGNrWTdPMEZCUVVFN08wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRjRRaXhOUVVGQlFTeEpRVUZKTEVOQlFVTkZMRXRCUVV3c1JVRkJWelJDTEVsQlFWZzdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZ2UWpKQ0xFMUJRVUZCTEZsQlFYQkNPenRCUVVOQk8wRkJRMFE3UVVGRFJpeEhRVmhFTEUxQlYwODdRVUZCU1R0QlFVRkJPMEZCUVVFN08wRkJRVUZKTzBGQlFVRkJPMEZCUVVGQk8wRkJRVUZCTzBGQlFVRkJPMEZCUVVGQk8wRkJRVUU3UVVGQlFTeEhRVUZYVEN4VFFVRllMRVZCUVhOQ1F5eFpRVUYwUWl4RFFVRktMRVZCUVhsRE8wRkJRVUU3UVVGQlFUczdRVUZCUVRzN1FVRkRPVU03TzBGQlFVRTdPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUY2UkN4SlFVRkJRU3hKUVVGSkxFTkJRVU5GTEV0QlFVd3NSVUZCVnpSQ0xFbEJRVmc3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGdlFqQkNMRWxCUVVGQkxGTkJRWEJDT3p0QlFVTkJPMEZCUTBRN08wRkJSVVJpTEVWQlFVRkJMRkZCUVZFc1EwRkJRek5ETEVsQlFVUXNSVUZCVDNkRUxGTkJRVkFzUlVGQmEwSkRMRmxCUVd4Q0xFTkJRVkk3UVVGRFJEczdRVUZGUkN4VFFVRlRTQ3hQUVVGVUxFTkJRV2xDZEVRc1NVRkJha0lzUlVGQmRVSlBMRWxCUVhaQ0xFVkJRVFpDTUVNc1MwRkJOMElzUlVGQmIwTmhMRWxCUVhCRExFVkJRVEJETzBGQlEzaERMRTFCUVVsT0xGTkJRVk1zUjBGQlIwZ3NZVUZCWVN4RFFVRkRPVU1zU1VGQlJDeERRVUUzUWp0QlFVRkJMRTFCUTBsclJDeFpRVUZaTEVkQlFVZE5MR05CUVdNc1EwRkJRMlFzUzBGQlJDeEZRVUZSVHl4VFFVRlNMRU5CUkdwRE96dEJRVVZCTEUxQlFVbERMRmxCUVZrc1EwRkJRMDhzVFVGQmFrSXNSVUZCZVVJN1FVRkJRVHRCUVVGQk96dEJRVUZCT3p0QlFVTjJRanM3UVVGQlFUczdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRV2hGTEVsQlFVRkJMRWxCUVVrc1EwRkJRMFVzUzBGQlRDeEZRVUZYTkVJc1NVRkJXRHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVc5Q01rSXNTVUZCUVVFc1dVRkJXU3hEUVVGRFR5eE5RVUZxUXp0QlFVTkVMRWRCUmtRc1RVRkZUenRCUVVOTWNrSXNTVUZCUVVFc1VVRkJVU3hEUVVGRE0wTXNTVUZCUkN4RlFVRlBPRVFzU1VGQlNTeEhRVUZIVEN4WlFVRklMRWRCUVd0Q1JDeFRRVUUzUWl4RlFVRjNRMDBzU1VGQlNTeEhRVUZIVGl4VFFVRklMRWRCUVdWRExGbEJRVE5FTEVOQlFWSTdRVUZEUkR0QlFVTkdPenRCUVVWRUxGTkJRVk5rTEZGQlFWUXNRMEZCYTBJelF5eEpRVUZzUWl4RlFVRjNRazhzU1VGQmVFSXNSVUZCT0VJd1F5eExRVUU1UWl4RlFVRnhRenRCUVVOdVEycEVMRVZCUVVGQkxFbEJRVWtzUTBGQlF6SkRMRkZCUVV3c1IwRkJaMElzU1VGQmFFSTdRVUZEUVRORExFVkJRVUZCTEVsQlFVa3NRMEZCUTBVc1MwRkJUQ3hEUVVGWE5FSXNTVUZCV0N4RFFVRm5RanRCUVVOa1lTeEpRVUZCUVN4UlFVRlJMRVZCUVVVc1NVRkVTVHRCUVVWa2NFTXNTVUZCUVVFc1NVRkJTU3hGUVVGRlFTeEpRVVpSTzBGQlIyUkRMRWxCUVVGQkxFMUJRVTBzUlVGQlJYbERPMEZCU0Uwc1IwRkJhRUk3UVVGTFJEczdRVUZGUkN4VFFVRlRReXhoUVVGVUxFTkJRWFZDYkVRc1NVRkJka0lzUlVGQk5rSnBSU3hOUVVFM1FpeEZRVUZ4UTJoQ0xFdEJRWEpETEVWQlFUUkRPMEZCUXpGRExGTkJRVTluUWl4TlFVRk5MRU5CUVVOd1FpeE5RVUZRTEVkQlFXZENTU3hMUVVGTExFTkJRVU5LTEUxQlFYUkNMRWxCUVdkRGIwSXNUVUZCVFN4RFFVRkRja1FzUzBGQlVDeEhRVUZsY1VRc1RVRkJUU3hEUVVGREwwUXNTMEZCVUN4RFFVRmhjMElzVFVGQmJrVXNSVUZCTWtVN1FVRkRla1VzVVVGQlNUQkRMRWxCUVVrc1IwRkJSMFFzVFVGQlRTeERRVUZETDBRc1MwRkJVQ3hEUVVGaEswUXNUVUZCVFN4RFFVRkRja1FzUzBGQlVDeEZRVUZpTEVOQlFWZzdRVUZEUVZvc1NVRkJRVUVzU1VGQlNTeERRVUZEUlN4TFFVRk1MRU5CUVZjMFFpeEpRVUZZTEVOQlFXZENiME1zU1VGQmFFSTdRVUZEUVVRc1NVRkJRVUVzVFVGQlRTeERRVUZEY0VJc1RVRkJVRHRCUVVORU8wRkJRMFk3TzBGQlEwUXNVMEZCVTFVc1kwRkJWQ3hEUVVGM1FuWkVMRWxCUVhoQ0xFVkJRVGhDYVVVc1RVRkJPVUlzUlVGQmMwTTdRVUZEY0VNc1UwRkJUMEVzVFVGQlRTeERRVUZEY2tRc1MwRkJVQ3hIUVVGbGNVUXNUVUZCVFN4RFFVRkRMMFFzUzBGQlVDeERRVUZoYzBJc1RVRkJia01zUlVGQk1rTTdRVUZEZWtNc1VVRkJTVEJETEVsQlFVa3NSMEZCUjBRc1RVRkJUU3hEUVVGREwwUXNTMEZCVUN4RFFVRmhLMFFzVFVGQlRTeERRVUZEY2tRc1MwRkJVQ3hGUVVGaUxFTkJRVmc3UVVGRFFWb3NTVUZCUVVFc1NVRkJTU3hEUVVGRFJTeExRVUZNTEVOQlFWYzBRaXhKUVVGWUxFTkJRV2RDYjBNc1NVRkJhRUk3UVVGRFJEdEJRVU5HT3p0QlFVVkVMRk5CUVZOaUxHRkJRVlFzUTBGQmRVSmpMRXRCUVhaQ0xFVkJRVGhDTzBGQlF6VkNMRTFCUVVsNFJDeEhRVUZITEVkQlFVY3NSVUZCVmp0QlFVRkJMRTFCUTBsNVJDeFRRVUZUTEVkQlFVZEVMRXRCUVVzc1EwRkJRMnBGTEV0QlFVNHNRMEZCV1dsRkxFdEJRVXNzUTBGQlEzWkVMRXRCUVd4Q0xFVkJRWGxDTEVOQlFYcENMRU5CUkdoQ096dEJRVVZCTEZOQlFVOTFSQ3hMUVVGTExFTkJRVU4yUkN4TFFVRk9MRWRCUVdOMVJDeExRVUZMTEVOQlFVTnFSU3hMUVVGT0xFTkJRVmx6UWl4TlFVRnFReXhGUVVGNVF6dEJRVU4yUXl4UlFVRkpNRU1zU1VGQlNTeEhRVUZIUXl4TFFVRkxMRU5CUVVOcVJTeExRVUZPTEVOQlFWbHBSU3hMUVVGTExFTkJRVU4yUkN4TFFVRnNRaXhEUVVGWUxFTkJSSFZETEVOQlIzWkRPenRCUVVOQkxGRkJRVWwzUkN4VFFVRlRMRXRCUVVzc1IwRkJaQ3hKUVVGeFFrWXNTVUZCU1N4RFFVRkRMRU5CUVVRc1EwRkJTaXhMUVVGWkxFZEJRWEpETEVWQlFUQkRPMEZCUTNoRFJTeE5RVUZCUVN4VFFVRlRMRWRCUVVjc1IwRkJXanRCUVVORU96dEJRVVZFTEZGQlFVbEJMRk5CUVZNc1MwRkJTMFlzU1VGQlNTeERRVUZETEVOQlFVUXNRMEZCZEVJc1JVRkJNa0k3UVVGRGVrSjJSQ3hOUVVGQlFTeEhRVUZITEVOQlFVTnRRaXhKUVVGS0xFTkJRVk52UXl4SlFVRlVPMEZCUTBGRExFMUJRVUZCTEV0QlFVc3NRMEZCUTNaRUxFdEJRVTQ3UVVGRFJDeExRVWhFTEUxQlIwODdRVUZEVER0QlFVTkVPMEZCUTBZN08wRkJSVVFzVTBGQlQwUXNSMEZCVUR0QlFVTkVPenRCUVVORUxGTkJRVk52UkN4alFVRlVMRU5CUVhkQ1NTeExRVUY0UWl4RlFVRXJRa1VzV1VGQkwwSXNSVUZCTmtNN1FVRkRNME1zVFVGQlNVTXNUMEZCVHl4SFFVRkhMRVZCUVdRN1FVRkJRU3hOUVVOSlRpeE5RVUZOTEVkQlFVY3NSVUZFWWp0QlFVRkJMRTFCUlVsUExGVkJRVlVzUjBGQlJ5eERRVVpxUWp0QlFVRkJMRTFCUjBsRExHTkJRV01zUjBGQlJ5eExRVWh5UWp0QlFVRkJMRTFCU1VsRExGVkJRVlVzUjBGQlJ5eExRVXBxUWpzN1FVRkxRU3hUUVVGUFJpeFZRVUZWTEVkQlFVZEdMRmxCUVZrc1EwRkJRemRETEUxQlFURkNMRWxCUTBVeVF5eExRVUZMTEVOQlFVTjJSQ3hMUVVGT0xFZEJRV04xUkN4TFFVRkxMRU5CUVVOcVJTeExRVUZPTEVOQlFWbHpRaXhOUVVSdVF5eEZRVU15UXp0QlFVTjZReXhSUVVGSmEwUXNUVUZCVFN4SFFVRkhVQ3hMUVVGTExFTkJRVU5xUlN4TFFVRk9MRU5CUVZscFJTeExRVUZMTEVOQlFVTjJSQ3hMUVVGc1FpeERRVUZpTzBGQlFVRXNVVUZEU1N0RUxFdEJRVXNzUjBGQlIwNHNXVUZCV1N4RFFVRkRSU3hWUVVGRUxFTkJSSGhDTEVOQlJIbERMRU5CU1hwRE96dEJRVU5CTEZGQlFVbEpMRXRCUVVzc1EwRkJReXhEUVVGRUxFTkJRVXdzUzBGQllTeEhRVUZxUWl4RlFVRnpRanRCUVVOd1FqdEJRVU5FT3p0QlFVVkVTQ3hKUVVGQlFTeGpRVUZqTEVkQlFVZEJMR05CUVdNc1NVRkJTVVVzVFVGQlRTeERRVUZETEVOQlFVUXNRMEZCVGl4TFFVRmpMRWRCUVdwRU8wRkJSVUZXTEVsQlFVRkJMRTFCUVUwc1EwRkJRMnhETEVsQlFWQXNRMEZCV1RaRExFdEJRVm83UVVGRFFVb3NTVUZCUVVFc1ZVRkJWU3hIUVZvclFpeERRV042UXp0QlFVTkJPenRCUVVOQkxGRkJRVWxITEUxQlFVMHNRMEZCUXl4RFFVRkVMRU5CUVU0c1MwRkJZeXhIUVVGc1FpeEZRVUYxUWp0QlFVTnlRa1FzVFVGQlFVRXNWVUZCVlN4SFFVRkhMRWxCUVdJN08wRkJSVUVzWVVGQlQwTXNUVUZCVFN4RFFVRkRMRU5CUVVRc1EwRkJUaXhMUVVGakxFZEJRWEpDTEVWQlFUQkNPMEZCUTNoQ1NpeFJRVUZCUVN4UFFVRlBMRU5CUVVONFF5eEpRVUZTTEVOQlFXRTBReXhOUVVGaU8wRkJRMEZCTEZGQlFVRkJMRTFCUVUwc1IwRkJSMUFzUzBGQlN5eERRVUZEYWtVc1MwRkJUaXhEUVVGWkxFVkJRVVZwUlN4TFFVRkxMRU5CUVVOMlJDeExRVUZ3UWl4RFFVRlVPMEZCUTBRN1FVRkRSanM3UVVGRlJDeFJRVUZKSzBRc1MwRkJTeXhEUVVGRFF5eE5RVUZPTEVOQlFXRXNRMEZCWWl4TlFVRnZRa1lzVFVGQlRTeERRVUZEUlN4TlFVRlFMRU5CUVdNc1EwRkJaQ3hEUVVGNFFpeEZRVUV3UXp0QlFVTjRRMDRzVFVGQlFVRXNUMEZCVHl4RFFVRkRlRU1zU1VGQlVpeERRVUZoTkVNc1RVRkJZanRCUVVOQlVDeE5RVUZCUVN4TFFVRkxMRU5CUVVOMlJDeExRVUZPTzBGQlEwUXNTMEZJUkN4TlFVZFBPMEZCUTB3MlJDeE5RVUZCUVN4VlFVRlZMRWRCUVVjc1NVRkJZanRCUVVORU8wRkJRMFk3TzBGQlJVUXNUVUZCU1N4RFFVRkRTaXhaUVVGWkxFTkJRVU5GTEZWQlFVUXNRMEZCV2l4SlFVRTBRaXhGUVVFM1FpeEZRVUZwUXl4RFFVRnFReXhOUVVGM1F5eEhRVUY0UXl4SlFVTkhReXhqUVVSUUxFVkJRM1ZDTzBGQlEzSkNReXhKUVVGQlFTeFZRVUZWTEVkQlFVY3NTVUZCWWp0QlFVTkVPenRCUVVWRUxFMUJRVWxCTEZWQlFVb3NSVUZCWjBJN1FVRkRaQ3hYUVVGUFNDeFBRVUZRTzBGQlEwUTdPMEZCUlVRc1UwRkJUME1zVlVGQlZTeEhRVUZIUml4WlFVRlpMRU5CUVVNM1F5eE5RVUZxUXl4RlFVRjVRenRCUVVOMlEzZERMRWxCUVVGQkxFMUJRVTBzUTBGQlEyeERMRWxCUVZBc1EwRkJXWFZETEZsQlFWa3NRMEZCUTBVc1ZVRkJWU3hGUVVGWUxFTkJRWGhDTzBGQlEwUTdPMEZCUlVRc1UwRkJUenRCUVVOTVVDeEpRVUZCUVN4TlFVRk5MRVZCUVU1QkxFMUJSRXM3UVVGRlRFMHNTVUZCUVVFc1QwRkJUeXhGUVVGUVFUdEJRVVpMTEVkQlFWQTdRVUZKUkRzN1FVRkZSQ3hUUVVGVFdpeFZRVUZVTEVOQlFXOUNXU3hQUVVGd1FpeEZRVUUyUWp0QlFVTXpRaXhUUVVGUFFTeFBRVUZQTEVOQlFVTlBMRTFCUVZJc1EwRkJaU3hWUVVGVFF5eEpRVUZVTEVWQlFXVktMRTFCUVdZc1JVRkJkVUk3UVVGRE0wTXNWMEZCVDBrc1NVRkJTU3hKUVVGSlNpeE5RVUZOTEVOQlFVTXNRMEZCUkN4RFFVRk9MRXRCUVdNc1IwRkJOMEk3UVVGRFJDeEhRVVpOTEVWQlJVb3NTVUZHU1N4RFFVRlFPMEZCUjBRN08wRkJRMFFzVTBGQlUyUXNhMEpCUVZRc1EwRkJORUpQTEV0QlFUVkNMRVZCUVcxRFdTeGhRVUZ1UXl4RlFVRnJSRU1zUzBGQmJFUXNSVUZCZVVRN1FVRkRka1FzVDBGQlN5eEpRVUZKUXl4RFFVRkRMRWRCUVVjc1EwRkJZaXhGUVVGblFrRXNRMEZCUXl4SFFVRkhSQ3hMUVVGd1FpeEZRVUV5UWtNc1EwRkJReXhGUVVFMVFpeEZRVUZuUXp0QlFVTTVRaXhSUVVGSlF5eGhRVUZoTEVkQlFVZElMR0ZCUVdFc1EwRkJRMEVzWVVGQllTeERRVUZEZGtRc1RVRkJaQ3hIUVVGMVFuZEVMRXRCUVhaQ0xFZEJRU3RDUXl4RFFVRm9ReXhEUVVGaUxFTkJRV2RFVEN4TlFVRm9SQ3hEUVVGMVJDeERRVUYyUkN4RFFVRndRanM3UVVGRFFTeFJRVUZKVkN4TFFVRkxMRU5CUVVOcVJTeExRVUZPTEVOQlFWbHBSU3hMUVVGTExFTkJRVU4yUkN4TFFVRk9MRWRCUVdOeFJTeERRVUV4UWl4TlFVRnBReXhOUVVGTlF5eGhRVUV6UXl4RlFVRXdSRHRCUVVONFJDeGhRVUZQTEV0QlFWQTdRVUZEUkR0QlFVTkdPenRCUVVWRVppeEZRVUZCUVN4TFFVRkxMRU5CUVVOMlJDeExRVUZPTEVsQlFXVnZSU3hMUVVGbU8wRkJRMEVzVTBGQlR5eEpRVUZRTzBGQlEwUTdPMEZCUlVRc1UwRkJVeTlGTEcxQ1FVRlVMRU5CUVRaQ1F5eExRVUUzUWl4RlFVRnZRenRCUVVOc1F5eE5RVUZKUXl4UlFVRlJMRWRCUVVjc1EwRkJaanRCUVVOQkxFMUJRVWxETEZGQlFWRXNSMEZCUnl4RFFVRm1PMEZCUlVGR0xFVkJRVUZCTEV0QlFVc3NRMEZCUTJsR0xFOUJRVTRzUTBGQll5eFZRVUZUYWtJc1NVRkJWQ3hGUVVGbE8wRkJRek5DTEZGQlFVa3NUMEZCVDBFc1NVRkJVQ3hMUVVGblFpeFJRVUZ3UWl4RlFVRTRRanRCUVVNMVFpeFZRVUZKYTBJc1QwRkJUeXhIUVVGSGJrWXNiVUpCUVcxQ0xFTkJRVU5wUlN4SlFVRkpMRU5CUVVNelJDeEpRVUZPTEVOQlFXcERPMEZCUTBFc1ZVRkJTVGhGTEZWQlFWVXNSMEZCUjNCR0xHMUNRVUZ0UWl4RFFVRkRhVVVzU1VGQlNTeERRVUZETVVRc1RVRkJUaXhEUVVGd1F6czdRVUZGUVN4VlFVRkpUQ3hSUVVGUkxFdEJRVXRGTEZOQlFXcENMRVZCUVRSQ08wRkJRekZDTEZsQlFVa3JSU3hQUVVGUExFTkJRVU5xUml4UlFVRlNMRXRCUVhGQ2EwWXNWVUZCVlN4RFFVRkRiRVlzVVVGQmNFTXNSVUZCT0VNN1FVRkROVU5CTEZWQlFVRkJMRkZCUVZFc1NVRkJTV2xHTEU5QlFVOHNRMEZCUTJwR0xGRkJRWEJDTzBGQlEwUXNVMEZHUkN4TlFVVlBPMEZCUTB4QkxGVkJRVUZCTEZGQlFWRXNSMEZCUjBVc1UwRkJXRHRCUVVORU8wRkJRMFk3TzBGQlJVUXNWVUZCU1VRc1VVRkJVU3hMUVVGTFF5eFRRVUZxUWl4RlFVRTBRanRCUVVNeFFpeFpRVUZKSzBVc1QwRkJUeXhEUVVGRGFFWXNVVUZCVWl4TFFVRnhRbWxHTEZWQlFWVXNRMEZCUTJwR0xGRkJRWEJETEVWQlFUaERPMEZCUXpWRFFTeFZRVUZCUVN4UlFVRlJMRWxCUVVsblJpeFBRVUZQTEVOQlFVTm9SaXhSUVVGd1FqdEJRVU5FTEZOQlJrUXNUVUZGVHp0QlFVTk1RU3hWUVVGQlFTeFJRVUZSTEVkQlFVZERMRk5CUVZnN1FVRkRSRHRCUVVOR08wRkJRMFlzUzBGdVFrUXNUVUZ0UWs4N1FVRkRUQ3hWUVVGSlJDeFJRVUZSTEV0QlFVdERMRk5CUVdJc1MwRkJNa0kyUkN4SlFVRkpMRU5CUVVNc1EwRkJSQ3hEUVVGS0xFdEJRVmtzUjBGQldpeEpRVUZ0UWtFc1NVRkJTU3hEUVVGRExFTkJRVVFzUTBGQlNpeExRVUZaTEVkQlFURkVMRU5CUVVvc1JVRkJiMFU3UVVGRGJFVTVSQ3hSUVVGQlFTeFJRVUZSTzBGQlExUTdPMEZCUTBRc1ZVRkJTVVFzVVVGQlVTeExRVUZMUlN4VFFVRmlMRXRCUVRKQ05rUXNTVUZCU1N4RFFVRkRMRU5CUVVRc1EwRkJTaXhMUVVGWkxFZEJRVm9zU1VGQmJVSkJMRWxCUVVrc1EwRkJReXhEUVVGRUxFTkJRVW9zUzBGQldTeEhRVUV4UkN4RFFVRktMRVZCUVc5Rk8wRkJRMnhGTDBRc1VVRkJRVUVzVVVGQlVUdEJRVU5VTzBGQlEwWTdRVUZEUml4SFFUVkNSRHRCUVRoQ1FTeFRRVUZQTzBGQlFVTkJMRWxCUVVGQkxGRkJRVkVzUlVGQlVrRXNVVUZCUkR0QlFVRlhReXhKUVVGQlFTeFJRVUZSTEVWQlFWSkJPMEZCUVZnc1IwRkJVRHRCUVVORUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lhVzF3YjNKMElIdHpkSEoxWTNSMWNtVmtVR0YwWTJoOUlHWnliMjBnSnk0dlkzSmxZWFJsSnp0Y2JtbHRjRzl5ZENCN2NHRnljMlZRWVhSamFIMGdabkp2YlNBbkxpOXdZWEp6WlNjN1hHNWNibWx0Y0c5eWRDQjdZWEp5WVhsRmNYVmhiQ3dnWVhKeVlYbFRkR0Z5ZEhOWGFYUm9mU0JtY205dElDY3VMaTkxZEdsc0wyRnljbUY1Snp0Y2JseHVaWGh3YjNKMElHWjFibU4wYVc5dUlHTmhiR05NYVc1bFEyOTFiblFvYUhWdWF5a2dlMXh1SUNCamIyNXpkQ0I3YjJ4a1RHbHVaWE1zSUc1bGQweHBibVZ6ZlNBOUlHTmhiR05QYkdST1pYZE1hVzVsUTI5MWJuUW9hSFZ1YXk1c2FXNWxjeWs3WEc1Y2JpQWdhV1lnS0c5c1pFeHBibVZ6SUNFOVBTQjFibVJsWm1sdVpXUXBJSHRjYmlBZ0lDQm9kVzVyTG05c1pFeHBibVZ6SUQwZ2IyeGtUR2x1WlhNN1hHNGdJSDBnWld4elpTQjdYRzRnSUNBZ1pHVnNaWFJsSUdoMWJtc3ViMnhrVEdsdVpYTTdYRzRnSUgxY2JseHVJQ0JwWmlBb2JtVjNUR2x1WlhNZ0lUMDlJSFZ1WkdWbWFXNWxaQ2tnZTF4dUlDQWdJR2gxYm1zdWJtVjNUR2x1WlhNZ1BTQnVaWGRNYVc1bGN6dGNiaUFnZlNCbGJITmxJSHRjYmlBZ0lDQmtaV3hsZEdVZ2FIVnVheTV1WlhkTWFXNWxjenRjYmlBZ2ZWeHVmVnh1WEc1bGVIQnZjblFnWm5WdVkzUnBiMjRnYldWeVoyVW9iV2x1WlN3Z2RHaGxhWEp6TENCaVlYTmxLU0I3WEc0Z0lHMXBibVVnUFNCc2IyRmtVR0YwWTJnb2JXbHVaU3dnWW1GelpTazdYRzRnSUhSb1pXbHljeUE5SUd4dllXUlFZWFJqYUNoMGFHVnBjbk1zSUdKaGMyVXBPMXh1WEc0Z0lHeGxkQ0J5WlhRZ1BTQjdmVHRjYmx4dUlDQXZMeUJHYjNJZ2FXNWtaWGdnZDJVZ2FuVnpkQ0JzWlhRZ2FYUWdjR0Z6Y3lCMGFISnZkV2RvSUdGeklHbDBJR1J2WlhOdUozUWdhR0YyWlNCaGJua2dibVZqWlhOellYSjVJRzFsWVc1cGJtY3VYRzRnSUM4dklFeGxZWFpwYm1jZ2MyRnVhWFI1SUdOb1pXTnJjeUJ2YmlCMGFHbHpJSFJ2SUhSb1pTQkJVRWtnWTI5dWMzVnRaWElnZEdoaGRDQnRZWGtnYTI1dmR5QnRiM0psSUdGaWIzVjBJSFJvWlZ4dUlDQXZMeUJ0WldGdWFXNW5JR2x1SUhSb1pXbHlJRzkzYmlCamIyNTBaWGgwTGx4dUlDQnBaaUFvYldsdVpTNXBibVJsZUNCOGZDQjBhR1ZwY25NdWFXNWtaWGdwSUh0Y2JpQWdJQ0J5WlhRdWFXNWtaWGdnUFNCdGFXNWxMbWx1WkdWNElIeDhJSFJvWldseWN5NXBibVJsZUR0Y2JpQWdmVnh1WEc0Z0lHbG1JQ2h0YVc1bExtNWxkMFpwYkdWT1lXMWxJSHg4SUhSb1pXbHljeTV1WlhkR2FXeGxUbUZ0WlNrZ2UxeHVJQ0FnSUdsbUlDZ2habWxzWlU1aGJXVkRhR0Z1WjJWa0tHMXBibVVwS1NCN1hHNGdJQ0FnSUNBdkx5Qk9ieUJvWldGa1pYSWdiM0lnYm04Z1kyaGhibWRsSUdsdUlHOTFjbk1zSUhWelpTQjBhR1ZwY25NZ0tHRnVaQ0J2ZFhKeklHbG1JSFJvWldseWN5QmtiMlZ6SUc1dmRDQmxlR2x6ZENsY2JpQWdJQ0FnSUhKbGRDNXZiR1JHYVd4bFRtRnRaU0E5SUhSb1pXbHljeTV2YkdSR2FXeGxUbUZ0WlNCOGZDQnRhVzVsTG05c1pFWnBiR1ZPWVcxbE8xeHVJQ0FnSUNBZ2NtVjBMbTVsZDBacGJHVk9ZVzFsSUQwZ2RHaGxhWEp6TG01bGQwWnBiR1ZPWVcxbElIeDhJRzFwYm1VdWJtVjNSbWxzWlU1aGJXVTdYRzRnSUNBZ0lDQnlaWFF1YjJ4a1NHVmhaR1Z5SUQwZ2RHaGxhWEp6TG05c1pFaGxZV1JsY2lCOGZDQnRhVzVsTG05c1pFaGxZV1JsY2p0Y2JpQWdJQ0FnSUhKbGRDNXVaWGRJWldGa1pYSWdQU0IwYUdWcGNuTXVibVYzU0dWaFpHVnlJSHg4SUcxcGJtVXVibVYzU0dWaFpHVnlPMXh1SUNBZ0lIMGdaV3h6WlNCcFppQW9JV1pwYkdWT1lXMWxRMmhoYm1kbFpDaDBhR1ZwY25NcEtTQjdYRzRnSUNBZ0lDQXZMeUJPYnlCb1pXRmtaWElnYjNJZ2JtOGdZMmhoYm1kbElHbHVJSFJvWldseWN5d2dkWE5sSUc5MWNuTmNiaUFnSUNBZ0lISmxkQzV2YkdSR2FXeGxUbUZ0WlNBOUlHMXBibVV1YjJ4a1JtbHNaVTVoYldVN1hHNGdJQ0FnSUNCeVpYUXVibVYzUm1sc1pVNWhiV1VnUFNCdGFXNWxMbTVsZDBacGJHVk9ZVzFsTzF4dUlDQWdJQ0FnY21WMExtOXNaRWhsWVdSbGNpQTlJRzFwYm1VdWIyeGtTR1ZoWkdWeU8xeHVJQ0FnSUNBZ2NtVjBMbTVsZDBobFlXUmxjaUE5SUcxcGJtVXVibVYzU0dWaFpHVnlPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBdkx5QkNiM1JvSUdOb1lXNW5aV1F1TGk0Z1ptbG5kWEpsSUdsMElHOTFkRnh1SUNBZ0lDQWdjbVYwTG05c1pFWnBiR1ZPWVcxbElEMGdjMlZzWldOMFJtbGxiR1FvY21WMExDQnRhVzVsTG05c1pFWnBiR1ZPWVcxbExDQjBhR1ZwY25NdWIyeGtSbWxzWlU1aGJXVXBPMXh1SUNBZ0lDQWdjbVYwTG01bGQwWnBiR1ZPWVcxbElEMGdjMlZzWldOMFJtbGxiR1FvY21WMExDQnRhVzVsTG01bGQwWnBiR1ZPWVcxbExDQjBhR1ZwY25NdWJtVjNSbWxzWlU1aGJXVXBPMXh1SUNBZ0lDQWdjbVYwTG05c1pFaGxZV1JsY2lBOUlITmxiR1ZqZEVacFpXeGtLSEpsZEN3Z2JXbHVaUzV2YkdSSVpXRmtaWElzSUhSb1pXbHljeTV2YkdSSVpXRmtaWElwTzF4dUlDQWdJQ0FnY21WMExtNWxkMGhsWVdSbGNpQTlJSE5sYkdWamRFWnBaV3hrS0hKbGRDd2diV2x1WlM1dVpYZElaV0ZrWlhJc0lIUm9aV2x5Y3k1dVpYZElaV0ZrWlhJcE8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lISmxkQzVvZFc1cmN5QTlJRnRkTzF4dVhHNGdJR3hsZENCdGFXNWxTVzVrWlhnZ1BTQXdMRnh1SUNBZ0lDQWdkR2hsYVhKelNXNWtaWGdnUFNBd0xGeHVJQ0FnSUNBZ2JXbHVaVTltWm5ObGRDQTlJREFzWEc0Z0lDQWdJQ0IwYUdWcGNuTlBabVp6WlhRZ1BTQXdPMXh1WEc0Z0lIZG9hV3hsSUNodGFXNWxTVzVrWlhnZ1BDQnRhVzVsTG1oMWJtdHpMbXhsYm1kMGFDQjhmQ0IwYUdWcGNuTkpibVJsZUNBOElIUm9aV2x5Y3k1b2RXNXJjeTVzWlc1bmRHZ3BJSHRjYmlBZ0lDQnNaWFFnYldsdVpVTjFjbkpsYm5RZ1BTQnRhVzVsTG1oMWJtdHpXMjFwYm1WSmJtUmxlRjBnZkh3Z2UyOXNaRk4wWVhKME9pQkpibVpwYm1sMGVYMHNYRzRnSUNBZ0lDQWdJSFJvWldseWMwTjFjbkpsYm5RZ1BTQjBhR1ZwY25NdWFIVnVhM05iZEdobGFYSnpTVzVrWlhoZElIeDhJSHR2YkdSVGRHRnlkRG9nU1c1bWFXNXBkSGw5TzF4dVhHNGdJQ0FnYVdZZ0tHaDFibXRDWldadmNtVW9iV2x1WlVOMWNuSmxiblFzSUhSb1pXbHljME4xY25KbGJuUXBLU0I3WEc0Z0lDQWdJQ0F2THlCVWFHbHpJSEJoZEdOb0lHUnZaWE1nYm05MElHOTJaWEpzWVhBZ2QybDBhQ0JoYm5rZ2IyWWdkR2hsSUc5MGFHVnljeXdnZVdGNUxseHVJQ0FnSUNBZ2NtVjBMbWgxYm10ekxuQjFjMmdvWTJ4dmJtVklkVzVyS0cxcGJtVkRkWEp5Wlc1MExDQnRhVzVsVDJabWMyVjBLU2s3WEc0Z0lDQWdJQ0J0YVc1bFNXNWtaWGdyS3p0Y2JpQWdJQ0FnSUhSb1pXbHljMDltWm5ObGRDQXJQU0J0YVc1bFEzVnljbVZ1ZEM1dVpYZE1hVzVsY3lBdElHMXBibVZEZFhKeVpXNTBMbTlzWkV4cGJtVnpPMXh1SUNBZ0lIMGdaV3h6WlNCcFppQW9hSFZ1YTBKbFptOXlaU2gwYUdWcGNuTkRkWEp5Wlc1MExDQnRhVzVsUTNWeWNtVnVkQ2twSUh0Y2JpQWdJQ0FnSUM4dklGUm9hWE1nY0dGMFkyZ2daRzlsY3lCdWIzUWdiM1psY214aGNDQjNhWFJvSUdGdWVTQnZaaUIwYUdVZ2IzUm9aWEp6TENCNVlYa3VYRzRnSUNBZ0lDQnlaWFF1YUhWdWEzTXVjSFZ6YUNoamJHOXVaVWgxYm1zb2RHaGxhWEp6UTNWeWNtVnVkQ3dnZEdobGFYSnpUMlptYzJWMEtTazdYRzRnSUNBZ0lDQjBhR1ZwY25OSmJtUmxlQ3NyTzF4dUlDQWdJQ0FnYldsdVpVOW1abk5sZENBclBTQjBhR1ZwY25ORGRYSnlaVzUwTG01bGQweHBibVZ6SUMwZ2RHaGxhWEp6UTNWeWNtVnVkQzV2YkdSTWFXNWxjenRjYmlBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0x5OGdUM1psY214aGNDd2diV1Z5WjJVZ1lYTWdZbVZ6ZENCM1pTQmpZVzVjYmlBZ0lDQWdJR3hsZENCdFpYSm5aV1JJZFc1cklEMGdlMXh1SUNBZ0lDQWdJQ0J2YkdSVGRHRnlkRG9nVFdGMGFDNXRhVzRvYldsdVpVTjFjbkpsYm5RdWIyeGtVM1JoY25Rc0lIUm9aV2x5YzBOMWNuSmxiblF1YjJ4a1UzUmhjblFwTEZ4dUlDQWdJQ0FnSUNCdmJHUk1hVzVsY3pvZ01DeGNiaUFnSUNBZ0lDQWdibVYzVTNSaGNuUTZJRTFoZEdndWJXbHVLRzFwYm1WRGRYSnlaVzUwTG01bGQxTjBZWEowSUNzZ2JXbHVaVTltWm5ObGRDd2dkR2hsYVhKelEzVnljbVZ1ZEM1dmJHUlRkR0Z5ZENBcklIUm9aV2x5YzA5bVpuTmxkQ2tzWEc0Z0lDQWdJQ0FnSUc1bGQweHBibVZ6T2lBd0xGeHVJQ0FnSUNBZ0lDQnNhVzVsY3pvZ1cxMWNiaUFnSUNBZ0lIMDdYRzRnSUNBZ0lDQnRaWEpuWlV4cGJtVnpLRzFsY21kbFpFaDFibXNzSUcxcGJtVkRkWEp5Wlc1MExtOXNaRk4wWVhKMExDQnRhVzVsUTNWeWNtVnVkQzVzYVc1bGN5d2dkR2hsYVhKelEzVnljbVZ1ZEM1dmJHUlRkR0Z5ZEN3Z2RHaGxhWEp6UTNWeWNtVnVkQzVzYVc1bGN5azdYRzRnSUNBZ0lDQjBhR1ZwY25OSmJtUmxlQ3NyTzF4dUlDQWdJQ0FnYldsdVpVbHVaR1Y0S3lzN1hHNWNiaUFnSUNBZ0lISmxkQzVvZFc1cmN5NXdkWE5vS0cxbGNtZGxaRWgxYm1zcE8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCeVpYUTdYRzU5WEc1Y2JtWjFibU4wYVc5dUlHeHZZV1JRWVhSamFDaHdZWEpoYlN3Z1ltRnpaU2tnZTF4dUlDQnBaaUFvZEhsd1pXOW1JSEJoY21GdElEMDlQU0FuYzNSeWFXNW5KeWtnZTF4dUlDQWdJR2xtSUNnb0wxNUFRQzl0S1M1MFpYTjBLSEJoY21GdEtTQjhmQ0FvS0M5ZVNXNWtaWGc2TDIwcExuUmxjM1FvY0dGeVlXMHBLU2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJSEJoY25ObFVHRjBZMmdvY0dGeVlXMHBXekJkTzF4dUlDQWdJSDFjYmx4dUlDQWdJR2xtSUNnaFltRnpaU2tnZTF4dUlDQWdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2ROZFhOMElIQnliM1pwWkdVZ1lTQmlZWE5sSUhKbFptVnlaVzVqWlNCdmNpQndZWE56SUdsdUlHRWdjR0YwWTJnbktUdGNiaUFnSUNCOVhHNGdJQ0FnY21WMGRYSnVJSE4wY25WamRIVnlaV1JRWVhSamFDaDFibVJsWm1sdVpXUXNJSFZ1WkdWbWFXNWxaQ3dnWW1GelpTd2djR0Z5WVcwcE8xeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlIQmhjbUZ0TzF4dWZWeHVYRzVtZFc1amRHbHZiaUJtYVd4bFRtRnRaVU5vWVc1blpXUW9jR0YwWTJncElIdGNiaUFnY21WMGRYSnVJSEJoZEdOb0xtNWxkMFpwYkdWT1lXMWxJQ1ltSUhCaGRHTm9MbTVsZDBacGJHVk9ZVzFsSUNFOVBTQndZWFJqYUM1dmJHUkdhV3hsVG1GdFpUdGNibjFjYmx4dVpuVnVZM1JwYjI0Z2MyVnNaV04wUm1sbGJHUW9hVzVrWlhnc0lHMXBibVVzSUhSb1pXbHljeWtnZTF4dUlDQnBaaUFvYldsdVpTQTlQVDBnZEdobGFYSnpLU0I3WEc0Z0lDQWdjbVYwZFhKdUlHMXBibVU3WEc0Z0lIMGdaV3h6WlNCN1hHNGdJQ0FnYVc1a1pYZ3VZMjl1Wm14cFkzUWdQU0IwY25WbE8xeHVJQ0FnSUhKbGRIVnliaUI3YldsdVpTd2dkR2hsYVhKemZUdGNiaUFnZlZ4dWZWeHVYRzVtZFc1amRHbHZiaUJvZFc1clFtVm1iM0psS0hSbGMzUXNJR05vWldOcktTQjdYRzRnSUhKbGRIVnliaUIwWlhOMExtOXNaRk4wWVhKMElEd2dZMmhsWTJzdWIyeGtVM1JoY25SY2JpQWdJQ0FtSmlBb2RHVnpkQzV2YkdSVGRHRnlkQ0FySUhSbGMzUXViMnhrVEdsdVpYTXBJRHdnWTJobFkyc3ViMnhrVTNSaGNuUTdYRzU5WEc1Y2JtWjFibU4wYVc5dUlHTnNiMjVsU0hWdWF5aG9kVzVyTENCdlptWnpaWFFwSUh0Y2JpQWdjbVYwZFhKdUlIdGNiaUFnSUNCdmJHUlRkR0Z5ZERvZ2FIVnVheTV2YkdSVGRHRnlkQ3dnYjJ4a1RHbHVaWE02SUdoMWJtc3ViMnhrVEdsdVpYTXNYRzRnSUNBZ2JtVjNVM1JoY25RNklHaDFibXN1Ym1WM1UzUmhjblFnS3lCdlptWnpaWFFzSUc1bGQweHBibVZ6T2lCb2RXNXJMbTVsZDB4cGJtVnpMRnh1SUNBZ0lHeHBibVZ6T2lCb2RXNXJMbXhwYm1WelhHNGdJSDA3WEc1OVhHNWNibVoxYm1OMGFXOXVJRzFsY21kbFRHbHVaWE1vYUhWdWF5d2diV2x1WlU5bVpuTmxkQ3dnYldsdVpVeHBibVZ6TENCMGFHVnBjazltWm5ObGRDd2dkR2hsYVhKTWFXNWxjeWtnZTF4dUlDQXZMeUJVYUdseklIZHBiR3dnWjJWdVpYSmhiR3g1SUhKbGMzVnNkQ0JwYmlCaElHTnZibVpzYVdOMFpXUWdhSFZ1YXl3Z1luVjBJSFJvWlhKbElHRnlaU0JqWVhObGN5QjNhR1Z5WlNCMGFHVWdZMjl1ZEdWNGRGeHVJQ0F2THlCcGN5QjBhR1VnYjI1c2VTQnZkbVZ5YkdGd0lIZG9aWEpsSUhkbElHTmhiaUJ6ZFdOalpYTnpablZzYkhrZ2JXVnlaMlVnZEdobElHTnZiblJsYm5RZ2FHVnlaUzVjYmlBZ2JHVjBJRzFwYm1VZ1BTQjdiMlptYzJWME9pQnRhVzVsVDJabWMyVjBMQ0JzYVc1bGN6b2diV2x1WlV4cGJtVnpMQ0JwYm1SbGVEb2dNSDBzWEc0Z0lDQWdJQ0IwYUdWcGNpQTlJSHR2Wm1aelpYUTZJSFJvWldseVQyWm1jMlYwTENCc2FXNWxjem9nZEdobGFYSk1hVzVsY3l3Z2FXNWtaWGc2SURCOU8xeHVYRzRnSUM4dklFaGhibVJzWlNCaGJua2diR1ZoWkdsdVp5QmpiMjUwWlc1MFhHNGdJR2x1YzJWeWRFeGxZV1JwYm1jb2FIVnVheXdnYldsdVpTd2dkR2hsYVhJcE8xeHVJQ0JwYm5ObGNuUk1aV0ZrYVc1bktHaDFibXNzSUhSb1pXbHlMQ0J0YVc1bEtUdGNibHh1SUNBdkx5Qk9iM2NnYVc0Z2RHaGxJRzkyWlhKc1lYQWdZMjl1ZEdWdWRDNGdVMk5oYmlCMGFISnZkV2RvSUdGdVpDQnpaV3hsWTNRZ2RHaGxJR0psYzNRZ1kyaGhibWRsY3lCbWNtOXRJR1ZoWTJndVhHNGdJSGRvYVd4bElDaHRhVzVsTG1sdVpHVjRJRHdnYldsdVpTNXNhVzVsY3k1c1pXNW5kR2dnSmlZZ2RHaGxhWEl1YVc1a1pYZ2dQQ0IwYUdWcGNpNXNhVzVsY3k1c1pXNW5kR2dwSUh0Y2JpQWdJQ0JzWlhRZ2JXbHVaVU4xY25KbGJuUWdQU0J0YVc1bExteHBibVZ6VzIxcGJtVXVhVzVrWlhoZExGeHVJQ0FnSUNBZ0lDQjBhR1ZwY2tOMWNuSmxiblFnUFNCMGFHVnBjaTVzYVc1bGMxdDBhR1ZwY2k1cGJtUmxlRjA3WEc1Y2JpQWdJQ0JwWmlBb0tHMXBibVZEZFhKeVpXNTBXekJkSUQwOVBTQW5MU2NnZkh3Z2JXbHVaVU4xY25KbGJuUmJNRjBnUFQwOUlDY3JKeWxjYmlBZ0lDQWdJQ0FnSmlZZ0tIUm9aV2x5UTNWeWNtVnVkRnN3WFNBOVBUMGdKeTBuSUh4OElIUm9aV2x5UTNWeWNtVnVkRnN3WFNBOVBUMGdKeXNuS1NrZ2UxeHVJQ0FnSUNBZ0x5OGdRbTkwYUNCdGIyUnBabWxsWkNBdUxpNWNiaUFnSUNBZ0lHMTFkSFZoYkVOb1lXNW5aU2hvZFc1ckxDQnRhVzVsTENCMGFHVnBjaWs3WEc0Z0lDQWdmU0JsYkhObElHbG1JQ2h0YVc1bFEzVnljbVZ1ZEZzd1hTQTlQVDBnSnlzbklDWW1JSFJvWldseVEzVnljbVZ1ZEZzd1hTQTlQVDBnSnlBbktTQjdYRzRnSUNBZ0lDQXZMeUJOYVc1bElHbHVjMlZ5ZEdWa1hHNGdJQ0FnSUNCb2RXNXJMbXhwYm1WekxuQjFjMmdvTGk0dUlHTnZiR3hsWTNSRGFHRnVaMlVvYldsdVpTa3BPMXh1SUNBZ0lIMGdaV3h6WlNCcFppQW9kR2hsYVhKRGRYSnlaVzUwV3pCZElEMDlQU0FuS3ljZ0ppWWdiV2x1WlVOMWNuSmxiblJiTUYwZ1BUMDlJQ2NnSnlrZ2UxeHVJQ0FnSUNBZ0x5OGdWR2hsYVhKeklHbHVjMlZ5ZEdWa1hHNGdJQ0FnSUNCb2RXNXJMbXhwYm1WekxuQjFjMmdvTGk0dUlHTnZiR3hsWTNSRGFHRnVaMlVvZEdobGFYSXBLVHRjYmlBZ0lDQjlJR1ZzYzJVZ2FXWWdLRzFwYm1WRGRYSnlaVzUwV3pCZElEMDlQU0FuTFNjZ0ppWWdkR2hsYVhKRGRYSnlaVzUwV3pCZElEMDlQU0FuSUNjcElIdGNiaUFnSUNBZ0lDOHZJRTFwYm1VZ2NtVnRiM1psWkNCdmNpQmxaR2wwWldSY2JpQWdJQ0FnSUhKbGJXOTJZV3dvYUhWdWF5d2diV2x1WlN3Z2RHaGxhWElwTzF4dUlDQWdJSDBnWld4elpTQnBaaUFvZEdobGFYSkRkWEp5Wlc1MFd6QmRJRDA5UFNBbkxTY2dKaVlnYldsdVpVTjFjbkpsYm5SYk1GMGdQVDA5SUNjZ0p5a2dlMXh1SUNBZ0lDQWdMeThnVkdobGFYSWdjbVZ0YjNabFpDQnZjaUJsWkdsMFpXUmNiaUFnSUNBZ0lISmxiVzkyWVd3b2FIVnVheXdnZEdobGFYSXNJRzFwYm1Vc0lIUnlkV1VwTzF4dUlDQWdJSDBnWld4elpTQnBaaUFvYldsdVpVTjFjbkpsYm5RZ1BUMDlJSFJvWldseVEzVnljbVZ1ZENrZ2UxeHVJQ0FnSUNBZ0x5OGdRMjl1ZEdWNGRDQnBaR1Z1ZEdsMGVWeHVJQ0FnSUNBZ2FIVnVheTVzYVc1bGN5NXdkWE5vS0cxcGJtVkRkWEp5Wlc1MEtUdGNiaUFnSUNBZ0lHMXBibVV1YVc1a1pYZ3JLenRjYmlBZ0lDQWdJSFJvWldseUxtbHVaR1Y0S3lzN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQzh2SUVOdmJuUmxlSFFnYldsemJXRjBZMmhjYmlBZ0lDQWdJR052Ym1ac2FXTjBLR2gxYm1zc0lHTnZiR3hsWTNSRGFHRnVaMlVvYldsdVpTa3NJR052Ykd4bFkzUkRhR0Z1WjJVb2RHaGxhWElwS1R0Y2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNBdkx5Qk9iM2NnY0hWemFDQmhibmwwYUdsdVp5QjBhR0YwSUcxaGVTQmlaU0J5WlcxaGFXNXBibWRjYmlBZ2FXNXpaWEowVkhKaGFXeHBibWNvYUhWdWF5d2diV2x1WlNrN1hHNGdJR2x1YzJWeWRGUnlZV2xzYVc1bktHaDFibXNzSUhSb1pXbHlLVHRjYmx4dUlDQmpZV3hqVEdsdVpVTnZkVzUwS0doMWJtc3BPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQnRkWFIxWVd4RGFHRnVaMlVvYUhWdWF5d2diV2x1WlN3Z2RHaGxhWElwSUh0Y2JpQWdiR1YwSUcxNVEyaGhibWRsY3lBOUlHTnZiR3hsWTNSRGFHRnVaMlVvYldsdVpTa3NYRzRnSUNBZ0lDQjBhR1ZwY2tOb1lXNW5aWE1nUFNCamIyeHNaV04wUTJoaGJtZGxLSFJvWldseUtUdGNibHh1SUNCcFppQW9ZV3hzVW1WdGIzWmxjeWh0ZVVOb1lXNW5aWE1wSUNZbUlHRnNiRkpsYlc5MlpYTW9kR2hsYVhKRGFHRnVaMlZ6S1NrZ2UxeHVJQ0FnSUM4dklGTndaV05wWVd3Z1kyRnpaU0JtYjNJZ2NtVnRiM1psSUdOb1lXNW5aWE1nZEdoaGRDQmhjbVVnYzNWd1pYSnpaWFJ6SUc5bUlHOXVaU0JoYm05MGFHVnlYRzRnSUNBZ2FXWWdLR0Z5Y21GNVUzUmhjblJ6VjJsMGFDaHRlVU5vWVc1blpYTXNJSFJvWldseVEyaGhibWRsY3lsY2JpQWdJQ0FnSUNBZ0ppWWdjMnRwY0ZKbGJXOTJaVk4xY0dWeWMyVjBLSFJvWldseUxDQnRlVU5vWVc1blpYTXNJRzE1UTJoaGJtZGxjeTVzWlc1bmRHZ2dMU0IwYUdWcGNrTm9ZVzVuWlhNdWJHVnVaM1JvS1NrZ2UxeHVJQ0FnSUNBZ2FIVnVheTVzYVc1bGN5NXdkWE5vS0M0dUxpQnRlVU5vWVc1blpYTXBPMXh1SUNBZ0lDQWdjbVYwZFhKdU8xeHVJQ0FnSUgwZ1pXeHpaU0JwWmlBb1lYSnlZWGxUZEdGeWRITlhhWFJvS0hSb1pXbHlRMmhoYm1kbGN5d2diWGxEYUdGdVoyVnpLVnh1SUNBZ0lDQWdJQ0FtSmlCemEybHdVbVZ0YjNabFUzVndaWEp6WlhRb2JXbHVaU3dnZEdobGFYSkRhR0Z1WjJWekxDQjBhR1ZwY2tOb1lXNW5aWE11YkdWdVozUm9JQzBnYlhsRGFHRnVaMlZ6TG14bGJtZDBhQ2twSUh0Y2JpQWdJQ0FnSUdoMWJtc3ViR2x1WlhNdWNIVnphQ2d1TGk0Z2RHaGxhWEpEYUdGdVoyVnpLVHRjYmlBZ0lDQWdJSEpsZEhWeWJqdGNiaUFnSUNCOVhHNGdJSDBnWld4elpTQnBaaUFvWVhKeVlYbEZjWFZoYkNodGVVTm9ZVzVuWlhNc0lIUm9aV2x5UTJoaGJtZGxjeWtwSUh0Y2JpQWdJQ0JvZFc1ckxteHBibVZ6TG5CMWMyZ29MaTR1SUcxNVEyaGhibWRsY3lrN1hHNGdJQ0FnY21WMGRYSnVPMXh1SUNCOVhHNWNiaUFnWTI5dVpteHBZM1FvYUhWdWF5d2diWGxEYUdGdVoyVnpMQ0IwYUdWcGNrTm9ZVzVuWlhNcE8xeHVmVnh1WEc1bWRXNWpkR2x2YmlCeVpXMXZkbUZzS0doMWJtc3NJRzFwYm1Vc0lIUm9aV2x5TENCemQyRndLU0I3WEc0Z0lHeGxkQ0J0ZVVOb1lXNW5aWE1nUFNCamIyeHNaV04wUTJoaGJtZGxLRzFwYm1VcExGeHVJQ0FnSUNBZ2RHaGxhWEpEYUdGdVoyVnpJRDBnWTI5c2JHVmpkRU52Ym5SbGVIUW9kR2hsYVhJc0lHMTVRMmhoYm1kbGN5azdYRzRnSUdsbUlDaDBhR1ZwY2tOb1lXNW5aWE11YldWeVoyVmtLU0I3WEc0Z0lDQWdhSFZ1YXk1c2FXNWxjeTV3ZFhOb0tDNHVMaUIwYUdWcGNrTm9ZVzVuWlhNdWJXVnlaMlZrS1R0Y2JpQWdmU0JsYkhObElIdGNiaUFnSUNCamIyNW1iR2xqZENob2RXNXJMQ0J6ZDJGd0lEOGdkR2hsYVhKRGFHRnVaMlZ6SURvZ2JYbERhR0Z1WjJWekxDQnpkMkZ3SUQ4Z2JYbERhR0Z1WjJWeklEb2dkR2hsYVhKRGFHRnVaMlZ6S1R0Y2JpQWdmVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmpiMjVtYkdsamRDaG9kVzVyTENCdGFXNWxMQ0IwYUdWcGNpa2dlMXh1SUNCb2RXNXJMbU52Ym1ac2FXTjBJRDBnZEhKMVpUdGNiaUFnYUhWdWF5NXNhVzVsY3k1d2RYTm9LSHRjYmlBZ0lDQmpiMjVtYkdsamREb2dkSEoxWlN4Y2JpQWdJQ0J0YVc1bE9pQnRhVzVsTEZ4dUlDQWdJSFJvWldseWN6b2dkR2hsYVhKY2JpQWdmU2s3WEc1OVhHNWNibVoxYm1OMGFXOXVJR2x1YzJWeWRFeGxZV1JwYm1jb2FIVnVheXdnYVc1elpYSjBMQ0IwYUdWcGNpa2dlMXh1SUNCM2FHbHNaU0FvYVc1elpYSjBMbTltWm5ObGRDQThJSFJvWldseUxtOW1abk5sZENBbUppQnBibk5sY25RdWFXNWtaWGdnUENCcGJuTmxjblF1YkdsdVpYTXViR1Z1WjNSb0tTQjdYRzRnSUNBZ2JHVjBJR3hwYm1VZ1BTQnBibk5sY25RdWJHbHVaWE5iYVc1elpYSjBMbWx1WkdWNEt5dGRPMXh1SUNBZ0lHaDFibXN1YkdsdVpYTXVjSFZ6YUNoc2FXNWxLVHRjYmlBZ0lDQnBibk5sY25RdWIyWm1jMlYwS3lzN1hHNGdJSDFjYm4xY2JtWjFibU4wYVc5dUlHbHVjMlZ5ZEZSeVlXbHNhVzVuS0doMWJtc3NJR2x1YzJWeWRDa2dlMXh1SUNCM2FHbHNaU0FvYVc1elpYSjBMbWx1WkdWNElEd2dhVzV6WlhKMExteHBibVZ6TG14bGJtZDBhQ2tnZTF4dUlDQWdJR3hsZENCc2FXNWxJRDBnYVc1elpYSjBMbXhwYm1WelcybHVjMlZ5ZEM1cGJtUmxlQ3NyWFR0Y2JpQWdJQ0JvZFc1ckxteHBibVZ6TG5CMWMyZ29iR2x1WlNrN1hHNGdJSDFjYm4xY2JseHVablZ1WTNScGIyNGdZMjlzYkdWamRFTm9ZVzVuWlNoemRHRjBaU2tnZTF4dUlDQnNaWFFnY21WMElEMGdXMTBzWEc0Z0lDQWdJQ0J2Y0dWeVlYUnBiMjRnUFNCemRHRjBaUzVzYVc1bGMxdHpkR0YwWlM1cGJtUmxlRjFiTUYwN1hHNGdJSGRvYVd4bElDaHpkR0YwWlM1cGJtUmxlQ0E4SUhOMFlYUmxMbXhwYm1WekxteGxibWQwYUNrZ2UxeHVJQ0FnSUd4bGRDQnNhVzVsSUQwZ2MzUmhkR1V1YkdsdVpYTmJjM1JoZEdVdWFXNWtaWGhkTzF4dVhHNGdJQ0FnTHk4Z1IzSnZkWEFnWVdSa2FYUnBiMjV6SUhSb1lYUWdZWEpsSUdsdGJXVmthV0YwWld4NUlHRm1kR1Z5SUhOMVluUnlZV04wYVc5dWN5QmhibVFnZEhKbFlYUWdkR2hsYlNCaGN5QnZibVVnWENKaGRHOXRhV05jSWlCdGIyUnBabmtnWTJoaGJtZGxMbHh1SUNBZ0lHbG1JQ2h2Y0dWeVlYUnBiMjRnUFQwOUlDY3RKeUFtSmlCc2FXNWxXekJkSUQwOVBTQW5LeWNwSUh0Y2JpQWdJQ0FnSUc5d1pYSmhkR2x2YmlBOUlDY3JKenRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnBaaUFvYjNCbGNtRjBhVzl1SUQwOVBTQnNhVzVsV3pCZEtTQjdYRzRnSUNBZ0lDQnlaWFF1Y0hWemFDaHNhVzVsS1R0Y2JpQWdJQ0FnSUhOMFlYUmxMbWx1WkdWNEt5czdYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUdKeVpXRnJPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQnlaWFE3WEc1OVhHNW1kVzVqZEdsdmJpQmpiMnhzWldOMFEyOXVkR1Y0ZENoemRHRjBaU3dnYldGMFkyaERhR0Z1WjJWektTQjdYRzRnSUd4bGRDQmphR0Z1WjJWeklEMGdXMTBzWEc0Z0lDQWdJQ0J0WlhKblpXUWdQU0JiWFN4Y2JpQWdJQ0FnSUcxaGRHTm9TVzVrWlhnZ1BTQXdMRnh1SUNBZ0lDQWdZMjl1ZEdWNGRFTm9ZVzVuWlhNZ1BTQm1ZV3h6WlN4Y2JpQWdJQ0FnSUdOdmJtWnNhV04wWldRZ1BTQm1ZV3h6WlR0Y2JpQWdkMmhwYkdVZ0tHMWhkR05vU1c1a1pYZ2dQQ0J0WVhSamFFTm9ZVzVuWlhNdWJHVnVaM1JvWEc0Z0lDQWdJQ0FnSUNZbUlITjBZWFJsTG1sdVpHVjRJRHdnYzNSaGRHVXViR2x1WlhNdWJHVnVaM1JvS1NCN1hHNGdJQ0FnYkdWMElHTm9ZVzVuWlNBOUlITjBZWFJsTG14cGJtVnpXM04wWVhSbExtbHVaR1Y0WFN4Y2JpQWdJQ0FnSUNBZ2JXRjBZMmdnUFNCdFlYUmphRU5vWVc1blpYTmJiV0YwWTJoSmJtUmxlRjA3WEc1Y2JpQWdJQ0F2THlCUGJtTmxJSGRsSjNabElHaHBkQ0J2ZFhJZ1lXUmtMQ0IwYUdWdUlIZGxJR0Z5WlNCa2IyNWxYRzRnSUNBZ2FXWWdLRzFoZEdOb1d6QmRJRDA5UFNBbkt5Y3BJSHRjYmlBZ0lDQWdJR0p5WldGck8xeHVJQ0FnSUgxY2JseHVJQ0FnSUdOdmJuUmxlSFJEYUdGdVoyVnpJRDBnWTI5dWRHVjRkRU5vWVc1blpYTWdmSHdnWTJoaGJtZGxXekJkSUNFOVBTQW5JQ2M3WEc1Y2JpQWdJQ0J0WlhKblpXUXVjSFZ6YUNodFlYUmphQ2s3WEc0Z0lDQWdiV0YwWTJoSmJtUmxlQ3NyTzF4dVhHNGdJQ0FnTHk4Z1EyOXVjM1Z0WlNCaGJua2dZV1JrYVhScGIyNXpJR2x1SUhSb1pTQnZkR2hsY2lCaWJHOWpheUJoY3lCaElHTnZibVpzYVdOMElIUnZJR0YwZEdWdGNIUmNiaUFnSUNBdkx5QjBieUJ3ZFd4c0lHbHVJSFJvWlNCeVpXMWhhVzVwYm1jZ1kyOXVkR1Y0ZENCaFpuUmxjaUIwYUdselhHNGdJQ0FnYVdZZ0tHTm9ZVzVuWlZzd1hTQTlQVDBnSnlzbktTQjdYRzRnSUNBZ0lDQmpiMjVtYkdsamRHVmtJRDBnZEhKMVpUdGNibHh1SUNBZ0lDQWdkMmhwYkdVZ0tHTm9ZVzVuWlZzd1hTQTlQVDBnSnlzbktTQjdYRzRnSUNBZ0lDQWdJR05vWVc1blpYTXVjSFZ6YUNoamFHRnVaMlVwTzF4dUlDQWdJQ0FnSUNCamFHRnVaMlVnUFNCemRHRjBaUzVzYVc1bGMxc3JLM04wWVhSbExtbHVaR1Y0WFR0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc1Y2JpQWdJQ0JwWmlBb2JXRjBZMmd1YzNWaWMzUnlLREVwSUQwOVBTQmphR0Z1WjJVdWMzVmljM1J5S0RFcEtTQjdYRzRnSUNBZ0lDQmphR0Z1WjJWekxuQjFjMmdvWTJoaGJtZGxLVHRjYmlBZ0lDQWdJSE4wWVhSbExtbHVaR1Y0S3lzN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJR052Ym1ac2FXTjBaV1FnUFNCMGNuVmxPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJR2xtSUNnb2JXRjBZMmhEYUdGdVoyVnpXMjFoZEdOb1NXNWtaWGhkSUh4OElDY25LVnN3WFNBOVBUMGdKeXNuWEc0Z0lDQWdJQ0FtSmlCamIyNTBaWGgwUTJoaGJtZGxjeWtnZTF4dUlDQWdJR052Ym1ac2FXTjBaV1FnUFNCMGNuVmxPMXh1SUNCOVhHNWNiaUFnYVdZZ0tHTnZibVpzYVdOMFpXUXBJSHRjYmlBZ0lDQnlaWFIxY200Z1kyaGhibWRsY3p0Y2JpQWdmVnh1WEc0Z0lIZG9hV3hsSUNodFlYUmphRWx1WkdWNElEd2diV0YwWTJoRGFHRnVaMlZ6TG14bGJtZDBhQ2tnZTF4dUlDQWdJRzFsY21kbFpDNXdkWE5vS0cxaGRHTm9RMmhoYm1kbGMxdHRZWFJqYUVsdVpHVjRLeXRkS1R0Y2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCN1hHNGdJQ0FnYldWeVoyVmtMRnh1SUNBZ0lHTm9ZVzVuWlhOY2JpQWdmVHRjYm4xY2JseHVablZ1WTNScGIyNGdZV3hzVW1WdGIzWmxjeWhqYUdGdVoyVnpLU0I3WEc0Z0lISmxkSFZ5YmlCamFHRnVaMlZ6TG5KbFpIVmpaU2htZFc1amRHbHZiaWh3Y21WMkxDQmphR0Z1WjJVcElIdGNiaUFnSUNCeVpYUjFjbTRnY0hKbGRpQW1KaUJqYUdGdVoyVmJNRjBnUFQwOUlDY3RKenRjYmlBZ2ZTd2dkSEoxWlNrN1hHNTlYRzVtZFc1amRHbHZiaUJ6YTJsd1VtVnRiM1psVTNWd1pYSnpaWFFvYzNSaGRHVXNJSEpsYlc5MlpVTm9ZVzVuWlhNc0lHUmxiSFJoS1NCN1hHNGdJR1p2Y2lBb2JHVjBJR2tnUFNBd095QnBJRHdnWkdWc2RHRTdJR2tyS3lrZ2UxeHVJQ0FnSUd4bGRDQmphR0Z1WjJWRGIyNTBaVzUwSUQwZ2NtVnRiM1psUTJoaGJtZGxjMXR5WlcxdmRtVkRhR0Z1WjJWekxteGxibWQwYUNBdElHUmxiSFJoSUNzZ2FWMHVjM1ZpYzNSeUtERXBPMXh1SUNBZ0lHbG1JQ2h6ZEdGMFpTNXNhVzVsYzF0emRHRjBaUzVwYm1SbGVDQXJJR2xkSUNFOVBTQW5JQ2NnS3lCamFHRnVaMlZEYjI1MFpXNTBLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdabUZzYzJVN1hHNGdJQ0FnZlZ4dUlDQjlYRzVjYmlBZ2MzUmhkR1V1YVc1a1pYZ2dLejBnWkdWc2RHRTdYRzRnSUhKbGRIVnliaUIwY25WbE8xeHVmVnh1WEc1bWRXNWpkR2x2YmlCallXeGpUMnhrVG1WM1RHbHVaVU52ZFc1MEtHeHBibVZ6S1NCN1hHNGdJR3hsZENCdmJHUk1hVzVsY3lBOUlEQTdYRzRnSUd4bGRDQnVaWGRNYVc1bGN5QTlJREE3WEc1Y2JpQWdiR2x1WlhNdVptOXlSV0ZqYUNobWRXNWpkR2x2Ymloc2FXNWxLU0I3WEc0Z0lDQWdhV1lnS0hSNWNHVnZaaUJzYVc1bElDRTlQU0FuYzNSeWFXNW5KeWtnZTF4dUlDQWdJQ0FnYkdWMElHMTVRMjkxYm5RZ1BTQmpZV3hqVDJ4a1RtVjNUR2x1WlVOdmRXNTBLR3hwYm1VdWJXbHVaU2s3WEc0Z0lDQWdJQ0JzWlhRZ2RHaGxhWEpEYjNWdWRDQTlJR05oYkdOUGJHUk9aWGRNYVc1bFEyOTFiblFvYkdsdVpTNTBhR1ZwY25NcE8xeHVYRzRnSUNBZ0lDQnBaaUFvYjJ4a1RHbHVaWE1nSVQwOUlIVnVaR1ZtYVc1bFpDa2dlMXh1SUNBZ0lDQWdJQ0JwWmlBb2JYbERiM1Z1ZEM1dmJHUk1hVzVsY3lBOVBUMGdkR2hsYVhKRGIzVnVkQzV2YkdSTWFXNWxjeWtnZTF4dUlDQWdJQ0FnSUNBZ0lHOXNaRXhwYm1WeklDczlJRzE1UTI5MWJuUXViMnhrVEdsdVpYTTdYRzRnSUNBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJQ0FnYjJ4a1RHbHVaWE1nUFNCMWJtUmxabWx1WldRN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMWNibHh1SUNBZ0lDQWdhV1lnS0c1bGQweHBibVZ6SUNFOVBTQjFibVJsWm1sdVpXUXBJSHRjYmlBZ0lDQWdJQ0FnYVdZZ0tHMTVRMjkxYm5RdWJtVjNUR2x1WlhNZ1BUMDlJSFJvWldseVEyOTFiblF1Ym1WM1RHbHVaWE1wSUh0Y2JpQWdJQ0FnSUNBZ0lDQnVaWGRNYVc1bGN5QXJQU0J0ZVVOdmRXNTBMbTVsZDB4cGJtVnpPMXh1SUNBZ0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0FnSUc1bGQweHBibVZ6SUQwZ2RXNWtaV1pwYm1Wa08xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUdsbUlDaHVaWGRNYVc1bGN5QWhQVDBnZFc1a1pXWnBibVZrSUNZbUlDaHNhVzVsV3pCZElEMDlQU0FuS3ljZ2ZId2diR2x1WlZzd1hTQTlQVDBnSnlBbktTa2dlMXh1SUNBZ0lDQWdJQ0J1WlhkTWFXNWxjeXNyTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJQ0FnYVdZZ0tHOXNaRXhwYm1WeklDRTlQU0IxYm1SbFptbHVaV1FnSmlZZ0tHeHBibVZiTUYwZ1BUMDlJQ2N0SnlCOGZDQnNhVzVsV3pCZElEMDlQU0FuSUNjcEtTQjdYRzRnSUNBZ0lDQWdJRzlzWkV4cGJtVnpLeXM3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmVnh1SUNCOUtUdGNibHh1SUNCeVpYUjFjbTRnZTI5c1pFeHBibVZ6TENCdVpYZE1hVzVsYzMwN1hHNTlYRzRpWFgwPVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/diff/lib/patch/merge.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/diff/lib/patch/parse.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mocha/node_modules/diff/lib/patch/parse.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/*istanbul ignore start*/\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.parsePatch = parsePatch;\n\n/*istanbul ignore end*/\nfunction parsePatch(uniDiff) {\n  /*istanbul ignore start*/\n  var\n  /*istanbul ignore end*/\n  options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    var index = {};\n    list.push(index); // Parse diff metadata\n\n    while (i < diffstr.length) {\n      var line = diffstr[i]; // File header found, end parsing diff metadata\n\n      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n        break;\n      } // Diff index\n\n\n      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    } // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n\n\n    parseFileHeader(index);\n    parseFileHeader(index); // Parse hunks\n\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      var _line = diffstr[i];\n\n      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n        break;\n      } else if (/^@@/.test(_line)) {\n        index.hunks.push(parseHunk());\n      } else if (_line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n      } else {\n        i++;\n      }\n    }\n  } // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n\n\n  function parseFileHeader(index) {\n    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\n    if (fileHeader) {\n      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      var data = fileHeader[2].split('\\t', 2);\n      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\n      if (/^\".*\"$/.test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n      i++;\n    }\n  } // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n\n\n  function parseHunk() {\n    var chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n    var hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: [],\n      linedelimiters: []\n    }; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n\n    var addCount = 0,\n        removeCount = 0;\n\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n        break;\n      }\n\n      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    } // Handle the empty block count case\n\n\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    } // Perform optional sanity checking\n\n\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXRjaC9wYXJzZS5qcyJdLCJuYW1lcyI6WyJwYXJzZVBhdGNoIiwidW5pRGlmZiIsIm9wdGlvbnMiLCJkaWZmc3RyIiwic3BsaXQiLCJkZWxpbWl0ZXJzIiwibWF0Y2giLCJsaXN0IiwiaSIsInBhcnNlSW5kZXgiLCJpbmRleCIsInB1c2giLCJsZW5ndGgiLCJsaW5lIiwidGVzdCIsImhlYWRlciIsImV4ZWMiLCJwYXJzZUZpbGVIZWFkZXIiLCJodW5rcyIsInBhcnNlSHVuayIsInN0cmljdCIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImZpbGVIZWFkZXIiLCJrZXlQcmVmaXgiLCJkYXRhIiwiZmlsZU5hbWUiLCJyZXBsYWNlIiwic3Vic3RyIiwidHJpbSIsImNodW5rSGVhZGVySW5kZXgiLCJjaHVua0hlYWRlckxpbmUiLCJjaHVua0hlYWRlciIsImh1bmsiLCJvbGRTdGFydCIsIm9sZExpbmVzIiwibmV3U3RhcnQiLCJuZXdMaW5lcyIsImxpbmVzIiwibGluZWRlbGltaXRlcnMiLCJhZGRDb3VudCIsInJlbW92ZUNvdW50IiwiaW5kZXhPZiIsIm9wZXJhdGlvbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQU8sU0FBU0EsVUFBVCxDQUFvQkMsT0FBcEIsRUFBMkM7QUFBQTtBQUFBO0FBQUE7QUFBZEMsRUFBQUEsT0FBYyx1RUFBSixFQUFJO0FBQ2hELE1BQUlDLE9BQU8sR0FBR0YsT0FBTyxDQUFDRyxLQUFSLENBQWMscUJBQWQsQ0FBZDtBQUFBLE1BQ0lDLFVBQVUsR0FBR0osT0FBTyxDQUFDSyxLQUFSLENBQWMsc0JBQWQsS0FBeUMsRUFEMUQ7QUFBQSxNQUVJQyxJQUFJLEdBQUcsRUFGWDtBQUFBLE1BR0lDLENBQUMsR0FBRyxDQUhSOztBQUtBLFdBQVNDLFVBQVQsR0FBc0I7QUFDcEIsUUFBSUMsS0FBSyxHQUFHLEVBQVo7QUFDQUgsSUFBQUEsSUFBSSxDQUFDSSxJQUFMLENBQVVELEtBQVYsRUFGb0IsQ0FJcEI7O0FB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QUwsS0FBa0IsQ0FBbkMsRUFBc0M7QUFDcENKLE1BQUFBLElBQUksQ0FBQ0ksUUFBTCxHQUFnQixDQUFoQjtBQUNEOztBQUNELFFBQUksQ0FBQ0ksV0FBRCxJQUFnQlIsSUFBSSxDQUFDRSxRQUFMLEtBQWtCLENBQXRDLEVBQXlDO0FBQ3ZDRixNQUFBQSxJQUFJLENBQUNFLFFBQUwsR0FBZ0IsQ0FBaEI7QUFDRCxLQTVEa0IsQ0E4RG5COzs7QUFDQSxRQUFJbEMsT0FBTyxDQUFDa0IsTUFBWixFQUFvQjtBQUNsQixVQUFJcUIsUUFBUSxLQUFLUCxJQUFJLENBQUNJLFFBQXRCLEVBQWdDO0FBQzlCLGNBQU0sSUFBSWpCLEtBQUosQ0FBVSxzREFBc0RVLGdCQUFnQixHQUFHLENBQXpFLENBQVYsQ0FBTjtBQUNEOztBQUNELFVBQUlXLFdBQVcsS0FBS1IsSUFBSSxDQUFDRSxRQUF6QixFQUFtQztBQUNqQyxjQUFNLElBQUlmLEtBQUosQ0FBVSx3REFBd0RVLGdCQUFnQixHQUFHLENBQTNFLENBQVYsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsV0FBT0csSUFBUDtBQUNEOztBQUVELFNBQU8xQixDQUFDLEdBQUdMLE9BQU8sQ0FBQ1MsTUFBbkIsRUFBMkI7QUFDekJILElBQUFBLFVBQVU7QUFDWDs7QUFFRCxTQUFPRixJQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gcGFyc2VQYXRjaCh1bmlEaWZmLCBvcHRpb25zID0ge30pIHtcbiAgbGV0IGRpZmZzdHIgPSB1bmlEaWZmLnNwbGl0KC9cXHJcXG58W1xcblxcdlxcZlxcclxceDg1XS8pLFxuICAgICAgZGVsaW1pdGVycyA9IHVuaURpZmYubWF0Y2goL1xcclxcbnxbXFxuXFx2XFxmXFxyXFx4ODVdL2cpIHx8IFtdLFxuICAgICAgbGlzdCA9IFtdLFxuICAgICAgaSA9IDA7XG5cbiAgZnVuY3Rpb24gcGFyc2VJbmRleCgpIHtcbiAgICBsZXQgaW5kZXggPSB7fTtcbiAgICBsaXN0LnB1c2goaW5kZXgpO1xuXG4gICAgLy8gUGFyc2UgZGlmZiBtZXRhZGF0YVxuICAgIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcbiAgICAgIGxldCBsaW5lID0gZGlmZnN0cltpXTtcblxuICAgICAgLy8gRmlsZSBoZWFkZXIgZm91bmQsIGVuZCBwYXJzaW5nIGRpZmYgbWV0YWRhdGFcbiAgICAgIGlmICgoL14oXFwtXFwtXFwtfFxcK1xcK1xcK3xAQClcXHMvKS50ZXN0KGxpbmUpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBEaWZmIGluZGV4XG4gICAgICBsZXQgaGVhZGVyID0gKC9eKD86SW5kZXg6fGRpZmYoPzogLXIgXFx3KykrKVxccysoLis/KVxccyokLykuZXhlYyhsaW5lKTtcbiAgICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgaW5kZXguaW5kZXggPSBoZWFkZXJbMV07XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICAvLyBQYXJzZSBmaWxlIGhlYWRlcnMgaWYgdGhleSBhcmUgZGVmaW5lZC4gVW5pZmllZCBkaWZmIHJlcXVpcmVzIHRoZW0sIGJ1dFxuICAgIC8vIHRoZXJlJ3Mgbm8gdGVjaG5pY2FsIGlzc3VlcyB0byBoYXZlIGFuIGlzb2xhdGVkIGh1bmsgd2l0aG91dCBmaWxlIGhlYWRlclxuICAgIHBhcnNlRmlsZUhlYWRlcihpbmRleCk7XG4gICAgcGFyc2VGaWxlSGVhZGVyKGluZGV4KTtcblxuICAgIC8vIFBhcnNlIGh1bmtzXG4gICAgaW5kZXguaHVua3MgPSBbXTtcblxuICAgIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcbiAgICAgIGxldCBsaW5lID0gZGlmZnN0cltpXTtcblxuICAgICAgaWYgKCgvXihJbmRleDp8ZGlmZnxcXC1cXC1cXC18XFwrXFwrXFwrKVxccy8pLnRlc3QobGluZSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKCgvXkBALykudGVzdChsaW5lKSkge1xuICAgICAgICBpbmRleC5odW5rcy5wdXNoKHBhcnNlSHVuaygpKTtcbiAgICAgIH0gZWxzZSBpZiAobGluZSAmJiBvcHRpb25zLnN0cmljdCkge1xuICAgICAgICAvLyBJZ25vcmUgdW5leHBlY3RlZCBjb250ZW50IHVubGVzcyBpbiBzdHJpY3QgbW9kZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGluZSAnICsgKGkgKyAxKSArICcgJyArIEpTT04uc3RyaW5naWZ5KGxpbmUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBQYXJzZXMgdGhlIC0tLSBhbmQgKysrIGhlYWRlcnMsIGlmIG5vbmUgYXJlIGZvdW5kLCBubyBsaW5lc1xuICAvLyBhcmUgY29uc3VtZWQuXG4gIGZ1bmN0aW9uIHBhcnNlRmlsZUhlYWRlcihpbmRleCkge1xuICAgIGNvbnN0IGZpbGVIZWFkZXIgPSAoL14oLS0tfFxcK1xcK1xcKylcXHMrKC4qKSQvKS5leGVjKGRpZmZzdHJbaV0pO1xuICAgIGlmIChmaWxlSGVhZGVyKSB7XG4gICAgICBsZXQga2V5UHJlZml4ID0gZmlsZUhlYWRlclsxXSA9PT0gJy0tLScgPyAnb2xkJyA6ICduZXcnO1xuICAgICAgY29uc3QgZGF0YSA9IGZpbGVIZWFkZXJbMl0uc3BsaXQoJ1xcdCcsIDIpO1xuICAgICAgbGV0IGZpbGVOYW1lID0gZGF0YVswXS5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnXFxcXCcpO1xuICAgICAgaWYgKCgvXlwiLipcIiQvKS50ZXN0KGZpbGVOYW1lKSkge1xuICAgICAgICBmaWxlTmFtZSA9IGZpbGVOYW1lLnN1YnN0cigxLCBmaWxlTmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIH1cbiAgICAgIGluZGV4W2tleVByZWZpeCArICdGaWxlTmFtZSddID0gZmlsZU5hbWU7XG4gICAgICBpbmRleFtrZXlQcmVmaXggKyAnSGVhZGVyJ10gPSAoZGF0YVsxXSB8fCAnJykudHJpbSgpO1xuXG4gICAgICBpKys7XG4gICAgfVxuICB9XG5cbiAgLy8gUGFyc2VzIGEgaHVua1xuICAvLyBUaGlzIGFzc3VtZXMgdGhhdCB3ZSBhcmUgYXQgdGhlIHN0YXJ0IG9mIGEgaHVuay5cbiAgZnVuY3Rpb24gcGFyc2VIdW5rKCkge1xuICAgIGxldCBjaHVua0hlYWRlckluZGV4ID0gaSxcbiAgICAgICAgY2h1bmtIZWFkZXJMaW5lID0gZGlmZnN0cltpKytdLFxuICAgICAgICBjaHVua0hlYWRlciA9IGNodW5rSGVhZGVyTGluZS5zcGxpdCgvQEAgLShcXGQrKSg/OiwoXFxkKykpPyBcXCsoXFxkKykoPzosKFxcZCspKT8gQEAvKTtcblxuICAgIGxldCBodW5rID0ge1xuICAgICAgb2xkU3RhcnQ6ICtjaHVua0hlYWRlclsxXSxcbiAgICAgIG9sZExpbmVzOiB0eXBlb2YgY2h1bmtIZWFkZXJbMl0gPT09ICd1bmRlZmluZWQnID8gMSA6ICtjaHVua0hlYWRlclsyXSxcbiAgICAgIG5ld1N0YXJ0OiArY2h1bmtIZWFkZXJbM10sXG4gICAgICBuZXdMaW5lczogdHlwZW9mIGNodW5rSGVhZGVyWzRdID09PSAndW5kZWZpbmVkJyA/IDEgOiArY2h1bmtIZWFkZXJbNF0sXG4gICAgICBsaW5lczogW10sXG4gICAgICBsaW5lZGVsaW1pdGVyczogW11cbiAgICB9O1xuXG4gICAgLy8gVW5pZmllZCBEaWZmIEZvcm1hdCBxdWlyazogSWYgdGhlIGNodW5rIHNpemUgaXMgMCxcbiAgICAvLyB0aGUgZmlyc3QgbnVtYmVyIGlzIG9uZSBsb3dlciB0aGFuIG9uZSB3b3VsZCBleHBlY3QuXG4gICAgLy8gaHR0cHM6Ly93d3cuYXJ0aW1hLmNvbS93ZWJsb2dzL3ZpZXdwb3N0LmpzcD90aHJlYWQ9MTY0MjkzXG4gICAgaWYgKGh1bmsub2xkTGluZXMgPT09IDApIHtcbiAgICAgIGh1bmsub2xkU3RhcnQgKz0gMTtcbiAgICB9XG4gICAgaWYgKGh1bmsubmV3TGluZXMgPT09IDApIHtcbiAgICAgIGh1bmsubmV3U3RhcnQgKz0gMTtcbiAgICB9XG5cbiAgICBsZXQgYWRkQ291bnQgPSAwLFxuICAgICAgICByZW1vdmVDb3VudCA9IDA7XG4gICAgZm9yICg7IGkgPCBkaWZmc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBMaW5lcyBzdGFydGluZyB3aXRoICctLS0nIGNvdWxkIGJlIG1pc3Rha2VuIGZvciB0aGUgXCJyZW1vdmUgbGluZVwiIG9wZXJhdGlvblxuICAgICAgLy8gQnV0IHRoZXkgY291bGQgYmUgdGhlIGhlYWRlciBmb3IgdGhlIG5leHQgZmlsZS4gVGhlcmVmb3JlIHBydW5lIHN1Y2ggY2FzZXMgb3V0LlxuICAgICAgaWYgKGRpZmZzdHJbaV0uaW5kZXhPZignLS0tICcpID09PSAwXG4gICAgICAgICAgICAmJiAoaSArIDIgPCBkaWZmc3RyLmxlbmd0aClcbiAgICAgICAgICAgICYmIGRpZmZzdHJbaSArIDFdLmluZGV4T2YoJysrKyAnKSA9PT0gMFxuICAgICAgICAgICAgJiYgZGlmZnN0cltpICsgMl0uaW5kZXhPZignQEAnKSA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGV0IG9wZXJhdGlvbiA9IChkaWZmc3RyW2ldLmxlbmd0aCA9PSAwICYmIGkgIT0gKGRpZmZzdHIubGVuZ3RoIC0gMSkpID8gJyAnIDogZGlmZnN0cltpXVswXTtcblxuICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJysnIHx8IG9wZXJhdGlvbiA9PT0gJy0nIHx8IG9wZXJhdGlvbiA9PT0gJyAnIHx8IG9wZXJhdGlvbiA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIGh1bmsubGluZXMucHVzaChkaWZmc3RyW2ldKTtcbiAgICAgICAgaHVuay5saW5lZGVsaW1pdGVycy5wdXNoKGRlbGltaXRlcnNbaV0gfHwgJ1xcbicpO1xuXG4gICAgICAgIGlmIChvcGVyYXRpb24gPT09ICcrJykge1xuICAgICAgICAgIGFkZENvdW50Kys7XG4gICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnLScpIHtcbiAgICAgICAgICByZW1vdmVDb3VudCsrO1xuICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJyAnKSB7XG4gICAgICAgICAgYWRkQ291bnQrKztcbiAgICAgICAgICByZW1vdmVDb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgdGhlIGVtcHR5IGJsb2NrIGNvdW50IGNhc2VcbiAgICBpZiAoIWFkZENvdW50ICYmIGh1bmsubmV3TGluZXMgPT09IDEpIHtcbiAgICAgIGh1bmsubmV3TGluZXMgPSAwO1xuICAgIH1cbiAgICBpZiAoIXJlbW92ZUNvdW50ICYmIGh1bmsub2xkTGluZXMgPT09IDEpIHtcbiAgICAgIGh1bmsub2xkTGluZXMgPSAwO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gb3B0aW9uYWwgc2FuaXR5IGNoZWNraW5nXG4gICAgaWYgKG9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICBpZiAoYWRkQ291bnQgIT09IGh1bmsubmV3TGluZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZGRlZCBsaW5lIGNvdW50IGRpZCBub3QgbWF0Y2ggZm9yIGh1bmsgYXQgbGluZSAnICsgKGNodW5rSGVhZGVySW5kZXggKyAxKSk7XG4gICAgICB9XG4gICAgICBpZiAocmVtb3ZlQ291bnQgIT09IGh1bmsub2xkTGluZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW1vdmVkIGxpbmUgY291bnQgZGlkIG5vdCBtYXRjaCBmb3IgaHVuayBhdCBsaW5lICcgKyAoY2h1bmtIZWFkZXJJbmRleCArIDEpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaHVuaztcbiAgfVxuXG4gIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcbiAgICBwYXJzZUluZGV4KCk7XG4gIH1cblxuICByZXR1cm4gbGlzdDtcbn1cbiJdfQ==\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL3BhdGNoL3BhcnNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBLFFBQVE7OztBQUdSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQSw0QkFBNEI7O0FBRTVCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9ub2RlX21vZHVsZXMvZGlmZi9saWIvcGF0Y2gvcGFyc2UuanM/MTZjNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucGFyc2VQYXRjaCA9IHBhcnNlUGF0Y2g7XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5mdW5jdGlvbiBwYXJzZVBhdGNoKHVuaURpZmYpIHtcbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICB2YXJcbiAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBkaWZmc3RyID0gdW5pRGlmZi5zcGxpdCgvXFxyXFxufFtcXG5cXHZcXGZcXHJcXHg4NV0vKSxcbiAgICAgIGRlbGltaXRlcnMgPSB1bmlEaWZmLm1hdGNoKC9cXHJcXG58W1xcblxcdlxcZlxcclxceDg1XS9nKSB8fCBbXSxcbiAgICAgIGxpc3QgPSBbXSxcbiAgICAgIGkgPSAwO1xuXG4gIGZ1bmN0aW9uIHBhcnNlSW5kZXgoKSB7XG4gICAgdmFyIGluZGV4ID0ge307XG4gICAgbGlzdC5wdXNoKGluZGV4KTsgLy8gUGFyc2UgZGlmZiBtZXRhZGF0YVxuXG4gICAgd2hpbGUgKGkgPCBkaWZmc3RyLmxlbmd0aCkge1xuICAgICAgdmFyIGxpbmUgPSBkaWZmc3RyW2ldOyAvLyBGaWxlIGhlYWRlciBmb3VuZCwgZW5kIHBhcnNpbmcgZGlmZiBtZXRhZGF0YVxuXG4gICAgICBpZiAoL14oXFwtXFwtXFwtfFxcK1xcK1xcK3xAQClcXHMvLnRlc3QobGluZSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIERpZmYgaW5kZXhcblxuXG4gICAgICB2YXIgaGVhZGVyID0gL14oPzpJbmRleDp8ZGlmZig/OiAtciBcXHcrKSspXFxzKyguKz8pXFxzKiQvLmV4ZWMobGluZSk7XG5cbiAgICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgaW5kZXguaW5kZXggPSBoZWFkZXJbMV07XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9IC8vIFBhcnNlIGZpbGUgaGVhZGVycyBpZiB0aGV5IGFyZSBkZWZpbmVkLiBVbmlmaWVkIGRpZmYgcmVxdWlyZXMgdGhlbSwgYnV0XG4gICAgLy8gdGhlcmUncyBubyB0ZWNobmljYWwgaXNzdWVzIHRvIGhhdmUgYW4gaXNvbGF0ZWQgaHVuayB3aXRob3V0IGZpbGUgaGVhZGVyXG5cblxuICAgIHBhcnNlRmlsZUhlYWRlcihpbmRleCk7XG4gICAgcGFyc2VGaWxlSGVhZGVyKGluZGV4KTsgLy8gUGFyc2UgaHVua3NcblxuICAgIGluZGV4Lmh1bmtzID0gW107XG5cbiAgICB3aGlsZSAoaSA8IGRpZmZzdHIubGVuZ3RoKSB7XG4gICAgICB2YXIgX2xpbmUgPSBkaWZmc3RyW2ldO1xuXG4gICAgICBpZiAoL14oSW5kZXg6fGRpZmZ8XFwtXFwtXFwtfFxcK1xcK1xcKylcXHMvLnRlc3QoX2xpbmUpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmICgvXkBALy50ZXN0KF9saW5lKSkge1xuICAgICAgICBpbmRleC5odW5rcy5wdXNoKHBhcnNlSHVuaygpKTtcbiAgICAgIH0gZWxzZSBpZiAoX2xpbmUgJiYgb3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgLy8gSWdub3JlIHVuZXhwZWN0ZWQgY29udGVudCB1bmxlc3MgaW4gc3RyaWN0IG1vZGVcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGxpbmUgJyArIChpICsgMSkgKyAnICcgKyBKU09OLnN0cmluZ2lmeShfbGluZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBQYXJzZXMgdGhlIC0tLSBhbmQgKysrIGhlYWRlcnMsIGlmIG5vbmUgYXJlIGZvdW5kLCBubyBsaW5lc1xuICAvLyBhcmUgY29uc3VtZWQuXG5cblxuICBmdW5jdGlvbiBwYXJzZUZpbGVIZWFkZXIoaW5kZXgpIHtcbiAgICB2YXIgZmlsZUhlYWRlciA9IC9eKC0tLXxcXCtcXCtcXCspXFxzKyguKikkLy5leGVjKGRpZmZzdHJbaV0pO1xuXG4gICAgaWYgKGZpbGVIZWFkZXIpIHtcbiAgICAgIHZhciBrZXlQcmVmaXggPSBmaWxlSGVhZGVyWzFdID09PSAnLS0tJyA/ICdvbGQnIDogJ25ldyc7XG4gICAgICB2YXIgZGF0YSA9IGZpbGVIZWFkZXJbMl0uc3BsaXQoJ1xcdCcsIDIpO1xuICAgICAgdmFyIGZpbGVOYW1lID0gZGF0YVswXS5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnXFxcXCcpO1xuXG4gICAgICBpZiAoL15cIi4qXCIkLy50ZXN0KGZpbGVOYW1lKSkge1xuICAgICAgICBmaWxlTmFtZSA9IGZpbGVOYW1lLnN1YnN0cigxLCBmaWxlTmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIH1cblxuICAgICAgaW5kZXhba2V5UHJlZml4ICsgJ0ZpbGVOYW1lJ10gPSBmaWxlTmFtZTtcbiAgICAgIGluZGV4W2tleVByZWZpeCArICdIZWFkZXInXSA9IChkYXRhWzFdIHx8ICcnKS50cmltKCk7XG4gICAgICBpKys7XG4gICAgfVxuICB9IC8vIFBhcnNlcyBhIGh1bmtcbiAgLy8gVGhpcyBhc3N1bWVzIHRoYXQgd2UgYXJlIGF0IHRoZSBzdGFydCBvZiBhIGh1bmsuXG5cblxuICBmdW5jdGlvbiBwYXJzZUh1bmsoKSB7XG4gICAgdmFyIGNodW5rSGVhZGVySW5kZXggPSBpLFxuICAgICAgICBjaHVua0hlYWRlckxpbmUgPSBkaWZmc3RyW2krK10sXG4gICAgICAgIGNodW5rSGVhZGVyID0gY2h1bmtIZWFkZXJMaW5lLnNwbGl0KC9AQCAtKFxcZCspKD86LChcXGQrKSk/IFxcKyhcXGQrKSg/OiwoXFxkKykpPyBAQC8pO1xuICAgIHZhciBodW5rID0ge1xuICAgICAgb2xkU3RhcnQ6ICtjaHVua0hlYWRlclsxXSxcbiAgICAgIG9sZExpbmVzOiB0eXBlb2YgY2h1bmtIZWFkZXJbMl0gPT09ICd1bmRlZmluZWQnID8gMSA6ICtjaHVua0hlYWRlclsyXSxcbiAgICAgIG5ld1N0YXJ0OiArY2h1bmtIZWFkZXJbM10sXG4gICAgICBuZXdMaW5lczogdHlwZW9mIGNodW5rSGVhZGVyWzRdID09PSAndW5kZWZpbmVkJyA/IDEgOiArY2h1bmtIZWFkZXJbNF0sXG4gICAgICBsaW5lczogW10sXG4gICAgICBsaW5lZGVsaW1pdGVyczogW11cbiAgICB9OyAvLyBVbmlmaWVkIERpZmYgRm9ybWF0IHF1aXJrOiBJZiB0aGUgY2h1bmsgc2l6ZSBpcyAwLFxuICAgIC8vIHRoZSBmaXJzdCBudW1iZXIgaXMgb25lIGxvd2VyIHRoYW4gb25lIHdvdWxkIGV4cGVjdC5cbiAgICAvLyBodHRwczovL3d3dy5hcnRpbWEuY29tL3dlYmxvZ3Mvdmlld3Bvc3QuanNwP3RocmVhZD0xNjQyOTNcblxuICAgIGlmIChodW5rLm9sZExpbmVzID09PSAwKSB7XG4gICAgICBodW5rLm9sZFN0YXJ0ICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKGh1bmsubmV3TGluZXMgPT09IDApIHtcbiAgICAgIGh1bmsubmV3U3RhcnQgKz0gMTtcbiAgICB9XG5cbiAgICB2YXIgYWRkQ291bnQgPSAwLFxuICAgICAgICByZW1vdmVDb3VudCA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGRpZmZzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIExpbmVzIHN0YXJ0aW5nIHdpdGggJy0tLScgY291bGQgYmUgbWlzdGFrZW4gZm9yIHRoZSBcInJlbW92ZSBsaW5lXCIgb3BlcmF0aW9uXG4gICAgICAvLyBCdXQgdGhleSBjb3VsZCBiZSB0aGUgaGVhZGVyIGZvciB0aGUgbmV4dCBmaWxlLiBUaGVyZWZvcmUgcHJ1bmUgc3VjaCBjYXNlcyBvdXQuXG4gICAgICBpZiAoZGlmZnN0cltpXS5pbmRleE9mKCctLS0gJykgPT09IDAgJiYgaSArIDIgPCBkaWZmc3RyLmxlbmd0aCAmJiBkaWZmc3RyW2kgKyAxXS5pbmRleE9mKCcrKysgJykgPT09IDAgJiYgZGlmZnN0cltpICsgMl0uaW5kZXhPZignQEAnKSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIG9wZXJhdGlvbiA9IGRpZmZzdHJbaV0ubGVuZ3RoID09IDAgJiYgaSAhPSBkaWZmc3RyLmxlbmd0aCAtIDEgPyAnICcgOiBkaWZmc3RyW2ldWzBdO1xuXG4gICAgICBpZiAob3BlcmF0aW9uID09PSAnKycgfHwgb3BlcmF0aW9uID09PSAnLScgfHwgb3BlcmF0aW9uID09PSAnICcgfHwgb3BlcmF0aW9uID09PSAnXFxcXCcpIHtcbiAgICAgICAgaHVuay5saW5lcy5wdXNoKGRpZmZzdHJbaV0pO1xuICAgICAgICBodW5rLmxpbmVkZWxpbWl0ZXJzLnB1c2goZGVsaW1pdGVyc1tpXSB8fCAnXFxuJyk7XG5cbiAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJysnKSB7XG4gICAgICAgICAgYWRkQ291bnQrKztcbiAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICctJykge1xuICAgICAgICAgIHJlbW92ZUNvdW50Kys7XG4gICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnICcpIHtcbiAgICAgICAgICBhZGRDb3VudCsrO1xuICAgICAgICAgIHJlbW92ZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gLy8gSGFuZGxlIHRoZSBlbXB0eSBibG9jayBjb3VudCBjYXNlXG5cblxuICAgIGlmICghYWRkQ291bnQgJiYgaHVuay5uZXdMaW5lcyA9PT0gMSkge1xuICAgICAgaHVuay5uZXdMaW5lcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKCFyZW1vdmVDb3VudCAmJiBodW5rLm9sZExpbmVzID09PSAxKSB7XG4gICAgICBodW5rLm9sZExpbmVzID0gMDtcbiAgICB9IC8vIFBlcmZvcm0gb3B0aW9uYWwgc2FuaXR5IGNoZWNraW5nXG5cblxuICAgIGlmIChvcHRpb25zLnN0cmljdCkge1xuICAgICAgaWYgKGFkZENvdW50ICE9PSBodW5rLm5ld0xpbmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWRkZWQgbGluZSBjb3VudCBkaWQgbm90IG1hdGNoIGZvciBodW5rIGF0IGxpbmUgJyArIChjaHVua0hlYWRlckluZGV4ICsgMSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVtb3ZlQ291bnQgIT09IGh1bmsub2xkTGluZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW1vdmVkIGxpbmUgY291bnQgZGlkIG5vdCBtYXRjaCBmb3IgaHVuayBhdCBsaW5lICcgKyAoY2h1bmtIZWFkZXJJbmRleCArIDEpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaHVuaztcbiAgfVxuXG4gIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcbiAgICBwYXJzZUluZGV4KCk7XG4gIH1cblxuICByZXR1cm4gbGlzdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXdZWFJqYUM5d1lYSnpaUzVxY3lKZExDSnVZVzFsY3lJNld5SndZWEp6WlZCaGRHTm9JaXdpZFc1cFJHbG1aaUlzSW05d2RHbHZibk1pTENKa2FXWm1jM1J5SWl3aWMzQnNhWFFpTENKa1pXeHBiV2wwWlhKeklpd2liV0YwWTJnaUxDSnNhWE4wSWl3aWFTSXNJbkJoY25ObFNXNWtaWGdpTENKcGJtUmxlQ0lzSW5CMWMyZ2lMQ0pzWlc1bmRHZ2lMQ0pzYVc1bElpd2lkR1Z6ZENJc0ltaGxZV1JsY2lJc0ltVjRaV01pTENKd1lYSnpaVVpwYkdWSVpXRmtaWElpTENKb2RXNXJjeUlzSW5CaGNuTmxTSFZ1YXlJc0luTjBjbWxqZENJc0lrVnljbTl5SWl3aVNsTlBUaUlzSW5OMGNtbHVaMmxtZVNJc0ltWnBiR1ZJWldGa1pYSWlMQ0pyWlhsUWNtVm1hWGdpTENKa1lYUmhJaXdpWm1sc1pVNWhiV1VpTENKeVpYQnNZV05sSWl3aWMzVmljM1J5SWl3aWRISnBiU0lzSW1Ob2RXNXJTR1ZoWkdWeVNXNWtaWGdpTENKamFIVnVhMGhsWVdSbGNreHBibVVpTENKamFIVnVhMGhsWVdSbGNpSXNJbWgxYm1zaUxDSnZiR1JUZEdGeWRDSXNJbTlzWkV4cGJtVnpJaXdpYm1WM1UzUmhjblFpTENKdVpYZE1hVzVsY3lJc0lteHBibVZ6SWl3aWJHbHVaV1JsYkdsdGFYUmxjbk1pTENKaFpHUkRiM1Z1ZENJc0luSmxiVzkyWlVOdmRXNTBJaXdpYVc1a1pYaFBaaUlzSW05d1pYSmhkR2x2YmlKZExDSnRZWEJ3YVc1bmN5STZJanM3T3pzN096czdPMEZCUVU4c1UwRkJVMEVzVlVGQlZDeERRVUZ2UWtNc1QwRkJjRUlzUlVGQk1rTTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJaRU1zUlVGQlFVRXNUMEZCWXl4MVJVRkJTaXhGUVVGSk8wRkJRMmhFTEUxQlFVbERMRTlCUVU4c1IwRkJSMFlzVDBGQlR5eERRVUZEUnl4TFFVRlNMRU5CUVdNc2NVSkJRV1FzUTBGQlpEdEJRVUZCTEUxQlEwbERMRlZCUVZVc1IwRkJSMG9zVDBGQlR5eERRVUZEU3l4TFFVRlNMRU5CUVdNc2MwSkJRV1FzUzBGQmVVTXNSVUZFTVVRN1FVRkJRU3hOUVVWSlF5eEpRVUZKTEVkQlFVY3NSVUZHV0R0QlFVRkJMRTFCUjBsRExFTkJRVU1zUjBGQlJ5eERRVWhTT3p0QlFVdEJMRmRCUVZORExGVkJRVlFzUjBGQmMwSTdRVUZEY0VJc1VVRkJTVU1zUzBGQlN5eEhRVUZITEVWQlFWbzdRVUZEUVVnc1NVRkJRVUVzU1VGQlNTeERRVUZEU1N4SlFVRk1MRU5CUVZWRUxFdEJRVllzUlVGR2IwSXNRMEZKY0VJN08wRkJRMEVzVjBGQlQwWXNRMEZCUXl4SFFVRkhUQ3hQUVVGUExFTkJRVU5UTEUxQlFXNUNMRVZCUVRKQ08wRkJRM3BDTEZWQlFVbERMRWxCUVVrc1IwRkJSMVlzVDBGQlR5eERRVUZEU3l4RFFVRkVMRU5CUVd4Q0xFTkJSSGxDTEVOQlIzcENPenRCUVVOQkxGVkJRVXNzZFVKQlFVUXNRMEZCTUVKTkxFbEJRVEZDTEVOQlFTdENSQ3hKUVVFdlFpeERRVUZLTEVWQlFUQkRPMEZCUTNoRE8wRkJRMFFzVDBGT2QwSXNRMEZSZWtJN096dEJRVU5CTEZWQlFVbEZMRTFCUVUwc1IwRkJTU3d3UTBGQlJDeERRVUUyUTBNc1NVRkJOME1zUTBGQmEwUklMRWxCUVd4RUxFTkJRV0k3TzBGQlEwRXNWVUZCU1VVc1RVRkJTaXhGUVVGWk8wRkJRMVpNTEZGQlFVRkJMRXRCUVVzc1EwRkJRMEVzUzBGQlRpeEhRVUZqU3l4TlFVRk5MRU5CUVVNc1EwRkJSQ3hEUVVGd1FqdEJRVU5FT3p0QlFVVkVVQ3hOUVVGQlFTeERRVUZETzBGQlEwWXNTMEZ3UW0xQ0xFTkJjMEp3UWp0QlFVTkJPenM3UVVGRFFWTXNTVUZCUVVFc1pVRkJaU3hEUVVGRFVDeExRVUZFTEVOQlFXWTdRVUZEUVU4c1NVRkJRVUVzWlVGQlpTeERRVUZEVUN4TFFVRkVMRU5CUVdZc1EwRjZRbTlDTEVOQk1rSndRanM3UVVGRFFVRXNTVUZCUVVFc1MwRkJTeXhEUVVGRFVTeExRVUZPTEVkQlFXTXNSVUZCWkRzN1FVRkZRU3hYUVVGUFZpeERRVUZETEVkQlFVZE1MRTlCUVU4c1EwRkJRMU1zVFVGQmJrSXNSVUZCTWtJN1FVRkRla0lzVlVGQlNVTXNTMEZCU1N4SFFVRkhWaXhQUVVGUExFTkJRVU5MTEVOQlFVUXNRMEZCYkVJN08wRkJSVUVzVlVGQlN5eG5RMEZCUkN4RFFVRnRRMDBzU1VGQmJrTXNRMEZCZDBORUxFdEJRWGhETEVOQlFVb3NSVUZCYlVRN1FVRkRha1E3UVVGRFJDeFBRVVpFTEUxQlJVOHNTVUZCU3l4TFFVRkVMRU5CUVZGRExFbEJRVklzUTBGQllVUXNTMEZCWWl4RFFVRktMRVZCUVhkQ08wRkJRemRDU0N4UlFVRkJRU3hMUVVGTExFTkJRVU5STEV0QlFVNHNRMEZCV1ZBc1NVRkJXaXhEUVVGcFFsRXNVMEZCVXl4RlFVRXhRanRCUVVORUxFOUJSazBzVFVGRlFTeEpRVUZKVGl4TFFVRkpMRWxCUVVsWUxFOUJRVThzUTBGQlEydENMRTFCUVhCQ0xFVkJRVFJDTzBGQlEycERPMEZCUTBFc1kwRkJUU3hKUVVGSlF5eExRVUZLTEVOQlFWVXNiVUpCUVcxQ1lpeERRVUZETEVkQlFVY3NRMEZCZGtJc1NVRkJORUlzUjBGQk5VSXNSMEZCYTBOakxFbEJRVWtzUTBGQlEwTXNVMEZCVEN4RFFVRmxWaXhMUVVGbUxFTkJRVFZETEVOQlFVNDdRVUZEUkN4UFFVaE5MRTFCUjBFN1FVRkRURXdzVVVGQlFVRXNRMEZCUXp0QlFVTkdPMEZCUTBZN1FVRkRSaXhIUVd4RUswTXNRMEZ2UkdoRU8wRkJRMEU3T3p0QlFVTkJMRmRCUVZOVExHVkJRVlFzUTBGQmVVSlFMRXRCUVhwQ0xFVkJRV2RETzBGQlF6bENMRkZCUVUxakxGVkJRVlVzUjBGQlNTeDFRa0ZCUkN4RFFVRXdRbElzU1VGQk1VSXNRMEZCSzBKaUxFOUJRVThzUTBGQlEwc3NRMEZCUkN4RFFVRjBReXhEUVVGdVFqczdRVUZEUVN4UlFVRkpaMElzVlVGQlNpeEZRVUZuUWp0QlFVTmtMRlZCUVVsRExGTkJRVk1zUjBGQlIwUXNWVUZCVlN4RFFVRkRMRU5CUVVRc1EwRkJWaXhMUVVGclFpeExRVUZzUWl4SFFVRXdRaXhMUVVFeFFpeEhRVUZyUXl4TFFVRnNSRHRCUVVOQkxGVkJRVTFGTEVsQlFVa3NSMEZCUjBZc1ZVRkJWU3hEUVVGRExFTkJRVVFzUTBGQlZpeERRVUZqY0VJc1MwRkJaQ3hEUVVGdlFpeEpRVUZ3UWl4RlFVRXdRaXhEUVVFeFFpeERRVUZpTzBGQlEwRXNWVUZCU1hWQ0xGRkJRVkVzUjBGQlIwUXNTVUZCU1N4RFFVRkRMRU5CUVVRc1EwRkJTaXhEUVVGUlJTeFBRVUZTTEVOQlFXZENMRTlCUVdoQ0xFVkJRWGxDTEVsQlFYcENMRU5CUVdZN08wRkJRMEVzVlVGQlN5eFJRVUZFTEVOQlFWZGtMRWxCUVZnc1EwRkJaMEpoTEZGQlFXaENMRU5CUVVvc1JVRkJLMEk3UVVGRE4wSkJMRkZCUVVGQkxGRkJRVkVzUjBGQlIwRXNVVUZCVVN4RFFVRkRSU3hOUVVGVUxFTkJRV2RDTEVOQlFXaENMRVZCUVcxQ1JpeFJRVUZSTEVOQlFVTm1MRTFCUVZRc1IwRkJhMElzUTBGQmNrTXNRMEZCV0R0QlFVTkVPenRCUVVORVJpeE5RVUZCUVN4TFFVRkxMRU5CUVVObExGTkJRVk1zUjBGQlJ5eFZRVUZpTEVOQlFVd3NSMEZCWjBORkxGRkJRV2hETzBGQlEwRnFRaXhOUVVGQlFTeExRVUZMTEVOQlFVTmxMRk5CUVZNc1IwRkJSeXhSUVVGaUxFTkJRVXdzUjBGQk9FSXNRMEZCUTBNc1NVRkJTU3hEUVVGRExFTkJRVVFzUTBGQlNpeEpRVUZYTEVWQlFWb3NSVUZCWjBKSkxFbEJRV2hDTEVWQlFUbENPMEZCUlVGMFFpeE5RVUZCUVN4RFFVRkRPMEZCUTBZN1FVRkRSaXhIUVhCRkswTXNRMEZ6UldoRU8wRkJRMEU3T3p0QlFVTkJMRmRCUVZOWExGTkJRVlFzUjBGQmNVSTdRVUZEYmtJc1VVRkJTVmtzWjBKQlFXZENMRWRCUVVkMlFpeERRVUYyUWp0QlFVRkJMRkZCUTBsM1FpeGxRVUZsTEVkQlFVYzNRaXhQUVVGUExFTkJRVU5MTEVOQlFVTXNSVUZCUml4RFFVUTNRanRCUVVGQkxGRkJSVWw1UWl4WFFVRlhMRWRCUVVkRUxHVkJRV1VzUTBGQlF6VkNMRXRCUVdoQ0xFTkJRWE5DTERSRFFVRjBRaXhEUVVac1FqdEJRVWxCTEZGQlFVazRRaXhKUVVGSkxFZEJRVWM3UVVGRFZFTXNUVUZCUVVFc1VVRkJVU3hGUVVGRkxFTkJRVU5HTEZkQlFWY3NRMEZCUXl4RFFVRkVMRU5CUkdJN1FVRkZWRWNzVFVGQlFVRXNVVUZCVVN4RlFVRkZMRTlCUVU5SUxGZEJRVmNzUTBGQlF5eERRVUZFTEVOQlFXeENMRXRCUVRCQ0xGZEJRVEZDTEVkQlFYZERMRU5CUVhoRExFZEJRVFJETEVOQlFVTkJMRmRCUVZjc1EwRkJReXhEUVVGRUxFTkJSbnBFTzBGQlIxUkpMRTFCUVVGQkxGRkJRVkVzUlVGQlJTeERRVUZEU2l4WFFVRlhMRU5CUVVNc1EwRkJSQ3hEUVVoaU8wRkJTVlJMTEUxQlFVRkJMRkZCUVZFc1JVRkJSU3hQUVVGUFRDeFhRVUZYTEVOQlFVTXNRMEZCUkN4RFFVRnNRaXhMUVVFd1FpeFhRVUV4UWl4SFFVRjNReXhEUVVGNFF5eEhRVUUwUXl4RFFVRkRRU3hYUVVGWExFTkJRVU1zUTBGQlJDeERRVXA2UkR0QlFVdFVUU3hOUVVGQlFTeExRVUZMTEVWQlFVVXNSVUZNUlR0QlFVMVVReXhOUVVGQlFTeGpRVUZqTEVWQlFVVTdRVUZPVUN4TFFVRllMRU5CVEcxQ0xFTkJZMjVDTzBGQlEwRTdRVUZEUVRzN1FVRkRRU3hSUVVGSlRpeEpRVUZKTEVOQlFVTkZMRkZCUVV3c1MwRkJhMElzUTBGQmRFSXNSVUZCZVVJN1FVRkRka0pHTEUxQlFVRkJMRWxCUVVrc1EwRkJRME1zVVVGQlRDeEpRVUZwUWl4RFFVRnFRanRCUVVORU96dEJRVU5FTEZGQlFVbEVMRWxCUVVrc1EwRkJRMGtzVVVGQlRDeExRVUZyUWl4RFFVRjBRaXhGUVVGNVFqdEJRVU4yUWtvc1RVRkJRVUVzU1VGQlNTeERRVUZEUnl4UlFVRk1MRWxCUVdsQ0xFTkJRV3BDTzBGQlEwUTdPMEZCUlVRc1VVRkJTVWtzVVVGQlVTeEhRVUZITEVOQlFXWTdRVUZCUVN4UlFVTkpReXhYUVVGWExFZEJRVWNzUTBGRWJFSTdPMEZCUlVFc1YwRkJUMnhETEVOQlFVTXNSMEZCUjB3c1QwRkJUeXhEUVVGRFV5eE5RVUZ1UWl4RlFVRXlRa29zUTBGQlF5eEZRVUUxUWl4RlFVRm5RenRCUVVNNVFqdEJRVU5CTzBGQlEwRXNWVUZCU1V3c1QwRkJUeXhEUVVGRFN5eERRVUZFTEVOQlFWQXNRMEZCVjIxRExFOUJRVmdzUTBGQmJVSXNUVUZCYmtJc1RVRkJLMElzUTBGQkwwSXNTVUZEVFc1RExFTkJRVU1zUjBGQlJ5eERRVUZLTEVkQlFWRk1MRTlCUVU4c1EwRkJRMU1zVFVGRWRFSXNTVUZGUzFRc1QwRkJUeXhEUVVGRFN5eERRVUZETEVkQlFVY3NRMEZCVEN4RFFVRlFMRU5CUVdWdFF5eFBRVUZtTEVOQlFYVkNMRTFCUVhaQ0xFMUJRVzFETEVOQlJuaERMRWxCUjB0NFF5eFBRVUZQTEVOQlFVTkxMRU5CUVVNc1IwRkJSeXhEUVVGTUxFTkJRVkFzUTBGQlpXMURMRTlCUVdZc1EwRkJkVUlzU1VGQmRrSXNUVUZCYVVNc1EwRklNVU1zUlVGSE5rTTdRVUZEZWtNN1FVRkRTRHM3UVVGRFJDeFZRVUZKUXl4VFFVRlRMRWRCUVVsNlF5eFBRVUZQTEVOQlFVTkxMRU5CUVVRc1EwRkJVQ3hEUVVGWFNTeE5RVUZZTEVsQlFYRkNMRU5CUVhKQ0xFbEJRVEJDU2l4RFFVRkRMRWxCUVV0TUxFOUJRVThzUTBGQlExTXNUVUZCVWl4SFFVRnBRaXhEUVVGc1JDeEhRVUYzUkN4SFFVRjRSQ3hIUVVFNFJGUXNUMEZCVHl4RFFVRkRTeXhEUVVGRUxFTkJRVkFzUTBGQlZ5eERRVUZZTEVOQlFUbEZPenRCUVVWQkxGVkJRVWx2UXl4VFFVRlRMRXRCUVVzc1IwRkJaQ3hKUVVGeFFrRXNVMEZCVXl4TFFVRkxMRWRCUVc1RExFbEJRVEJEUVN4VFFVRlRMRXRCUVVzc1IwRkJlRVFzU1VGQkswUkJMRk5CUVZNc1MwRkJTeXhKUVVGcVJpeEZRVUYxUmp0QlFVTnlSbFlzVVVGQlFVRXNTVUZCU1N4RFFVRkRTeXhMUVVGTUxFTkJRVmMxUWl4SlFVRllMRU5CUVdkQ1VpeFBRVUZQTEVOQlFVTkxMRU5CUVVRc1EwRkJka0k3UVVGRFFUQkNMRkZCUVVGQkxFbEJRVWtzUTBGQlEwMHNZMEZCVEN4RFFVRnZRamRDTEVsQlFYQkNMRU5CUVhsQ1RpeFZRVUZWTEVOQlFVTkhMRU5CUVVRc1EwRkJWaXhKUVVGcFFpeEpRVUV4UXpzN1FVRkZRU3haUVVGSmIwTXNVMEZCVXl4TFFVRkxMRWRCUVd4Q0xFVkJRWFZDTzBGQlEzSkNTQ3hWUVVGQlFTeFJRVUZSTzBGQlExUXNVMEZHUkN4TlFVVlBMRWxCUVVsSExGTkJRVk1zUzBGQlN5eEhRVUZzUWl4RlFVRjFRanRCUVVNMVFrWXNWVUZCUVVFc1YwRkJWenRCUVVOYUxGTkJSazBzVFVGRlFTeEpRVUZKUlN4VFFVRlRMRXRCUVVzc1IwRkJiRUlzUlVGQmRVSTdRVUZETlVKSUxGVkJRVUZCTEZGQlFWRTdRVUZEVWtNc1ZVRkJRVUVzVjBGQlZ6dEJRVU5hTzBGQlEwWXNUMEZhUkN4TlFWbFBPMEZCUTB3N1FVRkRSRHRCUVVOR0xFdEJjRVJyUWl4RFFYTkVia0k3T3p0QlFVTkJMRkZCUVVrc1EwRkJRMFFzVVVGQlJDeEpRVUZoVUN4SlFVRkpMRU5CUVVOSkxGRkJRVXdzUzBGQmEwSXNRMEZCYmtNc1JVRkJjME03UVVGRGNFTktMRTFCUVVGQkxFbEJRVWtzUTBGQlEwa3NVVUZCVEN4SFFVRm5RaXhEUVVGb1FqdEJRVU5FT3p0QlFVTkVMRkZCUVVrc1EwRkJRMGtzVjBGQlJDeEpRVUZuUWxJc1NVRkJTU3hEUVVGRFJTeFJRVUZNTEV0QlFXdENMRU5CUVhSRExFVkJRWGxETzBGQlEzWkRSaXhOUVVGQlFTeEpRVUZKTEVOQlFVTkZMRkZCUVV3c1IwRkJaMElzUTBGQmFFSTdRVUZEUkN4TFFUVkVhMElzUTBFNFJHNUNPenM3UVVGRFFTeFJRVUZKYkVNc1QwRkJUeXhEUVVGRGEwSXNUVUZCV2l4RlFVRnZRanRCUVVOc1FpeFZRVUZKY1VJc1VVRkJVU3hMUVVGTFVDeEpRVUZKTEVOQlFVTkpMRkZCUVhSQ0xFVkJRV2RETzBGQlF6bENMR05CUVUwc1NVRkJTV3BDTEV0QlFVb3NRMEZCVlN4elJFRkJjMFJWTEdkQ1FVRm5RaXhIUVVGSExFTkJRWHBGTEVOQlFWWXNRMEZCVGp0QlFVTkVPenRCUVVORUxGVkJRVWxYTEZkQlFWY3NTMEZCUzFJc1NVRkJTU3hEUVVGRFJTeFJRVUY2UWl4RlFVRnRRenRCUVVOcVF5eGpRVUZOTEVsQlFVbG1MRXRCUVVvc1EwRkJWU3gzUkVGQmQwUlZMR2RDUVVGblFpeEhRVUZITEVOQlFUTkZMRU5CUVZZc1EwRkJUanRCUVVORU8wRkJRMFk3TzBGQlJVUXNWMEZCVDBjc1NVRkJVRHRCUVVORU96dEJRVVZFTEZOQlFVOHhRaXhEUVVGRExFZEJRVWRNTEU5QlFVOHNRMEZCUTFNc1RVRkJia0lzUlVGQk1rSTdRVUZEZWtKSUxFbEJRVUZCTEZWQlFWVTdRVUZEV0RzN1FVRkZSQ3hUUVVGUFJpeEpRVUZRTzBGQlEwUWlMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUpsZUhCdmNuUWdablZ1WTNScGIyNGdjR0Z5YzJWUVlYUmphQ2gxYm1sRWFXWm1MQ0J2Y0hScGIyNXpJRDBnZTMwcElIdGNiaUFnYkdWMElHUnBabVp6ZEhJZ1BTQjFibWxFYVdabUxuTndiR2wwS0M5Y1hISmNYRzU4VzF4Y2JseGNkbHhjWmx4Y2NseGNlRGcxWFM4cExGeHVJQ0FnSUNBZ1pHVnNhVzFwZEdWeWN5QTlJSFZ1YVVScFptWXViV0YwWTJnb0wxeGNjbHhjYm54YlhGeHVYRngyWEZ4bVhGeHlYRng0T0RWZEwyY3BJSHg4SUZ0ZExGeHVJQ0FnSUNBZ2JHbHpkQ0E5SUZ0ZExGeHVJQ0FnSUNBZ2FTQTlJREE3WEc1Y2JpQWdablZ1WTNScGIyNGdjR0Z5YzJWSmJtUmxlQ2dwSUh0Y2JpQWdJQ0JzWlhRZ2FXNWtaWGdnUFNCN2ZUdGNiaUFnSUNCc2FYTjBMbkIxYzJnb2FXNWtaWGdwTzF4dVhHNGdJQ0FnTHk4Z1VHRnljMlVnWkdsbVppQnRaWFJoWkdGMFlWeHVJQ0FnSUhkb2FXeGxJQ2hwSUR3Z1pHbG1abk4wY2k1c1pXNW5kR2dwSUh0Y2JpQWdJQ0FnSUd4bGRDQnNhVzVsSUQwZ1pHbG1abk4wY2x0cFhUdGNibHh1SUNBZ0lDQWdMeThnUm1sc1pTQm9aV0ZrWlhJZ1ptOTFibVFzSUdWdVpDQndZWEp6YVc1bklHUnBabVlnYldWMFlXUmhkR0ZjYmlBZ0lDQWdJR2xtSUNnb0wxNG9YRnd0WEZ3dFhGd3RmRnhjSzF4Y0sxeGNLM3hBUUNsY1hITXZLUzUwWlhOMEtHeHBibVVwS1NCN1hHNGdJQ0FnSUNBZ0lHSnlaV0ZyTzF4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBdkx5QkVhV1ptSUdsdVpHVjRYRzRnSUNBZ0lDQnNaWFFnYUdWaFpHVnlJRDBnS0M5ZUtEODZTVzVrWlhnNmZHUnBabVlvUHpvZ0xYSWdYRngzS3lrcktWeGNjeXNvTGlzL0tWeGNjeW9rTHlrdVpYaGxZeWhzYVc1bEtUdGNiaUFnSUNBZ0lHbG1JQ2hvWldGa1pYSXBJSHRjYmlBZ0lDQWdJQ0FnYVc1a1pYZ3VhVzVrWlhnZ1BTQm9aV0ZrWlhKYk1WMDdYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJR2tyS3p0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0F2THlCUVlYSnpaU0JtYVd4bElHaGxZV1JsY25NZ2FXWWdkR2hsZVNCaGNtVWdaR1ZtYVc1bFpDNGdWVzVwWm1sbFpDQmthV1ptSUhKbGNYVnBjbVZ6SUhSb1pXMHNJR0oxZEZ4dUlDQWdJQzh2SUhSb1pYSmxKM01nYm04Z2RHVmphRzVwWTJGc0lHbHpjM1ZsY3lCMGJ5Qm9ZWFpsSUdGdUlHbHpiMnhoZEdWa0lHaDFibXNnZDJsMGFHOTFkQ0JtYVd4bElHaGxZV1JsY2x4dUlDQWdJSEJoY25ObFJtbHNaVWhsWVdSbGNpaHBibVJsZUNrN1hHNGdJQ0FnY0dGeWMyVkdhV3hsU0dWaFpHVnlLR2x1WkdWNEtUdGNibHh1SUNBZ0lDOHZJRkJoY25ObElHaDFibXR6WEc0Z0lDQWdhVzVrWlhndWFIVnVhM01nUFNCYlhUdGNibHh1SUNBZ0lIZG9hV3hsSUNocElEd2daR2xtWm5OMGNpNXNaVzVuZEdncElIdGNiaUFnSUNBZ0lHeGxkQ0JzYVc1bElEMGdaR2xtWm5OMGNsdHBYVHRjYmx4dUlDQWdJQ0FnYVdZZ0tDZ3ZYaWhKYm1SbGVEcDhaR2xtWm54Y1hDMWNYQzFjWEMxOFhGd3JYRndyWEZ3cktWeGNjeThwTG5SbGMzUW9iR2x1WlNrcElIdGNiaUFnSUNBZ0lDQWdZbkpsWVdzN1hHNGdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tDZ3ZYa0JBTHlrdWRHVnpkQ2hzYVc1bEtTa2dlMXh1SUNBZ0lDQWdJQ0JwYm1SbGVDNW9kVzVyY3k1d2RYTm9LSEJoY25ObFNIVnVheWdwS1R0Y2JpQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb2JHbHVaU0FtSmlCdmNIUnBiMjV6TG5OMGNtbGpkQ2tnZTF4dUlDQWdJQ0FnSUNBdkx5QkpaMjV2Y21VZ2RXNWxlSEJsWTNSbFpDQmpiMjUwWlc1MElIVnViR1Z6Y3lCcGJpQnpkSEpwWTNRZ2JXOWtaVnh1SUNBZ0lDQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9KMVZ1YTI1dmQyNGdiR2x1WlNBbklDc2dLR2tnS3lBeEtTQXJJQ2NnSnlBcklFcFRUMDR1YzNSeWFXNW5hV1o1S0d4cGJtVXBLVHRjYmlBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJR2tyS3p0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNBdkx5QlFZWEp6WlhNZ2RHaGxJQzB0TFNCaGJtUWdLeXNySUdobFlXUmxjbk1zSUdsbUlHNXZibVVnWVhKbElHWnZkVzVrTENCdWJ5QnNhVzVsYzF4dUlDQXZMeUJoY21VZ1kyOXVjM1Z0WldRdVhHNGdJR1oxYm1OMGFXOXVJSEJoY25ObFJtbHNaVWhsWVdSbGNpaHBibVJsZUNrZ2UxeHVJQ0FnSUdOdmJuTjBJR1pwYkdWSVpXRmtaWElnUFNBb0wxNG9MUzB0ZkZ4Y0sxeGNLMXhjS3lsY1hITXJLQzRxS1NRdktTNWxlR1ZqS0dScFptWnpkSEpiYVYwcE8xeHVJQ0FnSUdsbUlDaG1hV3hsU0dWaFpHVnlLU0I3WEc0Z0lDQWdJQ0JzWlhRZ2EyVjVVSEpsWm1sNElEMGdabWxzWlVobFlXUmxjbHN4WFNBOVBUMGdKeTB0TFNjZ1B5QW5iMnhrSnlBNklDZHVaWGNuTzF4dUlDQWdJQ0FnWTI5dWMzUWdaR0YwWVNBOUlHWnBiR1ZJWldGa1pYSmJNbDB1YzNCc2FYUW9KMXhjZENjc0lESXBPMXh1SUNBZ0lDQWdiR1YwSUdacGJHVk9ZVzFsSUQwZ1pHRjBZVnN3WFM1eVpYQnNZV05sS0M5Y1hGeGNYRnhjWEM5bkxDQW5YRnhjWENjcE8xeHVJQ0FnSUNBZ2FXWWdLQ2d2WGx3aUxpcGNJaVF2S1M1MFpYTjBLR1pwYkdWT1lXMWxLU2tnZTF4dUlDQWdJQ0FnSUNCbWFXeGxUbUZ0WlNBOUlHWnBiR1ZPWVcxbExuTjFZbk4wY2lneExDQm1hV3hsVG1GdFpTNXNaVzVuZEdnZ0xTQXlLVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQWdJR2x1WkdWNFcydGxlVkJ5WldacGVDQXJJQ2RHYVd4bFRtRnRaU2RkSUQwZ1ptbHNaVTVoYldVN1hHNGdJQ0FnSUNCcGJtUmxlRnRyWlhsUWNtVm1hWGdnS3lBblNHVmhaR1Z5SjEwZ1BTQW9aR0YwWVZzeFhTQjhmQ0FuSnlrdWRISnBiU2dwTzF4dVhHNGdJQ0FnSUNCcEt5czdYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdMeThnVUdGeWMyVnpJR0VnYUhWdWExeHVJQ0F2THlCVWFHbHpJR0Z6YzNWdFpYTWdkR2hoZENCM1pTQmhjbVVnWVhRZ2RHaGxJSE4wWVhKMElHOW1JR0VnYUhWdWF5NWNiaUFnWm5WdVkzUnBiMjRnY0dGeWMyVklkVzVyS0NrZ2UxeHVJQ0FnSUd4bGRDQmphSFZ1YTBobFlXUmxja2x1WkdWNElEMGdhU3hjYmlBZ0lDQWdJQ0FnWTJoMWJtdElaV0ZrWlhKTWFXNWxJRDBnWkdsbVpuTjBjbHRwS3l0ZExGeHVJQ0FnSUNBZ0lDQmphSFZ1YTBobFlXUmxjaUE5SUdOb2RXNXJTR1ZoWkdWeVRHbHVaUzV6Y0d4cGRDZ3ZRRUFnTFNoY1hHUXJLU2cvT2l3b1hGeGtLeWtwUHlCY1hDc29YRnhrS3lrb1B6b3NLRnhjWkNzcEtUOGdRRUF2S1R0Y2JseHVJQ0FnSUd4bGRDQm9kVzVySUQwZ2UxeHVJQ0FnSUNBZ2IyeGtVM1JoY25RNklDdGphSFZ1YTBobFlXUmxjbHN4WFN4Y2JpQWdJQ0FnSUc5c1pFeHBibVZ6T2lCMGVYQmxiMllnWTJoMWJtdElaV0ZrWlhKYk1sMGdQVDA5SUNkMWJtUmxabWx1WldRbklEOGdNU0E2SUN0amFIVnVhMGhsWVdSbGNsc3lYU3hjYmlBZ0lDQWdJRzVsZDFOMFlYSjBPaUFyWTJoMWJtdElaV0ZrWlhKYk0xMHNYRzRnSUNBZ0lDQnVaWGRNYVc1bGN6b2dkSGx3Wlc5bUlHTm9kVzVyU0dWaFpHVnlXelJkSUQwOVBTQW5kVzVrWldacGJtVmtKeUEvSURFZ09pQXJZMmgxYm10SVpXRmtaWEpiTkYwc1hHNGdJQ0FnSUNCc2FXNWxjem9nVzEwc1hHNGdJQ0FnSUNCc2FXNWxaR1ZzYVcxcGRHVnljem9nVzExY2JpQWdJQ0I5TzF4dVhHNGdJQ0FnTHk4Z1ZXNXBabWxsWkNCRWFXWm1JRVp2Y20xaGRDQnhkV2x5YXpvZ1NXWWdkR2hsSUdOb2RXNXJJSE5wZW1VZ2FYTWdNQ3hjYmlBZ0lDQXZMeUIwYUdVZ1ptbHljM1FnYm5WdFltVnlJR2x6SUc5dVpTQnNiM2RsY2lCMGFHRnVJRzl1WlNCM2IzVnNaQ0JsZUhCbFkzUXVYRzRnSUNBZ0x5OGdhSFIwY0hNNkx5OTNkM2N1WVhKMGFXMWhMbU52YlM5M1pXSnNiMmR6TDNacFpYZHdiM04wTG1wemNEOTBhSEpsWVdROU1UWTBNamt6WEc0Z0lDQWdhV1lnS0doMWJtc3ViMnhrVEdsdVpYTWdQVDA5SURBcElIdGNiaUFnSUNBZ0lHaDFibXN1YjJ4a1UzUmhjblFnS3owZ01UdGNiaUFnSUNCOVhHNGdJQ0FnYVdZZ0tHaDFibXN1Ym1WM1RHbHVaWE1nUFQwOUlEQXBJSHRjYmlBZ0lDQWdJR2gxYm1zdWJtVjNVM1JoY25RZ0t6MGdNVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnNaWFFnWVdSa1EyOTFiblFnUFNBd0xGeHVJQ0FnSUNBZ0lDQnlaVzF2ZG1WRGIzVnVkQ0E5SURBN1hHNGdJQ0FnWm05eUlDZzdJR2tnUENCa2FXWm1jM1J5TG14bGJtZDBhRHNnYVNzcktTQjdYRzRnSUNBZ0lDQXZMeUJNYVc1bGN5QnpkR0Z5ZEdsdVp5QjNhWFJvSUNjdExTMG5JR052ZFd4a0lHSmxJRzFwYzNSaGEyVnVJR1p2Y2lCMGFHVWdYQ0p5WlcxdmRtVWdiR2x1WlZ3aUlHOXdaWEpoZEdsdmJseHVJQ0FnSUNBZ0x5OGdRblYwSUhSb1pYa2dZMjkxYkdRZ1ltVWdkR2hsSUdobFlXUmxjaUJtYjNJZ2RHaGxJRzVsZUhRZ1ptbHNaUzRnVkdobGNtVm1iM0psSUhCeWRXNWxJSE4xWTJnZ1kyRnpaWE1nYjNWMExseHVJQ0FnSUNBZ2FXWWdLR1JwWm1aemRISmJhVjB1YVc1a1pYaFBaaWduTFMwdElDY3BJRDA5UFNBd1hHNGdJQ0FnSUNBZ0lDQWdJQ0FtSmlBb2FTQXJJRElnUENCa2FXWm1jM1J5TG14bGJtZDBhQ2xjYmlBZ0lDQWdJQ0FnSUNBZ0lDWW1JR1JwWm1aemRISmJhU0FySURGZExtbHVaR1Y0VDJZb0p5c3JLeUFuS1NBOVBUMGdNRnh1SUNBZ0lDQWdJQ0FnSUNBZ0ppWWdaR2xtWm5OMGNsdHBJQ3NnTWwwdWFXNWtaWGhQWmlnblFFQW5LU0E5UFQwZ01Da2dlMXh1SUNBZ0lDQWdJQ0FnSUdKeVpXRnJPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lDQWdiR1YwSUc5d1pYSmhkR2x2YmlBOUlDaGthV1ptYzNSeVcybGRMbXhsYm1kMGFDQTlQU0F3SUNZbUlHa2dJVDBnS0dScFptWnpkSEl1YkdWdVozUm9JQzBnTVNrcElEOGdKeUFuSURvZ1pHbG1abk4wY2x0cFhWc3dYVHRjYmx4dUlDQWdJQ0FnYVdZZ0tHOXdaWEpoZEdsdmJpQTlQVDBnSnlzbklIeDhJRzl3WlhKaGRHbHZiaUE5UFQwZ0p5MG5JSHg4SUc5d1pYSmhkR2x2YmlBOVBUMGdKeUFuSUh4OElHOXdaWEpoZEdsdmJpQTlQVDBnSjF4Y1hGd25LU0I3WEc0Z0lDQWdJQ0FnSUdoMWJtc3ViR2x1WlhNdWNIVnphQ2hrYVdabWMzUnlXMmxkS1R0Y2JpQWdJQ0FnSUNBZ2FIVnVheTVzYVc1bFpHVnNhVzFwZEdWeWN5NXdkWE5vS0dSbGJHbHRhWFJsY25OYmFWMGdmSHdnSjF4Y2JpY3BPMXh1WEc0Z0lDQWdJQ0FnSUdsbUlDaHZjR1Z5WVhScGIyNGdQVDA5SUNjckp5a2dlMXh1SUNBZ0lDQWdJQ0FnSUdGa1pFTnZkVzUwS3lzN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCcFppQW9iM0JsY21GMGFXOXVJRDA5UFNBbkxTY3BJSHRjYmlBZ0lDQWdJQ0FnSUNCeVpXMXZkbVZEYjNWdWRDc3JPMXh1SUNBZ0lDQWdJQ0I5SUdWc2MyVWdhV1lnS0c5d1pYSmhkR2x2YmlBOVBUMGdKeUFuS1NCN1hHNGdJQ0FnSUNBZ0lDQWdZV1JrUTI5MWJuUXJLenRjYmlBZ0lDQWdJQ0FnSUNCeVpXMXZkbVZEYjNWdWRDc3JPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0JpY21WaGF6dGNiaUFnSUNBZ0lIMWNiaUFnSUNCOVhHNWNiaUFnSUNBdkx5QklZVzVrYkdVZ2RHaGxJR1Z0Y0hSNUlHSnNiMk5ySUdOdmRXNTBJR05oYzJWY2JpQWdJQ0JwWmlBb0lXRmtaRU52ZFc1MElDWW1JR2gxYm1zdWJtVjNUR2x1WlhNZ1BUMDlJREVwSUh0Y2JpQWdJQ0FnSUdoMWJtc3VibVYzVEdsdVpYTWdQU0F3TzF4dUlDQWdJSDFjYmlBZ0lDQnBaaUFvSVhKbGJXOTJaVU52ZFc1MElDWW1JR2gxYm1zdWIyeGtUR2x1WlhNZ1BUMDlJREVwSUh0Y2JpQWdJQ0FnSUdoMWJtc3ViMnhrVEdsdVpYTWdQU0F3TzF4dUlDQWdJSDFjYmx4dUlDQWdJQzh2SUZCbGNtWnZjbTBnYjNCMGFXOXVZV3dnYzJGdWFYUjVJR05vWldOcmFXNW5YRzRnSUNBZ2FXWWdLRzl3ZEdsdmJuTXVjM1J5YVdOMEtTQjdYRzRnSUNBZ0lDQnBaaUFvWVdSa1EyOTFiblFnSVQwOUlHaDFibXN1Ym1WM1RHbHVaWE1wSUh0Y2JpQWdJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0NkQlpHUmxaQ0JzYVc1bElHTnZkVzUwSUdScFpDQnViM1FnYldGMFkyZ2dabTl5SUdoMWJtc2dZWFFnYkdsdVpTQW5JQ3NnS0dOb2RXNXJTR1ZoWkdWeVNXNWtaWGdnS3lBeEtTazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQnBaaUFvY21WdGIzWmxRMjkxYm5RZ0lUMDlJR2gxYm1zdWIyeGtUR2x1WlhNcElIdGNiaUFnSUNBZ0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtDZFNaVzF2ZG1Wa0lHeHBibVVnWTI5MWJuUWdaR2xrSUc1dmRDQnRZWFJqYUNCbWIzSWdhSFZ1YXlCaGRDQnNhVzVsSUNjZ0t5QW9ZMmgxYm10SVpXRmtaWEpKYm1SbGVDQXJJREVwS1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc1Y2JpQWdJQ0J5WlhSMWNtNGdhSFZ1YXp0Y2JpQWdmVnh1WEc0Z0lIZG9hV3hsSUNocElEd2daR2xtWm5OMGNpNXNaVzVuZEdncElIdGNiaUFnSUNCd1lYSnpaVWx1WkdWNEtDazdYRzRnSUgxY2JseHVJQ0J5WlhSMWNtNGdiR2x6ZER0Y2JuMWNiaUpkZlE9PVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/diff/lib/patch/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/diff/lib/patch/reverse.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mocha/node_modules/diff/lib/patch/reverse.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/*istanbul ignore start*/\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.reversePatch = reversePatch;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*istanbul ignore end*/\nfunction reversePatch(structuredPatch) {\n  if (Array.isArray(structuredPatch)) {\n    return structuredPatch.map(reversePatch).reverse();\n  }\n\n  return (\n    /*istanbul ignore start*/\n    _objectSpread(_objectSpread({},\n    /*istanbul ignore end*/\n    structuredPatch), {}, {\n      oldFileName: structuredPatch.newFileName,\n      oldHeader: structuredPatch.newHeader,\n      newFileName: structuredPatch.oldFileName,\n      newHeader: structuredPatch.oldHeader,\n      hunks: structuredPatch.hunks.map(function (hunk) {\n        return {\n          oldLines: hunk.newLines,\n          oldStart: hunk.newStart,\n          newLines: hunk.oldLines,\n          newStart: hunk.oldStart,\n          linedelimiters: hunk.linedelimiters,\n          lines: hunk.lines.map(function (l) {\n            if (l.startsWith('-')) {\n              return (\n                /*istanbul ignore start*/\n                \"+\".concat(\n                /*istanbul ignore end*/\n                l.slice(1))\n              );\n            }\n\n            if (l.startsWith('+')) {\n              return (\n                /*istanbul ignore start*/\n                \"-\".concat(\n                /*istanbul ignore end*/\n                l.slice(1))\n              );\n            }\n\n            return l;\n          })\n        };\n      })\n    })\n  );\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXRjaC9yZXZlcnNlLmpzIl0sIm5hbWVzIjpbInJldmVyc2VQYXRjaCIsInN0cnVjdHVyZWRQYXRjaCIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsInJldmVyc2UiLCJvbGRGaWxlTmFtZSIsIm5ld0ZpbGVOYW1lIiwib2xkSGVhZGVyIiwibmV3SGVhZGVyIiwiaHVua3MiLCJodW5rIiwib2xkTGluZXMiLCJuZXdMaW5lcyIsIm9sZFN0YXJ0IiwibmV3U3RhcnQiLCJsaW5lZGVsaW1pdGVycyIsImxpbmVzIiwibCIsInN0YXJ0c1dpdGgiLCJzbGljZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQU8sU0FBU0EsWUFBVCxDQUFzQkMsZUFBdEIsRUFBdUM7QUFDNUMsTUFBSUMsS0FBSyxDQUFDQyxPQUFOLENBQWNGLGVBQWQsQ0FBSixFQUFvQztBQUNsQyxXQUFPQSxlQUFlLENBQUNHLEdBQWhCLENBQW9CSixZQUFwQixFQUFrQ0ssT0FBbEMsRUFBUDtBQUNEOztBQUVEO0FBQUE7QUFBQTtBQUFBO0FBQ0tKLElBQUFBLGVBREw7QUFFRUssTUFBQUEsV0FBVyxFQUFFTCxlQUFlLENBQUNNLFdBRi9CO0FBR0VDLE1BQUFBLFNBQVMsRUFBRVAsZUFBZSxDQUFDUSxTQUg3QjtBQUlFRixNQUFBQSxXQUFXLEVBQUVOLGVBQWUsQ0FBQ0ssV0FKL0I7QUFLRUcsTUFBQUEsU0FBUyxFQUFFUixlQUFlLENBQUNPLFNBTDdCO0FBTUVFLE1BQUFBLEtBQUssRUFBRVQsZUFBZSxDQUFDUyxLQUFoQixDQUFzQk4sR0FBdEIsQ0FBMEIsVUFBQU8sSUFBSSxFQUFJO0FBQ3ZDLGVBQU87QUFDTEMsVUFBQUEsUUFBUSxFQUFFRCxJQUFJLENBQUNFLFFBRFY7QUFFTEMsVUFBQUEsUUFBUSxFQUFFSCxJQUFJLENBQUNJLFFBRlY7QUFHTEYsVUFBQUEsUUFBUSxFQUFFRixJQUFJLENBQUNDLFFBSFY7QUFJTEcsVUFBQUEsUUFBUSxFQUFFSixJQUFJLENBQUNHLFFBSlY7QUFLTEUsVUFBQUEsY0FBYyxFQUFFTCxJQUFJLENBQUNLLGNBTGhCO0FBTUxDLFVBQUFBLEtBQUssRUFBRU4sSUFBSSxDQUFDTSxLQUFMLENBQVdiLEdBQVgsQ0FBZSxVQUFBYyxDQUFDLEVBQUk7QUFDekIsZ0JBQUlBLENBQUMsQ0FBQ0MsVUFBRixDQUFhLEdBQWIsQ0FBSixFQUF1QjtBQUFFO0FBQUE7QUFBQTtBQUFBO0FBQVdELGdCQUFBQSxDQUFDLENBQUNFLEtBQUYsQ0FBUSxDQUFSLENBQVg7QUFBQTtBQUEwQjs7QUFDbkQsZ0JBQUlGLENBQUMsQ0FBQ0MsVUFBRixDQUFhLEdBQWIsQ0FBSixFQUF1QjtBQUFFO0FBQUE7QUFBQTtBQUFBO0FBQVdELGdCQUFBQSxDQUFDLENBQUNFLEtBQUYsQ0FBUSxDQUFSLENBQVg7QUFBQTtBQUEwQjs7QUFDbkQsbUJBQU9GLENBQVA7QUFDRCxXQUpNO0FBTkYsU0FBUDtBQVlELE9BYk07QUFOVDtBQUFBO0FBcUJEIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIHJldmVyc2VQYXRjaChzdHJ1Y3R1cmVkUGF0Y2gpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RydWN0dXJlZFBhdGNoKSkge1xuICAgIHJldHVybiBzdHJ1Y3R1cmVkUGF0Y2gubWFwKHJldmVyc2VQYXRjaCkucmV2ZXJzZSgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdHJ1Y3R1cmVkUGF0Y2gsXG4gICAgb2xkRmlsZU5hbWU6IHN0cnVjdHVyZWRQYXRjaC5uZXdGaWxlTmFtZSxcbiAgICBvbGRIZWFkZXI6IHN0cnVjdHVyZWRQYXRjaC5uZXdIZWFkZXIsXG4gICAgbmV3RmlsZU5hbWU6IHN0cnVjdHVyZWRQYXRjaC5vbGRGaWxlTmFtZSxcbiAgICBuZXdIZWFkZXI6IHN0cnVjdHVyZWRQYXRjaC5vbGRIZWFkZXIsXG4gICAgaHVua3M6IHN0cnVjdHVyZWRQYXRjaC5odW5rcy5tYXAoaHVuayA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvbGRMaW5lczogaHVuay5uZXdMaW5lcyxcbiAgICAgICAgb2xkU3RhcnQ6IGh1bmsubmV3U3RhcnQsXG4gICAgICAgIG5ld0xpbmVzOiBodW5rLm9sZExpbmVzLFxuICAgICAgICBuZXdTdGFydDogaHVuay5vbGRTdGFydCxcbiAgICAgICAgbGluZWRlbGltaXRlcnM6IGh1bmsubGluZWRlbGltaXRlcnMsXG4gICAgICAgIGxpbmVzOiBodW5rLmxpbmVzLm1hcChsID0+IHtcbiAgICAgICAgICBpZiAobC5zdGFydHNXaXRoKCctJykpIHsgcmV0dXJuIGArJHtsLnNsaWNlKDEpfWA7IH1cbiAgICAgICAgICBpZiAobC5zdGFydHNXaXRoKCcrJykpIHsgcmV0dXJuIGAtJHtsLnNsaWNlKDEpfWA7IH1cbiAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSlcbiAgfTtcbn1cbiJdfQ==\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL3BhdGNoL3JldmVyc2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixvQkFBb0I7O0FBRXBCLDJDQUEyQyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCw4REFBOEQsaUVBQWlFLEdBQUcsa0NBQWtDOztBQUV2VSxpQ0FBaUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCxhQUFhLHVEQUF1RCw0Q0FBNEMsS0FBSyw2Q0FBNkMsNkVBQTZFLE9BQU8saURBQWlELG1GQUFtRixPQUFPOztBQUV0Z0IsNENBQTRDLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7O0FBRXBNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL3BhdGNoL3JldmVyc2UuanM/NzNjZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmV2ZXJzZVBhdGNoID0gcmV2ZXJzZVBhdGNoO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbmZ1bmN0aW9uIHJldmVyc2VQYXRjaChzdHJ1Y3R1cmVkUGF0Y2gpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RydWN0dXJlZFBhdGNoKSkge1xuICAgIHJldHVybiBzdHJ1Y3R1cmVkUGF0Y2gubWFwKHJldmVyc2VQYXRjaCkucmV2ZXJzZSgpO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LFxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgc3RydWN0dXJlZFBhdGNoKSwge30sIHtcbiAgICAgIG9sZEZpbGVOYW1lOiBzdHJ1Y3R1cmVkUGF0Y2gubmV3RmlsZU5hbWUsXG4gICAgICBvbGRIZWFkZXI6IHN0cnVjdHVyZWRQYXRjaC5uZXdIZWFkZXIsXG4gICAgICBuZXdGaWxlTmFtZTogc3RydWN0dXJlZFBhdGNoLm9sZEZpbGVOYW1lLFxuICAgICAgbmV3SGVhZGVyOiBzdHJ1Y3R1cmVkUGF0Y2gub2xkSGVhZGVyLFxuICAgICAgaHVua3M6IHN0cnVjdHVyZWRQYXRjaC5odW5rcy5tYXAoZnVuY3Rpb24gKGh1bmspIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBvbGRMaW5lczogaHVuay5uZXdMaW5lcyxcbiAgICAgICAgICBvbGRTdGFydDogaHVuay5uZXdTdGFydCxcbiAgICAgICAgICBuZXdMaW5lczogaHVuay5vbGRMaW5lcyxcbiAgICAgICAgICBuZXdTdGFydDogaHVuay5vbGRTdGFydCxcbiAgICAgICAgICBsaW5lZGVsaW1pdGVyczogaHVuay5saW5lZGVsaW1pdGVycyxcbiAgICAgICAgICBsaW5lczogaHVuay5saW5lcy5tYXAoZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgIGlmIChsLnN0YXJ0c1dpdGgoJy0nKSkge1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgICAgICAgICAgICBcIitcIi5jb25jYXQoXG4gICAgICAgICAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAgICAgICAgICAgICBsLnNsaWNlKDEpKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobC5zdGFydHNXaXRoKCcrJykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICAgICAgICAgICAgXCItXCIuY29uY2F0KFxuICAgICAgICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICAgICAgICAgICAgbC5zbGljZSgxKSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgfSlcbiAgKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXdZWFJqYUM5eVpYWmxjbk5sTG1weklsMHNJbTVoYldWeklqcGJJbkpsZG1WeWMyVlFZWFJqYUNJc0luTjBjblZqZEhWeVpXUlFZWFJqYUNJc0lrRnljbUY1SWl3aWFYTkJjbkpoZVNJc0ltMWhjQ0lzSW5KbGRtVnljMlVpTENKdmJHUkdhV3hsVG1GdFpTSXNJbTVsZDBacGJHVk9ZVzFsSWl3aWIyeGtTR1ZoWkdWeUlpd2libVYzU0dWaFpHVnlJaXdpYUhWdWEzTWlMQ0pvZFc1cklpd2liMnhrVEdsdVpYTWlMQ0p1WlhkTWFXNWxjeUlzSW05c1pGTjBZWEowSWl3aWJtVjNVM1JoY25RaUxDSnNhVzVsWkdWc2FXMXBkR1Z5Y3lJc0lteHBibVZ6SWl3aWJDSXNJbk4wWVhKMGMxZHBkR2dpTENKemJHbGpaU0pkTENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN096czdPenM3TzBGQlFVOHNVMEZCVTBFc1dVRkJWQ3hEUVVGelFrTXNaVUZCZEVJc1JVRkJkVU03UVVGRE5VTXNUVUZCU1VNc1MwRkJTeXhEUVVGRFF5eFBRVUZPTEVOQlFXTkdMR1ZCUVdRc1EwRkJTaXhGUVVGdlF6dEJRVU5zUXl4WFFVRlBRU3hsUVVGbExFTkJRVU5ITEVkQlFXaENMRU5CUVc5Q1NpeFpRVUZ3UWl4RlFVRnJRMHNzVDBGQmJFTXNSVUZCVUR0QlFVTkVPenRCUVVWRU8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlEwdEtMRWxCUVVGQkxHVkJSRXc3UVVGRlJVc3NUVUZCUVVFc1YwRkJWeXhGUVVGRlRDeGxRVUZsTEVOQlFVTk5MRmRCUmk5Q08wRkJSMFZETEUxQlFVRkJMRk5CUVZNc1JVRkJSVkFzWlVGQlpTeERRVUZEVVN4VFFVZzNRanRCUVVsRlJpeE5RVUZCUVN4WFFVRlhMRVZCUVVWT0xHVkJRV1VzUTBGQlEwc3NWMEZLTDBJN1FVRkxSVWNzVFVGQlFVRXNVMEZCVXl4RlFVRkZVaXhsUVVGbExFTkJRVU5QTEZOQlREZENPMEZCVFVWRkxFMUJRVUZCTEV0QlFVc3NSVUZCUlZRc1pVRkJaU3hEUVVGRFV5eExRVUZvUWl4RFFVRnpRazRzUjBGQmRFSXNRMEZCTUVJc1ZVRkJRVThzU1VGQlNTeEZRVUZKTzBGQlEzWkRMR1ZCUVU4N1FVRkRURU1zVlVGQlFVRXNVVUZCVVN4RlFVRkZSQ3hKUVVGSkxFTkJRVU5GTEZGQlJGWTdRVUZGVEVNc1ZVRkJRVUVzVVVGQlVTeEZRVUZGU0N4SlFVRkpMRU5CUVVOSkxGRkJSbFk3UVVGSFRFWXNWVUZCUVVFc1VVRkJVU3hGUVVGRlJpeEpRVUZKTEVOQlFVTkRMRkZCU0ZZN1FVRkpURWNzVlVGQlFVRXNVVUZCVVN4RlFVRkZTaXhKUVVGSkxFTkJRVU5ITEZGQlNsWTdRVUZMVEVVc1ZVRkJRVUVzWTBGQll5eEZRVUZGVEN4SlFVRkpMRU5CUVVOTExHTkJUR2hDTzBGQlRVeERMRlZCUVVGQkxFdEJRVXNzUlVGQlJVNHNTVUZCU1N4RFFVRkRUU3hMUVVGTUxFTkJRVmRpTEVkQlFWZ3NRMEZCWlN4VlFVRkJZeXhEUVVGRExFVkJRVWs3UVVGRGVrSXNaMEpCUVVsQkxFTkJRVU1zUTBGQlEwTXNWVUZCUml4RFFVRmhMRWRCUVdJc1EwRkJTaXhGUVVGMVFqdEJRVUZGTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVZkRUxHZENRVUZCUVN4RFFVRkRMRU5CUVVORkxFdEJRVVlzUTBGQlVTeERRVUZTTEVOQlFWZzdRVUZCUVR0QlFVRXdRanM3UVVGRGJrUXNaMEpCUVVsR0xFTkJRVU1zUTBGQlEwTXNWVUZCUml4RFFVRmhMRWRCUVdJc1EwRkJTaXhGUVVGMVFqdEJRVUZGTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVZkRUxHZENRVUZCUVN4RFFVRkRMRU5CUVVORkxFdEJRVVlzUTBGQlVTeERRVUZTTEVOQlFWZzdRVUZCUVR0QlFVRXdRanM3UVVGRGJrUXNiVUpCUVU5R0xFTkJRVkE3UVVGRFJDeFhRVXBOTzBGQlRrWXNVMEZCVUR0QlFWbEVMRTlCWWswN1FVRk9WRHRCUVVGQk8wRkJjVUpFSWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaVpYaHdiM0owSUdaMWJtTjBhVzl1SUhKbGRtVnljMlZRWVhSamFDaHpkSEoxWTNSMWNtVmtVR0YwWTJncElIdGNiaUFnYVdZZ0tFRnljbUY1TG1selFYSnlZWGtvYzNSeWRXTjBkWEpsWkZCaGRHTm9LU2tnZTF4dUlDQWdJSEpsZEhWeWJpQnpkSEoxWTNSMWNtVmtVR0YwWTJndWJXRndLSEpsZG1WeWMyVlFZWFJqYUNrdWNtVjJaWEp6WlNncE8xeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlIdGNiaUFnSUNBdUxpNXpkSEoxWTNSMWNtVmtVR0YwWTJnc1hHNGdJQ0FnYjJ4a1JtbHNaVTVoYldVNklITjBjblZqZEhWeVpXUlFZWFJqYUM1dVpYZEdhV3hsVG1GdFpTeGNiaUFnSUNCdmJHUklaV0ZrWlhJNklITjBjblZqZEhWeVpXUlFZWFJqYUM1dVpYZElaV0ZrWlhJc1hHNGdJQ0FnYm1WM1JtbHNaVTVoYldVNklITjBjblZqZEhWeVpXUlFZWFJqYUM1dmJHUkdhV3hsVG1GdFpTeGNiaUFnSUNCdVpYZElaV0ZrWlhJNklITjBjblZqZEhWeVpXUlFZWFJqYUM1dmJHUklaV0ZrWlhJc1hHNGdJQ0FnYUhWdWEzTTZJSE4wY25WamRIVnlaV1JRWVhSamFDNW9kVzVyY3k1dFlYQW9hSFZ1YXlBOVBpQjdYRzRnSUNBZ0lDQnlaWFIxY200Z2UxeHVJQ0FnSUNBZ0lDQnZiR1JNYVc1bGN6b2dhSFZ1YXk1dVpYZE1hVzVsY3l4Y2JpQWdJQ0FnSUNBZ2IyeGtVM1JoY25RNklHaDFibXN1Ym1WM1UzUmhjblFzWEc0Z0lDQWdJQ0FnSUc1bGQweHBibVZ6T2lCb2RXNXJMbTlzWkV4cGJtVnpMRnh1SUNBZ0lDQWdJQ0J1WlhkVGRHRnlkRG9nYUhWdWF5NXZiR1JUZEdGeWRDeGNiaUFnSUNBZ0lDQWdiR2x1WldSbGJHbHRhWFJsY25NNklHaDFibXN1YkdsdVpXUmxiR2x0YVhSbGNuTXNYRzRnSUNBZ0lDQWdJR3hwYm1Wek9pQm9kVzVyTG14cGJtVnpMbTFoY0Noc0lEMCtJSHRjYmlBZ0lDQWdJQ0FnSUNCcFppQW9iQzV6ZEdGeWRITlhhWFJvS0NjdEp5a3BJSHNnY21WMGRYSnVJR0FySkh0c0xuTnNhV05sS0RFcGZXQTdJSDFjYmlBZ0lDQWdJQ0FnSUNCcFppQW9iQzV6ZEdGeWRITlhhWFJvS0Njckp5a3BJSHNnY21WMGRYSnVJR0F0Skh0c0xuTnNhV05sS0RFcGZXQTdJSDFjYmlBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnYkR0Y2JpQWdJQ0FnSUNBZ2ZTbGNiaUFnSUNBZ0lIMDdYRzRnSUNBZ2ZTbGNiaUFnZlR0Y2JuMWNiaUpkZlE9PVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/diff/lib/patch/reverse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/diff/lib/util/array.js":
/*!****************************************************************!*\
  !*** ./node_modules/mocha/node_modules/diff/lib/util/array.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/*istanbul ignore start*/\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.arrayEqual = arrayEqual;\nexports.arrayStartsWith = arrayStartsWith;\n\n/*istanbul ignore end*/\nfunction arrayEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  return arrayStartsWith(a, b);\n}\n\nfunction arrayStartsWith(array, start) {\n  if (start.length > array.length) {\n    return false;\n  }\n\n  for (var i = 0; i < start.length; i++) {\n    if (start[i] !== array[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2FycmF5LmpzIl0sIm5hbWVzIjpbImFycmF5RXF1YWwiLCJhIiwiYiIsImxlbmd0aCIsImFycmF5U3RhcnRzV2l0aCIsImFycmF5Iiwic3RhcnQiLCJpIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQU8sU0FBU0EsVUFBVCxDQUFvQkMsQ0FBcEIsRUFBdUJDLENBQXZCLEVBQTBCO0FBQy9CLE1BQUlELENBQUMsQ0FBQ0UsTUFBRixLQUFhRCxDQUFDLENBQUNDLE1BQW5CLEVBQTJCO0FBQ3pCLFdBQU8sS0FBUDtBQUNEOztBQUVELFNBQU9DLGVBQWUsQ0FBQ0gsQ0FBRCxFQUFJQyxDQUFKLENBQXRCO0FBQ0Q7O0FBRU0sU0FBU0UsZUFBVCxDQUF5QkMsS0FBekIsRUFBZ0NDLEtBQWhDLEVBQXVDO0FBQzVDLE1BQUlBLEtBQUssQ0FBQ0gsTUFBTixHQUFlRSxLQUFLLENBQUNGLE1BQXpCLEVBQWlDO0FBQy9CLFdBQU8sS0FBUDtBQUNEOztBQUVELE9BQUssSUFBSUksQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0QsS0FBSyxDQUFDSCxNQUExQixFQUFrQ0ksQ0FBQyxFQUFuQyxFQUF1QztBQUNyQyxRQUFJRCxLQUFLLENBQUNDLENBQUQsQ0FBTCxLQUFhRixLQUFLLENBQUNFLENBQUQsQ0FBdEIsRUFBMkI7QUFDekIsYUFBTyxLQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPLElBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBhcnJheUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBhcnJheVN0YXJ0c1dpdGgoYSwgYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheVN0YXJ0c1dpdGgoYXJyYXksIHN0YXJ0KSB7XG4gIGlmIChzdGFydC5sZW5ndGggPiBhcnJheS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0YXJ0W2ldICE9PSBhcnJheVtpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuIl19\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL3V0aWwvYXJyYXkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7QUFDbEIsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL21vY2hhL25vZGVfbW9kdWxlcy9kaWZmL2xpYi91dGlsL2FycmF5LmpzPzRlNDciXSwic291cmNlc0NvbnRlbnQiOlsiLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFycmF5RXF1YWwgPSBhcnJheUVxdWFsO1xuZXhwb3J0cy5hcnJheVN0YXJ0c1dpdGggPSBhcnJheVN0YXJ0c1dpdGg7XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5mdW5jdGlvbiBhcnJheUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBhcnJheVN0YXJ0c1dpdGgoYSwgYik7XG59XG5cbmZ1bmN0aW9uIGFycmF5U3RhcnRzV2l0aChhcnJheSwgc3RhcnQpIHtcbiAgaWYgKHN0YXJ0Lmxlbmd0aCA+IGFycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhcnQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RhcnRbaV0gIT09IGFycmF5W2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTkxZEdsc0wyRnljbUY1TG1weklsMHNJbTVoYldWeklqcGJJbUZ5Y21GNVJYRjFZV3dpTENKaElpd2lZaUlzSW14bGJtZDBhQ0lzSW1GeWNtRjVVM1JoY25SelYybDBhQ0lzSW1GeWNtRjVJaXdpYzNSaGNuUWlMQ0pwSWwwc0ltMWhjSEJwYm1keklqb2lPenM3T3pzN096czdPMEZCUVU4c1UwRkJVMEVzVlVGQlZDeERRVUZ2UWtNc1EwRkJjRUlzUlVGQmRVSkRMRU5CUVhaQ0xFVkJRVEJDTzBGQlF5OUNMRTFCUVVsRUxFTkJRVU1zUTBGQlEwVXNUVUZCUml4TFFVRmhSQ3hEUVVGRExFTkJRVU5ETEUxQlFXNUNMRVZCUVRKQ08wRkJRM3BDTEZkQlFVOHNTMEZCVUR0QlFVTkVPenRCUVVWRUxGTkJRVTlETEdWQlFXVXNRMEZCUTBnc1EwRkJSQ3hGUVVGSlF5eERRVUZLTEVOQlFYUkNPMEZCUTBRN08wRkJSVTBzVTBGQlUwVXNaVUZCVkN4RFFVRjVRa01zUzBGQmVrSXNSVUZCWjBORExFdEJRV2hETEVWQlFYVkRPMEZCUXpWRExFMUJRVWxCTEV0QlFVc3NRMEZCUTBnc1RVRkJUaXhIUVVGbFJTeExRVUZMTEVOQlFVTkdMRTFCUVhwQ0xFVkJRV2xETzBGQlF5OUNMRmRCUVU4c1MwRkJVRHRCUVVORU96dEJRVVZFTEU5QlFVc3NTVUZCU1Vrc1EwRkJReXhIUVVGSExFTkJRV0lzUlVGQlowSkJMRU5CUVVNc1IwRkJSMFFzUzBGQlN5eERRVUZEU0N4TlFVRXhRaXhGUVVGclEwa3NRMEZCUXl4RlFVRnVReXhGUVVGMVF6dEJRVU55UXl4UlFVRkpSQ3hMUVVGTExFTkJRVU5ETEVOQlFVUXNRMEZCVEN4TFFVRmhSaXhMUVVGTExFTkJRVU5GTEVOQlFVUXNRMEZCZEVJc1JVRkJNa0k3UVVGRGVrSXNZVUZCVHl4TFFVRlFPMEZCUTBRN1FVRkRSanM3UVVGRlJDeFRRVUZQTEVsQlFWQTdRVUZEUkNJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYkltVjRjRzl5ZENCbWRXNWpkR2x2YmlCaGNuSmhlVVZ4ZFdGc0tHRXNJR0lwSUh0Y2JpQWdhV1lnS0dFdWJHVnVaM1JvSUNFOVBTQmlMbXhsYm1kMGFDa2dlMXh1SUNBZ0lISmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUJoY25KaGVWTjBZWEowYzFkcGRHZ29ZU3dnWWlrN1hHNTlYRzVjYm1WNGNHOXlkQ0JtZFc1amRHbHZiaUJoY25KaGVWTjBZWEowYzFkcGRHZ29ZWEp5WVhrc0lITjBZWEowS1NCN1hHNGdJR2xtSUNoemRHRnlkQzVzWlc1bmRHZ2dQaUJoY25KaGVTNXNaVzVuZEdncElIdGNiaUFnSUNCeVpYUjFjbTRnWm1Gc2MyVTdYRzRnSUgxY2JseHVJQ0JtYjNJZ0tHeGxkQ0JwSUQwZ01Ec2dhU0E4SUhOMFlYSjBMbXhsYm1kMGFEc2dhU3NyS1NCN1hHNGdJQ0FnYVdZZ0tITjBZWEowVzJsZElDRTlQU0JoY25KaGVWdHBYU2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJR1poYkhObE8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCMGNuVmxPMXh1ZlZ4dUlsMTlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/diff/lib/util/array.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/diff/lib/util/distance-iterator.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mocha/node_modules/diff/lib/util/distance-iterator.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/*istanbul ignore start*/\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = _default;\n\n/*istanbul ignore end*/\n// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nfunction\n/*istanbul ignore start*/\n_default\n/*istanbul ignore end*/\n(start, minLine, maxLine) {\n  var wantForward = true,\n      backwardExhausted = false,\n      forwardExhausted = false,\n      localOffset = 1;\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      } // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n\n\n      if (start + localOffset <= maxLine) {\n        return localOffset;\n      }\n\n      forwardExhausted = true;\n    }\n\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      } // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n\n\n      if (minLine <= start - localOffset) {\n        return -localOffset++;\n      }\n\n      backwardExhausted = true;\n      return iterator();\n    } // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n\n  };\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2Rpc3RhbmNlLWl0ZXJhdG9yLmpzIl0sIm5hbWVzIjpbInN0YXJ0IiwibWluTGluZSIsIm1heExpbmUiLCJ3YW50Rm9yd2FyZCIsImJhY2t3YXJkRXhoYXVzdGVkIiwiZm9yd2FyZEV4aGF1c3RlZCIsImxvY2FsT2Zmc2V0IiwiaXRlcmF0b3IiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNlO0FBQUE7QUFBQTtBQUFBO0FBQUEsQ0FBU0EsS0FBVCxFQUFnQkMsT0FBaEIsRUFBeUJDLE9BQXpCLEVBQWtDO0FBQy9DLE1BQUlDLFdBQVcsR0FBRyxJQUFsQjtBQUFBLE1BQ0lDLGlCQUFpQixHQUFHLEtBRHhCO0FBQUEsTUFFSUMsZ0JBQWdCLEdBQUcsS0FGdkI7QUFBQSxNQUdJQyxXQUFXLEdBQUcsQ0FIbEI7QUFLQSxTQUFPLFNBQVNDLFFBQVQsR0FBb0I7QUFDekIsUUFBSUosV0FBVyxJQUFJLENBQUNFLGdCQUFwQixFQUFzQztBQUNwQyxVQUFJRCxpQkFBSixFQUF1QjtBQUNyQkUsUUFBQUEsV0FBVztBQUNaLE9BRkQsTUFFTztBQUNMSCxRQUFBQSxXQUFXLEdBQUcsS0FBZDtBQUNELE9BTG1DLENBT3BDO0FBQ0E7OztBQUNBLFVBQUlILEtBQUssR0FBR00sV0FBUixJQUF1QkosT0FBM0IsRUFBb0M7QUFDbEMsZUFBT0ksV0FBUDtBQUNEOztBQUVERCxNQUFBQSxnQkFBZ0IsR0FBRyxJQUFuQjtBQUNEOztBQUVELFFBQUksQ0FBQ0QsaUJBQUwsRUFBd0I7QUFDdEIsVUFBSSxDQUFDQyxnQkFBTCxFQUF1QjtBQUNyQkYsUUFBQUEsV0FBVyxHQUFHLElBQWQ7QUFDRCxPQUhxQixDQUt0QjtBQUNBOzs7QUFDQSxVQUFJRixPQUFPLElBQUlELEtBQUssR0FBR00sV0FBdkIsRUFBb0M7QUFDbEMsZUFBTyxDQUFDQSxXQUFXLEVBQW5CO0FBQ0Q7O0FBRURGLE1BQUFBLGlCQUFpQixHQUFHLElBQXBCO0FBQ0EsYUFBT0csUUFBUSxFQUFmO0FBQ0QsS0E5QndCLENBZ0N6QjtBQUNBOztBQUNELEdBbENEO0FBbUNEIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSXRlcmF0b3IgdGhhdCB0cmF2ZXJzZXMgaW4gdGhlIHJhbmdlIG9mIFttaW4sIG1heF0sIHN0ZXBwaW5nXG4vLyBieSBkaXN0YW5jZSBmcm9tIGEgZ2l2ZW4gc3RhcnQgcG9zaXRpb24uIEkuZS4gZm9yIFswLCA0XSwgd2l0aFxuLy8gc3RhcnQgb2YgMiwgdGhpcyB3aWxsIGl0ZXJhdGUgMiwgMywgMSwgNCwgMC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0YXJ0LCBtaW5MaW5lLCBtYXhMaW5lKSB7XG4gIGxldCB3YW50Rm9yd2FyZCA9IHRydWUsXG4gICAgICBiYWNrd2FyZEV4aGF1c3RlZCA9IGZhbHNlLFxuICAgICAgZm9yd2FyZEV4aGF1c3RlZCA9IGZhbHNlLFxuICAgICAgbG9jYWxPZmZzZXQgPSAxO1xuXG4gIHJldHVybiBmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICBpZiAod2FudEZvcndhcmQgJiYgIWZvcndhcmRFeGhhdXN0ZWQpIHtcbiAgICAgIGlmIChiYWNrd2FyZEV4aGF1c3RlZCkge1xuICAgICAgICBsb2NhbE9mZnNldCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FudEZvcndhcmQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdHJ5aW5nIHRvIGZpdCBiZXlvbmQgdGV4dCBsZW5ndGgsIGFuZCBpZiBub3QsIGNoZWNrIGl0IGZpdHNcbiAgICAgIC8vIGFmdGVyIG9mZnNldCBsb2NhdGlvbiAob3IgZGVzaXJlZCBsb2NhdGlvbiBvbiBmaXJzdCBpdGVyYXRpb24pXG4gICAgICBpZiAoc3RhcnQgKyBsb2NhbE9mZnNldCA8PSBtYXhMaW5lKSB7XG4gICAgICAgIHJldHVybiBsb2NhbE9mZnNldDtcbiAgICAgIH1cblxuICAgICAgZm9yd2FyZEV4aGF1c3RlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFiYWNrd2FyZEV4aGF1c3RlZCkge1xuICAgICAgaWYgKCFmb3J3YXJkRXhoYXVzdGVkKSB7XG4gICAgICAgIHdhbnRGb3J3YXJkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdHJ5aW5nIHRvIGZpdCBiZWZvcmUgdGV4dCBiZWdpbm5pbmcsIGFuZCBpZiBub3QsIGNoZWNrIGl0IGZpdHNcbiAgICAgIC8vIGJlZm9yZSBvZmZzZXQgbG9jYXRpb25cbiAgICAgIGlmIChtaW5MaW5lIDw9IHN0YXJ0IC0gbG9jYWxPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIC1sb2NhbE9mZnNldCsrO1xuICAgICAgfVxuXG4gICAgICBiYWNrd2FyZEV4aGF1c3RlZCA9IHRydWU7XG4gICAgICByZXR1cm4gaXRlcmF0b3IoKTtcbiAgICB9XG5cbiAgICAvLyBXZSB0cmllZCB0byBmaXQgaHVuayBiZWZvcmUgdGV4dCBiZWdpbm5pbmcgYW5kIGJleW9uZCB0ZXh0IGxlbmd0aCwgdGhlblxuICAgIC8vIGh1bmsgY2FuJ3QgZml0IG9uIHRoZSB0ZXh0LiBSZXR1cm4gdW5kZWZpbmVkXG4gIH07XG59XG4iXX0=\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL3V0aWwvZGlzdGFuY2UtaXRlcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9ub2RlX21vZHVsZXMvZGlmZi9saWIvdXRpbC9kaXN0YW5jZS1pdGVyYXRvci5qcz82ZGRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbi8vIEl0ZXJhdG9yIHRoYXQgdHJhdmVyc2VzIGluIHRoZSByYW5nZSBvZiBbbWluLCBtYXhdLCBzdGVwcGluZ1xuLy8gYnkgZGlzdGFuY2UgZnJvbSBhIGdpdmVuIHN0YXJ0IHBvc2l0aW9uLiBJLmUuIGZvciBbMCwgNF0sIHdpdGhcbi8vIHN0YXJ0IG9mIDIsIHRoaXMgd2lsbCBpdGVyYXRlIDIsIDMsIDEsIDQsIDAuXG5mdW5jdGlvblxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2RlZmF1bHRcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4oc3RhcnQsIG1pbkxpbmUsIG1heExpbmUpIHtcbiAgdmFyIHdhbnRGb3J3YXJkID0gdHJ1ZSxcbiAgICAgIGJhY2t3YXJkRXhoYXVzdGVkID0gZmFsc2UsXG4gICAgICBmb3J3YXJkRXhoYXVzdGVkID0gZmFsc2UsXG4gICAgICBsb2NhbE9mZnNldCA9IDE7XG4gIHJldHVybiBmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICBpZiAod2FudEZvcndhcmQgJiYgIWZvcndhcmRFeGhhdXN0ZWQpIHtcbiAgICAgIGlmIChiYWNrd2FyZEV4aGF1c3RlZCkge1xuICAgICAgICBsb2NhbE9mZnNldCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FudEZvcndhcmQgPSBmYWxzZTtcbiAgICAgIH0gLy8gQ2hlY2sgaWYgdHJ5aW5nIHRvIGZpdCBiZXlvbmQgdGV4dCBsZW5ndGgsIGFuZCBpZiBub3QsIGNoZWNrIGl0IGZpdHNcbiAgICAgIC8vIGFmdGVyIG9mZnNldCBsb2NhdGlvbiAob3IgZGVzaXJlZCBsb2NhdGlvbiBvbiBmaXJzdCBpdGVyYXRpb24pXG5cblxuICAgICAgaWYgKHN0YXJ0ICsgbG9jYWxPZmZzZXQgPD0gbWF4TGluZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGZvcndhcmRFeGhhdXN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghYmFja3dhcmRFeGhhdXN0ZWQpIHtcbiAgICAgIGlmICghZm9yd2FyZEV4aGF1c3RlZCkge1xuICAgICAgICB3YW50Rm9yd2FyZCA9IHRydWU7XG4gICAgICB9IC8vIENoZWNrIGlmIHRyeWluZyB0byBmaXQgYmVmb3JlIHRleHQgYmVnaW5uaW5nLCBhbmQgaWYgbm90LCBjaGVjayBpdCBmaXRzXG4gICAgICAvLyBiZWZvcmUgb2Zmc2V0IGxvY2F0aW9uXG5cblxuICAgICAgaWYgKG1pbkxpbmUgPD0gc3RhcnQgLSBsb2NhbE9mZnNldCkge1xuICAgICAgICByZXR1cm4gLWxvY2FsT2Zmc2V0Kys7XG4gICAgICB9XG5cbiAgICAgIGJhY2t3YXJkRXhoYXVzdGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBpdGVyYXRvcigpO1xuICAgIH0gLy8gV2UgdHJpZWQgdG8gZml0IGh1bmsgYmVmb3JlIHRleHQgYmVnaW5uaW5nIGFuZCBiZXlvbmQgdGV4dCBsZW5ndGgsIHRoZW5cbiAgICAvLyBodW5rIGNhbid0IGZpdCBvbiB0aGUgdGV4dC4gUmV0dXJuIHVuZGVmaW5lZFxuXG4gIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTkxZEdsc0wyUnBjM1JoYm1ObExXbDBaWEpoZEc5eUxtcHpJbDBzSW01aGJXVnpJanBiSW5OMFlYSjBJaXdpYldsdVRHbHVaU0lzSW0xaGVFeHBibVVpTENKM1lXNTBSbTl5ZDJGeVpDSXNJbUpoWTJ0M1lYSmtSWGhvWVhWemRHVmtJaXdpWm05eWQyRnlaRVY0YUdGMWMzUmxaQ0lzSW14dlkyRnNUMlptYzJWMElpd2lhWFJsY21GMGIzSWlYU3dpYldGd2NHbHVaM01pT2lJN096czdPenM3T3p0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVObE8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRXNRMEZCVTBFc1MwRkJWQ3hGUVVGblFrTXNUMEZCYUVJc1JVRkJlVUpETEU5QlFYcENMRVZCUVd0RE8wRkJReTlETEUxQlFVbERMRmRCUVZjc1IwRkJSeXhKUVVGc1FqdEJRVUZCTEUxQlEwbERMR2xDUVVGcFFpeEhRVUZITEV0QlJIaENPMEZCUVVFc1RVRkZTVU1zWjBKQlFXZENMRWRCUVVjc1MwRkdka0k3UVVGQlFTeE5RVWRKUXl4WFFVRlhMRWRCUVVjc1EwRkliRUk3UVVGTFFTeFRRVUZQTEZOQlFWTkRMRkZCUVZRc1IwRkJiMEk3UVVGRGVrSXNVVUZCU1Vvc1YwRkJWeXhKUVVGSkxFTkJRVU5GTEdkQ1FVRndRaXhGUVVGelF6dEJRVU53UXl4VlFVRkpSQ3hwUWtGQlNpeEZRVUYxUWp0QlFVTnlRa1VzVVVGQlFVRXNWMEZCVnp0QlFVTmFMRTlCUmtRc1RVRkZUenRCUVVOTVNDeFJRVUZCUVN4WFFVRlhMRWRCUVVjc1MwRkJaRHRCUVVORUxFOUJURzFETEVOQlQzQkRPMEZCUTBFN096dEJRVU5CTEZWQlFVbElMRXRCUVVzc1IwRkJSMDBzVjBGQlVpeEpRVUYxUWtvc1QwRkJNMElzUlVGQmIwTTdRVUZEYkVNc1pVRkJUMGtzVjBGQlVEdEJRVU5FT3p0QlFVVkVSQ3hOUVVGQlFTeG5Ra0ZCWjBJc1IwRkJSeXhKUVVGdVFqdEJRVU5FT3p0QlFVVkVMRkZCUVVrc1EwRkJRMFFzYVVKQlFVd3NSVUZCZDBJN1FVRkRkRUlzVlVGQlNTeERRVUZEUXl4blFrRkJUQ3hGUVVGMVFqdEJRVU55UWtZc1VVRkJRVUVzVjBGQlZ5eEhRVUZITEVsQlFXUTdRVUZEUkN4UFFVaHhRaXhEUVV0MFFqdEJRVU5CT3pzN1FVRkRRU3hWUVVGSlJpeFBRVUZQTEVsQlFVbEVMRXRCUVVzc1IwRkJSMDBzVjBGQmRrSXNSVUZCYjBNN1FVRkRiRU1zWlVGQlR5eERRVUZEUVN4WFFVRlhMRVZCUVc1Q08wRkJRMFE3TzBGQlJVUkdMRTFCUVVGQkxHbENRVUZwUWl4SFFVRkhMRWxCUVhCQ08wRkJRMEVzWVVGQlQwY3NVVUZCVVN4RlFVRm1PMEZCUTBRc1MwRTVRbmRDTEVOQlowTjZRanRCUVVOQk96dEJRVU5FTEVkQmJFTkVPMEZCYlVORUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lMeThnU1hSbGNtRjBiM0lnZEdoaGRDQjBjbUYyWlhKelpYTWdhVzRnZEdobElISmhibWRsSUc5bUlGdHRhVzRzSUcxaGVGMHNJSE4wWlhCd2FXNW5YRzR2THlCaWVTQmthWE4wWVc1alpTQm1jbTl0SUdFZ1oybDJaVzRnYzNSaGNuUWdjRzl6YVhScGIyNHVJRWt1WlM0Z1ptOXlJRnN3TENBMFhTd2dkMmwwYUZ4dUx5OGdjM1JoY25RZ2IyWWdNaXdnZEdocGN5QjNhV3hzSUdsMFpYSmhkR1VnTWl3Z015d2dNU3dnTkN3Z01DNWNibVY0Y0c5eWRDQmtaV1poZFd4MElHWjFibU4wYVc5dUtITjBZWEowTENCdGFXNU1hVzVsTENCdFlYaE1hVzVsS1NCN1hHNGdJR3hsZENCM1lXNTBSbTl5ZDJGeVpDQTlJSFJ5ZFdVc1hHNGdJQ0FnSUNCaVlXTnJkMkZ5WkVWNGFHRjFjM1JsWkNBOUlHWmhiSE5sTEZ4dUlDQWdJQ0FnWm05eWQyRnlaRVY0YUdGMWMzUmxaQ0E5SUdaaGJITmxMRnh1SUNBZ0lDQWdiRzlqWVd4UFptWnpaWFFnUFNBeE8xeHVYRzRnSUhKbGRIVnliaUJtZFc1amRHbHZiaUJwZEdWeVlYUnZjaWdwSUh0Y2JpQWdJQ0JwWmlBb2QyRnVkRVp2Y25kaGNtUWdKaVlnSVdadmNuZGhjbVJGZUdoaGRYTjBaV1FwSUh0Y2JpQWdJQ0FnSUdsbUlDaGlZV05yZDJGeVpFVjRhR0YxYzNSbFpDa2dlMXh1SUNBZ0lDQWdJQ0JzYjJOaGJFOW1abk5sZENzck8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ2QyRnVkRVp2Y25kaGNtUWdQU0JtWVd4elpUdGNiaUFnSUNBZ0lIMWNibHh1SUNBZ0lDQWdMeThnUTJobFkyc2dhV1lnZEhKNWFXNW5JSFJ2SUdacGRDQmlaWGx2Ym1RZ2RHVjRkQ0JzWlc1bmRHZ3NJR0Z1WkNCcFppQnViM1FzSUdOb1pXTnJJR2wwSUdacGRITmNiaUFnSUNBZ0lDOHZJR0ZtZEdWeUlHOW1abk5sZENCc2IyTmhkR2x2YmlBb2IzSWdaR1Z6YVhKbFpDQnNiMk5oZEdsdmJpQnZiaUJtYVhKemRDQnBkR1Z5WVhScGIyNHBYRzRnSUNBZ0lDQnBaaUFvYzNSaGNuUWdLeUJzYjJOaGJFOW1abk5sZENBOFBTQnRZWGhNYVc1bEtTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQnNiMk5oYkU5bVpuTmxkRHRjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnWm05eWQyRnlaRVY0YUdGMWMzUmxaQ0E5SUhSeWRXVTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2FXWWdLQ0ZpWVdOcmQyRnlaRVY0YUdGMWMzUmxaQ2tnZTF4dUlDQWdJQ0FnYVdZZ0tDRm1iM0ozWVhKa1JYaG9ZWFZ6ZEdWa0tTQjdYRzRnSUNBZ0lDQWdJSGRoYm5SR2IzSjNZWEprSUQwZ2RISjFaVHRjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnTHk4Z1EyaGxZMnNnYVdZZ2RISjVhVzVuSUhSdklHWnBkQ0JpWldadmNtVWdkR1Y0ZENCaVpXZHBibTVwYm1jc0lHRnVaQ0JwWmlCdWIzUXNJR05vWldOcklHbDBJR1pwZEhOY2JpQWdJQ0FnSUM4dklHSmxabTl5WlNCdlptWnpaWFFnYkc5allYUnBiMjVjYmlBZ0lDQWdJR2xtSUNodGFXNU1hVzVsSUR3OUlITjBZWEowSUMwZ2JHOWpZV3hQWm1aelpYUXBJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJQzFzYjJOaGJFOW1abk5sZENzck8xeHVJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQmlZV05yZDJGeVpFVjRhR0YxYzNSbFpDQTlJSFJ5ZFdVN1hHNGdJQ0FnSUNCeVpYUjFjbTRnYVhSbGNtRjBiM0lvS1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0F2THlCWFpTQjBjbWxsWkNCMGJ5Qm1hWFFnYUhWdWF5QmlaV1p2Y21VZ2RHVjRkQ0JpWldkcGJtNXBibWNnWVc1a0lHSmxlVzl1WkNCMFpYaDBJR3hsYm1kMGFDd2dkR2hsYmx4dUlDQWdJQzh2SUdoMWJtc2dZMkZ1SjNRZ1ptbDBJRzl1SUhSb1pTQjBaWGgwTGlCU1pYUjFjbTRnZFc1a1pXWnBibVZrWEc0Z0lIMDdYRzU5WEc0aVhYMD1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/diff/lib/util/distance-iterator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/diff/lib/util/params.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mocha/node_modules/diff/lib/util/params.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/*istanbul ignore start*/\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.generateOptions = generateOptions;\n\n/*istanbul ignore end*/\nfunction generateOptions(options, defaults) {\n  if (typeof options === 'function') {\n    defaults.callback = options;\n  } else if (options) {\n    for (var name in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(name)) {\n        defaults[name] = options[name];\n      }\n    }\n  }\n\n  return defaults;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL3BhcmFtcy5qcyJdLCJuYW1lcyI6WyJnZW5lcmF0ZU9wdGlvbnMiLCJvcHRpb25zIiwiZGVmYXVsdHMiLCJjYWxsYmFjayIsIm5hbWUiLCJoYXNPd25Qcm9wZXJ0eSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQU8sU0FBU0EsZUFBVCxDQUF5QkMsT0FBekIsRUFBa0NDLFFBQWxDLEVBQTRDO0FBQ2pELE1BQUksT0FBT0QsT0FBUCxLQUFtQixVQUF2QixFQUFtQztBQUNqQ0MsSUFBQUEsUUFBUSxDQUFDQyxRQUFULEdBQW9CRixPQUFwQjtBQUNELEdBRkQsTUFFTyxJQUFJQSxPQUFKLEVBQWE7QUFDbEIsU0FBSyxJQUFJRyxJQUFULElBQWlCSCxPQUFqQixFQUEwQjtBQUN4QjtBQUNBLFVBQUlBLE9BQU8sQ0FBQ0ksY0FBUixDQUF1QkQsSUFBdkIsQ0FBSixFQUFrQztBQUNoQ0YsUUFBQUEsUUFBUSxDQUFDRSxJQUFELENBQVIsR0FBaUJILE9BQU8sQ0FBQ0csSUFBRCxDQUF4QjtBQUNEO0FBQ0Y7QUFDRjs7QUFDRCxTQUFPRixRQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVPcHRpb25zKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRlZmF1bHRzLmNhbGxiYWNrID0gb3B0aW9ucztcbiAgfSBlbHNlIGlmIChvcHRpb25zKSB7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgZGVmYXVsdHNbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGVmYXVsdHM7XG59XG4iXX0=\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RpZmYvbGliL3V0aWwvcGFyYW1zLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL21vY2hhL25vZGVfbW9kdWxlcy9kaWZmL2xpYi91dGlsL3BhcmFtcy5qcz9lNjdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZW5lcmF0ZU9wdGlvbnMgPSBnZW5lcmF0ZU9wdGlvbnM7XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5mdW5jdGlvbiBnZW5lcmF0ZU9wdGlvbnMob3B0aW9ucywgZGVmYXVsdHMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZGVmYXVsdHMuY2FsbGJhY2sgPSBvcHRpb25zO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBkZWZhdWx0c1tuYW1lXSA9IG9wdGlvbnNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5MWRHbHNMM0JoY21GdGN5NXFjeUpkTENKdVlXMWxjeUk2V3lKblpXNWxjbUYwWlU5d2RHbHZibk1pTENKdmNIUnBiMjV6SWl3aVpHVm1ZWFZzZEhNaUxDSmpZV3hzWW1GamF5SXNJbTVoYldVaUxDSm9ZWE5QZDI1UWNtOXdaWEowZVNKZExDSnRZWEJ3YVc1bmN5STZJanM3T3pzN096czdPMEZCUVU4c1UwRkJVMEVzWlVGQlZDeERRVUY1UWtNc1QwRkJla0lzUlVGQmEwTkRMRkZCUVd4RExFVkJRVFJETzBGQlEycEVMRTFCUVVrc1QwRkJUMFFzVDBGQlVDeExRVUZ0UWl4VlFVRjJRaXhGUVVGdFF6dEJRVU5xUTBNc1NVRkJRVUVzVVVGQlVTeERRVUZEUXl4UlFVRlVMRWRCUVc5Q1JpeFBRVUZ3UWp0QlFVTkVMRWRCUmtRc1RVRkZUeXhKUVVGSlFTeFBRVUZLTEVWQlFXRTdRVUZEYkVJc1UwRkJTeXhKUVVGSlJ5eEpRVUZVTEVsQlFXbENTQ3hQUVVGcVFpeEZRVUV3UWp0QlFVTjRRanRCUVVOQkxGVkJRVWxCTEU5QlFVOHNRMEZCUTBrc1kwRkJVaXhEUVVGMVFrUXNTVUZCZGtJc1EwRkJTaXhGUVVGclF6dEJRVU5vUTBZc1VVRkJRVUVzVVVGQlVTeERRVUZEUlN4SlFVRkVMRU5CUVZJc1IwRkJhVUpJTEU5QlFVOHNRMEZCUTBjc1NVRkJSQ3hEUVVGNFFqdEJRVU5FTzBGQlEwWTdRVUZEUmpzN1FVRkRSQ3hUUVVGUFJpeFJRVUZRTzBGQlEwUWlMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUpsZUhCdmNuUWdablZ1WTNScGIyNGdaMlZ1WlhKaGRHVlBjSFJwYjI1ektHOXdkR2x2Ym5Nc0lHUmxabUYxYkhSektTQjdYRzRnSUdsbUlDaDBlWEJsYjJZZ2IzQjBhVzl1Y3lBOVBUMGdKMloxYm1OMGFXOXVKeWtnZTF4dUlDQWdJR1JsWm1GMWJIUnpMbU5oYkd4aVlXTnJJRDBnYjNCMGFXOXVjenRjYmlBZ2ZTQmxiSE5sSUdsbUlDaHZjSFJwYjI1ektTQjdYRzRnSUNBZ1ptOXlJQ2hzWlhRZ2JtRnRaU0JwYmlCdmNIUnBiMjV6S1NCN1hHNGdJQ0FnSUNBdktpQnBjM1JoYm1KMWJDQnBaMjV2Y21VZ1pXeHpaU0FxTDF4dUlDQWdJQ0FnYVdZZ0tHOXdkR2x2Ym5NdWFHRnpUM2R1VUhKdmNHVnlkSGtvYm1GdFpTa3BJSHRjYmlBZ0lDQWdJQ0FnWkdWbVlYVnNkSE5iYm1GdFpWMGdQU0J2Y0hScGIyNXpXMjVoYldWZE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JpQWdmVnh1SUNCeVpYUjFjbTRnWkdWbVlYVnNkSE03WEc1OVhHNGlYWDA9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/diff/lib/util/params.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/escape-string-regexp/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mocha/node_modules/escape-string-regexp/index.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = string => {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when its always valid, and a \\unnnn escape when the simpler form would be disallowed by Unicode patterns stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2VzY2FwZS1zdHJpbmctcmVnZXhwL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9ub2RlX21vZHVsZXMvZXNjYXBlLXN0cmluZy1yZWdleHAvaW5kZXguanM/MTdkZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nID0+IHtcblx0aWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcblx0fVxuXG5cdC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHdpdGggc3BlY2lhbCBtZWFuaW5nIGVpdGhlciBpbnNpZGUgb3Igb3V0c2lkZSBjaGFyYWN0ZXIgc2V0cy5cblx0Ly8gVXNlIGEgc2ltcGxlIGJhY2tzbGFzaCBlc2NhcGUgd2hlbiBpdOKAmXMgYWx3YXlzIHZhbGlkLCBhbmQgYSBcXHVubm5uIGVzY2FwZSB3aGVuIHRoZSBzaW1wbGVyIGZvcm0gd291bGQgYmUgZGlzYWxsb3dlZCBieSBVbmljb2RlIHBhdHRlcm5z4oCZIHN0cmljdGVyIGdyYW1tYXIuXG5cdHJldHVybiBzdHJpbmdcblx0XHQucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCsqPy5dL2csICdcXFxcJCYnKVxuXHRcdC5yZXBsYWNlKC8tL2csICdcXFxceDJkJyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/escape-string-regexp/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/glob/common.js":
/*!********************************************************!*\
  !*** ./node_modules/mocha/node_modules/glob/common.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("exports.setopts = setopts\nexports.ownProp = ownProp\nexports.makeAbs = makeAbs\nexports.finish = finish\nexports.mark = mark\nexports.isIgnored = isIgnored\nexports.childrenIgnored = childrenIgnored\n\nfunction ownProp (obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field)\n}\n\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"(ssr)/./node_modules/mocha/node_modules/minimatch/minimatch.js\")\nvar isAbsolute = (__webpack_require__(/*! path */ \"path\").isAbsolute)\nvar Minimatch = minimatch.Minimatch\n\nfunction alphasort (a, b) {\n  return a.localeCompare(b, 'en')\n}\n\nfunction setupIgnores (self, options) {\n  self.ignore = options.ignore || []\n\n  if (!Array.isArray(self.ignore))\n    self.ignore = [self.ignore]\n\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap)\n  }\n}\n\n// ignore patterns are always in dot:true mode.\nfunction ignoreMap (pattern) {\n  var gmatcher = null\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '')\n    gmatcher = new Minimatch(gpattern, { dot: true })\n  }\n\n  return {\n    matcher: new Minimatch(pattern, { dot: true }),\n    gmatcher: gmatcher\n  }\n}\n\nfunction setopts (self, pattern, options) {\n  if (!options)\n    options = {}\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\")\n    }\n    pattern = \"**/\" + pattern\n  }\n\n  self.windowsPathsNoEscape = !!options.windowsPathsNoEscape ||\n    options.allowWindowsEscape === false\n  if (self.windowsPathsNoEscape) {\n    pattern = pattern.replace(/\\\\/g, '/')\n  }\n\n  self.silent = !!options.silent\n  self.pattern = pattern\n  self.strict = options.strict !== false\n  self.realpath = !!options.realpath\n  self.realpathCache = options.realpathCache || Object.create(null)\n  self.follow = !!options.follow\n  self.dot = !!options.dot\n  self.mark = !!options.mark\n  self.nodir = !!options.nodir\n  if (self.nodir)\n    self.mark = true\n  self.sync = !!options.sync\n  self.nounique = !!options.nounique\n  self.nonull = !!options.nonull\n  self.nosort = !!options.nosort\n  self.nocase = !!options.nocase\n  self.stat = !!options.stat\n  self.noprocess = !!options.noprocess\n  self.absolute = !!options.absolute\n  self.fs = options.fs || fs\n\n  self.maxLength = options.maxLength || Infinity\n  self.cache = options.cache || Object.create(null)\n  self.statCache = options.statCache || Object.create(null)\n  self.symlinks = options.symlinks || Object.create(null)\n\n  setupIgnores(self, options)\n\n  self.changedCwd = false\n  var cwd = process.cwd()\n  if (!ownProp(options, \"cwd\"))\n    self.cwd = path.resolve(cwd)\n  else {\n    self.cwd = path.resolve(options.cwd)\n    self.changedCwd = self.cwd !== cwd\n  }\n\n  self.root = options.root || path.resolve(self.cwd, \"/\")\n  self.root = path.resolve(self.root)\n\n  // TODO: is an absolute `cwd` supposed to be resolved against `root`?\n  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\n  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)\n  self.nomount = !!options.nomount\n\n  if (process.platform === \"win32\") {\n    self.root = self.root.replace(/\\\\/g, \"/\")\n    self.cwd = self.cwd.replace(/\\\\/g, \"/\")\n    self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\")\n  }\n\n  // disable comments and negation in Minimatch.\n  // Note that they are not supported in Glob itself anyway.\n  options.nonegate = true\n  options.nocomment = true\n\n  self.minimatch = new Minimatch(pattern, options)\n  self.options = self.minimatch.options\n}\n\nfunction finish (self) {\n  var nou = self.nounique\n  var all = nou ? [] : Object.create(null)\n\n  for (var i = 0, l = self.matches.length; i < l; i ++) {\n    var matches = self.matches[i]\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i]\n        if (nou)\n          all.push(literal)\n        else\n          all[literal] = true\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches)\n      if (nou)\n        all.push.apply(all, m)\n      else\n        m.forEach(function (m) {\n          all[m] = true\n        })\n    }\n  }\n\n  if (!nou)\n    all = Object.keys(all)\n\n  if (!self.nosort)\n    all = all.sort(alphasort)\n\n  // at *some* point we statted all of these\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i])\n    }\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        var notDir = !(/\\/$/.test(e))\n        var c = self.cache[e] || self.cache[makeAbs(self, e)]\n        if (notDir && c)\n          notDir = c !== 'DIR' && !Array.isArray(c)\n        return notDir\n      })\n    }\n  }\n\n  if (self.ignore.length)\n    all = all.filter(function(m) {\n      return !isIgnored(self, m)\n    })\n\n  self.found = all\n}\n\nfunction mark (self, p) {\n  var abs = makeAbs(self, p)\n  var c = self.cache[abs]\n  var m = p\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c)\n    var slash = p.slice(-1) === '/'\n\n    if (isDir && !slash)\n      m += '/'\n    else if (!isDir && slash)\n      m = m.slice(0, -1)\n\n    if (m !== p) {\n      var mabs = makeAbs(self, m)\n      self.statCache[mabs] = self.statCache[abs]\n      self.cache[mabs] = self.cache[abs]\n    }\n  }\n\n  return m\n}\n\n// lotta situps...\nfunction makeAbs (self, f) {\n  var abs = f\n  if (f.charAt(0) === '/') {\n    abs = path.join(self.root, f)\n  } else if (isAbsolute(f) || f === '') {\n    abs = f\n  } else if (self.changedCwd) {\n    abs = path.resolve(self.cwd, f)\n  } else {\n    abs = path.resolve(f)\n  }\n\n  if (process.platform === 'win32')\n    abs = abs.replace(/\\\\/g, '/')\n\n  return abs\n}\n\n\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\nfunction childrenIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2dsb2IvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGNBQWM7QUFDZCxZQUFZO0FBQ1osaUJBQWlCO0FBQ2pCLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBOztBQUVBLFNBQVMsbUJBQU8sQ0FBQyxjQUFJO0FBQ3JCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixnQkFBZ0IsbUJBQU8sQ0FBQyxpRkFBVztBQUNuQyxpQkFBaUIsb0RBQTBCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BEOztBQUVBO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2dsb2IvY29tbW9uLmpzPzg3NDUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5zZXRvcHRzID0gc2V0b3B0c1xuZXhwb3J0cy5vd25Qcm9wID0gb3duUHJvcFxuZXhwb3J0cy5tYWtlQWJzID0gbWFrZUFic1xuZXhwb3J0cy5maW5pc2ggPSBmaW5pc2hcbmV4cG9ydHMubWFyayA9IG1hcmtcbmV4cG9ydHMuaXNJZ25vcmVkID0gaXNJZ25vcmVkXG5leHBvcnRzLmNoaWxkcmVuSWdub3JlZCA9IGNoaWxkcmVuSWdub3JlZFxuXG5mdW5jdGlvbiBvd25Qcm9wIChvYmosIGZpZWxkKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBmaWVsZClcbn1cblxudmFyIGZzID0gcmVxdWlyZShcImZzXCIpXG52YXIgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpXG52YXIgbWluaW1hdGNoID0gcmVxdWlyZShcIm1pbmltYXRjaFwiKVxudmFyIGlzQWJzb2x1dGUgPSByZXF1aXJlKFwicGF0aFwiKS5pc0Fic29sdXRlXG52YXIgTWluaW1hdGNoID0gbWluaW1hdGNoLk1pbmltYXRjaFxuXG5mdW5jdGlvbiBhbHBoYXNvcnQgKGEsIGIpIHtcbiAgcmV0dXJuIGEubG9jYWxlQ29tcGFyZShiLCAnZW4nKVxufVxuXG5mdW5jdGlvbiBzZXR1cElnbm9yZXMgKHNlbGYsIG9wdGlvbnMpIHtcbiAgc2VsZi5pZ25vcmUgPSBvcHRpb25zLmlnbm9yZSB8fCBbXVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShzZWxmLmlnbm9yZSkpXG4gICAgc2VsZi5pZ25vcmUgPSBbc2VsZi5pZ25vcmVdXG5cbiAgaWYgKHNlbGYuaWdub3JlLmxlbmd0aCkge1xuICAgIHNlbGYuaWdub3JlID0gc2VsZi5pZ25vcmUubWFwKGlnbm9yZU1hcClcbiAgfVxufVxuXG4vLyBpZ25vcmUgcGF0dGVybnMgYXJlIGFsd2F5cyBpbiBkb3Q6dHJ1ZSBtb2RlLlxuZnVuY3Rpb24gaWdub3JlTWFwIChwYXR0ZXJuKSB7XG4gIHZhciBnbWF0Y2hlciA9IG51bGxcbiAgaWYgKHBhdHRlcm4uc2xpY2UoLTMpID09PSAnLyoqJykge1xuICAgIHZhciBncGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZSgvKFxcL1xcKlxcKikrJC8sICcnKVxuICAgIGdtYXRjaGVyID0gbmV3IE1pbmltYXRjaChncGF0dGVybiwgeyBkb3Q6IHRydWUgfSlcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWF0Y2hlcjogbmV3IE1pbmltYXRjaChwYXR0ZXJuLCB7IGRvdDogdHJ1ZSB9KSxcbiAgICBnbWF0Y2hlcjogZ21hdGNoZXJcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRvcHRzIChzZWxmLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucylcbiAgICBvcHRpb25zID0ge31cblxuICAvLyBiYXNlLW1hdGNoaW5nOiBqdXN0IHVzZSBnbG9ic3RhciBmb3IgdGhhdC5cbiAgaWYgKG9wdGlvbnMubWF0Y2hCYXNlICYmIC0xID09PSBwYXR0ZXJuLmluZGV4T2YoXCIvXCIpKSB7XG4gICAgaWYgKG9wdGlvbnMubm9nbG9ic3Rhcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFzZSBtYXRjaGluZyByZXF1aXJlcyBnbG9ic3RhclwiKVxuICAgIH1cbiAgICBwYXR0ZXJuID0gXCIqKi9cIiArIHBhdHRlcm5cbiAgfVxuXG4gIHNlbGYud2luZG93c1BhdGhzTm9Fc2NhcGUgPSAhIW9wdGlvbnMud2luZG93c1BhdGhzTm9Fc2NhcGUgfHxcbiAgICBvcHRpb25zLmFsbG93V2luZG93c0VzY2FwZSA9PT0gZmFsc2VcbiAgaWYgKHNlbGYud2luZG93c1BhdGhzTm9Fc2NhcGUpIHtcbiAgICBwYXR0ZXJuID0gcGF0dGVybi5yZXBsYWNlKC9cXFxcL2csICcvJylcbiAgfVxuXG4gIHNlbGYuc2lsZW50ID0gISFvcHRpb25zLnNpbGVudFxuICBzZWxmLnBhdHRlcm4gPSBwYXR0ZXJuXG4gIHNlbGYuc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3QgIT09IGZhbHNlXG4gIHNlbGYucmVhbHBhdGggPSAhIW9wdGlvbnMucmVhbHBhdGhcbiAgc2VsZi5yZWFscGF0aENhY2hlID0gb3B0aW9ucy5yZWFscGF0aENhY2hlIHx8IE9iamVjdC5jcmVhdGUobnVsbClcbiAgc2VsZi5mb2xsb3cgPSAhIW9wdGlvbnMuZm9sbG93XG4gIHNlbGYuZG90ID0gISFvcHRpb25zLmRvdFxuICBzZWxmLm1hcmsgPSAhIW9wdGlvbnMubWFya1xuICBzZWxmLm5vZGlyID0gISFvcHRpb25zLm5vZGlyXG4gIGlmIChzZWxmLm5vZGlyKVxuICAgIHNlbGYubWFyayA9IHRydWVcbiAgc2VsZi5zeW5jID0gISFvcHRpb25zLnN5bmNcbiAgc2VsZi5ub3VuaXF1ZSA9ICEhb3B0aW9ucy5ub3VuaXF1ZVxuICBzZWxmLm5vbnVsbCA9ICEhb3B0aW9ucy5ub251bGxcbiAgc2VsZi5ub3NvcnQgPSAhIW9wdGlvbnMubm9zb3J0XG4gIHNlbGYubm9jYXNlID0gISFvcHRpb25zLm5vY2FzZVxuICBzZWxmLnN0YXQgPSAhIW9wdGlvbnMuc3RhdFxuICBzZWxmLm5vcHJvY2VzcyA9ICEhb3B0aW9ucy5ub3Byb2Nlc3NcbiAgc2VsZi5hYnNvbHV0ZSA9ICEhb3B0aW9ucy5hYnNvbHV0ZVxuICBzZWxmLmZzID0gb3B0aW9ucy5mcyB8fCBmc1xuXG4gIHNlbGYubWF4TGVuZ3RoID0gb3B0aW9ucy5tYXhMZW5ndGggfHwgSW5maW5pdHlcbiAgc2VsZi5jYWNoZSA9IG9wdGlvbnMuY2FjaGUgfHwgT2JqZWN0LmNyZWF0ZShudWxsKVxuICBzZWxmLnN0YXRDYWNoZSA9IG9wdGlvbnMuc3RhdENhY2hlIHx8IE9iamVjdC5jcmVhdGUobnVsbClcbiAgc2VsZi5zeW1saW5rcyA9IG9wdGlvbnMuc3ltbGlua3MgfHwgT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIHNldHVwSWdub3JlcyhzZWxmLCBvcHRpb25zKVxuXG4gIHNlbGYuY2hhbmdlZEN3ZCA9IGZhbHNlXG4gIHZhciBjd2QgPSBwcm9jZXNzLmN3ZCgpXG4gIGlmICghb3duUHJvcChvcHRpb25zLCBcImN3ZFwiKSlcbiAgICBzZWxmLmN3ZCA9IHBhdGgucmVzb2x2ZShjd2QpXG4gIGVsc2Uge1xuICAgIHNlbGYuY3dkID0gcGF0aC5yZXNvbHZlKG9wdGlvbnMuY3dkKVxuICAgIHNlbGYuY2hhbmdlZEN3ZCA9IHNlbGYuY3dkICE9PSBjd2RcbiAgfVxuXG4gIHNlbGYucm9vdCA9IG9wdGlvbnMucm9vdCB8fCBwYXRoLnJlc29sdmUoc2VsZi5jd2QsIFwiL1wiKVxuICBzZWxmLnJvb3QgPSBwYXRoLnJlc29sdmUoc2VsZi5yb290KVxuXG4gIC8vIFRPRE86IGlzIGFuIGFic29sdXRlIGBjd2RgIHN1cHBvc2VkIHRvIGJlIHJlc29sdmVkIGFnYWluc3QgYHJvb3RgP1xuICAvLyBlLmcuIHsgY3dkOiAnL3Rlc3QnLCByb290OiBfX2Rpcm5hbWUgfSA9PT0gcGF0aC5qb2luKF9fZGlybmFtZSwgJy90ZXN0JylcbiAgc2VsZi5jd2RBYnMgPSBpc0Fic29sdXRlKHNlbGYuY3dkKSA/IHNlbGYuY3dkIDogbWFrZUFicyhzZWxmLCBzZWxmLmN3ZClcbiAgc2VsZi5ub21vdW50ID0gISFvcHRpb25zLm5vbW91bnRcblxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgc2VsZi5yb290ID0gc2VsZi5yb290LnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpXG4gICAgc2VsZi5jd2QgPSBzZWxmLmN3ZC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKVxuICAgIHNlbGYuY3dkQWJzID0gc2VsZi5jd2RBYnMucmVwbGFjZSgvXFxcXC9nLCBcIi9cIilcbiAgfVxuXG4gIC8vIGRpc2FibGUgY29tbWVudHMgYW5kIG5lZ2F0aW9uIGluIE1pbmltYXRjaC5cbiAgLy8gTm90ZSB0aGF0IHRoZXkgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gR2xvYiBpdHNlbGYgYW55d2F5LlxuICBvcHRpb25zLm5vbmVnYXRlID0gdHJ1ZVxuICBvcHRpb25zLm5vY29tbWVudCA9IHRydWVcblxuICBzZWxmLm1pbmltYXRjaCA9IG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucylcbiAgc2VsZi5vcHRpb25zID0gc2VsZi5taW5pbWF0Y2gub3B0aW9uc1xufVxuXG5mdW5jdGlvbiBmaW5pc2ggKHNlbGYpIHtcbiAgdmFyIG5vdSA9IHNlbGYubm91bmlxdWVcbiAgdmFyIGFsbCA9IG5vdSA/IFtdIDogT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gc2VsZi5tYXRjaGVzLmxlbmd0aDsgaSA8IGw7IGkgKyspIHtcbiAgICB2YXIgbWF0Y2hlcyA9IHNlbGYubWF0Y2hlc1tpXVxuICAgIGlmICghbWF0Y2hlcyB8fCBPYmplY3Qua2V5cyhtYXRjaGVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChzZWxmLm5vbnVsbCkge1xuICAgICAgICAvLyBkbyBsaWtlIHRoZSBzaGVsbCwgYW5kIHNwaXQgb3V0IHRoZSBsaXRlcmFsIGdsb2JcbiAgICAgICAgdmFyIGxpdGVyYWwgPSBzZWxmLm1pbmltYXRjaC5nbG9iU2V0W2ldXG4gICAgICAgIGlmIChub3UpXG4gICAgICAgICAgYWxsLnB1c2gobGl0ZXJhbClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGFsbFtsaXRlcmFsXSA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaGFkIG1hdGNoZXNcbiAgICAgIHZhciBtID0gT2JqZWN0LmtleXMobWF0Y2hlcylcbiAgICAgIGlmIChub3UpXG4gICAgICAgIGFsbC5wdXNoLmFwcGx5KGFsbCwgbSlcbiAgICAgIGVsc2VcbiAgICAgICAgbS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgYWxsW21dID0gdHJ1ZVxuICAgICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlmICghbm91KVxuICAgIGFsbCA9IE9iamVjdC5rZXlzKGFsbClcblxuICBpZiAoIXNlbGYubm9zb3J0KVxuICAgIGFsbCA9IGFsbC5zb3J0KGFscGhhc29ydClcblxuICAvLyBhdCAqc29tZSogcG9pbnQgd2Ugc3RhdHRlZCBhbGwgb2YgdGhlc2VcbiAgaWYgKHNlbGYubWFyaykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhbGxbaV0gPSBzZWxmLl9tYXJrKGFsbFtpXSlcbiAgICB9XG4gICAgaWYgKHNlbGYubm9kaXIpIHtcbiAgICAgIGFsbCA9IGFsbC5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIG5vdERpciA9ICEoL1xcLyQvLnRlc3QoZSkpXG4gICAgICAgIHZhciBjID0gc2VsZi5jYWNoZVtlXSB8fCBzZWxmLmNhY2hlW21ha2VBYnMoc2VsZiwgZSldXG4gICAgICAgIGlmIChub3REaXIgJiYgYylcbiAgICAgICAgICBub3REaXIgPSBjICE9PSAnRElSJyAmJiAhQXJyYXkuaXNBcnJheShjKVxuICAgICAgICByZXR1cm4gbm90RGlyXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlmIChzZWxmLmlnbm9yZS5sZW5ndGgpXG4gICAgYWxsID0gYWxsLmZpbHRlcihmdW5jdGlvbihtKSB7XG4gICAgICByZXR1cm4gIWlzSWdub3JlZChzZWxmLCBtKVxuICAgIH0pXG5cbiAgc2VsZi5mb3VuZCA9IGFsbFxufVxuXG5mdW5jdGlvbiBtYXJrIChzZWxmLCBwKSB7XG4gIHZhciBhYnMgPSBtYWtlQWJzKHNlbGYsIHApXG4gIHZhciBjID0gc2VsZi5jYWNoZVthYnNdXG4gIHZhciBtID0gcFxuICBpZiAoYykge1xuICAgIHZhciBpc0RpciA9IGMgPT09ICdESVInIHx8IEFycmF5LmlzQXJyYXkoYylcbiAgICB2YXIgc2xhc2ggPSBwLnNsaWNlKC0xKSA9PT0gJy8nXG5cbiAgICBpZiAoaXNEaXIgJiYgIXNsYXNoKVxuICAgICAgbSArPSAnLydcbiAgICBlbHNlIGlmICghaXNEaXIgJiYgc2xhc2gpXG4gICAgICBtID0gbS5zbGljZSgwLCAtMSlcblxuICAgIGlmIChtICE9PSBwKSB7XG4gICAgICB2YXIgbWFicyA9IG1ha2VBYnMoc2VsZiwgbSlcbiAgICAgIHNlbGYuc3RhdENhY2hlW21hYnNdID0gc2VsZi5zdGF0Q2FjaGVbYWJzXVxuICAgICAgc2VsZi5jYWNoZVttYWJzXSA9IHNlbGYuY2FjaGVbYWJzXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtXG59XG5cbi8vIGxvdHRhIHNpdHVwcy4uLlxuZnVuY3Rpb24gbWFrZUFicyAoc2VsZiwgZikge1xuICB2YXIgYWJzID0gZlxuICBpZiAoZi5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgIGFicyA9IHBhdGguam9pbihzZWxmLnJvb3QsIGYpXG4gIH0gZWxzZSBpZiAoaXNBYnNvbHV0ZShmKSB8fCBmID09PSAnJykge1xuICAgIGFicyA9IGZcbiAgfSBlbHNlIGlmIChzZWxmLmNoYW5nZWRDd2QpIHtcbiAgICBhYnMgPSBwYXRoLnJlc29sdmUoc2VsZi5jd2QsIGYpXG4gIH0gZWxzZSB7XG4gICAgYWJzID0gcGF0aC5yZXNvbHZlKGYpXG4gIH1cblxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJylcbiAgICBhYnMgPSBhYnMucmVwbGFjZSgvXFxcXC9nLCAnLycpXG5cbiAgcmV0dXJuIGFic1xufVxuXG5cbi8vIFJldHVybiB0cnVlLCBpZiBwYXR0ZXJuIGVuZHMgd2l0aCBnbG9ic3RhciAnKionLCBmb3IgdGhlIGFjY29tcGFueWluZyBwYXJlbnQgZGlyZWN0b3J5LlxuLy8gRXg6LSBJZiBub2RlX21vZHVsZXMvKiogaXMgdGhlIHBhdHRlcm4sIGFkZCAnbm9kZV9tb2R1bGVzJyB0byBpZ25vcmUgbGlzdCBhbG9uZyB3aXRoIGl0J3MgY29udGVudHNcbmZ1bmN0aW9uIGlzSWdub3JlZCAoc2VsZiwgcGF0aCkge1xuICBpZiAoIXNlbGYuaWdub3JlLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2VcblxuICByZXR1cm4gc2VsZi5pZ25vcmUuc29tZShmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0ubWF0Y2hlci5tYXRjaChwYXRoKSB8fCAhIShpdGVtLmdtYXRjaGVyICYmIGl0ZW0uZ21hdGNoZXIubWF0Y2gocGF0aCkpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNoaWxkcmVuSWdub3JlZCAoc2VsZiwgcGF0aCkge1xuICBpZiAoIXNlbGYuaWdub3JlLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2VcblxuICByZXR1cm4gc2VsZi5pZ25vcmUuc29tZShmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuICEhKGl0ZW0uZ21hdGNoZXIgJiYgaXRlbS5nbWF0Y2hlci5tYXRjaChwYXRoKSlcbiAgfSlcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/glob/common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/glob/glob.js":
/*!******************************************************!*\
  !*** ./node_modules/mocha/node_modules/glob/glob.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\nmodule.exports = glob\n\nvar rp = __webpack_require__(/*! fs.realpath */ \"(ssr)/./node_modules/fs.realpath/index.js\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"(ssr)/./node_modules/mocha/node_modules/minimatch/minimatch.js\")\nvar Minimatch = minimatch.Minimatch\nvar inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/inherits/inherits.js\")\nvar EE = (__webpack_require__(/*! events */ \"events\").EventEmitter)\nvar path = __webpack_require__(/*! path */ \"path\")\nvar assert = __webpack_require__(/*! assert */ \"assert\")\nvar isAbsolute = (__webpack_require__(/*! path */ \"path\").isAbsolute)\nvar globSync = __webpack_require__(/*! ./sync.js */ \"(ssr)/./node_modules/mocha/node_modules/glob/sync.js\")\nvar common = __webpack_require__(/*! ./common.js */ \"(ssr)/./node_modules/mocha/node_modules/glob/common.js\")\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar inflight = __webpack_require__(/*! inflight */ \"(ssr)/./node_modules/inflight/inflight.js\")\nvar util = __webpack_require__(/*! util */ \"util\")\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nvar once = __webpack_require__(/*! once */ \"(ssr)/./node_modules/once/once.js\")\n\nfunction glob (pattern, options, cb) {\n  if (typeof options === 'function') cb = options, options = {}\n  if (!options) options = {}\n\n  if (options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return globSync(pattern, options)\n  }\n\n  return new Glob(pattern, options, cb)\n}\n\nglob.sync = globSync\nvar GlobSync = glob.GlobSync = globSync.GlobSync\n\n// old api surface\nglob.glob = glob\n\nfunction extend (origin, add) {\n  if (add === null || typeof add !== 'object') {\n    return origin\n  }\n\n  var keys = Object.keys(add)\n  var i = keys.length\n  while (i--) {\n    origin[keys[i]] = add[keys[i]]\n  }\n  return origin\n}\n\nglob.hasMagic = function (pattern, options_) {\n  var options = extend({}, options_)\n  options.noprocess = true\n\n  var g = new Glob(pattern, options)\n  var set = g.minimatch.set\n\n  if (!pattern)\n    return false\n\n  if (set.length > 1)\n    return true\n\n  for (var j = 0; j < set[0].length; j++) {\n    if (typeof set[0][j] !== 'string')\n      return true\n  }\n\n  return false\n}\n\nglob.Glob = Glob\ninherits(Glob, EE)\nfunction Glob (pattern, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = null\n  }\n\n  if (options && options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return new GlobSync(pattern, options)\n  }\n\n  if (!(this instanceof Glob))\n    return new Glob(pattern, options, cb)\n\n  setopts(this, pattern, options)\n  this._didRealPath = false\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n)\n\n  if (typeof cb === 'function') {\n    cb = once(cb)\n    this.on('error', cb)\n    this.on('end', function (matches) {\n      cb(null, matches)\n    })\n  }\n\n  var self = this\n  this._processing = 0\n\n  this._emitQueue = []\n  this._processQueue = []\n  this.paused = false\n\n  if (this.noprocess)\n    return this\n\n  if (n === 0)\n    return done()\n\n  var sync = true\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false, done)\n  }\n  sync = false\n\n  function done () {\n    --self._processing\n    if (self._processing <= 0) {\n      if (sync) {\n        process.nextTick(function () {\n          self._finish()\n        })\n      } else {\n        self._finish()\n      }\n    }\n  }\n}\n\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob)\n  if (this.aborted)\n    return\n\n  if (this.realpath && !this._didRealpath)\n    return this._realpath()\n\n  common.finish(this)\n  this.emit('end', this.found)\n}\n\nGlob.prototype._realpath = function () {\n  if (this._didRealpath)\n    return\n\n  this._didRealpath = true\n\n  var n = this.matches.length\n  if (n === 0)\n    return this._finish()\n\n  var self = this\n  for (var i = 0; i < this.matches.length; i++)\n    this._realpathSet(i, next)\n\n  function next () {\n    if (--n === 0)\n      self._finish()\n  }\n}\n\nGlob.prototype._realpathSet = function (index, cb) {\n  var matchset = this.matches[index]\n  if (!matchset)\n    return cb()\n\n  var found = Object.keys(matchset)\n  var self = this\n  var n = found.length\n\n  if (n === 0)\n    return cb()\n\n  var set = this.matches[index] = Object.create(null)\n  found.forEach(function (p, i) {\n    // If there's a problem with the stat, then it means that\n    // one or more of the links in the realpath couldn't be\n    // resolved.  just return the abs value in that case.\n    p = self._makeAbs(p)\n    rp.realpath(p, self.realpathCache, function (er, real) {\n      if (!er)\n        set[real] = true\n      else if (er.syscall === 'stat')\n        set[p] = true\n      else\n        self.emit('error', er) // srsly wtf right here\n\n      if (--n === 0) {\n        self.matches[index] = set\n        cb()\n      }\n    })\n  })\n}\n\nGlob.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlob.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\nGlob.prototype.abort = function () {\n  this.aborted = true\n  this.emit('abort')\n}\n\nGlob.prototype.pause = function () {\n  if (!this.paused) {\n    this.paused = true\n    this.emit('pause')\n  }\n}\n\nGlob.prototype.resume = function () {\n  if (this.paused) {\n    this.emit('resume')\n    this.paused = false\n    if (this._emitQueue.length) {\n      var eq = this._emitQueue.slice(0)\n      this._emitQueue.length = 0\n      for (var i = 0; i < eq.length; i ++) {\n        var e = eq[i]\n        this._emitMatch(e[0], e[1])\n      }\n    }\n    if (this._processQueue.length) {\n      var pq = this._processQueue.slice(0)\n      this._processQueue.length = 0\n      for (var i = 0; i < pq.length; i ++) {\n        var p = pq[i]\n        this._processing--\n        this._process(p[0], p[1], p[2], p[3])\n      }\n    }\n  }\n}\n\nGlob.prototype._process = function (pattern, index, inGlobStar, cb) {\n  assert(this instanceof Glob)\n  assert(typeof cb === 'function')\n\n  if (this.aborted)\n    return\n\n  this._processing++\n  if (this.paused) {\n    this._processQueue.push([pattern, index, inGlobStar, cb])\n    return\n  }\n\n  //console.error('PROCESS %d', this._processing, pattern)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index, cb)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) ||\n      isAbsolute(pattern.map(function (p) {\n        return typeof p === 'string' ? p : '[*]'\n      }).join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip _processing\n  if (childrenIgnored(this, read))\n    return cb()\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)\n}\n\nGlob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\nGlob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return cb()\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return cb()\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return cb()\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix) {\n      if (prefix !== '/')\n        e = prefix + '/' + e\n      else\n        e = prefix + e\n    }\n    this._process([e].concat(remain), index, inGlobStar, cb)\n  }\n  cb()\n}\n\nGlob.prototype._emitMatch = function (index, e) {\n  if (this.aborted)\n    return\n\n  if (isIgnored(this, e))\n    return\n\n  if (this.paused) {\n    this._emitQueue.push([index, e])\n    return\n  }\n\n  var abs = isAbsolute(e) ? e : this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute)\n    e = abs\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  var st = this.statCache[abs]\n  if (st)\n    this.emit('stat', e, st)\n\n  this.emit('match', e)\n}\n\nGlob.prototype._readdirInGlobStar = function (abs, cb) {\n  if (this.aborted)\n    return\n\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false, cb)\n\n  var lstatkey = 'lstat\\0' + abs\n  var self = this\n  var lstatcb = inflight(lstatkey, lstatcb_)\n\n  if (lstatcb)\n    self.fs.lstat(abs, lstatcb)\n\n  function lstatcb_ (er, lstat) {\n    if (er && er.code === 'ENOENT')\n      return cb()\n\n    var isSym = lstat && lstat.isSymbolicLink()\n    self.symlinks[abs] = isSym\n\n    // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n    if (!isSym && lstat && !lstat.isDirectory()) {\n      self.cache[abs] = 'FILE'\n      cb()\n    } else\n      self._readdir(abs, false, cb)\n  }\n}\n\nGlob.prototype._readdir = function (abs, inGlobStar, cb) {\n  if (this.aborted)\n    return\n\n  cb = inflight('readdir\\0'+abs+'\\0'+inGlobStar, cb)\n  if (!cb)\n    return\n\n  //console.error('RD %j %j', +inGlobStar, abs)\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs, cb)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return cb()\n\n    if (Array.isArray(c))\n      return cb(null, c)\n  }\n\n  var self = this\n  self.fs.readdir(abs, readdirCb(this, abs, cb))\n}\n\nfunction readdirCb (self, abs, cb) {\n  return function (er, entries) {\n    if (er)\n      self._readdirError(abs, er, cb)\n    else\n      self._readdirEntries(abs, entries, cb)\n  }\n}\n\nGlob.prototype._readdirEntries = function (abs, entries, cb) {\n  if (this.aborted)\n    return\n\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n  return cb(null, entries)\n}\n\nGlob.prototype._readdirError = function (f, er, cb) {\n  if (this.aborted)\n    return\n\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        this.emit('error', error)\n        this.abort()\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict) {\n        this.emit('error', er)\n        // If the error is handled, then we abort\n        // if not, we threw out of here\n        this.abort()\n      }\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n\n  return cb()\n}\n\nGlob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\n\nGlob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  //console.error('pgs2', prefix, remain[0], entries)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return cb()\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false, cb)\n\n  var isSym = this.symlinks[abs]\n  var len = entries.length\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return cb()\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true, cb)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true, cb)\n  }\n\n  cb()\n}\n\nGlob.prototype._processSimple = function (prefix, index, cb) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var self = this\n  this._stat(prefix, function (er, exists) {\n    self._processSimple2(prefix, index, er, exists, cb)\n  })\n}\nGlob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\n\n  //console.error('ps2', prefix, exists)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return cb()\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n  cb()\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlob.prototype._stat = function (f, cb) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return cb()\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return cb(null, c)\n\n    if (needDir && c === 'FILE')\n      return cb()\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (stat !== undefined) {\n    if (stat === false)\n      return cb(null, stat)\n    else {\n      var type = stat.isDirectory() ? 'DIR' : 'FILE'\n      if (needDir && type === 'FILE')\n        return cb()\n      else\n        return cb(null, type, stat)\n    }\n  }\n\n  var self = this\n  var statcb = inflight('stat\\0' + abs, lstatcb_)\n  if (statcb)\n    self.fs.lstat(abs, statcb)\n\n  function lstatcb_ (er, lstat) {\n    if (lstat && lstat.isSymbolicLink()) {\n      // If it's a symlink, then treat it as the target, unless\n      // the target does not exist, then treat it as a file.\n      return self.fs.stat(abs, function (er, stat) {\n        if (er)\n          self._stat2(f, abs, null, lstat, cb)\n        else\n          self._stat2(f, abs, er, stat, cb)\n      })\n    } else {\n      self._stat2(f, abs, er, lstat, cb)\n    }\n  }\n}\n\nGlob.prototype._stat2 = function (f, abs, er, stat, cb) {\n  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n    this.statCache[abs] = false\n    return cb()\n  }\n\n  var needDir = f.slice(-1) === '/'\n  this.statCache[abs] = stat\n\n  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())\n    return cb(null, false, stat)\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return cb()\n\n  return cb(null, c, stat)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2dsb2IvZ2xvYi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUyxtQkFBTyxDQUFDLDhEQUFhO0FBQzlCLGdCQUFnQixtQkFBTyxDQUFDLGlGQUFXO0FBQ25DO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDJEQUFVO0FBQ2pDLFNBQVMsMERBQThCO0FBQ3ZDLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsaUJBQWlCLG9EQUEwQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMsdUVBQVc7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLDJFQUFhO0FBQ2xDO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsMkRBQVU7QUFDakMsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLCtDQUFNOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9ub2RlX21vZHVsZXMvZ2xvYi9nbG9iLmpzP2I3ZjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQXBwcm9hY2g6XG4vL1xuLy8gMS4gR2V0IHRoZSBtaW5pbWF0Y2ggc2V0XG4vLyAyLiBGb3IgZWFjaCBwYXR0ZXJuIGluIHRoZSBzZXQsIFBST0NFU1MocGF0dGVybiwgZmFsc2UpXG4vLyAzLiBTdG9yZSBtYXRjaGVzIHBlci1zZXQsIHRoZW4gdW5pcSB0aGVtXG4vL1xuLy8gUFJPQ0VTUyhwYXR0ZXJuLCBpbkdsb2JTdGFyKVxuLy8gR2V0IHRoZSBmaXJzdCBbbl0gaXRlbXMgZnJvbSBwYXR0ZXJuIHRoYXQgYXJlIGFsbCBzdHJpbmdzXG4vLyBKb2luIHRoZXNlIHRvZ2V0aGVyLiAgVGhpcyBpcyBQUkVGSVguXG4vLyAgIElmIHRoZXJlIGlzIG5vIG1vcmUgcmVtYWluaW5nLCB0aGVuIHN0YXQoUFJFRklYKSBhbmRcbi8vICAgYWRkIHRvIG1hdGNoZXMgaWYgaXQgc3VjY2VlZHMuICBFTkQuXG4vL1xuLy8gSWYgaW5HbG9iU3RhciBhbmQgUFJFRklYIGlzIHN5bWxpbmsgYW5kIHBvaW50cyB0byBkaXJcbi8vICAgc2V0IEVOVFJJRVMgPSBbXVxuLy8gZWxzZSByZWFkZGlyKFBSRUZJWCkgYXMgRU5UUklFU1xuLy8gICBJZiBmYWlsLCBFTkRcbi8vXG4vLyB3aXRoIEVOVFJJRVNcbi8vICAgSWYgcGF0dGVybltuXSBpcyBHTE9CU1RBUlxuLy8gICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgZ2xvYnN0YXIgbWF0Y2ggaXMgZW1wdHlcbi8vICAgICAvLyBieSBwcnVuaW5nIGl0IG91dCwgYW5kIHRlc3RpbmcgdGhlIHJlc3VsdGluZyBwYXR0ZXJuXG4vLyAgICAgUFJPQ0VTUyhwYXR0ZXJuWzAuLm5dICsgcGF0dGVybltuKzEgLi4gJF0sIGZhbHNlKVxuLy8gICAgIC8vIGhhbmRsZSBvdGhlciBjYXNlcy5cbi8vICAgICBmb3IgRU5UUlkgaW4gRU5UUklFUyAobm90IGRvdGZpbGVzKVxuLy8gICAgICAgLy8gYXR0YWNoIGdsb2JzdGFyICsgdGFpbCBvbnRvIHRoZSBlbnRyeVxuLy8gICAgICAgLy8gTWFyayB0aGF0IHRoaXMgZW50cnkgaXMgYSBnbG9ic3RhciBtYXRjaFxuLy8gICAgICAgUFJPQ0VTUyhwYXR0ZXJuWzAuLm5dICsgRU5UUlkgKyBwYXR0ZXJuW24gLi4gJF0sIHRydWUpXG4vL1xuLy8gICBlbHNlIC8vIG5vdCBnbG9ic3RhclxuLy8gICAgIGZvciBFTlRSWSBpbiBFTlRSSUVTIChub3QgZG90ZmlsZXMsIHVubGVzcyBwYXR0ZXJuW25dIGlzIGRvdClcbi8vICAgICAgIFRlc3QgRU5UUlkgYWdhaW5zdCBwYXR0ZXJuW25dXG4vLyAgICAgICBJZiBmYWlscywgY29udGludWVcbi8vICAgICAgIElmIHBhc3NlcywgUFJPQ0VTUyhwYXR0ZXJuWzAuLm5dICsgaXRlbSArIHBhdHRlcm5bbisxIC4uICRdKVxuLy9cbi8vIENhdmVhdDpcbi8vICAgQ2FjaGUgYWxsIHN0YXRzIGFuZCByZWFkZGlycyByZXN1bHRzIHRvIG1pbmltaXplIHN5c2NhbGwuICBTaW5jZSBhbGxcbi8vICAgd2UgZXZlciBjYXJlIGFib3V0IGlzIGV4aXN0ZW5jZSBhbmQgZGlyZWN0b3J5LW5lc3MsIHdlIGNhbiBqdXN0IGtlZXBcbi8vICAgYHRydWVgIGZvciBmaWxlcywgYW5kIFtjaGlsZHJlbiwuLi5dIGZvciBkaXJlY3Rvcmllcywgb3IgYGZhbHNlYCBmb3Jcbi8vICAgdGhpbmdzIHRoYXQgZG9uJ3QgZXhpc3QuXG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYlxuXG52YXIgcnAgPSByZXF1aXJlKCdmcy5yZWFscGF0aCcpXG52YXIgbWluaW1hdGNoID0gcmVxdWlyZSgnbWluaW1hdGNoJylcbnZhciBNaW5pbWF0Y2ggPSBtaW5pbWF0Y2guTWluaW1hdGNoXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbnZhciBpc0Fic29sdXRlID0gcmVxdWlyZSgncGF0aCcpLmlzQWJzb2x1dGVcbnZhciBnbG9iU3luYyA9IHJlcXVpcmUoJy4vc3luYy5qcycpXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24uanMnKVxudmFyIHNldG9wdHMgPSBjb21tb24uc2V0b3B0c1xudmFyIG93blByb3AgPSBjb21tb24ub3duUHJvcFxudmFyIGluZmxpZ2h0ID0gcmVxdWlyZSgnaW5mbGlnaHQnKVxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcbnZhciBjaGlsZHJlbklnbm9yZWQgPSBjb21tb24uY2hpbGRyZW5JZ25vcmVkXG52YXIgaXNJZ25vcmVkID0gY29tbW9uLmlzSWdub3JlZFxuXG52YXIgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxuXG5mdW5jdGlvbiBnbG9iIChwYXR0ZXJuLCBvcHRpb25zLCBjYikge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIGNiID0gb3B0aW9ucywgb3B0aW9ucyA9IHt9XG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG5cbiAgaWYgKG9wdGlvbnMuc3luYykge1xuICAgIGlmIChjYilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIHByb3ZpZGVkIHRvIHN5bmMgZ2xvYicpXG4gICAgcmV0dXJuIGdsb2JTeW5jKHBhdHRlcm4sIG9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gbmV3IEdsb2IocGF0dGVybiwgb3B0aW9ucywgY2IpXG59XG5cbmdsb2Iuc3luYyA9IGdsb2JTeW5jXG52YXIgR2xvYlN5bmMgPSBnbG9iLkdsb2JTeW5jID0gZ2xvYlN5bmMuR2xvYlN5bmNcblxuLy8gb2xkIGFwaSBzdXJmYWNlXG5nbG9iLmdsb2IgPSBnbG9iXG5cbmZ1bmN0aW9uIGV4dGVuZCAob3JpZ2luLCBhZGQpIHtcbiAgaWYgKGFkZCA9PT0gbnVsbCB8fCB0eXBlb2YgYWRkICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvcmlnaW5cbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKVxuICB2YXIgaSA9IGtleXMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV1cbiAgfVxuICByZXR1cm4gb3JpZ2luXG59XG5cbmdsb2IuaGFzTWFnaWMgPSBmdW5jdGlvbiAocGF0dGVybiwgb3B0aW9uc18pIHtcbiAgdmFyIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnNfKVxuICBvcHRpb25zLm5vcHJvY2VzcyA9IHRydWVcblxuICB2YXIgZyA9IG5ldyBHbG9iKHBhdHRlcm4sIG9wdGlvbnMpXG4gIHZhciBzZXQgPSBnLm1pbmltYXRjaC5zZXRcblxuICBpZiAoIXBhdHRlcm4pXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgaWYgKHNldC5sZW5ndGggPiAxKVxuICAgIHJldHVybiB0cnVlXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXRbMF0ubGVuZ3RoOyBqKyspIHtcbiAgICBpZiAodHlwZW9mIHNldFswXVtqXSAhPT0gJ3N0cmluZycpXG4gICAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmdsb2IuR2xvYiA9IEdsb2JcbmluaGVyaXRzKEdsb2IsIEVFKVxuZnVuY3Rpb24gR2xvYiAocGF0dGVybiwgb3B0aW9ucywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IG51bGxcbiAgfVxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc3luYykge1xuICAgIGlmIChjYilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIHByb3ZpZGVkIHRvIHN5bmMgZ2xvYicpXG4gICAgcmV0dXJuIG5ldyBHbG9iU3luYyhwYXR0ZXJuLCBvcHRpb25zKVxuICB9XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEdsb2IpKVxuICAgIHJldHVybiBuZXcgR2xvYihwYXR0ZXJuLCBvcHRpb25zLCBjYilcblxuICBzZXRvcHRzKHRoaXMsIHBhdHRlcm4sIG9wdGlvbnMpXG4gIHRoaXMuX2RpZFJlYWxQYXRoID0gZmFsc2VcblxuICAvLyBwcm9jZXNzIGVhY2ggcGF0dGVybiBpbiB0aGUgbWluaW1hdGNoIHNldFxuICB2YXIgbiA9IHRoaXMubWluaW1hdGNoLnNldC5sZW5ndGhcblxuICAvLyBUaGUgbWF0Y2hlcyBhcmUgc3RvcmVkIGFzIHs8ZmlsZW5hbWU+OiB0cnVlLC4uLn0gc28gdGhhdFxuICAvLyBkdXBsaWNhdGVzIGFyZSBhdXRvbWFnaWNhbGx5IHBydW5lZC5cbiAgLy8gTGF0ZXIsIHdlIGRvIGFuIE9iamVjdC5rZXlzKCkgb24gdGhlc2UuXG4gIC8vIEtlZXAgdGhlbSBhcyBhIGxpc3Qgc28gd2UgY2FuIGZpbGwgaW4gd2hlbiBub251bGwgaXMgc2V0LlxuICB0aGlzLm1hdGNoZXMgPSBuZXcgQXJyYXkobilcblxuICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvbmNlKGNiKVxuICAgIHRoaXMub24oJ2Vycm9yJywgY2IpXG4gICAgdGhpcy5vbignZW5kJywgZnVuY3Rpb24gKG1hdGNoZXMpIHtcbiAgICAgIGNiKG51bGwsIG1hdGNoZXMpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLl9wcm9jZXNzaW5nID0gMFxuXG4gIHRoaXMuX2VtaXRRdWV1ZSA9IFtdXG4gIHRoaXMuX3Byb2Nlc3NRdWV1ZSA9IFtdXG4gIHRoaXMucGF1c2VkID0gZmFsc2VcblxuICBpZiAodGhpcy5ub3Byb2Nlc3MpXG4gICAgcmV0dXJuIHRoaXNcblxuICBpZiAobiA9PT0gMClcbiAgICByZXR1cm4gZG9uZSgpXG5cbiAgdmFyIHN5bmMgPSB0cnVlXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSArKykge1xuICAgIHRoaXMuX3Byb2Nlc3ModGhpcy5taW5pbWF0Y2guc2V0W2ldLCBpLCBmYWxzZSwgZG9uZSlcbiAgfVxuICBzeW5jID0gZmFsc2VcblxuICBmdW5jdGlvbiBkb25lICgpIHtcbiAgICAtLXNlbGYuX3Byb2Nlc3NpbmdcbiAgICBpZiAoc2VsZi5fcHJvY2Vzc2luZyA8PSAwKSB7XG4gICAgICBpZiAoc3luYykge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLl9maW5pc2goKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5fZmluaXNoKClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuR2xvYi5wcm90b3R5cGUuX2ZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBHbG9iKVxuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIGlmICh0aGlzLnJlYWxwYXRoICYmICF0aGlzLl9kaWRSZWFscGF0aClcbiAgICByZXR1cm4gdGhpcy5fcmVhbHBhdGgoKVxuXG4gIGNvbW1vbi5maW5pc2godGhpcylcbiAgdGhpcy5lbWl0KCdlbmQnLCB0aGlzLmZvdW5kKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcmVhbHBhdGggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kaWRSZWFscGF0aClcbiAgICByZXR1cm5cblxuICB0aGlzLl9kaWRSZWFscGF0aCA9IHRydWVcblxuICB2YXIgbiA9IHRoaXMubWF0Y2hlcy5sZW5ndGhcbiAgaWYgKG4gPT09IDApXG4gICAgcmV0dXJuIHRoaXMuX2ZpbmlzaCgpXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXRjaGVzLmxlbmd0aDsgaSsrKVxuICAgIHRoaXMuX3JlYWxwYXRoU2V0KGksIG5leHQpXG5cbiAgZnVuY3Rpb24gbmV4dCAoKSB7XG4gICAgaWYgKC0tbiA9PT0gMClcbiAgICAgIHNlbGYuX2ZpbmlzaCgpXG4gIH1cbn1cblxuR2xvYi5wcm90b3R5cGUuX3JlYWxwYXRoU2V0ID0gZnVuY3Rpb24gKGluZGV4LCBjYikge1xuICB2YXIgbWF0Y2hzZXQgPSB0aGlzLm1hdGNoZXNbaW5kZXhdXG4gIGlmICghbWF0Y2hzZXQpXG4gICAgcmV0dXJuIGNiKClcblxuICB2YXIgZm91bmQgPSBPYmplY3Qua2V5cyhtYXRjaHNldClcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBuID0gZm91bmQubGVuZ3RoXG5cbiAgaWYgKG4gPT09IDApXG4gICAgcmV0dXJuIGNiKClcblxuICB2YXIgc2V0ID0gdGhpcy5tYXRjaGVzW2luZGV4XSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgZm91bmQuZm9yRWFjaChmdW5jdGlvbiAocCwgaSkge1xuICAgIC8vIElmIHRoZXJlJ3MgYSBwcm9ibGVtIHdpdGggdGhlIHN0YXQsIHRoZW4gaXQgbWVhbnMgdGhhdFxuICAgIC8vIG9uZSBvciBtb3JlIG9mIHRoZSBsaW5rcyBpbiB0aGUgcmVhbHBhdGggY291bGRuJ3QgYmVcbiAgICAvLyByZXNvbHZlZC4gIGp1c3QgcmV0dXJuIHRoZSBhYnMgdmFsdWUgaW4gdGhhdCBjYXNlLlxuICAgIHAgPSBzZWxmLl9tYWtlQWJzKHApXG4gICAgcnAucmVhbHBhdGgocCwgc2VsZi5yZWFscGF0aENhY2hlLCBmdW5jdGlvbiAoZXIsIHJlYWwpIHtcbiAgICAgIGlmICghZXIpXG4gICAgICAgIHNldFtyZWFsXSA9IHRydWVcbiAgICAgIGVsc2UgaWYgKGVyLnN5c2NhbGwgPT09ICdzdGF0JylcbiAgICAgICAgc2V0W3BdID0gdHJ1ZVxuICAgICAgZWxzZVxuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXIpIC8vIHNyc2x5IHd0ZiByaWdodCBoZXJlXG5cbiAgICAgIGlmICgtLW4gPT09IDApIHtcbiAgICAgICAgc2VsZi5tYXRjaGVzW2luZGV4XSA9IHNldFxuICAgICAgICBjYigpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn1cblxuR2xvYi5wcm90b3R5cGUuX21hcmsgPSBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gY29tbW9uLm1hcmsodGhpcywgcClcbn1cblxuR2xvYi5wcm90b3R5cGUuX21ha2VBYnMgPSBmdW5jdGlvbiAoZikge1xuICByZXR1cm4gY29tbW9uLm1ha2VBYnModGhpcywgZilcbn1cblxuR2xvYi5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYWJvcnRlZCA9IHRydWVcbiAgdGhpcy5lbWl0KCdhYm9ydCcpXG59XG5cbkdsb2IucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMucGF1c2VkKSB7XG4gICAgdGhpcy5wYXVzZWQgPSB0cnVlXG4gICAgdGhpcy5lbWl0KCdwYXVzZScpXG4gIH1cbn1cblxuR2xvYi5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICB0aGlzLmVtaXQoJ3Jlc3VtZScpXG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuICAgIGlmICh0aGlzLl9lbWl0UXVldWUubGVuZ3RoKSB7XG4gICAgICB2YXIgZXEgPSB0aGlzLl9lbWl0UXVldWUuc2xpY2UoMClcbiAgICAgIHRoaXMuX2VtaXRRdWV1ZS5sZW5ndGggPSAwXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVxLmxlbmd0aDsgaSArKykge1xuICAgICAgICB2YXIgZSA9IGVxW2ldXG4gICAgICAgIHRoaXMuX2VtaXRNYXRjaChlWzBdLCBlWzFdKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5fcHJvY2Vzc1F1ZXVlLmxlbmd0aCkge1xuICAgICAgdmFyIHBxID0gdGhpcy5fcHJvY2Vzc1F1ZXVlLnNsaWNlKDApXG4gICAgICB0aGlzLl9wcm9jZXNzUXVldWUubGVuZ3RoID0gMFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcS5sZW5ndGg7IGkgKyspIHtcbiAgICAgICAgdmFyIHAgPSBwcVtpXVxuICAgICAgICB0aGlzLl9wcm9jZXNzaW5nLS1cbiAgICAgICAgdGhpcy5fcHJvY2VzcyhwWzBdLCBwWzFdLCBwWzJdLCBwWzNdKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcHJvY2VzcyA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpIHtcbiAgYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBHbG9iKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIGlmICh0aGlzLmFib3J0ZWQpXG4gICAgcmV0dXJuXG5cbiAgdGhpcy5fcHJvY2Vzc2luZysrXG4gIGlmICh0aGlzLnBhdXNlZCkge1xuICAgIHRoaXMuX3Byb2Nlc3NRdWV1ZS5wdXNoKFtwYXR0ZXJuLCBpbmRleCwgaW5HbG9iU3RhciwgY2JdKVxuICAgIHJldHVyblxuICB9XG5cbiAgLy9jb25zb2xlLmVycm9yKCdQUk9DRVNTICVkJywgdGhpcy5fcHJvY2Vzc2luZywgcGF0dGVybilcblxuICAvLyBHZXQgdGhlIGZpcnN0IFtuXSBwYXJ0cyBvZiBwYXR0ZXJuIHRoYXQgYXJlIGFsbCBzdHJpbmdzLlxuICB2YXIgbiA9IDBcbiAgd2hpbGUgKHR5cGVvZiBwYXR0ZXJuW25dID09PSAnc3RyaW5nJykge1xuICAgIG4gKytcbiAgfVxuICAvLyBub3cgbiBpcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG9uZSB0aGF0IGlzICpub3QqIGEgc3RyaW5nLlxuXG4gIC8vIHNlZSBpZiB0aGVyZSdzIGFueXRoaW5nIGVsc2VcbiAgdmFyIHByZWZpeFxuICBzd2l0Y2ggKG4pIHtcbiAgICAvLyBpZiBub3QsIHRoZW4gdGhpcyBpcyByYXRoZXIgc2ltcGxlXG4gICAgY2FzZSBwYXR0ZXJuLmxlbmd0aDpcbiAgICAgIHRoaXMuX3Byb2Nlc3NTaW1wbGUocGF0dGVybi5qb2luKCcvJyksIGluZGV4LCBjYilcbiAgICAgIHJldHVyblxuXG4gICAgY2FzZSAwOlxuICAgICAgLy8gcGF0dGVybiAqc3RhcnRzKiB3aXRoIHNvbWUgbm9uLXRyaXZpYWwgaXRlbS5cbiAgICAgIC8vIGdvaW5nIHRvIHJlYWRkaXIoY3dkKSwgYnV0IG5vdCBpbmNsdWRlIHRoZSBwcmVmaXggaW4gbWF0Y2hlcy5cbiAgICAgIHByZWZpeCA9IG51bGxcbiAgICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gcGF0dGVybiBoYXMgc29tZSBzdHJpbmcgYml0cyBpbiB0aGUgZnJvbnQuXG4gICAgICAvLyB3aGF0ZXZlciBpdCBzdGFydHMgd2l0aCwgd2hldGhlciB0aGF0J3MgJ2Fic29sdXRlJyBsaWtlIC9mb28vYmFyLFxuICAgICAgLy8gb3IgJ3JlbGF0aXZlJyBsaWtlICcuLi9iYXonXG4gICAgICBwcmVmaXggPSBwYXR0ZXJuLnNsaWNlKDAsIG4pLmpvaW4oJy8nKVxuICAgICAgYnJlYWtcbiAgfVxuXG4gIHZhciByZW1haW4gPSBwYXR0ZXJuLnNsaWNlKG4pXG5cbiAgLy8gZ2V0IHRoZSBsaXN0IG9mIGVudHJpZXMuXG4gIHZhciByZWFkXG4gIGlmIChwcmVmaXggPT09IG51bGwpXG4gICAgcmVhZCA9ICcuJ1xuICBlbHNlIGlmIChpc0Fic29sdXRlKHByZWZpeCkgfHxcbiAgICAgIGlzQWJzb2x1dGUocGF0dGVybi5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwID09PSAnc3RyaW5nJyA/IHAgOiAnWypdJ1xuICAgICAgfSkuam9pbignLycpKSkge1xuICAgIGlmICghcHJlZml4IHx8ICFpc0Fic29sdXRlKHByZWZpeCkpXG4gICAgICBwcmVmaXggPSAnLycgKyBwcmVmaXhcbiAgICByZWFkID0gcHJlZml4XG4gIH0gZWxzZVxuICAgIHJlYWQgPSBwcmVmaXhcblxuICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhyZWFkKVxuXG4gIC8vaWYgaWdub3JlZCwgc2tpcCBfcHJvY2Vzc2luZ1xuICBpZiAoY2hpbGRyZW5JZ25vcmVkKHRoaXMsIHJlYWQpKVxuICAgIHJldHVybiBjYigpXG5cbiAgdmFyIGlzR2xvYlN0YXIgPSByZW1haW5bMF0gPT09IG1pbmltYXRjaC5HTE9CU1RBUlxuICBpZiAoaXNHbG9iU3RhcilcbiAgICB0aGlzLl9wcm9jZXNzR2xvYlN0YXIocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGNiKVxuICBlbHNlXG4gICAgdGhpcy5fcHJvY2Vzc1JlYWRkaXIocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGNiKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcHJvY2Vzc1JlYWRkaXIgPSBmdW5jdGlvbiAocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLl9yZWFkZGlyKGFicywgaW5HbG9iU3RhciwgZnVuY3Rpb24gKGVyLCBlbnRyaWVzKSB7XG4gICAgcmV0dXJuIHNlbGYuX3Byb2Nlc3NSZWFkZGlyMihwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgZW50cmllcywgY2IpXG4gIH0pXG59XG5cbkdsb2IucHJvdG90eXBlLl9wcm9jZXNzUmVhZGRpcjIgPSBmdW5jdGlvbiAocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGVudHJpZXMsIGNiKSB7XG5cbiAgLy8gaWYgdGhlIGFicyBpc24ndCBhIGRpciwgdGhlbiBub3RoaW5nIGNhbiBtYXRjaCFcbiAgaWYgKCFlbnRyaWVzKVxuICAgIHJldHVybiBjYigpXG5cbiAgLy8gSXQgd2lsbCBvbmx5IG1hdGNoIGRvdCBlbnRyaWVzIGlmIGl0IHN0YXJ0cyB3aXRoIGEgZG90LCBvciBpZlxuICAvLyBkb3QgaXMgc2V0LiAgU3R1ZmYgbGlrZSBAKC5mb298LmJhcikgaXNuJ3QgYWxsb3dlZC5cbiAgdmFyIHBuID0gcmVtYWluWzBdXG4gIHZhciBuZWdhdGUgPSAhIXRoaXMubWluaW1hdGNoLm5lZ2F0ZVxuICB2YXIgcmF3R2xvYiA9IHBuLl9nbG9iXG4gIHZhciBkb3RPayA9IHRoaXMuZG90IHx8IHJhd0dsb2IuY2hhckF0KDApID09PSAnLidcblxuICB2YXIgbWF0Y2hlZEVudHJpZXMgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZSA9IGVudHJpZXNbaV1cbiAgICBpZiAoZS5jaGFyQXQoMCkgIT09ICcuJyB8fCBkb3RPaykge1xuICAgICAgdmFyIG1cbiAgICAgIGlmIChuZWdhdGUgJiYgIXByZWZpeCkge1xuICAgICAgICBtID0gIWUubWF0Y2gocG4pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtID0gZS5tYXRjaChwbilcbiAgICAgIH1cbiAgICAgIGlmIChtKVxuICAgICAgICBtYXRjaGVkRW50cmllcy5wdXNoKGUpXG4gICAgfVxuICB9XG5cbiAgLy9jb25zb2xlLmVycm9yKCdwcmQyJywgcHJlZml4LCBlbnRyaWVzLCByZW1haW5bMF0uX2dsb2IsIG1hdGNoZWRFbnRyaWVzKVxuXG4gIHZhciBsZW4gPSBtYXRjaGVkRW50cmllcy5sZW5ndGhcbiAgLy8gSWYgdGhlcmUgYXJlIG5vIG1hdGNoZWQgZW50cmllcywgdGhlbiBub3RoaW5nIG1hdGNoZXMuXG4gIGlmIChsZW4gPT09IDApXG4gICAgcmV0dXJuIGNiKClcblxuICAvLyBpZiB0aGlzIGlzIHRoZSBsYXN0IHJlbWFpbmluZyBwYXR0ZXJuIGJpdCwgdGhlbiBubyBuZWVkIGZvclxuICAvLyBhbiBhZGRpdGlvbmFsIHN0YXQgKnVubGVzcyogdGhlIHVzZXIgaGFzIHNwZWNpZmllZCBtYXJrIG9yXG4gIC8vIHN0YXQgZXhwbGljaXRseS4gIFdlIGtub3cgdGhleSBleGlzdCwgc2luY2UgcmVhZGRpciByZXR1cm5lZFxuICAvLyB0aGVtLlxuXG4gIGlmIChyZW1haW4ubGVuZ3RoID09PSAxICYmICF0aGlzLm1hcmsgJiYgIXRoaXMuc3RhdCkge1xuICAgIGlmICghdGhpcy5tYXRjaGVzW2luZGV4XSlcbiAgICAgIHRoaXMubWF0Y2hlc1tpbmRleF0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArKykge1xuICAgICAgdmFyIGUgPSBtYXRjaGVkRW50cmllc1tpXVxuICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICBpZiAocHJlZml4ICE9PSAnLycpXG4gICAgICAgICAgZSA9IHByZWZpeCArICcvJyArIGVcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGUgPSBwcmVmaXggKyBlXG4gICAgICB9XG5cbiAgICAgIGlmIChlLmNoYXJBdCgwKSA9PT0gJy8nICYmICF0aGlzLm5vbW91bnQpIHtcbiAgICAgICAgZSA9IHBhdGguam9pbih0aGlzLnJvb3QsIGUpXG4gICAgICB9XG4gICAgICB0aGlzLl9lbWl0TWF0Y2goaW5kZXgsIGUpXG4gICAgfVxuICAgIC8vIFRoaXMgd2FzIHRoZSBsYXN0IG9uZSwgYW5kIG5vIHN0YXRzIHdlcmUgbmVlZGVkXG4gICAgcmV0dXJuIGNiKClcbiAgfVxuXG4gIC8vIG5vdyB0ZXN0IGFsbCBtYXRjaGVkIGVudHJpZXMgYXMgc3RhbmQtaW5zIGZvciB0aGF0IHBhcnRcbiAgLy8gb2YgdGhlIHBhdHRlcm4uXG4gIHJlbWFpbi5zaGlmdCgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICsrKSB7XG4gICAgdmFyIGUgPSBtYXRjaGVkRW50cmllc1tpXVxuICAgIHZhciBuZXdQYXR0ZXJuXG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgaWYgKHByZWZpeCAhPT0gJy8nKVxuICAgICAgICBlID0gcHJlZml4ICsgJy8nICsgZVxuICAgICAgZWxzZVxuICAgICAgICBlID0gcHJlZml4ICsgZVxuICAgIH1cbiAgICB0aGlzLl9wcm9jZXNzKFtlXS5jb25jYXQocmVtYWluKSwgaW5kZXgsIGluR2xvYlN0YXIsIGNiKVxuICB9XG4gIGNiKClcbn1cblxuR2xvYi5wcm90b3R5cGUuX2VtaXRNYXRjaCA9IGZ1bmN0aW9uIChpbmRleCwgZSkge1xuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIGlmIChpc0lnbm9yZWQodGhpcywgZSkpXG4gICAgcmV0dXJuXG5cbiAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgdGhpcy5fZW1pdFF1ZXVlLnB1c2goW2luZGV4LCBlXSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBhYnMgPSBpc0Fic29sdXRlKGUpID8gZSA6IHRoaXMuX21ha2VBYnMoZSlcblxuICBpZiAodGhpcy5tYXJrKVxuICAgIGUgPSB0aGlzLl9tYXJrKGUpXG5cbiAgaWYgKHRoaXMuYWJzb2x1dGUpXG4gICAgZSA9IGFic1xuXG4gIGlmICh0aGlzLm1hdGNoZXNbaW5kZXhdW2VdKVxuICAgIHJldHVyblxuXG4gIGlmICh0aGlzLm5vZGlyKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNhY2hlW2Fic11cbiAgICBpZiAoYyA9PT0gJ0RJUicgfHwgQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy5tYXRjaGVzW2luZGV4XVtlXSA9IHRydWVcblxuICB2YXIgc3QgPSB0aGlzLnN0YXRDYWNoZVthYnNdXG4gIGlmIChzdClcbiAgICB0aGlzLmVtaXQoJ3N0YXQnLCBlLCBzdClcblxuICB0aGlzLmVtaXQoJ21hdGNoJywgZSlcbn1cblxuR2xvYi5wcm90b3R5cGUuX3JlYWRkaXJJbkdsb2JTdGFyID0gZnVuY3Rpb24gKGFicywgY2IpIHtcbiAgaWYgKHRoaXMuYWJvcnRlZClcbiAgICByZXR1cm5cblxuICAvLyBmb2xsb3cgYWxsIHN5bWxpbmtlZCBkaXJlY3RvcmllcyBmb3JldmVyXG4gIC8vIGp1c3QgcHJvY2VlZCBhcyBpZiB0aGlzIGlzIGEgbm9uLWdsb2JzdGFyIHNpdHVhdGlvblxuICBpZiAodGhpcy5mb2xsb3cpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRkaXIoYWJzLCBmYWxzZSwgY2IpXG5cbiAgdmFyIGxzdGF0a2V5ID0gJ2xzdGF0XFwwJyArIGFic1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGxzdGF0Y2IgPSBpbmZsaWdodChsc3RhdGtleSwgbHN0YXRjYl8pXG5cbiAgaWYgKGxzdGF0Y2IpXG4gICAgc2VsZi5mcy5sc3RhdChhYnMsIGxzdGF0Y2IpXG5cbiAgZnVuY3Rpb24gbHN0YXRjYl8gKGVyLCBsc3RhdCkge1xuICAgIGlmIChlciAmJiBlci5jb2RlID09PSAnRU5PRU5UJylcbiAgICAgIHJldHVybiBjYigpXG5cbiAgICB2YXIgaXNTeW0gPSBsc3RhdCAmJiBsc3RhdC5pc1N5bWJvbGljTGluaygpXG4gICAgc2VsZi5zeW1saW5rc1thYnNdID0gaXNTeW1cblxuICAgIC8vIElmIGl0J3Mgbm90IGEgc3ltbGluayBvciBhIGRpciwgdGhlbiBpdCdzIGRlZmluaXRlbHkgYSByZWd1bGFyIGZpbGUuXG4gICAgLy8gZG9uJ3QgYm90aGVyIGRvaW5nIGEgcmVhZGRpciBpbiB0aGF0IGNhc2UuXG4gICAgaWYgKCFpc1N5bSAmJiBsc3RhdCAmJiAhbHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgc2VsZi5jYWNoZVthYnNdID0gJ0ZJTEUnXG4gICAgICBjYigpXG4gICAgfSBlbHNlXG4gICAgICBzZWxmLl9yZWFkZGlyKGFicywgZmFsc2UsIGNiKVxuICB9XG59XG5cbkdsb2IucHJvdG90eXBlLl9yZWFkZGlyID0gZnVuY3Rpb24gKGFicywgaW5HbG9iU3RhciwgY2IpIHtcbiAgaWYgKHRoaXMuYWJvcnRlZClcbiAgICByZXR1cm5cblxuICBjYiA9IGluZmxpZ2h0KCdyZWFkZGlyXFwwJythYnMrJ1xcMCcraW5HbG9iU3RhciwgY2IpXG4gIGlmICghY2IpXG4gICAgcmV0dXJuXG5cbiAgLy9jb25zb2xlLmVycm9yKCdSRCAlaiAlaicsICtpbkdsb2JTdGFyLCBhYnMpXG4gIGlmIChpbkdsb2JTdGFyICYmICFvd25Qcm9wKHRoaXMuc3ltbGlua3MsIGFicykpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRkaXJJbkdsb2JTdGFyKGFicywgY2IpXG5cbiAgaWYgKG93blByb3AodGhpcy5jYWNoZSwgYWJzKSkge1xuICAgIHZhciBjID0gdGhpcy5jYWNoZVthYnNdXG4gICAgaWYgKCFjIHx8IGMgPT09ICdGSUxFJylcbiAgICAgIHJldHVybiBjYigpXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIHJldHVybiBjYihudWxsLCBjKVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuZnMucmVhZGRpcihhYnMsIHJlYWRkaXJDYih0aGlzLCBhYnMsIGNiKSlcbn1cblxuZnVuY3Rpb24gcmVhZGRpckNiIChzZWxmLCBhYnMsIGNiKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZXIsIGVudHJpZXMpIHtcbiAgICBpZiAoZXIpXG4gICAgICBzZWxmLl9yZWFkZGlyRXJyb3IoYWJzLCBlciwgY2IpXG4gICAgZWxzZVxuICAgICAgc2VsZi5fcmVhZGRpckVudHJpZXMoYWJzLCBlbnRyaWVzLCBjYilcbiAgfVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcmVhZGRpckVudHJpZXMgPSBmdW5jdGlvbiAoYWJzLCBlbnRyaWVzLCBjYikge1xuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIC8vIGlmIHdlIGhhdmVuJ3QgYXNrZWQgdG8gc3RhdCBldmVyeXRoaW5nLCB0aGVuIGp1c3RcbiAgLy8gYXNzdW1lIHRoYXQgZXZlcnl0aGluZyBpbiB0aGVyZSBleGlzdHMsIHNvIHdlIGNhbiBhdm9pZFxuICAvLyBoYXZpbmcgdG8gc3RhdCBpdCBhIHNlY29uZCB0aW1lLlxuICBpZiAoIXRoaXMubWFyayAmJiAhdGhpcy5zdGF0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSArKykge1xuICAgICAgdmFyIGUgPSBlbnRyaWVzW2ldXG4gICAgICBpZiAoYWJzID09PSAnLycpXG4gICAgICAgIGUgPSBhYnMgKyBlXG4gICAgICBlbHNlXG4gICAgICAgIGUgPSBhYnMgKyAnLycgKyBlXG4gICAgICB0aGlzLmNhY2hlW2VdID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuY2FjaGVbYWJzXSA9IGVudHJpZXNcbiAgcmV0dXJuIGNiKG51bGwsIGVudHJpZXMpXG59XG5cbkdsb2IucHJvdG90eXBlLl9yZWFkZGlyRXJyb3IgPSBmdW5jdGlvbiAoZiwgZXIsIGNiKSB7XG4gIGlmICh0aGlzLmFib3J0ZWQpXG4gICAgcmV0dXJuXG5cbiAgLy8gaGFuZGxlIGVycm9ycywgYW5kIGNhY2hlIHRoZSBpbmZvcm1hdGlvblxuICBzd2l0Y2ggKGVyLmNvZGUpIHtcbiAgICBjYXNlICdFTk9UU1VQJzogLy8gaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdsb2IvaXNzdWVzLzIwNVxuICAgIGNhc2UgJ0VOT1RESVInOiAvLyB0b3RhbGx5IG5vcm1hbC4gbWVhbnMgaXQgKmRvZXMqIGV4aXN0LlxuICAgICAgdmFyIGFicyA9IHRoaXMuX21ha2VBYnMoZilcbiAgICAgIHRoaXMuY2FjaGVbYWJzXSA9ICdGSUxFJ1xuICAgICAgaWYgKGFicyA9PT0gdGhpcy5jd2RBYnMpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKGVyLmNvZGUgKyAnIGludmFsaWQgY3dkICcgKyB0aGlzLmN3ZClcbiAgICAgICAgZXJyb3IucGF0aCA9IHRoaXMuY3dkXG4gICAgICAgIGVycm9yLmNvZGUgPSBlci5jb2RlXG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcilcbiAgICAgICAgdGhpcy5hYm9ydCgpXG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSAnRU5PRU5UJzogLy8gbm90IHRlcnJpYmx5IHVudXN1YWxcbiAgICBjYXNlICdFTE9PUCc6XG4gICAgY2FzZSAnRU5BTUVUT09MT05HJzpcbiAgICBjYXNlICdVTktOT1dOJzpcbiAgICAgIHRoaXMuY2FjaGVbdGhpcy5fbWFrZUFicyhmKV0gPSBmYWxzZVxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6IC8vIHNvbWUgdW51c3VhbCBlcnJvci4gIFRyZWF0IGFzIGZhaWx1cmUuXG4gICAgICB0aGlzLmNhY2hlW3RoaXMuX21ha2VBYnMoZildID0gZmFsc2VcbiAgICAgIGlmICh0aGlzLnN0cmljdCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgICAgIC8vIElmIHRoZSBlcnJvciBpcyBoYW5kbGVkLCB0aGVuIHdlIGFib3J0XG4gICAgICAgIC8vIGlmIG5vdCwgd2UgdGhyZXcgb3V0IG9mIGhlcmVcbiAgICAgICAgdGhpcy5hYm9ydCgpXG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc2lsZW50KVxuICAgICAgICBjb25zb2xlLmVycm9yKCdnbG9iIGVycm9yJywgZXIpXG4gICAgICBicmVha1xuICB9XG5cbiAgcmV0dXJuIGNiKClcbn1cblxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3NHbG9iU3RhciA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX3JlYWRkaXIoYWJzLCBpbkdsb2JTdGFyLCBmdW5jdGlvbiAoZXIsIGVudHJpZXMpIHtcbiAgICBzZWxmLl9wcm9jZXNzR2xvYlN0YXIyKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyLCBlbnRyaWVzLCBjYilcbiAgfSlcbn1cblxuXG5HbG9iLnByb3RvdHlwZS5fcHJvY2Vzc0dsb2JTdGFyMiA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgZW50cmllcywgY2IpIHtcbiAgLy9jb25zb2xlLmVycm9yKCdwZ3MyJywgcHJlZml4LCByZW1haW5bMF0sIGVudHJpZXMpXG5cbiAgLy8gbm8gZW50cmllcyBtZWFucyBub3QgYSBkaXIsIHNvIGl0IGNhbiBuZXZlciBoYXZlIG1hdGNoZXNcbiAgLy8gZm9vLnR4dC8qKiBkb2Vzbid0IG1hdGNoIGZvby50eHRcbiAgaWYgKCFlbnRyaWVzKVxuICAgIHJldHVybiBjYigpXG5cbiAgLy8gdGVzdCB3aXRob3V0IHRoZSBnbG9ic3RhciwgYW5kIHdpdGggZXZlcnkgY2hpbGQgYm90aCBiZWxvd1xuICAvLyBhbmQgcmVwbGFjaW5nIHRoZSBnbG9ic3Rhci5cbiAgdmFyIHJlbWFpbldpdGhvdXRHbG9iU3RhciA9IHJlbWFpbi5zbGljZSgxKVxuICB2YXIgZ3NwcmVmID0gcHJlZml4ID8gWyBwcmVmaXggXSA6IFtdXG4gIHZhciBub0dsb2JTdGFyID0gZ3NwcmVmLmNvbmNhdChyZW1haW5XaXRob3V0R2xvYlN0YXIpXG5cbiAgLy8gdGhlIG5vR2xvYlN0YXIgcGF0dGVybiBleGl0cyB0aGUgaW5HbG9iU3RhciBzdGF0ZVxuICB0aGlzLl9wcm9jZXNzKG5vR2xvYlN0YXIsIGluZGV4LCBmYWxzZSwgY2IpXG5cbiAgdmFyIGlzU3ltID0gdGhpcy5zeW1saW5rc1thYnNdXG4gIHZhciBsZW4gPSBlbnRyaWVzLmxlbmd0aFxuXG4gIC8vIElmIGl0J3MgYSBzeW1saW5rLCBhbmQgd2UncmUgaW4gYSBnbG9ic3RhciwgdGhlbiBzdG9wXG4gIGlmIChpc1N5bSAmJiBpbkdsb2JTdGFyKVxuICAgIHJldHVybiBjYigpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBlID0gZW50cmllc1tpXVxuICAgIGlmIChlLmNoYXJBdCgwKSA9PT0gJy4nICYmICF0aGlzLmRvdClcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAvLyB0aGVzZSB0d28gY2FzZXMgZW50ZXIgdGhlIGluR2xvYlN0YXIgc3RhdGVcbiAgICB2YXIgaW5zdGVhZCA9IGdzcHJlZi5jb25jYXQoZW50cmllc1tpXSwgcmVtYWluV2l0aG91dEdsb2JTdGFyKVxuICAgIHRoaXMuX3Byb2Nlc3MoaW5zdGVhZCwgaW5kZXgsIHRydWUsIGNiKVxuXG4gICAgdmFyIGJlbG93ID0gZ3NwcmVmLmNvbmNhdChlbnRyaWVzW2ldLCByZW1haW4pXG4gICAgdGhpcy5fcHJvY2VzcyhiZWxvdywgaW5kZXgsIHRydWUsIGNiKVxuICB9XG5cbiAgY2IoKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcHJvY2Vzc1NpbXBsZSA9IGZ1bmN0aW9uIChwcmVmaXgsIGluZGV4LCBjYikge1xuICAvLyBYWFggcmV2aWV3IHRoaXMuICBTaG91bGRuJ3QgaXQgYmUgZG9pbmcgdGhlIG1vdW50aW5nIGV0Y1xuICAvLyBiZWZvcmUgZG9pbmcgc3RhdD8gIGtpbmRhIHdlaXJkP1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5fc3RhdChwcmVmaXgsIGZ1bmN0aW9uIChlciwgZXhpc3RzKSB7XG4gICAgc2VsZi5fcHJvY2Vzc1NpbXBsZTIocHJlZml4LCBpbmRleCwgZXIsIGV4aXN0cywgY2IpXG4gIH0pXG59XG5HbG9iLnByb3RvdHlwZS5fcHJvY2Vzc1NpbXBsZTIgPSBmdW5jdGlvbiAocHJlZml4LCBpbmRleCwgZXIsIGV4aXN0cywgY2IpIHtcblxuICAvL2NvbnNvbGUuZXJyb3IoJ3BzMicsIHByZWZpeCwgZXhpc3RzKVxuXG4gIGlmICghdGhpcy5tYXRjaGVzW2luZGV4XSlcbiAgICB0aGlzLm1hdGNoZXNbaW5kZXhdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIC8vIElmIGl0IGRvZXNuJ3QgZXhpc3QsIHRoZW4ganVzdCBtYXJrIHRoZSBsYWNrIG9mIHJlc3VsdHNcbiAgaWYgKCFleGlzdHMpXG4gICAgcmV0dXJuIGNiKClcblxuICBpZiAocHJlZml4ICYmIGlzQWJzb2x1dGUocHJlZml4KSAmJiAhdGhpcy5ub21vdW50KSB7XG4gICAgdmFyIHRyYWlsID0gL1tcXC9cXFxcXSQvLnRlc3QocHJlZml4KVxuICAgIGlmIChwcmVmaXguY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgIHByZWZpeCA9IHBhdGguam9pbih0aGlzLnJvb3QsIHByZWZpeClcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZml4ID0gcGF0aC5yZXNvbHZlKHRoaXMucm9vdCwgcHJlZml4KVxuICAgICAgaWYgKHRyYWlsKVxuICAgICAgICBwcmVmaXggKz0gJy8nXG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpXG4gICAgcHJlZml4ID0gcHJlZml4LnJlcGxhY2UoL1xcXFwvZywgJy8nKVxuXG4gIC8vIE1hcmsgdGhpcyBhcyBhIG1hdGNoXG4gIHRoaXMuX2VtaXRNYXRjaChpbmRleCwgcHJlZml4KVxuICBjYigpXG59XG5cbi8vIFJldHVybnMgZWl0aGVyICdESVInLCAnRklMRScsIG9yIGZhbHNlXG5HbG9iLnByb3RvdHlwZS5fc3RhdCA9IGZ1bmN0aW9uIChmLCBjYikge1xuICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhmKVxuICB2YXIgbmVlZERpciA9IGYuc2xpY2UoLTEpID09PSAnLydcblxuICBpZiAoZi5sZW5ndGggPiB0aGlzLm1heExlbmd0aClcbiAgICByZXR1cm4gY2IoKVxuXG4gIGlmICghdGhpcy5zdGF0ICYmIG93blByb3AodGhpcy5jYWNoZSwgYWJzKSkge1xuICAgIHZhciBjID0gdGhpcy5jYWNoZVthYnNdXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIGMgPSAnRElSJ1xuXG4gICAgLy8gSXQgZXhpc3RzLCBidXQgbWF5YmUgbm90IGhvdyB3ZSBuZWVkIGl0XG4gICAgaWYgKCFuZWVkRGlyIHx8IGMgPT09ICdESVInKVxuICAgICAgcmV0dXJuIGNiKG51bGwsIGMpXG5cbiAgICBpZiAobmVlZERpciAmJiBjID09PSAnRklMRScpXG4gICAgICByZXR1cm4gY2IoKVxuXG4gICAgLy8gb3RoZXJ3aXNlIHdlIGhhdmUgdG8gc3RhdCwgYmVjYXVzZSBtYXliZSBjPXRydWVcbiAgICAvLyBpZiB3ZSBrbm93IGl0IGV4aXN0cywgYnV0IG5vdCB3aGF0IGl0IGlzLlxuICB9XG5cbiAgdmFyIGV4aXN0c1xuICB2YXIgc3RhdCA9IHRoaXMuc3RhdENhY2hlW2Fic11cbiAgaWYgKHN0YXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChzdGF0ID09PSBmYWxzZSlcbiAgICAgIHJldHVybiBjYihudWxsLCBzdGF0KVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHR5cGUgPSBzdGF0LmlzRGlyZWN0b3J5KCkgPyAnRElSJyA6ICdGSUxFJ1xuICAgICAgaWYgKG5lZWREaXIgJiYgdHlwZSA9PT0gJ0ZJTEUnKVxuICAgICAgICByZXR1cm4gY2IoKVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gY2IobnVsbCwgdHlwZSwgc3RhdClcbiAgICB9XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHN0YXRjYiA9IGluZmxpZ2h0KCdzdGF0XFwwJyArIGFicywgbHN0YXRjYl8pXG4gIGlmIChzdGF0Y2IpXG4gICAgc2VsZi5mcy5sc3RhdChhYnMsIHN0YXRjYilcblxuICBmdW5jdGlvbiBsc3RhdGNiXyAoZXIsIGxzdGF0KSB7XG4gICAgaWYgKGxzdGF0ICYmIGxzdGF0LmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgIC8vIElmIGl0J3MgYSBzeW1saW5rLCB0aGVuIHRyZWF0IGl0IGFzIHRoZSB0YXJnZXQsIHVubGVzc1xuICAgICAgLy8gdGhlIHRhcmdldCBkb2VzIG5vdCBleGlzdCwgdGhlbiB0cmVhdCBpdCBhcyBhIGZpbGUuXG4gICAgICByZXR1cm4gc2VsZi5mcy5zdGF0KGFicywgZnVuY3Rpb24gKGVyLCBzdGF0KSB7XG4gICAgICAgIGlmIChlcilcbiAgICAgICAgICBzZWxmLl9zdGF0MihmLCBhYnMsIG51bGwsIGxzdGF0LCBjYilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNlbGYuX3N0YXQyKGYsIGFicywgZXIsIHN0YXQsIGNiKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5fc3RhdDIoZiwgYWJzLCBlciwgbHN0YXQsIGNiKVxuICAgIH1cbiAgfVxufVxuXG5HbG9iLnByb3RvdHlwZS5fc3RhdDIgPSBmdW5jdGlvbiAoZiwgYWJzLCBlciwgc3RhdCwgY2IpIHtcbiAgaWYgKGVyICYmIChlci5jb2RlID09PSAnRU5PRU5UJyB8fCBlci5jb2RlID09PSAnRU5PVERJUicpKSB7XG4gICAgdGhpcy5zdGF0Q2FjaGVbYWJzXSA9IGZhbHNlXG4gICAgcmV0dXJuIGNiKClcbiAgfVxuXG4gIHZhciBuZWVkRGlyID0gZi5zbGljZSgtMSkgPT09ICcvJ1xuICB0aGlzLnN0YXRDYWNoZVthYnNdID0gc3RhdFxuXG4gIGlmIChhYnMuc2xpY2UoLTEpID09PSAnLycgJiYgc3RhdCAmJiAhc3RhdC5pc0RpcmVjdG9yeSgpKVxuICAgIHJldHVybiBjYihudWxsLCBmYWxzZSwgc3RhdClcblxuICB2YXIgYyA9IHRydWVcbiAgaWYgKHN0YXQpXG4gICAgYyA9IHN0YXQuaXNEaXJlY3RvcnkoKSA/ICdESVInIDogJ0ZJTEUnXG4gIHRoaXMuY2FjaGVbYWJzXSA9IHRoaXMuY2FjaGVbYWJzXSB8fCBjXG5cbiAgaWYgKG5lZWREaXIgJiYgYyA9PT0gJ0ZJTEUnKVxuICAgIHJldHVybiBjYigpXG5cbiAgcmV0dXJuIGNiKG51bGwsIGMsIHN0YXQpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/glob/glob.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/glob/sync.js":
/*!******************************************************!*\
  !*** ./node_modules/mocha/node_modules/glob/sync.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = globSync\nglobSync.GlobSync = GlobSync\n\nvar rp = __webpack_require__(/*! fs.realpath */ \"(ssr)/./node_modules/fs.realpath/index.js\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"(ssr)/./node_modules/mocha/node_modules/minimatch/minimatch.js\")\nvar Minimatch = minimatch.Minimatch\nvar Glob = (__webpack_require__(/*! ./glob.js */ \"(ssr)/./node_modules/mocha/node_modules/glob/glob.js\").Glob)\nvar util = __webpack_require__(/*! util */ \"util\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar assert = __webpack_require__(/*! assert */ \"assert\")\nvar isAbsolute = (__webpack_require__(/*! path */ \"path\").isAbsolute)\nvar common = __webpack_require__(/*! ./common.js */ \"(ssr)/./node_modules/mocha/node_modules/glob/common.js\")\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nfunction globSync (pattern, options) {\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  return new GlobSync(pattern, options).found\n}\n\nfunction GlobSync (pattern, options) {\n  if (!pattern)\n    throw new Error('must provide pattern')\n\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  if (!(this instanceof GlobSync))\n    return new GlobSync(pattern, options)\n\n  setopts(this, pattern, options)\n\n  if (this.noprocess)\n    return this\n\n  var n = this.minimatch.set.length\n  this.matches = new Array(n)\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false)\n  }\n  this._finish()\n}\n\nGlobSync.prototype._finish = function () {\n  assert.ok(this instanceof GlobSync)\n  if (this.realpath) {\n    var self = this\n    this.matches.forEach(function (matchset, index) {\n      var set = self.matches[index] = Object.create(null)\n      for (var p in matchset) {\n        try {\n          p = self._makeAbs(p)\n          var real = rp.realpathSync(p, self.realpathCache)\n          set[real] = true\n        } catch (er) {\n          if (er.syscall === 'stat')\n            set[self._makeAbs(p)] = true\n          else\n            throw er\n        }\n      }\n    })\n  }\n  common.finish(this)\n}\n\n\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\n  assert.ok(this instanceof GlobSync)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // See if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) ||\n      isAbsolute(pattern.map(function (p) {\n        return typeof p === 'string' ? p : '[*]'\n      }).join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip processing\n  if (childrenIgnored(this, read))\n    return\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)\n}\n\n\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar)\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix.slice(-1) !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix)\n      newPattern = [prefix, e]\n    else\n      newPattern = [e]\n    this._process(newPattern.concat(remain), index, inGlobStar)\n  }\n}\n\n\nGlobSync.prototype._emitMatch = function (index, e) {\n  if (isIgnored(this, e))\n    return\n\n  var abs = this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute) {\n    e = abs\n  }\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  if (this.stat)\n    this._stat(e)\n}\n\n\nGlobSync.prototype._readdirInGlobStar = function (abs) {\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false)\n\n  var entries\n  var lstat\n  var stat\n  try {\n    lstat = this.fs.lstatSync(abs)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      // lstat failed, doesn't exist\n      return null\n    }\n  }\n\n  var isSym = lstat && lstat.isSymbolicLink()\n  this.symlinks[abs] = isSym\n\n  // If it's not a symlink or a dir, then it's definitely a regular file.\n  // don't bother doing a readdir in that case.\n  if (!isSym && lstat && !lstat.isDirectory())\n    this.cache[abs] = 'FILE'\n  else\n    entries = this._readdir(abs, false)\n\n  return entries\n}\n\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\n  var entries\n\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return null\n\n    if (Array.isArray(c))\n      return c\n  }\n\n  try {\n    return this._readdirEntries(abs, this.fs.readdirSync(abs))\n  } catch (er) {\n    this._readdirError(abs, er)\n    return null\n  }\n}\n\nGlobSync.prototype._readdirEntries = function (abs, entries) {\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n\n  // mark and cache dir-ness\n  return entries\n}\n\nGlobSync.prototype._readdirError = function (f, er) {\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        throw error\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict)\n        throw er\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n}\n\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n\n  var entries = this._readdir(abs, inGlobStar)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false)\n\n  var len = entries.length\n  var isSym = this.symlinks[abs]\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true)\n  }\n}\n\nGlobSync.prototype._processSimple = function (prefix, index) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var exists = this._stat(prefix)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function (f) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return false\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return c\n\n    if (needDir && c === 'FILE')\n      return false\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (!stat) {\n    var lstat\n    try {\n      lstat = this.fs.lstatSync(abs)\n    } catch (er) {\n      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n        this.statCache[abs] = false\n        return false\n      }\n    }\n\n    if (lstat && lstat.isSymbolicLink()) {\n      try {\n        stat = this.fs.statSync(abs)\n      } catch (er) {\n        stat = lstat\n      }\n    } else {\n      stat = lstat\n    }\n  }\n\n  this.statCache[abs] = stat\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return false\n\n  return c\n}\n\nGlobSync.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlobSync.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2dsb2Ivc3luYy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBLFNBQVMsbUJBQU8sQ0FBQyw4REFBYTtBQUM5QixnQkFBZ0IsbUJBQU8sQ0FBQyxpRkFBVztBQUNuQztBQUNBLFdBQVcsbUdBQXlCO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGlCQUFpQixvREFBMEI7QUFDM0MsYUFBYSxtQkFBTyxDQUFDLDJFQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2dsb2Ivc3luYy5qcz81ZDA4Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZ2xvYlN5bmNcbmdsb2JTeW5jLkdsb2JTeW5jID0gR2xvYlN5bmNcblxudmFyIHJwID0gcmVxdWlyZSgnZnMucmVhbHBhdGgnKVxudmFyIG1pbmltYXRjaCA9IHJlcXVpcmUoJ21pbmltYXRjaCcpXG52YXIgTWluaW1hdGNoID0gbWluaW1hdGNoLk1pbmltYXRjaFxudmFyIEdsb2IgPSByZXF1aXJlKCcuL2dsb2IuanMnKS5HbG9iXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxudmFyIGlzQWJzb2x1dGUgPSByZXF1aXJlKCdwYXRoJykuaXNBYnNvbHV0ZVxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uLmpzJylcbnZhciBzZXRvcHRzID0gY29tbW9uLnNldG9wdHNcbnZhciBvd25Qcm9wID0gY29tbW9uLm93blByb3BcbnZhciBjaGlsZHJlbklnbm9yZWQgPSBjb21tb24uY2hpbGRyZW5JZ25vcmVkXG52YXIgaXNJZ25vcmVkID0gY29tbW9uLmlzSWdub3JlZFxuXG5mdW5jdGlvbiBnbG9iU3luYyAocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBwcm92aWRlZCB0byBzeW5jIGdsb2JcXG4nK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdsb2IvaXNzdWVzLzE2NycpXG5cbiAgcmV0dXJuIG5ldyBHbG9iU3luYyhwYXR0ZXJuLCBvcHRpb25zKS5mb3VuZFxufVxuXG5mdW5jdGlvbiBHbG9iU3luYyAocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAoIXBhdHRlcm4pXG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHByb3ZpZGUgcGF0dGVybicpXG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDMpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgcHJvdmlkZWQgdG8gc3luYyBnbG9iXFxuJytcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1nbG9iL2lzc3Vlcy8xNjcnKVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHbG9iU3luYykpXG4gICAgcmV0dXJuIG5ldyBHbG9iU3luYyhwYXR0ZXJuLCBvcHRpb25zKVxuXG4gIHNldG9wdHModGhpcywgcGF0dGVybiwgb3B0aW9ucylcblxuICBpZiAodGhpcy5ub3Byb2Nlc3MpXG4gICAgcmV0dXJuIHRoaXNcblxuICB2YXIgbiA9IHRoaXMubWluaW1hdGNoLnNldC5sZW5ndGhcbiAgdGhpcy5tYXRjaGVzID0gbmV3IEFycmF5KG4pXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSArKykge1xuICAgIHRoaXMuX3Byb2Nlc3ModGhpcy5taW5pbWF0Y2guc2V0W2ldLCBpLCBmYWxzZSlcbiAgfVxuICB0aGlzLl9maW5pc2goKVxufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX2ZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgYXNzZXJ0Lm9rKHRoaXMgaW5zdGFuY2VvZiBHbG9iU3luYylcbiAgaWYgKHRoaXMucmVhbHBhdGgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICB0aGlzLm1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAobWF0Y2hzZXQsIGluZGV4KSB7XG4gICAgICB2YXIgc2V0ID0gc2VsZi5tYXRjaGVzW2luZGV4XSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgIGZvciAodmFyIHAgaW4gbWF0Y2hzZXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwID0gc2VsZi5fbWFrZUFicyhwKVxuICAgICAgICAgIHZhciByZWFsID0gcnAucmVhbHBhdGhTeW5jKHAsIHNlbGYucmVhbHBhdGhDYWNoZSlcbiAgICAgICAgICBzZXRbcmVhbF0gPSB0cnVlXG4gICAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgaWYgKGVyLnN5c2NhbGwgPT09ICdzdGF0JylcbiAgICAgICAgICAgIHNldFtzZWxmLl9tYWtlQWJzKHApXSA9IHRydWVcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBlclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuICBjb21tb24uZmluaXNoKHRoaXMpXG59XG5cblxuR2xvYlN5bmMucHJvdG90eXBlLl9wcm9jZXNzID0gZnVuY3Rpb24gKHBhdHRlcm4sIGluZGV4LCBpbkdsb2JTdGFyKSB7XG4gIGFzc2VydC5vayh0aGlzIGluc3RhbmNlb2YgR2xvYlN5bmMpXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBbbl0gcGFydHMgb2YgcGF0dGVybiB0aGF0IGFyZSBhbGwgc3RyaW5ncy5cbiAgdmFyIG4gPSAwXG4gIHdoaWxlICh0eXBlb2YgcGF0dGVybltuXSA9PT0gJ3N0cmluZycpIHtcbiAgICBuICsrXG4gIH1cbiAgLy8gbm93IG4gaXMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBvbmUgdGhhdCBpcyAqbm90KiBhIHN0cmluZy5cblxuICAvLyBTZWUgaWYgdGhlcmUncyBhbnl0aGluZyBlbHNlXG4gIHZhciBwcmVmaXhcbiAgc3dpdGNoIChuKSB7XG4gICAgLy8gaWYgbm90LCB0aGVuIHRoaXMgaXMgcmF0aGVyIHNpbXBsZVxuICAgIGNhc2UgcGF0dGVybi5sZW5ndGg6XG4gICAgICB0aGlzLl9wcm9jZXNzU2ltcGxlKHBhdHRlcm4uam9pbignLycpLCBpbmRleClcbiAgICAgIHJldHVyblxuXG4gICAgY2FzZSAwOlxuICAgICAgLy8gcGF0dGVybiAqc3RhcnRzKiB3aXRoIHNvbWUgbm9uLXRyaXZpYWwgaXRlbS5cbiAgICAgIC8vIGdvaW5nIHRvIHJlYWRkaXIoY3dkKSwgYnV0IG5vdCBpbmNsdWRlIHRoZSBwcmVmaXggaW4gbWF0Y2hlcy5cbiAgICAgIHByZWZpeCA9IG51bGxcbiAgICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gcGF0dGVybiBoYXMgc29tZSBzdHJpbmcgYml0cyBpbiB0aGUgZnJvbnQuXG4gICAgICAvLyB3aGF0ZXZlciBpdCBzdGFydHMgd2l0aCwgd2hldGhlciB0aGF0J3MgJ2Fic29sdXRlJyBsaWtlIC9mb28vYmFyLFxuICAgICAgLy8gb3IgJ3JlbGF0aXZlJyBsaWtlICcuLi9iYXonXG4gICAgICBwcmVmaXggPSBwYXR0ZXJuLnNsaWNlKDAsIG4pLmpvaW4oJy8nKVxuICAgICAgYnJlYWtcbiAgfVxuXG4gIHZhciByZW1haW4gPSBwYXR0ZXJuLnNsaWNlKG4pXG5cbiAgLy8gZ2V0IHRoZSBsaXN0IG9mIGVudHJpZXMuXG4gIHZhciByZWFkXG4gIGlmIChwcmVmaXggPT09IG51bGwpXG4gICAgcmVhZCA9ICcuJ1xuICBlbHNlIGlmIChpc0Fic29sdXRlKHByZWZpeCkgfHxcbiAgICAgIGlzQWJzb2x1dGUocGF0dGVybi5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwID09PSAnc3RyaW5nJyA/IHAgOiAnWypdJ1xuICAgICAgfSkuam9pbignLycpKSkge1xuICAgIGlmICghcHJlZml4IHx8ICFpc0Fic29sdXRlKHByZWZpeCkpXG4gICAgICBwcmVmaXggPSAnLycgKyBwcmVmaXhcbiAgICByZWFkID0gcHJlZml4XG4gIH0gZWxzZVxuICAgIHJlYWQgPSBwcmVmaXhcblxuICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhyZWFkKVxuXG4gIC8vaWYgaWdub3JlZCwgc2tpcCBwcm9jZXNzaW5nXG4gIGlmIChjaGlsZHJlbklnbm9yZWQodGhpcywgcmVhZCkpXG4gICAgcmV0dXJuXG5cbiAgdmFyIGlzR2xvYlN0YXIgPSByZW1haW5bMF0gPT09IG1pbmltYXRjaC5HTE9CU1RBUlxuICBpZiAoaXNHbG9iU3RhcilcbiAgICB0aGlzLl9wcm9jZXNzR2xvYlN0YXIocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIpXG4gIGVsc2VcbiAgICB0aGlzLl9wcm9jZXNzUmVhZGRpcihwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3Rhcilcbn1cblxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3Byb2Nlc3NSZWFkZGlyID0gZnVuY3Rpb24gKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyKSB7XG4gIHZhciBlbnRyaWVzID0gdGhpcy5fcmVhZGRpcihhYnMsIGluR2xvYlN0YXIpXG5cbiAgLy8gaWYgdGhlIGFicyBpc24ndCBhIGRpciwgdGhlbiBub3RoaW5nIGNhbiBtYXRjaCFcbiAgaWYgKCFlbnRyaWVzKVxuICAgIHJldHVyblxuXG4gIC8vIEl0IHdpbGwgb25seSBtYXRjaCBkb3QgZW50cmllcyBpZiBpdCBzdGFydHMgd2l0aCBhIGRvdCwgb3IgaWZcbiAgLy8gZG90IGlzIHNldC4gIFN0dWZmIGxpa2UgQCguZm9vfC5iYXIpIGlzbid0IGFsbG93ZWQuXG4gIHZhciBwbiA9IHJlbWFpblswXVxuICB2YXIgbmVnYXRlID0gISF0aGlzLm1pbmltYXRjaC5uZWdhdGVcbiAgdmFyIHJhd0dsb2IgPSBwbi5fZ2xvYlxuICB2YXIgZG90T2sgPSB0aGlzLmRvdCB8fCByYXdHbG9iLmNoYXJBdCgwKSA9PT0gJy4nXG5cbiAgdmFyIG1hdGNoZWRFbnRyaWVzID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGUgPSBlbnRyaWVzW2ldXG4gICAgaWYgKGUuY2hhckF0KDApICE9PSAnLicgfHwgZG90T2spIHtcbiAgICAgIHZhciBtXG4gICAgICBpZiAobmVnYXRlICYmICFwcmVmaXgpIHtcbiAgICAgICAgbSA9ICFlLm1hdGNoKHBuKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbSA9IGUubWF0Y2gocG4pXG4gICAgICB9XG4gICAgICBpZiAobSlcbiAgICAgICAgbWF0Y2hlZEVudHJpZXMucHVzaChlKVxuICAgIH1cbiAgfVxuXG4gIHZhciBsZW4gPSBtYXRjaGVkRW50cmllcy5sZW5ndGhcbiAgLy8gSWYgdGhlcmUgYXJlIG5vIG1hdGNoZWQgZW50cmllcywgdGhlbiBub3RoaW5nIG1hdGNoZXMuXG4gIGlmIChsZW4gPT09IDApXG4gICAgcmV0dXJuXG5cbiAgLy8gaWYgdGhpcyBpcyB0aGUgbGFzdCByZW1haW5pbmcgcGF0dGVybiBiaXQsIHRoZW4gbm8gbmVlZCBmb3JcbiAgLy8gYW4gYWRkaXRpb25hbCBzdGF0ICp1bmxlc3MqIHRoZSB1c2VyIGhhcyBzcGVjaWZpZWQgbWFyayBvclxuICAvLyBzdGF0IGV4cGxpY2l0bHkuICBXZSBrbm93IHRoZXkgZXhpc3QsIHNpbmNlIHJlYWRkaXIgcmV0dXJuZWRcbiAgLy8gdGhlbS5cblxuICBpZiAocmVtYWluLmxlbmd0aCA9PT0gMSAmJiAhdGhpcy5tYXJrICYmICF0aGlzLnN0YXQpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2hlc1tpbmRleF0pXG4gICAgICB0aGlzLm1hdGNoZXNbaW5kZXhdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKyspIHtcbiAgICAgIHZhciBlID0gbWF0Y2hlZEVudHJpZXNbaV1cbiAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgaWYgKHByZWZpeC5zbGljZSgtMSkgIT09ICcvJylcbiAgICAgICAgICBlID0gcHJlZml4ICsgJy8nICsgZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZSA9IHByZWZpeCArIGVcbiAgICAgIH1cblxuICAgICAgaWYgKGUuY2hhckF0KDApID09PSAnLycgJiYgIXRoaXMubm9tb3VudCkge1xuICAgICAgICBlID0gcGF0aC5qb2luKHRoaXMucm9vdCwgZSlcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VtaXRNYXRjaChpbmRleCwgZSlcbiAgICB9XG4gICAgLy8gVGhpcyB3YXMgdGhlIGxhc3Qgb25lLCBhbmQgbm8gc3RhdHMgd2VyZSBuZWVkZWRcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIG5vdyB0ZXN0IGFsbCBtYXRjaGVkIGVudHJpZXMgYXMgc3RhbmQtaW5zIGZvciB0aGF0IHBhcnRcbiAgLy8gb2YgdGhlIHBhdHRlcm4uXG4gIHJlbWFpbi5zaGlmdCgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICsrKSB7XG4gICAgdmFyIGUgPSBtYXRjaGVkRW50cmllc1tpXVxuICAgIHZhciBuZXdQYXR0ZXJuXG4gICAgaWYgKHByZWZpeClcbiAgICAgIG5ld1BhdHRlcm4gPSBbcHJlZml4LCBlXVxuICAgIGVsc2VcbiAgICAgIG5ld1BhdHRlcm4gPSBbZV1cbiAgICB0aGlzLl9wcm9jZXNzKG5ld1BhdHRlcm4uY29uY2F0KHJlbWFpbiksIGluZGV4LCBpbkdsb2JTdGFyKVxuICB9XG59XG5cblxuR2xvYlN5bmMucHJvdG90eXBlLl9lbWl0TWF0Y2ggPSBmdW5jdGlvbiAoaW5kZXgsIGUpIHtcbiAgaWYgKGlzSWdub3JlZCh0aGlzLCBlKSlcbiAgICByZXR1cm5cblxuICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhlKVxuXG4gIGlmICh0aGlzLm1hcmspXG4gICAgZSA9IHRoaXMuX21hcmsoZSlcblxuICBpZiAodGhpcy5hYnNvbHV0ZSkge1xuICAgIGUgPSBhYnNcbiAgfVxuXG4gIGlmICh0aGlzLm1hdGNoZXNbaW5kZXhdW2VdKVxuICAgIHJldHVyblxuXG4gIGlmICh0aGlzLm5vZGlyKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNhY2hlW2Fic11cbiAgICBpZiAoYyA9PT0gJ0RJUicgfHwgQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy5tYXRjaGVzW2luZGV4XVtlXSA9IHRydWVcblxuICBpZiAodGhpcy5zdGF0KVxuICAgIHRoaXMuX3N0YXQoZSlcbn1cblxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3JlYWRkaXJJbkdsb2JTdGFyID0gZnVuY3Rpb24gKGFicykge1xuICAvLyBmb2xsb3cgYWxsIHN5bWxpbmtlZCBkaXJlY3RvcmllcyBmb3JldmVyXG4gIC8vIGp1c3QgcHJvY2VlZCBhcyBpZiB0aGlzIGlzIGEgbm9uLWdsb2JzdGFyIHNpdHVhdGlvblxuICBpZiAodGhpcy5mb2xsb3cpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRkaXIoYWJzLCBmYWxzZSlcblxuICB2YXIgZW50cmllc1xuICB2YXIgbHN0YXRcbiAgdmFyIHN0YXRcbiAgdHJ5IHtcbiAgICBsc3RhdCA9IHRoaXMuZnMubHN0YXRTeW5jKGFicylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIC8vIGxzdGF0IGZhaWxlZCwgZG9lc24ndCBleGlzdFxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICB2YXIgaXNTeW0gPSBsc3RhdCAmJiBsc3RhdC5pc1N5bWJvbGljTGluaygpXG4gIHRoaXMuc3ltbGlua3NbYWJzXSA9IGlzU3ltXG5cbiAgLy8gSWYgaXQncyBub3QgYSBzeW1saW5rIG9yIGEgZGlyLCB0aGVuIGl0J3MgZGVmaW5pdGVseSBhIHJlZ3VsYXIgZmlsZS5cbiAgLy8gZG9uJ3QgYm90aGVyIGRvaW5nIGEgcmVhZGRpciBpbiB0aGF0IGNhc2UuXG4gIGlmICghaXNTeW0gJiYgbHN0YXQgJiYgIWxzdGF0LmlzRGlyZWN0b3J5KCkpXG4gICAgdGhpcy5jYWNoZVthYnNdID0gJ0ZJTEUnXG4gIGVsc2VcbiAgICBlbnRyaWVzID0gdGhpcy5fcmVhZGRpcihhYnMsIGZhbHNlKVxuXG4gIHJldHVybiBlbnRyaWVzXG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fcmVhZGRpciA9IGZ1bmN0aW9uIChhYnMsIGluR2xvYlN0YXIpIHtcbiAgdmFyIGVudHJpZXNcblxuICBpZiAoaW5HbG9iU3RhciAmJiAhb3duUHJvcCh0aGlzLnN5bWxpbmtzLCBhYnMpKVxuICAgIHJldHVybiB0aGlzLl9yZWFkZGlySW5HbG9iU3RhcihhYnMpXG5cbiAgaWYgKG93blByb3AodGhpcy5jYWNoZSwgYWJzKSkge1xuICAgIHZhciBjID0gdGhpcy5jYWNoZVthYnNdXG4gICAgaWYgKCFjIHx8IGMgPT09ICdGSUxFJylcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIHJldHVybiBjXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkZGlyRW50cmllcyhhYnMsIHRoaXMuZnMucmVhZGRpclN5bmMoYWJzKSlcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICB0aGlzLl9yZWFkZGlyRXJyb3IoYWJzLCBlcilcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fcmVhZGRpckVudHJpZXMgPSBmdW5jdGlvbiAoYWJzLCBlbnRyaWVzKSB7XG4gIC8vIGlmIHdlIGhhdmVuJ3QgYXNrZWQgdG8gc3RhdCBldmVyeXRoaW5nLCB0aGVuIGp1c3RcbiAgLy8gYXNzdW1lIHRoYXQgZXZlcnl0aGluZyBpbiB0aGVyZSBleGlzdHMsIHNvIHdlIGNhbiBhdm9pZFxuICAvLyBoYXZpbmcgdG8gc3RhdCBpdCBhIHNlY29uZCB0aW1lLlxuICBpZiAoIXRoaXMubWFyayAmJiAhdGhpcy5zdGF0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSArKykge1xuICAgICAgdmFyIGUgPSBlbnRyaWVzW2ldXG4gICAgICBpZiAoYWJzID09PSAnLycpXG4gICAgICAgIGUgPSBhYnMgKyBlXG4gICAgICBlbHNlXG4gICAgICAgIGUgPSBhYnMgKyAnLycgKyBlXG4gICAgICB0aGlzLmNhY2hlW2VdID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuY2FjaGVbYWJzXSA9IGVudHJpZXNcblxuICAvLyBtYXJrIGFuZCBjYWNoZSBkaXItbmVzc1xuICByZXR1cm4gZW50cmllc1xufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3JlYWRkaXJFcnJvciA9IGZ1bmN0aW9uIChmLCBlcikge1xuICAvLyBoYW5kbGUgZXJyb3JzLCBhbmQgY2FjaGUgdGhlIGluZm9ybWF0aW9uXG4gIHN3aXRjaCAoZXIuY29kZSkge1xuICAgIGNhc2UgJ0VOT1RTVVAnOiAvLyBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtZ2xvYi9pc3N1ZXMvMjA1XG4gICAgY2FzZSAnRU5PVERJUic6IC8vIHRvdGFsbHkgbm9ybWFsLiBtZWFucyBpdCAqZG9lcyogZXhpc3QuXG4gICAgICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhmKVxuICAgICAgdGhpcy5jYWNoZVthYnNdID0gJ0ZJTEUnXG4gICAgICBpZiAoYWJzID09PSB0aGlzLmN3ZEFicykge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoZXIuY29kZSArICcgaW52YWxpZCBjd2QgJyArIHRoaXMuY3dkKVxuICAgICAgICBlcnJvci5wYXRoID0gdGhpcy5jd2RcbiAgICAgICAgZXJyb3IuY29kZSA9IGVyLmNvZGVcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdFTk9FTlQnOiAvLyBub3QgdGVycmlibHkgdW51c3VhbFxuICAgIGNhc2UgJ0VMT09QJzpcbiAgICBjYXNlICdFTkFNRVRPT0xPTkcnOlxuICAgIGNhc2UgJ1VOS05PV04nOlxuICAgICAgdGhpcy5jYWNoZVt0aGlzLl9tYWtlQWJzKGYpXSA9IGZhbHNlXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDogLy8gc29tZSB1bnVzdWFsIGVycm9yLiAgVHJlYXQgYXMgZmFpbHVyZS5cbiAgICAgIHRoaXMuY2FjaGVbdGhpcy5fbWFrZUFicyhmKV0gPSBmYWxzZVxuICAgICAgaWYgKHRoaXMuc3RyaWN0KVxuICAgICAgICB0aHJvdyBlclxuICAgICAgaWYgKCF0aGlzLnNpbGVudClcbiAgICAgICAgY29uc29sZS5lcnJvcignZ2xvYiBlcnJvcicsIGVyKVxuICAgICAgYnJlYWtcbiAgfVxufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3Byb2Nlc3NHbG9iU3RhciA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3Rhcikge1xuXG4gIHZhciBlbnRyaWVzID0gdGhpcy5fcmVhZGRpcihhYnMsIGluR2xvYlN0YXIpXG5cbiAgLy8gbm8gZW50cmllcyBtZWFucyBub3QgYSBkaXIsIHNvIGl0IGNhbiBuZXZlciBoYXZlIG1hdGNoZXNcbiAgLy8gZm9vLnR4dC8qKiBkb2Vzbid0IG1hdGNoIGZvby50eHRcbiAgaWYgKCFlbnRyaWVzKVxuICAgIHJldHVyblxuXG4gIC8vIHRlc3Qgd2l0aG91dCB0aGUgZ2xvYnN0YXIsIGFuZCB3aXRoIGV2ZXJ5IGNoaWxkIGJvdGggYmVsb3dcbiAgLy8gYW5kIHJlcGxhY2luZyB0aGUgZ2xvYnN0YXIuXG4gIHZhciByZW1haW5XaXRob3V0R2xvYlN0YXIgPSByZW1haW4uc2xpY2UoMSlcbiAgdmFyIGdzcHJlZiA9IHByZWZpeCA/IFsgcHJlZml4IF0gOiBbXVxuICB2YXIgbm9HbG9iU3RhciA9IGdzcHJlZi5jb25jYXQocmVtYWluV2l0aG91dEdsb2JTdGFyKVxuXG4gIC8vIHRoZSBub0dsb2JTdGFyIHBhdHRlcm4gZXhpdHMgdGhlIGluR2xvYlN0YXIgc3RhdGVcbiAgdGhpcy5fcHJvY2Vzcyhub0dsb2JTdGFyLCBpbmRleCwgZmFsc2UpXG5cbiAgdmFyIGxlbiA9IGVudHJpZXMubGVuZ3RoXG4gIHZhciBpc1N5bSA9IHRoaXMuc3ltbGlua3NbYWJzXVxuXG4gIC8vIElmIGl0J3MgYSBzeW1saW5rLCBhbmQgd2UncmUgaW4gYSBnbG9ic3RhciwgdGhlbiBzdG9wXG4gIGlmIChpc1N5bSAmJiBpbkdsb2JTdGFyKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZSA9IGVudHJpZXNbaV1cbiAgICBpZiAoZS5jaGFyQXQoMCkgPT09ICcuJyAmJiAhdGhpcy5kb3QpXG4gICAgICBjb250aW51ZVxuXG4gICAgLy8gdGhlc2UgdHdvIGNhc2VzIGVudGVyIHRoZSBpbkdsb2JTdGFyIHN0YXRlXG4gICAgdmFyIGluc3RlYWQgPSBnc3ByZWYuY29uY2F0KGVudHJpZXNbaV0sIHJlbWFpbldpdGhvdXRHbG9iU3RhcilcbiAgICB0aGlzLl9wcm9jZXNzKGluc3RlYWQsIGluZGV4LCB0cnVlKVxuXG4gICAgdmFyIGJlbG93ID0gZ3NwcmVmLmNvbmNhdChlbnRyaWVzW2ldLCByZW1haW4pXG4gICAgdGhpcy5fcHJvY2VzcyhiZWxvdywgaW5kZXgsIHRydWUpXG4gIH1cbn1cblxuR2xvYlN5bmMucHJvdG90eXBlLl9wcm9jZXNzU2ltcGxlID0gZnVuY3Rpb24gKHByZWZpeCwgaW5kZXgpIHtcbiAgLy8gWFhYIHJldmlldyB0aGlzLiAgU2hvdWxkbid0IGl0IGJlIGRvaW5nIHRoZSBtb3VudGluZyBldGNcbiAgLy8gYmVmb3JlIGRvaW5nIHN0YXQ/ICBraW5kYSB3ZWlyZD9cbiAgdmFyIGV4aXN0cyA9IHRoaXMuX3N0YXQocHJlZml4KVxuXG4gIGlmICghdGhpcy5tYXRjaGVzW2luZGV4XSlcbiAgICB0aGlzLm1hdGNoZXNbaW5kZXhdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIC8vIElmIGl0IGRvZXNuJ3QgZXhpc3QsIHRoZW4ganVzdCBtYXJrIHRoZSBsYWNrIG9mIHJlc3VsdHNcbiAgaWYgKCFleGlzdHMpXG4gICAgcmV0dXJuXG5cbiAgaWYgKHByZWZpeCAmJiBpc0Fic29sdXRlKHByZWZpeCkgJiYgIXRoaXMubm9tb3VudCkge1xuICAgIHZhciB0cmFpbCA9IC9bXFwvXFxcXF0kLy50ZXN0KHByZWZpeClcbiAgICBpZiAocHJlZml4LmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICBwcmVmaXggPSBwYXRoLmpvaW4odGhpcy5yb290LCBwcmVmaXgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeCA9IHBhdGgucmVzb2x2ZSh0aGlzLnJvb3QsIHByZWZpeClcbiAgICAgIGlmICh0cmFpbClcbiAgICAgICAgcHJlZml4ICs9ICcvJ1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKVxuICAgIHByZWZpeCA9IHByZWZpeC5yZXBsYWNlKC9cXFxcL2csICcvJylcblxuICAvLyBNYXJrIHRoaXMgYXMgYSBtYXRjaFxuICB0aGlzLl9lbWl0TWF0Y2goaW5kZXgsIHByZWZpeClcbn1cblxuLy8gUmV0dXJucyBlaXRoZXIgJ0RJUicsICdGSUxFJywgb3IgZmFsc2Vcbkdsb2JTeW5jLnByb3RvdHlwZS5fc3RhdCA9IGZ1bmN0aW9uIChmKSB7XG4gIHZhciBhYnMgPSB0aGlzLl9tYWtlQWJzKGYpXG4gIHZhciBuZWVkRGlyID0gZi5zbGljZSgtMSkgPT09ICcvJ1xuXG4gIGlmIChmLmxlbmd0aCA+IHRoaXMubWF4TGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIGlmICghdGhpcy5zdGF0ICYmIG93blByb3AodGhpcy5jYWNoZSwgYWJzKSkge1xuICAgIHZhciBjID0gdGhpcy5jYWNoZVthYnNdXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIGMgPSAnRElSJ1xuXG4gICAgLy8gSXQgZXhpc3RzLCBidXQgbWF5YmUgbm90IGhvdyB3ZSBuZWVkIGl0XG4gICAgaWYgKCFuZWVkRGlyIHx8IGMgPT09ICdESVInKVxuICAgICAgcmV0dXJuIGNcblxuICAgIGlmIChuZWVkRGlyICYmIGMgPT09ICdGSUxFJylcbiAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgLy8gb3RoZXJ3aXNlIHdlIGhhdmUgdG8gc3RhdCwgYmVjYXVzZSBtYXliZSBjPXRydWVcbiAgICAvLyBpZiB3ZSBrbm93IGl0IGV4aXN0cywgYnV0IG5vdCB3aGF0IGl0IGlzLlxuICB9XG5cbiAgdmFyIGV4aXN0c1xuICB2YXIgc3RhdCA9IHRoaXMuc3RhdENhY2hlW2Fic11cbiAgaWYgKCFzdGF0KSB7XG4gICAgdmFyIGxzdGF0XG4gICAgdHJ5IHtcbiAgICAgIGxzdGF0ID0gdGhpcy5mcy5sc3RhdFN5bmMoYWJzKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICBpZiAoZXIgJiYgKGVyLmNvZGUgPT09ICdFTk9FTlQnIHx8IGVyLmNvZGUgPT09ICdFTk9URElSJykpIHtcbiAgICAgICAgdGhpcy5zdGF0Q2FjaGVbYWJzXSA9IGZhbHNlXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsc3RhdCAmJiBsc3RhdC5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGF0ID0gdGhpcy5mcy5zdGF0U3luYyhhYnMpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBzdGF0ID0gbHN0YXRcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdCA9IGxzdGF0XG4gICAgfVxuICB9XG5cbiAgdGhpcy5zdGF0Q2FjaGVbYWJzXSA9IHN0YXRcblxuICB2YXIgYyA9IHRydWVcbiAgaWYgKHN0YXQpXG4gICAgYyA9IHN0YXQuaXNEaXJlY3RvcnkoKSA/ICdESVInIDogJ0ZJTEUnXG5cbiAgdGhpcy5jYWNoZVthYnNdID0gdGhpcy5jYWNoZVthYnNdIHx8IGNcblxuICBpZiAobmVlZERpciAmJiBjID09PSAnRklMRScpXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgcmV0dXJuIGNcbn1cblxuR2xvYlN5bmMucHJvdG90eXBlLl9tYXJrID0gZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIGNvbW1vbi5tYXJrKHRoaXMsIHApXG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fbWFrZUFicyA9IGZ1bmN0aW9uIChmKSB7XG4gIHJldHVybiBjb21tb24ubWFrZUFicyh0aGlzLCBmKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/glob/sync.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/minimatch/lib/path.js":
/*!***************************************************************!*\
  !*** ./node_modules/mocha/node_modules/minimatch/lib/path.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("const isWindows = typeof process === 'object' &&\n  process &&\n  process.platform === 'win32'\nmodule.exports = isWindows ? { sep: '\\\\' } : { sep: '/' }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL21pbmltYXRjaC9saWIvcGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWSxJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2xpYi9wYXRoLmpzPzg1MGEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgaXNXaW5kb3dzID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmXG4gIHByb2Nlc3MgJiZcbiAgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJ1xubW9kdWxlLmV4cG9ydHMgPSBpc1dpbmRvd3MgPyB7IHNlcDogJ1xcXFwnIH0gOiB7IHNlcDogJy8nIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/minimatch/lib/path.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/minimatch/minimatch.js":
/*!****************************************************************!*\
  !*** ./node_modules/mocha/node_modules/minimatch/minimatch.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const minimatch = module.exports = (p, pattern, options = {}) => {\n  assertValidPattern(pattern)\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nmodule.exports = minimatch\n\nconst path = __webpack_require__(/*! ./lib/path.js */ \"(ssr)/./node_modules/mocha/node_modules/minimatch/lib/path.js\")\nminimatch.sep = path.sep\n\nconst GLOBSTAR = Symbol('globstar **')\nminimatch.GLOBSTAR = GLOBSTAR\nconst expand = __webpack_require__(/*! brace-expansion */ \"(ssr)/./node_modules/mocha/node_modules/brace-expansion/index.js\")\n\nconst plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// \"abc\" -> { a:true, b:true, c:true }\nconst charSet = s => s.split('').reduce((set, c) => {\n  set[c] = true\n  return set\n}, {})\n\n// characters that need to be escaped in RegExp.\nconst reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// characters that indicate we have to add the pattern start\nconst addPatternStartSet = charSet('[.(')\n\n// normalizes slashes.\nconst slashSplit = /\\/+/\n\nminimatch.filter = (pattern, options = {}) =>\n  (p, i, list) => minimatch(p, pattern, options)\n\nconst ext = (a, b = {}) => {\n  const t = {}\n  Object.keys(a).forEach(k => t[k] = a[k])\n  Object.keys(b).forEach(k => t[k] = b[k])\n  return t\n}\n\nminimatch.defaults = def => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  const orig = minimatch\n\n  const m = (p, pattern, options) => orig(p, pattern, ext(def, options))\n  m.Minimatch = class Minimatch extends orig.Minimatch {\n    constructor (pattern, options) {\n      super(pattern, ext(def, options))\n    }\n  }\n  m.Minimatch.defaults = options => orig.defaults(ext(def, options)).Minimatch\n  m.filter = (pattern, options) => orig.filter(pattern, ext(def, options))\n  m.defaults = options => orig.defaults(ext(def, options))\n  m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options))\n  m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options))\n  m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options))\n\n  return m\n}\n\n\n\n\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = (pattern, options) => braceExpand(pattern, options)\n\nconst braceExpand = (pattern, options = {}) => {\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\nconst MAX_PATTERN_LENGTH = 1024 * 64\nconst assertValidPattern = pattern => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst SUBPARSE = Symbol('subparse')\n\nminimatch.makeRe = (pattern, options) =>\n  new Minimatch(pattern, options || {}).makeRe()\n\nminimatch.match = (list, pattern, options = {}) => {\n  const mm = new Minimatch(pattern, options)\n  list = list.filter(f => mm.match(f))\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\n// replace stuff like \\* with *\nconst globUnescape = s => s.replace(/\\\\(.)/g, '$1')\nconst charUnescape = s => s.replace(/\\\\([^-\\]])/g, '$1')\nconst regExpEscape = s => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\nconst braExpEscape = s => s.replace(/[[\\]\\\\]/g, '\\\\$&')\n\nclass Minimatch {\n  constructor (pattern, options) {\n    assertValidPattern(pattern)\n\n    if (!options) options = {}\n\n    this.options = options\n    this.set = []\n    this.pattern = pattern\n    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape ||\n      options.allowWindowsEscape === false\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/')\n    }\n    this.regexp = null\n    this.negate = false\n    this.comment = false\n    this.empty = false\n    this.partial = !!options.partial\n\n    // make the set of regexps etc.\n    this.make()\n  }\n\n  debug () {}\n\n  make () {\n    const pattern = this.pattern\n    const options = this.options\n\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true\n      return\n    }\n    if (!pattern) {\n      this.empty = true\n      return\n    }\n\n    // step 1: figure out negation, etc.\n    this.parseNegate()\n\n    // step 2: expand braces\n    let set = this.globSet = this.braceExpand()\n\n    if (options.debug) this.debug = (...args) => console.error(...args)\n\n    this.debug(this.pattern, set)\n\n    // step 3: now we have a set, so turn each one into a series of path-portion\n    // matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    set = this.globParts = set.map(s => s.split(slashSplit))\n\n    this.debug(this.pattern, set)\n\n    // glob --> regexps\n    set = set.map((s, si, set) => s.map(this.parse, this))\n\n    this.debug(this.pattern, set)\n\n    // filter out everything that didn't compile properly.\n    set = set.filter(s => s.indexOf(false) === -1)\n\n    this.debug(this.pattern, set)\n\n    this.set = set\n  }\n\n  parseNegate () {\n    if (this.options.nonegate) return\n\n    const pattern = this.pattern\n    let negate = false\n    let negateOffset = 0\n\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate\n      negateOffset++\n    }\n\n    if (negateOffset) this.pattern = pattern.slice(negateOffset)\n    this.negate = negate\n  }\n\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne (file, pattern, partial) {\n    var options = this.options\n\n    this.debug('matchOne',\n      { 'this': this, file: file, pattern: pattern })\n\n    this.debug('matchOne', file.length, pattern.length)\n\n    for (var fi = 0,\n        pi = 0,\n        fl = file.length,\n        pl = pattern.length\n        ; (fi < fl) && (pi < pl)\n        ; fi++, pi++) {\n      this.debug('matchOne loop')\n      var p = pattern[pi]\n      var f = file[fi]\n\n      this.debug(pattern, p, f)\n\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* istanbul ignore if */\n      if (p === false) return false\n\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f])\n\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi\n        var pr = pi + 1\n        if (pr === pl) {\n          this.debug('** at the end')\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (file[fi] === '.' || file[fi] === '..' ||\n              (!options.dot && file[fi].charAt(0) === '.')) return false\n          }\n          return true\n        }\n\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr]\n\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee)\n            // found a match.\n            return true\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (swallowee === '.' || swallowee === '..' ||\n              (!options.dot && swallowee.charAt(0) === '.')) {\n              this.debug('dot detected!', file, fr, pattern, pr)\n              break\n            }\n\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue')\n            fr++\n          }\n        }\n\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        // If there's more *pattern* left, then\n        /* istanbul ignore if */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n          if (fr === fl) return true\n        }\n        return false\n      }\n\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      var hit\n      if (typeof p === 'string') {\n        hit = f === p\n        this.debug('string match', p, f, hit)\n      } else {\n        hit = f.match(p)\n        this.debug('pattern match', p, f, hit)\n      }\n\n      if (!hit) return false\n    }\n\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial\n    } else /* istanbul ignore else */ if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return (fi === fl - 1) && (file[fi] === '')\n    }\n\n    // should be unreachable.\n    /* istanbul ignore next */\n    throw new Error('wtf?')\n  }\n\n  braceExpand () {\n    return braceExpand(this.pattern, this.options)\n  }\n\n  parse (pattern, isSub) {\n    assertValidPattern(pattern)\n\n    const options = this.options\n\n    // shortcuts\n    if (pattern === '**') {\n      if (!options.noglobstar)\n        return GLOBSTAR\n      else\n        pattern = '*'\n    }\n    if (pattern === '') return ''\n\n    let re = ''\n    let hasMagic = false\n    let escaping = false\n    // ? => one single character\n    const patternListStack = []\n    const negativeLists = []\n    let stateChar\n    let inClass = false\n    let reClassStart = -1\n    let classStart = -1\n    let cs\n    let pl\n    let sp\n    // . and .. never match anything that doesn't start with .,\n    // even when options.dot is set.  However, if the pattern\n    // starts with ., then traversal patterns can match.\n    let dotTravAllowed = pattern.charAt(0) === '.'\n    let dotFileAllowed = options.dot || dotTravAllowed\n    const patternStart = () =>\n      dotTravAllowed\n        ? ''\n        : dotFileAllowed\n        ? '(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))'\n        : '(?!\\\\.)'\n    const subPatternStart = (p) =>\n      p.charAt(0) === '.'\n        ? ''\n        : options.dot\n        ? '(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))'\n        : '(?!\\\\.)'\n\n\n    const clearStateChar = () => {\n      if (stateChar) {\n        // we had some state-tracking character\n        // that wasn't consumed by this pass.\n        switch (stateChar) {\n          case '*':\n            re += star\n            hasMagic = true\n          break\n          case '?':\n            re += qmark\n            hasMagic = true\n          break\n          default:\n            re += '\\\\' + stateChar\n          break\n        }\n        this.debug('clearStateChar %j %j', stateChar, re)\n        stateChar = false\n      }\n    }\n\n    for (let i = 0, c; (i < pattern.length) && (c = pattern.charAt(i)); i++) {\n      this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n      // skip over any that are escaped.\n      if (escaping) {\n        /* istanbul ignore next - completely not allowed, even escaped. */\n        if (c === '/') {\n          return false\n        }\n\n        if (reSpecials[c]) {\n          re += '\\\\'\n        }\n        re += c\n        escaping = false\n        continue\n      }\n\n      switch (c) {\n        /* istanbul ignore next */\n        case '/': {\n          // Should already be path-split by now.\n          return false\n        }\n\n        case '\\\\':\n          if (inClass && pattern.charAt(i + 1) === '-') {\n            re += c\n            continue\n          }\n\n          clearStateChar()\n          escaping = true\n        continue\n\n        // the various stateChar values\n        // for the \"extglob\" stuff.\n        case '?':\n        case '*':\n        case '+':\n        case '@':\n        case '!':\n          this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n          // all of those are literals inside a class, except that\n          // the glob [!a] means [^a] in regexp\n          if (inClass) {\n            this.debug('  in class')\n            if (c === '!' && i === classStart + 1) c = '^'\n            re += c\n            continue\n          }\n\n          // if we already have a stateChar, then it means\n          // that there was something like ** or +? in there.\n          // Handle the stateChar, then proceed with this one.\n          this.debug('call clearStateChar %j', stateChar)\n          clearStateChar()\n          stateChar = c\n          // if extglob is disabled, then +(asdf|foo) isn't a thing.\n          // just clear the statechar *now*, rather than even diving into\n          // the patternList stuff.\n          if (options.noext) clearStateChar()\n        continue\n\n        case '(': {\n          if (inClass) {\n            re += '('\n            continue\n          }\n\n          if (!stateChar) {\n            re += '\\\\('\n            continue\n          }\n\n          const plEntry = {\n            type: stateChar,\n            start: i - 1,\n            reStart: re.length,\n            open: plTypes[stateChar].open,\n            close: plTypes[stateChar].close,\n          }\n          this.debug(this.pattern, '\\t', plEntry)\n          patternListStack.push(plEntry)\n          // negation is (?:(?!(?:js)(?:<rest>))[^/]*)\n          re += plEntry.open\n          // next entry starts with a dot maybe?\n          if (plEntry.start === 0 && plEntry.type !== '!') {\n            dotTravAllowed = true\n            re += subPatternStart(pattern.slice(i + 1))\n          }\n          this.debug('plType %j %j', stateChar, re)\n          stateChar = false\n          continue\n        }\n\n        case ')': {\n          const plEntry = patternListStack[patternListStack.length - 1]\n          if (inClass || !plEntry) {\n            re += '\\\\)'\n            continue\n          }\n          patternListStack.pop()\n\n          // closing an extglob\n          clearStateChar()\n          hasMagic = true\n          pl = plEntry\n          // negation is (?:(?!js)[^/]*)\n          // The others are (?:<pattern>)<type>\n          re += pl.close\n          if (pl.type === '!') {\n            negativeLists.push(Object.assign(pl, { reEnd: re.length }))\n          }\n          continue\n        }\n\n        case '|': {\n          const plEntry = patternListStack[patternListStack.length - 1]\n          if (inClass || !plEntry) {\n            re += '\\\\|'\n            continue\n          }\n\n          clearStateChar()\n          re += '|'\n          // next subpattern can start with a dot?\n          if (plEntry.start === 0 && plEntry.type !== '!') {\n            dotTravAllowed = true\n            re += subPatternStart(pattern.slice(i + 1))\n          }\n          continue\n        }\n\n        // these are mostly the same in regexp and glob\n        case '[':\n          // swallow any state-tracking char before the [\n          clearStateChar()\n\n          if (inClass) {\n            re += '\\\\' + c\n            continue\n          }\n\n          inClass = true\n          classStart = i\n          reClassStart = re.length\n          re += c\n        continue\n\n        case ']':\n          //  a right bracket shall lose its special\n          //  meaning and represent itself in\n          //  a bracket expression if it occurs\n          //  first in the list.  -- POSIX.2 2.8.3.2\n          if (i === classStart + 1 || !inClass) {\n            re += '\\\\' + c\n            continue\n          }\n\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + braExpEscape(charUnescape(cs)) + ']')\n            // looks good, finish up the class.\n            re += c\n          } catch (er) {\n            // out of order ranges in JS are errors, but in glob syntax,\n            // they're just a range that matches nothing.\n            re = re.substring(0, reClassStart) + '(?:$.)' // match nothing ever\n          }\n          hasMagic = true\n          inClass = false\n        continue\n\n        default:\n          // swallow any state char that wasn't consumed\n          clearStateChar()\n\n          if (reSpecials[c] && !(c === '^' && inClass)) {\n            re += '\\\\'\n          }\n\n          re += c\n          break\n\n      } // switch\n    } // for\n\n    // handle the case where we left a class open.\n    // \"[abc\" is valid, equivalent to \"\\[abc\"\n    if (inClass) {\n      // split where the last [ was, and escape it\n      // this is a huge pita.  We now have to re-walk\n      // the contents of the would-be class to re-translate\n      // any characters that were passed through as-is\n      cs = pattern.slice(classStart + 1)\n      sp = this.parse(cs, SUBPARSE)\n      re = re.substring(0, reClassStart) + '\\\\[' + sp[0]\n      hasMagic = hasMagic || sp[1]\n    }\n\n    // handle the case where we had a +( thing at the *end*\n    // of the pattern.\n    // each pattern list stack adds 3 chars, and we need to go through\n    // and escape any | chars that were passed through as-is for the regexp.\n    // Go through and escape them, taking care not to double-escape any\n    // | chars that were already escaped.\n    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n      let tail\n      tail = re.slice(pl.reStart + pl.open.length)\n      this.debug('setting tail', re, pl)\n      // maybe some even number of \\, then maybe 1 \\, followed by a |\n      tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, (_, $1, $2) => {\n        /* istanbul ignore else - should already be done */\n        if (!$2) {\n          // the | isn't already escaped, so escape it.\n          $2 = '\\\\'\n        }\n\n        // need to escape all those slashes *again*, without escaping the\n        // one that we need for escaping the | character.  As it works out,\n        // escaping an even number of slashes can be done by simply repeating\n        // it exactly after itself.  That's why this trick works.\n        //\n        // I am sorry that you have to see this.\n        return $1 + $1 + $2 + '|'\n      })\n\n      this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n      const t = pl.type === '*' ? star\n        : pl.type === '?' ? qmark\n        : '\\\\' + pl.type\n\n      hasMagic = true\n      re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n    }\n\n    // handle trailing things that only matter at the very end.\n    clearStateChar()\n    if (escaping) {\n      // trailing \\\\\n      re += '\\\\\\\\'\n    }\n\n    // only need to apply the nodot start if the re starts with\n    // something that could conceivably capture a dot\n    const addPatternStart = addPatternStartSet[re.charAt(0)]\n\n    // Hack to work around lack of negative lookbehind in JS\n    // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n    // like 'a.xyz.yz' doesn't match.  So, the first negative\n    // lookahead, has to look ALL the way ahead, to the end of\n    // the pattern.\n    for (let n = negativeLists.length - 1; n > -1; n--) {\n      const nl = negativeLists[n]\n\n      const nlBefore = re.slice(0, nl.reStart)\n      const nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n      let nlAfter = re.slice(nl.reEnd)\n      const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter\n\n      // Handle nested stuff like *(*.js|!(*.json)), where open parens\n      // mean that we should *not* include the ) in the bit that is considered\n      // \"after\" the negated section.\n      const closeParensBefore = nlBefore.split(')').length\n      const openParensBefore = nlBefore.split('(').length - closeParensBefore\n      let cleanAfter = nlAfter\n      for (let i = 0; i < openParensBefore; i++) {\n        cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n      }\n      nlAfter = cleanAfter\n\n      const dollar = nlAfter === '' && isSub !== SUBPARSE ? '(?:$|\\\\/)' : ''\n\n      re = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    }\n\n    // if the re is not \"\" at this point, then we need to make sure\n    // it doesn't match against an empty path part.\n    // Otherwise a/* will match a/, which it should not.\n    if (re !== '' && hasMagic) {\n      re = '(?=.)' + re\n    }\n\n    if (addPatternStart) {\n      re = patternStart() + re\n    }\n\n    // parsing just a piece of a larger pattern.\n    if (isSub === SUBPARSE) {\n      return [re, hasMagic]\n    }\n\n    // if it's nocase, and the lcase/uppercase don't match, it's magic\n    if (options.nocase && !hasMagic) {\n      hasMagic = pattern.toUpperCase() !== pattern.toLowerCase()\n    }\n\n    // skip the regexp for non-magical patterns\n    // unescape anything in it, though, so that it'll be\n    // an exact match against a file etc.\n    if (!hasMagic) {\n      return globUnescape(pattern)\n    }\n\n    const flags = options.nocase ? 'i' : ''\n    try {\n      return Object.assign(new RegExp('^' + re + '$', flags), {\n        _glob: pattern,\n        _src: re,\n      })\n    } catch (er) /* istanbul ignore next - should be impossible */ {\n      // If it was an invalid regular expression, then it can't match\n      // anything.  This trick looks for a character after the end of\n      // the string, which is of course impossible, except in multi-line\n      // mode, but it's not a /m regex.\n      return new RegExp('$.')\n    }\n  }\n\n  makeRe () {\n    if (this.regexp || this.regexp === false) return this.regexp\n\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set\n\n    if (!set.length) {\n      this.regexp = false\n      return this.regexp\n    }\n    const options = this.options\n\n    const twoStar = options.noglobstar ? star\n      : options.dot ? twoStarDot\n      : twoStarNoDot\n    const flags = options.nocase ? 'i' : ''\n\n    // coalesce globstars and regexpify non-globstar patterns\n    // if it's the only item, then we just do one twoStar\n    // if it's the first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if it's the last, append (\\/twoStar|) to previous\n    // if it's in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set.map(pattern => {\n      pattern = pattern.map(p =>\n        typeof p === 'string' ? regExpEscape(p)\n        : p === GLOBSTAR ? GLOBSTAR\n        : p._src\n      ).reduce((set, p) => {\n        if (!(set[set.length - 1] === GLOBSTAR && p === GLOBSTAR)) {\n          set.push(p)\n        }\n        return set\n      }, [])\n      pattern.forEach((p, i) => {\n        if (p !== GLOBSTAR || pattern[i-1] === GLOBSTAR) {\n          return\n        }\n        if (i === 0) {\n          if (pattern.length > 1) {\n            pattern[i+1] = '(?:\\\\\\/|' + twoStar + '\\\\\\/)?' + pattern[i+1]\n          } else {\n            pattern[i] = twoStar\n          }\n        } else if (i === pattern.length - 1) {\n          pattern[i-1] += '(?:\\\\\\/|' + twoStar + ')?'\n        } else {\n          pattern[i-1] += '(?:\\\\\\/|\\\\\\/' + twoStar + '\\\\\\/)' + pattern[i+1]\n          pattern[i+1] = GLOBSTAR\n        }\n      })\n      return pattern.filter(p => p !== GLOBSTAR).join('/')\n    }).join('|')\n\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^(?:' + re + ')$'\n\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').*$'\n\n    try {\n      this.regexp = new RegExp(re, flags)\n    } catch (ex) /* istanbul ignore next - should be impossible */ {\n      this.regexp = false\n    }\n    return this.regexp\n  }\n\n  match (f, partial = this.partial) {\n    this.debug('match', f, this.pattern)\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) return false\n    if (this.empty) return f === ''\n\n    if (f === '/' && partial) return true\n\n    const options = this.options\n\n    // windows: need to use /, not \\\n    if (path.sep !== '/') {\n      f = f.split(path.sep).join('/')\n    }\n\n    // treat the test path as a set of pathparts.\n    f = f.split(slashSplit)\n    this.debug(this.pattern, 'split', f)\n\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    const set = this.set\n    this.debug(this.pattern, 'set', set)\n\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename\n    for (let i = f.length - 1; i >= 0; i--) {\n      filename = f[i]\n      if (filename) break\n    }\n\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i]\n      let file = f\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename]\n      }\n      const hit = this.matchOne(file, pattern, partial)\n      if (hit) {\n        if (options.flipNegate) return true\n        return !this.negate\n      }\n    }\n\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) return false\n    return this.negate\n  }\n\n  static defaults (def) {\n    return minimatch.defaults(def).Minimatch\n  }\n}\n\nminimatch.Minimatch = Minimatch\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL21pbmltYXRjaC9taW5pbWF0Y2guanMiLCJtYXBwaW5ncyI6IkFBQUEsNERBQTREO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLG9GQUFlO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMseUZBQWlCOztBQUV4QztBQUNBLFNBQVMsc0NBQXNDO0FBQy9DLFNBQVMsMEJBQTBCO0FBQ25DLFNBQVMsMEJBQTBCO0FBQ25DLFNBQVMsMEJBQTBCO0FBQ25DLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsSUFBSTs7QUFFL0M7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7O0FBRUw7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7OztBQU1BO0FBQ0EsS0FBSyxJQUFJO0FBQ1QsS0FBSyxHQUFHO0FBQ1IsS0FBSyxLQUFLO0FBQ1YsS0FBSyxJQUFJLElBQUksRUFBRTtBQUNmLEtBQUssSUFBSSxFQUFFLElBQUk7QUFDZjtBQUNBO0FBQ0EsS0FBSyxJQUFJLE9BQU8sSUFBSTtBQUNwQixLQUFLLEVBQUUsT0FBTyxFQUFFO0FBQ2hCOztBQUVBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVEsTUFBTTtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQzs7QUFFdEMsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaURBQWlEO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLDRDQUE0Qzs7QUFFcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLElBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixJQUFJO0FBQy9COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGlEQUFpRDtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGtCQUFrQjtBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFFBQVE7QUFDUixNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsSUFBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxFQUFFLEVBQUUsS0FBSztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL21vY2hhL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvbWluaW1hdGNoLmpzPzg5YWQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgbWluaW1hdGNoID0gbW9kdWxlLmV4cG9ydHMgPSAocCwgcGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKVxuXG4gIC8vIHNob3J0Y3V0OiBjb21tZW50cyBtYXRjaCBub3RoaW5nLlxuICBpZiAoIW9wdGlvbnMubm9jb21tZW50ICYmIHBhdHRlcm4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpLm1hdGNoKHApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWluaW1hdGNoXG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCcuL2xpYi9wYXRoLmpzJylcbm1pbmltYXRjaC5zZXAgPSBwYXRoLnNlcFxuXG5jb25zdCBHTE9CU1RBUiA9IFN5bWJvbCgnZ2xvYnN0YXIgKionKVxubWluaW1hdGNoLkdMT0JTVEFSID0gR0xPQlNUQVJcbmNvbnN0IGV4cGFuZCA9IHJlcXVpcmUoJ2JyYWNlLWV4cGFuc2lvbicpXG5cbmNvbnN0IHBsVHlwZXMgPSB7XG4gICchJzogeyBvcGVuOiAnKD86KD8hKD86JywgY2xvc2U6ICcpKVteL10qPyknfSxcbiAgJz8nOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJyk/JyB9LFxuICAnKyc6IHsgb3BlbjogJyg/OicsIGNsb3NlOiAnKSsnIH0sXG4gICcqJzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpKicgfSxcbiAgJ0AnOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJyknIH1cbn1cblxuLy8gYW55IHNpbmdsZSB0aGluZyBvdGhlciB0aGFuIC9cbi8vIGRvbid0IG5lZWQgdG8gZXNjYXBlIC8gd2hlbiB1c2luZyBuZXcgUmVnRXhwKClcbmNvbnN0IHFtYXJrID0gJ1teL10nXG5cbi8vICogPT4gYW55IG51bWJlciBvZiBjaGFyYWN0ZXJzXG5jb25zdCBzdGFyID0gcW1hcmsgKyAnKj8nXG5cbi8vICoqIHdoZW4gZG90cyBhcmUgYWxsb3dlZC4gIEFueXRoaW5nIGdvZXMsIGV4Y2VwdCAuLiBhbmQgLlxuLy8gbm90ICheIG9yIC8gZm9sbG93ZWQgYnkgb25lIG9yIHR3byBkb3RzIGZvbGxvd2VkIGJ5ICQgb3IgLyksXG4vLyBmb2xsb3dlZCBieSBhbnl0aGluZywgYW55IG51bWJlciBvZiB0aW1lcy5cbmNvbnN0IHR3b1N0YXJEb3QgPSAnKD86KD8hKD86XFxcXFxcL3xeKSg/OlxcXFwuezEsMn0pKCR8XFxcXFxcLykpLikqPydcblxuLy8gbm90IGEgXiBvciAvIGZvbGxvd2VkIGJ5IGEgZG90LFxuLy8gZm9sbG93ZWQgYnkgYW55dGhpbmcsIGFueSBudW1iZXIgb2YgdGltZXMuXG5jb25zdCB0d29TdGFyTm9Eb3QgPSAnKD86KD8hKD86XFxcXFxcL3xeKVxcXFwuKS4pKj8nXG5cbi8vIFwiYWJjXCIgLT4geyBhOnRydWUsIGI6dHJ1ZSwgYzp0cnVlIH1cbmNvbnN0IGNoYXJTZXQgPSBzID0+IHMuc3BsaXQoJycpLnJlZHVjZSgoc2V0LCBjKSA9PiB7XG4gIHNldFtjXSA9IHRydWVcbiAgcmV0dXJuIHNldFxufSwge30pXG5cbi8vIGNoYXJhY3RlcnMgdGhhdCBuZWVkIHRvIGJlIGVzY2FwZWQgaW4gUmVnRXhwLlxuY29uc3QgcmVTcGVjaWFscyA9IGNoYXJTZXQoJygpLip7fSs/W11eJFxcXFwhJylcblxuLy8gY2hhcmFjdGVycyB0aGF0IGluZGljYXRlIHdlIGhhdmUgdG8gYWRkIHRoZSBwYXR0ZXJuIHN0YXJ0XG5jb25zdCBhZGRQYXR0ZXJuU3RhcnRTZXQgPSBjaGFyU2V0KCdbLignKVxuXG4vLyBub3JtYWxpemVzIHNsYXNoZXMuXG5jb25zdCBzbGFzaFNwbGl0ID0gL1xcLysvXG5cbm1pbmltYXRjaC5maWx0ZXIgPSAocGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PlxuICAocCwgaSwgbGlzdCkgPT4gbWluaW1hdGNoKHAsIHBhdHRlcm4sIG9wdGlvbnMpXG5cbmNvbnN0IGV4dCA9IChhLCBiID0ge30pID0+IHtcbiAgY29uc3QgdCA9IHt9XG4gIE9iamVjdC5rZXlzKGEpLmZvckVhY2goayA9PiB0W2tdID0gYVtrXSlcbiAgT2JqZWN0LmtleXMoYikuZm9yRWFjaChrID0+IHRba10gPSBiW2tdKVxuICByZXR1cm4gdFxufVxuXG5taW5pbWF0Y2guZGVmYXVsdHMgPSBkZWYgPT4ge1xuICBpZiAoIWRlZiB8fCB0eXBlb2YgZGVmICE9PSAnb2JqZWN0JyB8fCAhT2JqZWN0LmtleXMoZGVmKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gbWluaW1hdGNoXG4gIH1cblxuICBjb25zdCBvcmlnID0gbWluaW1hdGNoXG5cbiAgY29uc3QgbSA9IChwLCBwYXR0ZXJuLCBvcHRpb25zKSA9PiBvcmlnKHAsIHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICBtLk1pbmltYXRjaCA9IGNsYXNzIE1pbmltYXRjaCBleHRlbmRzIG9yaWcuTWluaW1hdGNoIHtcbiAgICBjb25zdHJ1Y3RvciAocGF0dGVybiwgb3B0aW9ucykge1xuICAgICAgc3VwZXIocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gICAgfVxuICB9XG4gIG0uTWluaW1hdGNoLmRlZmF1bHRzID0gb3B0aW9ucyA9PiBvcmlnLmRlZmF1bHRzKGV4dChkZWYsIG9wdGlvbnMpKS5NaW5pbWF0Y2hcbiAgbS5maWx0ZXIgPSAocGF0dGVybiwgb3B0aW9ucykgPT4gb3JpZy5maWx0ZXIocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIG0uZGVmYXVsdHMgPSBvcHRpb25zID0+IG9yaWcuZGVmYXVsdHMoZXh0KGRlZiwgb3B0aW9ucykpXG4gIG0ubWFrZVJlID0gKHBhdHRlcm4sIG9wdGlvbnMpID0+IG9yaWcubWFrZVJlKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICBtLmJyYWNlRXhwYW5kID0gKHBhdHRlcm4sIG9wdGlvbnMpID0+IG9yaWcuYnJhY2VFeHBhbmQocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIG0ubWF0Y2ggPSAobGlzdCwgcGF0dGVybiwgb3B0aW9ucykgPT4gb3JpZy5tYXRjaChsaXN0LCBwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcblxuICByZXR1cm4gbVxufVxuXG5cblxuXG5cbi8vIEJyYWNlIGV4cGFuc2lvbjpcbi8vIGF7YixjfWQgLT4gYWJkIGFjZFxuLy8gYXtiLH1jIC0+IGFiYyBhY1xuLy8gYXswLi4zfWQgLT4gYTBkIGExZCBhMmQgYTNkXG4vLyBhe2IsY3tkLGV9Zn1nIC0+IGFiZyBhY2RmZyBhY2VmZ1xuLy8gYXtiLGN9ZHtlLGZ9ZyAtPiBhYmRlZyBhY2RlZyBhYmRlZyBhYmRmZ1xuLy9cbi8vIEludmFsaWQgc2V0cyBhcmUgbm90IGV4cGFuZGVkLlxuLy8gYXsyLi59YiAtPiBhezIuLn1iXG4vLyBhe2J9YyAtPiBhe2J9Y1xubWluaW1hdGNoLmJyYWNlRXhwYW5kID0gKHBhdHRlcm4sIG9wdGlvbnMpID0+IGJyYWNlRXhwYW5kKHBhdHRlcm4sIG9wdGlvbnMpXG5cbmNvbnN0IGJyYWNlRXhwYW5kID0gKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBhc3NlcnRWYWxpZFBhdHRlcm4ocGF0dGVybilcblxuICAvLyBUaGFua3MgdG8gWWV0aW5nIExpIDxodHRwczovL2dpdGh1Yi5jb20veWV0aW5nbGk+IGZvclxuICAvLyBpbXByb3ZpbmcgdGhpcyByZWdleHAgdG8gYXZvaWQgYSBSZURPUyB2dWxuZXJhYmlsaXR5LlxuICBpZiAob3B0aW9ucy5ub2JyYWNlIHx8ICEvXFx7KD86KD8hXFx7KS4pKlxcfS8udGVzdChwYXR0ZXJuKSkge1xuICAgIC8vIHNob3J0Y3V0LiBubyBuZWVkIHRvIGV4cGFuZC5cbiAgICByZXR1cm4gW3BhdHRlcm5dXG4gIH1cblxuICByZXR1cm4gZXhwYW5kKHBhdHRlcm4pXG59XG5cbmNvbnN0IE1BWF9QQVRURVJOX0xFTkdUSCA9IDEwMjQgKiA2NFxuY29uc3QgYXNzZXJ0VmFsaWRQYXR0ZXJuID0gcGF0dGVybiA9PiB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhdHRlcm4nKVxuICB9XG5cbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gTUFYX1BBVFRFUk5fTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0dGVybiBpcyB0b28gbG9uZycpXG4gIH1cbn1cblxuLy8gcGFyc2UgYSBjb21wb25lbnQgb2YgdGhlIGV4cGFuZGVkIHNldC5cbi8vIEF0IHRoaXMgcG9pbnQsIG5vIHBhdHRlcm4gbWF5IGNvbnRhaW4gXCIvXCIgaW4gaXRcbi8vIHNvIHdlJ3JlIGdvaW5nIHRvIHJldHVybiBhIDJkIGFycmF5LCB3aGVyZSBlYWNoIGVudHJ5IGlzIHRoZSBmdWxsXG4vLyBwYXR0ZXJuLCBzcGxpdCBvbiAnLycsIGFuZCB0aGVuIHR1cm5lZCBpbnRvIGEgcmVndWxhciBleHByZXNzaW9uLlxuLy8gQSByZWdleHAgaXMgbWFkZSBhdCB0aGUgZW5kIHdoaWNoIGpvaW5zIGVhY2ggYXJyYXkgd2l0aCBhblxuLy8gZXNjYXBlZCAvLCBhbmQgYW5vdGhlciBmdWxsIG9uZSB3aGljaCBqb2lucyBlYWNoIHJlZ2V4cCB3aXRoIHwuXG4vL1xuLy8gRm9sbG93aW5nIHRoZSBsZWFkIG9mIEJhc2ggNC4xLCBub3RlIHRoYXQgXCIqKlwiIG9ubHkgaGFzIHNwZWNpYWwgbWVhbmluZ1xuLy8gd2hlbiBpdCBpcyB0aGUgKm9ubHkqIHRoaW5nIGluIGEgcGF0aCBwb3J0aW9uLiAgT3RoZXJ3aXNlLCBhbnkgc2VyaWVzXG4vLyBvZiAqIGlzIGVxdWl2YWxlbnQgdG8gYSBzaW5nbGUgKi4gIEdsb2JzdGFyIGJlaGF2aW9yIGlzIGVuYWJsZWQgYnlcbi8vIGRlZmF1bHQsIGFuZCBjYW4gYmUgZGlzYWJsZWQgYnkgc2V0dGluZyBvcHRpb25zLm5vZ2xvYnN0YXIuXG5jb25zdCBTVUJQQVJTRSA9IFN5bWJvbCgnc3VicGFyc2UnKVxuXG5taW5pbWF0Y2gubWFrZVJlID0gKHBhdHRlcm4sIG9wdGlvbnMpID0+XG4gIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucyB8fCB7fSkubWFrZVJlKClcblxubWluaW1hdGNoLm1hdGNoID0gKGxpc3QsIHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBtbSA9IG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucylcbiAgbGlzdCA9IGxpc3QuZmlsdGVyKGYgPT4gbW0ubWF0Y2goZikpXG4gIGlmIChtbS5vcHRpb25zLm5vbnVsbCAmJiAhbGlzdC5sZW5ndGgpIHtcbiAgICBsaXN0LnB1c2gocGF0dGVybilcbiAgfVxuICByZXR1cm4gbGlzdFxufVxuXG4vLyByZXBsYWNlIHN0dWZmIGxpa2UgXFwqIHdpdGggKlxuY29uc3QgZ2xvYlVuZXNjYXBlID0gcyA9PiBzLnJlcGxhY2UoL1xcXFwoLikvZywgJyQxJylcbmNvbnN0IGNoYXJVbmVzY2FwZSA9IHMgPT4gcy5yZXBsYWNlKC9cXFxcKFteLVxcXV0pL2csICckMScpXG5jb25zdCByZWdFeHBFc2NhcGUgPSBzID0+IHMucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKVxuY29uc3QgYnJhRXhwRXNjYXBlID0gcyA9PiBzLnJlcGxhY2UoL1tbXFxdXFxcXF0vZywgJ1xcXFwkJicpXG5cbmNsYXNzIE1pbmltYXRjaCB7XG4gIGNvbnN0cnVjdG9yIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0VmFsaWRQYXR0ZXJuKHBhdHRlcm4pXG5cbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMuc2V0ID0gW11cbiAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuXG4gICAgdGhpcy53aW5kb3dzUGF0aHNOb0VzY2FwZSA9ICEhb3B0aW9ucy53aW5kb3dzUGF0aHNOb0VzY2FwZSB8fFxuICAgICAgb3B0aW9ucy5hbGxvd1dpbmRvd3NFc2NhcGUgPT09IGZhbHNlXG4gICAgaWYgKHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGUpIHtcbiAgICAgIHRoaXMucGF0dGVybiA9IHRoaXMucGF0dGVybi5yZXBsYWNlKC9cXFxcL2csICcvJylcbiAgICB9XG4gICAgdGhpcy5yZWdleHAgPSBudWxsXG4gICAgdGhpcy5uZWdhdGUgPSBmYWxzZVxuICAgIHRoaXMuY29tbWVudCA9IGZhbHNlXG4gICAgdGhpcy5lbXB0eSA9IGZhbHNlXG4gICAgdGhpcy5wYXJ0aWFsID0gISFvcHRpb25zLnBhcnRpYWxcblxuICAgIC8vIG1ha2UgdGhlIHNldCBvZiByZWdleHBzIGV0Yy5cbiAgICB0aGlzLm1ha2UoKVxuICB9XG5cbiAgZGVidWcgKCkge31cblxuICBtYWtlICgpIHtcbiAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gICAgLy8gZW1wdHkgcGF0dGVybnMgYW5kIGNvbW1lbnRzIG1hdGNoIG5vdGhpbmcuXG4gICAgaWYgKCFvcHRpb25zLm5vY29tbWVudCAmJiBwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICB0aGlzLmNvbW1lbnQgPSB0cnVlXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgICB0aGlzLmVtcHR5ID0gdHJ1ZVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gc3RlcCAxOiBmaWd1cmUgb3V0IG5lZ2F0aW9uLCBldGMuXG4gICAgdGhpcy5wYXJzZU5lZ2F0ZSgpXG5cbiAgICAvLyBzdGVwIDI6IGV4cGFuZCBicmFjZXNcbiAgICBsZXQgc2V0ID0gdGhpcy5nbG9iU2V0ID0gdGhpcy5icmFjZUV4cGFuZCgpXG5cbiAgICBpZiAob3B0aW9ucy5kZWJ1ZykgdGhpcy5kZWJ1ZyA9ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKC4uLmFyZ3MpXG5cbiAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gICAgLy8gc3RlcCAzOiBub3cgd2UgaGF2ZSBhIHNldCwgc28gdHVybiBlYWNoIG9uZSBpbnRvIGEgc2VyaWVzIG9mIHBhdGgtcG9ydGlvblxuICAgIC8vIG1hdGNoaW5nIHBhdHRlcm5zLlxuICAgIC8vIFRoZXNlIHdpbGwgYmUgcmVnZXhwcywgZXhjZXB0IGluIHRoZSBjYXNlIG9mIFwiKipcIiwgd2hpY2ggaXNcbiAgICAvLyBzZXQgdG8gdGhlIEdMT0JTVEFSIG9iamVjdCBmb3IgZ2xvYnN0YXIgYmVoYXZpb3IsXG4gICAgLy8gYW5kIHdpbGwgbm90IGNvbnRhaW4gYW55IC8gY2hhcmFjdGVyc1xuICAgIHNldCA9IHRoaXMuZ2xvYlBhcnRzID0gc2V0Lm1hcChzID0+IHMuc3BsaXQoc2xhc2hTcGxpdCkpXG5cbiAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gICAgLy8gZ2xvYiAtLT4gcmVnZXhwc1xuICAgIHNldCA9IHNldC5tYXAoKHMsIHNpLCBzZXQpID0+IHMubWFwKHRoaXMucGFyc2UsIHRoaXMpKVxuXG4gICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICAgIC8vIGZpbHRlciBvdXQgZXZlcnl0aGluZyB0aGF0IGRpZG4ndCBjb21waWxlIHByb3Blcmx5LlxuICAgIHNldCA9IHNldC5maWx0ZXIocyA9PiBzLmluZGV4T2YoZmFsc2UpID09PSAtMSlcblxuICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpXG5cbiAgICB0aGlzLnNldCA9IHNldFxuICB9XG5cbiAgcGFyc2VOZWdhdGUgKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubm9uZWdhdGUpIHJldHVyblxuXG4gICAgY29uc3QgcGF0dGVybiA9IHRoaXMucGF0dGVyblxuICAgIGxldCBuZWdhdGUgPSBmYWxzZVxuICAgIGxldCBuZWdhdGVPZmZzZXQgPSAwXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoICYmIHBhdHRlcm4uY2hhckF0KGkpID09PSAnISc7IGkrKykge1xuICAgICAgbmVnYXRlID0gIW5lZ2F0ZVxuICAgICAgbmVnYXRlT2Zmc2V0KytcbiAgICB9XG5cbiAgICBpZiAobmVnYXRlT2Zmc2V0KSB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuLnNsaWNlKG5lZ2F0ZU9mZnNldClcbiAgICB0aGlzLm5lZ2F0ZSA9IG5lZ2F0ZVxuICB9XG5cbiAgLy8gc2V0IHBhcnRpYWwgdG8gdHJ1ZSB0byB0ZXN0IGlmLCBmb3IgZXhhbXBsZSxcbiAgLy8gXCIvYS9iXCIgbWF0Y2hlcyB0aGUgc3RhcnQgb2YgXCIvKi9iLyovZFwiXG4gIC8vIFBhcnRpYWwgbWVhbnMsIGlmIHlvdSBydW4gb3V0IG9mIGZpbGUgYmVmb3JlIHlvdSBydW5cbiAgLy8gb3V0IG9mIHBhdHRlcm4sIHRoZW4gdGhhdCdzIGZpbmUsIGFzIGxvbmcgYXMgYWxsXG4gIC8vIHRoZSBwYXJ0cyBtYXRjaC5cbiAgbWF0Y2hPbmUgKGZpbGUsIHBhdHRlcm4sIHBhcnRpYWwpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gICAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLFxuICAgICAgeyAndGhpcyc6IHRoaXMsIGZpbGU6IGZpbGUsIHBhdHRlcm46IHBhdHRlcm4gfSlcblxuICAgIHRoaXMuZGVidWcoJ21hdGNoT25lJywgZmlsZS5sZW5ndGgsIHBhdHRlcm4ubGVuZ3RoKVxuXG4gICAgZm9yICh2YXIgZmkgPSAwLFxuICAgICAgICBwaSA9IDAsXG4gICAgICAgIGZsID0gZmlsZS5sZW5ndGgsXG4gICAgICAgIHBsID0gcGF0dGVybi5sZW5ndGhcbiAgICAgICAgOyAoZmkgPCBmbCkgJiYgKHBpIDwgcGwpXG4gICAgICAgIDsgZmkrKywgcGkrKykge1xuICAgICAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUgbG9vcCcpXG4gICAgICB2YXIgcCA9IHBhdHRlcm5bcGldXG4gICAgICB2YXIgZiA9IGZpbGVbZmldXG5cbiAgICAgIHRoaXMuZGVidWcocGF0dGVybiwgcCwgZilcblxuICAgICAgLy8gc2hvdWxkIGJlIGltcG9zc2libGUuXG4gICAgICAvLyBzb21lIGludmFsaWQgcmVnZXhwIHN0dWZmIGluIHRoZSBzZXQuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlXG5cbiAgICAgIGlmIChwID09PSBHTE9CU1RBUikge1xuICAgICAgICB0aGlzLmRlYnVnKCdHTE9CU1RBUicsIFtwYXR0ZXJuLCBwLCBmXSlcblxuICAgICAgICAvLyBcIioqXCJcbiAgICAgICAgLy8gYS8qKi9iLyoqL2Mgd291bGQgbWF0Y2ggdGhlIGZvbGxvd2luZzpcbiAgICAgICAgLy8gYS9iL3gveS96L2NcbiAgICAgICAgLy8gYS94L3kvei9iL2NcbiAgICAgICAgLy8gYS9iL3gvYi94L2NcbiAgICAgICAgLy8gYS9iL2NcbiAgICAgICAgLy8gVG8gZG8gdGhpcywgdGFrZSB0aGUgcmVzdCBvZiB0aGUgcGF0dGVybiBhZnRlclxuICAgICAgICAvLyB0aGUgKiosIGFuZCBzZWUgaWYgaXQgd291bGQgbWF0Y2ggdGhlIGZpbGUgcmVtYWluZGVyLlxuICAgICAgICAvLyBJZiBzbywgcmV0dXJuIHN1Y2Nlc3MuXG4gICAgICAgIC8vIElmIG5vdCwgdGhlICoqIFwic3dhbGxvd3NcIiBhIHNlZ21lbnQsIGFuZCB0cnkgYWdhaW4uXG4gICAgICAgIC8vIFRoaXMgaXMgcmVjdXJzaXZlbHkgYXdmdWwuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGEvKiovYi8qKi9jIG1hdGNoaW5nIGEvYi94L3kvei9jXG4gICAgICAgIC8vIC0gYSBtYXRjaGVzIGFcbiAgICAgICAgLy8gLSBkb3VibGVzdGFyXG4gICAgICAgIC8vICAgLSBtYXRjaE9uZShiL3gveS96L2MsIGIvKiovYylcbiAgICAgICAgLy8gICAgIC0gYiBtYXRjaGVzIGJcbiAgICAgICAgLy8gICAgIC0gZG91Ymxlc3RhclxuICAgICAgICAvLyAgICAgICAtIG1hdGNoT25lKHgveS96L2MsIGMpIC0+IG5vXG4gICAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoeS96L2MsIGMpIC0+IG5vXG4gICAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoei9jLCBjKSAtPiBub1xuICAgICAgICAvLyAgICAgICAtIG1hdGNoT25lKGMsIGMpIHllcywgaGl0XG4gICAgICAgIHZhciBmciA9IGZpXG4gICAgICAgIHZhciBwciA9IHBpICsgMVxuICAgICAgICBpZiAocHIgPT09IHBsKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZygnKiogYXQgdGhlIGVuZCcpXG4gICAgICAgICAgLy8gYSAqKiBhdCB0aGUgZW5kIHdpbGwganVzdCBzd2FsbG93IHRoZSByZXN0LlxuICAgICAgICAgIC8vIFdlIGhhdmUgZm91bmQgYSBtYXRjaC5cbiAgICAgICAgICAvLyBob3dldmVyLCBpdCB3aWxsIG5vdCBzd2FsbG93IC8ueCwgdW5sZXNzXG4gICAgICAgICAgLy8gb3B0aW9ucy5kb3QgaXMgc2V0LlxuICAgICAgICAgIC8vIC4gYW5kIC4uIGFyZSAqbmV2ZXIqIG1hdGNoZWQgYnkgKiosIGZvciBleHBsb3NpdmVseVxuICAgICAgICAgIC8vIGV4cG9uZW50aWFsIHJlYXNvbnMuXG4gICAgICAgICAgZm9yICg7IGZpIDwgZmw7IGZpKyspIHtcbiAgICAgICAgICAgIGlmIChmaWxlW2ZpXSA9PT0gJy4nIHx8IGZpbGVbZmldID09PSAnLi4nIHx8XG4gICAgICAgICAgICAgICghb3B0aW9ucy5kb3QgJiYgZmlsZVtmaV0uY2hhckF0KDApID09PSAnLicpKSByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9rLCBsZXQncyBzZWUgaWYgd2UgY2FuIHN3YWxsb3cgd2hhdGV2ZXIgd2UgY2FuLlxuICAgICAgICB3aGlsZSAoZnIgPCBmbCkge1xuICAgICAgICAgIHZhciBzd2FsbG93ZWUgPSBmaWxlW2ZyXVxuXG4gICAgICAgICAgdGhpcy5kZWJ1ZygnXFxuZ2xvYnN0YXIgd2hpbGUnLCBmaWxlLCBmciwgcGF0dGVybiwgcHIsIHN3YWxsb3dlZSlcblxuICAgICAgICAgIC8vIFhYWCByZW1vdmUgdGhpcyBzbGljZS4gIEp1c3QgcGFzcyB0aGUgc3RhcnQgaW5kZXguXG4gICAgICAgICAgaWYgKHRoaXMubWF0Y2hPbmUoZmlsZS5zbGljZShmciksIHBhdHRlcm4uc2xpY2UocHIpLCBwYXJ0aWFsKSkge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZygnZ2xvYnN0YXIgZm91bmQgbWF0Y2ghJywgZnIsIGZsLCBzd2FsbG93ZWUpXG4gICAgICAgICAgICAvLyBmb3VuZCBhIG1hdGNoLlxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY2FuJ3Qgc3dhbGxvdyBcIi5cIiBvciBcIi4uXCIgZXZlci5cbiAgICAgICAgICAgIC8vIGNhbiBvbmx5IHN3YWxsb3cgXCIuZm9vXCIgd2hlbiBleHBsaWNpdGx5IGFza2VkLlxuICAgICAgICAgICAgaWYgKHN3YWxsb3dlZSA9PT0gJy4nIHx8IHN3YWxsb3dlZSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgICAoIW9wdGlvbnMuZG90ICYmIHN3YWxsb3dlZS5jaGFyQXQoMCkgPT09ICcuJykpIHtcbiAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnZG90IGRldGVjdGVkIScsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwcilcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gKiogc3dhbGxvd3MgYSBzZWdtZW50LCBhbmQgY29udGludWUuXG4gICAgICAgICAgICB0aGlzLmRlYnVnKCdnbG9ic3RhciBzd2FsbG93IGEgc2VnbWVudCwgYW5kIGNvbnRpbnVlJylcbiAgICAgICAgICAgIGZyKytcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBtYXRjaCB3YXMgZm91bmQuXG4gICAgICAgIC8vIEhvd2V2ZXIsIGluIHBhcnRpYWwgbW9kZSwgd2UgY2FuJ3Qgc2F5IHRoaXMgaXMgbmVjZXNzYXJpbHkgb3Zlci5cbiAgICAgICAgLy8gSWYgdGhlcmUncyBtb3JlICpwYXR0ZXJuKiBsZWZ0LCB0aGVuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocGFydGlhbCkge1xuICAgICAgICAgIC8vIHJhbiBvdXQgb2YgZmlsZVxuICAgICAgICAgIHRoaXMuZGVidWcoJ1xcbj4+PiBubyBtYXRjaCwgcGFydGlhbD8nLCBmaWxlLCBmciwgcGF0dGVybiwgcHIpXG4gICAgICAgICAgaWYgKGZyID09PSBmbCkgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgLy8gc29tZXRoaW5nIG90aGVyIHRoYW4gKipcbiAgICAgIC8vIG5vbi1tYWdpYyBwYXR0ZXJucyBqdXN0IGhhdmUgdG8gbWF0Y2ggZXhhY3RseVxuICAgICAgLy8gcGF0dGVybnMgd2l0aCBtYWdpYyBoYXZlIGJlZW4gdHVybmVkIGludG8gcmVnZXhwcy5cbiAgICAgIHZhciBoaXRcbiAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaGl0ID0gZiA9PT0gcFxuICAgICAgICB0aGlzLmRlYnVnKCdzdHJpbmcgbWF0Y2gnLCBwLCBmLCBoaXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoaXQgPSBmLm1hdGNoKHApXG4gICAgICAgIHRoaXMuZGVidWcoJ3BhdHRlcm4gbWF0Y2gnLCBwLCBmLCBoaXQpXG4gICAgICB9XG5cbiAgICAgIGlmICghaGl0KSByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBOb3RlOiBlbmRpbmcgaW4gLyBtZWFucyB0aGF0IHdlJ2xsIGdldCBhIGZpbmFsIFwiXCJcbiAgICAvLyBhdCB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuLiAgVGhpcyBjYW4gb25seSBtYXRjaCBhXG4gICAgLy8gY29ycmVzcG9uZGluZyBcIlwiIGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUuXG4gICAgLy8gSWYgdGhlIGZpbGUgZW5kcyBpbiAvLCB0aGVuIGl0IGNhbiBvbmx5IG1hdGNoIGFcbiAgICAvLyBhIHBhdHRlcm4gdGhhdCBlbmRzIGluIC8sIHVubGVzcyB0aGUgcGF0dGVybiBqdXN0XG4gICAgLy8gZG9lc24ndCBoYXZlIGFueSBtb3JlIGZvciBpdC4gQnV0LCBhL2IvIHNob3VsZCAqbm90KlxuICAgIC8vIG1hdGNoIFwiYS9iLypcIiwgZXZlbiB0aG91Z2ggXCJcIiBtYXRjaGVzIGFnYWluc3QgdGhlXG4gICAgLy8gW14vXSo/IHBhdHRlcm4sIGV4Y2VwdCBpbiBwYXJ0aWFsIG1vZGUsIHdoZXJlIGl0IG1pZ2h0XG4gICAgLy8gc2ltcGx5IG5vdCBiZSByZWFjaGVkIHlldC5cbiAgICAvLyBIb3dldmVyLCBhL2IvIHNob3VsZCBzdGlsbCBzYXRpc2Z5IGEvKlxuXG4gICAgLy8gbm93IGVpdGhlciB3ZSBmZWxsIG9mZiB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuLCBvciB3ZSdyZSBkb25lLlxuICAgIGlmIChmaSA9PT0gZmwgJiYgcGkgPT09IHBsKSB7XG4gICAgICAvLyByYW4gb3V0IG9mIHBhdHRlcm4gYW5kIGZpbGVuYW1lIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICAvLyBhbiBleGFjdCBoaXQhXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoZmkgPT09IGZsKSB7XG4gICAgICAvLyByYW4gb3V0IG9mIGZpbGUsIGJ1dCBzdGlsbCBoYWQgcGF0dGVybiBsZWZ0LlxuICAgICAgLy8gdGhpcyBpcyBvayBpZiB3ZSdyZSBkb2luZyB0aGUgbWF0Y2ggYXMgcGFydCBvZlxuICAgICAgLy8gYSBnbG9iIGZzIHRyYXZlcnNhbC5cbiAgICAgIHJldHVybiBwYXJ0aWFsXG4gICAgfSBlbHNlIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovIGlmIChwaSA9PT0gcGwpIHtcbiAgICAgIC8vIHJhbiBvdXQgb2YgcGF0dGVybiwgc3RpbGwgaGF2ZSBmaWxlIGxlZnQuXG4gICAgICAvLyB0aGlzIGlzIG9ubHkgYWNjZXB0YWJsZSBpZiB3ZSdyZSBvbiB0aGUgdmVyeSBsYXN0XG4gICAgICAvLyBlbXB0eSBzZWdtZW50IG9mIGEgZmlsZSB3aXRoIGEgdHJhaWxpbmcgc2xhc2guXG4gICAgICAvLyBhLyogc2hvdWxkIG1hdGNoIGEvYi9cbiAgICAgIHJldHVybiAoZmkgPT09IGZsIC0gMSkgJiYgKGZpbGVbZmldID09PSAnJylcbiAgICB9XG5cbiAgICAvLyBzaG91bGQgYmUgdW5yZWFjaGFibGUuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3d0Zj8nKVxuICB9XG5cbiAgYnJhY2VFeHBhbmQgKCkge1xuICAgIHJldHVybiBicmFjZUV4cGFuZCh0aGlzLnBhdHRlcm4sIHRoaXMub3B0aW9ucylcbiAgfVxuXG4gIHBhcnNlIChwYXR0ZXJuLCBpc1N1Yikge1xuICAgIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gICAgLy8gc2hvcnRjdXRzXG4gICAgaWYgKHBhdHRlcm4gPT09ICcqKicpIHtcbiAgICAgIGlmICghb3B0aW9ucy5ub2dsb2JzdGFyKVxuICAgICAgICByZXR1cm4gR0xPQlNUQVJcbiAgICAgIGVsc2VcbiAgICAgICAgcGF0dGVybiA9ICcqJ1xuICAgIH1cbiAgICBpZiAocGF0dGVybiA9PT0gJycpIHJldHVybiAnJ1xuXG4gICAgbGV0IHJlID0gJydcbiAgICBsZXQgaGFzTWFnaWMgPSBmYWxzZVxuICAgIGxldCBlc2NhcGluZyA9IGZhbHNlXG4gICAgLy8gPyA9PiBvbmUgc2luZ2xlIGNoYXJhY3RlclxuICAgIGNvbnN0IHBhdHRlcm5MaXN0U3RhY2sgPSBbXVxuICAgIGNvbnN0IG5lZ2F0aXZlTGlzdHMgPSBbXVxuICAgIGxldCBzdGF0ZUNoYXJcbiAgICBsZXQgaW5DbGFzcyA9IGZhbHNlXG4gICAgbGV0IHJlQ2xhc3NTdGFydCA9IC0xXG4gICAgbGV0IGNsYXNzU3RhcnQgPSAtMVxuICAgIGxldCBjc1xuICAgIGxldCBwbFxuICAgIGxldCBzcFxuICAgIC8vIC4gYW5kIC4uIG5ldmVyIG1hdGNoIGFueXRoaW5nIHRoYXQgZG9lc24ndCBzdGFydCB3aXRoIC4sXG4gICAgLy8gZXZlbiB3aGVuIG9wdGlvbnMuZG90IGlzIHNldC4gIEhvd2V2ZXIsIGlmIHRoZSBwYXR0ZXJuXG4gICAgLy8gc3RhcnRzIHdpdGggLiwgdGhlbiB0cmF2ZXJzYWwgcGF0dGVybnMgY2FuIG1hdGNoLlxuICAgIGxldCBkb3RUcmF2QWxsb3dlZCA9IHBhdHRlcm4uY2hhckF0KDApID09PSAnLidcbiAgICBsZXQgZG90RmlsZUFsbG93ZWQgPSBvcHRpb25zLmRvdCB8fCBkb3RUcmF2QWxsb3dlZFxuICAgIGNvbnN0IHBhdHRlcm5TdGFydCA9ICgpID0+XG4gICAgICBkb3RUcmF2QWxsb3dlZFxuICAgICAgICA/ICcnXG4gICAgICAgIDogZG90RmlsZUFsbG93ZWRcbiAgICAgICAgPyAnKD8hKD86XnxcXFxcLylcXFxcLnsxLDJ9KD86JHxcXFxcLykpJ1xuICAgICAgICA6ICcoPyFcXFxcLiknXG4gICAgY29uc3Qgc3ViUGF0dGVyblN0YXJ0ID0gKHApID0+XG4gICAgICBwLmNoYXJBdCgwKSA9PT0gJy4nXG4gICAgICAgID8gJydcbiAgICAgICAgOiBvcHRpb25zLmRvdFxuICAgICAgICA/ICcoPyEoPzpefFxcXFwvKVxcXFwuezEsMn0oPzokfFxcXFwvKSknXG4gICAgICAgIDogJyg/IVxcXFwuKSdcblxuXG4gICAgY29uc3QgY2xlYXJTdGF0ZUNoYXIgPSAoKSA9PiB7XG4gICAgICBpZiAoc3RhdGVDaGFyKSB7XG4gICAgICAgIC8vIHdlIGhhZCBzb21lIHN0YXRlLXRyYWNraW5nIGNoYXJhY3RlclxuICAgICAgICAvLyB0aGF0IHdhc24ndCBjb25zdW1lZCBieSB0aGlzIHBhc3MuXG4gICAgICAgIHN3aXRjaCAoc3RhdGVDaGFyKSB7XG4gICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICByZSArPSBzdGFyXG4gICAgICAgICAgICBoYXNNYWdpYyA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgJz8nOlxuICAgICAgICAgICAgcmUgKz0gcW1hcmtcbiAgICAgICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlICs9ICdcXFxcJyArIHN0YXRlQ2hhclxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWJ1ZygnY2xlYXJTdGF0ZUNoYXIgJWogJWonLCBzdGF0ZUNoYXIsIHJlKVxuICAgICAgICBzdGF0ZUNoYXIgPSBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwLCBjOyAoaSA8IHBhdHRlcm4ubGVuZ3RoKSAmJiAoYyA9IHBhdHRlcm4uY2hhckF0KGkpKTsgaSsrKSB7XG4gICAgICB0aGlzLmRlYnVnKCclc1xcdCVzICVzICVqJywgcGF0dGVybiwgaSwgcmUsIGMpXG5cbiAgICAgIC8vIHNraXAgb3ZlciBhbnkgdGhhdCBhcmUgZXNjYXBlZC5cbiAgICAgIGlmIChlc2NhcGluZykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIGNvbXBsZXRlbHkgbm90IGFsbG93ZWQsIGV2ZW4gZXNjYXBlZC4gKi9cbiAgICAgICAgaWYgKGMgPT09ICcvJykge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlU3BlY2lhbHNbY10pIHtcbiAgICAgICAgICByZSArPSAnXFxcXCdcbiAgICAgICAgfVxuICAgICAgICByZSArPSBjXG4gICAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGNhc2UgJy8nOiB7XG4gICAgICAgICAgLy8gU2hvdWxkIGFscmVhZHkgYmUgcGF0aC1zcGxpdCBieSBub3cuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBjYXNlICdcXFxcJzpcbiAgICAgICAgICBpZiAoaW5DbGFzcyAmJiBwYXR0ZXJuLmNoYXJBdChpICsgMSkgPT09ICctJykge1xuICAgICAgICAgICAgcmUgKz0gY1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgICAgZXNjYXBpbmcgPSB0cnVlXG4gICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgLy8gdGhlIHZhcmlvdXMgc3RhdGVDaGFyIHZhbHVlc1xuICAgICAgICAvLyBmb3IgdGhlIFwiZXh0Z2xvYlwiIHN0dWZmLlxuICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICBjYXNlICdAJzpcbiAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgdGhpcy5kZWJ1ZygnJXNcXHQlcyAlcyAlaiA8LS0gc3RhdGVDaGFyJywgcGF0dGVybiwgaSwgcmUsIGMpXG5cbiAgICAgICAgICAvLyBhbGwgb2YgdGhvc2UgYXJlIGxpdGVyYWxzIGluc2lkZSBhIGNsYXNzLCBleGNlcHQgdGhhdFxuICAgICAgICAgIC8vIHRoZSBnbG9iIFshYV0gbWVhbnMgW15hXSBpbiByZWdleHBcbiAgICAgICAgICBpZiAoaW5DbGFzcykge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZygnICBpbiBjbGFzcycpXG4gICAgICAgICAgICBpZiAoYyA9PT0gJyEnICYmIGkgPT09IGNsYXNzU3RhcnQgKyAxKSBjID0gJ14nXG4gICAgICAgICAgICByZSArPSBjXG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHN0YXRlQ2hhciwgdGhlbiBpdCBtZWFuc1xuICAgICAgICAgIC8vIHRoYXQgdGhlcmUgd2FzIHNvbWV0aGluZyBsaWtlICoqIG9yICs/IGluIHRoZXJlLlxuICAgICAgICAgIC8vIEhhbmRsZSB0aGUgc3RhdGVDaGFyLCB0aGVuIHByb2NlZWQgd2l0aCB0aGlzIG9uZS5cbiAgICAgICAgICB0aGlzLmRlYnVnKCdjYWxsIGNsZWFyU3RhdGVDaGFyICVqJywgc3RhdGVDaGFyKVxuICAgICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgICBzdGF0ZUNoYXIgPSBjXG4gICAgICAgICAgLy8gaWYgZXh0Z2xvYiBpcyBkaXNhYmxlZCwgdGhlbiArKGFzZGZ8Zm9vKSBpc24ndCBhIHRoaW5nLlxuICAgICAgICAgIC8vIGp1c3QgY2xlYXIgdGhlIHN0YXRlY2hhciAqbm93KiwgcmF0aGVyIHRoYW4gZXZlbiBkaXZpbmcgaW50b1xuICAgICAgICAgIC8vIHRoZSBwYXR0ZXJuTGlzdCBzdHVmZi5cbiAgICAgICAgICBpZiAob3B0aW9ucy5ub2V4dCkgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgJygnOiB7XG4gICAgICAgICAgaWYgKGluQ2xhc3MpIHtcbiAgICAgICAgICAgIHJlICs9ICcoJ1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXN0YXRlQ2hhcikge1xuICAgICAgICAgICAgcmUgKz0gJ1xcXFwoJ1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBwbEVudHJ5ID0ge1xuICAgICAgICAgICAgdHlwZTogc3RhdGVDaGFyLFxuICAgICAgICAgICAgc3RhcnQ6IGkgLSAxLFxuICAgICAgICAgICAgcmVTdGFydDogcmUubGVuZ3RoLFxuICAgICAgICAgICAgb3BlbjogcGxUeXBlc1tzdGF0ZUNoYXJdLm9wZW4sXG4gICAgICAgICAgICBjbG9zZTogcGxUeXBlc1tzdGF0ZUNoYXJdLmNsb3NlLFxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ1xcdCcsIHBsRW50cnkpXG4gICAgICAgICAgcGF0dGVybkxpc3RTdGFjay5wdXNoKHBsRW50cnkpXG4gICAgICAgICAgLy8gbmVnYXRpb24gaXMgKD86KD8hKD86anMpKD86PHJlc3Q+KSlbXi9dKilcbiAgICAgICAgICByZSArPSBwbEVudHJ5Lm9wZW5cbiAgICAgICAgICAvLyBuZXh0IGVudHJ5IHN0YXJ0cyB3aXRoIGEgZG90IG1heWJlP1xuICAgICAgICAgIGlmIChwbEVudHJ5LnN0YXJ0ID09PSAwICYmIHBsRW50cnkudHlwZSAhPT0gJyEnKSB7XG4gICAgICAgICAgICBkb3RUcmF2QWxsb3dlZCA9IHRydWVcbiAgICAgICAgICAgIHJlICs9IHN1YlBhdHRlcm5TdGFydChwYXR0ZXJuLnNsaWNlKGkgKyAxKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5kZWJ1ZygncGxUeXBlICVqICVqJywgc3RhdGVDaGFyLCByZSlcbiAgICAgICAgICBzdGF0ZUNoYXIgPSBmYWxzZVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBjYXNlICcpJzoge1xuICAgICAgICAgIGNvbnN0IHBsRW50cnkgPSBwYXR0ZXJuTGlzdFN0YWNrW3BhdHRlcm5MaXN0U3RhY2subGVuZ3RoIC0gMV1cbiAgICAgICAgICBpZiAoaW5DbGFzcyB8fCAhcGxFbnRyeSkge1xuICAgICAgICAgICAgcmUgKz0gJ1xcXFwpJ1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0dGVybkxpc3RTdGFjay5wb3AoKVxuXG4gICAgICAgICAgLy8gY2xvc2luZyBhbiBleHRnbG9iXG4gICAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICAgIHBsID0gcGxFbnRyeVxuICAgICAgICAgIC8vIG5lZ2F0aW9uIGlzICg/Oig/IWpzKVteL10qKVxuICAgICAgICAgIC8vIFRoZSBvdGhlcnMgYXJlICg/OjxwYXR0ZXJuPik8dHlwZT5cbiAgICAgICAgICByZSArPSBwbC5jbG9zZVxuICAgICAgICAgIGlmIChwbC50eXBlID09PSAnIScpIHtcbiAgICAgICAgICAgIG5lZ2F0aXZlTGlzdHMucHVzaChPYmplY3QuYXNzaWduKHBsLCB7IHJlRW5kOiByZS5sZW5ndGggfSkpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBjYXNlICd8Jzoge1xuICAgICAgICAgIGNvbnN0IHBsRW50cnkgPSBwYXR0ZXJuTGlzdFN0YWNrW3BhdHRlcm5MaXN0U3RhY2subGVuZ3RoIC0gMV1cbiAgICAgICAgICBpZiAoaW5DbGFzcyB8fCAhcGxFbnRyeSkge1xuICAgICAgICAgICAgcmUgKz0gJ1xcXFx8J1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgICAgcmUgKz0gJ3wnXG4gICAgICAgICAgLy8gbmV4dCBzdWJwYXR0ZXJuIGNhbiBzdGFydCB3aXRoIGEgZG90P1xuICAgICAgICAgIGlmIChwbEVudHJ5LnN0YXJ0ID09PSAwICYmIHBsRW50cnkudHlwZSAhPT0gJyEnKSB7XG4gICAgICAgICAgICBkb3RUcmF2QWxsb3dlZCA9IHRydWVcbiAgICAgICAgICAgIHJlICs9IHN1YlBhdHRlcm5TdGFydChwYXR0ZXJuLnNsaWNlKGkgKyAxKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZXNlIGFyZSBtb3N0bHkgdGhlIHNhbWUgaW4gcmVnZXhwIGFuZCBnbG9iXG4gICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgIC8vIHN3YWxsb3cgYW55IHN0YXRlLXRyYWNraW5nIGNoYXIgYmVmb3JlIHRoZSBbXG4gICAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuXG4gICAgICAgICAgaWYgKGluQ2xhc3MpIHtcbiAgICAgICAgICAgIHJlICs9ICdcXFxcJyArIGNcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5DbGFzcyA9IHRydWVcbiAgICAgICAgICBjbGFzc1N0YXJ0ID0gaVxuICAgICAgICAgIHJlQ2xhc3NTdGFydCA9IHJlLmxlbmd0aFxuICAgICAgICAgIHJlICs9IGNcbiAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlICddJzpcbiAgICAgICAgICAvLyAgYSByaWdodCBicmFja2V0IHNoYWxsIGxvc2UgaXRzIHNwZWNpYWxcbiAgICAgICAgICAvLyAgbWVhbmluZyBhbmQgcmVwcmVzZW50IGl0c2VsZiBpblxuICAgICAgICAgIC8vICBhIGJyYWNrZXQgZXhwcmVzc2lvbiBpZiBpdCBvY2N1cnNcbiAgICAgICAgICAvLyAgZmlyc3QgaW4gdGhlIGxpc3QuICAtLSBQT1NJWC4yIDIuOC4zLjJcbiAgICAgICAgICBpZiAoaSA9PT0gY2xhc3NTdGFydCArIDEgfHwgIWluQ2xhc3MpIHtcbiAgICAgICAgICAgIHJlICs9ICdcXFxcJyArIGNcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gc3BsaXQgd2hlcmUgdGhlIGxhc3QgWyB3YXMsIG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlXG4gICAgICAgICAgLy8gYW4gaW52YWxpZCByZS4gaWYgc28sIHJlLXdhbGsgdGhlIGNvbnRlbnRzIG9mIHRoZVxuICAgICAgICAgIC8vIHdvdWxkLWJlIGNsYXNzIHRvIHJlLXRyYW5zbGF0ZSBhbnkgY2hhcmFjdGVycyB0aGF0XG4gICAgICAgICAgLy8gd2VyZSBwYXNzZWQgdGhyb3VnaCBhcy1pc1xuICAgICAgICAgIC8vIFRPRE86IEl0IHdvdWxkIHByb2JhYmx5IGJlIGZhc3RlciB0byBkZXRlcm1pbmUgdGhpc1xuICAgICAgICAgIC8vIHdpdGhvdXQgYSB0cnkvY2F0Y2ggYW5kIGEgbmV3IFJlZ0V4cCwgYnV0IGl0J3MgdHJpY2t5XG4gICAgICAgICAgLy8gdG8gZG8gc2FmZWx5LiAgRm9yIG5vdywgdGhpcyBpcyBzYWZlIGFuZCB3b3Jrcy5cbiAgICAgICAgICBjcyA9IHBhdHRlcm4uc3Vic3RyaW5nKGNsYXNzU3RhcnQgKyAxLCBpKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWdFeHAoJ1snICsgYnJhRXhwRXNjYXBlKGNoYXJVbmVzY2FwZShjcykpICsgJ10nKVxuICAgICAgICAgICAgLy8gbG9va3MgZ29vZCwgZmluaXNoIHVwIHRoZSBjbGFzcy5cbiAgICAgICAgICAgIHJlICs9IGNcbiAgICAgICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICAgICAgLy8gb3V0IG9mIG9yZGVyIHJhbmdlcyBpbiBKUyBhcmUgZXJyb3JzLCBidXQgaW4gZ2xvYiBzeW50YXgsXG4gICAgICAgICAgICAvLyB0aGV5J3JlIGp1c3QgYSByYW5nZSB0aGF0IG1hdGNoZXMgbm90aGluZy5cbiAgICAgICAgICAgIHJlID0gcmUuc3Vic3RyaW5nKDAsIHJlQ2xhc3NTdGFydCkgKyAnKD86JC4pJyAvLyBtYXRjaCBub3RoaW5nIGV2ZXJcbiAgICAgICAgICB9XG4gICAgICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICAgICAgaW5DbGFzcyA9IGZhbHNlXG4gICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBzd2FsbG93IGFueSBzdGF0ZSBjaGFyIHRoYXQgd2Fzbid0IGNvbnN1bWVkXG4gICAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuXG4gICAgICAgICAgaWYgKHJlU3BlY2lhbHNbY10gJiYgIShjID09PSAnXicgJiYgaW5DbGFzcykpIHtcbiAgICAgICAgICAgIHJlICs9ICdcXFxcJ1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlICs9IGNcbiAgICAgICAgICBicmVha1xuXG4gICAgICB9IC8vIHN3aXRjaFxuICAgIH0gLy8gZm9yXG5cbiAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgbGVmdCBhIGNsYXNzIG9wZW4uXG4gICAgLy8gXCJbYWJjXCIgaXMgdmFsaWQsIGVxdWl2YWxlbnQgdG8gXCJcXFthYmNcIlxuICAgIGlmIChpbkNsYXNzKSB7XG4gICAgICAvLyBzcGxpdCB3aGVyZSB0aGUgbGFzdCBbIHdhcywgYW5kIGVzY2FwZSBpdFxuICAgICAgLy8gdGhpcyBpcyBhIGh1Z2UgcGl0YS4gIFdlIG5vdyBoYXZlIHRvIHJlLXdhbGtcbiAgICAgIC8vIHRoZSBjb250ZW50cyBvZiB0aGUgd291bGQtYmUgY2xhc3MgdG8gcmUtdHJhbnNsYXRlXG4gICAgICAvLyBhbnkgY2hhcmFjdGVycyB0aGF0IHdlcmUgcGFzc2VkIHRocm91Z2ggYXMtaXNcbiAgICAgIGNzID0gcGF0dGVybi5zbGljZShjbGFzc1N0YXJ0ICsgMSlcbiAgICAgIHNwID0gdGhpcy5wYXJzZShjcywgU1VCUEFSU0UpXG4gICAgICByZSA9IHJlLnN1YnN0cmluZygwLCByZUNsYXNzU3RhcnQpICsgJ1xcXFxbJyArIHNwWzBdXG4gICAgICBoYXNNYWdpYyA9IGhhc01hZ2ljIHx8IHNwWzFdXG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGhhZCBhICsoIHRoaW5nIGF0IHRoZSAqZW5kKlxuICAgIC8vIG9mIHRoZSBwYXR0ZXJuLlxuICAgIC8vIGVhY2ggcGF0dGVybiBsaXN0IHN0YWNrIGFkZHMgMyBjaGFycywgYW5kIHdlIG5lZWQgdG8gZ28gdGhyb3VnaFxuICAgIC8vIGFuZCBlc2NhcGUgYW55IHwgY2hhcnMgdGhhdCB3ZXJlIHBhc3NlZCB0aHJvdWdoIGFzLWlzIGZvciB0aGUgcmVnZXhwLlxuICAgIC8vIEdvIHRocm91Z2ggYW5kIGVzY2FwZSB0aGVtLCB0YWtpbmcgY2FyZSBub3QgdG8gZG91YmxlLWVzY2FwZSBhbnlcbiAgICAvLyB8IGNoYXJzIHRoYXQgd2VyZSBhbHJlYWR5IGVzY2FwZWQuXG4gICAgZm9yIChwbCA9IHBhdHRlcm5MaXN0U3RhY2sucG9wKCk7IHBsOyBwbCA9IHBhdHRlcm5MaXN0U3RhY2sucG9wKCkpIHtcbiAgICAgIGxldCB0YWlsXG4gICAgICB0YWlsID0gcmUuc2xpY2UocGwucmVTdGFydCArIHBsLm9wZW4ubGVuZ3RoKVxuICAgICAgdGhpcy5kZWJ1Zygnc2V0dGluZyB0YWlsJywgcmUsIHBsKVxuICAgICAgLy8gbWF5YmUgc29tZSBldmVuIG51bWJlciBvZiBcXCwgdGhlbiBtYXliZSAxIFxcLCBmb2xsb3dlZCBieSBhIHxcbiAgICAgIHRhaWwgPSB0YWlsLnJlcGxhY2UoLygoPzpcXFxcezJ9KXswLDY0fSkoXFxcXD8pXFx8L2csIChfLCAkMSwgJDIpID0+IHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLSBzaG91bGQgYWxyZWFkeSBiZSBkb25lICovXG4gICAgICAgIGlmICghJDIpIHtcbiAgICAgICAgICAvLyB0aGUgfCBpc24ndCBhbHJlYWR5IGVzY2FwZWQsIHNvIGVzY2FwZSBpdC5cbiAgICAgICAgICAkMiA9ICdcXFxcJ1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbmVlZCB0byBlc2NhcGUgYWxsIHRob3NlIHNsYXNoZXMgKmFnYWluKiwgd2l0aG91dCBlc2NhcGluZyB0aGVcbiAgICAgICAgLy8gb25lIHRoYXQgd2UgbmVlZCBmb3IgZXNjYXBpbmcgdGhlIHwgY2hhcmFjdGVyLiAgQXMgaXQgd29ya3Mgb3V0LFxuICAgICAgICAvLyBlc2NhcGluZyBhbiBldmVuIG51bWJlciBvZiBzbGFzaGVzIGNhbiBiZSBkb25lIGJ5IHNpbXBseSByZXBlYXRpbmdcbiAgICAgICAgLy8gaXQgZXhhY3RseSBhZnRlciBpdHNlbGYuICBUaGF0J3Mgd2h5IHRoaXMgdHJpY2sgd29ya3MuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEkgYW0gc29ycnkgdGhhdCB5b3UgaGF2ZSB0byBzZWUgdGhpcy5cbiAgICAgICAgcmV0dXJuICQxICsgJDEgKyAkMiArICd8J1xuICAgICAgfSlcblxuICAgICAgdGhpcy5kZWJ1ZygndGFpbD0lalxcbiAgICVzJywgdGFpbCwgdGFpbCwgcGwsIHJlKVxuICAgICAgY29uc3QgdCA9IHBsLnR5cGUgPT09ICcqJyA/IHN0YXJcbiAgICAgICAgOiBwbC50eXBlID09PSAnPycgPyBxbWFya1xuICAgICAgICA6ICdcXFxcJyArIHBsLnR5cGVcblxuICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICByZSA9IHJlLnNsaWNlKDAsIHBsLnJlU3RhcnQpICsgdCArICdcXFxcKCcgKyB0YWlsXG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIHRyYWlsaW5nIHRoaW5ncyB0aGF0IG9ubHkgbWF0dGVyIGF0IHRoZSB2ZXJ5IGVuZC5cbiAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgaWYgKGVzY2FwaW5nKSB7XG4gICAgICAvLyB0cmFpbGluZyBcXFxcXG4gICAgICByZSArPSAnXFxcXFxcXFwnXG4gICAgfVxuXG4gICAgLy8gb25seSBuZWVkIHRvIGFwcGx5IHRoZSBub2RvdCBzdGFydCBpZiB0aGUgcmUgc3RhcnRzIHdpdGhcbiAgICAvLyBzb21ldGhpbmcgdGhhdCBjb3VsZCBjb25jZWl2YWJseSBjYXB0dXJlIGEgZG90XG4gICAgY29uc3QgYWRkUGF0dGVyblN0YXJ0ID0gYWRkUGF0dGVyblN0YXJ0U2V0W3JlLmNoYXJBdCgwKV1cblxuICAgIC8vIEhhY2sgdG8gd29yayBhcm91bmQgbGFjayBvZiBuZWdhdGl2ZSBsb29rYmVoaW5kIGluIEpTXG4gICAgLy8gQSBwYXR0ZXJuIGxpa2U6ICouISh4KS4hKHl8eikgbmVlZHMgdG8gZW5zdXJlIHRoYXQgYSBuYW1lXG4gICAgLy8gbGlrZSAnYS54eXoueXonIGRvZXNuJ3QgbWF0Y2guICBTbywgdGhlIGZpcnN0IG5lZ2F0aXZlXG4gICAgLy8gbG9va2FoZWFkLCBoYXMgdG8gbG9vayBBTEwgdGhlIHdheSBhaGVhZCwgdG8gdGhlIGVuZCBvZlxuICAgIC8vIHRoZSBwYXR0ZXJuLlxuICAgIGZvciAobGV0IG4gPSBuZWdhdGl2ZUxpc3RzLmxlbmd0aCAtIDE7IG4gPiAtMTsgbi0tKSB7XG4gICAgICBjb25zdCBubCA9IG5lZ2F0aXZlTGlzdHNbbl1cblxuICAgICAgY29uc3QgbmxCZWZvcmUgPSByZS5zbGljZSgwLCBubC5yZVN0YXJ0KVxuICAgICAgY29uc3QgbmxGaXJzdCA9IHJlLnNsaWNlKG5sLnJlU3RhcnQsIG5sLnJlRW5kIC0gOClcbiAgICAgIGxldCBubEFmdGVyID0gcmUuc2xpY2UobmwucmVFbmQpXG4gICAgICBjb25zdCBubExhc3QgPSByZS5zbGljZShubC5yZUVuZCAtIDgsIG5sLnJlRW5kKSArIG5sQWZ0ZXJcblxuICAgICAgLy8gSGFuZGxlIG5lc3RlZCBzdHVmZiBsaWtlICooKi5qc3whKCouanNvbikpLCB3aGVyZSBvcGVuIHBhcmVuc1xuICAgICAgLy8gbWVhbiB0aGF0IHdlIHNob3VsZCAqbm90KiBpbmNsdWRlIHRoZSApIGluIHRoZSBiaXQgdGhhdCBpcyBjb25zaWRlcmVkXG4gICAgICAvLyBcImFmdGVyXCIgdGhlIG5lZ2F0ZWQgc2VjdGlvbi5cbiAgICAgIGNvbnN0IGNsb3NlUGFyZW5zQmVmb3JlID0gbmxCZWZvcmUuc3BsaXQoJyknKS5sZW5ndGhcbiAgICAgIGNvbnN0IG9wZW5QYXJlbnNCZWZvcmUgPSBubEJlZm9yZS5zcGxpdCgnKCcpLmxlbmd0aCAtIGNsb3NlUGFyZW5zQmVmb3JlXG4gICAgICBsZXQgY2xlYW5BZnRlciA9IG5sQWZ0ZXJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3BlblBhcmVuc0JlZm9yZTsgaSsrKSB7XG4gICAgICAgIGNsZWFuQWZ0ZXIgPSBjbGVhbkFmdGVyLnJlcGxhY2UoL1xcKVsrKj9dPy8sICcnKVxuICAgICAgfVxuICAgICAgbmxBZnRlciA9IGNsZWFuQWZ0ZXJcblxuICAgICAgY29uc3QgZG9sbGFyID0gbmxBZnRlciA9PT0gJycgJiYgaXNTdWIgIT09IFNVQlBBUlNFID8gJyg/OiR8XFxcXC8pJyA6ICcnXG5cbiAgICAgIHJlID0gbmxCZWZvcmUgKyBubEZpcnN0ICsgbmxBZnRlciArIGRvbGxhciArIG5sTGFzdFxuICAgIH1cblxuICAgIC8vIGlmIHRoZSByZSBpcyBub3QgXCJcIiBhdCB0aGlzIHBvaW50LCB0aGVuIHdlIG5lZWQgdG8gbWFrZSBzdXJlXG4gICAgLy8gaXQgZG9lc24ndCBtYXRjaCBhZ2FpbnN0IGFuIGVtcHR5IHBhdGggcGFydC5cbiAgICAvLyBPdGhlcndpc2UgYS8qIHdpbGwgbWF0Y2ggYS8sIHdoaWNoIGl0IHNob3VsZCBub3QuXG4gICAgaWYgKHJlICE9PSAnJyAmJiBoYXNNYWdpYykge1xuICAgICAgcmUgPSAnKD89LiknICsgcmVcbiAgICB9XG5cbiAgICBpZiAoYWRkUGF0dGVyblN0YXJ0KSB7XG4gICAgICByZSA9IHBhdHRlcm5TdGFydCgpICsgcmVcbiAgICB9XG5cbiAgICAvLyBwYXJzaW5nIGp1c3QgYSBwaWVjZSBvZiBhIGxhcmdlciBwYXR0ZXJuLlxuICAgIGlmIChpc1N1YiA9PT0gU1VCUEFSU0UpIHtcbiAgICAgIHJldHVybiBbcmUsIGhhc01hZ2ljXVxuICAgIH1cblxuICAgIC8vIGlmIGl0J3Mgbm9jYXNlLCBhbmQgdGhlIGxjYXNlL3VwcGVyY2FzZSBkb24ndCBtYXRjaCwgaXQncyBtYWdpY1xuICAgIGlmIChvcHRpb25zLm5vY2FzZSAmJiAhaGFzTWFnaWMpIHtcbiAgICAgIGhhc01hZ2ljID0gcGF0dGVybi50b1VwcGVyQ2FzZSgpICE9PSBwYXR0ZXJuLnRvTG93ZXJDYXNlKClcbiAgICB9XG5cbiAgICAvLyBza2lwIHRoZSByZWdleHAgZm9yIG5vbi1tYWdpY2FsIHBhdHRlcm5zXG4gICAgLy8gdW5lc2NhcGUgYW55dGhpbmcgaW4gaXQsIHRob3VnaCwgc28gdGhhdCBpdCdsbCBiZVxuICAgIC8vIGFuIGV4YWN0IG1hdGNoIGFnYWluc3QgYSBmaWxlIGV0Yy5cbiAgICBpZiAoIWhhc01hZ2ljKSB7XG4gICAgICByZXR1cm4gZ2xvYlVuZXNjYXBlKHBhdHRlcm4pXG4gICAgfVxuXG4gICAgY29uc3QgZmxhZ3MgPSBvcHRpb25zLm5vY2FzZSA/ICdpJyA6ICcnXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBSZWdFeHAoJ14nICsgcmUgKyAnJCcsIGZsYWdzKSwge1xuICAgICAgICBfZ2xvYjogcGF0dGVybixcbiAgICAgICAgX3NyYzogcmUsXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVyKSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIHNob3VsZCBiZSBpbXBvc3NpYmxlICovIHtcbiAgICAgIC8vIElmIGl0IHdhcyBhbiBpbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiwgdGhlbiBpdCBjYW4ndCBtYXRjaFxuICAgICAgLy8gYW55dGhpbmcuICBUaGlzIHRyaWNrIGxvb2tzIGZvciBhIGNoYXJhY3RlciBhZnRlciB0aGUgZW5kIG9mXG4gICAgICAvLyB0aGUgc3RyaW5nLCB3aGljaCBpcyBvZiBjb3Vyc2UgaW1wb3NzaWJsZSwgZXhjZXB0IGluIG11bHRpLWxpbmVcbiAgICAgIC8vIG1vZGUsIGJ1dCBpdCdzIG5vdCBhIC9tIHJlZ2V4LlxuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJyQuJylcbiAgICB9XG4gIH1cblxuICBtYWtlUmUgKCkge1xuICAgIGlmICh0aGlzLnJlZ2V4cCB8fCB0aGlzLnJlZ2V4cCA9PT0gZmFsc2UpIHJldHVybiB0aGlzLnJlZ2V4cFxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgdGhpcy5zZXQgaXMgYSAyZCBhcnJheSBvZiBwYXJ0aWFsXG4gICAgLy8gcGF0dGVybiBzdHJpbmdzLCBvciBcIioqXCIuXG4gICAgLy9cbiAgICAvLyBJdCdzIGJldHRlciB0byB1c2UgLm1hdGNoKCkuICBUaGlzIGZ1bmN0aW9uIHNob3VsZG4ndFxuICAgIC8vIGJlIHVzZWQsIHJlYWxseSwgYnV0IGl0J3MgcHJldHR5IGNvbnZlbmllbnQgc29tZXRpbWVzLFxuICAgIC8vIHdoZW4geW91IGp1c3Qgd2FudCB0byB3b3JrIHdpdGggYSByZWdleC5cbiAgICBjb25zdCBzZXQgPSB0aGlzLnNldFxuXG4gICAgaWYgKCFzZXQubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJlZ2V4cCA9IGZhbHNlXG4gICAgICByZXR1cm4gdGhpcy5yZWdleHBcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gICAgY29uc3QgdHdvU3RhciA9IG9wdGlvbnMubm9nbG9ic3RhciA/IHN0YXJcbiAgICAgIDogb3B0aW9ucy5kb3QgPyB0d29TdGFyRG90XG4gICAgICA6IHR3b1N0YXJOb0RvdFxuICAgIGNvbnN0IGZsYWdzID0gb3B0aW9ucy5ub2Nhc2UgPyAnaScgOiAnJ1xuXG4gICAgLy8gY29hbGVzY2UgZ2xvYnN0YXJzIGFuZCByZWdleHBpZnkgbm9uLWdsb2JzdGFyIHBhdHRlcm5zXG4gICAgLy8gaWYgaXQncyB0aGUgb25seSBpdGVtLCB0aGVuIHdlIGp1c3QgZG8gb25lIHR3b1N0YXJcbiAgICAvLyBpZiBpdCdzIHRoZSBmaXJzdCwgYW5kIHRoZXJlIGFyZSBtb3JlLCBwcmVwZW5kIChcXC98dHdvU3RhclxcLyk/IHRvIG5leHRcbiAgICAvLyBpZiBpdCdzIHRoZSBsYXN0LCBhcHBlbmQgKFxcL3R3b1N0YXJ8KSB0byBwcmV2aW91c1xuICAgIC8vIGlmIGl0J3MgaW4gdGhlIG1pZGRsZSwgYXBwZW5kIChcXC98XFwvdHdvU3RhclxcLykgdG8gcHJldmlvdXNcbiAgICAvLyB0aGVuIGZpbHRlciBvdXQgR0xPQlNUQVIgc3ltYm9sc1xuICAgIGxldCByZSA9IHNldC5tYXAocGF0dGVybiA9PiB7XG4gICAgICBwYXR0ZXJuID0gcGF0dGVybi5tYXAocCA9PlxuICAgICAgICB0eXBlb2YgcCA9PT0gJ3N0cmluZycgPyByZWdFeHBFc2NhcGUocClcbiAgICAgICAgOiBwID09PSBHTE9CU1RBUiA/IEdMT0JTVEFSXG4gICAgICAgIDogcC5fc3JjXG4gICAgICApLnJlZHVjZSgoc2V0LCBwKSA9PiB7XG4gICAgICAgIGlmICghKHNldFtzZXQubGVuZ3RoIC0gMV0gPT09IEdMT0JTVEFSICYmIHAgPT09IEdMT0JTVEFSKSkge1xuICAgICAgICAgIHNldC5wdXNoKHApXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldFxuICAgICAgfSwgW10pXG4gICAgICBwYXR0ZXJuLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgICAgaWYgKHAgIT09IEdMT0JTVEFSIHx8IHBhdHRlcm5baS0xXSA9PT0gR0xPQlNUQVIpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIGlmIChwYXR0ZXJuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHBhdHRlcm5baSsxXSA9ICcoPzpcXFxcXFwvfCcgKyB0d29TdGFyICsgJ1xcXFxcXC8pPycgKyBwYXR0ZXJuW2krMV1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0dGVybltpXSA9IHR3b1N0YXJcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gcGF0dGVybi5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgcGF0dGVybltpLTFdICs9ICcoPzpcXFxcXFwvfCcgKyB0d29TdGFyICsgJyk/J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdHRlcm5baS0xXSArPSAnKD86XFxcXFxcL3xcXFxcXFwvJyArIHR3b1N0YXIgKyAnXFxcXFxcLyknICsgcGF0dGVybltpKzFdXG4gICAgICAgICAgcGF0dGVybltpKzFdID0gR0xPQlNUQVJcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHJldHVybiBwYXR0ZXJuLmZpbHRlcihwID0+IHAgIT09IEdMT0JTVEFSKS5qb2luKCcvJylcbiAgICB9KS5qb2luKCd8JylcblxuICAgIC8vIG11c3QgbWF0Y2ggZW50aXJlIHBhdHRlcm5cbiAgICAvLyBlbmRpbmcgaW4gYSAqIG9yICoqIHdpbGwgbWFrZSBpdCBsZXNzIHN0cmljdC5cbiAgICByZSA9ICdeKD86JyArIHJlICsgJykkJ1xuXG4gICAgLy8gY2FuIG1hdGNoIGFueXRoaW5nLCBhcyBsb25nIGFzIGl0J3Mgbm90IHRoaXMuXG4gICAgaWYgKHRoaXMubmVnYXRlKSByZSA9ICdeKD8hJyArIHJlICsgJykuKiQnXG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5yZWdleHAgPSBuZXcgUmVnRXhwKHJlLCBmbGFncylcbiAgICB9IGNhdGNoIChleCkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBzaG91bGQgYmUgaW1wb3NzaWJsZSAqLyB7XG4gICAgICB0aGlzLnJlZ2V4cCA9IGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlZ2V4cFxuICB9XG5cbiAgbWF0Y2ggKGYsIHBhcnRpYWwgPSB0aGlzLnBhcnRpYWwpIHtcbiAgICB0aGlzLmRlYnVnKCdtYXRjaCcsIGYsIHRoaXMucGF0dGVybilcbiAgICAvLyBzaG9ydC1jaXJjdWl0IGluIHRoZSBjYXNlIG9mIGJ1c3RlZCB0aGluZ3MuXG4gICAgLy8gY29tbWVudHMsIGV0Yy5cbiAgICBpZiAodGhpcy5jb21tZW50KSByZXR1cm4gZmFsc2VcbiAgICBpZiAodGhpcy5lbXB0eSkgcmV0dXJuIGYgPT09ICcnXG5cbiAgICBpZiAoZiA9PT0gJy8nICYmIHBhcnRpYWwpIHJldHVybiB0cnVlXG5cbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgICAvLyB3aW5kb3dzOiBuZWVkIHRvIHVzZSAvLCBub3QgXFxcbiAgICBpZiAocGF0aC5zZXAgIT09ICcvJykge1xuICAgICAgZiA9IGYuc3BsaXQocGF0aC5zZXApLmpvaW4oJy8nKVxuICAgIH1cblxuICAgIC8vIHRyZWF0IHRoZSB0ZXN0IHBhdGggYXMgYSBzZXQgb2YgcGF0aHBhcnRzLlxuICAgIGYgPSBmLnNwbGl0KHNsYXNoU3BsaXQpXG4gICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sICdzcGxpdCcsIGYpXG5cbiAgICAvLyBqdXN0IE9ORSBvZiB0aGUgcGF0dGVybiBzZXRzIGluIHRoaXMuc2V0IG5lZWRzIHRvIG1hdGNoXG4gICAgLy8gaW4gb3JkZXIgZm9yIGl0IHRvIGJlIHZhbGlkLiAgSWYgbmVnYXRpbmcsIHRoZW4ganVzdCBvbmVcbiAgICAvLyBtYXRjaCBtZWFucyB0aGF0IHdlIGhhdmUgZmFpbGVkLlxuICAgIC8vIEVpdGhlciB3YXksIHJldHVybiBvbiB0aGUgZmlyc3QgaGl0LlxuXG4gICAgY29uc3Qgc2V0ID0gdGhpcy5zZXRcbiAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ3NldCcsIHNldClcblxuICAgIC8vIEZpbmQgdGhlIGJhc2VuYW1lIG9mIHRoZSBwYXRoIGJ5IGxvb2tpbmcgZm9yIHRoZSBsYXN0IG5vbi1lbXB0eSBzZWdtZW50XG4gICAgbGV0IGZpbGVuYW1lXG4gICAgZm9yIChsZXQgaSA9IGYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGZpbGVuYW1lID0gZltpXVxuICAgICAgaWYgKGZpbGVuYW1lKSBicmVha1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXR0ZXJuID0gc2V0W2ldXG4gICAgICBsZXQgZmlsZSA9IGZcbiAgICAgIGlmIChvcHRpb25zLm1hdGNoQmFzZSAmJiBwYXR0ZXJuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBmaWxlID0gW2ZpbGVuYW1lXVxuICAgICAgfVxuICAgICAgY29uc3QgaGl0ID0gdGhpcy5tYXRjaE9uZShmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsKVxuICAgICAgaWYgKGhpdCkge1xuICAgICAgICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSByZXR1cm4gdHJ1ZVxuICAgICAgICByZXR1cm4gIXRoaXMubmVnYXRlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGlkbid0IGdldCBhbnkgaGl0cy4gIHRoaXMgaXMgc3VjY2VzcyBpZiBpdCdzIGEgbmVnYXRpdmVcbiAgICAvLyBwYXR0ZXJuLCBmYWlsdXJlIG90aGVyd2lzZS5cbiAgICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gdGhpcy5uZWdhdGVcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0cyAoZGVmKSB7XG4gICAgcmV0dXJuIG1pbmltYXRjaC5kZWZhdWx0cyhkZWYpLk1pbmltYXRjaFxuICB9XG59XG5cbm1pbmltYXRjaC5NaW5pbWF0Y2ggPSBNaW5pbWF0Y2hcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/minimatch/minimatch.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/node_modules/supports-color/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mocha/node_modules/supports-color/index.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst os = __webpack_require__(/*! os */ \"os\");\nconst tty = __webpack_require__(/*! tty */ \"tty\");\nconst hasFlag = __webpack_require__(/*! has-flag */ \"(ssr)/./node_modules/has-flag/index.js\");\n\nconst {env} = process;\n\nlet flagForceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false') ||\n\thasFlag('color=never')) {\n\tflagForceColor = 0;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tflagForceColor = 1;\n}\n\nfunction envForceColor() {\n\tif ('FORCE_COLOR' in env) {\n\t\tif (env.FORCE_COLOR === 'true') {\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (env.FORCE_COLOR === 'false') {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);\n\t}\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(haveStream, {streamIsTTY, sniffFlags = true} = {}) {\n\tconst noFlagForceColor = envForceColor();\n\tif (noFlagForceColor !== undefined) {\n\t\tflagForceColor = noFlagForceColor;\n\t}\n\n\tconst forceColor = sniffFlags ? flagForceColor : noFlagForceColor;\n\n\tif (forceColor === 0) {\n\t\treturn 0;\n\t}\n\n\tif (sniffFlags) {\n\t\tif (hasFlag('color=16m') ||\n\t\t\thasFlag('color=full') ||\n\t\t\thasFlag('color=truecolor')) {\n\t\t\treturn 3;\n\t\t}\n\n\t\tif (hasFlag('color=256')) {\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\tif (haveStream && !streamIsTTY && forceColor === undefined) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor || 0;\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\t// Windows 10 build 10586 is the first Windows release that supports 256 colors.\n\t\t// Windows 10 build 14931 is the first release that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE', 'DRONE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = Number.parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream, options = {}) {\n\tconst level = supportsColor(stream, {\n\t\tstreamIsTTY: stream && stream.isTTY,\n\t\t...options\n\t});\n\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: getSupportLevel({isTTY: tty.isatty(1)}),\n\tstderr: getSupportLevel({isTTY: tty.isatty(2)})\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL3N1cHBvcnRzLWNvbG9yL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGdCQUFnQixtQkFBTyxDQUFDLHdEQUFVOztBQUVsQyxPQUFPLEtBQUs7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxnQ0FBZ0MsSUFBSTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLEdBQUc7QUFDcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0MsMEJBQTBCLHFCQUFxQjtBQUMvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL3N1cHBvcnRzLWNvbG9yL2luZGV4LmpzPzUxMGQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG5jb25zdCBoYXNGbGFnID0gcmVxdWlyZSgnaGFzLWZsYWcnKTtcblxuY29uc3Qge2Vudn0gPSBwcm9jZXNzO1xuXG5sZXQgZmxhZ0ZvcmNlQ29sb3I7XG5pZiAoaGFzRmxhZygnbm8tY29sb3InKSB8fFxuXHRoYXNGbGFnKCduby1jb2xvcnMnKSB8fFxuXHRoYXNGbGFnKCdjb2xvcj1mYWxzZScpIHx8XG5cdGhhc0ZsYWcoJ2NvbG9yPW5ldmVyJykpIHtcblx0ZmxhZ0ZvcmNlQ29sb3IgPSAwO1xufSBlbHNlIGlmIChoYXNGbGFnKCdjb2xvcicpIHx8XG5cdGhhc0ZsYWcoJ2NvbG9ycycpIHx8XG5cdGhhc0ZsYWcoJ2NvbG9yPXRydWUnKSB8fFxuXHRoYXNGbGFnKCdjb2xvcj1hbHdheXMnKSkge1xuXHRmbGFnRm9yY2VDb2xvciA9IDE7XG59XG5cbmZ1bmN0aW9uIGVudkZvcmNlQ29sb3IoKSB7XG5cdGlmICgnRk9SQ0VfQ09MT1InIGluIGVudikge1xuXHRcdGlmIChlbnYuRk9SQ0VfQ09MT1IgPT09ICd0cnVlJykge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXG5cdFx0aWYgKGVudi5GT1JDRV9DT0xPUiA9PT0gJ2ZhbHNlJykge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVudi5GT1JDRV9DT0xPUi5sZW5ndGggPT09IDAgPyAxIDogTWF0aC5taW4oTnVtYmVyLnBhcnNlSW50KGVudi5GT1JDRV9DT0xPUiwgMTApLCAzKTtcblx0fVxufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVMZXZlbChsZXZlbCkge1xuXHRpZiAobGV2ZWwgPT09IDApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGxldmVsLFxuXHRcdGhhc0Jhc2ljOiB0cnVlLFxuXHRcdGhhczI1NjogbGV2ZWwgPj0gMixcblx0XHRoYXMxNm06IGxldmVsID49IDNcblx0fTtcbn1cblxuZnVuY3Rpb24gc3VwcG9ydHNDb2xvcihoYXZlU3RyZWFtLCB7c3RyZWFtSXNUVFksIHNuaWZmRmxhZ3MgPSB0cnVlfSA9IHt9KSB7XG5cdGNvbnN0IG5vRmxhZ0ZvcmNlQ29sb3IgPSBlbnZGb3JjZUNvbG9yKCk7XG5cdGlmIChub0ZsYWdGb3JjZUNvbG9yICE9PSB1bmRlZmluZWQpIHtcblx0XHRmbGFnRm9yY2VDb2xvciA9IG5vRmxhZ0ZvcmNlQ29sb3I7XG5cdH1cblxuXHRjb25zdCBmb3JjZUNvbG9yID0gc25pZmZGbGFncyA/IGZsYWdGb3JjZUNvbG9yIDogbm9GbGFnRm9yY2VDb2xvcjtcblxuXHRpZiAoZm9yY2VDb2xvciA9PT0gMCkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0aWYgKHNuaWZmRmxhZ3MpIHtcblx0XHRpZiAoaGFzRmxhZygnY29sb3I9MTZtJykgfHxcblx0XHRcdGhhc0ZsYWcoJ2NvbG9yPWZ1bGwnKSB8fFxuXHRcdFx0aGFzRmxhZygnY29sb3I9dHJ1ZWNvbG9yJykpIHtcblx0XHRcdHJldHVybiAzO1xuXHRcdH1cblxuXHRcdGlmIChoYXNGbGFnKCdjb2xvcj0yNTYnKSkge1xuXHRcdFx0cmV0dXJuIDI7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGhhdmVTdHJlYW0gJiYgIXN0cmVhbUlzVFRZICYmIGZvcmNlQ29sb3IgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0Y29uc3QgbWluID0gZm9yY2VDb2xvciB8fCAwO1xuXG5cdGlmIChlbnYuVEVSTSA9PT0gJ2R1bWInKSB7XG5cdFx0cmV0dXJuIG1pbjtcblx0fVxuXG5cdGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG5cdFx0Ly8gV2luZG93cyAxMCBidWlsZCAxMDU4NiBpcyB0aGUgZmlyc3QgV2luZG93cyByZWxlYXNlIHRoYXQgc3VwcG9ydHMgMjU2IGNvbG9ycy5cblx0XHQvLyBXaW5kb3dzIDEwIGJ1aWxkIDE0OTMxIGlzIHRoZSBmaXJzdCByZWxlYXNlIHRoYXQgc3VwcG9ydHMgMTZtL1RydWVDb2xvci5cblx0XHRjb25zdCBvc1JlbGVhc2UgPSBvcy5yZWxlYXNlKCkuc3BsaXQoJy4nKTtcblx0XHRpZiAoXG5cdFx0XHROdW1iZXIob3NSZWxlYXNlWzBdKSA+PSAxMCAmJlxuXHRcdFx0TnVtYmVyKG9zUmVsZWFzZVsyXSkgPj0gMTA1ODZcblx0XHQpIHtcblx0XHRcdHJldHVybiBOdW1iZXIob3NSZWxlYXNlWzJdKSA+PSAxNDkzMSA/IDMgOiAyO1xuXHRcdH1cblxuXHRcdHJldHVybiAxO1xuXHR9XG5cblx0aWYgKCdDSScgaW4gZW52KSB7XG5cdFx0aWYgKFsnVFJBVklTJywgJ0NJUkNMRUNJJywgJ0FQUFZFWU9SJywgJ0dJVExBQl9DSScsICdHSVRIVUJfQUNUSU9OUycsICdCVUlMREtJVEUnLCAnRFJPTkUnXS5zb21lKHNpZ24gPT4gc2lnbiBpbiBlbnYpIHx8IGVudi5DSV9OQU1FID09PSAnY29kZXNoaXAnKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWluO1xuXHR9XG5cblx0aWYgKCdURUFNQ0lUWV9WRVJTSU9OJyBpbiBlbnYpIHtcblx0XHRyZXR1cm4gL14oOVxcLigwKlsxLTldXFxkKilcXC58XFxkezIsfVxcLikvLnRlc3QoZW52LlRFQU1DSVRZX1ZFUlNJT04pID8gMSA6IDA7XG5cdH1cblxuXHRpZiAoZW52LkNPTE9SVEVSTSA9PT0gJ3RydWVjb2xvcicpIHtcblx0XHRyZXR1cm4gMztcblx0fVxuXG5cdGlmICgnVEVSTV9QUk9HUkFNJyBpbiBlbnYpIHtcblx0XHRjb25zdCB2ZXJzaW9uID0gTnVtYmVyLnBhcnNlSW50KChlbnYuVEVSTV9QUk9HUkFNX1ZFUlNJT04gfHwgJycpLnNwbGl0KCcuJylbMF0sIDEwKTtcblxuXHRcdHN3aXRjaCAoZW52LlRFUk1fUFJPR1JBTSkge1xuXHRcdFx0Y2FzZSAnaVRlcm0uYXBwJzpcblx0XHRcdFx0cmV0dXJuIHZlcnNpb24gPj0gMyA/IDMgOiAyO1xuXHRcdFx0Y2FzZSAnQXBwbGVfVGVybWluYWwnOlxuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdC8vIE5vIGRlZmF1bHRcblx0XHR9XG5cdH1cblxuXHRpZiAoLy0yNTYoY29sb3IpPyQvaS50ZXN0KGVudi5URVJNKSkge1xuXHRcdHJldHVybiAyO1xuXHR9XG5cblx0aWYgKC9ec2NyZWVufF54dGVybXxednQxMDB8XnZ0MjIwfF5yeHZ0fGNvbG9yfGFuc2l8Y3lnd2lufGxpbnV4L2kudGVzdChlbnYuVEVSTSkpIHtcblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGlmICgnQ09MT1JURVJNJyBpbiBlbnYpIHtcblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdHJldHVybiBtaW47XG59XG5cbmZ1bmN0aW9uIGdldFN1cHBvcnRMZXZlbChzdHJlYW0sIG9wdGlvbnMgPSB7fSkge1xuXHRjb25zdCBsZXZlbCA9IHN1cHBvcnRzQ29sb3Ioc3RyZWFtLCB7XG5cdFx0c3RyZWFtSXNUVFk6IHN0cmVhbSAmJiBzdHJlYW0uaXNUVFksXG5cdFx0Li4ub3B0aW9uc1xuXHR9KTtcblxuXHRyZXR1cm4gdHJhbnNsYXRlTGV2ZWwobGV2ZWwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0c3VwcG9ydHNDb2xvcjogZ2V0U3VwcG9ydExldmVsLFxuXHRzdGRvdXQ6IGdldFN1cHBvcnRMZXZlbCh7aXNUVFk6IHR0eS5pc2F0dHkoMSl9KSxcblx0c3RkZXJyOiBnZXRTdXBwb3J0TGV2ZWwoe2lzVFRZOiB0dHkuaXNhdHR5KDIpfSlcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/node_modules/supports-color/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/index.js":
/*!*************************************!*\
  !*** ./node_modules/mocha/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = __webpack_require__(/*! ./lib/mocha */ \"(ssr)/./node_modules/mocha/lib/mocha.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0dBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9pbmRleC5qcz8wZGUwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9tb2NoYScpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/cli/collect-files.js":
/*!*****************************************************!*\
  !*** ./node_modules/mocha/lib/cli/collect-files.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst ansi = __webpack_require__(/*! ansi-colors */ \"(ssr)/./node_modules/ansi-colors/index.js\");\nconst debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")('mocha:cli:run:helpers');\nconst minimatch = __webpack_require__(/*! minimatch */ \"(ssr)/./node_modules/mocha/node_modules/minimatch/minimatch.js\");\nconst {NO_FILES_MATCH_PATTERN} = (__webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/mocha/lib/errors.js\").constants);\nconst lookupFiles = __webpack_require__(/*! ./lookup-files */ \"(ssr)/./node_modules/mocha/lib/cli/lookup-files.js\");\nconst {castArray} = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\");\n\n/**\n * Exports a function that collects test files from CLI parameters.\n * @see module:lib/cli/run-helpers\n * @see module:lib/cli/watch-run\n * @module\n * @private\n */\n\n/**\n * Smash together an array of test files in the correct order\n * @param {FileCollectionOptions} [opts] - Options\n * @returns {FileCollectionResponse} An object containing a list of files to test and unmatched files.\n * @private\n */\nmodule.exports = ({\n  ignore,\n  extension,\n  file: fileArgs,\n  recursive,\n  sort,\n  spec\n} = {}) => {\n  const unmatchedSpecFiles = [];\n  const specFiles = spec.reduce((specFiles, arg) => {\n    try {\n      const moreSpecFiles = castArray(lookupFiles(arg, extension, recursive))\n        .filter(filename =>\n          ignore.every(\n            pattern =>\n              !minimatch(filename, pattern, {windowsPathsNoEscape: true})\n          )\n        )\n        .map(filename => path.resolve(filename));\n      return [...specFiles, ...moreSpecFiles];\n    } catch (err) {\n      if (err.code === NO_FILES_MATCH_PATTERN) {\n        unmatchedSpecFiles.push({message: err.message, pattern: err.pattern});\n        return specFiles;\n      }\n\n      throw err;\n    }\n  }, []);\n\n  // check that each file passed in to --file exists\n\n  const unmatchedFiles = [];\n  fileArgs.forEach(file => {\n    const fileAbsolutePath = path.resolve(file);\n    try {\n      // Used instead of fs.existsSync to ensure that file-ending less files are still resolved correctly\n      /*require.resolve*/(__webpack_require__(\"(ssr)/./node_modules/mocha/lib/cli sync recursive\").resolve(fileAbsolutePath));\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') {\n        unmatchedFiles.push({\n          pattern: file,\n          absolutePath: fileAbsolutePath\n        });\n        return;\n      }\n\n      throw err;\n    }\n  });\n\n  // ensure we don't sort the stuff from fileArgs; order is important!\n  if (sort) {\n    specFiles.sort();\n  }\n\n  // add files given through --file to be ran first\n  const files = [\n    ...fileArgs.map(filepath => path.resolve(filepath)),\n    ...specFiles\n  ];\n  debug('test files (in order): ', files);\n\n  if (!files.length) {\n    // give full message details when only 1 file is missing\n    const noneFoundMsg =\n      unmatchedSpecFiles.length === 1\n        ? `Error: No test files found: ${JSON.stringify(\n            unmatchedSpecFiles[0].pattern\n          )}` // stringify to print escaped characters raw\n        : 'Error: No test files found';\n    console.error(ansi.red(noneFoundMsg));\n    process.exit(1);\n  } else {\n    // print messages as a warning\n    unmatchedSpecFiles.forEach(warning => {\n      console.warn(ansi.yellow(`Warning: ${warning.message}`));\n    });\n  }\n\n  return {\n    files,\n    unmatchedFiles\n  };\n};\n\n/**\n * An object to configure how Mocha gathers test files\n * @private\n * @typedef {Object} FileCollectionOptions\n * @property {string[]} extension - File extensions to use\n * @property {string[]} spec - Files, dirs, globs to run\n * @property {string[]} ignore - Files, dirs, globs to ignore\n * @property {string[]} file - List of additional files to include\n * @property {boolean} recursive - Find files recursively\n * @property {boolean} sort - Sort test files\n */\n\n/**\n * Diagnostic object containing unmatched files\n * @typedef {Object} UnmatchedFile -\n * @property {string} absolutePath - A list of unmatched files derived from the file arguments passed in.\n * @property {string} pattern - A list of unmatched files derived from the file arguments passed in.\n *\n */\n\n/**\n * Response object containing a list of files to test and unmatched files.\n * @typedef {Object} FileCollectionResponse\n * @property {string[]} files - A list of files to test\n * @property {UnmatchedFile[]} unmatchedFiles - A list of unmatched files derived from the file arguments passed in.\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2NsaS9jb2xsZWN0LWZpbGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixhQUFhLG1CQUFPLENBQUMsOERBQWE7QUFDbEMsY0FBYyxtQkFBTyxDQUFDLHNEQUFPO0FBQzdCLGtCQUFrQixtQkFBTyxDQUFDLGlGQUFXO0FBQ3JDLE9BQU8sd0JBQXdCLEVBQUUsNEZBQThCO0FBQy9ELG9CQUFvQixtQkFBTyxDQUFDLDBFQUFnQjtBQUM1QyxPQUFPLFdBQVcsRUFBRSxtQkFBTyxDQUFDLHlEQUFVOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkJBQTJCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsaUNBQWlDLDJDQUEyQztBQUM1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1CQUFlLENBQUMsaUdBQWdCO0FBQ3RDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVILG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQjtBQUMzRCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsVUFBVTtBQUN4QixjQUFjLFVBQVU7QUFDeEIsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkI7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFVBQVU7QUFDeEIsY0FBYyxpQkFBaUI7QUFDL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9jbGkvY29sbGVjdC1maWxlcy5qcz9hNDQxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGFuc2kgPSByZXF1aXJlKCdhbnNpLWNvbG9ycycpO1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb2NoYTpjbGk6cnVuOmhlbHBlcnMnKTtcbmNvbnN0IG1pbmltYXRjaCA9IHJlcXVpcmUoJ21pbmltYXRjaCcpO1xuY29uc3Qge05PX0ZJTEVTX01BVENIX1BBVFRFUk59ID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29uc3RhbnRzO1xuY29uc3QgbG9va3VwRmlsZXMgPSByZXF1aXJlKCcuL2xvb2t1cC1maWxlcycpO1xuY29uc3Qge2Nhc3RBcnJheX0gPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIEV4cG9ydHMgYSBmdW5jdGlvbiB0aGF0IGNvbGxlY3RzIHRlc3QgZmlsZXMgZnJvbSBDTEkgcGFyYW1ldGVycy5cbiAqIEBzZWUgbW9kdWxlOmxpYi9jbGkvcnVuLWhlbHBlcnNcbiAqIEBzZWUgbW9kdWxlOmxpYi9jbGkvd2F0Y2gtcnVuXG4gKiBAbW9kdWxlXG4gKiBAcHJpdmF0ZVxuICovXG5cbi8qKlxuICogU21hc2ggdG9nZXRoZXIgYW4gYXJyYXkgb2YgdGVzdCBmaWxlcyBpbiB0aGUgY29ycmVjdCBvcmRlclxuICogQHBhcmFtIHtGaWxlQ29sbGVjdGlvbk9wdGlvbnN9IFtvcHRzXSAtIE9wdGlvbnNcbiAqIEByZXR1cm5zIHtGaWxlQ29sbGVjdGlvblJlc3BvbnNlfSBBbiBvYmplY3QgY29udGFpbmluZyBhIGxpc3Qgb2YgZmlsZXMgdG8gdGVzdCBhbmQgdW5tYXRjaGVkIGZpbGVzLlxuICogQHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAoe1xuICBpZ25vcmUsXG4gIGV4dGVuc2lvbixcbiAgZmlsZTogZmlsZUFyZ3MsXG4gIHJlY3Vyc2l2ZSxcbiAgc29ydCxcbiAgc3BlY1xufSA9IHt9KSA9PiB7XG4gIGNvbnN0IHVubWF0Y2hlZFNwZWNGaWxlcyA9IFtdO1xuICBjb25zdCBzcGVjRmlsZXMgPSBzcGVjLnJlZHVjZSgoc3BlY0ZpbGVzLCBhcmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbW9yZVNwZWNGaWxlcyA9IGNhc3RBcnJheShsb29rdXBGaWxlcyhhcmcsIGV4dGVuc2lvbiwgcmVjdXJzaXZlKSlcbiAgICAgICAgLmZpbHRlcihmaWxlbmFtZSA9PlxuICAgICAgICAgIGlnbm9yZS5ldmVyeShcbiAgICAgICAgICAgIHBhdHRlcm4gPT5cbiAgICAgICAgICAgICAgIW1pbmltYXRjaChmaWxlbmFtZSwgcGF0dGVybiwge3dpbmRvd3NQYXRoc05vRXNjYXBlOiB0cnVlfSlcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICAgLm1hcChmaWxlbmFtZSA9PiBwYXRoLnJlc29sdmUoZmlsZW5hbWUpKTtcbiAgICAgIHJldHVybiBbLi4uc3BlY0ZpbGVzLCAuLi5tb3JlU3BlY0ZpbGVzXTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gTk9fRklMRVNfTUFUQ0hfUEFUVEVSTikge1xuICAgICAgICB1bm1hdGNoZWRTcGVjRmlsZXMucHVzaCh7bWVzc2FnZTogZXJyLm1lc3NhZ2UsIHBhdHRlcm46IGVyci5wYXR0ZXJufSk7XG4gICAgICAgIHJldHVybiBzcGVjRmlsZXM7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyBjaGVjayB0aGF0IGVhY2ggZmlsZSBwYXNzZWQgaW4gdG8gLS1maWxlIGV4aXN0c1xuXG4gIGNvbnN0IHVubWF0Y2hlZEZpbGVzID0gW107XG4gIGZpbGVBcmdzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgY29uc3QgZmlsZUFic29sdXRlUGF0aCA9IHBhdGgucmVzb2x2ZShmaWxlKTtcbiAgICB0cnkge1xuICAgICAgLy8gVXNlZCBpbnN0ZWFkIG9mIGZzLmV4aXN0c1N5bmMgdG8gZW5zdXJlIHRoYXQgZmlsZS1lbmRpbmcgbGVzcyBmaWxlcyBhcmUgc3RpbGwgcmVzb2x2ZWQgY29ycmVjdGx5XG4gICAgICByZXF1aXJlLnJlc29sdmUoZmlsZUFic29sdXRlUGF0aCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLmNvZGUgPT09ICdNT0RVTEVfTk9UX0ZPVU5EJykge1xuICAgICAgICB1bm1hdGNoZWRGaWxlcy5wdXNoKHtcbiAgICAgICAgICBwYXR0ZXJuOiBmaWxlLFxuICAgICAgICAgIGFic29sdXRlUGF0aDogZmlsZUFic29sdXRlUGF0aFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9KTtcblxuICAvLyBlbnN1cmUgd2UgZG9uJ3Qgc29ydCB0aGUgc3R1ZmYgZnJvbSBmaWxlQXJnczsgb3JkZXIgaXMgaW1wb3J0YW50IVxuICBpZiAoc29ydCkge1xuICAgIHNwZWNGaWxlcy5zb3J0KCk7XG4gIH1cblxuICAvLyBhZGQgZmlsZXMgZ2l2ZW4gdGhyb3VnaCAtLWZpbGUgdG8gYmUgcmFuIGZpcnN0XG4gIGNvbnN0IGZpbGVzID0gW1xuICAgIC4uLmZpbGVBcmdzLm1hcChmaWxlcGF0aCA9PiBwYXRoLnJlc29sdmUoZmlsZXBhdGgpKSxcbiAgICAuLi5zcGVjRmlsZXNcbiAgXTtcbiAgZGVidWcoJ3Rlc3QgZmlsZXMgKGluIG9yZGVyKTogJywgZmlsZXMpO1xuXG4gIGlmICghZmlsZXMubGVuZ3RoKSB7XG4gICAgLy8gZ2l2ZSBmdWxsIG1lc3NhZ2UgZGV0YWlscyB3aGVuIG9ubHkgMSBmaWxlIGlzIG1pc3NpbmdcbiAgICBjb25zdCBub25lRm91bmRNc2cgPVxuICAgICAgdW5tYXRjaGVkU3BlY0ZpbGVzLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IGBFcnJvcjogTm8gdGVzdCBmaWxlcyBmb3VuZDogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIHVubWF0Y2hlZFNwZWNGaWxlc1swXS5wYXR0ZXJuXG4gICAgICAgICAgKX1gIC8vIHN0cmluZ2lmeSB0byBwcmludCBlc2NhcGVkIGNoYXJhY3RlcnMgcmF3XG4gICAgICAgIDogJ0Vycm9yOiBObyB0ZXN0IGZpbGVzIGZvdW5kJztcbiAgICBjb25zb2xlLmVycm9yKGFuc2kucmVkKG5vbmVGb3VuZE1zZykpO1xuICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBwcmludCBtZXNzYWdlcyBhcyBhIHdhcm5pbmdcbiAgICB1bm1hdGNoZWRTcGVjRmlsZXMuZm9yRWFjaCh3YXJuaW5nID0+IHtcbiAgICAgIGNvbnNvbGUud2FybihhbnNpLnllbGxvdyhgV2FybmluZzogJHt3YXJuaW5nLm1lc3NhZ2V9YCkpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmaWxlcyxcbiAgICB1bm1hdGNoZWRGaWxlc1xuICB9O1xufTtcblxuLyoqXG4gKiBBbiBvYmplY3QgdG8gY29uZmlndXJlIGhvdyBNb2NoYSBnYXRoZXJzIHRlc3QgZmlsZXNcbiAqIEBwcml2YXRlXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGaWxlQ29sbGVjdGlvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IGV4dGVuc2lvbiAtIEZpbGUgZXh0ZW5zaW9ucyB0byB1c2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHNwZWMgLSBGaWxlcywgZGlycywgZ2xvYnMgdG8gcnVuXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBpZ25vcmUgLSBGaWxlcywgZGlycywgZ2xvYnMgdG8gaWdub3JlXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBmaWxlIC0gTGlzdCBvZiBhZGRpdGlvbmFsIGZpbGVzIHRvIGluY2x1ZGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcmVjdXJzaXZlIC0gRmluZCBmaWxlcyByZWN1cnNpdmVseVxuICogQHByb3BlcnR5IHtib29sZWFufSBzb3J0IC0gU29ydCB0ZXN0IGZpbGVzXG4gKi9cblxuLyoqXG4gKiBEaWFnbm9zdGljIG9iamVjdCBjb250YWluaW5nIHVubWF0Y2hlZCBmaWxlc1xuICogQHR5cGVkZWYge09iamVjdH0gVW5tYXRjaGVkRmlsZSAtXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYWJzb2x1dGVQYXRoIC0gQSBsaXN0IG9mIHVubWF0Y2hlZCBmaWxlcyBkZXJpdmVkIGZyb20gdGhlIGZpbGUgYXJndW1lbnRzIHBhc3NlZCBpbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwYXR0ZXJuIC0gQSBsaXN0IG9mIHVubWF0Y2hlZCBmaWxlcyBkZXJpdmVkIGZyb20gdGhlIGZpbGUgYXJndW1lbnRzIHBhc3NlZCBpbi5cbiAqXG4gKi9cblxuLyoqXG4gKiBSZXNwb25zZSBvYmplY3QgY29udGFpbmluZyBhIGxpc3Qgb2YgZmlsZXMgdG8gdGVzdCBhbmQgdW5tYXRjaGVkIGZpbGVzLlxuICogQHR5cGVkZWYge09iamVjdH0gRmlsZUNvbGxlY3Rpb25SZXNwb25zZVxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gZmlsZXMgLSBBIGxpc3Qgb2YgZmlsZXMgdG8gdGVzdFxuICogQHByb3BlcnR5IHtVbm1hdGNoZWRGaWxlW119IHVubWF0Y2hlZEZpbGVzIC0gQSBsaXN0IG9mIHVubWF0Y2hlZCBmaWxlcyBkZXJpdmVkIGZyb20gdGhlIGZpbGUgYXJndW1lbnRzIHBhc3NlZCBpbi5cbiAqL1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/cli/collect-files.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/cli/lookup-files.js":
/*!****************************************************!*\
  !*** ./node_modules/mocha/lib/cli/lookup-files.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * Contains `lookupFiles`, which takes some globs/dirs/options and returns a list of files.\n * @module\n * @private\n */\n\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar glob = __webpack_require__(/*! glob */ \"(ssr)/./node_modules/mocha/node_modules/glob/glob.js\");\nvar errors = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/mocha/lib/errors.js\");\nvar createNoFilesMatchPatternError = errors.createNoFilesMatchPatternError;\nvar createMissingArgumentError = errors.createMissingArgumentError;\nconst debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")('mocha:cli:lookup-files');\n\n/**\n * Determines if pathname would be a \"hidden\" file (or directory) on UN*X.\n *\n * @description\n * On UN*X, pathnames beginning with a full stop (aka dot) are hidden during\n * typical usage. Dotfiles, plain-text configuration files, are prime examples.\n *\n * @see {@link http://xahlee.info/UnixResource_dir/writ/unix_origin_of_dot_filename.html|Origin of Dot File Names}\n *\n * @private\n * @param {string} pathname - Pathname to check for match.\n * @return {boolean} whether pathname would be considered a hidden file.\n * @example\n * isHiddenOnUnix('.profile'); // => true\n */\nconst isHiddenOnUnix = pathname => path.basename(pathname).startsWith('.');\n\n/**\n * Determines if pathname has a matching file extension.\n *\n * Supports multi-part extensions.\n *\n * @private\n * @param {string} pathname - Pathname to check for match.\n * @param {string[]} exts - List of file extensions, w/-or-w/o leading period\n * @return {boolean} `true` if file extension matches.\n * @example\n * hasMatchingExtname('foo.html', ['js', 'css']); // false\n * hasMatchingExtname('foo.js', ['.js']); // true\n * hasMatchingExtname('foo.js', ['js']); // ture\n */\nconst hasMatchingExtname = (pathname, exts = []) =>\n  exts\n    .map(ext => (ext.startsWith('.') ? ext : `.${ext}`))\n    .some(ext => pathname.endsWith(ext));\n\n/**\n * Lookup file names at the given `path`.\n *\n * @description\n * Filenames are returned in _traversal_ order by the OS/filesystem.\n * **Make no assumption that the names will be sorted in any fashion.**\n *\n * @public\n * @alias module:lib/cli.lookupFiles\n * @param {string} filepath - Base path to start searching from.\n * @param {string[]} [extensions=[]] - File extensions to look for.\n * @param {boolean} [recursive=false] - Whether to recurse into subdirectories.\n * @return {string[]} An array of paths.\n * @throws {Error} if no files match pattern.\n * @throws {TypeError} if `filepath` is directory and `extensions` not provided.\n */\nmodule.exports = function lookupFiles(\n  filepath,\n  extensions = [],\n  recursive = false\n) {\n  const files = [];\n  let stat;\n\n  if (!fs.existsSync(filepath)) {\n    let pattern;\n    if (glob.hasMagic(filepath, {windowsPathsNoEscape: true})) {\n      // Handle glob as is without extensions\n      pattern = filepath;\n    } else {\n      // glob pattern e.g. 'filepath+(.js|.ts)'\n      const strExtensions = extensions\n        .map(ext => (ext.startsWith('.') ? ext : `.${ext}`))\n        .join('|');\n      pattern = `${filepath}+(${strExtensions})`;\n      debug('looking for files using glob pattern: %s', pattern);\n    }\n    files.push(\n      ...glob.sync(pattern, {\n        nodir: true,\n        windowsPathsNoEscape: true\n      })\n    );\n    if (!files.length) {\n      throw createNoFilesMatchPatternError(\n        `Cannot find any files matching pattern \"${filepath}\"`,\n        filepath\n      );\n    }\n    return files;\n  }\n\n  // Handle file\n  try {\n    stat = fs.statSync(filepath);\n    if (stat.isFile()) {\n      return filepath;\n    }\n  } catch (err) {\n    // ignore error\n    return;\n  }\n\n  // Handle directory\n  fs.readdirSync(filepath).forEach(dirent => {\n    const pathname = path.join(filepath, dirent);\n    let stat;\n\n    try {\n      stat = fs.statSync(pathname);\n      if (stat.isDirectory()) {\n        if (recursive) {\n          files.push(...lookupFiles(pathname, extensions, recursive));\n        }\n        return;\n      }\n    } catch (ignored) {\n      return;\n    }\n    if (!extensions.length) {\n      throw createMissingArgumentError(\n        `Argument '${extensions}' required when argument '${filepath}' is a directory`,\n        'extensions',\n        'array'\n      );\n    }\n\n    if (\n      !stat.isFile() ||\n      !hasMatchingExtname(pathname, extensions) ||\n      isHiddenOnUnix(pathname)\n    ) {\n      return;\n    }\n    files.push(pathname);\n  });\n\n  return files;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2NsaS9sb29rdXAtZmlsZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsbUJBQU8sQ0FBQyxjQUFJO0FBQ3JCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixXQUFXLG1CQUFPLENBQUMsa0VBQU07QUFDekIsYUFBYSxtQkFBTyxDQUFDLDJEQUFXO0FBQ2hDO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsc0RBQU87O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixZQUFZLFNBQVM7QUFDckI7QUFDQSxrREFBa0Q7QUFDbEQsMENBQTBDO0FBQzFDLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxpREFBaUQsSUFBSTtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsU0FBUztBQUNwQixZQUFZLFVBQVU7QUFDdEIsWUFBWSxPQUFPO0FBQ25CLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsMkJBQTJCO0FBQzVEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHFEQUFxRCxJQUFJO0FBQ3pEO0FBQ0EsbUJBQW1CLFNBQVMsSUFBSSxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXLDRCQUE0QixTQUFTO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9jbGkvbG9va3VwLWZpbGVzLmpzPzhlMzEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBDb250YWlucyBgbG9va3VwRmlsZXNgLCB3aGljaCB0YWtlcyBzb21lIGdsb2JzL2RpcnMvb3B0aW9ucyBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgZmlsZXMuXG4gKiBAbW9kdWxlXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBnbG9iID0gcmVxdWlyZSgnZ2xvYicpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xudmFyIGNyZWF0ZU5vRmlsZXNNYXRjaFBhdHRlcm5FcnJvciA9IGVycm9ycy5jcmVhdGVOb0ZpbGVzTWF0Y2hQYXR0ZXJuRXJyb3I7XG52YXIgY3JlYXRlTWlzc2luZ0FyZ3VtZW50RXJyb3IgPSBlcnJvcnMuY3JlYXRlTWlzc2luZ0FyZ3VtZW50RXJyb3I7XG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21vY2hhOmNsaTpsb29rdXAtZmlsZXMnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHBhdGhuYW1lIHdvdWxkIGJlIGEgXCJoaWRkZW5cIiBmaWxlIChvciBkaXJlY3RvcnkpIG9uIFVOKlguXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBPbiBVTipYLCBwYXRobmFtZXMgYmVnaW5uaW5nIHdpdGggYSBmdWxsIHN0b3AgKGFrYSBkb3QpIGFyZSBoaWRkZW4gZHVyaW5nXG4gKiB0eXBpY2FsIHVzYWdlLiBEb3RmaWxlcywgcGxhaW4tdGV4dCBjb25maWd1cmF0aW9uIGZpbGVzLCBhcmUgcHJpbWUgZXhhbXBsZXMuXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3hhaGxlZS5pbmZvL1VuaXhSZXNvdXJjZV9kaXIvd3JpdC91bml4X29yaWdpbl9vZl9kb3RfZmlsZW5hbWUuaHRtbHxPcmlnaW4gb2YgRG90IEZpbGUgTmFtZXN9XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRobmFtZSAtIFBhdGhuYW1lIHRvIGNoZWNrIGZvciBtYXRjaC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgcGF0aG5hbWUgd291bGQgYmUgY29uc2lkZXJlZCBhIGhpZGRlbiBmaWxlLlxuICogQGV4YW1wbGVcbiAqIGlzSGlkZGVuT25Vbml4KCcucHJvZmlsZScpOyAvLyA9PiB0cnVlXG4gKi9cbmNvbnN0IGlzSGlkZGVuT25Vbml4ID0gcGF0aG5hbWUgPT4gcGF0aC5iYXNlbmFtZShwYXRobmFtZSkuc3RhcnRzV2l0aCgnLicpO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgcGF0aG5hbWUgaGFzIGEgbWF0Y2hpbmcgZmlsZSBleHRlbnNpb24uXG4gKlxuICogU3VwcG9ydHMgbXVsdGktcGFydCBleHRlbnNpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aG5hbWUgLSBQYXRobmFtZSB0byBjaGVjayBmb3IgbWF0Y2guXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBleHRzIC0gTGlzdCBvZiBmaWxlIGV4dGVuc2lvbnMsIHcvLW9yLXcvbyBsZWFkaW5nIHBlcmlvZFxuICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGZpbGUgZXh0ZW5zaW9uIG1hdGNoZXMuXG4gKiBAZXhhbXBsZVxuICogaGFzTWF0Y2hpbmdFeHRuYW1lKCdmb28uaHRtbCcsIFsnanMnLCAnY3NzJ10pOyAvLyBmYWxzZVxuICogaGFzTWF0Y2hpbmdFeHRuYW1lKCdmb28uanMnLCBbJy5qcyddKTsgLy8gdHJ1ZVxuICogaGFzTWF0Y2hpbmdFeHRuYW1lKCdmb28uanMnLCBbJ2pzJ10pOyAvLyB0dXJlXG4gKi9cbmNvbnN0IGhhc01hdGNoaW5nRXh0bmFtZSA9IChwYXRobmFtZSwgZXh0cyA9IFtdKSA9PlxuICBleHRzXG4gICAgLm1hcChleHQgPT4gKGV4dC5zdGFydHNXaXRoKCcuJykgPyBleHQgOiBgLiR7ZXh0fWApKVxuICAgIC5zb21lKGV4dCA9PiBwYXRobmFtZS5lbmRzV2l0aChleHQpKTtcblxuLyoqXG4gKiBMb29rdXAgZmlsZSBuYW1lcyBhdCB0aGUgZ2l2ZW4gYHBhdGhgLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogRmlsZW5hbWVzIGFyZSByZXR1cm5lZCBpbiBfdHJhdmVyc2FsXyBvcmRlciBieSB0aGUgT1MvZmlsZXN5c3RlbS5cbiAqICoqTWFrZSBubyBhc3N1bXB0aW9uIHRoYXQgdGhlIG5hbWVzIHdpbGwgYmUgc29ydGVkIGluIGFueSBmYXNoaW9uLioqXG4gKlxuICogQHB1YmxpY1xuICogQGFsaWFzIG1vZHVsZTpsaWIvY2xpLmxvb2t1cEZpbGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZXBhdGggLSBCYXNlIHBhdGggdG8gc3RhcnQgc2VhcmNoaW5nIGZyb20uXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbZXh0ZW5zaW9ucz1bXV0gLSBGaWxlIGV4dGVuc2lvbnMgdG8gbG9vayBmb3IuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWN1cnNpdmU9ZmFsc2VdIC0gV2hldGhlciB0byByZWN1cnNlIGludG8gc3ViZGlyZWN0b3JpZXMuXG4gKiBAcmV0dXJuIHtzdHJpbmdbXX0gQW4gYXJyYXkgb2YgcGF0aHMuXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm8gZmlsZXMgbWF0Y2ggcGF0dGVybi5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgYGZpbGVwYXRoYCBpcyBkaXJlY3RvcnkgYW5kIGBleHRlbnNpb25zYCBub3QgcHJvdmlkZWQuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbG9va3VwRmlsZXMoXG4gIGZpbGVwYXRoLFxuICBleHRlbnNpb25zID0gW10sXG4gIHJlY3Vyc2l2ZSA9IGZhbHNlXG4pIHtcbiAgY29uc3QgZmlsZXMgPSBbXTtcbiAgbGV0IHN0YXQ7XG5cbiAgaWYgKCFmcy5leGlzdHNTeW5jKGZpbGVwYXRoKSkge1xuICAgIGxldCBwYXR0ZXJuO1xuICAgIGlmIChnbG9iLmhhc01hZ2ljKGZpbGVwYXRoLCB7d2luZG93c1BhdGhzTm9Fc2NhcGU6IHRydWV9KSkge1xuICAgICAgLy8gSGFuZGxlIGdsb2IgYXMgaXMgd2l0aG91dCBleHRlbnNpb25zXG4gICAgICBwYXR0ZXJuID0gZmlsZXBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdsb2IgcGF0dGVybiBlLmcuICdmaWxlcGF0aCsoLmpzfC50cyknXG4gICAgICBjb25zdCBzdHJFeHRlbnNpb25zID0gZXh0ZW5zaW9uc1xuICAgICAgICAubWFwKGV4dCA9PiAoZXh0LnN0YXJ0c1dpdGgoJy4nKSA/IGV4dCA6IGAuJHtleHR9YCkpXG4gICAgICAgIC5qb2luKCd8Jyk7XG4gICAgICBwYXR0ZXJuID0gYCR7ZmlsZXBhdGh9Kygke3N0ckV4dGVuc2lvbnN9KWA7XG4gICAgICBkZWJ1ZygnbG9va2luZyBmb3IgZmlsZXMgdXNpbmcgZ2xvYiBwYXR0ZXJuOiAlcycsIHBhdHRlcm4pO1xuICAgIH1cbiAgICBmaWxlcy5wdXNoKFxuICAgICAgLi4uZ2xvYi5zeW5jKHBhdHRlcm4sIHtcbiAgICAgICAgbm9kaXI6IHRydWUsXG4gICAgICAgIHdpbmRvd3NQYXRoc05vRXNjYXBlOiB0cnVlXG4gICAgICB9KVxuICAgICk7XG4gICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IGNyZWF0ZU5vRmlsZXNNYXRjaFBhdHRlcm5FcnJvcihcbiAgICAgICAgYENhbm5vdCBmaW5kIGFueSBmaWxlcyBtYXRjaGluZyBwYXR0ZXJuIFwiJHtmaWxlcGF0aH1cImAsXG4gICAgICAgIGZpbGVwYXRoXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZmlsZXM7XG4gIH1cblxuICAvLyBIYW5kbGUgZmlsZVxuICB0cnkge1xuICAgIHN0YXQgPSBmcy5zdGF0U3luYyhmaWxlcGF0aCk7XG4gICAgaWYgKHN0YXQuaXNGaWxlKCkpIHtcbiAgICAgIHJldHVybiBmaWxlcGF0aDtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIGlnbm9yZSBlcnJvclxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEhhbmRsZSBkaXJlY3RvcnlcbiAgZnMucmVhZGRpclN5bmMoZmlsZXBhdGgpLmZvckVhY2goZGlyZW50ID0+IHtcbiAgICBjb25zdCBwYXRobmFtZSA9IHBhdGguam9pbihmaWxlcGF0aCwgZGlyZW50KTtcbiAgICBsZXQgc3RhdDtcblxuICAgIHRyeSB7XG4gICAgICBzdGF0ID0gZnMuc3RhdFN5bmMocGF0aG5hbWUpO1xuICAgICAgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICAgICAgZmlsZXMucHVzaCguLi5sb29rdXBGaWxlcyhwYXRobmFtZSwgZXh0ZW5zaW9ucywgcmVjdXJzaXZlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFleHRlbnNpb25zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgY3JlYXRlTWlzc2luZ0FyZ3VtZW50RXJyb3IoXG4gICAgICAgIGBBcmd1bWVudCAnJHtleHRlbnNpb25zfScgcmVxdWlyZWQgd2hlbiBhcmd1bWVudCAnJHtmaWxlcGF0aH0nIGlzIGEgZGlyZWN0b3J5YCxcbiAgICAgICAgJ2V4dGVuc2lvbnMnLFxuICAgICAgICAnYXJyYXknXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICFzdGF0LmlzRmlsZSgpIHx8XG4gICAgICAhaGFzTWF0Y2hpbmdFeHRuYW1lKHBhdGhuYW1lLCBleHRlbnNpb25zKSB8fFxuICAgICAgaXNIaWRkZW5PblVuaXgocGF0aG5hbWUpXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpbGVzLnB1c2gocGF0aG5hbWUpO1xuICB9KTtcblxuICByZXR1cm4gZmlsZXM7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/cli/lookup-files.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/cli/run-helpers.js":
/*!***************************************************!*\
  !*** ./node_modules/mocha/lib/cli/run-helpers.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n * Helper scripts for the `run` command\n * @see module:lib/cli/run\n * @module\n * @private\n */\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst ansi = __webpack_require__(/*! ansi-colors */ \"(ssr)/./node_modules/ansi-colors/index.js\");\nconst debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")('mocha:cli:run:helpers');\nconst {watchRun, watchParallelRun} = __webpack_require__(/*! ./watch-run */ \"(ssr)/./node_modules/mocha/lib/cli/watch-run.js\");\nconst collectFiles = __webpack_require__(/*! ./collect-files */ \"(ssr)/./node_modules/mocha/lib/cli/collect-files.js\");\nconst {format} = __webpack_require__(/*! util */ \"util\");\nconst {createInvalidLegacyPluginError} = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/mocha/lib/errors.js\");\nconst {requireOrImport} = __webpack_require__(/*! ../nodejs/esm-utils */ \"(ssr)/./node_modules/mocha/lib/nodejs/esm-utils.js\");\nconst PluginLoader = __webpack_require__(/*! ../plugin-loader */ \"(ssr)/./node_modules/mocha/lib/plugin-loader.js\");\nconst {UnmatchedFile} = __webpack_require__(/*! ./collect-files */ \"(ssr)/./node_modules/mocha/lib/cli/collect-files.js\");\n\n/**\n * Exits Mocha when tests + code under test has finished execution (default)\n * @param {number} clampedCode - Exit code; typically # of failures\n * @ignore\n * @private\n */\nconst exitMochaLater = clampedCode => {\n  process.on('exit', () => {\n    process.exitCode = clampedCode;\n  });\n};\n\n/**\n * Exits Mocha when Mocha itself has finished execution, regardless of\n * what the tests or code under test is doing.\n * @param {number} clampedCode - Exit code; typically # of failures\n * @ignore\n * @private\n */\nconst exitMocha = clampedCode => {\n  let draining = 0;\n\n  // Eagerly set the process's exit code in case stream.write doesn't\n  // execute its callback before the process terminates.\n  process.exitCode = clampedCode;\n\n  // flush output for Node.js Windows pipe bug\n  // https://github.com/joyent/node/issues/6247 is just one bug example\n  // https://github.com/visionmedia/mocha/issues/333 has a good discussion\n  const done = () => {\n    if (!draining--) {\n      process.exit(clampedCode);\n    }\n  };\n\n  const streams = [process.stdout, process.stderr];\n\n  streams.forEach(stream => {\n    // submit empty write request and wait for completion\n    draining += 1;\n    stream.write('', done);\n  });\n\n  done();\n};\n\n/**\n * Coerce a comma-delimited string (or array thereof) into a flattened array of\n * strings\n * @param {string|string[]} str - Value to coerce\n * @returns {string[]} Array of strings\n * @private\n */\nexports.list = str =>\n  Array.isArray(str) ? exports.list(str.join(',')) : str.split(/ *, */);\n\n/**\n * `require()` the modules as required by `--require <require>`.\n *\n * Returns array of `mochaHooks` exports, if any.\n * @param {string[]} requires - Modules to require\n * @returns {Promise<object>} Plugin implementations\n * @private\n */\nexports.handleRequires = async (requires = [], {ignoredPlugins = []} = {}) => {\n  const pluginLoader = PluginLoader.create({ignore: ignoredPlugins});\n  for await (const mod of requires) {\n    let modpath = mod;\n    // this is relative to cwd\n    if (fs.existsSync(mod) || fs.existsSync(`${mod}.js`)) {\n      modpath = path.resolve(mod);\n      debug('resolved required file %s to %s', mod, modpath);\n    }\n    const requiredModule = await requireOrImport(modpath);\n    if (requiredModule && typeof requiredModule === 'object') {\n      if (pluginLoader.load(requiredModule)) {\n        debug('found one or more plugin implementations in %s', modpath);\n      }\n    }\n    debug('loaded required module \"%s\"', mod);\n  }\n  const plugins = await pluginLoader.finalize();\n  if (Object.keys(plugins).length) {\n    debug('finalized plugin implementations: %O', plugins);\n  }\n  return plugins;\n};\n\n/**\n * Logs errors and exits the app if unmatched files exist\n * @param {Mocha} mocha - Mocha instance\n * @param {UnmatchedFile} unmatchedFiles - object containing unmatched file paths\n * @returns {Promise<Runner>}\n * @private\n */\nconst handleUnmatchedFiles = (mocha, unmatchedFiles) => {\n  if (unmatchedFiles.length === 0) {\n    return;\n  }\n\n  unmatchedFiles.forEach(({pattern, absolutePath}) => {\n    console.error(\n      ansi.yellow(\n        `Warning: Cannot find any files matching pattern \"${pattern}\" at the absolute path \"${absolutePath}\"`\n      )\n    );\n  });\n  console.log(\n    'No test file(s) found with the given pattern, exiting with code 1'\n  );\n\n  return mocha.run(exitMocha(1));\n};\n\n/**\n * Collect and load test files, then run mocha instance.\n * @param {Mocha} mocha - Mocha instance\n * @param {Options} [opts] - Command line options\n * @param {boolean} [opts.exit] - Whether or not to force-exit after tests are complete\n * @param {boolean} [opts.passOnFailingTestSuite] - Whether or not to fail test run if tests were failed\n * @param {Object} fileCollectParams - Parameters that control test\n *   file collection. See `lib/cli/collect-files.js`.\n * @returns {Promise<Runner>}\n * @private\n */\nconst singleRun = async (\n  mocha,\n  {exit, passOnFailingTestSuite},\n  fileCollectParams\n) => {\n  const fileCollectionObj = collectFiles(fileCollectParams);\n\n  if (fileCollectionObj.unmatchedFiles.length > 0) {\n    return handleUnmatchedFiles(mocha, fileCollectionObj.unmatchedFiles);\n  }\n\n  debug('single run with %d file(s)', fileCollectionObj.files.length);\n  mocha.files = fileCollectionObj.files;\n\n  // handles ESM modules\n  await mocha.loadFilesAsync();\n  return mocha.run(\n    createExitHandler({exit, passOnFailingTestSuite})\n  );\n};\n\n/**\n * Collect files and run tests (using `BufferedRunner`).\n *\n * This is `async` for consistency.\n *\n * @param {Mocha} mocha - Mocha instance\n * @param {Options} options - Command line options\n * @param {Object} fileCollectParams - Parameters that control test\n *   file collection. See `lib/cli/collect-files.js`.\n * @returns {Promise<BufferedRunner>}\n * @ignore\n * @private\n */\nconst parallelRun = async (mocha, options, fileCollectParams) => {\n  const fileCollectionObj = collectFiles(fileCollectParams);\n\n  if (fileCollectionObj.unmatchedFiles.length > 0) {\n    return handleUnmatchedFiles(mocha, fileCollectionObj.unmatchedFiles);\n  }\n\n  debug(\n    'executing %d test file(s) in parallel mode',\n    fileCollectionObj.files.length\n  );\n  mocha.files = fileCollectionObj.files;\n\n  // note that we DO NOT load any files here; this is handled by the worker\n  return mocha.run(\n    createExitHandler(options)\n  );\n};\n\n/**\n * Actually run tests.  Delegates to one of four different functions:\n * - `singleRun`: run tests in serial & exit\n * - `watchRun`: run tests in serial, rerunning as files change\n * - `parallelRun`: run tests in parallel & exit\n * - `watchParallelRun`: run tests in parallel, rerunning as files change\n * @param {Mocha} mocha - Mocha instance\n * @param {Options} opts - Command line options\n * @private\n * @returns {Promise<Runner>}\n */\nexports.runMocha = async (mocha, options) => {\n  const {\n    watch = false,\n    extension = [],\n    ignore = [],\n    file = [],\n    parallel = false,\n    recursive = false,\n    sort = false,\n    spec = []\n  } = options;\n\n  const fileCollectParams = {\n    ignore,\n    extension,\n    file,\n    recursive,\n    sort,\n    spec\n  };\n\n  let run;\n  if (watch) {\n    run = parallel ? watchParallelRun : watchRun;\n  } else {\n    run = parallel ? parallelRun : singleRun;\n  }\n\n  return run(mocha, options, fileCollectParams);\n};\n\n/**\n * Used for `--reporter` and `--ui`.  Ensures there's only one, and asserts that\n * it actually exists. This must be run _after_ requires are processed (see\n * {@link handleRequires}), as it'll prevent interfaces from loading otherwise.\n * @param {Object} opts - Options object\n * @param {\"reporter\"|\"ui\"} pluginType - Type of plugin.\n * @param {Object} [map] - Used as a cache of sorts;\n * `Mocha.reporters` where each key corresponds to a reporter name,\n * `Mocha.interfaces` where each key corresponds to an interface name.\n * @private\n */\nexports.validateLegacyPlugin = (opts, pluginType, map = {}) => {\n  /**\n   * This should be a unique identifier; either a string (present in `map`),\n   * or a resolvable (via `require.resolve`) module ID/path.\n   * @type {string}\n   */\n  const pluginId = opts[pluginType];\n\n  if (Array.isArray(pluginId)) {\n    throw createInvalidLegacyPluginError(\n      `\"--${pluginType}\" can only be specified once`,\n      pluginType\n    );\n  }\n\n  const createUnknownError = err =>\n    createInvalidLegacyPluginError(\n      format('Could not load %s \"%s\":\\n\\n %O', pluginType, pluginId, err),\n      pluginType,\n      pluginId\n    );\n\n  // if this exists, then it's already loaded, so nothing more to do.\n  if (!map[pluginId]) {\n    let foundId;\n    try {\n      foundId = /*require.resolve*/(__webpack_require__(\"(ssr)/./node_modules/mocha/lib/cli sync recursive\").resolve(pluginId));\n      map[pluginId] = __webpack_require__(\"(ssr)/./node_modules/mocha/lib/cli sync recursive\")(foundId);\n    } catch (err) {\n      if (foundId) throw createUnknownError(err);\n\n      // Try to load reporters from a cwd-relative path\n      try {\n        map[pluginId] = __webpack_require__(\"(ssr)/./node_modules/mocha/lib/cli sync recursive\")(path.resolve(pluginId));\n      } catch (e) {\n        throw createUnknownError(e);\n      }\n    }\n  }\n};\n\nconst createExitHandler = ({ exit, passOnFailingTestSuite }) => {\n  return code => {\n    const clampedCode = passOnFailingTestSuite\n      ? 0\n      : Math.min(code, 255);\n\n    return exit\n      ? exitMocha(clampedCode)\n      : exitMochaLater(clampedCode);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2NsaS9ydW4taGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGFBQWEsbUJBQU8sQ0FBQyw4REFBYTtBQUNsQyxjQUFjLG1CQUFPLENBQUMsc0RBQU87QUFDN0IsT0FBTyw0QkFBNEIsRUFBRSxtQkFBTyxDQUFDLG9FQUFhO0FBQzFELHFCQUFxQixtQkFBTyxDQUFDLDRFQUFpQjtBQUM5QyxPQUFPLFFBQVEsRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQy9CLE9BQU8sZ0NBQWdDLEVBQUUsbUJBQU8sQ0FBQywyREFBVztBQUM1RCxPQUFPLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsK0VBQXFCO0FBQ3ZELHFCQUFxQixtQkFBTyxDQUFDLHlFQUFrQjtBQUMvQyxPQUFPLGVBQWUsRUFBRSxtQkFBTyxDQUFDLDRFQUFpQjs7QUFFakQ7QUFDQTtBQUNBLFdBQVcsUUFBUSx5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUSx5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQixxQkFBcUIsSUFBSTtBQUN6RSw0Q0FBNEMsdUJBQXVCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxJQUFJO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQSw0REFBNEQsUUFBUSwwQkFBMEIsYUFBYTtBQUMzRztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw2QkFBNkI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBLGFBQWE7QUFDYjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBLHlDQUF5QztBQUN6QztBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBZSxDQUFDLHlGQUFRO0FBQ3hDLHNCQUFzQix5RUFBUSxPQUFPLENBQUM7QUFDdEMsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IseUVBQVEsc0JBQXNCLENBQUM7QUFDdkQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvY2xpL3J1bi1oZWxwZXJzLmpzPzgyYTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEhlbHBlciBzY3JpcHRzIGZvciB0aGUgYHJ1bmAgY29tbWFuZFxuICogQHNlZSBtb2R1bGU6bGliL2NsaS9ydW5cbiAqIEBtb2R1bGVcbiAqIEBwcml2YXRlXG4gKi9cblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGFuc2kgPSByZXF1aXJlKCdhbnNpLWNvbG9ycycpO1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb2NoYTpjbGk6cnVuOmhlbHBlcnMnKTtcbmNvbnN0IHt3YXRjaFJ1biwgd2F0Y2hQYXJhbGxlbFJ1bn0gPSByZXF1aXJlKCcuL3dhdGNoLXJ1bicpO1xuY29uc3QgY29sbGVjdEZpbGVzID0gcmVxdWlyZSgnLi9jb2xsZWN0LWZpbGVzJyk7XG5jb25zdCB7Zm9ybWF0fSA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHtjcmVhdGVJbnZhbGlkTGVnYWN5UGx1Z2luRXJyb3J9ID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCB7cmVxdWlyZU9ySW1wb3J0fSA9IHJlcXVpcmUoJy4uL25vZGVqcy9lc20tdXRpbHMnKTtcbmNvbnN0IFBsdWdpbkxvYWRlciA9IHJlcXVpcmUoJy4uL3BsdWdpbi1sb2FkZXInKTtcbmNvbnN0IHtVbm1hdGNoZWRGaWxlfSA9IHJlcXVpcmUoJy4vY29sbGVjdC1maWxlcycpO1xuXG4vKipcbiAqIEV4aXRzIE1vY2hhIHdoZW4gdGVzdHMgKyBjb2RlIHVuZGVyIHRlc3QgaGFzIGZpbmlzaGVkIGV4ZWN1dGlvbiAoZGVmYXVsdClcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbGFtcGVkQ29kZSAtIEV4aXQgY29kZTsgdHlwaWNhbGx5ICMgb2YgZmFpbHVyZXNcbiAqIEBpZ25vcmVcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGV4aXRNb2NoYUxhdGVyID0gY2xhbXBlZENvZGUgPT4ge1xuICBwcm9jZXNzLm9uKCdleGl0JywgKCkgPT4ge1xuICAgIHByb2Nlc3MuZXhpdENvZGUgPSBjbGFtcGVkQ29kZTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEV4aXRzIE1vY2hhIHdoZW4gTW9jaGEgaXRzZWxmIGhhcyBmaW5pc2hlZCBleGVjdXRpb24sIHJlZ2FyZGxlc3Mgb2ZcbiAqIHdoYXQgdGhlIHRlc3RzIG9yIGNvZGUgdW5kZXIgdGVzdCBpcyBkb2luZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjbGFtcGVkQ29kZSAtIEV4aXQgY29kZTsgdHlwaWNhbGx5ICMgb2YgZmFpbHVyZXNcbiAqIEBpZ25vcmVcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGV4aXRNb2NoYSA9IGNsYW1wZWRDb2RlID0+IHtcbiAgbGV0IGRyYWluaW5nID0gMDtcblxuICAvLyBFYWdlcmx5IHNldCB0aGUgcHJvY2VzcydzIGV4aXQgY29kZSBpbiBjYXNlIHN0cmVhbS53cml0ZSBkb2Vzbid0XG4gIC8vIGV4ZWN1dGUgaXRzIGNhbGxiYWNrIGJlZm9yZSB0aGUgcHJvY2VzcyB0ZXJtaW5hdGVzLlxuICBwcm9jZXNzLmV4aXRDb2RlID0gY2xhbXBlZENvZGU7XG5cbiAgLy8gZmx1c2ggb3V0cHV0IGZvciBOb2RlLmpzIFdpbmRvd3MgcGlwZSBidWdcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy82MjQ3IGlzIGp1c3Qgb25lIGJ1ZyBleGFtcGxlXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aXNpb25tZWRpYS9tb2NoYS9pc3N1ZXMvMzMzIGhhcyBhIGdvb2QgZGlzY3Vzc2lvblxuICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgIGlmICghZHJhaW5pbmctLSkge1xuICAgICAgcHJvY2Vzcy5leGl0KGNsYW1wZWRDb2RlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc3RyZWFtcyA9IFtwcm9jZXNzLnN0ZG91dCwgcHJvY2Vzcy5zdGRlcnJdO1xuXG4gIHN0cmVhbXMuZm9yRWFjaChzdHJlYW0gPT4ge1xuICAgIC8vIHN1Ym1pdCBlbXB0eSB3cml0ZSByZXF1ZXN0IGFuZCB3YWl0IGZvciBjb21wbGV0aW9uXG4gICAgZHJhaW5pbmcgKz0gMTtcbiAgICBzdHJlYW0ud3JpdGUoJycsIGRvbmUpO1xuICB9KTtcblxuICBkb25lKCk7XG59O1xuXG4vKipcbiAqIENvZXJjZSBhIGNvbW1hLWRlbGltaXRlZCBzdHJpbmcgKG9yIGFycmF5IHRoZXJlb2YpIGludG8gYSBmbGF0dGVuZWQgYXJyYXkgb2ZcbiAqIHN0cmluZ3NcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBzdHIgLSBWYWx1ZSB0byBjb2VyY2VcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX0gQXJyYXkgb2Ygc3RyaW5nc1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5saXN0ID0gc3RyID0+XG4gIEFycmF5LmlzQXJyYXkoc3RyKSA/IGV4cG9ydHMubGlzdChzdHIuam9pbignLCcpKSA6IHN0ci5zcGxpdCgvICosICovKTtcblxuLyoqXG4gKiBgcmVxdWlyZSgpYCB0aGUgbW9kdWxlcyBhcyByZXF1aXJlZCBieSBgLS1yZXF1aXJlIDxyZXF1aXJlPmAuXG4gKlxuICogUmV0dXJucyBhcnJheSBvZiBgbW9jaGFIb29rc2AgZXhwb3J0cywgaWYgYW55LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcmVxdWlyZXMgLSBNb2R1bGVzIHRvIHJlcXVpcmVcbiAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IFBsdWdpbiBpbXBsZW1lbnRhdGlvbnNcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuaGFuZGxlUmVxdWlyZXMgPSBhc3luYyAocmVxdWlyZXMgPSBbXSwge2lnbm9yZWRQbHVnaW5zID0gW119ID0ge30pID0+IHtcbiAgY29uc3QgcGx1Z2luTG9hZGVyID0gUGx1Z2luTG9hZGVyLmNyZWF0ZSh7aWdub3JlOiBpZ25vcmVkUGx1Z2luc30pO1xuICBmb3IgYXdhaXQgKGNvbnN0IG1vZCBvZiByZXF1aXJlcykge1xuICAgIGxldCBtb2RwYXRoID0gbW9kO1xuICAgIC8vIHRoaXMgaXMgcmVsYXRpdmUgdG8gY3dkXG4gICAgaWYgKGZzLmV4aXN0c1N5bmMobW9kKSB8fCBmcy5leGlzdHNTeW5jKGAke21vZH0uanNgKSkge1xuICAgICAgbW9kcGF0aCA9IHBhdGgucmVzb2x2ZShtb2QpO1xuICAgICAgZGVidWcoJ3Jlc29sdmVkIHJlcXVpcmVkIGZpbGUgJXMgdG8gJXMnLCBtb2QsIG1vZHBhdGgpO1xuICAgIH1cbiAgICBjb25zdCByZXF1aXJlZE1vZHVsZSA9IGF3YWl0IHJlcXVpcmVPckltcG9ydChtb2RwYXRoKTtcbiAgICBpZiAocmVxdWlyZWRNb2R1bGUgJiYgdHlwZW9mIHJlcXVpcmVkTW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHBsdWdpbkxvYWRlci5sb2FkKHJlcXVpcmVkTW9kdWxlKSkge1xuICAgICAgICBkZWJ1ZygnZm91bmQgb25lIG9yIG1vcmUgcGx1Z2luIGltcGxlbWVudGF0aW9ucyBpbiAlcycsIG1vZHBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWJ1ZygnbG9hZGVkIHJlcXVpcmVkIG1vZHVsZSBcIiVzXCInLCBtb2QpO1xuICB9XG4gIGNvbnN0IHBsdWdpbnMgPSBhd2FpdCBwbHVnaW5Mb2FkZXIuZmluYWxpemUoKTtcbiAgaWYgKE9iamVjdC5rZXlzKHBsdWdpbnMpLmxlbmd0aCkge1xuICAgIGRlYnVnKCdmaW5hbGl6ZWQgcGx1Z2luIGltcGxlbWVudGF0aW9uczogJU8nLCBwbHVnaW5zKTtcbiAgfVxuICByZXR1cm4gcGx1Z2lucztcbn07XG5cbi8qKlxuICogTG9ncyBlcnJvcnMgYW5kIGV4aXRzIHRoZSBhcHAgaWYgdW5tYXRjaGVkIGZpbGVzIGV4aXN0XG4gKiBAcGFyYW0ge01vY2hhfSBtb2NoYSAtIE1vY2hhIGluc3RhbmNlXG4gKiBAcGFyYW0ge1VubWF0Y2hlZEZpbGV9IHVubWF0Y2hlZEZpbGVzIC0gb2JqZWN0IGNvbnRhaW5pbmcgdW5tYXRjaGVkIGZpbGUgcGF0aHNcbiAqIEByZXR1cm5zIHtQcm9taXNlPFJ1bm5lcj59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBoYW5kbGVVbm1hdGNoZWRGaWxlcyA9IChtb2NoYSwgdW5tYXRjaGVkRmlsZXMpID0+IHtcbiAgaWYgKHVubWF0Y2hlZEZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHVubWF0Y2hlZEZpbGVzLmZvckVhY2goKHtwYXR0ZXJuLCBhYnNvbHV0ZVBhdGh9KSA9PiB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIGFuc2kueWVsbG93KFxuICAgICAgICBgV2FybmluZzogQ2Fubm90IGZpbmQgYW55IGZpbGVzIG1hdGNoaW5nIHBhdHRlcm4gXCIke3BhdHRlcm59XCIgYXQgdGhlIGFic29sdXRlIHBhdGggXCIke2Fic29sdXRlUGF0aH1cImBcbiAgICAgIClcbiAgICApO1xuICB9KTtcbiAgY29uc29sZS5sb2coXG4gICAgJ05vIHRlc3QgZmlsZShzKSBmb3VuZCB3aXRoIHRoZSBnaXZlbiBwYXR0ZXJuLCBleGl0aW5nIHdpdGggY29kZSAxJ1xuICApO1xuXG4gIHJldHVybiBtb2NoYS5ydW4oZXhpdE1vY2hhKDEpKTtcbn07XG5cbi8qKlxuICogQ29sbGVjdCBhbmQgbG9hZCB0ZXN0IGZpbGVzLCB0aGVuIHJ1biBtb2NoYSBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7TW9jaGF9IG1vY2hhIC0gTW9jaGEgaW5zdGFuY2VcbiAqIEBwYXJhbSB7T3B0aW9uc30gW29wdHNdIC0gQ29tbWFuZCBsaW5lIG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZXhpdF0gLSBXaGV0aGVyIG9yIG5vdCB0byBmb3JjZS1leGl0IGFmdGVyIHRlc3RzIGFyZSBjb21wbGV0ZVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5wYXNzT25GYWlsaW5nVGVzdFN1aXRlXSAtIFdoZXRoZXIgb3Igbm90IHRvIGZhaWwgdGVzdCBydW4gaWYgdGVzdHMgd2VyZSBmYWlsZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWxlQ29sbGVjdFBhcmFtcyAtIFBhcmFtZXRlcnMgdGhhdCBjb250cm9sIHRlc3RcbiAqICAgZmlsZSBjb2xsZWN0aW9uLiBTZWUgYGxpYi9jbGkvY29sbGVjdC1maWxlcy5qc2AuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxSdW5uZXI+fVxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgc2luZ2xlUnVuID0gYXN5bmMgKFxuICBtb2NoYSxcbiAge2V4aXQsIHBhc3NPbkZhaWxpbmdUZXN0U3VpdGV9LFxuICBmaWxlQ29sbGVjdFBhcmFtc1xuKSA9PiB7XG4gIGNvbnN0IGZpbGVDb2xsZWN0aW9uT2JqID0gY29sbGVjdEZpbGVzKGZpbGVDb2xsZWN0UGFyYW1zKTtcblxuICBpZiAoZmlsZUNvbGxlY3Rpb25PYmoudW5tYXRjaGVkRmlsZXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBoYW5kbGVVbm1hdGNoZWRGaWxlcyhtb2NoYSwgZmlsZUNvbGxlY3Rpb25PYmoudW5tYXRjaGVkRmlsZXMpO1xuICB9XG5cbiAgZGVidWcoJ3NpbmdsZSBydW4gd2l0aCAlZCBmaWxlKHMpJywgZmlsZUNvbGxlY3Rpb25PYmouZmlsZXMubGVuZ3RoKTtcbiAgbW9jaGEuZmlsZXMgPSBmaWxlQ29sbGVjdGlvbk9iai5maWxlcztcblxuICAvLyBoYW5kbGVzIEVTTSBtb2R1bGVzXG4gIGF3YWl0IG1vY2hhLmxvYWRGaWxlc0FzeW5jKCk7XG4gIHJldHVybiBtb2NoYS5ydW4oXG4gICAgY3JlYXRlRXhpdEhhbmRsZXIoe2V4aXQsIHBhc3NPbkZhaWxpbmdUZXN0U3VpdGV9KVxuICApO1xufTtcblxuLyoqXG4gKiBDb2xsZWN0IGZpbGVzIGFuZCBydW4gdGVzdHMgKHVzaW5nIGBCdWZmZXJlZFJ1bm5lcmApLlxuICpcbiAqIFRoaXMgaXMgYGFzeW5jYCBmb3IgY29uc2lzdGVuY3kuXG4gKlxuICogQHBhcmFtIHtNb2NoYX0gbW9jaGEgLSBNb2NoYSBpbnN0YW5jZVxuICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIC0gQ29tbWFuZCBsaW5lIG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWxlQ29sbGVjdFBhcmFtcyAtIFBhcmFtZXRlcnMgdGhhdCBjb250cm9sIHRlc3RcbiAqICAgZmlsZSBjb2xsZWN0aW9uLiBTZWUgYGxpYi9jbGkvY29sbGVjdC1maWxlcy5qc2AuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxCdWZmZXJlZFJ1bm5lcj59XG4gKiBAaWdub3JlXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBwYXJhbGxlbFJ1biA9IGFzeW5jIChtb2NoYSwgb3B0aW9ucywgZmlsZUNvbGxlY3RQYXJhbXMpID0+IHtcbiAgY29uc3QgZmlsZUNvbGxlY3Rpb25PYmogPSBjb2xsZWN0RmlsZXMoZmlsZUNvbGxlY3RQYXJhbXMpO1xuXG4gIGlmIChmaWxlQ29sbGVjdGlvbk9iai51bm1hdGNoZWRGaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGhhbmRsZVVubWF0Y2hlZEZpbGVzKG1vY2hhLCBmaWxlQ29sbGVjdGlvbk9iai51bm1hdGNoZWRGaWxlcyk7XG4gIH1cblxuICBkZWJ1ZyhcbiAgICAnZXhlY3V0aW5nICVkIHRlc3QgZmlsZShzKSBpbiBwYXJhbGxlbCBtb2RlJyxcbiAgICBmaWxlQ29sbGVjdGlvbk9iai5maWxlcy5sZW5ndGhcbiAgKTtcbiAgbW9jaGEuZmlsZXMgPSBmaWxlQ29sbGVjdGlvbk9iai5maWxlcztcblxuICAvLyBub3RlIHRoYXQgd2UgRE8gTk9UIGxvYWQgYW55IGZpbGVzIGhlcmU7IHRoaXMgaXMgaGFuZGxlZCBieSB0aGUgd29ya2VyXG4gIHJldHVybiBtb2NoYS5ydW4oXG4gICAgY3JlYXRlRXhpdEhhbmRsZXIob3B0aW9ucylcbiAgKTtcbn07XG5cbi8qKlxuICogQWN0dWFsbHkgcnVuIHRlc3RzLiAgRGVsZWdhdGVzIHRvIG9uZSBvZiBmb3VyIGRpZmZlcmVudCBmdW5jdGlvbnM6XG4gKiAtIGBzaW5nbGVSdW5gOiBydW4gdGVzdHMgaW4gc2VyaWFsICYgZXhpdFxuICogLSBgd2F0Y2hSdW5gOiBydW4gdGVzdHMgaW4gc2VyaWFsLCByZXJ1bm5pbmcgYXMgZmlsZXMgY2hhbmdlXG4gKiAtIGBwYXJhbGxlbFJ1bmA6IHJ1biB0ZXN0cyBpbiBwYXJhbGxlbCAmIGV4aXRcbiAqIC0gYHdhdGNoUGFyYWxsZWxSdW5gOiBydW4gdGVzdHMgaW4gcGFyYWxsZWwsIHJlcnVubmluZyBhcyBmaWxlcyBjaGFuZ2VcbiAqIEBwYXJhbSB7TW9jaGF9IG1vY2hhIC0gTW9jaGEgaW5zdGFuY2VcbiAqIEBwYXJhbSB7T3B0aW9uc30gb3B0cyAtIENvbW1hbmQgbGluZSBvcHRpb25zXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybnMge1Byb21pc2U8UnVubmVyPn1cbiAqL1xuZXhwb3J0cy5ydW5Nb2NoYSA9IGFzeW5jIChtb2NoYSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCB7XG4gICAgd2F0Y2ggPSBmYWxzZSxcbiAgICBleHRlbnNpb24gPSBbXSxcbiAgICBpZ25vcmUgPSBbXSxcbiAgICBmaWxlID0gW10sXG4gICAgcGFyYWxsZWwgPSBmYWxzZSxcbiAgICByZWN1cnNpdmUgPSBmYWxzZSxcbiAgICBzb3J0ID0gZmFsc2UsXG4gICAgc3BlYyA9IFtdXG4gIH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IGZpbGVDb2xsZWN0UGFyYW1zID0ge1xuICAgIGlnbm9yZSxcbiAgICBleHRlbnNpb24sXG4gICAgZmlsZSxcbiAgICByZWN1cnNpdmUsXG4gICAgc29ydCxcbiAgICBzcGVjXG4gIH07XG5cbiAgbGV0IHJ1bjtcbiAgaWYgKHdhdGNoKSB7XG4gICAgcnVuID0gcGFyYWxsZWwgPyB3YXRjaFBhcmFsbGVsUnVuIDogd2F0Y2hSdW47XG4gIH0gZWxzZSB7XG4gICAgcnVuID0gcGFyYWxsZWwgPyBwYXJhbGxlbFJ1biA6IHNpbmdsZVJ1bjtcbiAgfVxuXG4gIHJldHVybiBydW4obW9jaGEsIG9wdGlvbnMsIGZpbGVDb2xsZWN0UGFyYW1zKTtcbn07XG5cbi8qKlxuICogVXNlZCBmb3IgYC0tcmVwb3J0ZXJgIGFuZCBgLS11aWAuICBFbnN1cmVzIHRoZXJlJ3Mgb25seSBvbmUsIGFuZCBhc3NlcnRzIHRoYXRcbiAqIGl0IGFjdHVhbGx5IGV4aXN0cy4gVGhpcyBtdXN0IGJlIHJ1biBfYWZ0ZXJfIHJlcXVpcmVzIGFyZSBwcm9jZXNzZWQgKHNlZVxuICoge0BsaW5rIGhhbmRsZVJlcXVpcmVzfSksIGFzIGl0J2xsIHByZXZlbnQgaW50ZXJmYWNlcyBmcm9tIGxvYWRpbmcgb3RoZXJ3aXNlLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtcInJlcG9ydGVyXCJ8XCJ1aVwifSBwbHVnaW5UeXBlIC0gVHlwZSBvZiBwbHVnaW4uXG4gKiBAcGFyYW0ge09iamVjdH0gW21hcF0gLSBVc2VkIGFzIGEgY2FjaGUgb2Ygc29ydHM7XG4gKiBgTW9jaGEucmVwb3J0ZXJzYCB3aGVyZSBlYWNoIGtleSBjb3JyZXNwb25kcyB0byBhIHJlcG9ydGVyIG5hbWUsXG4gKiBgTW9jaGEuaW50ZXJmYWNlc2Agd2hlcmUgZWFjaCBrZXkgY29ycmVzcG9uZHMgdG8gYW4gaW50ZXJmYWNlIG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLnZhbGlkYXRlTGVnYWN5UGx1Z2luID0gKG9wdHMsIHBsdWdpblR5cGUsIG1hcCA9IHt9KSA9PiB7XG4gIC8qKlxuICAgKiBUaGlzIHNob3VsZCBiZSBhIHVuaXF1ZSBpZGVudGlmaWVyOyBlaXRoZXIgYSBzdHJpbmcgKHByZXNlbnQgaW4gYG1hcGApLFxuICAgKiBvciBhIHJlc29sdmFibGUgKHZpYSBgcmVxdWlyZS5yZXNvbHZlYCkgbW9kdWxlIElEL3BhdGguXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBjb25zdCBwbHVnaW5JZCA9IG9wdHNbcGx1Z2luVHlwZV07XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkocGx1Z2luSWQpKSB7XG4gICAgdGhyb3cgY3JlYXRlSW52YWxpZExlZ2FjeVBsdWdpbkVycm9yKFxuICAgICAgYFwiLS0ke3BsdWdpblR5cGV9XCIgY2FuIG9ubHkgYmUgc3BlY2lmaWVkIG9uY2VgLFxuICAgICAgcGx1Z2luVHlwZVxuICAgICk7XG4gIH1cblxuICBjb25zdCBjcmVhdGVVbmtub3duRXJyb3IgPSBlcnIgPT5cbiAgICBjcmVhdGVJbnZhbGlkTGVnYWN5UGx1Z2luRXJyb3IoXG4gICAgICBmb3JtYXQoJ0NvdWxkIG5vdCBsb2FkICVzIFwiJXNcIjpcXG5cXG4gJU8nLCBwbHVnaW5UeXBlLCBwbHVnaW5JZCwgZXJyKSxcbiAgICAgIHBsdWdpblR5cGUsXG4gICAgICBwbHVnaW5JZFxuICAgICk7XG5cbiAgLy8gaWYgdGhpcyBleGlzdHMsIHRoZW4gaXQncyBhbHJlYWR5IGxvYWRlZCwgc28gbm90aGluZyBtb3JlIHRvIGRvLlxuICBpZiAoIW1hcFtwbHVnaW5JZF0pIHtcbiAgICBsZXQgZm91bmRJZDtcbiAgICB0cnkge1xuICAgICAgZm91bmRJZCA9IHJlcXVpcmUucmVzb2x2ZShwbHVnaW5JZCk7XG4gICAgICBtYXBbcGx1Z2luSWRdID0gcmVxdWlyZShmb3VuZElkKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChmb3VuZElkKSB0aHJvdyBjcmVhdGVVbmtub3duRXJyb3IoZXJyKTtcblxuICAgICAgLy8gVHJ5IHRvIGxvYWQgcmVwb3J0ZXJzIGZyb20gYSBjd2QtcmVsYXRpdmUgcGF0aFxuICAgICAgdHJ5IHtcbiAgICAgICAgbWFwW3BsdWdpbklkXSA9IHJlcXVpcmUocGF0aC5yZXNvbHZlKHBsdWdpbklkKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZVVua25vd25FcnJvcihlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZUV4aXRIYW5kbGVyID0gKHsgZXhpdCwgcGFzc09uRmFpbGluZ1Rlc3RTdWl0ZSB9KSA9PiB7XG4gIHJldHVybiBjb2RlID0+IHtcbiAgICBjb25zdCBjbGFtcGVkQ29kZSA9IHBhc3NPbkZhaWxpbmdUZXN0U3VpdGVcbiAgICAgID8gMFxuICAgICAgOiBNYXRoLm1pbihjb2RlLCAyNTUpO1xuXG4gICAgcmV0dXJuIGV4aXRcbiAgICAgID8gZXhpdE1vY2hhKGNsYW1wZWRDb2RlKVxuICAgICAgOiBleGl0TW9jaGFMYXRlcihjbGFtcGVkQ29kZSk7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/cli/run-helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/cli/watch-run.js":
/*!*************************************************!*\
  !*** ./node_modules/mocha/lib/cli/watch-run.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst logSymbols = __webpack_require__(/*! log-symbols */ \"(ssr)/./node_modules/log-symbols/index.js\");\nconst debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")('mocha:cli:watch');\nconst path = __webpack_require__(/*! path */ \"path\");\nconst chokidar = __webpack_require__(/*! chokidar */ \"(ssr)/./node_modules/chokidar/index.js\");\nconst Context = __webpack_require__(/*! ../context */ \"(ssr)/./node_modules/mocha/lib/context.js\");\nconst collectFiles = __webpack_require__(/*! ./collect-files */ \"(ssr)/./node_modules/mocha/lib/cli/collect-files.js\");\n\n/**\n * Exports the `watchRun` function that runs mocha in \"watch\" mode.\n * @see module:lib/cli/run-helpers\n * @module\n * @private\n */\n\n/**\n * Run Mocha in parallel \"watch\" mode\n * @param {Mocha} mocha - Mocha instance\n * @param {Object} opts - Options\n * @param {string[]} [opts.watchFiles] - List of paths and patterns to\n *   watch. If not provided all files with an extension included in\n *   `fileCollectionParams.extension` are watched. See first argument of\n *   `chokidar.watch`.\n * @param {string[]} opts.watchIgnore - List of paths and patterns to\n *   exclude from watching. See `ignored` option of `chokidar`.\n * @param {FileCollectionOptions} fileCollectParams - Parameters that control test\n * @private\n */\nexports.watchParallelRun = (\n  mocha,\n  {watchFiles, watchIgnore},\n  fileCollectParams\n) => {\n  debug('creating parallel watcher');\n\n  return createWatcher(mocha, {\n    watchFiles,\n    watchIgnore,\n    beforeRun({mocha}) {\n      // I don't know why we're cloning the root suite.\n      const rootSuite = mocha.suite.clone();\n\n      // ensure we aren't leaking event listeners\n      mocha.dispose();\n\n      // this `require` is needed because the require cache has been cleared.  the dynamic\n      // exports set via the below call to `mocha.ui()` won't work properly if a\n      // test depends on this module.\n      const Mocha = __webpack_require__(/*! ../mocha */ \"(ssr)/./node_modules/mocha/lib/mocha.js\");\n\n      // ... and now that we've gotten a new module, we need to use it again due\n      // to `mocha.ui()` call\n      const newMocha = new Mocha(mocha.options);\n      // don't know why this is needed\n      newMocha.suite = rootSuite;\n      // nor this\n      newMocha.suite.ctx = new Context();\n\n      // reset the list of files\n      newMocha.files = collectFiles(fileCollectParams).files;\n\n      // because we've swapped out the root suite (see the `run` inner function\n      // in `createRerunner`), we need to call `mocha.ui()` again to set up the context/globals.\n      newMocha.ui(newMocha.options.ui);\n\n      // we need to call `newMocha.rootHooks` to set up rootHooks for the new\n      // suite\n      newMocha.rootHooks(newMocha.options.rootHooks);\n\n      // in parallel mode, the main Mocha process doesn't actually load the\n      // files. this flag prevents `mocha.run()` from autoloading.\n      newMocha.lazyLoadFiles(true);\n      return newMocha;\n    },\n    fileCollectParams\n  });\n};\n\n/**\n * Run Mocha in \"watch\" mode\n * @param {Mocha} mocha - Mocha instance\n * @param {Object} opts - Options\n * @param {string[]} [opts.watchFiles] - List of paths and patterns to\n *   watch. If not provided all files with an extension included in\n *   `fileCollectionParams.extension` are watched. See first argument of\n *   `chokidar.watch`.\n * @param {string[]} opts.watchIgnore - List of paths and patterns to\n *   exclude from watching. See `ignored` option of `chokidar`.\n * @param {FileCollectionOptions} fileCollectParams - Parameters that control test\n *   file collection. See `lib/cli/collect-files.js`.\n * @private\n */\nexports.watchRun = (mocha, {watchFiles, watchIgnore}, fileCollectParams) => {\n  debug('creating serial watcher');\n\n  return createWatcher(mocha, {\n    watchFiles,\n    watchIgnore,\n    beforeRun({mocha}) {\n      mocha.unloadFiles();\n\n      // I don't know why we're cloning the root suite.\n      const rootSuite = mocha.suite.clone();\n\n      // ensure we aren't leaking event listeners\n      mocha.dispose();\n\n      // this `require` is needed because the require cache has been cleared.  the dynamic\n      // exports set via the below call to `mocha.ui()` won't work properly if a\n      // test depends on this module.\n      const Mocha = __webpack_require__(/*! ../mocha */ \"(ssr)/./node_modules/mocha/lib/mocha.js\");\n\n      // ... and now that we've gotten a new module, we need to use it again due\n      // to `mocha.ui()` call\n      const newMocha = new Mocha(mocha.options);\n      // don't know why this is needed\n      newMocha.suite = rootSuite;\n      // nor this\n      newMocha.suite.ctx = new Context();\n\n      // reset the list of files\n      newMocha.files = collectFiles(fileCollectParams).files;\n\n      // because we've swapped out the root suite (see the `run` inner function\n      // in `createRerunner`), we need to call `mocha.ui()` again to set up the context/globals.\n      newMocha.ui(newMocha.options.ui);\n\n      // we need to call `newMocha.rootHooks` to set up rootHooks for the new\n      // suite\n      newMocha.rootHooks(newMocha.options.rootHooks);\n\n      return newMocha;\n    },\n    fileCollectParams\n  });\n};\n\n/**\n * Bootstraps a chokidar watcher. Handles keyboard input & signals\n * @param {Mocha} mocha - Mocha instance\n * @param {Object} opts\n * @param {BeforeWatchRun} [opts.beforeRun] - Function to call before\n * `mocha.run()`\n * @param {string[]} [opts.watchFiles] - List of paths and patterns to watch. If\n *   not provided all files with an extension included in\n *   `fileCollectionParams.extension` are watched. See first argument of\n *   `chokidar.watch`.\n * @param {string[]} [opts.watchIgnore] - List of paths and patterns to exclude\n *   from watching. See `ignored` option of `chokidar`.\n * @param {FileCollectionOptions} opts.fileCollectParams - List of extensions to watch if `opts.watchFiles` is not given.\n * @returns {FSWatcher}\n * @ignore\n * @private\n */\nconst createWatcher = (\n  mocha,\n  {watchFiles, watchIgnore, beforeRun, fileCollectParams}\n) => {\n  if (!watchFiles) {\n    watchFiles = fileCollectParams.extension.map(ext => `**/*.${ext}`);\n  }\n\n  debug('ignoring files matching: %s', watchIgnore);\n  let globalFixtureContext;\n\n  // we handle global fixtures manually\n  mocha.enableGlobalSetup(false).enableGlobalTeardown(false);\n\n  const watcher = chokidar.watch(watchFiles, {\n    ignored: watchIgnore,\n    ignoreInitial: true\n  });\n\n  const rerunner = createRerunner(mocha, watcher, {\n    beforeRun\n  });\n\n  watcher.on('ready', async () => {\n    if (!globalFixtureContext) {\n      debug('triggering global setup');\n      globalFixtureContext = await mocha.runGlobalSetup();\n    }\n    rerunner.run();\n  });\n\n  watcher.on('all', () => {\n    rerunner.scheduleRun();\n  });\n\n  hideCursor();\n  process.on('exit', () => {\n    showCursor();\n  });\n\n  // this is for testing.\n  // win32 cannot gracefully shutdown via a signal from a parent\n  // process; a `SIGINT` from a parent will cause the process\n  // to immediately exit.  during normal course of operation, a user\n  // will type Ctrl-C and the listener will be invoked, but this\n  // is not possible in automated testing.\n  // there may be another way to solve this, but it too will be a hack.\n  // for our watch tests on win32 we must _fork_ mocha with an IPC channel\n  if (process.connected) {\n    process.on('message', msg => {\n      if (msg === 'SIGINT') {\n        process.emit('SIGINT');\n      }\n    });\n  }\n\n  let exiting = false;\n  process.on('SIGINT', async () => {\n    showCursor();\n    console.error(`${logSymbols.warning} [mocha] cleaning up, please wait...`);\n    if (!exiting) {\n      exiting = true;\n      if (mocha.hasGlobalTeardownFixtures()) {\n        debug('running global teardown');\n        try {\n          await mocha.runGlobalTeardown(globalFixtureContext);\n        } catch (err) {\n          console.error(err);\n        }\n      }\n      process.exit(130);\n    }\n  });\n\n  // Keyboard shortcut for restarting when \"rs\\n\" is typed (ala Nodemon)\n  process.stdin.resume();\n  process.stdin.setEncoding('utf8');\n  process.stdin.on('data', data => {\n    const str = data.toString().trim().toLowerCase();\n    if (str === 'rs') rerunner.scheduleRun();\n  });\n\n  return watcher;\n};\n\n/**\n * Create an object that allows you to rerun tests on the mocha instance.\n *\n * @param {Mocha} mocha - Mocha instance\n * @param {FSWatcher} watcher - chokidar `FSWatcher` instance\n * @param {Object} [opts] - Options!\n * @param {BeforeWatchRun} [opts.beforeRun] - Function to call before `mocha.run()`\n * @returns {Rerunner}\n * @ignore\n * @private\n */\nconst createRerunner = (mocha, watcher, {beforeRun} = {}) => {\n  // Set to a `Runner` when mocha is running. Set to `null` when mocha is not\n  // running.\n  let runner = null;\n\n  // true if a file has changed during a test run\n  let rerunScheduled = false;\n\n  const run = () => {\n    try {\n      mocha = beforeRun ? beforeRun({mocha, watcher}) || mocha : mocha;\n      runner = mocha.run(() => {\n        debug('finished watch run');\n        runner = null;\n        blastCache(watcher);\n        if (rerunScheduled) {\n          rerun();\n        } else {\n          console.error(`${logSymbols.info} [mocha] waiting for changes...`);\n        }\n      });\n    } catch (e) {\n      console.error(e.stack);\n    }\n  };\n\n  const scheduleRun = () => {\n    if (rerunScheduled) {\n      return;\n    }\n\n    rerunScheduled = true;\n    if (runner) {\n      runner.abort();\n    } else {\n      rerun();\n    }\n  };\n\n  const rerun = () => {\n    rerunScheduled = false;\n    eraseLine();\n    run();\n  };\n\n  return {\n    scheduleRun,\n    run\n  };\n};\n\n/**\n * Return the list of absolute paths watched by a chokidar watcher.\n *\n * @param watcher - Instance of a chokidar watcher\n * @return {string[]} - List of absolute paths\n * @ignore\n * @private\n */\nconst getWatchedFiles = watcher => {\n  const watchedDirs = watcher.getWatched();\n  return Object.keys(watchedDirs).reduce(\n    (acc, dir) => [\n      ...acc,\n      ...watchedDirs[dir].map(file => path.join(dir, file))\n    ],\n    []\n  );\n};\n\n/**\n * Hide the cursor.\n * @ignore\n * @private\n */\nconst hideCursor = () => {\n  process.stdout.write('\\u001b[?25l');\n};\n\n/**\n * Show the cursor.\n * @ignore\n * @private\n */\nconst showCursor = () => {\n  process.stdout.write('\\u001b[?25h');\n};\n\n/**\n * Erases the line on stdout\n * @private\n */\nconst eraseLine = () => {\n  process.stdout.write('\\u001b[2K');\n};\n\n/**\n * Blast all of the watched files out of `require.cache`\n * @param {FSWatcher} watcher - chokidar FSWatcher\n * @ignore\n * @private\n */\nconst blastCache = watcher => {\n  const files = getWatchedFiles(watcher);\n  files.forEach(file => {\n    delete __webpack_require__.c[file];\n  });\n  debug('deleted %d file(s) from the require cache', files.length);\n};\n\n/**\n * Callback to be run before `mocha.run()` is called.\n * Optionally, it can return a new `Mocha` instance.\n * @callback BeforeWatchRun\n * @private\n * @param {{mocha: Mocha, watcher: FSWatcher}} options\n * @returns {Mocha}\n */\n\n/**\n * Object containing run control methods\n * @typedef {Object} Rerunner\n * @private\n * @property {Function} run - Calls `mocha.run()`\n * @property {Function} scheduleRun - Schedules another call to `run`\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2NsaS93YXRjaC1ydW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMsOERBQWE7QUFDeEMsY0FBYyxtQkFBTyxDQUFDLHNEQUFPO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixpQkFBaUIsbUJBQU8sQ0FBQyx3REFBVTtBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyw2REFBWTtBQUNwQyxxQkFBcUIsbUJBQU8sQ0FBQyw0RUFBaUI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLEdBQUcsd0JBQXdCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLHlEQUFVOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZLHdCQUF3QjtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLHlEQUFVOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdFQUFnRSxJQUFJO0FBQ3BFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdCQUFnQjtBQUMzQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFdBQVcsSUFBSTtBQUN4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLGVBQWU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFhO0FBQ3hCLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1DQUFtQztBQUMvQyxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWMsVUFBVTtBQUN4QixjQUFjLFVBQVU7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9jbGkvd2F0Y2gtcnVuLmpzPzA2MDUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBsb2dTeW1ib2xzID0gcmVxdWlyZSgnbG9nLXN5bWJvbHMnKTtcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9jaGE6Y2xpOndhdGNoJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgY2hva2lkYXIgPSByZXF1aXJlKCdjaG9raWRhcicpO1xuY29uc3QgQ29udGV4dCA9IHJlcXVpcmUoJy4uL2NvbnRleHQnKTtcbmNvbnN0IGNvbGxlY3RGaWxlcyA9IHJlcXVpcmUoJy4vY29sbGVjdC1maWxlcycpO1xuXG4vKipcbiAqIEV4cG9ydHMgdGhlIGB3YXRjaFJ1bmAgZnVuY3Rpb24gdGhhdCBydW5zIG1vY2hhIGluIFwid2F0Y2hcIiBtb2RlLlxuICogQHNlZSBtb2R1bGU6bGliL2NsaS9ydW4taGVscGVyc1xuICogQG1vZHVsZVxuICogQHByaXZhdGVcbiAqL1xuXG4vKipcbiAqIFJ1biBNb2NoYSBpbiBwYXJhbGxlbCBcIndhdGNoXCIgbW9kZVxuICogQHBhcmFtIHtNb2NoYX0gbW9jaGEgLSBNb2NoYSBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3B0cy53YXRjaEZpbGVzXSAtIExpc3Qgb2YgcGF0aHMgYW5kIHBhdHRlcm5zIHRvXG4gKiAgIHdhdGNoLiBJZiBub3QgcHJvdmlkZWQgYWxsIGZpbGVzIHdpdGggYW4gZXh0ZW5zaW9uIGluY2x1ZGVkIGluXG4gKiAgIGBmaWxlQ29sbGVjdGlvblBhcmFtcy5leHRlbnNpb25gIGFyZSB3YXRjaGVkLiBTZWUgZmlyc3QgYXJndW1lbnQgb2ZcbiAqICAgYGNob2tpZGFyLndhdGNoYC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IG9wdHMud2F0Y2hJZ25vcmUgLSBMaXN0IG9mIHBhdGhzIGFuZCBwYXR0ZXJucyB0b1xuICogICBleGNsdWRlIGZyb20gd2F0Y2hpbmcuIFNlZSBgaWdub3JlZGAgb3B0aW9uIG9mIGBjaG9raWRhcmAuXG4gKiBAcGFyYW0ge0ZpbGVDb2xsZWN0aW9uT3B0aW9uc30gZmlsZUNvbGxlY3RQYXJhbXMgLSBQYXJhbWV0ZXJzIHRoYXQgY29udHJvbCB0ZXN0XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLndhdGNoUGFyYWxsZWxSdW4gPSAoXG4gIG1vY2hhLFxuICB7d2F0Y2hGaWxlcywgd2F0Y2hJZ25vcmV9LFxuICBmaWxlQ29sbGVjdFBhcmFtc1xuKSA9PiB7XG4gIGRlYnVnKCdjcmVhdGluZyBwYXJhbGxlbCB3YXRjaGVyJyk7XG5cbiAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIobW9jaGEsIHtcbiAgICB3YXRjaEZpbGVzLFxuICAgIHdhdGNoSWdub3JlLFxuICAgIGJlZm9yZVJ1bih7bW9jaGF9KSB7XG4gICAgICAvLyBJIGRvbid0IGtub3cgd2h5IHdlJ3JlIGNsb25pbmcgdGhlIHJvb3Qgc3VpdGUuXG4gICAgICBjb25zdCByb290U3VpdGUgPSBtb2NoYS5zdWl0ZS5jbG9uZSgpO1xuXG4gICAgICAvLyBlbnN1cmUgd2UgYXJlbid0IGxlYWtpbmcgZXZlbnQgbGlzdGVuZXJzXG4gICAgICBtb2NoYS5kaXNwb3NlKCk7XG5cbiAgICAgIC8vIHRoaXMgYHJlcXVpcmVgIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSByZXF1aXJlIGNhY2hlIGhhcyBiZWVuIGNsZWFyZWQuICB0aGUgZHluYW1pY1xuICAgICAgLy8gZXhwb3J0cyBzZXQgdmlhIHRoZSBiZWxvdyBjYWxsIHRvIGBtb2NoYS51aSgpYCB3b24ndCB3b3JrIHByb3Blcmx5IGlmIGFcbiAgICAgIC8vIHRlc3QgZGVwZW5kcyBvbiB0aGlzIG1vZHVsZS5cbiAgICAgIGNvbnN0IE1vY2hhID0gcmVxdWlyZSgnLi4vbW9jaGEnKTtcblxuICAgICAgLy8gLi4uIGFuZCBub3cgdGhhdCB3ZSd2ZSBnb3R0ZW4gYSBuZXcgbW9kdWxlLCB3ZSBuZWVkIHRvIHVzZSBpdCBhZ2FpbiBkdWVcbiAgICAgIC8vIHRvIGBtb2NoYS51aSgpYCBjYWxsXG4gICAgICBjb25zdCBuZXdNb2NoYSA9IG5ldyBNb2NoYShtb2NoYS5vcHRpb25zKTtcbiAgICAgIC8vIGRvbid0IGtub3cgd2h5IHRoaXMgaXMgbmVlZGVkXG4gICAgICBuZXdNb2NoYS5zdWl0ZSA9IHJvb3RTdWl0ZTtcbiAgICAgIC8vIG5vciB0aGlzXG4gICAgICBuZXdNb2NoYS5zdWl0ZS5jdHggPSBuZXcgQ29udGV4dCgpO1xuXG4gICAgICAvLyByZXNldCB0aGUgbGlzdCBvZiBmaWxlc1xuICAgICAgbmV3TW9jaGEuZmlsZXMgPSBjb2xsZWN0RmlsZXMoZmlsZUNvbGxlY3RQYXJhbXMpLmZpbGVzO1xuXG4gICAgICAvLyBiZWNhdXNlIHdlJ3ZlIHN3YXBwZWQgb3V0IHRoZSByb290IHN1aXRlIChzZWUgdGhlIGBydW5gIGlubmVyIGZ1bmN0aW9uXG4gICAgICAvLyBpbiBgY3JlYXRlUmVydW5uZXJgKSwgd2UgbmVlZCB0byBjYWxsIGBtb2NoYS51aSgpYCBhZ2FpbiB0byBzZXQgdXAgdGhlIGNvbnRleHQvZ2xvYmFscy5cbiAgICAgIG5ld01vY2hhLnVpKG5ld01vY2hhLm9wdGlvbnMudWkpO1xuXG4gICAgICAvLyB3ZSBuZWVkIHRvIGNhbGwgYG5ld01vY2hhLnJvb3RIb29rc2AgdG8gc2V0IHVwIHJvb3RIb29rcyBmb3IgdGhlIG5ld1xuICAgICAgLy8gc3VpdGVcbiAgICAgIG5ld01vY2hhLnJvb3RIb29rcyhuZXdNb2NoYS5vcHRpb25zLnJvb3RIb29rcyk7XG5cbiAgICAgIC8vIGluIHBhcmFsbGVsIG1vZGUsIHRoZSBtYWluIE1vY2hhIHByb2Nlc3MgZG9lc24ndCBhY3R1YWxseSBsb2FkIHRoZVxuICAgICAgLy8gZmlsZXMuIHRoaXMgZmxhZyBwcmV2ZW50cyBgbW9jaGEucnVuKClgIGZyb20gYXV0b2xvYWRpbmcuXG4gICAgICBuZXdNb2NoYS5sYXp5TG9hZEZpbGVzKHRydWUpO1xuICAgICAgcmV0dXJuIG5ld01vY2hhO1xuICAgIH0sXG4gICAgZmlsZUNvbGxlY3RQYXJhbXNcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJ1biBNb2NoYSBpbiBcIndhdGNoXCIgbW9kZVxuICogQHBhcmFtIHtNb2NoYX0gbW9jaGEgLSBNb2NoYSBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3B0cy53YXRjaEZpbGVzXSAtIExpc3Qgb2YgcGF0aHMgYW5kIHBhdHRlcm5zIHRvXG4gKiAgIHdhdGNoLiBJZiBub3QgcHJvdmlkZWQgYWxsIGZpbGVzIHdpdGggYW4gZXh0ZW5zaW9uIGluY2x1ZGVkIGluXG4gKiAgIGBmaWxlQ29sbGVjdGlvblBhcmFtcy5leHRlbnNpb25gIGFyZSB3YXRjaGVkLiBTZWUgZmlyc3QgYXJndW1lbnQgb2ZcbiAqICAgYGNob2tpZGFyLndhdGNoYC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IG9wdHMud2F0Y2hJZ25vcmUgLSBMaXN0IG9mIHBhdGhzIGFuZCBwYXR0ZXJucyB0b1xuICogICBleGNsdWRlIGZyb20gd2F0Y2hpbmcuIFNlZSBgaWdub3JlZGAgb3B0aW9uIG9mIGBjaG9raWRhcmAuXG4gKiBAcGFyYW0ge0ZpbGVDb2xsZWN0aW9uT3B0aW9uc30gZmlsZUNvbGxlY3RQYXJhbXMgLSBQYXJhbWV0ZXJzIHRoYXQgY29udHJvbCB0ZXN0XG4gKiAgIGZpbGUgY29sbGVjdGlvbi4gU2VlIGBsaWIvY2xpL2NvbGxlY3QtZmlsZXMuanNgLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy53YXRjaFJ1biA9IChtb2NoYSwge3dhdGNoRmlsZXMsIHdhdGNoSWdub3JlfSwgZmlsZUNvbGxlY3RQYXJhbXMpID0+IHtcbiAgZGVidWcoJ2NyZWF0aW5nIHNlcmlhbCB3YXRjaGVyJyk7XG5cbiAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIobW9jaGEsIHtcbiAgICB3YXRjaEZpbGVzLFxuICAgIHdhdGNoSWdub3JlLFxuICAgIGJlZm9yZVJ1bih7bW9jaGF9KSB7XG4gICAgICBtb2NoYS51bmxvYWRGaWxlcygpO1xuXG4gICAgICAvLyBJIGRvbid0IGtub3cgd2h5IHdlJ3JlIGNsb25pbmcgdGhlIHJvb3Qgc3VpdGUuXG4gICAgICBjb25zdCByb290U3VpdGUgPSBtb2NoYS5zdWl0ZS5jbG9uZSgpO1xuXG4gICAgICAvLyBlbnN1cmUgd2UgYXJlbid0IGxlYWtpbmcgZXZlbnQgbGlzdGVuZXJzXG4gICAgICBtb2NoYS5kaXNwb3NlKCk7XG5cbiAgICAgIC8vIHRoaXMgYHJlcXVpcmVgIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSByZXF1aXJlIGNhY2hlIGhhcyBiZWVuIGNsZWFyZWQuICB0aGUgZHluYW1pY1xuICAgICAgLy8gZXhwb3J0cyBzZXQgdmlhIHRoZSBiZWxvdyBjYWxsIHRvIGBtb2NoYS51aSgpYCB3b24ndCB3b3JrIHByb3Blcmx5IGlmIGFcbiAgICAgIC8vIHRlc3QgZGVwZW5kcyBvbiB0aGlzIG1vZHVsZS5cbiAgICAgIGNvbnN0IE1vY2hhID0gcmVxdWlyZSgnLi4vbW9jaGEnKTtcblxuICAgICAgLy8gLi4uIGFuZCBub3cgdGhhdCB3ZSd2ZSBnb3R0ZW4gYSBuZXcgbW9kdWxlLCB3ZSBuZWVkIHRvIHVzZSBpdCBhZ2FpbiBkdWVcbiAgICAgIC8vIHRvIGBtb2NoYS51aSgpYCBjYWxsXG4gICAgICBjb25zdCBuZXdNb2NoYSA9IG5ldyBNb2NoYShtb2NoYS5vcHRpb25zKTtcbiAgICAgIC8vIGRvbid0IGtub3cgd2h5IHRoaXMgaXMgbmVlZGVkXG4gICAgICBuZXdNb2NoYS5zdWl0ZSA9IHJvb3RTdWl0ZTtcbiAgICAgIC8vIG5vciB0aGlzXG4gICAgICBuZXdNb2NoYS5zdWl0ZS5jdHggPSBuZXcgQ29udGV4dCgpO1xuXG4gICAgICAvLyByZXNldCB0aGUgbGlzdCBvZiBmaWxlc1xuICAgICAgbmV3TW9jaGEuZmlsZXMgPSBjb2xsZWN0RmlsZXMoZmlsZUNvbGxlY3RQYXJhbXMpLmZpbGVzO1xuXG4gICAgICAvLyBiZWNhdXNlIHdlJ3ZlIHN3YXBwZWQgb3V0IHRoZSByb290IHN1aXRlIChzZWUgdGhlIGBydW5gIGlubmVyIGZ1bmN0aW9uXG4gICAgICAvLyBpbiBgY3JlYXRlUmVydW5uZXJgKSwgd2UgbmVlZCB0byBjYWxsIGBtb2NoYS51aSgpYCBhZ2FpbiB0byBzZXQgdXAgdGhlIGNvbnRleHQvZ2xvYmFscy5cbiAgICAgIG5ld01vY2hhLnVpKG5ld01vY2hhLm9wdGlvbnMudWkpO1xuXG4gICAgICAvLyB3ZSBuZWVkIHRvIGNhbGwgYG5ld01vY2hhLnJvb3RIb29rc2AgdG8gc2V0IHVwIHJvb3RIb29rcyBmb3IgdGhlIG5ld1xuICAgICAgLy8gc3VpdGVcbiAgICAgIG5ld01vY2hhLnJvb3RIb29rcyhuZXdNb2NoYS5vcHRpb25zLnJvb3RIb29rcyk7XG5cbiAgICAgIHJldHVybiBuZXdNb2NoYTtcbiAgICB9LFxuICAgIGZpbGVDb2xsZWN0UGFyYW1zXG4gIH0pO1xufTtcblxuLyoqXG4gKiBCb290c3RyYXBzIGEgY2hva2lkYXIgd2F0Y2hlci4gSGFuZGxlcyBrZXlib2FyZCBpbnB1dCAmIHNpZ25hbHNcbiAqIEBwYXJhbSB7TW9jaGF9IG1vY2hhIC0gTW9jaGEgaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge0JlZm9yZVdhdGNoUnVufSBbb3B0cy5iZWZvcmVSdW5dIC0gRnVuY3Rpb24gdG8gY2FsbCBiZWZvcmVcbiAqIGBtb2NoYS5ydW4oKWBcbiAqIEBwYXJhbSB7c3RyaW5nW119IFtvcHRzLndhdGNoRmlsZXNdIC0gTGlzdCBvZiBwYXRocyBhbmQgcGF0dGVybnMgdG8gd2F0Y2guIElmXG4gKiAgIG5vdCBwcm92aWRlZCBhbGwgZmlsZXMgd2l0aCBhbiBleHRlbnNpb24gaW5jbHVkZWQgaW5cbiAqICAgYGZpbGVDb2xsZWN0aW9uUGFyYW1zLmV4dGVuc2lvbmAgYXJlIHdhdGNoZWQuIFNlZSBmaXJzdCBhcmd1bWVudCBvZlxuICogICBgY2hva2lkYXIud2F0Y2hgLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gW29wdHMud2F0Y2hJZ25vcmVdIC0gTGlzdCBvZiBwYXRocyBhbmQgcGF0dGVybnMgdG8gZXhjbHVkZVxuICogICBmcm9tIHdhdGNoaW5nLiBTZWUgYGlnbm9yZWRgIG9wdGlvbiBvZiBgY2hva2lkYXJgLlxuICogQHBhcmFtIHtGaWxlQ29sbGVjdGlvbk9wdGlvbnN9IG9wdHMuZmlsZUNvbGxlY3RQYXJhbXMgLSBMaXN0IG9mIGV4dGVuc2lvbnMgdG8gd2F0Y2ggaWYgYG9wdHMud2F0Y2hGaWxlc2AgaXMgbm90IGdpdmVuLlxuICogQHJldHVybnMge0ZTV2F0Y2hlcn1cbiAqIEBpZ25vcmVcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGNyZWF0ZVdhdGNoZXIgPSAoXG4gIG1vY2hhLFxuICB7d2F0Y2hGaWxlcywgd2F0Y2hJZ25vcmUsIGJlZm9yZVJ1biwgZmlsZUNvbGxlY3RQYXJhbXN9XG4pID0+IHtcbiAgaWYgKCF3YXRjaEZpbGVzKSB7XG4gICAgd2F0Y2hGaWxlcyA9IGZpbGVDb2xsZWN0UGFyYW1zLmV4dGVuc2lvbi5tYXAoZXh0ID0+IGAqKi8qLiR7ZXh0fWApO1xuICB9XG5cbiAgZGVidWcoJ2lnbm9yaW5nIGZpbGVzIG1hdGNoaW5nOiAlcycsIHdhdGNoSWdub3JlKTtcbiAgbGV0IGdsb2JhbEZpeHR1cmVDb250ZXh0O1xuXG4gIC8vIHdlIGhhbmRsZSBnbG9iYWwgZml4dHVyZXMgbWFudWFsbHlcbiAgbW9jaGEuZW5hYmxlR2xvYmFsU2V0dXAoZmFsc2UpLmVuYWJsZUdsb2JhbFRlYXJkb3duKGZhbHNlKTtcblxuICBjb25zdCB3YXRjaGVyID0gY2hva2lkYXIud2F0Y2god2F0Y2hGaWxlcywge1xuICAgIGlnbm9yZWQ6IHdhdGNoSWdub3JlLFxuICAgIGlnbm9yZUluaXRpYWw6IHRydWVcbiAgfSk7XG5cbiAgY29uc3QgcmVydW5uZXIgPSBjcmVhdGVSZXJ1bm5lcihtb2NoYSwgd2F0Y2hlciwge1xuICAgIGJlZm9yZVJ1blxuICB9KTtcblxuICB3YXRjaGVyLm9uKCdyZWFkeScsIGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWdsb2JhbEZpeHR1cmVDb250ZXh0KSB7XG4gICAgICBkZWJ1ZygndHJpZ2dlcmluZyBnbG9iYWwgc2V0dXAnKTtcbiAgICAgIGdsb2JhbEZpeHR1cmVDb250ZXh0ID0gYXdhaXQgbW9jaGEucnVuR2xvYmFsU2V0dXAoKTtcbiAgICB9XG4gICAgcmVydW5uZXIucnVuKCk7XG4gIH0pO1xuXG4gIHdhdGNoZXIub24oJ2FsbCcsICgpID0+IHtcbiAgICByZXJ1bm5lci5zY2hlZHVsZVJ1bigpO1xuICB9KTtcblxuICBoaWRlQ3Vyc29yKCk7XG4gIHByb2Nlc3Mub24oJ2V4aXQnLCAoKSA9PiB7XG4gICAgc2hvd0N1cnNvcigpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIGZvciB0ZXN0aW5nLlxuICAvLyB3aW4zMiBjYW5ub3QgZ3JhY2VmdWxseSBzaHV0ZG93biB2aWEgYSBzaWduYWwgZnJvbSBhIHBhcmVudFxuICAvLyBwcm9jZXNzOyBhIGBTSUdJTlRgIGZyb20gYSBwYXJlbnQgd2lsbCBjYXVzZSB0aGUgcHJvY2Vzc1xuICAvLyB0byBpbW1lZGlhdGVseSBleGl0LiAgZHVyaW5nIG5vcm1hbCBjb3Vyc2Ugb2Ygb3BlcmF0aW9uLCBhIHVzZXJcbiAgLy8gd2lsbCB0eXBlIEN0cmwtQyBhbmQgdGhlIGxpc3RlbmVyIHdpbGwgYmUgaW52b2tlZCwgYnV0IHRoaXNcbiAgLy8gaXMgbm90IHBvc3NpYmxlIGluIGF1dG9tYXRlZCB0ZXN0aW5nLlxuICAvLyB0aGVyZSBtYXkgYmUgYW5vdGhlciB3YXkgdG8gc29sdmUgdGhpcywgYnV0IGl0IHRvbyB3aWxsIGJlIGEgaGFjay5cbiAgLy8gZm9yIG91ciB3YXRjaCB0ZXN0cyBvbiB3aW4zMiB3ZSBtdXN0IF9mb3JrXyBtb2NoYSB3aXRoIGFuIElQQyBjaGFubmVsXG4gIGlmIChwcm9jZXNzLmNvbm5lY3RlZCkge1xuICAgIHByb2Nlc3Mub24oJ21lc3NhZ2UnLCBtc2cgPT4ge1xuICAgICAgaWYgKG1zZyA9PT0gJ1NJR0lOVCcpIHtcbiAgICAgICAgcHJvY2Vzcy5lbWl0KCdTSUdJTlQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGxldCBleGl0aW5nID0gZmFsc2U7XG4gIHByb2Nlc3Mub24oJ1NJR0lOVCcsIGFzeW5jICgpID0+IHtcbiAgICBzaG93Q3Vyc29yKCk7XG4gICAgY29uc29sZS5lcnJvcihgJHtsb2dTeW1ib2xzLndhcm5pbmd9IFttb2NoYV0gY2xlYW5pbmcgdXAsIHBsZWFzZSB3YWl0Li4uYCk7XG4gICAgaWYgKCFleGl0aW5nKSB7XG4gICAgICBleGl0aW5nID0gdHJ1ZTtcbiAgICAgIGlmIChtb2NoYS5oYXNHbG9iYWxUZWFyZG93bkZpeHR1cmVzKCkpIHtcbiAgICAgICAgZGVidWcoJ3J1bm5pbmcgZ2xvYmFsIHRlYXJkb3duJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgbW9jaGEucnVuR2xvYmFsVGVhcmRvd24oZ2xvYmFsRml4dHVyZUNvbnRleHQpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByb2Nlc3MuZXhpdCgxMzApO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gS2V5Ym9hcmQgc2hvcnRjdXQgZm9yIHJlc3RhcnRpbmcgd2hlbiBcInJzXFxuXCIgaXMgdHlwZWQgKGFsYSBOb2RlbW9uKVxuICBwcm9jZXNzLnN0ZGluLnJlc3VtZSgpO1xuICBwcm9jZXNzLnN0ZGluLnNldEVuY29kaW5nKCd1dGY4Jyk7XG4gIHByb2Nlc3Muc3RkaW4ub24oJ2RhdGEnLCBkYXRhID0+IHtcbiAgICBjb25zdCBzdHIgPSBkYXRhLnRvU3RyaW5nKCkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHN0ciA9PT0gJ3JzJykgcmVydW5uZXIuc2NoZWR1bGVSdW4oKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHdhdGNoZXI7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbiBvYmplY3QgdGhhdCBhbGxvd3MgeW91IHRvIHJlcnVuIHRlc3RzIG9uIHRoZSBtb2NoYSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge01vY2hhfSBtb2NoYSAtIE1vY2hhIGluc3RhbmNlXG4gKiBAcGFyYW0ge0ZTV2F0Y2hlcn0gd2F0Y2hlciAtIGNob2tpZGFyIGBGU1dhdGNoZXJgIGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gT3B0aW9ucyFcbiAqIEBwYXJhbSB7QmVmb3JlV2F0Y2hSdW59IFtvcHRzLmJlZm9yZVJ1bl0gLSBGdW5jdGlvbiB0byBjYWxsIGJlZm9yZSBgbW9jaGEucnVuKClgXG4gKiBAcmV0dXJucyB7UmVydW5uZXJ9XG4gKiBAaWdub3JlXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBjcmVhdGVSZXJ1bm5lciA9IChtb2NoYSwgd2F0Y2hlciwge2JlZm9yZVJ1bn0gPSB7fSkgPT4ge1xuICAvLyBTZXQgdG8gYSBgUnVubmVyYCB3aGVuIG1vY2hhIGlzIHJ1bm5pbmcuIFNldCB0byBgbnVsbGAgd2hlbiBtb2NoYSBpcyBub3RcbiAgLy8gcnVubmluZy5cbiAgbGV0IHJ1bm5lciA9IG51bGw7XG5cbiAgLy8gdHJ1ZSBpZiBhIGZpbGUgaGFzIGNoYW5nZWQgZHVyaW5nIGEgdGVzdCBydW5cbiAgbGV0IHJlcnVuU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgY29uc3QgcnVuID0gKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBtb2NoYSA9IGJlZm9yZVJ1biA/IGJlZm9yZVJ1bih7bW9jaGEsIHdhdGNoZXJ9KSB8fCBtb2NoYSA6IG1vY2hhO1xuICAgICAgcnVubmVyID0gbW9jaGEucnVuKCgpID0+IHtcbiAgICAgICAgZGVidWcoJ2ZpbmlzaGVkIHdhdGNoIHJ1bicpO1xuICAgICAgICBydW5uZXIgPSBudWxsO1xuICAgICAgICBibGFzdENhY2hlKHdhdGNoZXIpO1xuICAgICAgICBpZiAocmVydW5TY2hlZHVsZWQpIHtcbiAgICAgICAgICByZXJ1bigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCR7bG9nU3ltYm9scy5pbmZvfSBbbW9jaGFdIHdhaXRpbmcgZm9yIGNoYW5nZXMuLi5gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlLnN0YWNrKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc2NoZWR1bGVSdW4gPSAoKSA9PiB7XG4gICAgaWYgKHJlcnVuU2NoZWR1bGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVydW5TY2hlZHVsZWQgPSB0cnVlO1xuICAgIGlmIChydW5uZXIpIHtcbiAgICAgIHJ1bm5lci5hYm9ydCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXJ1bigpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCByZXJ1biA9ICgpID0+IHtcbiAgICByZXJ1blNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGVyYXNlTGluZSgpO1xuICAgIHJ1bigpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgc2NoZWR1bGVSdW4sXG4gICAgcnVuXG4gIH07XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdCBvZiBhYnNvbHV0ZSBwYXRocyB3YXRjaGVkIGJ5IGEgY2hva2lkYXIgd2F0Y2hlci5cbiAqXG4gKiBAcGFyYW0gd2F0Y2hlciAtIEluc3RhbmNlIG9mIGEgY2hva2lkYXIgd2F0Y2hlclxuICogQHJldHVybiB7c3RyaW5nW119IC0gTGlzdCBvZiBhYnNvbHV0ZSBwYXRoc1xuICogQGlnbm9yZVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgZ2V0V2F0Y2hlZEZpbGVzID0gd2F0Y2hlciA9PiB7XG4gIGNvbnN0IHdhdGNoZWREaXJzID0gd2F0Y2hlci5nZXRXYXRjaGVkKCk7XG4gIHJldHVybiBPYmplY3Qua2V5cyh3YXRjaGVkRGlycykucmVkdWNlKFxuICAgIChhY2MsIGRpcikgPT4gW1xuICAgICAgLi4uYWNjLFxuICAgICAgLi4ud2F0Y2hlZERpcnNbZGlyXS5tYXAoZmlsZSA9PiBwYXRoLmpvaW4oZGlyLCBmaWxlKSlcbiAgICBdLFxuICAgIFtdXG4gICk7XG59O1xuXG4vKipcbiAqIEhpZGUgdGhlIGN1cnNvci5cbiAqIEBpZ25vcmVcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGhpZGVDdXJzb3IgPSAoKSA9PiB7XG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXHUwMDFiWz8yNWwnKTtcbn07XG5cbi8qKlxuICogU2hvdyB0aGUgY3Vyc29yLlxuICogQGlnbm9yZVxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgc2hvd0N1cnNvciA9ICgpID0+IHtcbiAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcdTAwMWJbPzI1aCcpO1xufTtcblxuLyoqXG4gKiBFcmFzZXMgdGhlIGxpbmUgb24gc3Rkb3V0XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBlcmFzZUxpbmUgPSAoKSA9PiB7XG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXHUwMDFiWzJLJyk7XG59O1xuXG4vKipcbiAqIEJsYXN0IGFsbCBvZiB0aGUgd2F0Y2hlZCBmaWxlcyBvdXQgb2YgYHJlcXVpcmUuY2FjaGVgXG4gKiBAcGFyYW0ge0ZTV2F0Y2hlcn0gd2F0Y2hlciAtIGNob2tpZGFyIEZTV2F0Y2hlclxuICogQGlnbm9yZVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgYmxhc3RDYWNoZSA9IHdhdGNoZXIgPT4ge1xuICBjb25zdCBmaWxlcyA9IGdldFdhdGNoZWRGaWxlcyh3YXRjaGVyKTtcbiAgZmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICBkZWxldGUgcmVxdWlyZS5jYWNoZVtmaWxlXTtcbiAgfSk7XG4gIGRlYnVnKCdkZWxldGVkICVkIGZpbGUocykgZnJvbSB0aGUgcmVxdWlyZSBjYWNoZScsIGZpbGVzLmxlbmd0aCk7XG59O1xuXG4vKipcbiAqIENhbGxiYWNrIHRvIGJlIHJ1biBiZWZvcmUgYG1vY2hhLnJ1bigpYCBpcyBjYWxsZWQuXG4gKiBPcHRpb25hbGx5LCBpdCBjYW4gcmV0dXJuIGEgbmV3IGBNb2NoYWAgaW5zdGFuY2UuXG4gKiBAY2FsbGJhY2sgQmVmb3JlV2F0Y2hSdW5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3ttb2NoYTogTW9jaGEsIHdhdGNoZXI6IEZTV2F0Y2hlcn19IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtNb2NoYX1cbiAqL1xuXG4vKipcbiAqIE9iamVjdCBjb250YWluaW5nIHJ1biBjb250cm9sIG1ldGhvZHNcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlcnVubmVyXG4gKiBAcHJpdmF0ZVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcnVuIC0gQ2FsbHMgYG1vY2hhLnJ1bigpYFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gc2NoZWR1bGVSdW4gLSBTY2hlZHVsZXMgYW5vdGhlciBjYWxsIHRvIGBydW5gXG4gKi9cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/cli/watch-run.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/context.js":
/*!*******************************************!*\
  !*** ./node_modules/mocha/lib/context.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("\n/**\n * @module Context\n */\n/**\n * Expose `Context`.\n */\n\nmodule.exports = Context;\n\n/**\n * Initialize a new `Context`.\n *\n * @private\n */\nfunction Context() {}\n\n/**\n * Set or get the context `Runnable` to `runnable`.\n *\n * @private\n * @param {Runnable} runnable\n * @return {Context} context\n */\nContext.prototype.runnable = function (runnable) {\n  if (!arguments.length) {\n    return this._runnable;\n  }\n  this.test = this._runnable = runnable;\n  return this;\n};\n\n/**\n * Set or get test timeout `ms`.\n *\n * @private\n * @param {number} ms\n * @return {Context} self\n */\nContext.prototype.timeout = function (ms) {\n  if (!arguments.length) {\n    return this.runnable().timeout();\n  }\n  this.runnable().timeout(ms);\n  return this;\n};\n\n/**\n * Set or get test slowness threshold `ms`.\n *\n * @private\n * @param {number} ms\n * @return {Context} self\n */\nContext.prototype.slow = function (ms) {\n  if (!arguments.length) {\n    return this.runnable().slow();\n  }\n  this.runnable().slow(ms);\n  return this;\n};\n\n/**\n * Mark a test as skipped.\n *\n * @private\n * @throws Pending\n */\nContext.prototype.skip = function () {\n  this.runnable().skip();\n};\n\n/**\n * Set or get a number of allowed retries on failed tests\n *\n * @private\n * @param {number} n\n * @return {Context} self\n */\nContext.prototype.retries = function (n) {\n  if (!arguments.length) {\n    return this.runnable().retries();\n  }\n  this.runnable().retries(n);\n  return this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2NvbnRleHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2NvbnRleHQuanM/Mjc2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBtb2R1bGUgQ29udGV4dFxuICovXG4vKipcbiAqIEV4cG9zZSBgQ29udGV4dGAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBDb250ZXh0O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYENvbnRleHRgLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIENvbnRleHQoKSB7fVxuXG4vKipcbiAqIFNldCBvciBnZXQgdGhlIGNvbnRleHQgYFJ1bm5hYmxlYCB0byBgcnVubmFibGVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1J1bm5hYmxlfSBydW5uYWJsZVxuICogQHJldHVybiB7Q29udGV4dH0gY29udGV4dFxuICovXG5Db250ZXh0LnByb3RvdHlwZS5ydW5uYWJsZSA9IGZ1bmN0aW9uIChydW5uYWJsZSkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fcnVubmFibGU7XG4gIH1cbiAgdGhpcy50ZXN0ID0gdGhpcy5fcnVubmFibGUgPSBydW5uYWJsZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBvciBnZXQgdGVzdCB0aW1lb3V0IGBtc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBtc1xuICogQHJldHVybiB7Q29udGV4dH0gc2VsZlxuICovXG5Db250ZXh0LnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnJ1bm5hYmxlKCkudGltZW91dCgpO1xuICB9XG4gIHRoaXMucnVubmFibGUoKS50aW1lb3V0KG1zKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBvciBnZXQgdGVzdCBzbG93bmVzcyB0aHJlc2hvbGQgYG1zYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtDb250ZXh0fSBzZWxmXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnNsb3cgPSBmdW5jdGlvbiAobXMpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMucnVubmFibGUoKS5zbG93KCk7XG4gIH1cbiAgdGhpcy5ydW5uYWJsZSgpLnNsb3cobXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTWFyayBhIHRlc3QgYXMgc2tpcHBlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHRocm93cyBQZW5kaW5nXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucnVubmFibGUoKS5za2lwKCk7XG59O1xuXG4vKipcbiAqIFNldCBvciBnZXQgYSBudW1iZXIgb2YgYWxsb3dlZCByZXRyaWVzIG9uIGZhaWxlZCB0ZXN0c1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gblxuICogQHJldHVybiB7Q29udGV4dH0gc2VsZlxuICovXG5Db250ZXh0LnByb3RvdHlwZS5yZXRyaWVzID0gZnVuY3Rpb24gKG4pIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMucnVubmFibGUoKS5yZXRyaWVzKCk7XG4gIH1cbiAgdGhpcy5ydW5uYWJsZSgpLnJldHJpZXMobik7XG4gIHJldHVybiB0aGlzO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/context.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/errors.js":
/*!******************************************!*\
  !*** ./node_modules/mocha/lib/errors.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {format} = __webpack_require__(/*! util */ \"util\");\n\n/**\n * Contains error codes, factory functions to create throwable error objects,\n * and warning/deprecation functions.\n * @module\n */\n\n/**\n * process.emitWarning or a polyfill\n * @see https://nodejs.org/api/process.html#process_process_emitwarning_warning_options\n * @ignore\n */\nconst emitWarning = (msg, type) => {\n  if (process.emitWarning) {\n    process.emitWarning(msg, type);\n  } else {\n    /* istanbul ignore next */\n    process.nextTick(function () {\n      console.warn(type + ': ' + msg);\n    });\n  }\n};\n\n/**\n * Show a deprecation warning. Each distinct message is only displayed once.\n * Ignores empty messages.\n *\n * @param {string} [msg] - Warning to print\n * @private\n */\nconst deprecate = msg => {\n  msg = String(msg);\n  if (msg && !deprecate.cache[msg]) {\n    deprecate.cache[msg] = true;\n    emitWarning(msg, 'DeprecationWarning');\n  }\n};\ndeprecate.cache = {};\n\n/**\n * Show a generic warning.\n * Ignores empty messages.\n *\n * @param {string} [msg] - Warning to print\n * @private\n */\nconst warn = msg => {\n  if (msg) {\n    emitWarning(msg);\n  }\n};\n\n/**\n * When Mocha throws exceptions (or rejects `Promise`s), it attempts to assign a `code` property to the `Error` object, for easier handling. These are the potential values of `code`.\n * @public\n * @namespace\n * @memberof module:lib/errors\n */\nvar constants = {\n  /**\n   * An unrecoverable error.\n   * @constant\n   * @default\n   */\n  FATAL: 'ERR_MOCHA_FATAL',\n\n  /**\n   * The type of an argument to a function call is invalid\n   * @constant\n   * @default\n   */\n  INVALID_ARG_TYPE: 'ERR_MOCHA_INVALID_ARG_TYPE',\n\n  /**\n   * The value of an argument to a function call is invalid\n   * @constant\n   * @default\n   */\n  INVALID_ARG_VALUE: 'ERR_MOCHA_INVALID_ARG_VALUE',\n\n  /**\n   * Something was thrown, but it wasn't an `Error`\n   * @constant\n   * @default\n   */\n  INVALID_EXCEPTION: 'ERR_MOCHA_INVALID_EXCEPTION',\n\n  /**\n   * An interface (e.g., `Mocha.interfaces`) is unknown or invalid\n   * @constant\n   * @default\n   */\n  INVALID_INTERFACE: 'ERR_MOCHA_INVALID_INTERFACE',\n\n  /**\n   * A reporter (.e.g, `Mocha.reporters`) is unknown or invalid\n   * @constant\n   * @default\n   */\n  INVALID_REPORTER: 'ERR_MOCHA_INVALID_REPORTER',\n\n  /**\n   * `done()` was called twice in a `Test` or `Hook` callback\n   * @constant\n   * @default\n   */\n  MULTIPLE_DONE: 'ERR_MOCHA_MULTIPLE_DONE',\n\n  /**\n   * No files matched the pattern provided by the user\n   * @constant\n   * @default\n   */\n  NO_FILES_MATCH_PATTERN: 'ERR_MOCHA_NO_FILES_MATCH_PATTERN',\n\n  /**\n   * Known, but unsupported behavior of some kind\n   * @constant\n   * @default\n   */\n  UNSUPPORTED: 'ERR_MOCHA_UNSUPPORTED',\n\n  /**\n   * Invalid state transition occurring in `Mocha` instance\n   * @constant\n   * @default\n   */\n  INSTANCE_ALREADY_RUNNING: 'ERR_MOCHA_INSTANCE_ALREADY_RUNNING',\n\n  /**\n   * Invalid state transition occurring in `Mocha` instance\n   * @constant\n   * @default\n   */\n  INSTANCE_ALREADY_DISPOSED: 'ERR_MOCHA_INSTANCE_ALREADY_DISPOSED',\n\n  /**\n   * Use of `only()` w/ `--forbid-only` results in this error.\n   * @constant\n   * @default\n   */\n  FORBIDDEN_EXCLUSIVITY: 'ERR_MOCHA_FORBIDDEN_EXCLUSIVITY',\n\n  /**\n   * To be thrown when a user-defined plugin implementation (e.g., `mochaHooks`) is invalid\n   * @constant\n   * @default\n   */\n  INVALID_PLUGIN_IMPLEMENTATION: 'ERR_MOCHA_INVALID_PLUGIN_IMPLEMENTATION',\n\n  /**\n   * To be thrown when a builtin or third-party plugin definition (the _definition_ of `mochaHooks`) is invalid\n   * @constant\n   * @default\n   */\n  INVALID_PLUGIN_DEFINITION: 'ERR_MOCHA_INVALID_PLUGIN_DEFINITION',\n\n  /**\n   * When a runnable exceeds its allowed run time.\n   * @constant\n   * @default\n   */\n  TIMEOUT: 'ERR_MOCHA_TIMEOUT',\n\n  /**\n   * Input file is not able to be parsed\n   * @constant\n   * @default\n   */\n  UNPARSABLE_FILE: 'ERR_MOCHA_UNPARSABLE_FILE'\n};\n\n/**\n * A set containing all string values of all Mocha error constants, for use by {@link isMochaError}.\n * @private\n */\nconst MOCHA_ERRORS = new Set(Object.values(constants));\n\n/**\n * Creates an error object to be thrown when no files to be tested could be found using specified pattern.\n *\n * @public\n * @static\n * @param {string} message - Error message to be displayed.\n * @param {string} pattern - User-specified argument value.\n * @returns {Error} instance detailing the error condition\n */\nfunction createNoFilesMatchPatternError(message, pattern) {\n  var err = new Error(message);\n  err.code = constants.NO_FILES_MATCH_PATTERN;\n  err.pattern = pattern;\n  return err;\n}\n\n/**\n * Creates an error object to be thrown when the reporter specified in the options was not found.\n *\n * @public\n * @param {string} message - Error message to be displayed.\n * @param {string} reporter - User-specified reporter value.\n * @returns {Error} instance detailing the error condition\n */\nfunction createInvalidReporterError(message, reporter) {\n  var err = new TypeError(message);\n  err.code = constants.INVALID_REPORTER;\n  err.reporter = reporter;\n  return err;\n}\n\n/**\n * Creates an error object to be thrown when the interface specified in the options was not found.\n *\n * @public\n * @static\n * @param {string} message - Error message to be displayed.\n * @param {string} ui - User-specified interface value.\n * @returns {Error} instance detailing the error condition\n */\nfunction createInvalidInterfaceError(message, ui) {\n  var err = new Error(message);\n  err.code = constants.INVALID_INTERFACE;\n  err.interface = ui;\n  return err;\n}\n\n/**\n * Creates an error object to be thrown when a behavior, option, or parameter is unsupported.\n *\n * @public\n * @static\n * @param {string} message - Error message to be displayed.\n * @returns {Error} instance detailing the error condition\n */\nfunction createUnsupportedError(message) {\n  var err = new Error(message);\n  err.code = constants.UNSUPPORTED;\n  return err;\n}\n\n/**\n * Creates an error object to be thrown when an argument is missing.\n *\n * @public\n * @static\n * @param {string} message - Error message to be displayed.\n * @param {string} argument - Argument name.\n * @param {string} expected - Expected argument datatype.\n * @returns {Error} instance detailing the error condition\n */\nfunction createMissingArgumentError(message, argument, expected) {\n  return createInvalidArgumentTypeError(message, argument, expected);\n}\n\n/**\n * Creates an error object to be thrown when an argument did not use the supported type\n *\n * @public\n * @static\n * @param {string} message - Error message to be displayed.\n * @param {string} argument - Argument name.\n * @param {string} expected - Expected argument datatype.\n * @returns {Error} instance detailing the error condition\n */\nfunction createInvalidArgumentTypeError(message, argument, expected) {\n  var err = new TypeError(message);\n  err.code = constants.INVALID_ARG_TYPE;\n  err.argument = argument;\n  err.expected = expected;\n  err.actual = typeof argument;\n  return err;\n}\n\n/**\n * Creates an error object to be thrown when an argument did not use the supported value\n *\n * @public\n * @static\n * @param {string} message - Error message to be displayed.\n * @param {string} argument - Argument name.\n * @param {string} value - Argument value.\n * @param {string} [reason] - Why value is invalid.\n * @returns {Error} instance detailing the error condition\n */\nfunction createInvalidArgumentValueError(message, argument, value, reason) {\n  var err = new TypeError(message);\n  err.code = constants.INVALID_ARG_VALUE;\n  err.argument = argument;\n  err.value = value;\n  err.reason = typeof reason !== 'undefined' ? reason : 'is invalid';\n  return err;\n}\n\n/**\n * Creates an error object to be thrown when an exception was caught, but the `Error` is falsy or undefined.\n *\n * @public\n * @static\n * @param {string} message - Error message to be displayed.\n * @returns {Error} instance detailing the error condition\n */\nfunction createInvalidExceptionError(message, value) {\n  var err = new Error(message);\n  err.code = constants.INVALID_EXCEPTION;\n  err.valueType = typeof value;\n  err.value = value;\n  return err;\n}\n\n/**\n * Creates an error object to be thrown when an unrecoverable error occurs.\n *\n * @public\n * @static\n * @param {string} message - Error message to be displayed.\n * @returns {Error} instance detailing the error condition\n */\nfunction createFatalError(message, value) {\n  var err = new Error(message);\n  err.code = constants.FATAL;\n  err.valueType = typeof value;\n  err.value = value;\n  return err;\n}\n\n/**\n * Dynamically creates a plugin-type-specific error based on plugin type\n * @param {string} message - Error message\n * @param {\"reporter\"|\"ui\"} pluginType - Plugin type. Future: expand as needed\n * @param {string} [pluginId] - Name/path of plugin, if any\n * @throws When `pluginType` is not known\n * @public\n * @static\n * @returns {Error}\n */\nfunction createInvalidLegacyPluginError(message, pluginType, pluginId) {\n  switch (pluginType) {\n    case 'reporter':\n      return createInvalidReporterError(message, pluginId);\n    case 'ui':\n      return createInvalidInterfaceError(message, pluginId);\n    default:\n      throw new Error('unknown pluginType \"' + pluginType + '\"');\n  }\n}\n\n/**\n * **DEPRECATED**.  Use {@link createInvalidLegacyPluginError} instead  Dynamically creates a plugin-type-specific error based on plugin type\n * @deprecated\n * @param {string} message - Error message\n * @param {\"reporter\"|\"interface\"} pluginType - Plugin type. Future: expand as needed\n * @param {string} [pluginId] - Name/path of plugin, if any\n * @throws When `pluginType` is not known\n * @public\n * @static\n * @returns {Error}\n */\nfunction createInvalidPluginError(...args) {\n  deprecate('Use createInvalidLegacyPluginError() instead');\n  return createInvalidLegacyPluginError(...args);\n}\n\n/**\n * Creates an error object to be thrown when a mocha object's `run` method is executed while it is already disposed.\n * @param {string} message The error message to be displayed.\n * @param {boolean} cleanReferencesAfterRun the value of `cleanReferencesAfterRun`\n * @param {Mocha} instance the mocha instance that throw this error\n * @static\n */\nfunction createMochaInstanceAlreadyDisposedError(\n  message,\n  cleanReferencesAfterRun,\n  instance\n) {\n  var err = new Error(message);\n  err.code = constants.INSTANCE_ALREADY_DISPOSED;\n  err.cleanReferencesAfterRun = cleanReferencesAfterRun;\n  err.instance = instance;\n  return err;\n}\n\n/**\n * Creates an error object to be thrown when a mocha object's `run` method is called while a test run is in progress.\n * @param {string} message The error message to be displayed.\n * @static\n * @public\n */\nfunction createMochaInstanceAlreadyRunningError(message, instance) {\n  var err = new Error(message);\n  err.code = constants.INSTANCE_ALREADY_RUNNING;\n  err.instance = instance;\n  return err;\n}\n\n/**\n * Creates an error object to be thrown when done() is called multiple times in a test\n *\n * @public\n * @param {Runnable} runnable - Original runnable\n * @param {Error} [originalErr] - Original error, if any\n * @returns {Error} instance detailing the error condition\n * @static\n */\nfunction createMultipleDoneError(runnable, originalErr) {\n  var title;\n  try {\n    title = format('<%s>', runnable.fullTitle());\n    if (runnable.parent.root) {\n      title += ' (of root suite)';\n    }\n  } catch (ignored) {\n    title = format('<%s> (of unknown suite)', runnable.title);\n  }\n  var message = format(\n    'done() called multiple times in %s %s',\n    runnable.type ? runnable.type : 'unknown runnable',\n    title\n  );\n  if (runnable.file) {\n    message += format(' of file %s', runnable.file);\n  }\n  if (originalErr) {\n    message += format('; in addition, done() received error: %s', originalErr);\n  }\n\n  var err = new Error(message);\n  err.code = constants.MULTIPLE_DONE;\n  err.valueType = typeof originalErr;\n  err.value = originalErr;\n  return err;\n}\n\n/**\n * Creates an error object to be thrown when `.only()` is used with\n * `--forbid-only`.\n * @static\n * @public\n * @param {Mocha} mocha - Mocha instance\n * @returns {Error} Error with code {@link constants.FORBIDDEN_EXCLUSIVITY}\n */\nfunction createForbiddenExclusivityError(mocha) {\n  var err = new Error(\n    mocha.isWorker\n      ? '`.only` is not supported in parallel mode'\n      : '`.only` forbidden by --forbid-only'\n  );\n  err.code = constants.FORBIDDEN_EXCLUSIVITY;\n  return err;\n}\n\n/**\n * Creates an error object to be thrown when a plugin definition is invalid\n * @static\n * @param {string} msg - Error message\n * @param {PluginDefinition} [pluginDef] - Problematic plugin definition\n * @public\n * @returns {Error} Error with code {@link constants.INVALID_PLUGIN_DEFINITION}\n */\nfunction createInvalidPluginDefinitionError(msg, pluginDef) {\n  const err = new Error(msg);\n  err.code = constants.INVALID_PLUGIN_DEFINITION;\n  err.pluginDef = pluginDef;\n  return err;\n}\n\n/**\n * Creates an error object to be thrown when a plugin implementation (user code) is invalid\n * @static\n * @param {string} msg - Error message\n * @param {Object} [opts] - Plugin definition and user-supplied implementation\n * @param {PluginDefinition} [opts.pluginDef] - Plugin Definition\n * @param {*} [opts.pluginImpl] - Plugin Implementation (user-supplied)\n * @public\n * @returns {Error} Error with code {@link constants.INVALID_PLUGIN_DEFINITION}\n */\nfunction createInvalidPluginImplementationError(\n  msg,\n  {pluginDef, pluginImpl} = {}\n) {\n  const err = new Error(msg);\n  err.code = constants.INVALID_PLUGIN_IMPLEMENTATION;\n  err.pluginDef = pluginDef;\n  err.pluginImpl = pluginImpl;\n  return err;\n}\n\n/**\n * Creates an error object to be thrown when a runnable exceeds its allowed run time.\n * @static\n * @param {string} msg - Error message\n * @param {number} [timeout] - Timeout in ms\n * @param {string} [file] - File, if given\n * @returns {MochaTimeoutError}\n */\nfunction createTimeoutError(msg, timeout, file) {\n  const err = new Error(msg);\n  err.code = constants.TIMEOUT;\n  err.timeout = timeout;\n  err.file = file;\n  return err;\n}\n\n/**\n * Creates an error object to be thrown when file is unparsable\n * @public\n * @static\n * @param {string} message - Error message to be displayed.\n * @param {string} filename - File name\n * @returns {Error} Error with code {@link constants.UNPARSABLE_FILE}\n */\nfunction createUnparsableFileError(message, filename) {\n  var err = new Error(message);\n  err.code = constants.UNPARSABLE_FILE;\n  return err;\n}\n\n/**\n * Returns `true` if an error came out of Mocha.\n * _Can suffer from false negatives, but not false positives._\n * @static\n * @public\n * @param {*} err - Error, or anything\n * @returns {boolean}\n */\nconst isMochaError = err =>\n  Boolean(err && typeof err === 'object' && MOCHA_ERRORS.has(err.code));\n\nmodule.exports = {\n  constants,\n  createFatalError,\n  createForbiddenExclusivityError,\n  createInvalidArgumentTypeError,\n  createInvalidArgumentValueError,\n  createInvalidExceptionError,\n  createInvalidInterfaceError,\n  createInvalidLegacyPluginError,\n  createInvalidPluginDefinitionError,\n  createInvalidPluginError,\n  createInvalidPluginImplementationError,\n  createInvalidReporterError,\n  createMissingArgumentError,\n  createMochaInstanceAlreadyDisposedError,\n  createMochaInstanceAlreadyRunningError,\n  createMultipleDoneError,\n  createNoFilesMatchPatternError,\n  createTimeoutError,\n  createUnparsableFileError,\n  createUnsupportedError,\n  deprecate,\n  isMochaError,\n  warn\n};\n\n/**\n * The error thrown when a Runnable times out\n * @memberof module:lib/errors\n * @typedef {Error} MochaTimeoutError\n * @property {constants.TIMEOUT} code - Error code\n * @property {number?} timeout Timeout in ms\n * @property {string?} file Filepath, if given\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixPQUFPLFFBQVEsRUFBRSxtQkFBTyxDQUFDLGtCQUFNOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdGQUFnRixtQkFBbUI7QUFDbkc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Y2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2Vycm9ycy5qcz9iYjFkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3Qge2Zvcm1hdH0gPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8qKlxuICogQ29udGFpbnMgZXJyb3IgY29kZXMsIGZhY3RvcnkgZnVuY3Rpb25zIHRvIGNyZWF0ZSB0aHJvd2FibGUgZXJyb3Igb2JqZWN0cyxcbiAqIGFuZCB3YXJuaW5nL2RlcHJlY2F0aW9uIGZ1bmN0aW9ucy5cbiAqIEBtb2R1bGVcbiAqL1xuXG4vKipcbiAqIHByb2Nlc3MuZW1pdFdhcm5pbmcgb3IgYSBwb2x5ZmlsbFxuICogQHNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL3Byb2Nlc3MuaHRtbCNwcm9jZXNzX3Byb2Nlc3NfZW1pdHdhcm5pbmdfd2FybmluZ19vcHRpb25zXG4gKiBAaWdub3JlXG4gKi9cbmNvbnN0IGVtaXRXYXJuaW5nID0gKG1zZywgdHlwZSkgPT4ge1xuICBpZiAocHJvY2Vzcy5lbWl0V2FybmluZykge1xuICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcobXNnLCB0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgY29uc29sZS53YXJuKHR5cGUgKyAnOiAnICsgbXNnKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBTaG93IGEgZGVwcmVjYXRpb24gd2FybmluZy4gRWFjaCBkaXN0aW5jdCBtZXNzYWdlIGlzIG9ubHkgZGlzcGxheWVkIG9uY2UuXG4gKiBJZ25vcmVzIGVtcHR5IG1lc3NhZ2VzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbXNnXSAtIFdhcm5pbmcgdG8gcHJpbnRcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGRlcHJlY2F0ZSA9IG1zZyA9PiB7XG4gIG1zZyA9IFN0cmluZyhtc2cpO1xuICBpZiAobXNnICYmICFkZXByZWNhdGUuY2FjaGVbbXNnXSkge1xuICAgIGRlcHJlY2F0ZS5jYWNoZVttc2ddID0gdHJ1ZTtcbiAgICBlbWl0V2FybmluZyhtc2csICdEZXByZWNhdGlvbldhcm5pbmcnKTtcbiAgfVxufTtcbmRlcHJlY2F0ZS5jYWNoZSA9IHt9O1xuXG4vKipcbiAqIFNob3cgYSBnZW5lcmljIHdhcm5pbmcuXG4gKiBJZ25vcmVzIGVtcHR5IG1lc3NhZ2VzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbXNnXSAtIFdhcm5pbmcgdG8gcHJpbnRcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHdhcm4gPSBtc2cgPT4ge1xuICBpZiAobXNnKSB7XG4gICAgZW1pdFdhcm5pbmcobXNnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXaGVuIE1vY2hhIHRocm93cyBleGNlcHRpb25zIChvciByZWplY3RzIGBQcm9taXNlYHMpLCBpdCBhdHRlbXB0cyB0byBhc3NpZ24gYSBgY29kZWAgcHJvcGVydHkgdG8gdGhlIGBFcnJvcmAgb2JqZWN0LCBmb3IgZWFzaWVyIGhhbmRsaW5nLiBUaGVzZSBhcmUgdGhlIHBvdGVudGlhbCB2YWx1ZXMgb2YgYGNvZGVgLlxuICogQHB1YmxpY1xuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIG1vZHVsZTpsaWIvZXJyb3JzXG4gKi9cbnZhciBjb25zdGFudHMgPSB7XG4gIC8qKlxuICAgKiBBbiB1bnJlY292ZXJhYmxlIGVycm9yLlxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIEZBVEFMOiAnRVJSX01PQ0hBX0ZBVEFMJyxcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgYW4gYXJndW1lbnQgdG8gYSBmdW5jdGlvbiBjYWxsIGlzIGludmFsaWRcbiAgICogQGNvbnN0YW50XG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBJTlZBTElEX0FSR19UWVBFOiAnRVJSX01PQ0hBX0lOVkFMSURfQVJHX1RZUEUnLFxuXG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgb2YgYW4gYXJndW1lbnQgdG8gYSBmdW5jdGlvbiBjYWxsIGlzIGludmFsaWRcbiAgICogQGNvbnN0YW50XG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBJTlZBTElEX0FSR19WQUxVRTogJ0VSUl9NT0NIQV9JTlZBTElEX0FSR19WQUxVRScsXG5cbiAgLyoqXG4gICAqIFNvbWV0aGluZyB3YXMgdGhyb3duLCBidXQgaXQgd2Fzbid0IGFuIGBFcnJvcmBcbiAgICogQGNvbnN0YW50XG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBJTlZBTElEX0VYQ0VQVElPTjogJ0VSUl9NT0NIQV9JTlZBTElEX0VYQ0VQVElPTicsXG5cbiAgLyoqXG4gICAqIEFuIGludGVyZmFjZSAoZS5nLiwgYE1vY2hhLmludGVyZmFjZXNgKSBpcyB1bmtub3duIG9yIGludmFsaWRcbiAgICogQGNvbnN0YW50XG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBJTlZBTElEX0lOVEVSRkFDRTogJ0VSUl9NT0NIQV9JTlZBTElEX0lOVEVSRkFDRScsXG5cbiAgLyoqXG4gICAqIEEgcmVwb3J0ZXIgKC5lLmcsIGBNb2NoYS5yZXBvcnRlcnNgKSBpcyB1bmtub3duIG9yIGludmFsaWRcbiAgICogQGNvbnN0YW50XG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBJTlZBTElEX1JFUE9SVEVSOiAnRVJSX01PQ0hBX0lOVkFMSURfUkVQT1JURVInLFxuXG4gIC8qKlxuICAgKiBgZG9uZSgpYCB3YXMgY2FsbGVkIHR3aWNlIGluIGEgYFRlc3RgIG9yIGBIb29rYCBjYWxsYmFja1xuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIE1VTFRJUExFX0RPTkU6ICdFUlJfTU9DSEFfTVVMVElQTEVfRE9ORScsXG5cbiAgLyoqXG4gICAqIE5vIGZpbGVzIG1hdGNoZWQgdGhlIHBhdHRlcm4gcHJvdmlkZWQgYnkgdGhlIHVzZXJcbiAgICogQGNvbnN0YW50XG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBOT19GSUxFU19NQVRDSF9QQVRURVJOOiAnRVJSX01PQ0hBX05PX0ZJTEVTX01BVENIX1BBVFRFUk4nLFxuXG4gIC8qKlxuICAgKiBLbm93biwgYnV0IHVuc3VwcG9ydGVkIGJlaGF2aW9yIG9mIHNvbWUga2luZFxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIFVOU1VQUE9SVEVEOiAnRVJSX01PQ0hBX1VOU1VQUE9SVEVEJyxcblxuICAvKipcbiAgICogSW52YWxpZCBzdGF0ZSB0cmFuc2l0aW9uIG9jY3VycmluZyBpbiBgTW9jaGFgIGluc3RhbmNlXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgSU5TVEFOQ0VfQUxSRUFEWV9SVU5OSU5HOiAnRVJSX01PQ0hBX0lOU1RBTkNFX0FMUkVBRFlfUlVOTklORycsXG5cbiAgLyoqXG4gICAqIEludmFsaWQgc3RhdGUgdHJhbnNpdGlvbiBvY2N1cnJpbmcgaW4gYE1vY2hhYCBpbnN0YW5jZVxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIElOU1RBTkNFX0FMUkVBRFlfRElTUE9TRUQ6ICdFUlJfTU9DSEFfSU5TVEFOQ0VfQUxSRUFEWV9ESVNQT1NFRCcsXG5cbiAgLyoqXG4gICAqIFVzZSBvZiBgb25seSgpYCB3LyBgLS1mb3JiaWQtb25seWAgcmVzdWx0cyBpbiB0aGlzIGVycm9yLlxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIEZPUkJJRERFTl9FWENMVVNJVklUWTogJ0VSUl9NT0NIQV9GT1JCSURERU5fRVhDTFVTSVZJVFknLFxuXG4gIC8qKlxuICAgKiBUbyBiZSB0aHJvd24gd2hlbiBhIHVzZXItZGVmaW5lZCBwbHVnaW4gaW1wbGVtZW50YXRpb24gKGUuZy4sIGBtb2NoYUhvb2tzYCkgaXMgaW52YWxpZFxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIElOVkFMSURfUExVR0lOX0lNUExFTUVOVEFUSU9OOiAnRVJSX01PQ0hBX0lOVkFMSURfUExVR0lOX0lNUExFTUVOVEFUSU9OJyxcblxuICAvKipcbiAgICogVG8gYmUgdGhyb3duIHdoZW4gYSBidWlsdGluIG9yIHRoaXJkLXBhcnR5IHBsdWdpbiBkZWZpbml0aW9uICh0aGUgX2RlZmluaXRpb25fIG9mIGBtb2NoYUhvb2tzYCkgaXMgaW52YWxpZFxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIElOVkFMSURfUExVR0lOX0RFRklOSVRJT046ICdFUlJfTU9DSEFfSU5WQUxJRF9QTFVHSU5fREVGSU5JVElPTicsXG5cbiAgLyoqXG4gICAqIFdoZW4gYSBydW5uYWJsZSBleGNlZWRzIGl0cyBhbGxvd2VkIHJ1biB0aW1lLlxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIFRJTUVPVVQ6ICdFUlJfTU9DSEFfVElNRU9VVCcsXG5cbiAgLyoqXG4gICAqIElucHV0IGZpbGUgaXMgbm90IGFibGUgdG8gYmUgcGFyc2VkXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgVU5QQVJTQUJMRV9GSUxFOiAnRVJSX01PQ0hBX1VOUEFSU0FCTEVfRklMRSdcbn07XG5cbi8qKlxuICogQSBzZXQgY29udGFpbmluZyBhbGwgc3RyaW5nIHZhbHVlcyBvZiBhbGwgTW9jaGEgZXJyb3IgY29uc3RhbnRzLCBmb3IgdXNlIGJ5IHtAbGluayBpc01vY2hhRXJyb3J9LlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgTU9DSEFfRVJST1JTID0gbmV3IFNldChPYmplY3QudmFsdWVzKGNvbnN0YW50cykpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gZXJyb3Igb2JqZWN0IHRvIGJlIHRocm93biB3aGVuIG5vIGZpbGVzIHRvIGJlIHRlc3RlZCBjb3VsZCBiZSBmb3VuZCB1c2luZyBzcGVjaWZpZWQgcGF0dGVybi5cbiAqXG4gKiBAcHVibGljXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIEVycm9yIG1lc3NhZ2UgdG8gYmUgZGlzcGxheWVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm4gLSBVc2VyLXNwZWNpZmllZCBhcmd1bWVudCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gaW5zdGFuY2UgZGV0YWlsaW5nIHRoZSBlcnJvciBjb25kaXRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm9GaWxlc01hdGNoUGF0dGVybkVycm9yKG1lc3NhZ2UsIHBhdHRlcm4pIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgZXJyLmNvZGUgPSBjb25zdGFudHMuTk9fRklMRVNfTUFUQ0hfUEFUVEVSTjtcbiAgZXJyLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICByZXR1cm4gZXJyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZXJyb3Igb2JqZWN0IHRvIGJlIHRocm93biB3aGVuIHRoZSByZXBvcnRlciBzcGVjaWZpZWQgaW4gdGhlIG9wdGlvbnMgd2FzIG5vdCBmb3VuZC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIEVycm9yIG1lc3NhZ2UgdG8gYmUgZGlzcGxheWVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlcG9ydGVyIC0gVXNlci1zcGVjaWZpZWQgcmVwb3J0ZXIgdmFsdWUuXG4gKiBAcmV0dXJucyB7RXJyb3J9IGluc3RhbmNlIGRldGFpbGluZyB0aGUgZXJyb3IgY29uZGl0aW9uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWRSZXBvcnRlckVycm9yKG1lc3NhZ2UsIHJlcG9ydGVyKSB7XG4gIHZhciBlcnIgPSBuZXcgVHlwZUVycm9yKG1lc3NhZ2UpO1xuICBlcnIuY29kZSA9IGNvbnN0YW50cy5JTlZBTElEX1JFUE9SVEVSO1xuICBlcnIucmVwb3J0ZXIgPSByZXBvcnRlcjtcbiAgcmV0dXJuIGVycjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVycm9yIG9iamVjdCB0byBiZSB0aHJvd24gd2hlbiB0aGUgaW50ZXJmYWNlIHNwZWNpZmllZCBpbiB0aGUgb3B0aW9ucyB3YXMgbm90IGZvdW5kLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gRXJyb3IgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdWkgLSBVc2VyLXNwZWNpZmllZCBpbnRlcmZhY2UgdmFsdWUuXG4gKiBAcmV0dXJucyB7RXJyb3J9IGluc3RhbmNlIGRldGFpbGluZyB0aGUgZXJyb3IgY29uZGl0aW9uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWRJbnRlcmZhY2VFcnJvcihtZXNzYWdlLCB1aSkge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnIuY29kZSA9IGNvbnN0YW50cy5JTlZBTElEX0lOVEVSRkFDRTtcbiAgZXJyLmludGVyZmFjZSA9IHVpO1xuICByZXR1cm4gZXJyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZXJyb3Igb2JqZWN0IHRvIGJlIHRocm93biB3aGVuIGEgYmVoYXZpb3IsIG9wdGlvbiwgb3IgcGFyYW1ldGVyIGlzIHVuc3VwcG9ydGVkLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gRXJyb3IgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQuXG4gKiBAcmV0dXJucyB7RXJyb3J9IGluc3RhbmNlIGRldGFpbGluZyB0aGUgZXJyb3IgY29uZGl0aW9uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVVuc3VwcG9ydGVkRXJyb3IobWVzc2FnZSkge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnIuY29kZSA9IGNvbnN0YW50cy5VTlNVUFBPUlRFRDtcbiAgcmV0dXJuIGVycjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVycm9yIG9iamVjdCB0byBiZSB0aHJvd24gd2hlbiBhbiBhcmd1bWVudCBpcyBtaXNzaW5nLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gRXJyb3IgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJndW1lbnQgLSBBcmd1bWVudCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkIC0gRXhwZWN0ZWQgYXJndW1lbnQgZGF0YXR5cGUuXG4gKiBAcmV0dXJucyB7RXJyb3J9IGluc3RhbmNlIGRldGFpbGluZyB0aGUgZXJyb3IgY29uZGl0aW9uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1pc3NpbmdBcmd1bWVudEVycm9yKG1lc3NhZ2UsIGFyZ3VtZW50LCBleHBlY3RlZCkge1xuICByZXR1cm4gY3JlYXRlSW52YWxpZEFyZ3VtZW50VHlwZUVycm9yKG1lc3NhZ2UsIGFyZ3VtZW50LCBleHBlY3RlZCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgdG8gYmUgdGhyb3duIHdoZW4gYW4gYXJndW1lbnQgZGlkIG5vdCB1c2UgdGhlIHN1cHBvcnRlZCB0eXBlXG4gKlxuICogQHB1YmxpY1xuICogQHN0YXRpY1xuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBFcnJvciBtZXNzYWdlIHRvIGJlIGRpc3BsYXllZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmd1bWVudCAtIEFyZ3VtZW50IG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWQgLSBFeHBlY3RlZCBhcmd1bWVudCBkYXRhdHlwZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gaW5zdGFuY2UgZGV0YWlsaW5nIHRoZSBlcnJvciBjb25kaXRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW52YWxpZEFyZ3VtZW50VHlwZUVycm9yKG1lc3NhZ2UsIGFyZ3VtZW50LCBleHBlY3RlZCkge1xuICB2YXIgZXJyID0gbmV3IFR5cGVFcnJvcihtZXNzYWdlKTtcbiAgZXJyLmNvZGUgPSBjb25zdGFudHMuSU5WQUxJRF9BUkdfVFlQRTtcbiAgZXJyLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gIGVyci5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICBlcnIuYWN0dWFsID0gdHlwZW9mIGFyZ3VtZW50O1xuICByZXR1cm4gZXJyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZXJyb3Igb2JqZWN0IHRvIGJlIHRocm93biB3aGVuIGFuIGFyZ3VtZW50IGRpZCBub3QgdXNlIHRoZSBzdXBwb3J0ZWQgdmFsdWVcbiAqXG4gKiBAcHVibGljXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIEVycm9yIG1lc3NhZ2UgdG8gYmUgZGlzcGxheWVkLlxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3VtZW50IC0gQXJndW1lbnQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIEFyZ3VtZW50IHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtyZWFzb25dIC0gV2h5IHZhbHVlIGlzIGludmFsaWQuXG4gKiBAcmV0dXJucyB7RXJyb3J9IGluc3RhbmNlIGRldGFpbGluZyB0aGUgZXJyb3IgY29uZGl0aW9uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWRBcmd1bWVudFZhbHVlRXJyb3IobWVzc2FnZSwgYXJndW1lbnQsIHZhbHVlLCByZWFzb24pIHtcbiAgdmFyIGVyciA9IG5ldyBUeXBlRXJyb3IobWVzc2FnZSk7XG4gIGVyci5jb2RlID0gY29uc3RhbnRzLklOVkFMSURfQVJHX1ZBTFVFO1xuICBlcnIuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgZXJyLnZhbHVlID0gdmFsdWU7XG4gIGVyci5yZWFzb24gPSB0eXBlb2YgcmVhc29uICE9PSAndW5kZWZpbmVkJyA/IHJlYXNvbiA6ICdpcyBpbnZhbGlkJztcbiAgcmV0dXJuIGVycjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVycm9yIG9iamVjdCB0byBiZSB0aHJvd24gd2hlbiBhbiBleGNlcHRpb24gd2FzIGNhdWdodCwgYnV0IHRoZSBgRXJyb3JgIGlzIGZhbHN5IG9yIHVuZGVmaW5lZC5cbiAqXG4gKiBAcHVibGljXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIEVycm9yIG1lc3NhZ2UgdG8gYmUgZGlzcGxheWVkLlxuICogQHJldHVybnMge0Vycm9yfSBpbnN0YW5jZSBkZXRhaWxpbmcgdGhlIGVycm9yIGNvbmRpdGlvblxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkRXhjZXB0aW9uRXJyb3IobWVzc2FnZSwgdmFsdWUpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgZXJyLmNvZGUgPSBjb25zdGFudHMuSU5WQUxJRF9FWENFUFRJT047XG4gIGVyci52YWx1ZVR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGVyci52YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gZXJyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZXJyb3Igb2JqZWN0IHRvIGJlIHRocm93biB3aGVuIGFuIHVucmVjb3ZlcmFibGUgZXJyb3Igb2NjdXJzLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gRXJyb3IgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQuXG4gKiBAcmV0dXJucyB7RXJyb3J9IGluc3RhbmNlIGRldGFpbGluZyB0aGUgZXJyb3IgY29uZGl0aW9uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZhdGFsRXJyb3IobWVzc2FnZSwgdmFsdWUpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgZXJyLmNvZGUgPSBjb25zdGFudHMuRkFUQUw7XG4gIGVyci52YWx1ZVR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGVyci52YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gZXJyO1xufVxuXG4vKipcbiAqIER5bmFtaWNhbGx5IGNyZWF0ZXMgYSBwbHVnaW4tdHlwZS1zcGVjaWZpYyBlcnJvciBiYXNlZCBvbiBwbHVnaW4gdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBFcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge1wicmVwb3J0ZXJcInxcInVpXCJ9IHBsdWdpblR5cGUgLSBQbHVnaW4gdHlwZS4gRnV0dXJlOiBleHBhbmQgYXMgbmVlZGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BsdWdpbklkXSAtIE5hbWUvcGF0aCBvZiBwbHVnaW4sIGlmIGFueVxuICogQHRocm93cyBXaGVuIGBwbHVnaW5UeXBlYCBpcyBub3Qga25vd25cbiAqIEBwdWJsaWNcbiAqIEBzdGF0aWNcbiAqIEByZXR1cm5zIHtFcnJvcn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW52YWxpZExlZ2FjeVBsdWdpbkVycm9yKG1lc3NhZ2UsIHBsdWdpblR5cGUsIHBsdWdpbklkKSB7XG4gIHN3aXRjaCAocGx1Z2luVHlwZSkge1xuICAgIGNhc2UgJ3JlcG9ydGVyJzpcbiAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkUmVwb3J0ZXJFcnJvcihtZXNzYWdlLCBwbHVnaW5JZCk7XG4gICAgY2FzZSAndWknOlxuICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWRJbnRlcmZhY2VFcnJvcihtZXNzYWdlLCBwbHVnaW5JZCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBwbHVnaW5UeXBlIFwiJyArIHBsdWdpblR5cGUgKyAnXCInKTtcbiAgfVxufVxuXG4vKipcbiAqICoqREVQUkVDQVRFRCoqLiAgVXNlIHtAbGluayBjcmVhdGVJbnZhbGlkTGVnYWN5UGx1Z2luRXJyb3J9IGluc3RlYWQgIER5bmFtaWNhbGx5IGNyZWF0ZXMgYSBwbHVnaW4tdHlwZS1zcGVjaWZpYyBlcnJvciBiYXNlZCBvbiBwbHVnaW4gdHlwZVxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gRXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIHtcInJlcG9ydGVyXCJ8XCJpbnRlcmZhY2VcIn0gcGx1Z2luVHlwZSAtIFBsdWdpbiB0eXBlLiBGdXR1cmU6IGV4cGFuZCBhcyBuZWVkZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGx1Z2luSWRdIC0gTmFtZS9wYXRoIG9mIHBsdWdpbiwgaWYgYW55XG4gKiBAdGhyb3dzIFdoZW4gYHBsdWdpblR5cGVgIGlzIG5vdCBrbm93blxuICogQHB1YmxpY1xuICogQHN0YXRpY1xuICogQHJldHVybnMge0Vycm9yfVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkUGx1Z2luRXJyb3IoLi4uYXJncykge1xuICBkZXByZWNhdGUoJ1VzZSBjcmVhdGVJbnZhbGlkTGVnYWN5UGx1Z2luRXJyb3IoKSBpbnN0ZWFkJyk7XG4gIHJldHVybiBjcmVhdGVJbnZhbGlkTGVnYWN5UGx1Z2luRXJyb3IoLi4uYXJncyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgdG8gYmUgdGhyb3duIHdoZW4gYSBtb2NoYSBvYmplY3QncyBgcnVuYCBtZXRob2QgaXMgZXhlY3V0ZWQgd2hpbGUgaXQgaXMgYWxyZWFkeSBkaXNwb3NlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlIHRvIGJlIGRpc3BsYXllZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYW5SZWZlcmVuY2VzQWZ0ZXJSdW4gdGhlIHZhbHVlIG9mIGBjbGVhblJlZmVyZW5jZXNBZnRlclJ1bmBcbiAqIEBwYXJhbSB7TW9jaGF9IGluc3RhbmNlIHRoZSBtb2NoYSBpbnN0YW5jZSB0aGF0IHRocm93IHRoaXMgZXJyb3JcbiAqIEBzdGF0aWNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9jaGFJbnN0YW5jZUFscmVhZHlEaXNwb3NlZEVycm9yKFxuICBtZXNzYWdlLFxuICBjbGVhblJlZmVyZW5jZXNBZnRlclJ1bixcbiAgaW5zdGFuY2Vcbikge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnIuY29kZSA9IGNvbnN0YW50cy5JTlNUQU5DRV9BTFJFQURZX0RJU1BPU0VEO1xuICBlcnIuY2xlYW5SZWZlcmVuY2VzQWZ0ZXJSdW4gPSBjbGVhblJlZmVyZW5jZXNBZnRlclJ1bjtcbiAgZXJyLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgdG8gYmUgdGhyb3duIHdoZW4gYSBtb2NoYSBvYmplY3QncyBgcnVuYCBtZXRob2QgaXMgY2FsbGVkIHdoaWxlIGEgdGVzdCBydW4gaXMgaW4gcHJvZ3Jlc3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQuXG4gKiBAc3RhdGljXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1vY2hhSW5zdGFuY2VBbHJlYWR5UnVubmluZ0Vycm9yKG1lc3NhZ2UsIGluc3RhbmNlKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGVyci5jb2RlID0gY29uc3RhbnRzLklOU1RBTkNFX0FMUkVBRFlfUlVOTklORztcbiAgZXJyLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgdG8gYmUgdGhyb3duIHdoZW4gZG9uZSgpIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBpbiBhIHRlc3RcbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge1J1bm5hYmxlfSBydW5uYWJsZSAtIE9yaWdpbmFsIHJ1bm5hYmxlXG4gKiBAcGFyYW0ge0Vycm9yfSBbb3JpZ2luYWxFcnJdIC0gT3JpZ2luYWwgZXJyb3IsIGlmIGFueVxuICogQHJldHVybnMge0Vycm9yfSBpbnN0YW5jZSBkZXRhaWxpbmcgdGhlIGVycm9yIGNvbmRpdGlvblxuICogQHN0YXRpY1xuICovXG5mdW5jdGlvbiBjcmVhdGVNdWx0aXBsZURvbmVFcnJvcihydW5uYWJsZSwgb3JpZ2luYWxFcnIpIHtcbiAgdmFyIHRpdGxlO1xuICB0cnkge1xuICAgIHRpdGxlID0gZm9ybWF0KCc8JXM+JywgcnVubmFibGUuZnVsbFRpdGxlKCkpO1xuICAgIGlmIChydW5uYWJsZS5wYXJlbnQucm9vdCkge1xuICAgICAgdGl0bGUgKz0gJyAob2Ygcm9vdCBzdWl0ZSknO1xuICAgIH1cbiAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgIHRpdGxlID0gZm9ybWF0KCc8JXM+IChvZiB1bmtub3duIHN1aXRlKScsIHJ1bm5hYmxlLnRpdGxlKTtcbiAgfVxuICB2YXIgbWVzc2FnZSA9IGZvcm1hdChcbiAgICAnZG9uZSgpIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBpbiAlcyAlcycsXG4gICAgcnVubmFibGUudHlwZSA/IHJ1bm5hYmxlLnR5cGUgOiAndW5rbm93biBydW5uYWJsZScsXG4gICAgdGl0bGVcbiAgKTtcbiAgaWYgKHJ1bm5hYmxlLmZpbGUpIHtcbiAgICBtZXNzYWdlICs9IGZvcm1hdCgnIG9mIGZpbGUgJXMnLCBydW5uYWJsZS5maWxlKTtcbiAgfVxuICBpZiAob3JpZ2luYWxFcnIpIHtcbiAgICBtZXNzYWdlICs9IGZvcm1hdCgnOyBpbiBhZGRpdGlvbiwgZG9uZSgpIHJlY2VpdmVkIGVycm9yOiAlcycsIG9yaWdpbmFsRXJyKTtcbiAgfVxuXG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGVyci5jb2RlID0gY29uc3RhbnRzLk1VTFRJUExFX0RPTkU7XG4gIGVyci52YWx1ZVR5cGUgPSB0eXBlb2Ygb3JpZ2luYWxFcnI7XG4gIGVyci52YWx1ZSA9IG9yaWdpbmFsRXJyO1xuICByZXR1cm4gZXJyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZXJyb3Igb2JqZWN0IHRvIGJlIHRocm93biB3aGVuIGAub25seSgpYCBpcyB1c2VkIHdpdGhcbiAqIGAtLWZvcmJpZC1vbmx5YC5cbiAqIEBzdGF0aWNcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7TW9jaGF9IG1vY2hhIC0gTW9jaGEgaW5zdGFuY2VcbiAqIEByZXR1cm5zIHtFcnJvcn0gRXJyb3Igd2l0aCBjb2RlIHtAbGluayBjb25zdGFudHMuRk9SQklEREVOX0VYQ0xVU0lWSVRZfVxuICovXG5mdW5jdGlvbiBjcmVhdGVGb3JiaWRkZW5FeGNsdXNpdml0eUVycm9yKG1vY2hhKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgbW9jaGEuaXNXb3JrZXJcbiAgICAgID8gJ2Aub25seWAgaXMgbm90IHN1cHBvcnRlZCBpbiBwYXJhbGxlbCBtb2RlJ1xuICAgICAgOiAnYC5vbmx5YCBmb3JiaWRkZW4gYnkgLS1mb3JiaWQtb25seSdcbiAgKTtcbiAgZXJyLmNvZGUgPSBjb25zdGFudHMuRk9SQklEREVOX0VYQ0xVU0lWSVRZO1xuICByZXR1cm4gZXJyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZXJyb3Igb2JqZWN0IHRvIGJlIHRocm93biB3aGVuIGEgcGx1Z2luIGRlZmluaXRpb24gaXMgaW52YWxpZFxuICogQHN0YXRpY1xuICogQHBhcmFtIHtzdHJpbmd9IG1zZyAtIEVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSB7UGx1Z2luRGVmaW5pdGlvbn0gW3BsdWdpbkRlZl0gLSBQcm9ibGVtYXRpYyBwbHVnaW4gZGVmaW5pdGlvblxuICogQHB1YmxpY1xuICogQHJldHVybnMge0Vycm9yfSBFcnJvciB3aXRoIGNvZGUge0BsaW5rIGNvbnN0YW50cy5JTlZBTElEX1BMVUdJTl9ERUZJTklUSU9OfVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkUGx1Z2luRGVmaW5pdGlvbkVycm9yKG1zZywgcGx1Z2luRGVmKSB7XG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIuY29kZSA9IGNvbnN0YW50cy5JTlZBTElEX1BMVUdJTl9ERUZJTklUSU9OO1xuICBlcnIucGx1Z2luRGVmID0gcGx1Z2luRGVmO1xuICByZXR1cm4gZXJyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZXJyb3Igb2JqZWN0IHRvIGJlIHRocm93biB3aGVuIGEgcGx1Z2luIGltcGxlbWVudGF0aW9uICh1c2VyIGNvZGUpIGlzIGludmFsaWRcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBtc2cgLSBFcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gUGx1Z2luIGRlZmluaXRpb24gYW5kIHVzZXItc3VwcGxpZWQgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7UGx1Z2luRGVmaW5pdGlvbn0gW29wdHMucGx1Z2luRGVmXSAtIFBsdWdpbiBEZWZpbml0aW9uXG4gKiBAcGFyYW0geyp9IFtvcHRzLnBsdWdpbkltcGxdIC0gUGx1Z2luIEltcGxlbWVudGF0aW9uICh1c2VyLXN1cHBsaWVkKVxuICogQHB1YmxpY1xuICogQHJldHVybnMge0Vycm9yfSBFcnJvciB3aXRoIGNvZGUge0BsaW5rIGNvbnN0YW50cy5JTlZBTElEX1BMVUdJTl9ERUZJTklUSU9OfVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkUGx1Z2luSW1wbGVtZW50YXRpb25FcnJvcihcbiAgbXNnLFxuICB7cGx1Z2luRGVmLCBwbHVnaW5JbXBsfSA9IHt9XG4pIHtcbiAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci5jb2RlID0gY29uc3RhbnRzLklOVkFMSURfUExVR0lOX0lNUExFTUVOVEFUSU9OO1xuICBlcnIucGx1Z2luRGVmID0gcGx1Z2luRGVmO1xuICBlcnIucGx1Z2luSW1wbCA9IHBsdWdpbkltcGw7XG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgdG8gYmUgdGhyb3duIHdoZW4gYSBydW5uYWJsZSBleGNlZWRzIGl0cyBhbGxvd2VkIHJ1biB0aW1lLlxuICogQHN0YXRpY1xuICogQHBhcmFtIHtzdHJpbmd9IG1zZyAtIEVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dF0gLSBUaW1lb3V0IGluIG1zXG4gKiBAcGFyYW0ge3N0cmluZ30gW2ZpbGVdIC0gRmlsZSwgaWYgZ2l2ZW5cbiAqIEByZXR1cm5zIHtNb2NoYVRpbWVvdXRFcnJvcn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGltZW91dEVycm9yKG1zZywgdGltZW91dCwgZmlsZSkge1xuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLmNvZGUgPSBjb25zdGFudHMuVElNRU9VVDtcbiAgZXJyLnRpbWVvdXQgPSB0aW1lb3V0O1xuICBlcnIuZmlsZSA9IGZpbGU7XG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgdG8gYmUgdGhyb3duIHdoZW4gZmlsZSBpcyB1bnBhcnNhYmxlXG4gKiBAcHVibGljXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIEVycm9yIG1lc3NhZ2UgdG8gYmUgZGlzcGxheWVkLlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lIC0gRmlsZSBuYW1lXG4gKiBAcmV0dXJucyB7RXJyb3J9IEVycm9yIHdpdGggY29kZSB7QGxpbmsgY29uc3RhbnRzLlVOUEFSU0FCTEVfRklMRX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVW5wYXJzYWJsZUZpbGVFcnJvcihtZXNzYWdlLCBmaWxlbmFtZSkge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnIuY29kZSA9IGNvbnN0YW50cy5VTlBBUlNBQkxFX0ZJTEU7XG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZXJyb3IgY2FtZSBvdXQgb2YgTW9jaGEuXG4gKiBfQ2FuIHN1ZmZlciBmcm9tIGZhbHNlIG5lZ2F0aXZlcywgYnV0IG5vdCBmYWxzZSBwb3NpdGl2ZXMuX1xuICogQHN0YXRpY1xuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSBlcnIgLSBFcnJvciwgb3IgYW55dGhpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBpc01vY2hhRXJyb3IgPSBlcnIgPT5cbiAgQm9vbGVhbihlcnIgJiYgdHlwZW9mIGVyciA9PT0gJ29iamVjdCcgJiYgTU9DSEFfRVJST1JTLmhhcyhlcnIuY29kZSkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29uc3RhbnRzLFxuICBjcmVhdGVGYXRhbEVycm9yLFxuICBjcmVhdGVGb3JiaWRkZW5FeGNsdXNpdml0eUVycm9yLFxuICBjcmVhdGVJbnZhbGlkQXJndW1lbnRUeXBlRXJyb3IsXG4gIGNyZWF0ZUludmFsaWRBcmd1bWVudFZhbHVlRXJyb3IsXG4gIGNyZWF0ZUludmFsaWRFeGNlcHRpb25FcnJvcixcbiAgY3JlYXRlSW52YWxpZEludGVyZmFjZUVycm9yLFxuICBjcmVhdGVJbnZhbGlkTGVnYWN5UGx1Z2luRXJyb3IsXG4gIGNyZWF0ZUludmFsaWRQbHVnaW5EZWZpbml0aW9uRXJyb3IsXG4gIGNyZWF0ZUludmFsaWRQbHVnaW5FcnJvcixcbiAgY3JlYXRlSW52YWxpZFBsdWdpbkltcGxlbWVudGF0aW9uRXJyb3IsXG4gIGNyZWF0ZUludmFsaWRSZXBvcnRlckVycm9yLFxuICBjcmVhdGVNaXNzaW5nQXJndW1lbnRFcnJvcixcbiAgY3JlYXRlTW9jaGFJbnN0YW5jZUFscmVhZHlEaXNwb3NlZEVycm9yLFxuICBjcmVhdGVNb2NoYUluc3RhbmNlQWxyZWFkeVJ1bm5pbmdFcnJvcixcbiAgY3JlYXRlTXVsdGlwbGVEb25lRXJyb3IsXG4gIGNyZWF0ZU5vRmlsZXNNYXRjaFBhdHRlcm5FcnJvcixcbiAgY3JlYXRlVGltZW91dEVycm9yLFxuICBjcmVhdGVVbnBhcnNhYmxlRmlsZUVycm9yLFxuICBjcmVhdGVVbnN1cHBvcnRlZEVycm9yLFxuICBkZXByZWNhdGUsXG4gIGlzTW9jaGFFcnJvcixcbiAgd2FyblxufTtcblxuLyoqXG4gKiBUaGUgZXJyb3IgdGhyb3duIHdoZW4gYSBSdW5uYWJsZSB0aW1lcyBvdXRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6bGliL2Vycm9yc1xuICogQHR5cGVkZWYge0Vycm9yfSBNb2NoYVRpbWVvdXRFcnJvclxuICogQHByb3BlcnR5IHtjb25zdGFudHMuVElNRU9VVH0gY29kZSAtIEVycm9yIGNvZGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyP30gdGltZW91dCBUaW1lb3V0IGluIG1zXG4gKiBAcHJvcGVydHkge3N0cmluZz99IGZpbGUgRmlsZXBhdGgsIGlmIGdpdmVuXG4gKi9cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/hook.js":
/*!****************************************!*\
  !*** ./node_modules/mocha/lib/hook.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Runnable = __webpack_require__(/*! ./runnable */ \"(ssr)/./node_modules/mocha/lib/runnable.js\");\nconst {inherits, constants} = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\");\nconst {MOCHA_ID_PROP_NAME} = constants;\n\n/**\n * Expose `Hook`.\n */\n\nmodule.exports = Hook;\n\n/**\n * Initialize a new `Hook` with the given `title` and callback `fn`\n *\n * @class\n * @extends Runnable\n * @param {String} title\n * @param {Function} fn\n */\nfunction Hook(title, fn) {\n  Runnable.call(this, title, fn);\n  this.type = 'hook';\n}\n\n/**\n * Inherit from `Runnable.prototype`.\n */\ninherits(Hook, Runnable);\n\n/**\n * Resets the state for a next run.\n */\nHook.prototype.reset = function () {\n  Runnable.prototype.reset.call(this);\n  delete this._error;\n};\n\n/**\n * Get or set the test `err`.\n *\n * @memberof Hook\n * @public\n * @param {Error} err\n * @return {Error}\n */\nHook.prototype.error = function (err) {\n  if (!arguments.length) {\n    err = this._error;\n    this._error = null;\n    return err;\n  }\n\n  this._error = err;\n};\n\n/**\n * Returns an object suitable for IPC.\n * Functions are represented by keys beginning with `$$`.\n * @private\n * @returns {Object}\n */\nHook.prototype.serialize = function serialize() {\n  return {\n    $$currentRetry: this.currentRetry(),\n    $$fullTitle: this.fullTitle(),\n    $$isPending: Boolean(this.isPending()),\n    $$titlePath: this.titlePath(),\n    ctx:\n      this.ctx && this.ctx.currentTest\n        ? {\n            currentTest: {\n              title: this.ctx.currentTest.title,\n              [MOCHA_ID_PROP_NAME]: this.ctx.currentTest.id\n            }\n          }\n        : {},\n    duration: this.duration,\n    file: this.file,\n    parent: {\n      $$fullTitle: this.parent.fullTitle(),\n      [MOCHA_ID_PROP_NAME]: this.parent.id\n    },\n    state: this.state,\n    title: this.title,\n    type: this.type,\n    [MOCHA_ID_PROP_NAME]: this.id\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2hvb2suanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDhEQUFZO0FBQ25DLE9BQU8scUJBQXFCLEVBQUUsbUJBQU8sQ0FBQyx3REFBUztBQUMvQyxPQUFPLG9CQUFvQjs7QUFFM0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9ob29rLmpzPzdhZGIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUnVubmFibGUgPSByZXF1aXJlKCcuL3J1bm5hYmxlJyk7XG5jb25zdCB7aW5oZXJpdHMsIGNvbnN0YW50c30gPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCB7TU9DSEFfSURfUFJPUF9OQU1FfSA9IGNvbnN0YW50cztcblxuLyoqXG4gKiBFeHBvc2UgYEhvb2tgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gSG9vaztcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBIb29rYCB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBSdW5uYWJsZVxuICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBIb29rKHRpdGxlLCBmbikge1xuICBSdW5uYWJsZS5jYWxsKHRoaXMsIHRpdGxlLCBmbik7XG4gIHRoaXMudHlwZSA9ICdob29rJztcbn1cblxuLyoqXG4gKiBJbmhlcml0IGZyb20gYFJ1bm5hYmxlLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKEhvb2ssIFJ1bm5hYmxlKTtcblxuLyoqXG4gKiBSZXNldHMgdGhlIHN0YXRlIGZvciBhIG5leHQgcnVuLlxuICovXG5Ib29rLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgUnVubmFibGUucHJvdG90eXBlLnJlc2V0LmNhbGwodGhpcyk7XG4gIGRlbGV0ZSB0aGlzLl9lcnJvcjtcbn07XG5cbi8qKlxuICogR2V0IG9yIHNldCB0aGUgdGVzdCBgZXJyYC5cbiAqXG4gKiBAbWVtYmVyb2YgSG9va1xuICogQHB1YmxpY1xuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqL1xuSG9vay5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGVyciA9IHRoaXMuX2Vycm9yO1xuICAgIHRoaXMuX2Vycm9yID0gbnVsbDtcbiAgICByZXR1cm4gZXJyO1xuICB9XG5cbiAgdGhpcy5fZXJyb3IgPSBlcnI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHN1aXRhYmxlIGZvciBJUEMuXG4gKiBGdW5jdGlvbnMgYXJlIHJlcHJlc2VudGVkIGJ5IGtleXMgYmVnaW5uaW5nIHdpdGggYCQkYC5cbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5Ib29rLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gIHJldHVybiB7XG4gICAgJCRjdXJyZW50UmV0cnk6IHRoaXMuY3VycmVudFJldHJ5KCksXG4gICAgJCRmdWxsVGl0bGU6IHRoaXMuZnVsbFRpdGxlKCksXG4gICAgJCRpc1BlbmRpbmc6IEJvb2xlYW4odGhpcy5pc1BlbmRpbmcoKSksXG4gICAgJCR0aXRsZVBhdGg6IHRoaXMudGl0bGVQYXRoKCksXG4gICAgY3R4OlxuICAgICAgdGhpcy5jdHggJiYgdGhpcy5jdHguY3VycmVudFRlc3RcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBjdXJyZW50VGVzdDoge1xuICAgICAgICAgICAgICB0aXRsZTogdGhpcy5jdHguY3VycmVudFRlc3QudGl0bGUsXG4gICAgICAgICAgICAgIFtNT0NIQV9JRF9QUk9QX05BTUVdOiB0aGlzLmN0eC5jdXJyZW50VGVzdC5pZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgOiB7fSxcbiAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICBmaWxlOiB0aGlzLmZpbGUsXG4gICAgcGFyZW50OiB7XG4gICAgICAkJGZ1bGxUaXRsZTogdGhpcy5wYXJlbnQuZnVsbFRpdGxlKCksXG4gICAgICBbTU9DSEFfSURfUFJPUF9OQU1FXTogdGhpcy5wYXJlbnQuaWRcbiAgICB9LFxuICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgIHRpdGxlOiB0aGlzLnRpdGxlLFxuICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICBbTU9DSEFfSURfUFJPUF9OQU1FXTogdGhpcy5pZFxuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/hook.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/interfaces/bdd.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/interfaces/bdd.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Test = __webpack_require__(/*! ../test */ \"(ssr)/./node_modules/mocha/lib/test.js\");\nvar EVENT_FILE_PRE_REQUIRE =\n  (__webpack_require__(/*! ../suite */ \"(ssr)/./node_modules/mocha/lib/suite.js\").constants).EVENT_FILE_PRE_REQUIRE;\n\n/**\n * BDD-style interface:\n *\n *      describe('Array', function() {\n *        describe('#indexOf()', function() {\n *          it('should return -1 when not present', function() {\n *            // ...\n *          });\n *\n *          it('should return the index when present', function() {\n *            // ...\n *          });\n *        });\n *      });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function bddInterface(suite) {\n  var suites = [suite];\n\n  suite.on(EVENT_FILE_PRE_REQUIRE, function (context, file, mocha) {\n    var common = __webpack_require__(/*! ./common */ \"(ssr)/./node_modules/mocha/lib/interfaces/common.js\")(suites, context, mocha);\n\n    context.before = common.before;\n    context.after = common.after;\n    context.beforeEach = common.beforeEach;\n    context.afterEach = common.afterEach;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`\n     * and callback `fn` containing nested suites\n     * and/or tests.\n     */\n\n    context.describe = context.context = function (title, fn) {\n      return common.suite.create({\n        title,\n        file,\n        fn\n      });\n    };\n\n    /**\n     * Pending describe.\n     */\n\n    context.xdescribe =\n      context.xcontext =\n      context.describe.skip =\n        function (title, fn) {\n          return common.suite.skip({\n            title,\n            file,\n            fn\n          });\n        };\n\n    /**\n     * Exclusive suite.\n     */\n\n    context.describe.only = function (title, fn) {\n      return common.suite.only({\n        title,\n        file,\n        fn\n      });\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    context.it = context.specify = function (title, fn) {\n      var suite = suites[0];\n      if (suite.isPending()) {\n        fn = null;\n      }\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.it.only = function (title, fn) {\n      return common.test.only(mocha, context.it(title, fn));\n    };\n\n    /**\n     * Pending test case.\n     */\n\n    context.xit =\n      context.xspecify =\n      context.it.skip =\n        function (title) {\n          return context.it(title);\n        };\n  });\n};\n\nmodule.exports.description = 'BDD or RSpec style [default]';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2ludGVyZmFjZXMvYmRkLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyx1REFBUztBQUM1QjtBQUNBLEVBQUUsMEZBQTZCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxxRUFBVTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSwwQkFBMEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9pbnRlcmZhY2VzL2JkZC5qcz9mYjAzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFRlc3QgPSByZXF1aXJlKCcuLi90ZXN0Jyk7XG52YXIgRVZFTlRfRklMRV9QUkVfUkVRVUlSRSA9XG4gIHJlcXVpcmUoJy4uL3N1aXRlJykuY29uc3RhbnRzLkVWRU5UX0ZJTEVfUFJFX1JFUVVJUkU7XG5cbi8qKlxuICogQkRELXN0eWxlIGludGVyZmFjZTpcbiAqXG4gKiAgICAgIGRlc2NyaWJlKCdBcnJheScsIGZ1bmN0aW9uKCkge1xuICogICAgICAgIGRlc2NyaWJlKCcjaW5kZXhPZigpJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICBpdCgnc2hvdWxkIHJldHVybiAtMSB3aGVuIG5vdCBwcmVzZW50JywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgIC8vIC4uLlxuICogICAgICAgICAgfSk7XG4gKlxuICogICAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gdGhlIGluZGV4IHdoZW4gcHJlc2VudCcsIGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAvLyAuLi5cbiAqICAgICAgICAgIH0pO1xuICogICAgICAgIH0pO1xuICogICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSBSb290IHN1aXRlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJkZEludGVyZmFjZShzdWl0ZSkge1xuICB2YXIgc3VpdGVzID0gW3N1aXRlXTtcblxuICBzdWl0ZS5vbihFVkVOVF9GSUxFX1BSRV9SRVFVSVJFLCBmdW5jdGlvbiAoY29udGV4dCwgZmlsZSwgbW9jaGEpIHtcbiAgICB2YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKShzdWl0ZXMsIGNvbnRleHQsIG1vY2hhKTtcblxuICAgIGNvbnRleHQuYmVmb3JlID0gY29tbW9uLmJlZm9yZTtcbiAgICBjb250ZXh0LmFmdGVyID0gY29tbW9uLmFmdGVyO1xuICAgIGNvbnRleHQuYmVmb3JlRWFjaCA9IGNvbW1vbi5iZWZvcmVFYWNoO1xuICAgIGNvbnRleHQuYWZ0ZXJFYWNoID0gY29tbW9uLmFmdGVyRWFjaDtcbiAgICBjb250ZXh0LnJ1biA9IG1vY2hhLm9wdGlvbnMuZGVsYXkgJiYgY29tbW9uLnJ1bldpdGhTdWl0ZShzdWl0ZSk7XG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgYSBcInN1aXRlXCIgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYFxuICAgICAqIGFuZCBjYWxsYmFjayBgZm5gIGNvbnRhaW5pbmcgbmVzdGVkIHN1aXRlc1xuICAgICAqIGFuZC9vciB0ZXN0cy5cbiAgICAgKi9cblxuICAgIGNvbnRleHQuZGVzY3JpYmUgPSBjb250ZXh0LmNvbnRleHQgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLmNyZWF0ZSh7XG4gICAgICAgIHRpdGxlLFxuICAgICAgICBmaWxlLFxuICAgICAgICBmblxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBlbmRpbmcgZGVzY3JpYmUuXG4gICAgICovXG5cbiAgICBjb250ZXh0LnhkZXNjcmliZSA9XG4gICAgICBjb250ZXh0Lnhjb250ZXh0ID1cbiAgICAgIGNvbnRleHQuZGVzY3JpYmUuc2tpcCA9XG4gICAgICAgIGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcbiAgICAgICAgICByZXR1cm4gY29tbW9uLnN1aXRlLnNraXAoe1xuICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgZm5cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4Y2x1c2l2ZSBzdWl0ZS5cbiAgICAgKi9cblxuICAgIGNvbnRleHQuZGVzY3JpYmUub25seSA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcbiAgICAgIHJldHVybiBjb21tb24uc3VpdGUub25seSh7XG4gICAgICAgIHRpdGxlLFxuICAgICAgICBmaWxlLFxuICAgICAgICBmblxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIGEgc3BlY2lmaWNhdGlvbiBvciB0ZXN0LWNhc2VcbiAgICAgKiB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gXG4gICAgICogYWN0aW5nIGFzIGEgdGh1bmsuXG4gICAgICovXG5cbiAgICBjb250ZXh0Lml0ID0gY29udGV4dC5zcGVjaWZ5ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xuICAgICAgdmFyIHN1aXRlID0gc3VpdGVzWzBdO1xuICAgICAgaWYgKHN1aXRlLmlzUGVuZGluZygpKSB7XG4gICAgICAgIGZuID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciB0ZXN0ID0gbmV3IFRlc3QodGl0bGUsIGZuKTtcbiAgICAgIHRlc3QuZmlsZSA9IGZpbGU7XG4gICAgICBzdWl0ZS5hZGRUZXN0KHRlc3QpO1xuICAgICAgcmV0dXJuIHRlc3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4Y2x1c2l2ZSB0ZXN0LWNhc2UuXG4gICAgICovXG5cbiAgICBjb250ZXh0Lml0Lm9ubHkgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XG4gICAgICByZXR1cm4gY29tbW9uLnRlc3Qub25seShtb2NoYSwgY29udGV4dC5pdCh0aXRsZSwgZm4pKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGVuZGluZyB0ZXN0IGNhc2UuXG4gICAgICovXG5cbiAgICBjb250ZXh0LnhpdCA9XG4gICAgICBjb250ZXh0LnhzcGVjaWZ5ID1cbiAgICAgIGNvbnRleHQuaXQuc2tpcCA9XG4gICAgICAgIGZ1bmN0aW9uICh0aXRsZSkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Lml0KHRpdGxlKTtcbiAgICAgICAgfTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5kZXNjcmlwdGlvbiA9ICdCREQgb3IgUlNwZWMgc3R5bGUgW2RlZmF1bHRdJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/interfaces/bdd.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/interfaces/common.js":
/*!*****************************************************!*\
  !*** ./node_modules/mocha/lib/interfaces/common.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n @module interfaces/common\n*/\n\nvar Suite = __webpack_require__(/*! ../suite */ \"(ssr)/./node_modules/mocha/lib/suite.js\");\nvar errors = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/mocha/lib/errors.js\");\nvar createMissingArgumentError = errors.createMissingArgumentError;\nvar createUnsupportedError = errors.createUnsupportedError;\nvar createForbiddenExclusivityError = errors.createForbiddenExclusivityError;\n\n/**\n * Functions common to more than one interface.\n *\n * @private\n * @param {Suite[]} suites\n * @param {Context} context\n * @param {Mocha} mocha\n * @return {Object} An object containing common functions.\n */\nmodule.exports = function (suites, context, mocha) {\n  /**\n   * Check if the suite should be tested.\n   *\n   * @private\n   * @param {Suite} suite - suite to check\n   * @returns {boolean}\n   */\n  function shouldBeTested(suite) {\n    return (\n      !mocha.options.grep ||\n      (mocha.options.grep &&\n        mocha.options.grep.test(suite.fullTitle()) &&\n        !mocha.options.invert)\n    );\n  }\n\n  return {\n    /**\n     * This is only present if flag --delay is passed into Mocha. It triggers\n     * root suite execution.\n     *\n     * @param {Suite} suite The root suite.\n     * @return {Function} A function which runs the root suite\n     */\n    runWithSuite: function runWithSuite(suite) {\n      return function run() {\n        suite.run();\n      };\n    },\n\n    /**\n     * Execute before running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    before: function (name, fn) {\n      suites[0].beforeAll(name, fn);\n    },\n\n    /**\n     * Execute after running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    after: function (name, fn) {\n      suites[0].afterAll(name, fn);\n    },\n\n    /**\n     * Execute before each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    beforeEach: function (name, fn) {\n      suites[0].beforeEach(name, fn);\n    },\n\n    /**\n     * Execute after each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    afterEach: function (name, fn) {\n      suites[0].afterEach(name, fn);\n    },\n\n    suite: {\n      /**\n       * Create an exclusive Suite; convenience function\n       * See docstring for create() below.\n       *\n       * @param {Object} opts\n       * @returns {Suite}\n       */\n      only: function only(opts) {\n        if (mocha.options.forbidOnly) {\n          throw createForbiddenExclusivityError(mocha);\n        }\n        opts.isOnly = true;\n        return this.create(opts);\n      },\n\n      /**\n       * Create a Suite, but skip it; convenience function\n       * See docstring for create() below.\n       *\n       * @param {Object} opts\n       * @returns {Suite}\n       */\n      skip: function skip(opts) {\n        opts.pending = true;\n        return this.create(opts);\n      },\n\n      /**\n       * Creates a suite.\n       *\n       * @param {Object} opts Options\n       * @param {string} opts.title Title of Suite\n       * @param {Function} [opts.fn] Suite Function (not always applicable)\n       * @param {boolean} [opts.pending] Is Suite pending?\n       * @param {string} [opts.file] Filepath where this Suite resides\n       * @param {boolean} [opts.isOnly] Is Suite exclusive?\n       * @returns {Suite}\n       */\n      create: function create(opts) {\n        var suite = Suite.create(suites[0], opts.title);\n        suite.pending = Boolean(opts.pending);\n        suite.file = opts.file;\n        suites.unshift(suite);\n        if (opts.isOnly) {\n          suite.markOnly();\n        }\n        if (\n          suite.pending &&\n          mocha.options.forbidPending &&\n          shouldBeTested(suite)\n        ) {\n          throw createUnsupportedError('Pending test forbidden');\n        }\n        if (typeof opts.fn === 'function') {\n          opts.fn.call(suite);\n          suites.shift();\n        } else if (typeof opts.fn === 'undefined' && !suite.pending) {\n          throw createMissingArgumentError(\n            'Suite \"' +\n              suite.fullTitle() +\n              '\" was defined but no callback was supplied. ' +\n              'Supply a callback or explicitly skip the suite.',\n            'callback',\n            'function'\n          );\n        } else if (!opts.fn && suite.pending) {\n          suites.shift();\n        }\n\n        return suite;\n      }\n    },\n\n    test: {\n      /**\n       * Exclusive test-case.\n       *\n       * @param {Object} mocha\n       * @param {Function} test\n       * @returns {*}\n       */\n      only: function (mocha, test) {\n        if (mocha.options.forbidOnly) {\n          throw createForbiddenExclusivityError(mocha);\n        }\n        test.markOnly();\n        return test;\n      },\n\n      /**\n       * Pending test case.\n       *\n       * @param {string} title\n       */\n      skip: function (title) {\n        context.test(title);\n      }\n    }\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2ludGVyZmFjZXMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMseURBQVU7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLDJEQUFXO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCLGlCQUFpQixTQUFTO0FBQzFCLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixTQUFTO0FBQzFCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsVUFBVTtBQUMzQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvaW50ZXJmYWNlcy9jb21tb24uanM/MjE3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuIEBtb2R1bGUgaW50ZXJmYWNlcy9jb21tb25cbiovXG5cbnZhciBTdWl0ZSA9IHJlcXVpcmUoJy4uL3N1aXRlJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG52YXIgY3JlYXRlTWlzc2luZ0FyZ3VtZW50RXJyb3IgPSBlcnJvcnMuY3JlYXRlTWlzc2luZ0FyZ3VtZW50RXJyb3I7XG52YXIgY3JlYXRlVW5zdXBwb3J0ZWRFcnJvciA9IGVycm9ycy5jcmVhdGVVbnN1cHBvcnRlZEVycm9yO1xudmFyIGNyZWF0ZUZvcmJpZGRlbkV4Y2x1c2l2aXR5RXJyb3IgPSBlcnJvcnMuY3JlYXRlRm9yYmlkZGVuRXhjbHVzaXZpdHlFcnJvcjtcblxuLyoqXG4gKiBGdW5jdGlvbnMgY29tbW9uIHRvIG1vcmUgdGhhbiBvbmUgaW50ZXJmYWNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N1aXRlW119IHN1aXRlc1xuICogQHBhcmFtIHtDb250ZXh0fSBjb250ZXh0XG4gKiBAcGFyYW0ge01vY2hhfSBtb2NoYVxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBjb21tb24gZnVuY3Rpb25zLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdWl0ZXMsIGNvbnRleHQsIG1vY2hhKSB7XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgc3VpdGUgc2hvdWxkIGJlIHRlc3RlZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdWl0ZX0gc3VpdGUgLSBzdWl0ZSB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIHNob3VsZEJlVGVzdGVkKHN1aXRlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICFtb2NoYS5vcHRpb25zLmdyZXAgfHxcbiAgICAgIChtb2NoYS5vcHRpb25zLmdyZXAgJiZcbiAgICAgICAgbW9jaGEub3B0aW9ucy5ncmVwLnRlc3Qoc3VpdGUuZnVsbFRpdGxlKCkpICYmXG4gICAgICAgICFtb2NoYS5vcHRpb25zLmludmVydClcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIG9ubHkgcHJlc2VudCBpZiBmbGFnIC0tZGVsYXkgaXMgcGFzc2VkIGludG8gTW9jaGEuIEl0IHRyaWdnZXJzXG4gICAgICogcm9vdCBzdWl0ZSBleGVjdXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSBUaGUgcm9vdCBzdWl0ZS5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB3aGljaCBydW5zIHRoZSByb290IHN1aXRlXG4gICAgICovXG4gICAgcnVuV2l0aFN1aXRlOiBmdW5jdGlvbiBydW5XaXRoU3VpdGUoc3VpdGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBydW4oKSB7XG4gICAgICAgIHN1aXRlLnJ1bigpO1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBiZWZvcmUgcnVubmluZyB0ZXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgKi9cbiAgICBiZWZvcmU6IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgICAgc3VpdGVzWzBdLmJlZm9yZUFsbChuYW1lLCBmbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYWZ0ZXIgcnVubmluZyB0ZXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgKi9cbiAgICBhZnRlcjogZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgICBzdWl0ZXNbMF0uYWZ0ZXJBbGwobmFtZSwgZm4pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGJlZm9yZSBlYWNoIHRlc3QgY2FzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgKi9cbiAgICBiZWZvcmVFYWNoOiBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICAgIHN1aXRlc1swXS5iZWZvcmVFYWNoKG5hbWUsIGZuKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBhZnRlciBlYWNoIHRlc3QgY2FzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgKi9cbiAgICBhZnRlckVhY2g6IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgICAgc3VpdGVzWzBdLmFmdGVyRWFjaChuYW1lLCBmbik7XG4gICAgfSxcblxuICAgIHN1aXRlOiB7XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSBhbiBleGNsdXNpdmUgU3VpdGU7IGNvbnZlbmllbmNlIGZ1bmN0aW9uXG4gICAgICAgKiBTZWUgZG9jc3RyaW5nIGZvciBjcmVhdGUoKSBiZWxvdy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAgICogQHJldHVybnMge1N1aXRlfVxuICAgICAgICovXG4gICAgICBvbmx5OiBmdW5jdGlvbiBvbmx5KG9wdHMpIHtcbiAgICAgICAgaWYgKG1vY2hhLm9wdGlvbnMuZm9yYmlkT25seSkge1xuICAgICAgICAgIHRocm93IGNyZWF0ZUZvcmJpZGRlbkV4Y2x1c2l2aXR5RXJyb3IobW9jaGEpO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMuaXNPbmx5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKG9wdHMpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGUgYSBTdWl0ZSwgYnV0IHNraXAgaXQ7IGNvbnZlbmllbmNlIGZ1bmN0aW9uXG4gICAgICAgKiBTZWUgZG9jc3RyaW5nIGZvciBjcmVhdGUoKSBiZWxvdy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAgICogQHJldHVybnMge1N1aXRlfVxuICAgICAgICovXG4gICAgICBza2lwOiBmdW5jdGlvbiBza2lwKG9wdHMpIHtcbiAgICAgICAgb3B0cy5wZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKG9wdHMpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgc3VpdGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uc1xuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMudGl0bGUgVGl0bGUgb2YgU3VpdGVcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLmZuXSBTdWl0ZSBGdW5jdGlvbiAobm90IGFsd2F5cyBhcHBsaWNhYmxlKVxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5wZW5kaW5nXSBJcyBTdWl0ZSBwZW5kaW5nP1xuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZpbGVdIEZpbGVwYXRoIHdoZXJlIHRoaXMgU3VpdGUgcmVzaWRlc1xuICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pc09ubHldIElzIFN1aXRlIGV4Y2x1c2l2ZT9cbiAgICAgICAqIEByZXR1cm5zIHtTdWl0ZX1cbiAgICAgICAqL1xuICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUob3B0cykge1xuICAgICAgICB2YXIgc3VpdGUgPSBTdWl0ZS5jcmVhdGUoc3VpdGVzWzBdLCBvcHRzLnRpdGxlKTtcbiAgICAgICAgc3VpdGUucGVuZGluZyA9IEJvb2xlYW4ob3B0cy5wZW5kaW5nKTtcbiAgICAgICAgc3VpdGUuZmlsZSA9IG9wdHMuZmlsZTtcbiAgICAgICAgc3VpdGVzLnVuc2hpZnQoc3VpdGUpO1xuICAgICAgICBpZiAob3B0cy5pc09ubHkpIHtcbiAgICAgICAgICBzdWl0ZS5tYXJrT25seSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICBzdWl0ZS5wZW5kaW5nICYmXG4gICAgICAgICAgbW9jaGEub3B0aW9ucy5mb3JiaWRQZW5kaW5nICYmXG4gICAgICAgICAgc2hvdWxkQmVUZXN0ZWQoc3VpdGUpXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVVuc3VwcG9ydGVkRXJyb3IoJ1BlbmRpbmcgdGVzdCBmb3JiaWRkZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdHMuZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvcHRzLmZuLmNhbGwoc3VpdGUpO1xuICAgICAgICAgIHN1aXRlcy5zaGlmdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzLmZuID09PSAndW5kZWZpbmVkJyAmJiAhc3VpdGUucGVuZGluZykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZU1pc3NpbmdBcmd1bWVudEVycm9yKFxuICAgICAgICAgICAgJ1N1aXRlIFwiJyArXG4gICAgICAgICAgICAgIHN1aXRlLmZ1bGxUaXRsZSgpICtcbiAgICAgICAgICAgICAgJ1wiIHdhcyBkZWZpbmVkIGJ1dCBubyBjYWxsYmFjayB3YXMgc3VwcGxpZWQuICcgK1xuICAgICAgICAgICAgICAnU3VwcGx5IGEgY2FsbGJhY2sgb3IgZXhwbGljaXRseSBza2lwIHRoZSBzdWl0ZS4nLFxuICAgICAgICAgICAgJ2NhbGxiYWNrJyxcbiAgICAgICAgICAgICdmdW5jdGlvbidcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCFvcHRzLmZuICYmIHN1aXRlLnBlbmRpbmcpIHtcbiAgICAgICAgICBzdWl0ZXMuc2hpZnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdWl0ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdGVzdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBFeGNsdXNpdmUgdGVzdC1jYXNlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2NoYVxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdGVzdFxuICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgKi9cbiAgICAgIG9ubHk6IGZ1bmN0aW9uIChtb2NoYSwgdGVzdCkge1xuICAgICAgICBpZiAobW9jaGEub3B0aW9ucy5mb3JiaWRPbmx5KSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlRm9yYmlkZGVuRXhjbHVzaXZpdHlFcnJvcihtb2NoYSk7XG4gICAgICAgIH1cbiAgICAgICAgdGVzdC5tYXJrT25seSgpO1xuICAgICAgICByZXR1cm4gdGVzdDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUGVuZGluZyB0ZXN0IGNhc2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXG4gICAgICAgKi9cbiAgICAgIHNraXA6IGZ1bmN0aW9uICh0aXRsZSkge1xuICAgICAgICBjb250ZXh0LnRlc3QodGl0bGUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/interfaces/common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/interfaces/exports.js":
/*!******************************************************!*\
  !*** ./node_modules/mocha/lib/interfaces/exports.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar Suite = __webpack_require__(/*! ../suite */ \"(ssr)/./node_modules/mocha/lib/suite.js\");\nvar Test = __webpack_require__(/*! ../test */ \"(ssr)/./node_modules/mocha/lib/test.js\");\n\n/**\n * Exports-style (as Node.js module) interface:\n *\n *     exports.Array = {\n *       '#indexOf()': {\n *         'should return -1 when the value is not present': function() {\n *\n *         },\n *\n *         'should return the correct index when the value is present': function() {\n *\n *         }\n *       }\n *     };\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n\n  suite.on(Suite.constants.EVENT_FILE_REQUIRE, visit);\n\n  function visit(obj, file) {\n    var suite;\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        var fn = obj[key];\n        switch (key) {\n          case 'before':\n            suites[0].beforeAll(fn);\n            break;\n          case 'after':\n            suites[0].afterAll(fn);\n            break;\n          case 'beforeEach':\n            suites[0].beforeEach(fn);\n            break;\n          case 'afterEach':\n            suites[0].afterEach(fn);\n            break;\n          default:\n            var test = new Test(key, fn);\n            test.file = file;\n            suites[0].addTest(test);\n        }\n      } else {\n        suite = Suite.create(suites[0], key);\n        suites.unshift(suite);\n        visit(obj[key], file);\n        suites.shift();\n      }\n    }\n  }\n};\n\nmodule.exports.description = 'Node.js module (\"exports\") style';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2ludGVyZmFjZXMvZXhwb3J0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFlBQVksbUJBQU8sQ0FBQyx5REFBVTtBQUM5QixXQUFXLG1CQUFPLENBQUMsdURBQVM7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvaW50ZXJmYWNlcy9leHBvcnRzLmpzPzExNGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIFN1aXRlID0gcmVxdWlyZSgnLi4vc3VpdGUnKTtcbnZhciBUZXN0ID0gcmVxdWlyZSgnLi4vdGVzdCcpO1xuXG4vKipcbiAqIEV4cG9ydHMtc3R5bGUgKGFzIE5vZGUuanMgbW9kdWxlKSBpbnRlcmZhY2U6XG4gKlxuICogICAgIGV4cG9ydHMuQXJyYXkgPSB7XG4gKiAgICAgICAnI2luZGV4T2YoKSc6IHtcbiAqICAgICAgICAgJ3Nob3VsZCByZXR1cm4gLTEgd2hlbiB0aGUgdmFsdWUgaXMgbm90IHByZXNlbnQnOiBmdW5jdGlvbigpIHtcbiAqXG4gKiAgICAgICAgIH0sXG4gKlxuICogICAgICAgICAnc2hvdWxkIHJldHVybiB0aGUgY29ycmVjdCBpbmRleCB3aGVuIHRoZSB2YWx1ZSBpcyBwcmVzZW50JzogZnVuY3Rpb24oKSB7XG4gKlxuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfTtcbiAqXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSBSb290IHN1aXRlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdWl0ZSkge1xuICB2YXIgc3VpdGVzID0gW3N1aXRlXTtcblxuICBzdWl0ZS5vbihTdWl0ZS5jb25zdGFudHMuRVZFTlRfRklMRV9SRVFVSVJFLCB2aXNpdCk7XG5cbiAgZnVuY3Rpb24gdmlzaXQob2JqLCBmaWxlKSB7XG4gICAgdmFyIHN1aXRlO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGZuID0gb2JqW2tleV07XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgY2FzZSAnYmVmb3JlJzpcbiAgICAgICAgICAgIHN1aXRlc1swXS5iZWZvcmVBbGwoZm4pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYWZ0ZXInOlxuICAgICAgICAgICAgc3VpdGVzWzBdLmFmdGVyQWxsKGZuKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2JlZm9yZUVhY2gnOlxuICAgICAgICAgICAgc3VpdGVzWzBdLmJlZm9yZUVhY2goZm4pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYWZ0ZXJFYWNoJzpcbiAgICAgICAgICAgIHN1aXRlc1swXS5hZnRlckVhY2goZm4pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciB0ZXN0ID0gbmV3IFRlc3Qoa2V5LCBmbik7XG4gICAgICAgICAgICB0ZXN0LmZpbGUgPSBmaWxlO1xuICAgICAgICAgICAgc3VpdGVzWzBdLmFkZFRlc3QodGVzdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1aXRlID0gU3VpdGUuY3JlYXRlKHN1aXRlc1swXSwga2V5KTtcbiAgICAgICAgc3VpdGVzLnVuc2hpZnQoc3VpdGUpO1xuICAgICAgICB2aXNpdChvYmpba2V5XSwgZmlsZSk7XG4gICAgICAgIHN1aXRlcy5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZGVzY3JpcHRpb24gPSAnTm9kZS5qcyBtb2R1bGUgKFwiZXhwb3J0c1wiKSBzdHlsZSc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/interfaces/exports.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/interfaces/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mocha/lib/interfaces/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.bdd = __webpack_require__(/*! ./bdd */ \"(ssr)/./node_modules/mocha/lib/interfaces/bdd.js\");\nexports.tdd = __webpack_require__(/*! ./tdd */ \"(ssr)/./node_modules/mocha/lib/interfaces/tdd.js\");\nexports.qunit = __webpack_require__(/*! ./qunit */ \"(ssr)/./node_modules/mocha/lib/interfaces/qunit.js\");\nexports.exports = __webpack_require__(/*! ./exports */ \"(ssr)/./node_modules/mocha/lib/interfaces/exports.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2ludGVyZmFjZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0dBQThCO0FBQzlCLGtHQUE4QjtBQUM5Qix3R0FBa0M7QUFDbEMsOEdBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvaW50ZXJmYWNlcy9pbmRleC5qcz9kYzQ2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5iZGQgPSByZXF1aXJlKCcuL2JkZCcpO1xuZXhwb3J0cy50ZGQgPSByZXF1aXJlKCcuL3RkZCcpO1xuZXhwb3J0cy5xdW5pdCA9IHJlcXVpcmUoJy4vcXVuaXQnKTtcbmV4cG9ydHMuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZXhwb3J0cycpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/interfaces/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/interfaces/qunit.js":
/*!****************************************************!*\
  !*** ./node_modules/mocha/lib/interfaces/qunit.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Test = __webpack_require__(/*! ../test */ \"(ssr)/./node_modules/mocha/lib/test.js\");\nvar EVENT_FILE_PRE_REQUIRE =\n  (__webpack_require__(/*! ../suite */ \"(ssr)/./node_modules/mocha/lib/suite.js\").constants).EVENT_FILE_PRE_REQUIRE;\n\n/**\n * QUnit-style interface:\n *\n *     suite('Array');\n *\n *     test('#length', function() {\n *       var arr = [1,2,3];\n *       ok(arr.length == 3);\n *     });\n *\n *     test('#indexOf()', function() {\n *       var arr = [1,2,3];\n *       ok(arr.indexOf(1) == 0);\n *       ok(arr.indexOf(2) == 1);\n *       ok(arr.indexOf(3) == 2);\n *     });\n *\n *     suite('String');\n *\n *     test('#length', function() {\n *       ok('foo'.length == 3);\n *     });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function qUnitInterface(suite) {\n  var suites = [suite];\n\n  suite.on(EVENT_FILE_PRE_REQUIRE, function (context, file, mocha) {\n    var common = __webpack_require__(/*! ./common */ \"(ssr)/./node_modules/mocha/lib/interfaces/common.js\")(suites, context, mocha);\n\n    context.before = common.before;\n    context.after = common.after;\n    context.beforeEach = common.beforeEach;\n    context.afterEach = common.afterEach;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`.\n     */\n\n    context.suite = function (title) {\n      if (suites.length > 1) {\n        suites.shift();\n      }\n      return common.suite.create({\n        title,\n        file,\n        fn: false\n      });\n    };\n\n    /**\n     * Exclusive Suite.\n     */\n\n    context.suite.only = function (title) {\n      if (suites.length > 1) {\n        suites.shift();\n      }\n      return common.suite.only({\n        title,\n        file,\n        fn: false\n      });\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    context.test = function (title, fn) {\n      var test = new Test(title, fn);\n      test.file = file;\n      suites[0].addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.test.only = function (title, fn) {\n      return common.test.only(mocha, context.test(title, fn));\n    };\n\n    context.test.skip = common.test.skip;\n  });\n};\n\nmodule.exports.description = 'QUnit style';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2ludGVyZmFjZXMvcXVuaXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLHVEQUFTO0FBQzVCO0FBQ0EsRUFBRSwwRkFBNkI7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMscUVBQVU7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBLDBCQUEwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2ludGVyZmFjZXMvcXVuaXQuanM/YmU1NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBUZXN0ID0gcmVxdWlyZSgnLi4vdGVzdCcpO1xudmFyIEVWRU5UX0ZJTEVfUFJFX1JFUVVJUkUgPVxuICByZXF1aXJlKCcuLi9zdWl0ZScpLmNvbnN0YW50cy5FVkVOVF9GSUxFX1BSRV9SRVFVSVJFO1xuXG4vKipcbiAqIFFVbml0LXN0eWxlIGludGVyZmFjZTpcbiAqXG4gKiAgICAgc3VpdGUoJ0FycmF5Jyk7XG4gKlxuICogICAgIHRlc3QoJyNsZW5ndGgnLCBmdW5jdGlvbigpIHtcbiAqICAgICAgIHZhciBhcnIgPSBbMSwyLDNdO1xuICogICAgICAgb2soYXJyLmxlbmd0aCA9PSAzKTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgdGVzdCgnI2luZGV4T2YoKScsIGZ1bmN0aW9uKCkge1xuICogICAgICAgdmFyIGFyciA9IFsxLDIsM107XG4gKiAgICAgICBvayhhcnIuaW5kZXhPZigxKSA9PSAwKTtcbiAqICAgICAgIG9rKGFyci5pbmRleE9mKDIpID09IDEpO1xuICogICAgICAgb2soYXJyLmluZGV4T2YoMykgPT0gMik7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIHN1aXRlKCdTdHJpbmcnKTtcbiAqXG4gKiAgICAgdGVzdCgnI2xlbmd0aCcsIGZ1bmN0aW9uKCkge1xuICogICAgICAgb2soJ2ZvbycubGVuZ3RoID09IDMpO1xuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlIFJvb3Qgc3VpdGUuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcVVuaXRJbnRlcmZhY2Uoc3VpdGUpIHtcbiAgdmFyIHN1aXRlcyA9IFtzdWl0ZV07XG5cbiAgc3VpdGUub24oRVZFTlRfRklMRV9QUkVfUkVRVUlSRSwgZnVuY3Rpb24gKGNvbnRleHQsIGZpbGUsIG1vY2hhKSB7XG4gICAgdmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJykoc3VpdGVzLCBjb250ZXh0LCBtb2NoYSk7XG5cbiAgICBjb250ZXh0LmJlZm9yZSA9IGNvbW1vbi5iZWZvcmU7XG4gICAgY29udGV4dC5hZnRlciA9IGNvbW1vbi5hZnRlcjtcbiAgICBjb250ZXh0LmJlZm9yZUVhY2ggPSBjb21tb24uYmVmb3JlRWFjaDtcbiAgICBjb250ZXh0LmFmdGVyRWFjaCA9IGNvbW1vbi5hZnRlckVhY2g7XG4gICAgY29udGV4dC5ydW4gPSBtb2NoYS5vcHRpb25zLmRlbGF5ICYmIGNvbW1vbi5ydW5XaXRoU3VpdGUoc3VpdGUpO1xuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIGEgXCJzdWl0ZVwiIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAuXG4gICAgICovXG5cbiAgICBjb250ZXh0LnN1aXRlID0gZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgICBpZiAoc3VpdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc3VpdGVzLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLmNyZWF0ZSh7XG4gICAgICAgIHRpdGxlLFxuICAgICAgICBmaWxlLFxuICAgICAgICBmbjogZmFsc2VcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeGNsdXNpdmUgU3VpdGUuXG4gICAgICovXG5cbiAgICBjb250ZXh0LnN1aXRlLm9ubHkgPSBmdW5jdGlvbiAodGl0bGUpIHtcbiAgICAgIGlmIChzdWl0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBzdWl0ZXMuc2hpZnQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21tb24uc3VpdGUub25seSh7XG4gICAgICAgIHRpdGxlLFxuICAgICAgICBmaWxlLFxuICAgICAgICBmbjogZmFsc2VcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSBhIHNwZWNpZmljYXRpb24gb3IgdGVzdC1jYXNlXG4gICAgICogd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgY2FsbGJhY2sgYGZuYFxuICAgICAqIGFjdGluZyBhcyBhIHRodW5rLlxuICAgICAqL1xuXG4gICAgY29udGV4dC50ZXN0ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xuICAgICAgdmFyIHRlc3QgPSBuZXcgVGVzdCh0aXRsZSwgZm4pO1xuICAgICAgdGVzdC5maWxlID0gZmlsZTtcbiAgICAgIHN1aXRlc1swXS5hZGRUZXN0KHRlc3QpO1xuICAgICAgcmV0dXJuIHRlc3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4Y2x1c2l2ZSB0ZXN0LWNhc2UuXG4gICAgICovXG5cbiAgICBjb250ZXh0LnRlc3Qub25seSA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcbiAgICAgIHJldHVybiBjb21tb24udGVzdC5vbmx5KG1vY2hhLCBjb250ZXh0LnRlc3QodGl0bGUsIGZuKSk7XG4gICAgfTtcblxuICAgIGNvbnRleHQudGVzdC5za2lwID0gY29tbW9uLnRlc3Quc2tpcDtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5kZXNjcmlwdGlvbiA9ICdRVW5pdCBzdHlsZSc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/interfaces/qunit.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/interfaces/tdd.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/interfaces/tdd.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Test = __webpack_require__(/*! ../test */ \"(ssr)/./node_modules/mocha/lib/test.js\");\nvar EVENT_FILE_PRE_REQUIRE =\n  (__webpack_require__(/*! ../suite */ \"(ssr)/./node_modules/mocha/lib/suite.js\").constants).EVENT_FILE_PRE_REQUIRE;\n\n/**\n * TDD-style interface:\n *\n *      suite('Array', function() {\n *        suite('#indexOf()', function() {\n *          suiteSetup(function() {\n *\n *          });\n *\n *          test('should return -1 when not present', function() {\n *\n *          });\n *\n *          test('should return the index when present', function() {\n *\n *          });\n *\n *          suiteTeardown(function() {\n *\n *          });\n *        });\n *      });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n\n  suite.on(EVENT_FILE_PRE_REQUIRE, function (context, file, mocha) {\n    var common = __webpack_require__(/*! ./common */ \"(ssr)/./node_modules/mocha/lib/interfaces/common.js\")(suites, context, mocha);\n\n    context.setup = common.beforeEach;\n    context.teardown = common.afterEach;\n    context.suiteSetup = common.before;\n    context.suiteTeardown = common.after;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n\n    /**\n     * Describe a \"suite\" with the given `title` and callback `fn` containing\n     * nested suites and/or tests.\n     */\n    context.suite = function (title, fn) {\n      return common.suite.create({\n        title,\n        file,\n        fn\n      });\n    };\n\n    /**\n     * Pending suite.\n     */\n    context.suite.skip = function (title, fn) {\n      return common.suite.skip({\n        title,\n        file,\n        fn\n      });\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n    context.suite.only = function (title, fn) {\n      return common.suite.only({\n        title,\n        file,\n        fn\n      });\n    };\n\n    /**\n     * Describe a specification or test-case with the given `title` and\n     * callback `fn` acting as a thunk.\n     */\n    context.test = function (title, fn) {\n      var suite = suites[0];\n      if (suite.isPending()) {\n        fn = null;\n      }\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.test.only = function (title, fn) {\n      return common.test.only(mocha, context.test(title, fn));\n    };\n\n    context.test.skip = common.test.skip;\n  });\n};\n\nmodule.exports.description =\n  'traditional \"suite\"/\"test\" instead of BDD\\'s \"describe\"/\"it\"';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2ludGVyZmFjZXMvdGRkLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyx1REFBUztBQUM1QjtBQUNBLEVBQUUsMEZBQTZCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHFFQUFVOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2ludGVyZmFjZXMvdGRkLmpzPzFjNmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVGVzdCA9IHJlcXVpcmUoJy4uL3Rlc3QnKTtcbnZhciBFVkVOVF9GSUxFX1BSRV9SRVFVSVJFID1cbiAgcmVxdWlyZSgnLi4vc3VpdGUnKS5jb25zdGFudHMuRVZFTlRfRklMRV9QUkVfUkVRVUlSRTtcblxuLyoqXG4gKiBUREQtc3R5bGUgaW50ZXJmYWNlOlxuICpcbiAqICAgICAgc3VpdGUoJ0FycmF5JywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgc3VpdGUoJyNpbmRleE9mKCknLCBmdW5jdGlvbigpIHtcbiAqICAgICAgICAgIHN1aXRlU2V0dXAoZnVuY3Rpb24oKSB7XG4gKlxuICogICAgICAgICAgfSk7XG4gKlxuICogICAgICAgICAgdGVzdCgnc2hvdWxkIHJldHVybiAtMSB3aGVuIG5vdCBwcmVzZW50JywgZnVuY3Rpb24oKSB7XG4gKlxuICogICAgICAgICAgfSk7XG4gKlxuICogICAgICAgICAgdGVzdCgnc2hvdWxkIHJldHVybiB0aGUgaW5kZXggd2hlbiBwcmVzZW50JywgZnVuY3Rpb24oKSB7XG4gKlxuICogICAgICAgICAgfSk7XG4gKlxuICogICAgICAgICAgc3VpdGVUZWFyZG93bihmdW5jdGlvbigpIHtcbiAqXG4gKiAgICAgICAgICB9KTtcbiAqICAgICAgICB9KTtcbiAqICAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGUgUm9vdCBzdWl0ZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3VpdGUpIHtcbiAgdmFyIHN1aXRlcyA9IFtzdWl0ZV07XG5cbiAgc3VpdGUub24oRVZFTlRfRklMRV9QUkVfUkVRVUlSRSwgZnVuY3Rpb24gKGNvbnRleHQsIGZpbGUsIG1vY2hhKSB7XG4gICAgdmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJykoc3VpdGVzLCBjb250ZXh0LCBtb2NoYSk7XG5cbiAgICBjb250ZXh0LnNldHVwID0gY29tbW9uLmJlZm9yZUVhY2g7XG4gICAgY29udGV4dC50ZWFyZG93biA9IGNvbW1vbi5hZnRlckVhY2g7XG4gICAgY29udGV4dC5zdWl0ZVNldHVwID0gY29tbW9uLmJlZm9yZTtcbiAgICBjb250ZXh0LnN1aXRlVGVhcmRvd24gPSBjb21tb24uYWZ0ZXI7XG4gICAgY29udGV4dC5ydW4gPSBtb2NoYS5vcHRpb25zLmRlbGF5ICYmIGNvbW1vbi5ydW5XaXRoU3VpdGUoc3VpdGUpO1xuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgYSBcInN1aXRlXCIgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgY2FsbGJhY2sgYGZuYCBjb250YWluaW5nXG4gICAgICogbmVzdGVkIHN1aXRlcyBhbmQvb3IgdGVzdHMuXG4gICAgICovXG4gICAgY29udGV4dC5zdWl0ZSA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcbiAgICAgIHJldHVybiBjb21tb24uc3VpdGUuY3JlYXRlKHtcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGZpbGUsXG4gICAgICAgIGZuXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGVuZGluZyBzdWl0ZS5cbiAgICAgKi9cbiAgICBjb250ZXh0LnN1aXRlLnNraXAgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLnNraXAoe1xuICAgICAgICB0aXRsZSxcbiAgICAgICAgZmlsZSxcbiAgICAgICAgZm5cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeGNsdXNpdmUgdGVzdC1jYXNlLlxuICAgICAqL1xuICAgIGNvbnRleHQuc3VpdGUub25seSA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcbiAgICAgIHJldHVybiBjb21tb24uc3VpdGUub25seSh7XG4gICAgICAgIHRpdGxlLFxuICAgICAgICBmaWxlLFxuICAgICAgICBmblxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIGEgc3BlY2lmaWNhdGlvbiBvciB0ZXN0LWNhc2Ugd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmRcbiAgICAgKiBjYWxsYmFjayBgZm5gIGFjdGluZyBhcyBhIHRodW5rLlxuICAgICAqL1xuICAgIGNvbnRleHQudGVzdCA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcbiAgICAgIHZhciBzdWl0ZSA9IHN1aXRlc1swXTtcbiAgICAgIGlmIChzdWl0ZS5pc1BlbmRpbmcoKSkge1xuICAgICAgICBmbiA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgdGVzdCA9IG5ldyBUZXN0KHRpdGxlLCBmbik7XG4gICAgICB0ZXN0LmZpbGUgPSBmaWxlO1xuICAgICAgc3VpdGUuYWRkVGVzdCh0ZXN0KTtcbiAgICAgIHJldHVybiB0ZXN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeGNsdXNpdmUgdGVzdC1jYXNlLlxuICAgICAqL1xuXG4gICAgY29udGV4dC50ZXN0Lm9ubHkgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XG4gICAgICByZXR1cm4gY29tbW9uLnRlc3Qub25seShtb2NoYSwgY29udGV4dC50ZXN0KHRpdGxlLCBmbikpO1xuICAgIH07XG5cbiAgICBjb250ZXh0LnRlc3Quc2tpcCA9IGNvbW1vbi50ZXN0LnNraXA7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZGVzY3JpcHRpb24gPVxuICAndHJhZGl0aW9uYWwgXCJzdWl0ZVwiL1widGVzdFwiIGluc3RlYWQgb2YgQkREXFwncyBcImRlc2NyaWJlXCIvXCJpdFwiJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/interfaces/tdd.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/mocha.js":
/*!*****************************************!*\
  !*** ./node_modules/mocha/lib/mocha.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\n\n/*!\n * mocha\n * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\nvar escapeRe = __webpack_require__(/*! escape-string-regexp */ \"(ssr)/./node_modules/mocha/node_modules/escape-string-regexp/index.js\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar builtinReporters = __webpack_require__(/*! ./reporters */ \"(ssr)/./node_modules/mocha/lib/reporters/index.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\");\nvar mocharc = __webpack_require__(/*! ./mocharc.json */ \"(ssr)/./node_modules/mocha/lib/mocharc.json\");\nvar Suite = __webpack_require__(/*! ./suite */ \"(ssr)/./node_modules/mocha/lib/suite.js\");\nvar esmUtils = __webpack_require__(/*! ./nodejs/esm-utils */ \"(ssr)/./node_modules/mocha/lib/nodejs/esm-utils.js\");\nvar createStatsCollector = __webpack_require__(/*! ./stats-collector */ \"(ssr)/./node_modules/mocha/lib/stats-collector.js\");\nconst {\n  createInvalidReporterError,\n  createInvalidInterfaceError,\n  createMochaInstanceAlreadyDisposedError,\n  createMochaInstanceAlreadyRunningError,\n  createUnsupportedError\n} = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/mocha/lib/errors.js\");\nconst {EVENT_FILE_PRE_REQUIRE, EVENT_FILE_POST_REQUIRE, EVENT_FILE_REQUIRE} =\n  Suite.constants;\nvar debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")('mocha:mocha');\n\nexports = module.exports = Mocha;\n\n/**\n * A Mocha instance is a finite state machine.\n * These are the states it can be in.\n * @private\n */\nvar mochaStates = utils.defineConstants({\n  /**\n   * Initial state of the mocha instance\n   * @private\n   */\n  INIT: 'init',\n  /**\n   * Mocha instance is running tests\n   * @private\n   */\n  RUNNING: 'running',\n  /**\n   * Mocha instance is done running tests and references to test functions and hooks are cleaned.\n   * You can reset this state by unloading the test files.\n   * @private\n   */\n  REFERENCES_CLEANED: 'referencesCleaned',\n  /**\n   * Mocha instance is disposed and can no longer be used.\n   * @private\n   */\n  DISPOSED: 'disposed'\n});\n\n/**\n * To require local UIs and reporters when running in node.\n */\n\nif (!utils.isBrowser() && typeof module.paths !== 'undefined') {\n  var cwd = utils.cwd();\n  module.paths.push(cwd, path.join(cwd, 'node_modules'));\n}\n\n/**\n * Expose internals.\n * @private\n */\n\nexports.utils = utils;\nexports.interfaces = __webpack_require__(/*! ./interfaces */ \"(ssr)/./node_modules/mocha/lib/interfaces/index.js\");\n/**\n * @public\n * @memberof Mocha\n */\nexports.reporters = builtinReporters;\nexports.Runnable = __webpack_require__(/*! ./runnable */ \"(ssr)/./node_modules/mocha/lib/runnable.js\");\nexports.Context = __webpack_require__(/*! ./context */ \"(ssr)/./node_modules/mocha/lib/context.js\");\n/**\n *\n * @memberof Mocha\n */\nexports.Runner = __webpack_require__(/*! ./runner */ \"(ssr)/./node_modules/mocha/lib/runner.js\");\nexports.Suite = Suite;\nexports.Hook = __webpack_require__(/*! ./hook */ \"(ssr)/./node_modules/mocha/lib/hook.js\");\nexports.Test = __webpack_require__(/*! ./test */ \"(ssr)/./node_modules/mocha/lib/test.js\");\n\nlet currentContext;\nexports.afterEach = function (...args) {\n  return (currentContext.afterEach || currentContext.teardown).apply(\n    this,\n    args\n  );\n};\nexports.after = function (...args) {\n  return (currentContext.after || currentContext.suiteTeardown).apply(\n    this,\n    args\n  );\n};\nexports.beforeEach = function (...args) {\n  return (currentContext.beforeEach || currentContext.setup).apply(this, args);\n};\nexports.before = function (...args) {\n  return (currentContext.before || currentContext.suiteSetup).apply(this, args);\n};\nexports.describe = function (...args) {\n  return (currentContext.describe || currentContext.suite).apply(this, args);\n};\nexports.describe.only = function (...args) {\n  return (currentContext.describe || currentContext.suite).only.apply(\n    this,\n    args\n  );\n};\nexports.describe.skip = function (...args) {\n  return (currentContext.describe || currentContext.suite).skip.apply(\n    this,\n    args\n  );\n};\nexports.it = function (...args) {\n  return (currentContext.it || currentContext.test).apply(this, args);\n};\nexports.it.only = function (...args) {\n  return (currentContext.it || currentContext.test).only.apply(this, args);\n};\nexports.it.skip = function (...args) {\n  return (currentContext.it || currentContext.test).skip.apply(this, args);\n};\nexports.xdescribe = exports.describe.skip;\nexports.xit = exports.it.skip;\nexports.setup = exports.beforeEach;\nexports.suiteSetup = exports.before;\nexports.suiteTeardown = exports.after;\nexports.suite = exports.describe;\nexports.teardown = exports.afterEach;\nexports.test = exports.it;\nexports.run = function (...args) {\n  return currentContext.run.apply(this, args);\n};\n\n/**\n * Constructs a new Mocha instance with `options`.\n *\n * @public\n * @class Mocha\n * @param {Object} [options] - Settings object.\n * @param {boolean} [options.allowUncaught] - Propagate uncaught errors?\n * @param {boolean} [options.asyncOnly] - Force `done` callback or promise?\n * @param {boolean} [options.bail] - Bail after first test failure?\n * @param {boolean} [options.checkLeaks] - Check for global variable leaks?\n * @param {boolean} [options.color] - Color TTY output from reporter?\n * @param {boolean} [options.delay] - Delay root suite execution?\n * @param {boolean} [options.diff] - Show diff on failure?\n * @param {boolean} [options.dryRun] - Report tests without running them?\n * @param {boolean} [options.passOnFailingTestSuite] - Fail test run if tests were failed?\n * @param {boolean} [options.failZero] - Fail test run if zero tests?\n * @param {string} [options.fgrep] - Test filter given string.\n * @param {boolean} [options.forbidOnly] - Tests marked `only` fail the suite?\n * @param {boolean} [options.forbidPending] - Pending tests fail the suite?\n * @param {boolean} [options.fullTrace] - Full stacktrace upon failure?\n * @param {string[]} [options.global] - Variables expected in global scope.\n * @param {RegExp|string} [options.grep] - Test filter given regular expression.\n * @param {boolean} [options.inlineDiffs] - Display inline diffs?\n * @param {boolean} [options.invert] - Invert test filter matches?\n * @param {boolean} [options.noHighlighting] - Disable syntax highlighting?\n * @param {string|constructor} [options.reporter] - Reporter name or constructor.\n * @param {Object} [options.reporterOption] - Reporter settings object.\n * @param {number} [options.retries] - Number of times to retry failed tests.\n * @param {number} [options.slow] - Slow threshold value.\n * @param {number|string} [options.timeout] - Timeout threshold value.\n * @param {string} [options.ui] - Interface name.\n * @param {boolean} [options.parallel] - Run jobs in parallel.\n * @param {number} [options.jobs] - Max number of worker processes for parallel runs.\n * @param {MochaRootHookObject} [options.rootHooks] - Hooks to bootstrap the root suite with.\n * @param {string[]} [options.require] - Pathname of `rootHooks` plugin for parallel runs.\n * @param {boolean} [options.isWorker] - Should be `true` if `Mocha` process is running in a worker process.\n */\nfunction Mocha(options = {}) {\n  options = {...mocharc, ...options};\n  this.files = [];\n  this.options = options;\n  // root suite\n  this.suite = new exports.Suite('', new exports.Context(), true);\n  this._cleanReferencesAfterRun = true;\n  this._state = mochaStates.INIT;\n\n  this.grep(options.grep)\n    .fgrep(options.fgrep)\n    .ui(options.ui)\n    .reporter(\n      options.reporter,\n      options.reporterOption || options.reporterOptions // for backwards compatibility\n    )\n    .slow(options.slow)\n    .global(options.global);\n\n  // this guard exists because Suite#timeout does not consider `undefined` to be valid input\n  if (typeof options.timeout !== 'undefined') {\n    this.timeout(options.timeout === false ? 0 : options.timeout);\n  }\n\n  if ('retries' in options) {\n    this.retries(options.retries);\n  }\n\n  [\n    'allowUncaught',\n    'asyncOnly',\n    'bail',\n    'checkLeaks',\n    'color',\n    'delay',\n    'diff',\n    'dryRun',\n    'passOnFailingTestSuite',\n    'failZero',\n    'forbidOnly',\n    'forbidPending',\n    'fullTrace',\n    'inlineDiffs',\n    'invert'\n  ].forEach(function (opt) {\n    if (options[opt]) {\n      this[opt]();\n    }\n  }, this);\n\n  if (options.rootHooks) {\n    this.rootHooks(options.rootHooks);\n  }\n\n  /**\n   * The class which we'll instantiate in {@link Mocha#run}.  Defaults to\n   * {@link Runner} in serial mode; changes in parallel mode.\n   * @memberof Mocha\n   * @private\n   */\n  this._runnerClass = exports.Runner;\n\n  /**\n   * Whether or not to call {@link Mocha#loadFiles} implicitly when calling\n   * {@link Mocha#run}.  If this is `true`, then it's up to the consumer to call\n   * {@link Mocha#loadFiles} _or_ {@link Mocha#loadFilesAsync}.\n   * @private\n   * @memberof Mocha\n   */\n  this._lazyLoadFiles = false;\n\n  /**\n   * It's useful for a Mocha instance to know if it's running in a worker process.\n   * We could derive this via other means, but it's helpful to have a flag to refer to.\n   * @memberof Mocha\n   * @private\n   */\n  this.isWorker = Boolean(options.isWorker);\n\n  this.globalSetup(options.globalSetup)\n    .globalTeardown(options.globalTeardown)\n    .enableGlobalSetup(options.enableGlobalSetup)\n    .enableGlobalTeardown(options.enableGlobalTeardown);\n\n  if (\n    options.parallel &&\n    (typeof options.jobs === 'undefined' || options.jobs > 1)\n  ) {\n    debug('attempting to enable parallel mode');\n    this.parallelMode(true);\n  }\n}\n\n/**\n * Enables or disables bailing on the first failure.\n *\n * @public\n * @see [CLI option](../#-bail-b)\n * @param {boolean} [bail=true] - Whether to bail on first error.\n * @returns {Mocha} this\n * @chainable\n */\nMocha.prototype.bail = function (bail) {\n  this.suite.bail(bail !== false);\n  return this;\n};\n\n/**\n * @summary\n * Adds `file` to be loaded for execution.\n *\n * @description\n * Useful for generic setup code that must be included within test suite.\n *\n * @public\n * @see [CLI option](../#-file-filedirectoryglob)\n * @param {string} file - Pathname of file to be loaded.\n * @returns {Mocha} this\n * @chainable\n */\nMocha.prototype.addFile = function (file) {\n  this.files.push(file);\n  return this;\n};\n\n/**\n * Sets reporter to `reporter`, defaults to \"spec\".\n *\n * @public\n * @see [CLI option](../#-reporter-name-r-name)\n * @see [Reporters](../#reporters)\n * @param {String|Function} reporterName - Reporter name or constructor.\n * @param {Object} [reporterOptions] - Options used to configure the reporter.\n * @returns {Mocha} this\n * @chainable\n * @throws {Error} if requested reporter cannot be loaded\n * @example\n *\n * // Use XUnit reporter and direct its output to file\n * mocha.reporter('xunit', { output: '/path/to/testspec.xunit.xml' });\n */\nMocha.prototype.reporter = function (reporterName, reporterOptions) {\n  if (typeof reporterName === 'function') {\n    this._reporter = reporterName;\n  } else {\n    reporterName = reporterName || 'spec';\n    var reporter;\n    // Try to load a built-in reporter.\n    if (builtinReporters[reporterName]) {\n      reporter = builtinReporters[reporterName];\n    }\n    // Try to load reporters from process.cwd() and node_modules\n    if (!reporter) {\n      let foundReporter;\n      try {\n        foundReporter = /*require.resolve*/(__webpack_require__(\"(ssr)/./node_modules/mocha/lib sync recursive\").resolve(reporterName));\n        reporter = __webpack_require__(\"(ssr)/./node_modules/mocha/lib sync recursive\")(foundReporter);\n      } catch (err) {\n        if (foundReporter) {\n          throw createInvalidReporterError(err.message, foundReporter);\n        }\n        // Try to load reporters from a cwd-relative path\n        try {\n          reporter = __webpack_require__(\"(ssr)/./node_modules/mocha/lib sync recursive\")(path.resolve(reporterName));\n        } catch (e) {\n          throw createInvalidReporterError(e.message, reporterName);\n        }\n      }\n    }\n    this._reporter = reporter;\n  }\n  this.options.reporterOption = reporterOptions;\n  // alias option name is used in built-in reporters xunit/tap/progress\n  this.options.reporterOptions = reporterOptions;\n  return this;\n};\n\n/**\n * Sets test UI `name`, defaults to \"bdd\".\n *\n * @public\n * @see [CLI option](../#-ui-name-u-name)\n * @see [Interface DSLs](../#interfaces)\n * @param {string|Function} [ui=bdd] - Interface name or class.\n * @returns {Mocha} this\n * @chainable\n * @throws {Error} if requested interface cannot be loaded\n */\nMocha.prototype.ui = function (ui) {\n  var bindInterface;\n  if (typeof ui === 'function') {\n    bindInterface = ui;\n  } else {\n    ui = ui || 'bdd';\n    bindInterface = exports.interfaces[ui];\n    if (!bindInterface) {\n      try {\n        bindInterface = __webpack_require__(\"(ssr)/./node_modules/mocha/lib sync recursive\")(ui);\n      } catch (err) {\n        throw createInvalidInterfaceError(`invalid interface '${ui}'`, ui);\n      }\n    }\n  }\n  bindInterface(this.suite);\n\n  this.suite.on(EVENT_FILE_PRE_REQUIRE, function (context) {\n    currentContext = context;\n  });\n\n  return this;\n};\n\n/**\n * Loads `files` prior to execution. Does not support ES Modules.\n *\n * @description\n * The implementation relies on Node's `require` to execute\n * the test interface functions and will be subject to its cache.\n * Supports only CommonJS modules. To load ES modules, use Mocha#loadFilesAsync.\n *\n * @private\n * @see {@link Mocha#addFile}\n * @see {@link Mocha#run}\n * @see {@link Mocha#unloadFiles}\n * @see {@link Mocha#loadFilesAsync}\n * @param {Function} [fn] - Callback invoked upon completion.\n */\nMocha.prototype.loadFiles = function (fn) {\n  var self = this;\n  var suite = this.suite;\n  this.files.forEach(function (file) {\n    file = path.resolve(file);\n    suite.emit(EVENT_FILE_PRE_REQUIRE, global, file, self);\n    suite.emit(EVENT_FILE_REQUIRE, __webpack_require__(\"(ssr)/./node_modules/mocha/lib sync recursive\")(file), file, self);\n    suite.emit(EVENT_FILE_POST_REQUIRE, global, file, self);\n  });\n  fn && fn();\n};\n\n/**\n * Loads `files` prior to execution. Supports Node ES Modules.\n *\n * @description\n * The implementation relies on Node's `require` and `import` to execute\n * the test interface functions and will be subject to its cache.\n * Supports both CJS and ESM modules.\n *\n * @public\n * @see {@link Mocha#addFile}\n * @see {@link Mocha#run}\n * @see {@link Mocha#unloadFiles}\n * @param {Object} [options] - Settings object.\n * @param {Function} [options.esmDecorator] - Function invoked on esm module name right before importing it. By default will passthrough as is.\n * @returns {Promise}\n * @example\n *\n * // loads ESM (and CJS) test files asynchronously, then runs root suite\n * mocha.loadFilesAsync()\n *   .then(() => mocha.run(failures => process.exitCode = failures ? 1 : 0))\n *   .catch(() => process.exitCode = 1);\n */\nMocha.prototype.loadFilesAsync = function ({esmDecorator} = {}) {\n  var self = this;\n  var suite = this.suite;\n  this.lazyLoadFiles(true);\n\n  return esmUtils.loadFilesAsync(\n    this.files,\n    function (file) {\n      suite.emit(EVENT_FILE_PRE_REQUIRE, global, file, self);\n    },\n    function (file, resultModule) {\n      suite.emit(EVENT_FILE_REQUIRE, resultModule, file, self);\n      suite.emit(EVENT_FILE_POST_REQUIRE, global, file, self);\n    },\n    esmDecorator\n  );\n};\n\n/**\n * Removes a previously loaded file from Node's `require` cache.\n *\n * @private\n * @static\n * @see {@link Mocha#unloadFiles}\n * @param {string} file - Pathname of file to be unloaded.\n */\nMocha.unloadFile = function (file) {\n  if (utils.isBrowser()) {\n    throw createUnsupportedError(\n      'unloadFile() is only supported in a Node.js environment'\n    );\n  }\n  return (__webpack_require__(/*! ./nodejs/file-unloader */ \"(ssr)/./node_modules/mocha/lib/nodejs/file-unloader.js\").unloadFile)(file);\n};\n\n/**\n * Unloads `files` from Node's `require` cache.\n *\n * @description\n * This allows required files to be \"freshly\" reloaded, providing the ability\n * to reuse a Mocha instance programmatically.\n * Note: does not clear ESM module files from the cache\n *\n * <strong>Intended for consumers &mdash; not used internally</strong>\n *\n * @public\n * @see {@link Mocha#run}\n * @returns {Mocha} this\n * @chainable\n */\nMocha.prototype.unloadFiles = function () {\n  if (this._state === mochaStates.DISPOSED) {\n    throw createMochaInstanceAlreadyDisposedError(\n      'Mocha instance is already disposed, it cannot be used again.',\n      this._cleanReferencesAfterRun,\n      this\n    );\n  }\n\n  this.files.forEach(function (file) {\n    Mocha.unloadFile(file);\n  });\n  this._state = mochaStates.INIT;\n  return this;\n};\n\n/**\n * Sets `grep` filter after escaping RegExp special characters.\n *\n * @public\n * @see {@link Mocha#grep}\n * @param {string} str - Value to be converted to a regexp.\n * @returns {Mocha} this\n * @chainable\n * @example\n *\n * // Select tests whose full title begins with `\"foo\"` followed by a period\n * mocha.fgrep('foo.');\n */\nMocha.prototype.fgrep = function (str) {\n  if (!str) {\n    return this;\n  }\n  return this.grep(new RegExp(escapeRe(str)));\n};\n\n/**\n * @summary\n * Sets `grep` filter used to select specific tests for execution.\n *\n * @description\n * If `re` is a regexp-like string, it will be converted to regexp.\n * The regexp is tested against the full title of each test (i.e., the\n * name of the test preceded by titles of each its ancestral suites).\n * As such, using an <em>exact-match</em> fixed pattern against the\n * test name itself will not yield any matches.\n * <br>\n * <strong>Previous filter value will be overwritten on each call!</strong>\n *\n * @public\n * @see [CLI option](../#-grep-regexp-g-regexp)\n * @see {@link Mocha#fgrep}\n * @see {@link Mocha#invert}\n * @param {RegExp|String} re - Regular expression used to select tests.\n * @return {Mocha} this\n * @chainable\n * @example\n *\n * // Select tests whose full title contains `\"match\"`, ignoring case\n * mocha.grep(/match/i);\n * @example\n *\n * // Same as above but with regexp-like string argument\n * mocha.grep('/match/i');\n * @example\n *\n * // ## Anti-example\n * // Given embedded test `it('only-this-test')`...\n * mocha.grep('/^only-this-test$/');    // NO! Use `.only()` to do this!\n */\nMocha.prototype.grep = function (re) {\n  if (utils.isString(re)) {\n    // extract args if it's regex-like, i.e: [string, pattern, flag]\n    var arg = re.match(/^\\/(.*)\\/([gimy]{0,4})$|.*/);\n    this.options.grep = new RegExp(arg[1] || arg[0], arg[2]);\n  } else {\n    this.options.grep = re;\n  }\n  return this;\n};\n\n/**\n * Inverts `grep` matches.\n *\n * @public\n * @see {@link Mocha#grep}\n * @return {Mocha} this\n * @chainable\n * @example\n *\n * // Select tests whose full title does *not* contain `\"match\"`, ignoring case\n * mocha.grep(/match/i).invert();\n */\nMocha.prototype.invert = function () {\n  this.options.invert = true;\n  return this;\n};\n\n/**\n * Enables or disables checking for global variables leaked while running tests.\n *\n * @public\n * @see [CLI option](../#-check-leaks)\n * @param {boolean} [checkLeaks=true] - Whether to check for global variable leaks.\n * @return {Mocha} this\n * @chainable\n */\nMocha.prototype.checkLeaks = function (checkLeaks) {\n  this.options.checkLeaks = checkLeaks !== false;\n  return this;\n};\n\n/**\n * Enables or disables whether or not to dispose after each test run.\n * Disable this to ensure you can run the test suite multiple times.\n * If disabled, be sure to dispose mocha when you're done to prevent memory leaks.\n * @public\n * @see {@link Mocha#dispose}\n * @param {boolean} cleanReferencesAfterRun\n * @return {Mocha} this\n * @chainable\n */\nMocha.prototype.cleanReferencesAfterRun = function (cleanReferencesAfterRun) {\n  this._cleanReferencesAfterRun = cleanReferencesAfterRun !== false;\n  return this;\n};\n\n/**\n * Manually dispose this mocha instance. Mark this instance as `disposed` and unable to run more tests.\n * It also removes function references to tests functions and hooks, so variables trapped in closures can be cleaned by the garbage collector.\n * @public\n */\nMocha.prototype.dispose = function () {\n  if (this._state === mochaStates.RUNNING) {\n    throw createMochaInstanceAlreadyRunningError(\n      'Cannot dispose while the mocha instance is still running tests.'\n    );\n  }\n  this.unloadFiles();\n  this._previousRunner && this._previousRunner.dispose();\n  this.suite.dispose();\n  this._state = mochaStates.DISPOSED;\n};\n\n/**\n * Displays full stack trace upon test failure.\n *\n * @public\n * @see [CLI option](../#-full-trace)\n * @param {boolean} [fullTrace=true] - Whether to print full stacktrace upon failure.\n * @return {Mocha} this\n * @chainable\n */\nMocha.prototype.fullTrace = function (fullTrace) {\n  this.options.fullTrace = fullTrace !== false;\n  return this;\n};\n\n/**\n * Specifies whitelist of variable names to be expected in global scope.\n *\n * @public\n * @see [CLI option](../#-global-variable-name)\n * @see {@link Mocha#checkLeaks}\n * @param {String[]|String} global - Accepted global variable name(s).\n * @return {Mocha} this\n * @chainable\n * @example\n *\n * // Specify variables to be expected in global scope\n * mocha.global(['jQuery', 'MyLib']);\n */\nMocha.prototype.global = function (global) {\n  this.options.global = (this.options.global || [])\n    .concat(global)\n    .filter(Boolean)\n    .filter(function (elt, idx, arr) {\n      return arr.indexOf(elt) === idx;\n    });\n  return this;\n};\n// for backwards compatibility, 'globals' is an alias of 'global'\nMocha.prototype.globals = Mocha.prototype.global;\n\n/**\n * Enables or disables TTY color output by screen-oriented reporters.\n *\n * @public\n * @see [CLI option](../#-color-c-colors)\n * @param {boolean} [color=true] - Whether to enable color output.\n * @return {Mocha} this\n * @chainable\n */\nMocha.prototype.color = function (color) {\n  this.options.color = color !== false;\n  return this;\n};\n\n/**\n * Enables or disables reporter to use inline diffs (rather than +/-)\n * in test failure output.\n *\n * @public\n * @see [CLI option](../#-inline-diffs)\n * @param {boolean} [inlineDiffs=true] - Whether to use inline diffs.\n * @return {Mocha} this\n * @chainable\n */\nMocha.prototype.inlineDiffs = function (inlineDiffs) {\n  this.options.inlineDiffs = inlineDiffs !== false;\n  return this;\n};\n\n/**\n * Enables or disables reporter to include diff in test failure output.\n *\n * @public\n * @see [CLI option](../#-diff)\n * @param {boolean} [diff=true] - Whether to show diff on failure.\n * @return {Mocha} this\n * @chainable\n */\nMocha.prototype.diff = function (diff) {\n  this.options.diff = diff !== false;\n  return this;\n};\n\n/**\n * @summary\n * Sets timeout threshold value.\n *\n * @description\n * A string argument can use shorthand (such as \"2s\") and will be converted.\n * If the value is `0`, timeouts will be disabled.\n *\n * @public\n * @see [CLI option](../#-timeout-ms-t-ms)\n * @see [Timeouts](../#timeouts)\n * @param {number|string} msecs - Timeout threshold value.\n * @return {Mocha} this\n * @chainable\n * @example\n *\n * // Sets timeout to one second\n * mocha.timeout(1000);\n * @example\n *\n * // Same as above but using string argument\n * mocha.timeout('1s');\n */\nMocha.prototype.timeout = function (msecs) {\n  this.suite.timeout(msecs);\n  return this;\n};\n\n/**\n * Sets the number of times to retry failed tests.\n *\n * @public\n * @see [CLI option](../#-retries-n)\n * @see [Retry Tests](../#retry-tests)\n * @param {number} retry - Number of times to retry failed tests.\n * @return {Mocha} this\n * @chainable\n * @example\n *\n * // Allow any failed test to retry one more time\n * mocha.retries(1);\n */\nMocha.prototype.retries = function (retry) {\n  this.suite.retries(retry);\n  return this;\n};\n\n/**\n * Sets slowness threshold value.\n *\n * @public\n * @see [CLI option](../#-slow-ms-s-ms)\n * @param {number} msecs - Slowness threshold value.\n * @return {Mocha} this\n * @chainable\n * @example\n *\n * // Sets \"slow\" threshold to half a second\n * mocha.slow(500);\n * @example\n *\n * // Same as above but using string argument\n * mocha.slow('0.5s');\n */\nMocha.prototype.slow = function (msecs) {\n  this.suite.slow(msecs);\n  return this;\n};\n\n/**\n * Forces all tests to either accept a `done` callback or return a promise.\n *\n * @public\n * @see [CLI option](../#-async-only-a)\n * @param {boolean} [asyncOnly=true] - Whether to force `done` callback or promise.\n * @return {Mocha} this\n * @chainable\n */\nMocha.prototype.asyncOnly = function (asyncOnly) {\n  this.options.asyncOnly = asyncOnly !== false;\n  return this;\n};\n\n/**\n * Disables syntax highlighting (in browser).\n *\n * @public\n * @return {Mocha} this\n * @chainable\n */\nMocha.prototype.noHighlighting = function () {\n  this.options.noHighlighting = true;\n  return this;\n};\n\n/**\n * Enables or disables uncaught errors to propagate.\n *\n * @public\n * @see [CLI option](../#-allow-uncaught)\n * @param {boolean} [allowUncaught=true] - Whether to propagate uncaught errors.\n * @return {Mocha} this\n * @chainable\n */\nMocha.prototype.allowUncaught = function (allowUncaught) {\n  this.options.allowUncaught = allowUncaught !== false;\n  return this;\n};\n\n/**\n * @summary\n * Delays root suite execution.\n *\n * @description\n * Used to perform async operations before any suites are run.\n *\n * @public\n * @see [delayed root suite](../#delayed-root-suite)\n * @returns {Mocha} this\n * @chainable\n */\nMocha.prototype.delay = function delay() {\n  this.options.delay = true;\n  return this;\n};\n\n/**\n * Enables or disables running tests in dry-run mode.\n *\n * @public\n * @see [CLI option](../#-dry-run)\n * @param {boolean} [dryRun=true] - Whether to activate dry-run mode.\n * @return {Mocha} this\n * @chainable\n */\nMocha.prototype.dryRun = function (dryRun) {\n  this.options.dryRun = dryRun !== false;\n  return this;\n};\n\n/**\n * Fails test run if no tests encountered with exit-code 1.\n *\n * @public\n * @see [CLI option](../#-fail-zero)\n * @param {boolean} [failZero=true] - Whether to fail test run.\n * @return {Mocha} this\n * @chainable\n */\nMocha.prototype.failZero = function (failZero) {\n  this.options.failZero = failZero !== false;\n  return this;\n};\n\n/**\n * Fail test run if tests were failed.\n *\n * @public\n * @see [CLI option](../#-pass-on-failing-test-suite)\n * @param {boolean} [passOnFailingTestSuite=false] - Whether to fail test run.\n * @return {Mocha} this\n * @chainable\n */\nMocha.prototype.passOnFailingTestSuite = function(passOnFailingTestSuite) {\n  this.options.passOnFailingTestSuite = passOnFailingTestSuite === true;\n  return this;\n};\n\n/**\n * Causes tests marked `only` to fail the suite.\n *\n * @public\n * @see [CLI option](../#-forbid-only)\n * @param {boolean} [forbidOnly=true] - Whether tests marked `only` fail the suite.\n * @returns {Mocha} this\n * @chainable\n */\nMocha.prototype.forbidOnly = function (forbidOnly) {\n  this.options.forbidOnly = forbidOnly !== false;\n  return this;\n};\n\n/**\n * Causes pending tests and tests marked `skip` to fail the suite.\n *\n * @public\n * @see [CLI option](../#-forbid-pending)\n * @param {boolean} [forbidPending=true] - Whether pending tests fail the suite.\n * @returns {Mocha} this\n * @chainable\n */\nMocha.prototype.forbidPending = function (forbidPending) {\n  this.options.forbidPending = forbidPending !== false;\n  return this;\n};\n\n/**\n * Throws an error if mocha is in the wrong state to be able to transition to a \"running\" state.\n * @private\n */\nMocha.prototype._guardRunningStateTransition = function () {\n  if (this._state === mochaStates.RUNNING) {\n    throw createMochaInstanceAlreadyRunningError(\n      'Mocha instance is currently running tests, cannot start a next test run until this one is done',\n      this\n    );\n  }\n  if (\n    this._state === mochaStates.DISPOSED ||\n    this._state === mochaStates.REFERENCES_CLEANED\n  ) {\n    throw createMochaInstanceAlreadyDisposedError(\n      'Mocha instance is already disposed, cannot start a new test run. Please create a new mocha instance. Be sure to set disable `cleanReferencesAfterRun` when you want to reuse the same mocha instance for multiple test runs.',\n      this._cleanReferencesAfterRun,\n      this\n    );\n  }\n};\n\n/**\n * Mocha version as specified by \"package.json\".\n *\n * @name Mocha#version\n * @type string\n * @readonly\n */\nObject.defineProperty(Mocha.prototype, 'version', {\n  value: (__webpack_require__(/*! ../package.json */ \"(ssr)/./node_modules/mocha/package.json\").version),\n  configurable: false,\n  enumerable: true,\n  writable: false\n});\n\n/**\n * Callback to be invoked when test execution is complete.\n *\n * @private\n * @callback DoneCB\n * @param {number} failures - Number of failures that occurred.\n */\n\n/**\n * Runs root suite and invokes `fn()` when complete.\n *\n * @description\n * To run tests multiple times (or to run tests in files that are\n * already in the `require` cache), make sure to clear them from\n * the cache first!\n *\n * @public\n * @see {@link Mocha#unloadFiles}\n * @see {@link Runner#run}\n * @param {DoneCB} [fn] - Callback invoked when test execution completed.\n * @returns {Runner} runner instance\n * @example\n *\n * // exit with non-zero status if there were test failures\n * mocha.run(failures => process.exitCode = failures ? 1 : 0);\n */\nMocha.prototype.run = function (fn) {\n  this._guardRunningStateTransition();\n  this._state = mochaStates.RUNNING;\n  if (this._previousRunner) {\n    this._previousRunner.dispose();\n    this.suite.reset();\n  }\n  if (this.files.length && !this._lazyLoadFiles) {\n    this.loadFiles();\n  }\n  var suite = this.suite;\n  var options = this.options;\n  options.files = this.files;\n  const runner = new this._runnerClass(suite, {\n    cleanReferencesAfterRun: this._cleanReferencesAfterRun,\n    delay: options.delay,\n    dryRun: options.dryRun,\n    failZero: options.failZero\n  });\n  createStatsCollector(runner);\n  var reporter = new this._reporter(runner, options);\n  runner.checkLeaks = options.checkLeaks === true;\n  runner.fullStackTrace = options.fullTrace;\n  runner.asyncOnly = options.asyncOnly;\n  runner.allowUncaught = options.allowUncaught;\n  runner.forbidOnly = options.forbidOnly;\n  runner.forbidPending = options.forbidPending;\n  if (options.grep) {\n    runner.grep(options.grep, options.invert);\n  }\n  if (options.global) {\n    runner.globals(options.global);\n  }\n  if (options.color !== undefined) {\n    exports.reporters.Base.useColors = options.color;\n  }\n  exports.reporters.Base.inlineDiffs = options.inlineDiffs;\n  exports.reporters.Base.hideDiff = !options.diff;\n\n  const done = failures => {\n    this._previousRunner = runner;\n    this._state = this._cleanReferencesAfterRun\n      ? mochaStates.REFERENCES_CLEANED\n      : mochaStates.INIT;\n    fn = fn || utils.noop;\n    if (typeof reporter.done === 'function') {\n      reporter.done(failures, fn);\n    } else {\n      fn(failures);\n    }\n  };\n\n  const runAsync = async runner => {\n    const context =\n      this.options.enableGlobalSetup && this.hasGlobalSetupFixtures()\n        ? await this.runGlobalSetup(runner)\n        : {};\n    const failureCount = await runner.runAsync({\n      files: this.files,\n      options\n    });\n    if (this.options.enableGlobalTeardown && this.hasGlobalTeardownFixtures()) {\n      await this.runGlobalTeardown(runner, {context});\n    }\n    return failureCount;\n  };\n\n  // no \"catch\" here is intentional. errors coming out of\n  // Runner#run are considered uncaught/unhandled and caught\n  // by the `process` event listeners.\n  // also: returning anything other than `runner` would be a breaking\n  // change\n  runAsync(runner).then(done);\n\n  return runner;\n};\n\n/**\n * Assigns hooks to the root suite\n * @param {MochaRootHookObject} [hooks] - Hooks to assign to root suite\n * @chainable\n */\nMocha.prototype.rootHooks = function rootHooks({\n  beforeAll = [],\n  beforeEach = [],\n  afterAll = [],\n  afterEach = []\n} = {}) {\n  beforeAll = utils.castArray(beforeAll);\n  beforeEach = utils.castArray(beforeEach);\n  afterAll = utils.castArray(afterAll);\n  afterEach = utils.castArray(afterEach);\n  beforeAll.forEach(hook => {\n    this.suite.beforeAll(hook);\n  });\n  beforeEach.forEach(hook => {\n    this.suite.beforeEach(hook);\n  });\n  afterAll.forEach(hook => {\n    this.suite.afterAll(hook);\n  });\n  afterEach.forEach(hook => {\n    this.suite.afterEach(hook);\n  });\n  return this;\n};\n\n/**\n * Toggles parallel mode.\n *\n * Must be run before calling {@link Mocha#run}. Changes the `Runner` class to\n * use; also enables lazy file loading if not already done so.\n *\n * Warning: when passed `false` and lazy loading has been enabled _via any means_ (including calling `parallelMode(true)`), this method will _not_ disable lazy loading. Lazy loading is a prerequisite for parallel\n * mode, but parallel mode is _not_ a prerequisite for lazy loading!\n * @param {boolean} [enable] - If `true`, enable; otherwise disable.\n * @throws If run in browser\n * @throws If Mocha not in `INIT` state\n * @returns {Mocha}\n * @chainable\n * @public\n */\nMocha.prototype.parallelMode = function parallelMode(enable = true) {\n  if (utils.isBrowser()) {\n    throw createUnsupportedError('parallel mode is only supported in Node.js');\n  }\n  const parallel = Boolean(enable);\n  if (\n    parallel === this.options.parallel &&\n    this._lazyLoadFiles &&\n    this._runnerClass !== exports.Runner\n  ) {\n    return this;\n  }\n  if (this._state !== mochaStates.INIT) {\n    throw createUnsupportedError(\n      'cannot change parallel mode after having called run()'\n    );\n  }\n  this.options.parallel = parallel;\n\n  // swap Runner class\n  this._runnerClass = parallel\n    ? __webpack_require__(/*! ./nodejs/parallel-buffered-runner */ \"(ssr)/./node_modules/mocha/lib/nodejs/parallel-buffered-runner.js\")\n    : exports.Runner;\n\n  // lazyLoadFiles may have been set `true` otherwise (for ESM loading),\n  // so keep `true` if so.\n  return this.lazyLoadFiles(this._lazyLoadFiles || parallel);\n};\n\n/**\n * Disables implicit call to {@link Mocha#loadFiles} in {@link Mocha#run}. This\n * setting is used by watch mode, parallel mode, and for loading ESM files.\n * @todo This should throw if we've already loaded files; such behavior\n * necessitates adding a new state.\n * @param {boolean} [enable] - If `true`, disable eager loading of files in\n * {@link Mocha#run}\n * @chainable\n * @public\n */\nMocha.prototype.lazyLoadFiles = function lazyLoadFiles(enable) {\n  this._lazyLoadFiles = enable === true;\n  debug('set lazy load to %s', enable);\n  return this;\n};\n\n/**\n * Configures one or more global setup fixtures.\n *\n * If given no parameters, _unsets_ any previously-set fixtures.\n * @chainable\n * @public\n * @param {MochaGlobalFixture|MochaGlobalFixture[]} [setupFns] - Global setup fixture(s)\n * @returns {Mocha}\n */\nMocha.prototype.globalSetup = function globalSetup(setupFns = []) {\n  setupFns = utils.castArray(setupFns);\n  this.options.globalSetup = setupFns;\n  debug('configured %d global setup functions', setupFns.length);\n  return this;\n};\n\n/**\n * Configures one or more global teardown fixtures.\n *\n * If given no parameters, _unsets_ any previously-set fixtures.\n * @chainable\n * @public\n * @param {MochaGlobalFixture|MochaGlobalFixture[]} [teardownFns] - Global teardown fixture(s)\n * @returns {Mocha}\n */\nMocha.prototype.globalTeardown = function globalTeardown(teardownFns = []) {\n  teardownFns = utils.castArray(teardownFns);\n  this.options.globalTeardown = teardownFns;\n  debug('configured %d global teardown functions', teardownFns.length);\n  return this;\n};\n\n/**\n * Run any global setup fixtures sequentially, if any.\n *\n * This is _automatically called_ by {@link Mocha#run} _unless_ the `runGlobalSetup` option is `false`; see {@link Mocha#enableGlobalSetup}.\n *\n * The context object this function resolves with should be consumed by {@link Mocha#runGlobalTeardown}.\n * @param {object} [context] - Context object if already have one\n * @public\n * @returns {Promise<object>} Context object\n */\nMocha.prototype.runGlobalSetup = async function runGlobalSetup(context = {}) {\n  const {globalSetup} = this.options;\n  if (globalSetup && globalSetup.length) {\n    debug('run(): global setup starting');\n    await this._runGlobalFixtures(globalSetup, context);\n    debug('run(): global setup complete');\n  }\n  return context;\n};\n\n/**\n * Run any global teardown fixtures sequentially, if any.\n *\n * This is _automatically called_ by {@link Mocha#run} _unless_ the `runGlobalTeardown` option is `false`; see {@link Mocha#enableGlobalTeardown}.\n *\n * Should be called with context object returned by {@link Mocha#runGlobalSetup}, if applicable.\n * @param {object} [context] - Context object if already have one\n * @public\n * @returns {Promise<object>} Context object\n */\nMocha.prototype.runGlobalTeardown = async function runGlobalTeardown(\n  context = {}\n) {\n  const {globalTeardown} = this.options;\n  if (globalTeardown && globalTeardown.length) {\n    debug('run(): global teardown starting');\n    await this._runGlobalFixtures(globalTeardown, context);\n  }\n  debug('run(): global teardown complete');\n  return context;\n};\n\n/**\n * Run global fixtures sequentially with context `context`\n * @private\n * @param {MochaGlobalFixture[]} [fixtureFns] - Fixtures to run\n * @param {object} [context] - context object\n * @returns {Promise<object>} context object\n */\nMocha.prototype._runGlobalFixtures = async function _runGlobalFixtures(\n  fixtureFns = [],\n  context = {}\n) {\n  for await (const fixtureFn of fixtureFns) {\n    await fixtureFn.call(context);\n  }\n  return context;\n};\n\n/**\n * Toggle execution of any global setup fixture(s)\n *\n * @chainable\n * @public\n * @param {boolean } [enabled=true] - If `false`, do not run global setup fixture\n * @returns {Mocha}\n */\nMocha.prototype.enableGlobalSetup = function enableGlobalSetup(enabled = true) {\n  this.options.enableGlobalSetup = Boolean(enabled);\n  return this;\n};\n\n/**\n * Toggle execution of any global teardown fixture(s)\n *\n * @chainable\n * @public\n * @param {boolean } [enabled=true] - If `false`, do not run global teardown fixture\n * @returns {Mocha}\n */\nMocha.prototype.enableGlobalTeardown = function enableGlobalTeardown(\n  enabled = true\n) {\n  this.options.enableGlobalTeardown = Boolean(enabled);\n  return this;\n};\n\n/**\n * Returns `true` if one or more global setup fixtures have been supplied.\n * @public\n * @returns {boolean}\n */\nMocha.prototype.hasGlobalSetupFixtures = function hasGlobalSetupFixtures() {\n  return Boolean(this.options.globalSetup.length);\n};\n\n/**\n * Returns `true` if one or more global teardown fixtures have been supplied.\n * @public\n * @returns {boolean}\n */\nMocha.prototype.hasGlobalTeardownFixtures =\n  function hasGlobalTeardownFixtures() {\n    return Boolean(this.options.globalTeardown.length);\n  };\n\n/**\n * An alternative way to define root hooks that works with parallel runs.\n * @typedef {Object} MochaRootHookObject\n * @property {Function|Function[]} [beforeAll] - \"Before all\" hook(s)\n * @property {Function|Function[]} [beforeEach] - \"Before each\" hook(s)\n * @property {Function|Function[]} [afterAll] - \"After all\" hook(s)\n * @property {Function|Function[]} [afterEach] - \"After each\" hook(s)\n */\n\n/**\n * An function that returns a {@link MochaRootHookObject}, either sync or async.\n   @callback MochaRootHookFunction\n * @returns {MochaRootHookObject|Promise<MochaRootHookObject>}\n */\n\n/**\n * A function that's invoked _once_ which is either sync or async.\n * Can be a \"teardown\" or \"setup\".  These will all share the same context.\n * @callback MochaGlobalFixture\n * @returns {void|Promise<void>}\n */\n\n/**\n * An object making up all necessary parts of a plugin loader and aggregator\n * @typedef {Object} PluginDefinition\n * @property {string} exportName - Named export to use\n * @property {string} [optionName] - Option name for Mocha constructor (use `exportName` if omitted)\n * @property {PluginValidator} [validate] - Validator function\n * @property {PluginFinalizer} [finalize] - Finalizer/aggregator function\n */\n\n/**\n * A (sync) function to assert a user-supplied plugin implementation is valid.\n *\n * Defined in a {@link PluginDefinition}.\n\n * @callback PluginValidator\n * @param {*} value - Value to check\n * @this {PluginDefinition}\n * @returns {void}\n */\n\n/**\n * A function to finalize plugins impls of a particular ilk\n * @callback PluginFinalizer\n * @param {Array<*>} impls - User-supplied implementations\n * @returns {Promise<*>|*}\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL21vY2hhLmpzIiwibWFwcGluZ3MiOiI7QUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsbUJBQU8sQ0FBQyxtR0FBc0I7QUFDN0MsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLHVCQUF1QixtQkFBTyxDQUFDLHNFQUFhO0FBQzVDLFlBQVksbUJBQU8sQ0FBQyx3REFBUztBQUM3QixjQUFjLG1CQUFPLENBQUMsbUVBQWdCO0FBQ3RDLFlBQVksbUJBQU8sQ0FBQyx3REFBUztBQUM3QixlQUFlLG1CQUFPLENBQUMsOEVBQW9CO0FBQzNDLDJCQUEyQixtQkFBTyxDQUFDLDRFQUFtQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQywwREFBVTtBQUN0QixPQUFPLHFFQUFxRTtBQUM1RTtBQUNBLFlBQVksbUJBQU8sQ0FBQyxzREFBTzs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiLGtIQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixzR0FBd0M7QUFDeEMsbUdBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQW9DO0FBQ3BDLGFBQWE7QUFDYiwwRkFBZ0M7QUFDaEMsMEZBQWdDOztBQUVoQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFdBQVc7QUFDWCxhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLHFCQUFxQjtBQUNyQixhQUFhO0FBQ2IsZ0JBQWdCO0FBQ2hCLFlBQVk7QUFDWixXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsZUFBZTtBQUMxQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLG9CQUFvQjtBQUMvQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsU0FBUztBQUNwQjtBQUNBLDJCQUEyQjtBQUMzQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLGdCQUFnQjtBQUMzRCxNQUFNLGNBQWMsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRCxNQUFNLGdCQUFnQjtBQUN0QixNQUFNLHVCQUF1QixNQUFNLDJCQUEyQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1Q0FBdUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQWUsQ0FBQyx5RkFBWTtBQUNwRCxtQkFBbUIscUVBQVEsYUFBYSxDQUFDO0FBQ3pDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFFQUFRLDBCQUEwQixDQUFDO0FBQ3hELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsT0FBTztBQUNwQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFFQUFRLEVBQUUsQ0FBQztBQUNuQyxRQUFRO0FBQ1IsZ0VBQWdFLEdBQUc7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1QsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHFFQUFRLElBQUksQ0FBQztBQUNoRDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNULFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGNBQWMsSUFBSTtBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0hBQTRDO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLFNBQVM7QUFDVCxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVCxXQUFXLGVBQWU7QUFDMUIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLElBQUk7QUFDN0M7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFdBQVcsU0FBUztBQUNwQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFdBQVcsaUJBQWlCO0FBQzVCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsK0ZBQWtDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsU0FBUztBQUNULFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdDQUFnQztBQUNwQztBQUNBLEVBQUUsa0NBQWtDO0FBQ3BDLEVBQUUsK0JBQStCOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0MsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUyw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sbUJBQU8sQ0FBQyw0R0FBbUM7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsdUJBQXVCLElBQUksZ0JBQWdCO0FBQ3pFO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUNBQXlDO0FBQ3BELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlDQUF5QztBQUNwRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQixpREFBaUQsS0FBSyw4QkFBOEI7QUFDM0k7QUFDQSx5RUFBeUUsOEJBQThCO0FBQ3ZHLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0EsMkVBQTJFO0FBQzNFLFNBQVMsYUFBYTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCLG9EQUFvRCxLQUFLLGlDQUFpQztBQUNqSjtBQUNBLHFEQUFxRCwyQkFBMkI7QUFDaEYsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdCQUFnQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLFFBQVE7QUFDbkIsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLHFCQUFxQjtBQUNuQyxjQUFjLHFCQUFxQjtBQUNuQyxjQUFjLHFCQUFxQjtBQUNuQyxjQUFjLHFCQUFxQjtBQUNuQzs7QUFFQTtBQUNBLCtCQUErQiwwQkFBMEI7QUFDekQ7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsaUJBQWlCO0FBQy9CLGNBQWMsaUJBQWlCO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7O0FBRXhDO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsVUFBVTtBQUNWLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvbW9jaGEuanM/YzAyMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogbW9jaGFcbiAqIENvcHlyaWdodChjKSAyMDExIFRKIEhvbG93YXljaHVrIDx0akB2aXNpb24tbWVkaWEuY2E+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgZXNjYXBlUmUgPSByZXF1aXJlKCdlc2NhcGUtc3RyaW5nLXJlZ2V4cCcpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgYnVpbHRpblJlcG9ydGVycyA9IHJlcXVpcmUoJy4vcmVwb3J0ZXJzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbW9jaGFyYyA9IHJlcXVpcmUoJy4vbW9jaGFyYy5qc29uJyk7XG52YXIgU3VpdGUgPSByZXF1aXJlKCcuL3N1aXRlJyk7XG52YXIgZXNtVXRpbHMgPSByZXF1aXJlKCcuL25vZGVqcy9lc20tdXRpbHMnKTtcbnZhciBjcmVhdGVTdGF0c0NvbGxlY3RvciA9IHJlcXVpcmUoJy4vc3RhdHMtY29sbGVjdG9yJyk7XG5jb25zdCB7XG4gIGNyZWF0ZUludmFsaWRSZXBvcnRlckVycm9yLFxuICBjcmVhdGVJbnZhbGlkSW50ZXJmYWNlRXJyb3IsXG4gIGNyZWF0ZU1vY2hhSW5zdGFuY2VBbHJlYWR5RGlzcG9zZWRFcnJvcixcbiAgY3JlYXRlTW9jaGFJbnN0YW5jZUFscmVhZHlSdW5uaW5nRXJyb3IsXG4gIGNyZWF0ZVVuc3VwcG9ydGVkRXJyb3Jcbn0gPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3Qge0VWRU5UX0ZJTEVfUFJFX1JFUVVJUkUsIEVWRU5UX0ZJTEVfUE9TVF9SRVFVSVJFLCBFVkVOVF9GSUxFX1JFUVVJUkV9ID1cbiAgU3VpdGUuY29uc3RhbnRzO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9jaGE6bW9jaGEnKTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTW9jaGE7XG5cbi8qKlxuICogQSBNb2NoYSBpbnN0YW5jZSBpcyBhIGZpbml0ZSBzdGF0ZSBtYWNoaW5lLlxuICogVGhlc2UgYXJlIHRoZSBzdGF0ZXMgaXQgY2FuIGJlIGluLlxuICogQHByaXZhdGVcbiAqL1xudmFyIG1vY2hhU3RhdGVzID0gdXRpbHMuZGVmaW5lQ29uc3RhbnRzKHtcbiAgLyoqXG4gICAqIEluaXRpYWwgc3RhdGUgb2YgdGhlIG1vY2hhIGluc3RhbmNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJTklUOiAnaW5pdCcsXG4gIC8qKlxuICAgKiBNb2NoYSBpbnN0YW5jZSBpcyBydW5uaW5nIHRlc3RzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBSVU5OSU5HOiAncnVubmluZycsXG4gIC8qKlxuICAgKiBNb2NoYSBpbnN0YW5jZSBpcyBkb25lIHJ1bm5pbmcgdGVzdHMgYW5kIHJlZmVyZW5jZXMgdG8gdGVzdCBmdW5jdGlvbnMgYW5kIGhvb2tzIGFyZSBjbGVhbmVkLlxuICAgKiBZb3UgY2FuIHJlc2V0IHRoaXMgc3RhdGUgYnkgdW5sb2FkaW5nIHRoZSB0ZXN0IGZpbGVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUkVGRVJFTkNFU19DTEVBTkVEOiAncmVmZXJlbmNlc0NsZWFuZWQnLFxuICAvKipcbiAgICogTW9jaGEgaW5zdGFuY2UgaXMgZGlzcG9zZWQgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIERJU1BPU0VEOiAnZGlzcG9zZWQnXG59KTtcblxuLyoqXG4gKiBUbyByZXF1aXJlIGxvY2FsIFVJcyBhbmQgcmVwb3J0ZXJzIHdoZW4gcnVubmluZyBpbiBub2RlLlxuICovXG5cbmlmICghdXRpbHMuaXNCcm93c2VyKCkgJiYgdHlwZW9mIG1vZHVsZS5wYXRocyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIGN3ZCA9IHV0aWxzLmN3ZCgpO1xuICBtb2R1bGUucGF0aHMucHVzaChjd2QsIHBhdGguam9pbihjd2QsICdub2RlX21vZHVsZXMnKSk7XG59XG5cbi8qKlxuICogRXhwb3NlIGludGVybmFscy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy51dGlscyA9IHV0aWxzO1xuZXhwb3J0cy5pbnRlcmZhY2VzID0gcmVxdWlyZSgnLi9pbnRlcmZhY2VzJyk7XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBtZW1iZXJvZiBNb2NoYVxuICovXG5leHBvcnRzLnJlcG9ydGVycyA9IGJ1aWx0aW5SZXBvcnRlcnM7XG5leHBvcnRzLlJ1bm5hYmxlID0gcmVxdWlyZSgnLi9ydW5uYWJsZScpO1xuZXhwb3J0cy5Db250ZXh0ID0gcmVxdWlyZSgnLi9jb250ZXh0Jyk7XG4vKipcbiAqXG4gKiBAbWVtYmVyb2YgTW9jaGFcbiAqL1xuZXhwb3J0cy5SdW5uZXIgPSByZXF1aXJlKCcuL3J1bm5lcicpO1xuZXhwb3J0cy5TdWl0ZSA9IFN1aXRlO1xuZXhwb3J0cy5Ib29rID0gcmVxdWlyZSgnLi9ob29rJyk7XG5leHBvcnRzLlRlc3QgPSByZXF1aXJlKCcuL3Rlc3QnKTtcblxubGV0IGN1cnJlbnRDb250ZXh0O1xuZXhwb3J0cy5hZnRlckVhY2ggPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICByZXR1cm4gKGN1cnJlbnRDb250ZXh0LmFmdGVyRWFjaCB8fCBjdXJyZW50Q29udGV4dC50ZWFyZG93bikuYXBwbHkoXG4gICAgdGhpcyxcbiAgICBhcmdzXG4gICk7XG59O1xuZXhwb3J0cy5hZnRlciA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gIHJldHVybiAoY3VycmVudENvbnRleHQuYWZ0ZXIgfHwgY3VycmVudENvbnRleHQuc3VpdGVUZWFyZG93bikuYXBwbHkoXG4gICAgdGhpcyxcbiAgICBhcmdzXG4gICk7XG59O1xuZXhwb3J0cy5iZWZvcmVFYWNoID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIChjdXJyZW50Q29udGV4dC5iZWZvcmVFYWNoIHx8IGN1cnJlbnRDb250ZXh0LnNldHVwKS5hcHBseSh0aGlzLCBhcmdzKTtcbn07XG5leHBvcnRzLmJlZm9yZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gIHJldHVybiAoY3VycmVudENvbnRleHQuYmVmb3JlIHx8IGN1cnJlbnRDb250ZXh0LnN1aXRlU2V0dXApLmFwcGx5KHRoaXMsIGFyZ3MpO1xufTtcbmV4cG9ydHMuZGVzY3JpYmUgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICByZXR1cm4gKGN1cnJlbnRDb250ZXh0LmRlc2NyaWJlIHx8IGN1cnJlbnRDb250ZXh0LnN1aXRlKS5hcHBseSh0aGlzLCBhcmdzKTtcbn07XG5leHBvcnRzLmRlc2NyaWJlLm9ubHkgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICByZXR1cm4gKGN1cnJlbnRDb250ZXh0LmRlc2NyaWJlIHx8IGN1cnJlbnRDb250ZXh0LnN1aXRlKS5vbmx5LmFwcGx5KFxuICAgIHRoaXMsXG4gICAgYXJnc1xuICApO1xufTtcbmV4cG9ydHMuZGVzY3JpYmUuc2tpcCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gIHJldHVybiAoY3VycmVudENvbnRleHQuZGVzY3JpYmUgfHwgY3VycmVudENvbnRleHQuc3VpdGUpLnNraXAuYXBwbHkoXG4gICAgdGhpcyxcbiAgICBhcmdzXG4gICk7XG59O1xuZXhwb3J0cy5pdCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gIHJldHVybiAoY3VycmVudENvbnRleHQuaXQgfHwgY3VycmVudENvbnRleHQudGVzdCkuYXBwbHkodGhpcywgYXJncyk7XG59O1xuZXhwb3J0cy5pdC5vbmx5ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIChjdXJyZW50Q29udGV4dC5pdCB8fCBjdXJyZW50Q29udGV4dC50ZXN0KS5vbmx5LmFwcGx5KHRoaXMsIGFyZ3MpO1xufTtcbmV4cG9ydHMuaXQuc2tpcCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gIHJldHVybiAoY3VycmVudENvbnRleHQuaXQgfHwgY3VycmVudENvbnRleHQudGVzdCkuc2tpcC5hcHBseSh0aGlzLCBhcmdzKTtcbn07XG5leHBvcnRzLnhkZXNjcmliZSA9IGV4cG9ydHMuZGVzY3JpYmUuc2tpcDtcbmV4cG9ydHMueGl0ID0gZXhwb3J0cy5pdC5za2lwO1xuZXhwb3J0cy5zZXR1cCA9IGV4cG9ydHMuYmVmb3JlRWFjaDtcbmV4cG9ydHMuc3VpdGVTZXR1cCA9IGV4cG9ydHMuYmVmb3JlO1xuZXhwb3J0cy5zdWl0ZVRlYXJkb3duID0gZXhwb3J0cy5hZnRlcjtcbmV4cG9ydHMuc3VpdGUgPSBleHBvcnRzLmRlc2NyaWJlO1xuZXhwb3J0cy50ZWFyZG93biA9IGV4cG9ydHMuYWZ0ZXJFYWNoO1xuZXhwb3J0cy50ZXN0ID0gZXhwb3J0cy5pdDtcbmV4cG9ydHMucnVuID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGN1cnJlbnRDb250ZXh0LnJ1bi5hcHBseSh0aGlzLCBhcmdzKTtcbn07XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBNb2NoYSBpbnN0YW5jZSB3aXRoIGBvcHRpb25zYC5cbiAqXG4gKiBAcHVibGljXG4gKiBAY2xhc3MgTW9jaGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBTZXR0aW5ncyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFsbG93VW5jYXVnaHRdIC0gUHJvcGFnYXRlIHVuY2F1Z2h0IGVycm9ycz9cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXN5bmNPbmx5XSAtIEZvcmNlIGBkb25lYCBjYWxsYmFjayBvciBwcm9taXNlP1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5iYWlsXSAtIEJhaWwgYWZ0ZXIgZmlyc3QgdGVzdCBmYWlsdXJlP1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGVja0xlYWtzXSAtIENoZWNrIGZvciBnbG9iYWwgdmFyaWFibGUgbGVha3M/XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvbG9yXSAtIENvbG9yIFRUWSBvdXRwdXQgZnJvbSByZXBvcnRlcj9cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVsYXldIC0gRGVsYXkgcm9vdCBzdWl0ZSBleGVjdXRpb24/XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRpZmZdIC0gU2hvdyBkaWZmIG9uIGZhaWx1cmU/XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRyeVJ1bl0gLSBSZXBvcnQgdGVzdHMgd2l0aG91dCBydW5uaW5nIHRoZW0/XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnBhc3NPbkZhaWxpbmdUZXN0U3VpdGVdIC0gRmFpbCB0ZXN0IHJ1biBpZiB0ZXN0cyB3ZXJlIGZhaWxlZD9cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZmFpbFplcm9dIC0gRmFpbCB0ZXN0IHJ1biBpZiB6ZXJvIHRlc3RzP1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZncmVwXSAtIFRlc3QgZmlsdGVyIGdpdmVuIHN0cmluZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZm9yYmlkT25seV0gLSBUZXN0cyBtYXJrZWQgYG9ubHlgIGZhaWwgdGhlIHN1aXRlP1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mb3JiaWRQZW5kaW5nXSAtIFBlbmRpbmcgdGVzdHMgZmFpbCB0aGUgc3VpdGU/XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZ1bGxUcmFjZV0gLSBGdWxsIHN0YWNrdHJhY2UgdXBvbiBmYWlsdXJlP1xuICogQHBhcmFtIHtzdHJpbmdbXX0gW29wdGlvbnMuZ2xvYmFsXSAtIFZhcmlhYmxlcyBleHBlY3RlZCBpbiBnbG9iYWwgc2NvcGUuXG4gKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtvcHRpb25zLmdyZXBdIC0gVGVzdCBmaWx0ZXIgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pbmxpbmVEaWZmc10gLSBEaXNwbGF5IGlubGluZSBkaWZmcz9cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaW52ZXJ0XSAtIEludmVydCB0ZXN0IGZpbHRlciBtYXRjaGVzP1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5ub0hpZ2hsaWdodGluZ10gLSBEaXNhYmxlIHN5bnRheCBoaWdobGlnaHRpbmc/XG4gKiBAcGFyYW0ge3N0cmluZ3xjb25zdHJ1Y3Rvcn0gW29wdGlvbnMucmVwb3J0ZXJdIC0gUmVwb3J0ZXIgbmFtZSBvciBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5yZXBvcnRlck9wdGlvbl0gLSBSZXBvcnRlciBzZXR0aW5ncyBvYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmV0cmllc10gLSBOdW1iZXIgb2YgdGltZXMgdG8gcmV0cnkgZmFpbGVkIHRlc3RzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNsb3ddIC0gU2xvdyB0aHJlc2hvbGQgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRpb25zLnRpbWVvdXRdIC0gVGltZW91dCB0aHJlc2hvbGQgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudWldIC0gSW50ZXJmYWNlIG5hbWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnBhcmFsbGVsXSAtIFJ1biBqb2JzIGluIHBhcmFsbGVsLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmpvYnNdIC0gTWF4IG51bWJlciBvZiB3b3JrZXIgcHJvY2Vzc2VzIGZvciBwYXJhbGxlbCBydW5zLlxuICogQHBhcmFtIHtNb2NoYVJvb3RIb29rT2JqZWN0fSBbb3B0aW9ucy5yb290SG9va3NdIC0gSG9va3MgdG8gYm9vdHN0cmFwIHRoZSByb290IHN1aXRlIHdpdGguXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3B0aW9ucy5yZXF1aXJlXSAtIFBhdGhuYW1lIG9mIGByb290SG9va3NgIHBsdWdpbiBmb3IgcGFyYWxsZWwgcnVucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaXNXb3JrZXJdIC0gU2hvdWxkIGJlIGB0cnVlYCBpZiBgTW9jaGFgIHByb2Nlc3MgaXMgcnVubmluZyBpbiBhIHdvcmtlciBwcm9jZXNzLlxuICovXG5mdW5jdGlvbiBNb2NoYShvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucyA9IHsuLi5tb2NoYXJjLCAuLi5vcHRpb25zfTtcbiAgdGhpcy5maWxlcyA9IFtdO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAvLyByb290IHN1aXRlXG4gIHRoaXMuc3VpdGUgPSBuZXcgZXhwb3J0cy5TdWl0ZSgnJywgbmV3IGV4cG9ydHMuQ29udGV4dCgpLCB0cnVlKTtcbiAgdGhpcy5fY2xlYW5SZWZlcmVuY2VzQWZ0ZXJSdW4gPSB0cnVlO1xuICB0aGlzLl9zdGF0ZSA9IG1vY2hhU3RhdGVzLklOSVQ7XG5cbiAgdGhpcy5ncmVwKG9wdGlvbnMuZ3JlcClcbiAgICAuZmdyZXAob3B0aW9ucy5mZ3JlcClcbiAgICAudWkob3B0aW9ucy51aSlcbiAgICAucmVwb3J0ZXIoXG4gICAgICBvcHRpb25zLnJlcG9ydGVyLFxuICAgICAgb3B0aW9ucy5yZXBvcnRlck9wdGlvbiB8fCBvcHRpb25zLnJlcG9ydGVyT3B0aW9ucyAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICApXG4gICAgLnNsb3cob3B0aW9ucy5zbG93KVxuICAgIC5nbG9iYWwob3B0aW9ucy5nbG9iYWwpO1xuXG4gIC8vIHRoaXMgZ3VhcmQgZXhpc3RzIGJlY2F1c2UgU3VpdGUjdGltZW91dCBkb2VzIG5vdCBjb25zaWRlciBgdW5kZWZpbmVkYCB0byBiZSB2YWxpZCBpbnB1dFxuICBpZiAodHlwZW9mIG9wdGlvbnMudGltZW91dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLnRpbWVvdXQob3B0aW9ucy50aW1lb3V0ID09PSBmYWxzZSA/IDAgOiBvcHRpb25zLnRpbWVvdXQpO1xuICB9XG5cbiAgaWYgKCdyZXRyaWVzJyBpbiBvcHRpb25zKSB7XG4gICAgdGhpcy5yZXRyaWVzKG9wdGlvbnMucmV0cmllcyk7XG4gIH1cblxuICBbXG4gICAgJ2FsbG93VW5jYXVnaHQnLFxuICAgICdhc3luY09ubHknLFxuICAgICdiYWlsJyxcbiAgICAnY2hlY2tMZWFrcycsXG4gICAgJ2NvbG9yJyxcbiAgICAnZGVsYXknLFxuICAgICdkaWZmJyxcbiAgICAnZHJ5UnVuJyxcbiAgICAncGFzc09uRmFpbGluZ1Rlc3RTdWl0ZScsXG4gICAgJ2ZhaWxaZXJvJyxcbiAgICAnZm9yYmlkT25seScsXG4gICAgJ2ZvcmJpZFBlbmRpbmcnLFxuICAgICdmdWxsVHJhY2UnLFxuICAgICdpbmxpbmVEaWZmcycsXG4gICAgJ2ludmVydCdcbiAgXS5mb3JFYWNoKGZ1bmN0aW9uIChvcHQpIHtcbiAgICBpZiAob3B0aW9uc1tvcHRdKSB7XG4gICAgICB0aGlzW29wdF0oKTtcbiAgICB9XG4gIH0sIHRoaXMpO1xuXG4gIGlmIChvcHRpb25zLnJvb3RIb29rcykge1xuICAgIHRoaXMucm9vdEhvb2tzKG9wdGlvbnMucm9vdEhvb2tzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY2xhc3Mgd2hpY2ggd2UnbGwgaW5zdGFudGlhdGUgaW4ge0BsaW5rIE1vY2hhI3J1bn0uICBEZWZhdWx0cyB0b1xuICAgKiB7QGxpbmsgUnVubmVyfSBpbiBzZXJpYWwgbW9kZTsgY2hhbmdlcyBpbiBwYXJhbGxlbCBtb2RlLlxuICAgKiBAbWVtYmVyb2YgTW9jaGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuX3J1bm5lckNsYXNzID0gZXhwb3J0cy5SdW5uZXI7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRvIGNhbGwge0BsaW5rIE1vY2hhI2xvYWRGaWxlc30gaW1wbGljaXRseSB3aGVuIGNhbGxpbmdcbiAgICoge0BsaW5rIE1vY2hhI3J1bn0uICBJZiB0aGlzIGlzIGB0cnVlYCwgdGhlbiBpdCdzIHVwIHRvIHRoZSBjb25zdW1lciB0byBjYWxsXG4gICAqIHtAbGluayBNb2NoYSNsb2FkRmlsZXN9IF9vcl8ge0BsaW5rIE1vY2hhI2xvYWRGaWxlc0FzeW5jfS5cbiAgICogQHByaXZhdGVcbiAgICogQG1lbWJlcm9mIE1vY2hhXG4gICAqL1xuICB0aGlzLl9sYXp5TG9hZEZpbGVzID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEl0J3MgdXNlZnVsIGZvciBhIE1vY2hhIGluc3RhbmNlIHRvIGtub3cgaWYgaXQncyBydW5uaW5nIGluIGEgd29ya2VyIHByb2Nlc3MuXG4gICAqIFdlIGNvdWxkIGRlcml2ZSB0aGlzIHZpYSBvdGhlciBtZWFucywgYnV0IGl0J3MgaGVscGZ1bCB0byBoYXZlIGEgZmxhZyB0byByZWZlciB0by5cbiAgICogQG1lbWJlcm9mIE1vY2hhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmlzV29ya2VyID0gQm9vbGVhbihvcHRpb25zLmlzV29ya2VyKTtcblxuICB0aGlzLmdsb2JhbFNldHVwKG9wdGlvbnMuZ2xvYmFsU2V0dXApXG4gICAgLmdsb2JhbFRlYXJkb3duKG9wdGlvbnMuZ2xvYmFsVGVhcmRvd24pXG4gICAgLmVuYWJsZUdsb2JhbFNldHVwKG9wdGlvbnMuZW5hYmxlR2xvYmFsU2V0dXApXG4gICAgLmVuYWJsZUdsb2JhbFRlYXJkb3duKG9wdGlvbnMuZW5hYmxlR2xvYmFsVGVhcmRvd24pO1xuXG4gIGlmIChcbiAgICBvcHRpb25zLnBhcmFsbGVsICYmXG4gICAgKHR5cGVvZiBvcHRpb25zLmpvYnMgPT09ICd1bmRlZmluZWQnIHx8IG9wdGlvbnMuam9icyA+IDEpXG4gICkge1xuICAgIGRlYnVnKCdhdHRlbXB0aW5nIHRvIGVuYWJsZSBwYXJhbGxlbCBtb2RlJyk7XG4gICAgdGhpcy5wYXJhbGxlbE1vZGUodHJ1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmFibGVzIG9yIGRpc2FibGVzIGJhaWxpbmcgb24gdGhlIGZpcnN0IGZhaWx1cmUuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1iYWlsLWIpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtiYWlsPXRydWVdIC0gV2hldGhlciB0byBiYWlsIG9uIGZpcnN0IGVycm9yLlxuICogQHJldHVybnMge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5iYWlsID0gZnVuY3Rpb24gKGJhaWwpIHtcbiAgdGhpcy5zdWl0ZS5iYWlsKGJhaWwgIT09IGZhbHNlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBzdW1tYXJ5XG4gKiBBZGRzIGBmaWxlYCB0byBiZSBsb2FkZWQgZm9yIGV4ZWN1dGlvbi5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFVzZWZ1bCBmb3IgZ2VuZXJpYyBzZXR1cCBjb2RlIHRoYXQgbXVzdCBiZSBpbmNsdWRlZCB3aXRoaW4gdGVzdCBzdWl0ZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLWZpbGUtZmlsZWRpcmVjdG9yeWdsb2IpXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZSAtIFBhdGhuYW1lIG9mIGZpbGUgdG8gYmUgbG9hZGVkLlxuICogQHJldHVybnMge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5hZGRGaWxlID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgdGhpcy5maWxlcy5wdXNoKGZpbGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyByZXBvcnRlciB0byBgcmVwb3J0ZXJgLCBkZWZhdWx0cyB0byBcInNwZWNcIi5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLXJlcG9ydGVyLW5hbWUtci1uYW1lKVxuICogQHNlZSBbUmVwb3J0ZXJzXSguLi8jcmVwb3J0ZXJzKVxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHJlcG9ydGVyTmFtZSAtIFJlcG9ydGVyIG5hbWUgb3IgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcG9ydGVyT3B0aW9uc10gLSBPcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoZSByZXBvcnRlci5cbiAqIEByZXR1cm5zIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICogQHRocm93cyB7RXJyb3J9IGlmIHJlcXVlc3RlZCByZXBvcnRlciBjYW5ub3QgYmUgbG9hZGVkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFVzZSBYVW5pdCByZXBvcnRlciBhbmQgZGlyZWN0IGl0cyBvdXRwdXQgdG8gZmlsZVxuICogbW9jaGEucmVwb3J0ZXIoJ3h1bml0JywgeyBvdXRwdXQ6ICcvcGF0aC90by90ZXN0c3BlYy54dW5pdC54bWwnIH0pO1xuICovXG5Nb2NoYS5wcm90b3R5cGUucmVwb3J0ZXIgPSBmdW5jdGlvbiAocmVwb3J0ZXJOYW1lLCByZXBvcnRlck9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiByZXBvcnRlck5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9yZXBvcnRlciA9IHJlcG9ydGVyTmFtZTtcbiAgfSBlbHNlIHtcbiAgICByZXBvcnRlck5hbWUgPSByZXBvcnRlck5hbWUgfHwgJ3NwZWMnO1xuICAgIHZhciByZXBvcnRlcjtcbiAgICAvLyBUcnkgdG8gbG9hZCBhIGJ1aWx0LWluIHJlcG9ydGVyLlxuICAgIGlmIChidWlsdGluUmVwb3J0ZXJzW3JlcG9ydGVyTmFtZV0pIHtcbiAgICAgIHJlcG9ydGVyID0gYnVpbHRpblJlcG9ydGVyc1tyZXBvcnRlck5hbWVdO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gbG9hZCByZXBvcnRlcnMgZnJvbSBwcm9jZXNzLmN3ZCgpIGFuZCBub2RlX21vZHVsZXNcbiAgICBpZiAoIXJlcG9ydGVyKSB7XG4gICAgICBsZXQgZm91bmRSZXBvcnRlcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvdW5kUmVwb3J0ZXIgPSByZXF1aXJlLnJlc29sdmUocmVwb3J0ZXJOYW1lKTtcbiAgICAgICAgcmVwb3J0ZXIgPSByZXF1aXJlKGZvdW5kUmVwb3J0ZXIpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChmb3VuZFJlcG9ydGVyKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFJlcG9ydGVyRXJyb3IoZXJyLm1lc3NhZ2UsIGZvdW5kUmVwb3J0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSB0byBsb2FkIHJlcG9ydGVycyBmcm9tIGEgY3dkLXJlbGF0aXZlIHBhdGhcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXBvcnRlciA9IHJlcXVpcmUocGF0aC5yZXNvbHZlKHJlcG9ydGVyTmFtZSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFJlcG9ydGVyRXJyb3IoZS5tZXNzYWdlLCByZXBvcnRlck5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3JlcG9ydGVyID0gcmVwb3J0ZXI7XG4gIH1cbiAgdGhpcy5vcHRpb25zLnJlcG9ydGVyT3B0aW9uID0gcmVwb3J0ZXJPcHRpb25zO1xuICAvLyBhbGlhcyBvcHRpb24gbmFtZSBpcyB1c2VkIGluIGJ1aWx0LWluIHJlcG9ydGVycyB4dW5pdC90YXAvcHJvZ3Jlc3NcbiAgdGhpcy5vcHRpb25zLnJlcG9ydGVyT3B0aW9ucyA9IHJlcG9ydGVyT3B0aW9ucztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGVzdCBVSSBgbmFtZWAsIGRlZmF1bHRzIHRvIFwiYmRkXCIuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy11aS1uYW1lLXUtbmFtZSlcbiAqIEBzZWUgW0ludGVyZmFjZSBEU0xzXSguLi8jaW50ZXJmYWNlcylcbiAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufSBbdWk9YmRkXSAtIEludGVyZmFjZSBuYW1lIG9yIGNsYXNzLlxuICogQHJldHVybnMge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgcmVxdWVzdGVkIGludGVyZmFjZSBjYW5ub3QgYmUgbG9hZGVkXG4gKi9cbk1vY2hhLnByb3RvdHlwZS51aSA9IGZ1bmN0aW9uICh1aSkge1xuICB2YXIgYmluZEludGVyZmFjZTtcbiAgaWYgKHR5cGVvZiB1aSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGJpbmRJbnRlcmZhY2UgPSB1aTtcbiAgfSBlbHNlIHtcbiAgICB1aSA9IHVpIHx8ICdiZGQnO1xuICAgIGJpbmRJbnRlcmZhY2UgPSBleHBvcnRzLmludGVyZmFjZXNbdWldO1xuICAgIGlmICghYmluZEludGVyZmFjZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYmluZEludGVyZmFjZSA9IHJlcXVpcmUodWkpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRJbnRlcmZhY2VFcnJvcihgaW52YWxpZCBpbnRlcmZhY2UgJyR7dWl9J2AsIHVpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYmluZEludGVyZmFjZSh0aGlzLnN1aXRlKTtcblxuICB0aGlzLnN1aXRlLm9uKEVWRU5UX0ZJTEVfUFJFX1JFUVVJUkUsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgY3VycmVudENvbnRleHQgPSBjb250ZXh0O1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTG9hZHMgYGZpbGVzYCBwcmlvciB0byBleGVjdXRpb24uIERvZXMgbm90IHN1cHBvcnQgRVMgTW9kdWxlcy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiByZWxpZXMgb24gTm9kZSdzIGByZXF1aXJlYCB0byBleGVjdXRlXG4gKiB0aGUgdGVzdCBpbnRlcmZhY2UgZnVuY3Rpb25zIGFuZCB3aWxsIGJlIHN1YmplY3QgdG8gaXRzIGNhY2hlLlxuICogU3VwcG9ydHMgb25seSBDb21tb25KUyBtb2R1bGVzLiBUbyBsb2FkIEVTIG1vZHVsZXMsIHVzZSBNb2NoYSNsb2FkRmlsZXNBc3luYy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHNlZSB7QGxpbmsgTW9jaGEjYWRkRmlsZX1cbiAqIEBzZWUge0BsaW5rIE1vY2hhI3J1bn1cbiAqIEBzZWUge0BsaW5rIE1vY2hhI3VubG9hZEZpbGVzfVxuICogQHNlZSB7QGxpbmsgTW9jaGEjbG9hZEZpbGVzQXN5bmN9XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIC0gQ2FsbGJhY2sgaW52b2tlZCB1cG9uIGNvbXBsZXRpb24uXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5sb2FkRmlsZXMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc3VpdGUgPSB0aGlzLnN1aXRlO1xuICB0aGlzLmZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICBmaWxlID0gcGF0aC5yZXNvbHZlKGZpbGUpO1xuICAgIHN1aXRlLmVtaXQoRVZFTlRfRklMRV9QUkVfUkVRVUlSRSwgZ2xvYmFsLCBmaWxlLCBzZWxmKTtcbiAgICBzdWl0ZS5lbWl0KEVWRU5UX0ZJTEVfUkVRVUlSRSwgcmVxdWlyZShmaWxlKSwgZmlsZSwgc2VsZik7XG4gICAgc3VpdGUuZW1pdChFVkVOVF9GSUxFX1BPU1RfUkVRVUlSRSwgZ2xvYmFsLCBmaWxlLCBzZWxmKTtcbiAgfSk7XG4gIGZuICYmIGZuKCk7XG59O1xuXG4vKipcbiAqIExvYWRzIGBmaWxlc2AgcHJpb3IgdG8gZXhlY3V0aW9uLiBTdXBwb3J0cyBOb2RlIEVTIE1vZHVsZXMuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gcmVsaWVzIG9uIE5vZGUncyBgcmVxdWlyZWAgYW5kIGBpbXBvcnRgIHRvIGV4ZWN1dGVcbiAqIHRoZSB0ZXN0IGludGVyZmFjZSBmdW5jdGlvbnMgYW5kIHdpbGwgYmUgc3ViamVjdCB0byBpdHMgY2FjaGUuXG4gKiBTdXBwb3J0cyBib3RoIENKUyBhbmQgRVNNIG1vZHVsZXMuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSB7QGxpbmsgTW9jaGEjYWRkRmlsZX1cbiAqIEBzZWUge0BsaW5rIE1vY2hhI3J1bn1cbiAqIEBzZWUge0BsaW5rIE1vY2hhI3VubG9hZEZpbGVzfVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFNldHRpbmdzIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmVzbURlY29yYXRvcl0gLSBGdW5jdGlvbiBpbnZva2VkIG9uIGVzbSBtb2R1bGUgbmFtZSByaWdodCBiZWZvcmUgaW1wb3J0aW5nIGl0LiBCeSBkZWZhdWx0IHdpbGwgcGFzc3Rocm91Z2ggYXMgaXMuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gbG9hZHMgRVNNIChhbmQgQ0pTKSB0ZXN0IGZpbGVzIGFzeW5jaHJvbm91c2x5LCB0aGVuIHJ1bnMgcm9vdCBzdWl0ZVxuICogbW9jaGEubG9hZEZpbGVzQXN5bmMoKVxuICogICAudGhlbigoKSA9PiBtb2NoYS5ydW4oZmFpbHVyZXMgPT4gcHJvY2Vzcy5leGl0Q29kZSA9IGZhaWx1cmVzID8gMSA6IDApKVxuICogICAuY2F0Y2goKCkgPT4gcHJvY2Vzcy5leGl0Q29kZSA9IDEpO1xuICovXG5Nb2NoYS5wcm90b3R5cGUubG9hZEZpbGVzQXN5bmMgPSBmdW5jdGlvbiAoe2VzbURlY29yYXRvcn0gPSB7fSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzdWl0ZSA9IHRoaXMuc3VpdGU7XG4gIHRoaXMubGF6eUxvYWRGaWxlcyh0cnVlKTtcblxuICByZXR1cm4gZXNtVXRpbHMubG9hZEZpbGVzQXN5bmMoXG4gICAgdGhpcy5maWxlcyxcbiAgICBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgc3VpdGUuZW1pdChFVkVOVF9GSUxFX1BSRV9SRVFVSVJFLCBnbG9iYWwsIGZpbGUsIHNlbGYpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gKGZpbGUsIHJlc3VsdE1vZHVsZSkge1xuICAgICAgc3VpdGUuZW1pdChFVkVOVF9GSUxFX1JFUVVJUkUsIHJlc3VsdE1vZHVsZSwgZmlsZSwgc2VsZik7XG4gICAgICBzdWl0ZS5lbWl0KEVWRU5UX0ZJTEVfUE9TVF9SRVFVSVJFLCBnbG9iYWwsIGZpbGUsIHNlbGYpO1xuICAgIH0sXG4gICAgZXNtRGVjb3JhdG9yXG4gICk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBwcmV2aW91c2x5IGxvYWRlZCBmaWxlIGZyb20gTm9kZSdzIGByZXF1aXJlYCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICogQHNlZSB7QGxpbmsgTW9jaGEjdW5sb2FkRmlsZXN9XG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZSAtIFBhdGhuYW1lIG9mIGZpbGUgdG8gYmUgdW5sb2FkZWQuXG4gKi9cbk1vY2hhLnVubG9hZEZpbGUgPSBmdW5jdGlvbiAoZmlsZSkge1xuICBpZiAodXRpbHMuaXNCcm93c2VyKCkpIHtcbiAgICB0aHJvdyBjcmVhdGVVbnN1cHBvcnRlZEVycm9yKFxuICAgICAgJ3VubG9hZEZpbGUoKSBpcyBvbmx5IHN1cHBvcnRlZCBpbiBhIE5vZGUuanMgZW52aXJvbm1lbnQnXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVxdWlyZSgnLi9ub2RlanMvZmlsZS11bmxvYWRlcicpLnVubG9hZEZpbGUoZmlsZSk7XG59O1xuXG4vKipcbiAqIFVubG9hZHMgYGZpbGVzYCBmcm9tIE5vZGUncyBgcmVxdWlyZWAgY2FjaGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIGFsbG93cyByZXF1aXJlZCBmaWxlcyB0byBiZSBcImZyZXNobHlcIiByZWxvYWRlZCwgcHJvdmlkaW5nIHRoZSBhYmlsaXR5XG4gKiB0byByZXVzZSBhIE1vY2hhIGluc3RhbmNlIHByb2dyYW1tYXRpY2FsbHkuXG4gKiBOb3RlOiBkb2VzIG5vdCBjbGVhciBFU00gbW9kdWxlIGZpbGVzIGZyb20gdGhlIGNhY2hlXG4gKlxuICogPHN0cm9uZz5JbnRlbmRlZCBmb3IgY29uc3VtZXJzICZtZGFzaDsgbm90IHVzZWQgaW50ZXJuYWxseTwvc3Ryb25nPlxuICpcbiAqIEBwdWJsaWNcbiAqIEBzZWUge0BsaW5rIE1vY2hhI3J1bn1cbiAqIEByZXR1cm5zIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICovXG5Nb2NoYS5wcm90b3R5cGUudW5sb2FkRmlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9zdGF0ZSA9PT0gbW9jaGFTdGF0ZXMuRElTUE9TRUQpIHtcbiAgICB0aHJvdyBjcmVhdGVNb2NoYUluc3RhbmNlQWxyZWFkeURpc3Bvc2VkRXJyb3IoXG4gICAgICAnTW9jaGEgaW5zdGFuY2UgaXMgYWxyZWFkeSBkaXNwb3NlZCwgaXQgY2Fubm90IGJlIHVzZWQgYWdhaW4uJyxcbiAgICAgIHRoaXMuX2NsZWFuUmVmZXJlbmNlc0FmdGVyUnVuLFxuICAgICAgdGhpc1xuICAgICk7XG4gIH1cblxuICB0aGlzLmZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICBNb2NoYS51bmxvYWRGaWxlKGZpbGUpO1xuICB9KTtcbiAgdGhpcy5fc3RhdGUgPSBtb2NoYVN0YXRlcy5JTklUO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBgZ3JlcGAgZmlsdGVyIGFmdGVyIGVzY2FwaW5nIFJlZ0V4cCBzcGVjaWFsIGNoYXJhY3RlcnMuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSB7QGxpbmsgTW9jaGEjZ3JlcH1cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBWYWx1ZSB0byBiZSBjb252ZXJ0ZWQgdG8gYSByZWdleHAuXG4gKiBAcmV0dXJucyB7TW9jaGF9IHRoaXNcbiAqIEBjaGFpbmFibGVcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gU2VsZWN0IHRlc3RzIHdob3NlIGZ1bGwgdGl0bGUgYmVnaW5zIHdpdGggYFwiZm9vXCJgIGZvbGxvd2VkIGJ5IGEgcGVyaW9kXG4gKiBtb2NoYS5mZ3JlcCgnZm9vLicpO1xuICovXG5Nb2NoYS5wcm90b3R5cGUuZmdyZXAgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIGlmICghc3RyKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZ3JlcChuZXcgUmVnRXhwKGVzY2FwZVJlKHN0cikpKTtcbn07XG5cbi8qKlxuICogQHN1bW1hcnlcbiAqIFNldHMgYGdyZXBgIGZpbHRlciB1c2VkIHRvIHNlbGVjdCBzcGVjaWZpYyB0ZXN0cyBmb3IgZXhlY3V0aW9uLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSWYgYHJlYCBpcyBhIHJlZ2V4cC1saWtlIHN0cmluZywgaXQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gcmVnZXhwLlxuICogVGhlIHJlZ2V4cCBpcyB0ZXN0ZWQgYWdhaW5zdCB0aGUgZnVsbCB0aXRsZSBvZiBlYWNoIHRlc3QgKGkuZS4sIHRoZVxuICogbmFtZSBvZiB0aGUgdGVzdCBwcmVjZWRlZCBieSB0aXRsZXMgb2YgZWFjaCBpdHMgYW5jZXN0cmFsIHN1aXRlcykuXG4gKiBBcyBzdWNoLCB1c2luZyBhbiA8ZW0+ZXhhY3QtbWF0Y2g8L2VtPiBmaXhlZCBwYXR0ZXJuIGFnYWluc3QgdGhlXG4gKiB0ZXN0IG5hbWUgaXRzZWxmIHdpbGwgbm90IHlpZWxkIGFueSBtYXRjaGVzLlxuICogPGJyPlxuICogPHN0cm9uZz5QcmV2aW91cyBmaWx0ZXIgdmFsdWUgd2lsbCBiZSBvdmVyd3JpdHRlbiBvbiBlYWNoIGNhbGwhPC9zdHJvbmc+XG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1ncmVwLXJlZ2V4cC1nLXJlZ2V4cClcbiAqIEBzZWUge0BsaW5rIE1vY2hhI2ZncmVwfVxuICogQHNlZSB7QGxpbmsgTW9jaGEjaW52ZXJ0fVxuICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSByZSAtIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHNlbGVjdCB0ZXN0cy5cbiAqIEByZXR1cm4ge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFNlbGVjdCB0ZXN0cyB3aG9zZSBmdWxsIHRpdGxlIGNvbnRhaW5zIGBcIm1hdGNoXCJgLCBpZ25vcmluZyBjYXNlXG4gKiBtb2NoYS5ncmVwKC9tYXRjaC9pKTtcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gU2FtZSBhcyBhYm92ZSBidXQgd2l0aCByZWdleHAtbGlrZSBzdHJpbmcgYXJndW1lbnRcbiAqIG1vY2hhLmdyZXAoJy9tYXRjaC9pJyk7XG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vICMjIEFudGktZXhhbXBsZVxuICogLy8gR2l2ZW4gZW1iZWRkZWQgdGVzdCBgaXQoJ29ubHktdGhpcy10ZXN0JylgLi4uXG4gKiBtb2NoYS5ncmVwKCcvXm9ubHktdGhpcy10ZXN0JC8nKTsgICAgLy8gTk8hIFVzZSBgLm9ubHkoKWAgdG8gZG8gdGhpcyFcbiAqL1xuTW9jaGEucHJvdG90eXBlLmdyZXAgPSBmdW5jdGlvbiAocmUpIHtcbiAgaWYgKHV0aWxzLmlzU3RyaW5nKHJlKSkge1xuICAgIC8vIGV4dHJhY3QgYXJncyBpZiBpdCdzIHJlZ2V4LWxpa2UsIGkuZTogW3N0cmluZywgcGF0dGVybiwgZmxhZ11cbiAgICB2YXIgYXJnID0gcmUubWF0Y2goL15cXC8oLiopXFwvKFtnaW15XXswLDR9KSR8LiovKTtcbiAgICB0aGlzLm9wdGlvbnMuZ3JlcCA9IG5ldyBSZWdFeHAoYXJnWzFdIHx8IGFyZ1swXSwgYXJnWzJdKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMuZ3JlcCA9IHJlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGBncmVwYCBtYXRjaGVzLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBzZWUge0BsaW5rIE1vY2hhI2dyZXB9XG4gKiBAcmV0dXJuIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBTZWxlY3QgdGVzdHMgd2hvc2UgZnVsbCB0aXRsZSBkb2VzICpub3QqIGNvbnRhaW4gYFwibWF0Y2hcImAsIGlnbm9yaW5nIGNhc2VcbiAqIG1vY2hhLmdyZXAoL21hdGNoL2kpLmludmVydCgpO1xuICovXG5Nb2NoYS5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm9wdGlvbnMuaW52ZXJ0ID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgY2hlY2tpbmcgZm9yIGdsb2JhbCB2YXJpYWJsZXMgbGVha2VkIHdoaWxlIHJ1bm5pbmcgdGVzdHMuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1jaGVjay1sZWFrcylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NoZWNrTGVha3M9dHJ1ZV0gLSBXaGV0aGVyIHRvIGNoZWNrIGZvciBnbG9iYWwgdmFyaWFibGUgbGVha3MuXG4gKiBAcmV0dXJuIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICovXG5Nb2NoYS5wcm90b3R5cGUuY2hlY2tMZWFrcyA9IGZ1bmN0aW9uIChjaGVja0xlYWtzKSB7XG4gIHRoaXMub3B0aW9ucy5jaGVja0xlYWtzID0gY2hlY2tMZWFrcyAhPT0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbmFibGVzIG9yIGRpc2FibGVzIHdoZXRoZXIgb3Igbm90IHRvIGRpc3Bvc2UgYWZ0ZXIgZWFjaCB0ZXN0IHJ1bi5cbiAqIERpc2FibGUgdGhpcyB0byBlbnN1cmUgeW91IGNhbiBydW4gdGhlIHRlc3Qgc3VpdGUgbXVsdGlwbGUgdGltZXMuXG4gKiBJZiBkaXNhYmxlZCwgYmUgc3VyZSB0byBkaXNwb3NlIG1vY2hhIHdoZW4geW91J3JlIGRvbmUgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuXG4gKiBAcHVibGljXG4gKiBAc2VlIHtAbGluayBNb2NoYSNkaXNwb3NlfVxuICogQHBhcmFtIHtib29sZWFufSBjbGVhblJlZmVyZW5jZXNBZnRlclJ1blxuICogQHJldHVybiB7TW9jaGF9IHRoaXNcbiAqIEBjaGFpbmFibGVcbiAqL1xuTW9jaGEucHJvdG90eXBlLmNsZWFuUmVmZXJlbmNlc0FmdGVyUnVuID0gZnVuY3Rpb24gKGNsZWFuUmVmZXJlbmNlc0FmdGVyUnVuKSB7XG4gIHRoaXMuX2NsZWFuUmVmZXJlbmNlc0FmdGVyUnVuID0gY2xlYW5SZWZlcmVuY2VzQWZ0ZXJSdW4gIT09IGZhbHNlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTWFudWFsbHkgZGlzcG9zZSB0aGlzIG1vY2hhIGluc3RhbmNlLiBNYXJrIHRoaXMgaW5zdGFuY2UgYXMgYGRpc3Bvc2VkYCBhbmQgdW5hYmxlIHRvIHJ1biBtb3JlIHRlc3RzLlxuICogSXQgYWxzbyByZW1vdmVzIGZ1bmN0aW9uIHJlZmVyZW5jZXMgdG8gdGVzdHMgZnVuY3Rpb25zIGFuZCBob29rcywgc28gdmFyaWFibGVzIHRyYXBwZWQgaW4gY2xvc3VyZXMgY2FuIGJlIGNsZWFuZWQgYnkgdGhlIGdhcmJhZ2UgY29sbGVjdG9yLlxuICogQHB1YmxpY1xuICovXG5Nb2NoYS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX3N0YXRlID09PSBtb2NoYVN0YXRlcy5SVU5OSU5HKSB7XG4gICAgdGhyb3cgY3JlYXRlTW9jaGFJbnN0YW5jZUFscmVhZHlSdW5uaW5nRXJyb3IoXG4gICAgICAnQ2Fubm90IGRpc3Bvc2Ugd2hpbGUgdGhlIG1vY2hhIGluc3RhbmNlIGlzIHN0aWxsIHJ1bm5pbmcgdGVzdHMuJ1xuICAgICk7XG4gIH1cbiAgdGhpcy51bmxvYWRGaWxlcygpO1xuICB0aGlzLl9wcmV2aW91c1J1bm5lciAmJiB0aGlzLl9wcmV2aW91c1J1bm5lci5kaXNwb3NlKCk7XG4gIHRoaXMuc3VpdGUuZGlzcG9zZSgpO1xuICB0aGlzLl9zdGF0ZSA9IG1vY2hhU3RhdGVzLkRJU1BPU0VEO1xufTtcblxuLyoqXG4gKiBEaXNwbGF5cyBmdWxsIHN0YWNrIHRyYWNlIHVwb24gdGVzdCBmYWlsdXJlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBzZWUgW0NMSSBvcHRpb25dKC4uLyMtZnVsbC10cmFjZSlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Z1bGxUcmFjZT10cnVlXSAtIFdoZXRoZXIgdG8gcHJpbnQgZnVsbCBzdGFja3RyYWNlIHVwb24gZmFpbHVyZS5cbiAqIEByZXR1cm4ge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5mdWxsVHJhY2UgPSBmdW5jdGlvbiAoZnVsbFRyYWNlKSB7XG4gIHRoaXMub3B0aW9ucy5mdWxsVHJhY2UgPSBmdWxsVHJhY2UgIT09IGZhbHNlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHdoaXRlbGlzdCBvZiB2YXJpYWJsZSBuYW1lcyB0byBiZSBleHBlY3RlZCBpbiBnbG9iYWwgc2NvcGUuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1nbG9iYWwtdmFyaWFibGUtbmFtZSlcbiAqIEBzZWUge0BsaW5rIE1vY2hhI2NoZWNrTGVha3N9XG4gKiBAcGFyYW0ge1N0cmluZ1tdfFN0cmluZ30gZ2xvYmFsIC0gQWNjZXB0ZWQgZ2xvYmFsIHZhcmlhYmxlIG5hbWUocykuXG4gKiBAcmV0dXJuIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBTcGVjaWZ5IHZhcmlhYmxlcyB0byBiZSBleHBlY3RlZCBpbiBnbG9iYWwgc2NvcGVcbiAqIG1vY2hhLmdsb2JhbChbJ2pRdWVyeScsICdNeUxpYiddKTtcbiAqL1xuTW9jaGEucHJvdG90eXBlLmdsb2JhbCA9IGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgdGhpcy5vcHRpb25zLmdsb2JhbCA9ICh0aGlzLm9wdGlvbnMuZ2xvYmFsIHx8IFtdKVxuICAgIC5jb25jYXQoZ2xvYmFsKVxuICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIChlbHQsIGlkeCwgYXJyKSB7XG4gICAgICByZXR1cm4gYXJyLmluZGV4T2YoZWx0KSA9PT0gaWR4O1xuICAgIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG4vLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksICdnbG9iYWxzJyBpcyBhbiBhbGlhcyBvZiAnZ2xvYmFsJ1xuTW9jaGEucHJvdG90eXBlLmdsb2JhbHMgPSBNb2NoYS5wcm90b3R5cGUuZ2xvYmFsO1xuXG4vKipcbiAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgVFRZIGNvbG9yIG91dHB1dCBieSBzY3JlZW4tb3JpZW50ZWQgcmVwb3J0ZXJzLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBzZWUgW0NMSSBvcHRpb25dKC4uLyMtY29sb3ItYy1jb2xvcnMpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtjb2xvcj10cnVlXSAtIFdoZXRoZXIgdG8gZW5hYmxlIGNvbG9yIG91dHB1dC5cbiAqIEByZXR1cm4ge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5jb2xvciA9IGZ1bmN0aW9uIChjb2xvcikge1xuICB0aGlzLm9wdGlvbnMuY29sb3IgPSBjb2xvciAhPT0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbmFibGVzIG9yIGRpc2FibGVzIHJlcG9ydGVyIHRvIHVzZSBpbmxpbmUgZGlmZnMgKHJhdGhlciB0aGFuICsvLSlcbiAqIGluIHRlc3QgZmFpbHVyZSBvdXRwdXQuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1pbmxpbmUtZGlmZnMpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmxpbmVEaWZmcz10cnVlXSAtIFdoZXRoZXIgdG8gdXNlIGlubGluZSBkaWZmcy5cbiAqIEByZXR1cm4ge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5pbmxpbmVEaWZmcyA9IGZ1bmN0aW9uIChpbmxpbmVEaWZmcykge1xuICB0aGlzLm9wdGlvbnMuaW5saW5lRGlmZnMgPSBpbmxpbmVEaWZmcyAhPT0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbmFibGVzIG9yIGRpc2FibGVzIHJlcG9ydGVyIHRvIGluY2x1ZGUgZGlmZiBpbiB0ZXN0IGZhaWx1cmUgb3V0cHV0LlxuICpcbiAqIEBwdWJsaWNcbiAqIEBzZWUgW0NMSSBvcHRpb25dKC4uLyMtZGlmZilcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RpZmY9dHJ1ZV0gLSBXaGV0aGVyIHRvIHNob3cgZGlmZiBvbiBmYWlsdXJlLlxuICogQHJldHVybiB7TW9jaGF9IHRoaXNcbiAqIEBjaGFpbmFibGVcbiAqL1xuTW9jaGEucHJvdG90eXBlLmRpZmYgPSBmdW5jdGlvbiAoZGlmZikge1xuICB0aGlzLm9wdGlvbnMuZGlmZiA9IGRpZmYgIT09IGZhbHNlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHN1bW1hcnlcbiAqIFNldHMgdGltZW91dCB0aHJlc2hvbGQgdmFsdWUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBIHN0cmluZyBhcmd1bWVudCBjYW4gdXNlIHNob3J0aGFuZCAoc3VjaCBhcyBcIjJzXCIpIGFuZCB3aWxsIGJlIGNvbnZlcnRlZC5cbiAqIElmIHRoZSB2YWx1ZSBpcyBgMGAsIHRpbWVvdXRzIHdpbGwgYmUgZGlzYWJsZWQuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy10aW1lb3V0LW1zLXQtbXMpXG4gKiBAc2VlIFtUaW1lb3V0c10oLi4vI3RpbWVvdXRzKVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBtc2VjcyAtIFRpbWVvdXQgdGhyZXNob2xkIHZhbHVlLlxuICogQHJldHVybiB7TW9jaGF9IHRoaXNcbiAqIEBjaGFpbmFibGVcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gU2V0cyB0aW1lb3V0IHRvIG9uZSBzZWNvbmRcbiAqIG1vY2hhLnRpbWVvdXQoMTAwMCk7XG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFNhbWUgYXMgYWJvdmUgYnV0IHVzaW5nIHN0cmluZyBhcmd1bWVudFxuICogbW9jaGEudGltZW91dCgnMXMnKTtcbiAqL1xuTW9jaGEucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAobXNlY3MpIHtcbiAgdGhpcy5zdWl0ZS50aW1lb3V0KG1zZWNzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG51bWJlciBvZiB0aW1lcyB0byByZXRyeSBmYWlsZWQgdGVzdHMuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1yZXRyaWVzLW4pXG4gKiBAc2VlIFtSZXRyeSBUZXN0c10oLi4vI3JldHJ5LXRlc3RzKVxuICogQHBhcmFtIHtudW1iZXJ9IHJldHJ5IC0gTnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5IGZhaWxlZCB0ZXN0cy5cbiAqIEByZXR1cm4ge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEFsbG93IGFueSBmYWlsZWQgdGVzdCB0byByZXRyeSBvbmUgbW9yZSB0aW1lXG4gKiBtb2NoYS5yZXRyaWVzKDEpO1xuICovXG5Nb2NoYS5wcm90b3R5cGUucmV0cmllcyA9IGZ1bmN0aW9uIChyZXRyeSkge1xuICB0aGlzLnN1aXRlLnJldHJpZXMocmV0cnkpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBzbG93bmVzcyB0aHJlc2hvbGQgdmFsdWUuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1zbG93LW1zLXMtbXMpXG4gKiBAcGFyYW0ge251bWJlcn0gbXNlY3MgLSBTbG93bmVzcyB0aHJlc2hvbGQgdmFsdWUuXG4gKiBAcmV0dXJuIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBTZXRzIFwic2xvd1wiIHRocmVzaG9sZCB0byBoYWxmIGEgc2Vjb25kXG4gKiBtb2NoYS5zbG93KDUwMCk7XG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFNhbWUgYXMgYWJvdmUgYnV0IHVzaW5nIHN0cmluZyBhcmd1bWVudFxuICogbW9jaGEuc2xvdygnMC41cycpO1xuICovXG5Nb2NoYS5wcm90b3R5cGUuc2xvdyA9IGZ1bmN0aW9uIChtc2Vjcykge1xuICB0aGlzLnN1aXRlLnNsb3cobXNlY3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRm9yY2VzIGFsbCB0ZXN0cyB0byBlaXRoZXIgYWNjZXB0IGEgYGRvbmVgIGNhbGxiYWNrIG9yIHJldHVybiBhIHByb21pc2UuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1hc3luYy1vbmx5LWEpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthc3luY09ubHk9dHJ1ZV0gLSBXaGV0aGVyIHRvIGZvcmNlIGBkb25lYCBjYWxsYmFjayBvciBwcm9taXNlLlxuICogQHJldHVybiB7TW9jaGF9IHRoaXNcbiAqIEBjaGFpbmFibGVcbiAqL1xuTW9jaGEucHJvdG90eXBlLmFzeW5jT25seSA9IGZ1bmN0aW9uIChhc3luY09ubHkpIHtcbiAgdGhpcy5vcHRpb25zLmFzeW5jT25seSA9IGFzeW5jT25seSAhPT0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlcyBzeW50YXggaGlnaGxpZ2h0aW5nIChpbiBicm93c2VyKS5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJuIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICovXG5Nb2NoYS5wcm90b3R5cGUubm9IaWdobGlnaHRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMub3B0aW9ucy5ub0hpZ2hsaWdodGluZyA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbmFibGVzIG9yIGRpc2FibGVzIHVuY2F1Z2h0IGVycm9ycyB0byBwcm9wYWdhdGUuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1hbGxvdy11bmNhdWdodClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FsbG93VW5jYXVnaHQ9dHJ1ZV0gLSBXaGV0aGVyIHRvIHByb3BhZ2F0ZSB1bmNhdWdodCBlcnJvcnMuXG4gKiBAcmV0dXJuIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICovXG5Nb2NoYS5wcm90b3R5cGUuYWxsb3dVbmNhdWdodCA9IGZ1bmN0aW9uIChhbGxvd1VuY2F1Z2h0KSB7XG4gIHRoaXMub3B0aW9ucy5hbGxvd1VuY2F1Z2h0ID0gYWxsb3dVbmNhdWdodCAhPT0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAc3VtbWFyeVxuICogRGVsYXlzIHJvb3Qgc3VpdGUgZXhlY3V0aW9uLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVXNlZCB0byBwZXJmb3JtIGFzeW5jIG9wZXJhdGlvbnMgYmVmb3JlIGFueSBzdWl0ZXMgYXJlIHJ1bi5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtkZWxheWVkIHJvb3Qgc3VpdGVdKC4uLyNkZWxheWVkLXJvb3Qtc3VpdGUpXG4gKiBAcmV0dXJucyB7TW9jaGF9IHRoaXNcbiAqIEBjaGFpbmFibGVcbiAqL1xuTW9jaGEucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gZGVsYXkoKSB7XG4gIHRoaXMub3B0aW9ucy5kZWxheSA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbmFibGVzIG9yIGRpc2FibGVzIHJ1bm5pbmcgdGVzdHMgaW4gZHJ5LXJ1biBtb2RlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBzZWUgW0NMSSBvcHRpb25dKC4uLyMtZHJ5LXJ1bilcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RyeVJ1bj10cnVlXSAtIFdoZXRoZXIgdG8gYWN0aXZhdGUgZHJ5LXJ1biBtb2RlLlxuICogQHJldHVybiB7TW9jaGF9IHRoaXNcbiAqIEBjaGFpbmFibGVcbiAqL1xuTW9jaGEucHJvdG90eXBlLmRyeVJ1biA9IGZ1bmN0aW9uIChkcnlSdW4pIHtcbiAgdGhpcy5vcHRpb25zLmRyeVJ1biA9IGRyeVJ1biAhPT0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGYWlscyB0ZXN0IHJ1biBpZiBubyB0ZXN0cyBlbmNvdW50ZXJlZCB3aXRoIGV4aXQtY29kZSAxLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBzZWUgW0NMSSBvcHRpb25dKC4uLyMtZmFpbC16ZXJvKVxuICogQHBhcmFtIHtib29sZWFufSBbZmFpbFplcm89dHJ1ZV0gLSBXaGV0aGVyIHRvIGZhaWwgdGVzdCBydW4uXG4gKiBAcmV0dXJuIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICovXG5Nb2NoYS5wcm90b3R5cGUuZmFpbFplcm8gPSBmdW5jdGlvbiAoZmFpbFplcm8pIHtcbiAgdGhpcy5vcHRpb25zLmZhaWxaZXJvID0gZmFpbFplcm8gIT09IGZhbHNlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmFpbCB0ZXN0IHJ1biBpZiB0ZXN0cyB3ZXJlIGZhaWxlZC5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLXBhc3Mtb24tZmFpbGluZy10ZXN0LXN1aXRlKVxuICogQHBhcmFtIHtib29sZWFufSBbcGFzc09uRmFpbGluZ1Rlc3RTdWl0ZT1mYWxzZV0gLSBXaGV0aGVyIHRvIGZhaWwgdGVzdCBydW4uXG4gKiBAcmV0dXJuIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICovXG5Nb2NoYS5wcm90b3R5cGUucGFzc09uRmFpbGluZ1Rlc3RTdWl0ZSA9IGZ1bmN0aW9uKHBhc3NPbkZhaWxpbmdUZXN0U3VpdGUpIHtcbiAgdGhpcy5vcHRpb25zLnBhc3NPbkZhaWxpbmdUZXN0U3VpdGUgPSBwYXNzT25GYWlsaW5nVGVzdFN1aXRlID09PSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2F1c2VzIHRlc3RzIG1hcmtlZCBgb25seWAgdG8gZmFpbCB0aGUgc3VpdGUuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1mb3JiaWQtb25seSlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmJpZE9ubHk9dHJ1ZV0gLSBXaGV0aGVyIHRlc3RzIG1hcmtlZCBgb25seWAgZmFpbCB0aGUgc3VpdGUuXG4gKiBAcmV0dXJucyB7TW9jaGF9IHRoaXNcbiAqIEBjaGFpbmFibGVcbiAqL1xuTW9jaGEucHJvdG90eXBlLmZvcmJpZE9ubHkgPSBmdW5jdGlvbiAoZm9yYmlkT25seSkge1xuICB0aGlzLm9wdGlvbnMuZm9yYmlkT25seSA9IGZvcmJpZE9ubHkgIT09IGZhbHNlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2F1c2VzIHBlbmRpbmcgdGVzdHMgYW5kIHRlc3RzIG1hcmtlZCBgc2tpcGAgdG8gZmFpbCB0aGUgc3VpdGUuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1mb3JiaWQtcGVuZGluZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmJpZFBlbmRpbmc9dHJ1ZV0gLSBXaGV0aGVyIHBlbmRpbmcgdGVzdHMgZmFpbCB0aGUgc3VpdGUuXG4gKiBAcmV0dXJucyB7TW9jaGF9IHRoaXNcbiAqIEBjaGFpbmFibGVcbiAqL1xuTW9jaGEucHJvdG90eXBlLmZvcmJpZFBlbmRpbmcgPSBmdW5jdGlvbiAoZm9yYmlkUGVuZGluZykge1xuICB0aGlzLm9wdGlvbnMuZm9yYmlkUGVuZGluZyA9IGZvcmJpZFBlbmRpbmcgIT09IGZhbHNlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVGhyb3dzIGFuIGVycm9yIGlmIG1vY2hhIGlzIGluIHRoZSB3cm9uZyBzdGF0ZSB0byBiZSBhYmxlIHRvIHRyYW5zaXRpb24gdG8gYSBcInJ1bm5pbmdcIiBzdGF0ZS5cbiAqIEBwcml2YXRlXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5fZ3VhcmRSdW5uaW5nU3RhdGVUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fc3RhdGUgPT09IG1vY2hhU3RhdGVzLlJVTk5JTkcpIHtcbiAgICB0aHJvdyBjcmVhdGVNb2NoYUluc3RhbmNlQWxyZWFkeVJ1bm5pbmdFcnJvcihcbiAgICAgICdNb2NoYSBpbnN0YW5jZSBpcyBjdXJyZW50bHkgcnVubmluZyB0ZXN0cywgY2Fubm90IHN0YXJ0IGEgbmV4dCB0ZXN0IHJ1biB1bnRpbCB0aGlzIG9uZSBpcyBkb25lJyxcbiAgICAgIHRoaXNcbiAgICApO1xuICB9XG4gIGlmIChcbiAgICB0aGlzLl9zdGF0ZSA9PT0gbW9jaGFTdGF0ZXMuRElTUE9TRUQgfHxcbiAgICB0aGlzLl9zdGF0ZSA9PT0gbW9jaGFTdGF0ZXMuUkVGRVJFTkNFU19DTEVBTkVEXG4gICkge1xuICAgIHRocm93IGNyZWF0ZU1vY2hhSW5zdGFuY2VBbHJlYWR5RGlzcG9zZWRFcnJvcihcbiAgICAgICdNb2NoYSBpbnN0YW5jZSBpcyBhbHJlYWR5IGRpc3Bvc2VkLCBjYW5ub3Qgc3RhcnQgYSBuZXcgdGVzdCBydW4uIFBsZWFzZSBjcmVhdGUgYSBuZXcgbW9jaGEgaW5zdGFuY2UuIEJlIHN1cmUgdG8gc2V0IGRpc2FibGUgYGNsZWFuUmVmZXJlbmNlc0FmdGVyUnVuYCB3aGVuIHlvdSB3YW50IHRvIHJldXNlIHRoZSBzYW1lIG1vY2hhIGluc3RhbmNlIGZvciBtdWx0aXBsZSB0ZXN0IHJ1bnMuJyxcbiAgICAgIHRoaXMuX2NsZWFuUmVmZXJlbmNlc0FmdGVyUnVuLFxuICAgICAgdGhpc1xuICAgICk7XG4gIH1cbn07XG5cbi8qKlxuICogTW9jaGEgdmVyc2lvbiBhcyBzcGVjaWZpZWQgYnkgXCJwYWNrYWdlLmpzb25cIi5cbiAqXG4gKiBAbmFtZSBNb2NoYSN2ZXJzaW9uXG4gKiBAdHlwZSBzdHJpbmdcbiAqIEByZWFkb25seVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTW9jaGEucHJvdG90eXBlLCAndmVyc2lvbicsIHtcbiAgdmFsdWU6IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb24sXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiBmYWxzZVxufSk7XG5cbi8qKlxuICogQ2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIHRlc3QgZXhlY3V0aW9uIGlzIGNvbXBsZXRlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2FsbGJhY2sgRG9uZUNCXG4gKiBAcGFyYW0ge251bWJlcn0gZmFpbHVyZXMgLSBOdW1iZXIgb2YgZmFpbHVyZXMgdGhhdCBvY2N1cnJlZC5cbiAqL1xuXG4vKipcbiAqIFJ1bnMgcm9vdCBzdWl0ZSBhbmQgaW52b2tlcyBgZm4oKWAgd2hlbiBjb21wbGV0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRvIHJ1biB0ZXN0cyBtdWx0aXBsZSB0aW1lcyAob3IgdG8gcnVuIHRlc3RzIGluIGZpbGVzIHRoYXQgYXJlXG4gKiBhbHJlYWR5IGluIHRoZSBgcmVxdWlyZWAgY2FjaGUpLCBtYWtlIHN1cmUgdG8gY2xlYXIgdGhlbSBmcm9tXG4gKiB0aGUgY2FjaGUgZmlyc3QhXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSB7QGxpbmsgTW9jaGEjdW5sb2FkRmlsZXN9XG4gKiBAc2VlIHtAbGluayBSdW5uZXIjcnVufVxuICogQHBhcmFtIHtEb25lQ0J9IFtmbl0gLSBDYWxsYmFjayBpbnZva2VkIHdoZW4gdGVzdCBleGVjdXRpb24gY29tcGxldGVkLlxuICogQHJldHVybnMge1J1bm5lcn0gcnVubmVyIGluc3RhbmNlXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGV4aXQgd2l0aCBub24temVybyBzdGF0dXMgaWYgdGhlcmUgd2VyZSB0ZXN0IGZhaWx1cmVzXG4gKiBtb2NoYS5ydW4oZmFpbHVyZXMgPT4gcHJvY2Vzcy5leGl0Q29kZSA9IGZhaWx1cmVzID8gMSA6IDApO1xuICovXG5Nb2NoYS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKGZuKSB7XG4gIHRoaXMuX2d1YXJkUnVubmluZ1N0YXRlVHJhbnNpdGlvbigpO1xuICB0aGlzLl9zdGF0ZSA9IG1vY2hhU3RhdGVzLlJVTk5JTkc7XG4gIGlmICh0aGlzLl9wcmV2aW91c1J1bm5lcikge1xuICAgIHRoaXMuX3ByZXZpb3VzUnVubmVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLnN1aXRlLnJlc2V0KCk7XG4gIH1cbiAgaWYgKHRoaXMuZmlsZXMubGVuZ3RoICYmICF0aGlzLl9sYXp5TG9hZEZpbGVzKSB7XG4gICAgdGhpcy5sb2FkRmlsZXMoKTtcbiAgfVxuICB2YXIgc3VpdGUgPSB0aGlzLnN1aXRlO1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgb3B0aW9ucy5maWxlcyA9IHRoaXMuZmlsZXM7XG4gIGNvbnN0IHJ1bm5lciA9IG5ldyB0aGlzLl9ydW5uZXJDbGFzcyhzdWl0ZSwge1xuICAgIGNsZWFuUmVmZXJlbmNlc0FmdGVyUnVuOiB0aGlzLl9jbGVhblJlZmVyZW5jZXNBZnRlclJ1bixcbiAgICBkZWxheTogb3B0aW9ucy5kZWxheSxcbiAgICBkcnlSdW46IG9wdGlvbnMuZHJ5UnVuLFxuICAgIGZhaWxaZXJvOiBvcHRpb25zLmZhaWxaZXJvXG4gIH0pO1xuICBjcmVhdGVTdGF0c0NvbGxlY3RvcihydW5uZXIpO1xuICB2YXIgcmVwb3J0ZXIgPSBuZXcgdGhpcy5fcmVwb3J0ZXIocnVubmVyLCBvcHRpb25zKTtcbiAgcnVubmVyLmNoZWNrTGVha3MgPSBvcHRpb25zLmNoZWNrTGVha3MgPT09IHRydWU7XG4gIHJ1bm5lci5mdWxsU3RhY2tUcmFjZSA9IG9wdGlvbnMuZnVsbFRyYWNlO1xuICBydW5uZXIuYXN5bmNPbmx5ID0gb3B0aW9ucy5hc3luY09ubHk7XG4gIHJ1bm5lci5hbGxvd1VuY2F1Z2h0ID0gb3B0aW9ucy5hbGxvd1VuY2F1Z2h0O1xuICBydW5uZXIuZm9yYmlkT25seSA9IG9wdGlvbnMuZm9yYmlkT25seTtcbiAgcnVubmVyLmZvcmJpZFBlbmRpbmcgPSBvcHRpb25zLmZvcmJpZFBlbmRpbmc7XG4gIGlmIChvcHRpb25zLmdyZXApIHtcbiAgICBydW5uZXIuZ3JlcChvcHRpb25zLmdyZXAsIG9wdGlvbnMuaW52ZXJ0KTtcbiAgfVxuICBpZiAob3B0aW9ucy5nbG9iYWwpIHtcbiAgICBydW5uZXIuZ2xvYmFscyhvcHRpb25zLmdsb2JhbCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgIGV4cG9ydHMucmVwb3J0ZXJzLkJhc2UudXNlQ29sb3JzID0gb3B0aW9ucy5jb2xvcjtcbiAgfVxuICBleHBvcnRzLnJlcG9ydGVycy5CYXNlLmlubGluZURpZmZzID0gb3B0aW9ucy5pbmxpbmVEaWZmcztcbiAgZXhwb3J0cy5yZXBvcnRlcnMuQmFzZS5oaWRlRGlmZiA9ICFvcHRpb25zLmRpZmY7XG5cbiAgY29uc3QgZG9uZSA9IGZhaWx1cmVzID0+IHtcbiAgICB0aGlzLl9wcmV2aW91c1J1bm5lciA9IHJ1bm5lcjtcbiAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuX2NsZWFuUmVmZXJlbmNlc0FmdGVyUnVuXG4gICAgICA/IG1vY2hhU3RhdGVzLlJFRkVSRU5DRVNfQ0xFQU5FRFxuICAgICAgOiBtb2NoYVN0YXRlcy5JTklUO1xuICAgIGZuID0gZm4gfHwgdXRpbHMubm9vcDtcbiAgICBpZiAodHlwZW9mIHJlcG9ydGVyLmRvbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcG9ydGVyLmRvbmUoZmFpbHVyZXMsIGZuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm4oZmFpbHVyZXMpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBydW5Bc3luYyA9IGFzeW5jIHJ1bm5lciA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9XG4gICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlR2xvYmFsU2V0dXAgJiYgdGhpcy5oYXNHbG9iYWxTZXR1cEZpeHR1cmVzKClcbiAgICAgICAgPyBhd2FpdCB0aGlzLnJ1bkdsb2JhbFNldHVwKHJ1bm5lcilcbiAgICAgICAgOiB7fTtcbiAgICBjb25zdCBmYWlsdXJlQ291bnQgPSBhd2FpdCBydW5uZXIucnVuQXN5bmMoe1xuICAgICAgZmlsZXM6IHRoaXMuZmlsZXMsXG4gICAgICBvcHRpb25zXG4gICAgfSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVHbG9iYWxUZWFyZG93biAmJiB0aGlzLmhhc0dsb2JhbFRlYXJkb3duRml4dHVyZXMoKSkge1xuICAgICAgYXdhaXQgdGhpcy5ydW5HbG9iYWxUZWFyZG93bihydW5uZXIsIHtjb250ZXh0fSk7XG4gICAgfVxuICAgIHJldHVybiBmYWlsdXJlQ291bnQ7XG4gIH07XG5cbiAgLy8gbm8gXCJjYXRjaFwiIGhlcmUgaXMgaW50ZW50aW9uYWwuIGVycm9ycyBjb21pbmcgb3V0IG9mXG4gIC8vIFJ1bm5lciNydW4gYXJlIGNvbnNpZGVyZWQgdW5jYXVnaHQvdW5oYW5kbGVkIGFuZCBjYXVnaHRcbiAgLy8gYnkgdGhlIGBwcm9jZXNzYCBldmVudCBsaXN0ZW5lcnMuXG4gIC8vIGFsc286IHJldHVybmluZyBhbnl0aGluZyBvdGhlciB0aGFuIGBydW5uZXJgIHdvdWxkIGJlIGEgYnJlYWtpbmdcbiAgLy8gY2hhbmdlXG4gIHJ1bkFzeW5jKHJ1bm5lcikudGhlbihkb25lKTtcblxuICByZXR1cm4gcnVubmVyO1xufTtcblxuLyoqXG4gKiBBc3NpZ25zIGhvb2tzIHRvIHRoZSByb290IHN1aXRlXG4gKiBAcGFyYW0ge01vY2hhUm9vdEhvb2tPYmplY3R9IFtob29rc10gLSBIb29rcyB0byBhc3NpZ24gdG8gcm9vdCBzdWl0ZVxuICogQGNoYWluYWJsZVxuICovXG5Nb2NoYS5wcm90b3R5cGUucm9vdEhvb2tzID0gZnVuY3Rpb24gcm9vdEhvb2tzKHtcbiAgYmVmb3JlQWxsID0gW10sXG4gIGJlZm9yZUVhY2ggPSBbXSxcbiAgYWZ0ZXJBbGwgPSBbXSxcbiAgYWZ0ZXJFYWNoID0gW11cbn0gPSB7fSkge1xuICBiZWZvcmVBbGwgPSB1dGlscy5jYXN0QXJyYXkoYmVmb3JlQWxsKTtcbiAgYmVmb3JlRWFjaCA9IHV0aWxzLmNhc3RBcnJheShiZWZvcmVFYWNoKTtcbiAgYWZ0ZXJBbGwgPSB1dGlscy5jYXN0QXJyYXkoYWZ0ZXJBbGwpO1xuICBhZnRlckVhY2ggPSB1dGlscy5jYXN0QXJyYXkoYWZ0ZXJFYWNoKTtcbiAgYmVmb3JlQWxsLmZvckVhY2goaG9vayA9PiB7XG4gICAgdGhpcy5zdWl0ZS5iZWZvcmVBbGwoaG9vayk7XG4gIH0pO1xuICBiZWZvcmVFYWNoLmZvckVhY2goaG9vayA9PiB7XG4gICAgdGhpcy5zdWl0ZS5iZWZvcmVFYWNoKGhvb2spO1xuICB9KTtcbiAgYWZ0ZXJBbGwuZm9yRWFjaChob29rID0+IHtcbiAgICB0aGlzLnN1aXRlLmFmdGVyQWxsKGhvb2spO1xuICB9KTtcbiAgYWZ0ZXJFYWNoLmZvckVhY2goaG9vayA9PiB7XG4gICAgdGhpcy5zdWl0ZS5hZnRlckVhY2goaG9vayk7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVG9nZ2xlcyBwYXJhbGxlbCBtb2RlLlxuICpcbiAqIE11c3QgYmUgcnVuIGJlZm9yZSBjYWxsaW5nIHtAbGluayBNb2NoYSNydW59LiBDaGFuZ2VzIHRoZSBgUnVubmVyYCBjbGFzcyB0b1xuICogdXNlOyBhbHNvIGVuYWJsZXMgbGF6eSBmaWxlIGxvYWRpbmcgaWYgbm90IGFscmVhZHkgZG9uZSBzby5cbiAqXG4gKiBXYXJuaW5nOiB3aGVuIHBhc3NlZCBgZmFsc2VgIGFuZCBsYXp5IGxvYWRpbmcgaGFzIGJlZW4gZW5hYmxlZCBfdmlhIGFueSBtZWFuc18gKGluY2x1ZGluZyBjYWxsaW5nIGBwYXJhbGxlbE1vZGUodHJ1ZSlgKSwgdGhpcyBtZXRob2Qgd2lsbCBfbm90XyBkaXNhYmxlIGxhenkgbG9hZGluZy4gTGF6eSBsb2FkaW5nIGlzIGEgcHJlcmVxdWlzaXRlIGZvciBwYXJhbGxlbFxuICogbW9kZSwgYnV0IHBhcmFsbGVsIG1vZGUgaXMgX25vdF8gYSBwcmVyZXF1aXNpdGUgZm9yIGxhenkgbG9hZGluZyFcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuYWJsZV0gLSBJZiBgdHJ1ZWAsIGVuYWJsZTsgb3RoZXJ3aXNlIGRpc2FibGUuXG4gKiBAdGhyb3dzIElmIHJ1biBpbiBicm93c2VyXG4gKiBAdGhyb3dzIElmIE1vY2hhIG5vdCBpbiBgSU5JVGAgc3RhdGVcbiAqIEByZXR1cm5zIHtNb2NoYX1cbiAqIEBjaGFpbmFibGVcbiAqIEBwdWJsaWNcbiAqL1xuTW9jaGEucHJvdG90eXBlLnBhcmFsbGVsTW9kZSA9IGZ1bmN0aW9uIHBhcmFsbGVsTW9kZShlbmFibGUgPSB0cnVlKSB7XG4gIGlmICh1dGlscy5pc0Jyb3dzZXIoKSkge1xuICAgIHRocm93IGNyZWF0ZVVuc3VwcG9ydGVkRXJyb3IoJ3BhcmFsbGVsIG1vZGUgaXMgb25seSBzdXBwb3J0ZWQgaW4gTm9kZS5qcycpO1xuICB9XG4gIGNvbnN0IHBhcmFsbGVsID0gQm9vbGVhbihlbmFibGUpO1xuICBpZiAoXG4gICAgcGFyYWxsZWwgPT09IHRoaXMub3B0aW9ucy5wYXJhbGxlbCAmJlxuICAgIHRoaXMuX2xhenlMb2FkRmlsZXMgJiZcbiAgICB0aGlzLl9ydW5uZXJDbGFzcyAhPT0gZXhwb3J0cy5SdW5uZXJcbiAgKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKHRoaXMuX3N0YXRlICE9PSBtb2NoYVN0YXRlcy5JTklUKSB7XG4gICAgdGhyb3cgY3JlYXRlVW5zdXBwb3J0ZWRFcnJvcihcbiAgICAgICdjYW5ub3QgY2hhbmdlIHBhcmFsbGVsIG1vZGUgYWZ0ZXIgaGF2aW5nIGNhbGxlZCBydW4oKSdcbiAgICApO1xuICB9XG4gIHRoaXMub3B0aW9ucy5wYXJhbGxlbCA9IHBhcmFsbGVsO1xuXG4gIC8vIHN3YXAgUnVubmVyIGNsYXNzXG4gIHRoaXMuX3J1bm5lckNsYXNzID0gcGFyYWxsZWxcbiAgICA/IHJlcXVpcmUoJy4vbm9kZWpzL3BhcmFsbGVsLWJ1ZmZlcmVkLXJ1bm5lcicpXG4gICAgOiBleHBvcnRzLlJ1bm5lcjtcblxuICAvLyBsYXp5TG9hZEZpbGVzIG1heSBoYXZlIGJlZW4gc2V0IGB0cnVlYCBvdGhlcndpc2UgKGZvciBFU00gbG9hZGluZyksXG4gIC8vIHNvIGtlZXAgYHRydWVgIGlmIHNvLlxuICByZXR1cm4gdGhpcy5sYXp5TG9hZEZpbGVzKHRoaXMuX2xhenlMb2FkRmlsZXMgfHwgcGFyYWxsZWwpO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlcyBpbXBsaWNpdCBjYWxsIHRvIHtAbGluayBNb2NoYSNsb2FkRmlsZXN9IGluIHtAbGluayBNb2NoYSNydW59LiBUaGlzXG4gKiBzZXR0aW5nIGlzIHVzZWQgYnkgd2F0Y2ggbW9kZSwgcGFyYWxsZWwgbW9kZSwgYW5kIGZvciBsb2FkaW5nIEVTTSBmaWxlcy5cbiAqIEB0b2RvIFRoaXMgc2hvdWxkIHRocm93IGlmIHdlJ3ZlIGFscmVhZHkgbG9hZGVkIGZpbGVzOyBzdWNoIGJlaGF2aW9yXG4gKiBuZWNlc3NpdGF0ZXMgYWRkaW5nIGEgbmV3IHN0YXRlLlxuICogQHBhcmFtIHtib29sZWFufSBbZW5hYmxlXSAtIElmIGB0cnVlYCwgZGlzYWJsZSBlYWdlciBsb2FkaW5nIG9mIGZpbGVzIGluXG4gKiB7QGxpbmsgTW9jaGEjcnVufVxuICogQGNoYWluYWJsZVxuICogQHB1YmxpY1xuICovXG5Nb2NoYS5wcm90b3R5cGUubGF6eUxvYWRGaWxlcyA9IGZ1bmN0aW9uIGxhenlMb2FkRmlsZXMoZW5hYmxlKSB7XG4gIHRoaXMuX2xhenlMb2FkRmlsZXMgPSBlbmFibGUgPT09IHRydWU7XG4gIGRlYnVnKCdzZXQgbGF6eSBsb2FkIHRvICVzJywgZW5hYmxlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbmZpZ3VyZXMgb25lIG9yIG1vcmUgZ2xvYmFsIHNldHVwIGZpeHR1cmVzLlxuICpcbiAqIElmIGdpdmVuIG5vIHBhcmFtZXRlcnMsIF91bnNldHNfIGFueSBwcmV2aW91c2x5LXNldCBmaXh0dXJlcy5cbiAqIEBjaGFpbmFibGVcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7TW9jaGFHbG9iYWxGaXh0dXJlfE1vY2hhR2xvYmFsRml4dHVyZVtdfSBbc2V0dXBGbnNdIC0gR2xvYmFsIHNldHVwIGZpeHR1cmUocylcbiAqIEByZXR1cm5zIHtNb2NoYX1cbiAqL1xuTW9jaGEucHJvdG90eXBlLmdsb2JhbFNldHVwID0gZnVuY3Rpb24gZ2xvYmFsU2V0dXAoc2V0dXBGbnMgPSBbXSkge1xuICBzZXR1cEZucyA9IHV0aWxzLmNhc3RBcnJheShzZXR1cEZucyk7XG4gIHRoaXMub3B0aW9ucy5nbG9iYWxTZXR1cCA9IHNldHVwRm5zO1xuICBkZWJ1ZygnY29uZmlndXJlZCAlZCBnbG9iYWwgc2V0dXAgZnVuY3Rpb25zJywgc2V0dXBGbnMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbmZpZ3VyZXMgb25lIG9yIG1vcmUgZ2xvYmFsIHRlYXJkb3duIGZpeHR1cmVzLlxuICpcbiAqIElmIGdpdmVuIG5vIHBhcmFtZXRlcnMsIF91bnNldHNfIGFueSBwcmV2aW91c2x5LXNldCBmaXh0dXJlcy5cbiAqIEBjaGFpbmFibGVcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7TW9jaGFHbG9iYWxGaXh0dXJlfE1vY2hhR2xvYmFsRml4dHVyZVtdfSBbdGVhcmRvd25GbnNdIC0gR2xvYmFsIHRlYXJkb3duIGZpeHR1cmUocylcbiAqIEByZXR1cm5zIHtNb2NoYX1cbiAqL1xuTW9jaGEucHJvdG90eXBlLmdsb2JhbFRlYXJkb3duID0gZnVuY3Rpb24gZ2xvYmFsVGVhcmRvd24odGVhcmRvd25GbnMgPSBbXSkge1xuICB0ZWFyZG93bkZucyA9IHV0aWxzLmNhc3RBcnJheSh0ZWFyZG93bkZucyk7XG4gIHRoaXMub3B0aW9ucy5nbG9iYWxUZWFyZG93biA9IHRlYXJkb3duRm5zO1xuICBkZWJ1ZygnY29uZmlndXJlZCAlZCBnbG9iYWwgdGVhcmRvd24gZnVuY3Rpb25zJywgdGVhcmRvd25GbnMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJ1biBhbnkgZ2xvYmFsIHNldHVwIGZpeHR1cmVzIHNlcXVlbnRpYWxseSwgaWYgYW55LlxuICpcbiAqIFRoaXMgaXMgX2F1dG9tYXRpY2FsbHkgY2FsbGVkXyBieSB7QGxpbmsgTW9jaGEjcnVufSBfdW5sZXNzXyB0aGUgYHJ1bkdsb2JhbFNldHVwYCBvcHRpb24gaXMgYGZhbHNlYDsgc2VlIHtAbGluayBNb2NoYSNlbmFibGVHbG9iYWxTZXR1cH0uXG4gKlxuICogVGhlIGNvbnRleHQgb2JqZWN0IHRoaXMgZnVuY3Rpb24gcmVzb2x2ZXMgd2l0aCBzaG91bGQgYmUgY29uc3VtZWQgYnkge0BsaW5rIE1vY2hhI3J1bkdsb2JhbFRlYXJkb3dufS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBDb250ZXh0IG9iamVjdCBpZiBhbHJlYWR5IGhhdmUgb25lXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBDb250ZXh0IG9iamVjdFxuICovXG5Nb2NoYS5wcm90b3R5cGUucnVuR2xvYmFsU2V0dXAgPSBhc3luYyBmdW5jdGlvbiBydW5HbG9iYWxTZXR1cChjb250ZXh0ID0ge30pIHtcbiAgY29uc3Qge2dsb2JhbFNldHVwfSA9IHRoaXMub3B0aW9ucztcbiAgaWYgKGdsb2JhbFNldHVwICYmIGdsb2JhbFNldHVwLmxlbmd0aCkge1xuICAgIGRlYnVnKCdydW4oKTogZ2xvYmFsIHNldHVwIHN0YXJ0aW5nJyk7XG4gICAgYXdhaXQgdGhpcy5fcnVuR2xvYmFsRml4dHVyZXMoZ2xvYmFsU2V0dXAsIGNvbnRleHQpO1xuICAgIGRlYnVnKCdydW4oKTogZ2xvYmFsIHNldHVwIGNvbXBsZXRlJyk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG4vKipcbiAqIFJ1biBhbnkgZ2xvYmFsIHRlYXJkb3duIGZpeHR1cmVzIHNlcXVlbnRpYWxseSwgaWYgYW55LlxuICpcbiAqIFRoaXMgaXMgX2F1dG9tYXRpY2FsbHkgY2FsbGVkXyBieSB7QGxpbmsgTW9jaGEjcnVufSBfdW5sZXNzXyB0aGUgYHJ1bkdsb2JhbFRlYXJkb3duYCBvcHRpb24gaXMgYGZhbHNlYDsgc2VlIHtAbGluayBNb2NoYSNlbmFibGVHbG9iYWxUZWFyZG93bn0uXG4gKlxuICogU2hvdWxkIGJlIGNhbGxlZCB3aXRoIGNvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IHtAbGluayBNb2NoYSNydW5HbG9iYWxTZXR1cH0sIGlmIGFwcGxpY2FibGUuXG4gKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdIC0gQ29udGV4dCBvYmplY3QgaWYgYWxyZWFkeSBoYXZlIG9uZVxuICogQHB1YmxpY1xuICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gQ29udGV4dCBvYmplY3RcbiAqL1xuTW9jaGEucHJvdG90eXBlLnJ1bkdsb2JhbFRlYXJkb3duID0gYXN5bmMgZnVuY3Rpb24gcnVuR2xvYmFsVGVhcmRvd24oXG4gIGNvbnRleHQgPSB7fVxuKSB7XG4gIGNvbnN0IHtnbG9iYWxUZWFyZG93bn0gPSB0aGlzLm9wdGlvbnM7XG4gIGlmIChnbG9iYWxUZWFyZG93biAmJiBnbG9iYWxUZWFyZG93bi5sZW5ndGgpIHtcbiAgICBkZWJ1ZygncnVuKCk6IGdsb2JhbCB0ZWFyZG93biBzdGFydGluZycpO1xuICAgIGF3YWl0IHRoaXMuX3J1bkdsb2JhbEZpeHR1cmVzKGdsb2JhbFRlYXJkb3duLCBjb250ZXh0KTtcbiAgfVxuICBkZWJ1ZygncnVuKCk6IGdsb2JhbCB0ZWFyZG93biBjb21wbGV0ZScpO1xuICByZXR1cm4gY29udGV4dDtcbn07XG5cbi8qKlxuICogUnVuIGdsb2JhbCBmaXh0dXJlcyBzZXF1ZW50aWFsbHkgd2l0aCBjb250ZXh0IGBjb250ZXh0YFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TW9jaGFHbG9iYWxGaXh0dXJlW119IFtmaXh0dXJlRm5zXSAtIEZpeHR1cmVzIHRvIHJ1blxuICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSAtIGNvbnRleHQgb2JqZWN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBjb250ZXh0IG9iamVjdFxuICovXG5Nb2NoYS5wcm90b3R5cGUuX3J1bkdsb2JhbEZpeHR1cmVzID0gYXN5bmMgZnVuY3Rpb24gX3J1bkdsb2JhbEZpeHR1cmVzKFxuICBmaXh0dXJlRm5zID0gW10sXG4gIGNvbnRleHQgPSB7fVxuKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgZml4dHVyZUZuIG9mIGZpeHR1cmVGbnMpIHtcbiAgICBhd2FpdCBmaXh0dXJlRm4uY2FsbChjb250ZXh0KTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn07XG5cbi8qKlxuICogVG9nZ2xlIGV4ZWN1dGlvbiBvZiBhbnkgZ2xvYmFsIHNldHVwIGZpeHR1cmUocylcbiAqXG4gKiBAY2hhaW5hYmxlXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfSBbZW5hYmxlZD10cnVlXSAtIElmIGBmYWxzZWAsIGRvIG5vdCBydW4gZ2xvYmFsIHNldHVwIGZpeHR1cmVcbiAqIEByZXR1cm5zIHtNb2NoYX1cbiAqL1xuTW9jaGEucHJvdG90eXBlLmVuYWJsZUdsb2JhbFNldHVwID0gZnVuY3Rpb24gZW5hYmxlR2xvYmFsU2V0dXAoZW5hYmxlZCA9IHRydWUpIHtcbiAgdGhpcy5vcHRpb25zLmVuYWJsZUdsb2JhbFNldHVwID0gQm9vbGVhbihlbmFibGVkKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRvZ2dsZSBleGVjdXRpb24gb2YgYW55IGdsb2JhbCB0ZWFyZG93biBmaXh0dXJlKHMpXG4gKlxuICogQGNoYWluYWJsZVxuICogQHB1YmxpY1xuICogQHBhcmFtIHtib29sZWFuIH0gW2VuYWJsZWQ9dHJ1ZV0gLSBJZiBgZmFsc2VgLCBkbyBub3QgcnVuIGdsb2JhbCB0ZWFyZG93biBmaXh0dXJlXG4gKiBAcmV0dXJucyB7TW9jaGF9XG4gKi9cbk1vY2hhLnByb3RvdHlwZS5lbmFibGVHbG9iYWxUZWFyZG93biA9IGZ1bmN0aW9uIGVuYWJsZUdsb2JhbFRlYXJkb3duKFxuICBlbmFibGVkID0gdHJ1ZVxuKSB7XG4gIHRoaXMub3B0aW9ucy5lbmFibGVHbG9iYWxUZWFyZG93biA9IEJvb2xlYW4oZW5hYmxlZCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBvbmUgb3IgbW9yZSBnbG9iYWwgc2V0dXAgZml4dHVyZXMgaGF2ZSBiZWVuIHN1cHBsaWVkLlxuICogQHB1YmxpY1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbk1vY2hhLnByb3RvdHlwZS5oYXNHbG9iYWxTZXR1cEZpeHR1cmVzID0gZnVuY3Rpb24gaGFzR2xvYmFsU2V0dXBGaXh0dXJlcygpIHtcbiAgcmV0dXJuIEJvb2xlYW4odGhpcy5vcHRpb25zLmdsb2JhbFNldHVwLmxlbmd0aCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIG9uZSBvciBtb3JlIGdsb2JhbCB0ZWFyZG93biBmaXh0dXJlcyBoYXZlIGJlZW4gc3VwcGxpZWQuXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTW9jaGEucHJvdG90eXBlLmhhc0dsb2JhbFRlYXJkb3duRml4dHVyZXMgPVxuICBmdW5jdGlvbiBoYXNHbG9iYWxUZWFyZG93bkZpeHR1cmVzKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMub3B0aW9ucy5nbG9iYWxUZWFyZG93bi5sZW5ndGgpO1xuICB9O1xuXG4vKipcbiAqIEFuIGFsdGVybmF0aXZlIHdheSB0byBkZWZpbmUgcm9vdCBob29rcyB0aGF0IHdvcmtzIHdpdGggcGFyYWxsZWwgcnVucy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1vY2hhUm9vdEhvb2tPYmplY3RcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb258RnVuY3Rpb25bXX0gW2JlZm9yZUFsbF0gLSBcIkJlZm9yZSBhbGxcIiBob29rKHMpXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufEZ1bmN0aW9uW119IFtiZWZvcmVFYWNoXSAtIFwiQmVmb3JlIGVhY2hcIiBob29rKHMpXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufEZ1bmN0aW9uW119IFthZnRlckFsbF0gLSBcIkFmdGVyIGFsbFwiIGhvb2socylcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb258RnVuY3Rpb25bXX0gW2FmdGVyRWFjaF0gLSBcIkFmdGVyIGVhY2hcIiBob29rKHMpXG4gKi9cblxuLyoqXG4gKiBBbiBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB7QGxpbmsgTW9jaGFSb290SG9va09iamVjdH0sIGVpdGhlciBzeW5jIG9yIGFzeW5jLlxuICAgQGNhbGxiYWNrIE1vY2hhUm9vdEhvb2tGdW5jdGlvblxuICogQHJldHVybnMge01vY2hhUm9vdEhvb2tPYmplY3R8UHJvbWlzZTxNb2NoYVJvb3RIb29rT2JqZWN0Pn1cbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCdzIGludm9rZWQgX29uY2VfIHdoaWNoIGlzIGVpdGhlciBzeW5jIG9yIGFzeW5jLlxuICogQ2FuIGJlIGEgXCJ0ZWFyZG93blwiIG9yIFwic2V0dXBcIi4gIFRoZXNlIHdpbGwgYWxsIHNoYXJlIHRoZSBzYW1lIGNvbnRleHQuXG4gKiBAY2FsbGJhY2sgTW9jaGFHbG9iYWxGaXh0dXJlXG4gKiBAcmV0dXJucyB7dm9pZHxQcm9taXNlPHZvaWQ+fVxuICovXG5cbi8qKlxuICogQW4gb2JqZWN0IG1ha2luZyB1cCBhbGwgbmVjZXNzYXJ5IHBhcnRzIG9mIGEgcGx1Z2luIGxvYWRlciBhbmQgYWdncmVnYXRvclxuICogQHR5cGVkZWYge09iamVjdH0gUGx1Z2luRGVmaW5pdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IGV4cG9ydE5hbWUgLSBOYW1lZCBleHBvcnQgdG8gdXNlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW29wdGlvbk5hbWVdIC0gT3B0aW9uIG5hbWUgZm9yIE1vY2hhIGNvbnN0cnVjdG9yICh1c2UgYGV4cG9ydE5hbWVgIGlmIG9taXR0ZWQpXG4gKiBAcHJvcGVydHkge1BsdWdpblZhbGlkYXRvcn0gW3ZhbGlkYXRlXSAtIFZhbGlkYXRvciBmdW5jdGlvblxuICogQHByb3BlcnR5IHtQbHVnaW5GaW5hbGl6ZXJ9IFtmaW5hbGl6ZV0gLSBGaW5hbGl6ZXIvYWdncmVnYXRvciBmdW5jdGlvblxuICovXG5cbi8qKlxuICogQSAoc3luYykgZnVuY3Rpb24gdG8gYXNzZXJ0IGEgdXNlci1zdXBwbGllZCBwbHVnaW4gaW1wbGVtZW50YXRpb24gaXMgdmFsaWQuXG4gKlxuICogRGVmaW5lZCBpbiBhIHtAbGluayBQbHVnaW5EZWZpbml0aW9ufS5cblxuICogQGNhbGxiYWNrIFBsdWdpblZhbGlkYXRvclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrXG4gKiBAdGhpcyB7UGx1Z2luRGVmaW5pdGlvbn1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0byBmaW5hbGl6ZSBwbHVnaW5zIGltcGxzIG9mIGEgcGFydGljdWxhciBpbGtcbiAqIEBjYWxsYmFjayBQbHVnaW5GaW5hbGl6ZXJcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGltcGxzIC0gVXNlci1zdXBwbGllZCBpbXBsZW1lbnRhdGlvbnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPCo+fCp9XG4gKi9cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/mocha.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/nodejs/buffered-worker-pool.js":
/*!***************************************************************!*\
  !*** ./node_modules/mocha/lib/nodejs/buffered-worker-pool.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * A wrapper around a third-party child process worker pool implementation.\n * Used by {@link module:buffered-runner}.\n * @private\n * @module buffered-worker-pool\n */\n\n\n\nconst serializeJavascript = __webpack_require__(/*! serialize-javascript */ \"(ssr)/./node_modules/serialize-javascript/index.js\");\nconst workerpool = __webpack_require__(/*! workerpool */ \"(ssr)/./node_modules/workerpool/src/index.js\");\nconst {deserialize} = __webpack_require__(/*! ./serializer */ \"(ssr)/./node_modules/mocha/lib/nodejs/serializer.js\");\nconst debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")('mocha:parallel:buffered-worker-pool');\nconst {createInvalidArgumentTypeError} = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/mocha/lib/errors.js\");\n\nconst WORKER_PATH = /*require.resolve*/(/*! ./worker.js */ \"(ssr)/./node_modules/mocha/lib/nodejs/worker.js\");\n\n/**\n * A mapping of Mocha `Options` objects to serialized values.\n *\n * This is helpful because we tend to same the same options over and over\n * over IPC.\n * @type {WeakMap<Options,string>}\n */\nlet optionsCache = new WeakMap();\n\n/**\n * These options are passed into the [workerpool](https://npm.im/workerpool) module.\n * @type {Partial<WorkerPoolOptions>}\n */\nconst WORKER_POOL_DEFAULT_OPTS = {\n  // use child processes, not worker threads!\n  workerType: 'process',\n  // ensure the same flags sent to `node` for this `mocha` invocation are passed\n  // along to children\n  forkOpts: {execArgv: process.execArgv},\n  maxWorkers: workerpool.cpus - 1\n};\n\n/**\n * A wrapper around a third-party worker pool implementation.\n * @private\n */\nclass BufferedWorkerPool {\n  /**\n   * Creates an underlying worker pool instance; determines max worker count\n   * @param {Partial<WorkerPoolOptions>} [opts] - Options\n   */\n  constructor(opts = {}) {\n    const maxWorkers = Math.max(\n      1,\n      typeof opts.maxWorkers === 'undefined'\n        ? WORKER_POOL_DEFAULT_OPTS.maxWorkers\n        : opts.maxWorkers\n    );\n\n    /* istanbul ignore next */\n    if (workerpool.cpus < 2) {\n      // TODO: decide whether we should warn\n      debug(\n        'not enough CPU cores available to run multiple jobs; avoid --parallel on this machine'\n      );\n    } else if (maxWorkers >= workerpool.cpus) {\n      // TODO: decide whether we should warn\n      debug(\n        '%d concurrent job(s) requested, but only %d core(s) available',\n        maxWorkers,\n        workerpool.cpus\n      );\n    }\n    /* istanbul ignore next */\n    debug(\n      'run(): starting worker pool of max size %d, using node args: %s',\n      maxWorkers,\n      process.execArgv.join(' ')\n    );\n\n    let counter = 0;\n    const onCreateWorker = ({forkOpts}) => {\n      return {\n        forkOpts: {\n          ...forkOpts,\n          // adds an incremental id to all workers, which can be useful to allocate resources for each process\n          env: {...process.env, MOCHA_WORKER_ID: counter++}\n        }\n      };\n    };\n\n    this.options = {\n      ...WORKER_POOL_DEFAULT_OPTS,\n      ...opts,\n      maxWorkers,\n      onCreateWorker\n    };\n    this._pool = workerpool.pool(WORKER_PATH, this.options);\n  }\n\n  /**\n   * Terminates all workers in the pool.\n   * @param {boolean} [force] - Whether to force-kill workers. By default, lets workers finish their current task before termination.\n   * @private\n   * @returns {Promise<void>}\n   */\n  async terminate(force = false) {\n    /* istanbul ignore next */\n    debug('terminate(): terminating with force = %s', force);\n    return this._pool.terminate(force);\n  }\n\n  /**\n   * Adds a test file run to the worker pool queue for execution by a worker process.\n   *\n   * Handles serialization/deserialization.\n   *\n   * @param {string} filepath - Filepath of test\n   * @param {Options} [options] - Options for Mocha instance\n   * @private\n   * @returns {Promise<SerializedWorkerResult>}\n   */\n  async run(filepath, options = {}) {\n    if (!filepath || typeof filepath !== 'string') {\n      throw createInvalidArgumentTypeError(\n        'Expected a non-empty filepath',\n        'filepath',\n        'string'\n      );\n    }\n    const serializedOptions = BufferedWorkerPool.serializeOptions(options);\n    const result = await this._pool.exec('run', [filepath, serializedOptions]);\n    return deserialize(result);\n  }\n\n  /**\n   * Returns stats about the state of the worker processes in the pool.\n   *\n   * Used for debugging.\n   *\n   * @private\n   */\n  stats() {\n    return this._pool.stats();\n  }\n\n  /**\n   * Instantiates a {@link WorkerPool}.\n   * @private\n   */\n  static create(...args) {\n    return new BufferedWorkerPool(...args);\n  }\n\n  /**\n   * Given Mocha options object `opts`, serialize into a format suitable for\n   * transmission over IPC.\n   *\n   * @param {Options} [opts] - Mocha options\n   * @private\n   * @returns {string} Serialized options\n   */\n  static serializeOptions(opts = {}) {\n    if (!optionsCache.has(opts)) {\n      const serialized = serializeJavascript(opts, {\n        unsafe: true, // this means we don't care about XSS\n        ignoreFunction: true // do not serialize functions\n      });\n      optionsCache.set(opts, serialized);\n      /* istanbul ignore next */\n      debug(\n        'serializeOptions(): serialized options %O to: %s',\n        opts,\n        serialized\n      );\n    }\n    return optionsCache.get(opts);\n  }\n\n  /**\n   * Resets internal cache of serialized options objects.\n   *\n   * For testing/debugging\n   * @private\n   */\n  static resetOptionsCache() {\n    optionsCache = new WeakMap();\n  }\n}\n\nexports.BufferedWorkerPool = BufferedWorkerPool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL25vZGVqcy9idWZmZXJlZC13b3JrZXItcG9vbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBOztBQUVhOztBQUViLDRCQUE0QixtQkFBTyxDQUFDLGdGQUFzQjtBQUMxRCxtQkFBbUIsbUJBQU8sQ0FBQyxnRUFBWTtBQUN2QyxPQUFPLGFBQWEsRUFBRSxtQkFBTyxDQUFDLHlFQUFjO0FBQzVDLGNBQWMsbUJBQU8sQ0FBQyxzREFBTztBQUM3QixPQUFPLGdDQUFnQyxFQUFFLG1CQUFPLENBQUMsMkRBQVc7O0FBRTVELG9CQUFvQixtQkFBZSxDQUFDLG9FQUFhOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJCQUEyQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxhQUFhLDRCQUE0QjtBQUN6QztBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBLGVBQWU7QUFDZjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL25vZGVqcy9idWZmZXJlZC13b3JrZXItcG9vbC5qcz9kZmRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCBhIHRoaXJkLXBhcnR5IGNoaWxkIHByb2Nlc3Mgd29ya2VyIHBvb2wgaW1wbGVtZW50YXRpb24uXG4gKiBVc2VkIGJ5IHtAbGluayBtb2R1bGU6YnVmZmVyZWQtcnVubmVyfS5cbiAqIEBwcml2YXRlXG4gKiBAbW9kdWxlIGJ1ZmZlcmVkLXdvcmtlci1wb29sXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzZXJpYWxpemVKYXZhc2NyaXB0ID0gcmVxdWlyZSgnc2VyaWFsaXplLWphdmFzY3JpcHQnKTtcbmNvbnN0IHdvcmtlcnBvb2wgPSByZXF1aXJlKCd3b3JrZXJwb29sJyk7XG5jb25zdCB7ZGVzZXJpYWxpemV9ID0gcmVxdWlyZSgnLi9zZXJpYWxpemVyJyk7XG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21vY2hhOnBhcmFsbGVsOmJ1ZmZlcmVkLXdvcmtlci1wb29sJyk7XG5jb25zdCB7Y3JlYXRlSW52YWxpZEFyZ3VtZW50VHlwZUVycm9yfSA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuXG5jb25zdCBXT1JLRVJfUEFUSCA9IHJlcXVpcmUucmVzb2x2ZSgnLi93b3JrZXIuanMnKTtcblxuLyoqXG4gKiBBIG1hcHBpbmcgb2YgTW9jaGEgYE9wdGlvbnNgIG9iamVjdHMgdG8gc2VyaWFsaXplZCB2YWx1ZXMuXG4gKlxuICogVGhpcyBpcyBoZWxwZnVsIGJlY2F1c2Ugd2UgdGVuZCB0byBzYW1lIHRoZSBzYW1lIG9wdGlvbnMgb3ZlciBhbmQgb3ZlclxuICogb3ZlciBJUEMuXG4gKiBAdHlwZSB7V2Vha01hcDxPcHRpb25zLHN0cmluZz59XG4gKi9cbmxldCBvcHRpb25zQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIFRoZXNlIG9wdGlvbnMgYXJlIHBhc3NlZCBpbnRvIHRoZSBbd29ya2VycG9vbF0oaHR0cHM6Ly9ucG0uaW0vd29ya2VycG9vbCkgbW9kdWxlLlxuICogQHR5cGUge1BhcnRpYWw8V29ya2VyUG9vbE9wdGlvbnM+fVxuICovXG5jb25zdCBXT1JLRVJfUE9PTF9ERUZBVUxUX09QVFMgPSB7XG4gIC8vIHVzZSBjaGlsZCBwcm9jZXNzZXMsIG5vdCB3b3JrZXIgdGhyZWFkcyFcbiAgd29ya2VyVHlwZTogJ3Byb2Nlc3MnLFxuICAvLyBlbnN1cmUgdGhlIHNhbWUgZmxhZ3Mgc2VudCB0byBgbm9kZWAgZm9yIHRoaXMgYG1vY2hhYCBpbnZvY2F0aW9uIGFyZSBwYXNzZWRcbiAgLy8gYWxvbmcgdG8gY2hpbGRyZW5cbiAgZm9ya09wdHM6IHtleGVjQXJndjogcHJvY2Vzcy5leGVjQXJndn0sXG4gIG1heFdvcmtlcnM6IHdvcmtlcnBvb2wuY3B1cyAtIDFcbn07XG5cbi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCBhIHRoaXJkLXBhcnR5IHdvcmtlciBwb29sIGltcGxlbWVudGF0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQnVmZmVyZWRXb3JrZXJQb29sIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gdW5kZXJseWluZyB3b3JrZXIgcG9vbCBpbnN0YW5jZTsgZGV0ZXJtaW5lcyBtYXggd29ya2VyIGNvdW50XG4gICAqIEBwYXJhbSB7UGFydGlhbDxXb3JrZXJQb29sT3B0aW9ucz59IFtvcHRzXSAtIE9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IG1heFdvcmtlcnMgPSBNYXRoLm1heChcbiAgICAgIDEsXG4gICAgICB0eXBlb2Ygb3B0cy5tYXhXb3JrZXJzID09PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IFdPUktFUl9QT09MX0RFRkFVTFRfT1BUUy5tYXhXb3JrZXJzXG4gICAgICAgIDogb3B0cy5tYXhXb3JrZXJzXG4gICAgKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHdvcmtlcnBvb2wuY3B1cyA8IDIpIHtcbiAgICAgIC8vIFRPRE86IGRlY2lkZSB3aGV0aGVyIHdlIHNob3VsZCB3YXJuXG4gICAgICBkZWJ1ZyhcbiAgICAgICAgJ25vdCBlbm91Z2ggQ1BVIGNvcmVzIGF2YWlsYWJsZSB0byBydW4gbXVsdGlwbGUgam9iczsgYXZvaWQgLS1wYXJhbGxlbCBvbiB0aGlzIG1hY2hpbmUnXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAobWF4V29ya2VycyA+PSB3b3JrZXJwb29sLmNwdXMpIHtcbiAgICAgIC8vIFRPRE86IGRlY2lkZSB3aGV0aGVyIHdlIHNob3VsZCB3YXJuXG4gICAgICBkZWJ1ZyhcbiAgICAgICAgJyVkIGNvbmN1cnJlbnQgam9iKHMpIHJlcXVlc3RlZCwgYnV0IG9ubHkgJWQgY29yZShzKSBhdmFpbGFibGUnLFxuICAgICAgICBtYXhXb3JrZXJzLFxuICAgICAgICB3b3JrZXJwb29sLmNwdXNcbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZGVidWcoXG4gICAgICAncnVuKCk6IHN0YXJ0aW5nIHdvcmtlciBwb29sIG9mIG1heCBzaXplICVkLCB1c2luZyBub2RlIGFyZ3M6ICVzJyxcbiAgICAgIG1heFdvcmtlcnMsXG4gICAgICBwcm9jZXNzLmV4ZWNBcmd2LmpvaW4oJyAnKVxuICAgICk7XG5cbiAgICBsZXQgY291bnRlciA9IDA7XG4gICAgY29uc3Qgb25DcmVhdGVXb3JrZXIgPSAoe2ZvcmtPcHRzfSkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZm9ya09wdHM6IHtcbiAgICAgICAgICAuLi5mb3JrT3B0cyxcbiAgICAgICAgICAvLyBhZGRzIGFuIGluY3JlbWVudGFsIGlkIHRvIGFsbCB3b3JrZXJzLCB3aGljaCBjYW4gYmUgdXNlZnVsIHRvIGFsbG9jYXRlIHJlc291cmNlcyBmb3IgZWFjaCBwcm9jZXNzXG4gICAgICAgICAgZW52OiB7Li4ucHJvY2Vzcy5lbnYsIE1PQ0hBX1dPUktFUl9JRDogY291bnRlcisrfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi5XT1JLRVJfUE9PTF9ERUZBVUxUX09QVFMsXG4gICAgICAuLi5vcHRzLFxuICAgICAgbWF4V29ya2VycyxcbiAgICAgIG9uQ3JlYXRlV29ya2VyXG4gICAgfTtcbiAgICB0aGlzLl9wb29sID0gd29ya2VycG9vbC5wb29sKFdPUktFUl9QQVRILCB0aGlzLm9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlcm1pbmF0ZXMgYWxsIHdvcmtlcnMgaW4gdGhlIHBvb2wuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlXSAtIFdoZXRoZXIgdG8gZm9yY2Uta2lsbCB3b3JrZXJzLiBCeSBkZWZhdWx0LCBsZXRzIHdvcmtlcnMgZmluaXNoIHRoZWlyIGN1cnJlbnQgdGFzayBiZWZvcmUgdGVybWluYXRpb24uXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgdGVybWluYXRlKGZvcmNlID0gZmFsc2UpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGRlYnVnKCd0ZXJtaW5hdGUoKTogdGVybWluYXRpbmcgd2l0aCBmb3JjZSA9ICVzJywgZm9yY2UpO1xuICAgIHJldHVybiB0aGlzLl9wb29sLnRlcm1pbmF0ZShmb3JjZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHRlc3QgZmlsZSBydW4gdG8gdGhlIHdvcmtlciBwb29sIHF1ZXVlIGZvciBleGVjdXRpb24gYnkgYSB3b3JrZXIgcHJvY2Vzcy5cbiAgICpcbiAgICogSGFuZGxlcyBzZXJpYWxpemF0aW9uL2Rlc2VyaWFsaXphdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVwYXRoIC0gRmlsZXBhdGggb2YgdGVzdFxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIE1vY2hhIGluc3RhbmNlXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFNlcmlhbGl6ZWRXb3JrZXJSZXN1bHQ+fVxuICAgKi9cbiAgYXN5bmMgcnVuKGZpbGVwYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWZpbGVwYXRoIHx8IHR5cGVvZiBmaWxlcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IGNyZWF0ZUludmFsaWRBcmd1bWVudFR5cGVFcnJvcihcbiAgICAgICAgJ0V4cGVjdGVkIGEgbm9uLWVtcHR5IGZpbGVwYXRoJyxcbiAgICAgICAgJ2ZpbGVwYXRoJyxcbiAgICAgICAgJ3N0cmluZydcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHNlcmlhbGl6ZWRPcHRpb25zID0gQnVmZmVyZWRXb3JrZXJQb29sLnNlcmlhbGl6ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fcG9vbC5leGVjKCdydW4nLCBbZmlsZXBhdGgsIHNlcmlhbGl6ZWRPcHRpb25zXSk7XG4gICAgcmV0dXJuIGRlc2VyaWFsaXplKHJlc3VsdCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBzdGF0cyBhYm91dCB0aGUgc3RhdGUgb2YgdGhlIHdvcmtlciBwcm9jZXNzZXMgaW4gdGhlIHBvb2wuXG4gICAqXG4gICAqIFVzZWQgZm9yIGRlYnVnZ2luZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wb29sLnN0YXRzKCk7XG4gIH1cblxuICAvKipcbiAgICogSW5zdGFudGlhdGVzIGEge0BsaW5rIFdvcmtlclBvb2x9LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXJlZFdvcmtlclBvb2woLi4uYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gTW9jaGEgb3B0aW9ucyBvYmplY3QgYG9wdHNgLCBzZXJpYWxpemUgaW50byBhIGZvcm1hdCBzdWl0YWJsZSBmb3JcbiAgICogdHJhbnNtaXNzaW9uIG92ZXIgSVBDLlxuICAgKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRzXSAtIE1vY2hhIG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge3N0cmluZ30gU2VyaWFsaXplZCBvcHRpb25zXG4gICAqL1xuICBzdGF0aWMgc2VyaWFsaXplT3B0aW9ucyhvcHRzID0ge30pIHtcbiAgICBpZiAoIW9wdGlvbnNDYWNoZS5oYXMob3B0cykpIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBzZXJpYWxpemVKYXZhc2NyaXB0KG9wdHMsIHtcbiAgICAgICAgdW5zYWZlOiB0cnVlLCAvLyB0aGlzIG1lYW5zIHdlIGRvbid0IGNhcmUgYWJvdXQgWFNTXG4gICAgICAgIGlnbm9yZUZ1bmN0aW9uOiB0cnVlIC8vIGRvIG5vdCBzZXJpYWxpemUgZnVuY3Rpb25zXG4gICAgICB9KTtcbiAgICAgIG9wdGlvbnNDYWNoZS5zZXQob3B0cywgc2VyaWFsaXplZCk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgZGVidWcoXG4gICAgICAgICdzZXJpYWxpemVPcHRpb25zKCk6IHNlcmlhbGl6ZWQgb3B0aW9ucyAlTyB0bzogJXMnLFxuICAgICAgICBvcHRzLFxuICAgICAgICBzZXJpYWxpemVkXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9uc0NhY2hlLmdldChvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgaW50ZXJuYWwgY2FjaGUgb2Ygc2VyaWFsaXplZCBvcHRpb25zIG9iamVjdHMuXG4gICAqXG4gICAqIEZvciB0ZXN0aW5nL2RlYnVnZ2luZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIHJlc2V0T3B0aW9uc0NhY2hlKCkge1xuICAgIG9wdGlvbnNDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG4gIH1cbn1cblxuZXhwb3J0cy5CdWZmZXJlZFdvcmtlclBvb2wgPSBCdWZmZXJlZFdvcmtlclBvb2w7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/nodejs/buffered-worker-pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/nodejs/esm-utils.js":
/*!****************************************************!*\
  !*** ./node_modules/mocha/lib/nodejs/esm-utils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const path = __webpack_require__(/*! path */ \"path\");\nconst url = __webpack_require__(/*! url */ \"url\");\n\nconst forward = x => x;\n\nconst formattedImport = async (file, esmDecorator = forward) => {\n  if (path.isAbsolute(file)) {\n    try {\n      return await exports.doImport(esmDecorator(url.pathToFileURL(file)));\n    } catch (err) {\n      // This is a hack created because ESM in Node.js (at least in Node v15.5.1) does not emit\n      // the location of the syntax error in the error thrown.\n      // This is problematic because the user can't see what file has the problem,\n      // so we add the file location to the error.\n      // TODO: remove once Node.js fixes the problem.\n      if (\n        err instanceof SyntaxError &&\n        err.message &&\n        err.stack &&\n        !err.stack.includes(file)\n      ) {\n        const newErrorWithFilename = new SyntaxError(err.message);\n        newErrorWithFilename.stack = err.stack.replace(\n          /^SyntaxError/,\n          `SyntaxError[ @${file} ]`\n        );\n        throw newErrorWithFilename;\n      }\n      throw err;\n    }\n  }\n  return exports.doImport(esmDecorator(file));\n};\n\nexports.doImport = async file => __webpack_require__(\"(ssr)/./node_modules/mocha/lib/nodejs lazy recursive\")(file);\n\nexports.requireOrImport = async (file, esmDecorator) => {\n  if (path.extname(file) === '.mjs') {\n    return formattedImport(file, esmDecorator);\n  }\n  try {\n    return dealWithExports(await formattedImport(file, esmDecorator));\n  } catch (err) {\n    if (\n      err.code === 'ERR_MODULE_NOT_FOUND' ||\n      err.code === 'ERR_UNKNOWN_FILE_EXTENSION' ||\n      err.code === 'ERR_UNSUPPORTED_DIR_IMPORT'\n    ) {\n      try {\n        // Importing a file usually works, but the resolution of `import` is the ESM\n        // resolution algorithm, and not the CJS resolution algorithm. We may have\n        // failed because we tried the ESM resolution, so we try to `require` it.\n        return __webpack_require__(\"(ssr)/./node_modules/mocha/lib/nodejs sync recursive\")(file);\n      } catch (requireErr) {\n        if (\n          requireErr.code === 'ERR_REQUIRE_ESM' ||\n          (requireErr instanceof SyntaxError &&\n            requireErr\n              .toString()\n              .includes('Cannot use import statement outside a module'))\n        ) {\n          // ERR_REQUIRE_ESM happens when the test file is a JS file, but via type:module is actually ESM,\n          // AND has an import to a file that doesn't exist.\n          // This throws an `ERR_MODULE_NOT_FOUND` error above,\n          // and when we try to `require` it here, it throws an `ERR_REQUIRE_ESM`.\n          // What we want to do is throw the original error (the `ERR_MODULE_NOT_FOUND`),\n          // and not the `ERR_REQUIRE_ESM` error, which is a red herring.\n          //\n          // SyntaxError happens when in an edge case: when we're using an ESM loader that loads\n          // a `test.ts` file (i.e. unrecognized extension), and that file includes an unknown\n          // import (which throws an ERR_MODULE_NOT_FOUND). `require`-ing it will throw the\n          // syntax error, because we cannot require a file that has `import`-s.\n          throw err;\n        } else {\n          throw requireErr;\n        }\n      }\n    } else {\n      throw err;\n    }\n  }\n};\n\nfunction dealWithExports(module) {\n  if (module.default) {\n    return module.default;\n  } else {\n    return {...module, default: undefined};\n  }\n}\n\nexports.loadFilesAsync = async (\n  files,\n  preLoadFunc,\n  postLoadFunc,\n  esmDecorator\n) => {\n  for (const file of files) {\n    preLoadFunc(file);\n    const result = await exports.requireOrImport(\n      path.resolve(file),\n      esmDecorator\n    );\n    postLoadFunc(file, result);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL25vZGVqcy9lc20tdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFlBQVksbUJBQU8sQ0FBQyxnQkFBSzs7QUFFekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixNQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGlCQUFpQiw0RUFBTyxJQUFJLENBQUM7O0FBRTdDLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEVBQVEsSUFBSSxDQUFDO0FBQzVCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLFlBQVk7QUFDWjtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvbm9kZWpzL2VzbS11dGlscy5qcz8xYzRmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCB1cmwgPSByZXF1aXJlKCd1cmwnKTtcblxuY29uc3QgZm9yd2FyZCA9IHggPT4geDtcblxuY29uc3QgZm9ybWF0dGVkSW1wb3J0ID0gYXN5bmMgKGZpbGUsIGVzbURlY29yYXRvciA9IGZvcndhcmQpID0+IHtcbiAgaWYgKHBhdGguaXNBYnNvbHV0ZShmaWxlKSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgZXhwb3J0cy5kb0ltcG9ydChlc21EZWNvcmF0b3IodXJsLnBhdGhUb0ZpbGVVUkwoZmlsZSkpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBoYWNrIGNyZWF0ZWQgYmVjYXVzZSBFU00gaW4gTm9kZS5qcyAoYXQgbGVhc3QgaW4gTm9kZSB2MTUuNS4xKSBkb2VzIG5vdCBlbWl0XG4gICAgICAvLyB0aGUgbG9jYXRpb24gb2YgdGhlIHN5bnRheCBlcnJvciBpbiB0aGUgZXJyb3IgdGhyb3duLlxuICAgICAgLy8gVGhpcyBpcyBwcm9ibGVtYXRpYyBiZWNhdXNlIHRoZSB1c2VyIGNhbid0IHNlZSB3aGF0IGZpbGUgaGFzIHRoZSBwcm9ibGVtLFxuICAgICAgLy8gc28gd2UgYWRkIHRoZSBmaWxlIGxvY2F0aW9uIHRvIHRoZSBlcnJvci5cbiAgICAgIC8vIFRPRE86IHJlbW92ZSBvbmNlIE5vZGUuanMgZml4ZXMgdGhlIHByb2JsZW0uXG4gICAgICBpZiAoXG4gICAgICAgIGVyciBpbnN0YW5jZW9mIFN5bnRheEVycm9yICYmXG4gICAgICAgIGVyci5tZXNzYWdlICYmXG4gICAgICAgIGVyci5zdGFjayAmJlxuICAgICAgICAhZXJyLnN0YWNrLmluY2x1ZGVzKGZpbGUpXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgbmV3RXJyb3JXaXRoRmlsZW5hbWUgPSBuZXcgU3ludGF4RXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgICBuZXdFcnJvcldpdGhGaWxlbmFtZS5zdGFjayA9IGVyci5zdGFjay5yZXBsYWNlKFxuICAgICAgICAgIC9eU3ludGF4RXJyb3IvLFxuICAgICAgICAgIGBTeW50YXhFcnJvclsgQCR7ZmlsZX0gXWBcbiAgICAgICAgKTtcbiAgICAgICAgdGhyb3cgbmV3RXJyb3JXaXRoRmlsZW5hbWU7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIHJldHVybiBleHBvcnRzLmRvSW1wb3J0KGVzbURlY29yYXRvcihmaWxlKSk7XG59O1xuXG5leHBvcnRzLmRvSW1wb3J0ID0gYXN5bmMgZmlsZSA9PiBpbXBvcnQoZmlsZSk7XG5cbmV4cG9ydHMucmVxdWlyZU9ySW1wb3J0ID0gYXN5bmMgKGZpbGUsIGVzbURlY29yYXRvcikgPT4ge1xuICBpZiAocGF0aC5leHRuYW1lKGZpbGUpID09PSAnLm1qcycpIHtcbiAgICByZXR1cm4gZm9ybWF0dGVkSW1wb3J0KGZpbGUsIGVzbURlY29yYXRvcik7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVhbFdpdGhFeHBvcnRzKGF3YWl0IGZvcm1hdHRlZEltcG9ydChmaWxlLCBlc21EZWNvcmF0b3IpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKFxuICAgICAgZXJyLmNvZGUgPT09ICdFUlJfTU9EVUxFX05PVF9GT1VORCcgfHxcbiAgICAgIGVyci5jb2RlID09PSAnRVJSX1VOS05PV05fRklMRV9FWFRFTlNJT04nIHx8XG4gICAgICBlcnIuY29kZSA9PT0gJ0VSUl9VTlNVUFBPUlRFRF9ESVJfSU1QT1JUJ1xuICAgICkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gSW1wb3J0aW5nIGEgZmlsZSB1c3VhbGx5IHdvcmtzLCBidXQgdGhlIHJlc29sdXRpb24gb2YgYGltcG9ydGAgaXMgdGhlIEVTTVxuICAgICAgICAvLyByZXNvbHV0aW9uIGFsZ29yaXRobSwgYW5kIG5vdCB0aGUgQ0pTIHJlc29sdXRpb24gYWxnb3JpdGhtLiBXZSBtYXkgaGF2ZVxuICAgICAgICAvLyBmYWlsZWQgYmVjYXVzZSB3ZSB0cmllZCB0aGUgRVNNIHJlc29sdXRpb24sIHNvIHdlIHRyeSB0byBgcmVxdWlyZWAgaXQuXG4gICAgICAgIHJldHVybiByZXF1aXJlKGZpbGUpO1xuICAgICAgfSBjYXRjaCAocmVxdWlyZUVycikge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcmVxdWlyZUVyci5jb2RlID09PSAnRVJSX1JFUVVJUkVfRVNNJyB8fFxuICAgICAgICAgIChyZXF1aXJlRXJyIGluc3RhbmNlb2YgU3ludGF4RXJyb3IgJiZcbiAgICAgICAgICAgIHJlcXVpcmVFcnJcbiAgICAgICAgICAgICAgLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgLmluY2x1ZGVzKCdDYW5ub3QgdXNlIGltcG9ydCBzdGF0ZW1lbnQgb3V0c2lkZSBhIG1vZHVsZScpKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBFUlJfUkVRVUlSRV9FU00gaGFwcGVucyB3aGVuIHRoZSB0ZXN0IGZpbGUgaXMgYSBKUyBmaWxlLCBidXQgdmlhIHR5cGU6bW9kdWxlIGlzIGFjdHVhbGx5IEVTTSxcbiAgICAgICAgICAvLyBBTkQgaGFzIGFuIGltcG9ydCB0byBhIGZpbGUgdGhhdCBkb2Vzbid0IGV4aXN0LlxuICAgICAgICAgIC8vIFRoaXMgdGhyb3dzIGFuIGBFUlJfTU9EVUxFX05PVF9GT1VORGAgZXJyb3IgYWJvdmUsXG4gICAgICAgICAgLy8gYW5kIHdoZW4gd2UgdHJ5IHRvIGByZXF1aXJlYCBpdCBoZXJlLCBpdCB0aHJvd3MgYW4gYEVSUl9SRVFVSVJFX0VTTWAuXG4gICAgICAgICAgLy8gV2hhdCB3ZSB3YW50IHRvIGRvIGlzIHRocm93IHRoZSBvcmlnaW5hbCBlcnJvciAodGhlIGBFUlJfTU9EVUxFX05PVF9GT1VORGApLFxuICAgICAgICAgIC8vIGFuZCBub3QgdGhlIGBFUlJfUkVRVUlSRV9FU01gIGVycm9yLCB3aGljaCBpcyBhIHJlZCBoZXJyaW5nLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gU3ludGF4RXJyb3IgaGFwcGVucyB3aGVuIGluIGFuIGVkZ2UgY2FzZTogd2hlbiB3ZSdyZSB1c2luZyBhbiBFU00gbG9hZGVyIHRoYXQgbG9hZHNcbiAgICAgICAgICAvLyBhIGB0ZXN0LnRzYCBmaWxlIChpLmUuIHVucmVjb2duaXplZCBleHRlbnNpb24pLCBhbmQgdGhhdCBmaWxlIGluY2x1ZGVzIGFuIHVua25vd25cbiAgICAgICAgICAvLyBpbXBvcnQgKHdoaWNoIHRocm93cyBhbiBFUlJfTU9EVUxFX05PVF9GT1VORCkuIGByZXF1aXJlYC1pbmcgaXQgd2lsbCB0aHJvdyB0aGVcbiAgICAgICAgICAvLyBzeW50YXggZXJyb3IsIGJlY2F1c2Ugd2UgY2Fubm90IHJlcXVpcmUgYSBmaWxlIHRoYXQgaGFzIGBpbXBvcnRgLXMuXG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IHJlcXVpcmVFcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gZGVhbFdpdGhFeHBvcnRzKG1vZHVsZSkge1xuICBpZiAobW9kdWxlLmRlZmF1bHQpIHtcbiAgICByZXR1cm4gbW9kdWxlLmRlZmF1bHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsuLi5tb2R1bGUsIGRlZmF1bHQ6IHVuZGVmaW5lZH07XG4gIH1cbn1cblxuZXhwb3J0cy5sb2FkRmlsZXNBc3luYyA9IGFzeW5jIChcbiAgZmlsZXMsXG4gIHByZUxvYWRGdW5jLFxuICBwb3N0TG9hZEZ1bmMsXG4gIGVzbURlY29yYXRvclxuKSA9PiB7XG4gIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgIHByZUxvYWRGdW5jKGZpbGUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4cG9ydHMucmVxdWlyZU9ySW1wb3J0KFxuICAgICAgcGF0aC5yZXNvbHZlKGZpbGUpLFxuICAgICAgZXNtRGVjb3JhdG9yXG4gICAgKTtcbiAgICBwb3N0TG9hZEZ1bmMoZmlsZSwgcmVzdWx0KTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/nodejs/esm-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/nodejs/file-unloader.js":
/*!********************************************************!*\
  !*** ./node_modules/mocha/lib/nodejs/file-unloader.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n * This module should not be in the browser bundle, so it's here.\n * @private\n * @module\n */\n\n/**\n * Deletes a file from the `require` cache.\n * @param {string} file - File\n */\nexports.unloadFile = file => {\n  delete __webpack_require__.c[/*require.resolve*/(__webpack_require__(\"(ssr)/./node_modules/mocha/lib/nodejs sync recursive\").resolve(file))];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL25vZGVqcy9maWxlLXVubG9hZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGtCQUFrQjtBQUNsQixTQUFTLHFCQUFhLENBQUMsbUJBQWUsQ0FBQyx3RkFBSTtBQUMzQyIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL25vZGVqcy9maWxlLXVubG9hZGVyLmpzP2U5ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgaW4gdGhlIGJyb3dzZXIgYnVuZGxlLCBzbyBpdCdzIGhlcmUuXG4gKiBAcHJpdmF0ZVxuICogQG1vZHVsZVxuICovXG5cbi8qKlxuICogRGVsZXRlcyBhIGZpbGUgZnJvbSB0aGUgYHJlcXVpcmVgIGNhY2hlLlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGUgLSBGaWxlXG4gKi9cbmV4cG9ydHMudW5sb2FkRmlsZSA9IGZpbGUgPT4ge1xuICBkZWxldGUgcmVxdWlyZS5jYWNoZVtyZXF1aXJlLnJlc29sdmUoZmlsZSldO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/nodejs/file-unloader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/nodejs/parallel-buffered-runner.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mocha/lib/nodejs/parallel-buffered-runner.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * A test Runner that uses a {@link module:buffered-worker-pool}.\n * @module parallel-buffered-runner\n * @private\n */\n\n\n\nconst Runner = __webpack_require__(/*! ../runner */ \"(ssr)/./node_modules/mocha/lib/runner.js\");\nconst {EVENT_RUN_BEGIN, EVENT_RUN_END} = Runner.constants;\nconst debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")('mocha:parallel:parallel-buffered-runner');\nconst {BufferedWorkerPool} = __webpack_require__(/*! ./buffered-worker-pool */ \"(ssr)/./node_modules/mocha/lib/nodejs/buffered-worker-pool.js\");\nconst {setInterval, clearInterval} = global;\nconst {createMap, constants} = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\");\nconst {MOCHA_ID_PROP_NAME} = constants;\nconst {createFatalError} = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/mocha/lib/errors.js\");\n\nconst DEFAULT_WORKER_REPORTER = /*require.resolve*/(\n  /*! ./reporters/parallel-buffered */ \"(ssr)/./node_modules/mocha/lib/nodejs/reporters/parallel-buffered.js\"\n);\n\n/**\n * List of options to _not_ serialize for transmission to workers\n */\nconst DENY_OPTIONS = [\n  'globalSetup',\n  'globalTeardown',\n  'parallel',\n  'p',\n  'jobs',\n  'j'\n];\n\n/**\n * Outputs a debug statement with worker stats\n * @param {BufferedWorkerPool} pool - Worker pool\n */\n/* istanbul ignore next */\nconst debugStats = pool => {\n  const {totalWorkers, busyWorkers, idleWorkers, pendingTasks} = pool.stats();\n  debug(\n    '%d/%d busy workers; %d idle; %d tasks queued',\n    busyWorkers,\n    totalWorkers,\n    idleWorkers,\n    pendingTasks\n  );\n};\n\n/**\n * The interval at which we will display stats for worker processes in debug mode\n */\nconst DEBUG_STATS_INTERVAL = 5000;\n\nconst ABORTED = 'ABORTED';\nconst IDLE = 'IDLE';\nconst ABORTING = 'ABORTING';\nconst RUNNING = 'RUNNING';\nconst BAILING = 'BAILING';\nconst BAILED = 'BAILED';\nconst COMPLETE = 'COMPLETE';\n\nconst states = createMap({\n  [IDLE]: new Set([RUNNING, ABORTING]),\n  [RUNNING]: new Set([COMPLETE, BAILING, ABORTING]),\n  [COMPLETE]: new Set(),\n  [ABORTED]: new Set(),\n  [ABORTING]: new Set([ABORTED]),\n  [BAILING]: new Set([BAILED, ABORTING]),\n  [BAILED]: new Set([COMPLETE, ABORTING])\n});\n\n/**\n * This `Runner` delegates tests runs to worker threads.  Does not execute any\n * {@link Runnable}s by itself!\n * @public\n */\nclass ParallelBufferedRunner extends Runner {\n  constructor(...args) {\n    super(...args);\n\n    let state = IDLE;\n    Object.defineProperty(this, '_state', {\n      get() {\n        return state;\n      },\n      set(newState) {\n        if (states[state].has(newState)) {\n          state = newState;\n        } else {\n          throw new Error(`invalid state transition: ${state} => ${newState}`);\n        }\n      }\n    });\n\n    this._workerReporter = DEFAULT_WORKER_REPORTER;\n    this._linkPartialObjects = false;\n    this._linkedObjectMap = new Map();\n\n    this.once(Runner.constants.EVENT_RUN_END, () => {\n      this._state = COMPLETE;\n    });\n  }\n\n  /**\n   * Returns a mapping function to enqueue a file in the worker pool and return results of its execution.\n   * @param {BufferedWorkerPool} pool - Worker pool\n   * @param {Options} options - Mocha options\n   * @returns {FileRunner} Mapping function\n   * @private\n   */\n  _createFileRunner(pool, options) {\n    /**\n     * Emits event and sets `BAILING` state, if necessary.\n     * @param {Object} event - Event having `eventName`, maybe `data` and maybe `error`\n     * @param {number} failureCount - Failure count\n     */\n    const emitEvent = (event, failureCount) => {\n      this.emit(event.eventName, event.data, event.error);\n      if (\n        this._state !== BAILING &&\n        event.data &&\n        event.data._bail &&\n        (failureCount || event.error)\n      ) {\n        debug('run(): nonzero failure count & found bail flag');\n        // we need to let the events complete for this file, as the worker\n        // should run any cleanup hooks\n        this._state = BAILING;\n      }\n    };\n\n    /**\n     * Given an event, recursively find any objects in its data that have ID's, and create object references to already-seen objects.\n     * @param {Object} event - Event having `eventName`, maybe `data` and maybe `error`\n     */\n    const linkEvent = event => {\n      const stack = [{parent: event, prop: 'data'}];\n      while (stack.length) {\n        const {parent, prop} = stack.pop();\n        const obj = parent[prop];\n        let newObj;\n        if (obj && typeof obj === 'object') {\n          if (obj[MOCHA_ID_PROP_NAME]) {\n            const id = obj[MOCHA_ID_PROP_NAME];\n            newObj = this._linkedObjectMap.has(id)\n              ? Object.assign(this._linkedObjectMap.get(id), obj)\n              : obj;\n            this._linkedObjectMap.set(id, newObj);\n            parent[prop] = newObj;\n          } else {\n            throw createFatalError(\n              'Object missing ID received in event data',\n              obj\n            );\n          }\n        }\n        Object.keys(newObj).forEach(key => {\n          const value = obj[key];\n          if (value && typeof value === 'object' && value[MOCHA_ID_PROP_NAME]) {\n            stack.push({obj: value, parent: newObj, prop: key});\n          }\n        });\n      }\n    };\n\n    return async file => {\n      debug('run(): enqueueing test file %s', file);\n      try {\n        const {failureCount, events} = await pool.run(file, options);\n\n        if (this._state === BAILED) {\n          // short-circuit after a graceful bail. if this happens,\n          // some other worker has bailed.\n          // TODO: determine if this is the desired behavior, or if we\n          // should report the events of this run anyway.\n          return;\n        }\n        debug(\n          'run(): completed run of file %s; %d failures / %d events',\n          file,\n          failureCount,\n          events.length\n        );\n        this.failures += failureCount; // can this ever be non-numeric?\n        let event = events.shift();\n\n        if (this._linkPartialObjects) {\n          while (event) {\n            linkEvent(event);\n            emitEvent(event, failureCount);\n            event = events.shift();\n          }\n        } else {\n          while (event) {\n            emitEvent(event, failureCount);\n            event = events.shift();\n          }\n        }\n        if (this._state === BAILING) {\n          debug('run(): terminating pool due to \"bail\" flag');\n          this._state = BAILED;\n          await pool.terminate();\n        }\n      } catch (err) {\n        if (this._state === BAILED || this._state === ABORTING) {\n          debug(\n            'run(): worker pool terminated with intent; skipping file %s',\n            file\n          );\n        } else {\n          // this is an uncaught exception\n          debug('run(): encountered uncaught exception: %O', err);\n          if (this.allowUncaught) {\n            // still have to clean up\n            this._state = ABORTING;\n            await pool.terminate(true);\n          }\n          throw err;\n        }\n      } finally {\n        debug('run(): done running file %s', file);\n      }\n    };\n  }\n\n  /**\n   * Listen on `Process.SIGINT`; terminate pool if caught.\n   * Returns the listener for later call to `process.removeListener()`.\n   * @param {BufferedWorkerPool} pool - Worker pool\n   * @returns {SigIntListener} Listener\n   * @private\n   */\n  _bindSigIntListener(pool) {\n    const sigIntListener = async () => {\n      debug('run(): caught a SIGINT');\n      this._state = ABORTING;\n\n      try {\n        debug('run(): force-terminating worker pool');\n        await pool.terminate(true);\n      } catch (err) {\n        console.error(\n          `Error while attempting to force-terminate worker pool: ${err}`\n        );\n        process.exitCode = 1;\n      } finally {\n        process.nextTick(() => {\n          debug('run(): imminent death');\n          this._state = ABORTED;\n          process.kill(process.pid, 'SIGINT');\n        });\n      }\n    };\n\n    process.once('SIGINT', sigIntListener);\n\n    return sigIntListener;\n  }\n\n  /**\n   * Runs Mocha tests by creating a thread pool, then delegating work to the\n   * worker threads.\n   *\n   * Each worker receives one file, and as workers become available, they take a\n   * file from the queue and run it. The worker thread execution is treated like\n   * an RPC--it returns a `Promise` containing serialized information about the\n   * run.  The information is processed as it's received, and emitted to a\n   * {@link Reporter}, which is likely listening for these events.\n   *\n   * @param {Function} callback - Called with an exit code corresponding to\n   * number of test failures.\n   * @param {Object} [opts] - options\n   * @param {string[]} opts.files - Files to run\n   * @param {Options} opts.options - command-line options\n   */\n  run(callback, {files, options = {}} = {}) {\n    /**\n     * Listener on `Process.SIGINT` which tries to cleanly terminate the worker pool.\n     */\n    let sigIntListener;\n\n    // assign the reporter the worker will use, which will be different than the\n    // main process' reporter\n    options = {...options, reporter: this._workerReporter};\n\n    // This function should _not_ return a `Promise`; its parent (`Runner#run`)\n    // returns this instance, so this should do the same. However, we want to make\n    // use of `async`/`await`, so we use this IIFE.\n    (async () => {\n      /**\n       * This is an interval that outputs stats about the worker pool every so often\n       */\n      let debugInterval;\n\n      /**\n       * @type {BufferedWorkerPool}\n       */\n      let pool;\n\n      try {\n        pool = BufferedWorkerPool.create({maxWorkers: options.jobs});\n\n        sigIntListener = this._bindSigIntListener(pool);\n\n        /* istanbul ignore next */\n        debugInterval = setInterval(\n          () => debugStats(pool),\n          DEBUG_STATS_INTERVAL\n        ).unref();\n\n        // this is set for uncaught exception handling in `Runner#uncaught`\n        // TODO: `Runner` should be using a state machine instead.\n        this.started = true;\n        this._state = RUNNING;\n\n        this.emit(EVENT_RUN_BEGIN);\n\n        options = {...options};\n        DENY_OPTIONS.forEach(opt => {\n          delete options[opt];\n        });\n\n        const results = await Promise.allSettled(\n          files.map(this._createFileRunner(pool, options))\n        );\n\n        // note that pool may already be terminated due to --bail\n        await pool.terminate();\n\n        results\n          .filter(({status}) => status === 'rejected')\n          .forEach(({reason}) => {\n            if (this.allowUncaught) {\n              // yep, just the first one.\n              throw reason;\n            }\n            // \"rejected\" will correspond to uncaught exceptions.\n            // unlike the serial runner, the parallel runner can always recover.\n            this.uncaught(reason);\n          });\n\n        if (this._state === ABORTING) {\n          return;\n        }\n\n        this.emit(EVENT_RUN_END);\n        debug('run(): completing with failure count %d', this.failures);\n        callback(this.failures);\n      } catch (err) {\n        // this `nextTick` takes us out of the `Promise` scope, so the\n        // exception will not be caught and returned as a rejected `Promise`,\n        // which would lead to an `unhandledRejection` event.\n        process.nextTick(() => {\n          debug('run(): re-throwing uncaught exception');\n          throw err;\n        });\n      } finally {\n        clearInterval(debugInterval);\n        process.removeListener('SIGINT', sigIntListener);\n      }\n    })();\n    return this;\n  }\n\n  /**\n   * Toggle partial object linking behavior; used for building object references from\n   * unique ID's.\n   * @param {boolean} [value] - If `true`, enable partial object linking, otherwise disable\n   * @returns {Runner}\n   * @chainable\n   * @public\n   * @example\n   * // this reporter needs proper object references when run in parallel mode\n   * class MyReporter() {\n   *   constructor(runner) {\n   *     this.runner.linkPartialObjects(true)\n   *       .on(EVENT_SUITE_BEGIN, suite => {\n             // this Suite may be the same object...\n  *       })\n  *       .on(EVENT_TEST_BEGIN, test => {\n  *         // ...as the `test.parent` property\n  *       });\n  *   }\n  * }\n  */\n  linkPartialObjects(value) {\n    this._linkPartialObjects = Boolean(value);\n    return super.linkPartialObjects(value);\n  }\n\n  /**\n   * If this class is the `Runner` in use, then this is going to return `true`.\n   *\n   * For use by reporters.\n   * @returns {true}\n   * @public\n   */\n  isParallelMode() {\n    return true;\n  }\n\n  /**\n   * Configures an alternate reporter for worker processes to use. Subclasses\n   * using worker processes should implement this.\n   * @public\n   * @param {string} path - Absolute path to alternate reporter for worker processes to use\n   * @returns {Runner}\n   * @throws When in serial mode\n   * @chainable\n   */\n  workerReporter(reporter) {\n    this._workerReporter = reporter;\n    return this;\n  }\n}\n\nmodule.exports = ParallelBufferedRunner;\n\n/**\n * Listener function intended to be bound to `Process.SIGINT` event\n * @private\n * @callback SigIntListener\n * @returns {Promise<void>}\n */\n\n/**\n * A function accepting a test file path and returning the results of a test run\n * @private\n * @callback FileRunner\n * @param {string} filename - File to run\n * @returns {Promise<SerializedWorkerResult>}\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL25vZGVqcy9wYXJhbGxlbC1idWZmZXJlZC1ydW5uZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsMkRBQVc7QUFDbEMsT0FBTyxnQ0FBZ0M7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLHNEQUFPO0FBQzdCLE9BQU8sb0JBQW9CLEVBQUUsbUJBQU8sQ0FBQyw2RkFBd0I7QUFDN0QsT0FBTyw0QkFBNEI7QUFDbkMsT0FBTyxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLHlEQUFVO0FBQ2pELE9BQU8sb0JBQW9CO0FBQzNCLE9BQU8sa0JBQWtCLEVBQUUsbUJBQU8sQ0FBQywyREFBVzs7QUFFOUMsZ0NBQWdDLG1CQUFlO0FBQy9DLEVBQUUsMkdBQStCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0RBQXNEO0FBQy9EO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxJQUFJLGVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsdURBQXVELE9BQU8sS0FBSyxTQUFTO0FBQzVFO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztB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O0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvbm9kZWpzL3BhcmFsbGVsLWJ1ZmZlcmVkLXJ1bm5lci5qcz9jZjVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSB0ZXN0IFJ1bm5lciB0aGF0IHVzZXMgYSB7QGxpbmsgbW9kdWxlOmJ1ZmZlcmVkLXdvcmtlci1wb29sfS5cbiAqIEBtb2R1bGUgcGFyYWxsZWwtYnVmZmVyZWQtcnVubmVyXG4gKiBAcHJpdmF0ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgUnVubmVyID0gcmVxdWlyZSgnLi4vcnVubmVyJyk7XG5jb25zdCB7RVZFTlRfUlVOX0JFR0lOLCBFVkVOVF9SVU5fRU5EfSA9IFJ1bm5lci5jb25zdGFudHM7XG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21vY2hhOnBhcmFsbGVsOnBhcmFsbGVsLWJ1ZmZlcmVkLXJ1bm5lcicpO1xuY29uc3Qge0J1ZmZlcmVkV29ya2VyUG9vbH0gPSByZXF1aXJlKCcuL2J1ZmZlcmVkLXdvcmtlci1wb29sJyk7XG5jb25zdCB7c2V0SW50ZXJ2YWwsIGNsZWFySW50ZXJ2YWx9ID0gZ2xvYmFsO1xuY29uc3Qge2NyZWF0ZU1hcCwgY29uc3RhbnRzfSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5jb25zdCB7TU9DSEFfSURfUFJPUF9OQU1FfSA9IGNvbnN0YW50cztcbmNvbnN0IHtjcmVhdGVGYXRhbEVycm9yfSA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuXG5jb25zdCBERUZBVUxUX1dPUktFUl9SRVBPUlRFUiA9IHJlcXVpcmUucmVzb2x2ZShcbiAgJy4vcmVwb3J0ZXJzL3BhcmFsbGVsLWJ1ZmZlcmVkJ1xuKTtcblxuLyoqXG4gKiBMaXN0IG9mIG9wdGlvbnMgdG8gX25vdF8gc2VyaWFsaXplIGZvciB0cmFuc21pc3Npb24gdG8gd29ya2Vyc1xuICovXG5jb25zdCBERU5ZX09QVElPTlMgPSBbXG4gICdnbG9iYWxTZXR1cCcsXG4gICdnbG9iYWxUZWFyZG93bicsXG4gICdwYXJhbGxlbCcsXG4gICdwJyxcbiAgJ2pvYnMnLFxuICAnaidcbl07XG5cbi8qKlxuICogT3V0cHV0cyBhIGRlYnVnIHN0YXRlbWVudCB3aXRoIHdvcmtlciBzdGF0c1xuICogQHBhcmFtIHtCdWZmZXJlZFdvcmtlclBvb2x9IHBvb2wgLSBXb3JrZXIgcG9vbFxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgZGVidWdTdGF0cyA9IHBvb2wgPT4ge1xuICBjb25zdCB7dG90YWxXb3JrZXJzLCBidXN5V29ya2VycywgaWRsZVdvcmtlcnMsIHBlbmRpbmdUYXNrc30gPSBwb29sLnN0YXRzKCk7XG4gIGRlYnVnKFxuICAgICclZC8lZCBidXN5IHdvcmtlcnM7ICVkIGlkbGU7ICVkIHRhc2tzIHF1ZXVlZCcsXG4gICAgYnVzeVdvcmtlcnMsXG4gICAgdG90YWxXb3JrZXJzLFxuICAgIGlkbGVXb3JrZXJzLFxuICAgIHBlbmRpbmdUYXNrc1xuICApO1xufTtcblxuLyoqXG4gKiBUaGUgaW50ZXJ2YWwgYXQgd2hpY2ggd2Ugd2lsbCBkaXNwbGF5IHN0YXRzIGZvciB3b3JrZXIgcHJvY2Vzc2VzIGluIGRlYnVnIG1vZGVcbiAqL1xuY29uc3QgREVCVUdfU1RBVFNfSU5URVJWQUwgPSA1MDAwO1xuXG5jb25zdCBBQk9SVEVEID0gJ0FCT1JURUQnO1xuY29uc3QgSURMRSA9ICdJRExFJztcbmNvbnN0IEFCT1JUSU5HID0gJ0FCT1JUSU5HJztcbmNvbnN0IFJVTk5JTkcgPSAnUlVOTklORyc7XG5jb25zdCBCQUlMSU5HID0gJ0JBSUxJTkcnO1xuY29uc3QgQkFJTEVEID0gJ0JBSUxFRCc7XG5jb25zdCBDT01QTEVURSA9ICdDT01QTEVURSc7XG5cbmNvbnN0IHN0YXRlcyA9IGNyZWF0ZU1hcCh7XG4gIFtJRExFXTogbmV3IFNldChbUlVOTklORywgQUJPUlRJTkddKSxcbiAgW1JVTk5JTkddOiBuZXcgU2V0KFtDT01QTEVURSwgQkFJTElORywgQUJPUlRJTkddKSxcbiAgW0NPTVBMRVRFXTogbmV3IFNldCgpLFxuICBbQUJPUlRFRF06IG5ldyBTZXQoKSxcbiAgW0FCT1JUSU5HXTogbmV3IFNldChbQUJPUlRFRF0pLFxuICBbQkFJTElOR106IG5ldyBTZXQoW0JBSUxFRCwgQUJPUlRJTkddKSxcbiAgW0JBSUxFRF06IG5ldyBTZXQoW0NPTVBMRVRFLCBBQk9SVElOR10pXG59KTtcblxuLyoqXG4gKiBUaGlzIGBSdW5uZXJgIGRlbGVnYXRlcyB0ZXN0cyBydW5zIHRvIHdvcmtlciB0aHJlYWRzLiAgRG9lcyBub3QgZXhlY3V0ZSBhbnlcbiAqIHtAbGluayBSdW5uYWJsZX1zIGJ5IGl0c2VsZiFcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgUGFyYWxsZWxCdWZmZXJlZFJ1bm5lciBleHRlbmRzIFJ1bm5lciB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIGxldCBzdGF0ZSA9IElETEU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfc3RhdGUnLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH0sXG4gICAgICBzZXQobmV3U3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlc1tzdGF0ZV0uaGFzKG5ld1N0YXRlKSkge1xuICAgICAgICAgIHN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHN0YXRlIHRyYW5zaXRpb246ICR7c3RhdGV9ID0+ICR7bmV3U3RhdGV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX3dvcmtlclJlcG9ydGVyID0gREVGQVVMVF9XT1JLRVJfUkVQT1JURVI7XG4gICAgdGhpcy5fbGlua1BhcnRpYWxPYmplY3RzID0gZmFsc2U7XG4gICAgdGhpcy5fbGlua2VkT2JqZWN0TWFwID0gbmV3IE1hcCgpO1xuXG4gICAgdGhpcy5vbmNlKFJ1bm5lci5jb25zdGFudHMuRVZFTlRfUlVOX0VORCwgKCkgPT4ge1xuICAgICAgdGhpcy5fc3RhdGUgPSBDT01QTEVURTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbWFwcGluZyBmdW5jdGlvbiB0byBlbnF1ZXVlIGEgZmlsZSBpbiB0aGUgd29ya2VyIHBvb2wgYW5kIHJldHVybiByZXN1bHRzIG9mIGl0cyBleGVjdXRpb24uXG4gICAqIEBwYXJhbSB7QnVmZmVyZWRXb3JrZXJQb29sfSBwb29sIC0gV29ya2VyIHBvb2xcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIC0gTW9jaGEgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7RmlsZVJ1bm5lcn0gTWFwcGluZyBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZUZpbGVSdW5uZXIocG9vbCwgb3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqIEVtaXRzIGV2ZW50IGFuZCBzZXRzIGBCQUlMSU5HYCBzdGF0ZSwgaWYgbmVjZXNzYXJ5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIEV2ZW50IGhhdmluZyBgZXZlbnROYW1lYCwgbWF5YmUgYGRhdGFgIGFuZCBtYXliZSBgZXJyb3JgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZhaWx1cmVDb3VudCAtIEZhaWx1cmUgY291bnRcbiAgICAgKi9cbiAgICBjb25zdCBlbWl0RXZlbnQgPSAoZXZlbnQsIGZhaWx1cmVDb3VudCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KGV2ZW50LmV2ZW50TmFtZSwgZXZlbnQuZGF0YSwgZXZlbnQuZXJyb3IpO1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9zdGF0ZSAhPT0gQkFJTElORyAmJlxuICAgICAgICBldmVudC5kYXRhICYmXG4gICAgICAgIGV2ZW50LmRhdGEuX2JhaWwgJiZcbiAgICAgICAgKGZhaWx1cmVDb3VudCB8fCBldmVudC5lcnJvcilcbiAgICAgICkge1xuICAgICAgICBkZWJ1ZygncnVuKCk6IG5vbnplcm8gZmFpbHVyZSBjb3VudCAmIGZvdW5kIGJhaWwgZmxhZycpO1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIGxldCB0aGUgZXZlbnRzIGNvbXBsZXRlIGZvciB0aGlzIGZpbGUsIGFzIHRoZSB3b3JrZXJcbiAgICAgICAgLy8gc2hvdWxkIHJ1biBhbnkgY2xlYW51cCBob29rc1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IEJBSUxJTkc7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGFuIGV2ZW50LCByZWN1cnNpdmVseSBmaW5kIGFueSBvYmplY3RzIGluIGl0cyBkYXRhIHRoYXQgaGF2ZSBJRCdzLCBhbmQgY3JlYXRlIG9iamVjdCByZWZlcmVuY2VzIHRvIGFscmVhZHktc2VlbiBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIEV2ZW50IGhhdmluZyBgZXZlbnROYW1lYCwgbWF5YmUgYGRhdGFgIGFuZCBtYXliZSBgZXJyb3JgXG4gICAgICovXG4gICAgY29uc3QgbGlua0V2ZW50ID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3Qgc3RhY2sgPSBbe3BhcmVudDogZXZlbnQsIHByb3A6ICdkYXRhJ31dO1xuICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB7cGFyZW50LCBwcm9wfSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBjb25zdCBvYmogPSBwYXJlbnRbcHJvcF07XG4gICAgICAgIGxldCBuZXdPYmo7XG4gICAgICAgIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpZiAob2JqW01PQ0hBX0lEX1BST1BfTkFNRV0pIHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gb2JqW01PQ0hBX0lEX1BST1BfTkFNRV07XG4gICAgICAgICAgICBuZXdPYmogPSB0aGlzLl9saW5rZWRPYmplY3RNYXAuaGFzKGlkKVxuICAgICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24odGhpcy5fbGlua2VkT2JqZWN0TWFwLmdldChpZCksIG9iailcbiAgICAgICAgICAgICAgOiBvYmo7XG4gICAgICAgICAgICB0aGlzLl9saW5rZWRPYmplY3RNYXAuc2V0KGlkLCBuZXdPYmopO1xuICAgICAgICAgICAgcGFyZW50W3Byb3BdID0gbmV3T2JqO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVGYXRhbEVycm9yKFxuICAgICAgICAgICAgICAnT2JqZWN0IG1pc3NpbmcgSUQgcmVjZWl2ZWQgaW4gZXZlbnQgZGF0YScsXG4gICAgICAgICAgICAgIG9ialxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmtleXMobmV3T2JqKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZVtNT0NIQV9JRF9QUk9QX05BTUVdKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHtvYmo6IHZhbHVlLCBwYXJlbnQ6IG5ld09iaiwgcHJvcDoga2V5fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGFzeW5jIGZpbGUgPT4ge1xuICAgICAgZGVidWcoJ3J1bigpOiBlbnF1ZXVlaW5nIHRlc3QgZmlsZSAlcycsIGZpbGUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qge2ZhaWx1cmVDb3VudCwgZXZlbnRzfSA9IGF3YWl0IHBvb2wucnVuKGZpbGUsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gQkFJTEVEKSB7XG4gICAgICAgICAgLy8gc2hvcnQtY2lyY3VpdCBhZnRlciBhIGdyYWNlZnVsIGJhaWwuIGlmIHRoaXMgaGFwcGVucyxcbiAgICAgICAgICAvLyBzb21lIG90aGVyIHdvcmtlciBoYXMgYmFpbGVkLlxuICAgICAgICAgIC8vIFRPRE86IGRldGVybWluZSBpZiB0aGlzIGlzIHRoZSBkZXNpcmVkIGJlaGF2aW9yLCBvciBpZiB3ZVxuICAgICAgICAgIC8vIHNob3VsZCByZXBvcnQgdGhlIGV2ZW50cyBvZiB0aGlzIHJ1biBhbnl3YXkuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFxuICAgICAgICAgICdydW4oKTogY29tcGxldGVkIHJ1biBvZiBmaWxlICVzOyAlZCBmYWlsdXJlcyAvICVkIGV2ZW50cycsXG4gICAgICAgICAgZmlsZSxcbiAgICAgICAgICBmYWlsdXJlQ291bnQsXG4gICAgICAgICAgZXZlbnRzLmxlbmd0aFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmZhaWx1cmVzICs9IGZhaWx1cmVDb3VudDsgLy8gY2FuIHRoaXMgZXZlciBiZSBub24tbnVtZXJpYz9cbiAgICAgICAgbGV0IGV2ZW50ID0gZXZlbnRzLnNoaWZ0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2xpbmtQYXJ0aWFsT2JqZWN0cykge1xuICAgICAgICAgIHdoaWxlIChldmVudCkge1xuICAgICAgICAgICAgbGlua0V2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIGVtaXRFdmVudChldmVudCwgZmFpbHVyZUNvdW50KTtcbiAgICAgICAgICAgIGV2ZW50ID0gZXZlbnRzLnNoaWZ0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoaWxlIChldmVudCkge1xuICAgICAgICAgICAgZW1pdEV2ZW50KGV2ZW50LCBmYWlsdXJlQ291bnQpO1xuICAgICAgICAgICAgZXZlbnQgPSBldmVudHMuc2hpZnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBCQUlMSU5HKSB7XG4gICAgICAgICAgZGVidWcoJ3J1bigpOiB0ZXJtaW5hdGluZyBwb29sIGR1ZSB0byBcImJhaWxcIiBmbGFnJyk7XG4gICAgICAgICAgdGhpcy5fc3RhdGUgPSBCQUlMRUQ7XG4gICAgICAgICAgYXdhaXQgcG9vbC50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gQkFJTEVEIHx8IHRoaXMuX3N0YXRlID09PSBBQk9SVElORykge1xuICAgICAgICAgIGRlYnVnKFxuICAgICAgICAgICAgJ3J1bigpOiB3b3JrZXIgcG9vbCB0ZXJtaW5hdGVkIHdpdGggaW50ZW50OyBza2lwcGluZyBmaWxlICVzJyxcbiAgICAgICAgICAgIGZpbGVcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoaXMgaXMgYW4gdW5jYXVnaHQgZXhjZXB0aW9uXG4gICAgICAgICAgZGVidWcoJ3J1bigpOiBlbmNvdW50ZXJlZCB1bmNhdWdodCBleGNlcHRpb246ICVPJywgZXJyKTtcbiAgICAgICAgICBpZiAodGhpcy5hbGxvd1VuY2F1Z2h0KSB7XG4gICAgICAgICAgICAvLyBzdGlsbCBoYXZlIHRvIGNsZWFuIHVwXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEFCT1JUSU5HO1xuICAgICAgICAgICAgYXdhaXQgcG9vbC50ZXJtaW5hdGUodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZGVidWcoJ3J1bigpOiBkb25lIHJ1bm5pbmcgZmlsZSAlcycsIGZpbGUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogTGlzdGVuIG9uIGBQcm9jZXNzLlNJR0lOVGA7IHRlcm1pbmF0ZSBwb29sIGlmIGNhdWdodC5cbiAgICogUmV0dXJucyB0aGUgbGlzdGVuZXIgZm9yIGxhdGVyIGNhbGwgdG8gYHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoKWAuXG4gICAqIEBwYXJhbSB7QnVmZmVyZWRXb3JrZXJQb29sfSBwb29sIC0gV29ya2VyIHBvb2xcbiAgICogQHJldHVybnMge1NpZ0ludExpc3RlbmVyfSBMaXN0ZW5lclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2JpbmRTaWdJbnRMaXN0ZW5lcihwb29sKSB7XG4gICAgY29uc3Qgc2lnSW50TGlzdGVuZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICBkZWJ1ZygncnVuKCk6IGNhdWdodCBhIFNJR0lOVCcpO1xuICAgICAgdGhpcy5fc3RhdGUgPSBBQk9SVElORztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZGVidWcoJ3J1bigpOiBmb3JjZS10ZXJtaW5hdGluZyB3b3JrZXIgcG9vbCcpO1xuICAgICAgICBhd2FpdCBwb29sLnRlcm1pbmF0ZSh0cnVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIGBFcnJvciB3aGlsZSBhdHRlbXB0aW5nIHRvIGZvcmNlLXRlcm1pbmF0ZSB3b3JrZXIgcG9vbDogJHtlcnJ9YFxuICAgICAgICApO1xuICAgICAgICBwcm9jZXNzLmV4aXRDb2RlID0gMTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgIGRlYnVnKCdydW4oKTogaW1taW5lbnQgZGVhdGgnKTtcbiAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEFCT1JURUQ7XG4gICAgICAgICAgcHJvY2Vzcy5raWxsKHByb2Nlc3MucGlkLCAnU0lHSU5UJyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBwcm9jZXNzLm9uY2UoJ1NJR0lOVCcsIHNpZ0ludExpc3RlbmVyKTtcblxuICAgIHJldHVybiBzaWdJbnRMaXN0ZW5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIE1vY2hhIHRlc3RzIGJ5IGNyZWF0aW5nIGEgdGhyZWFkIHBvb2wsIHRoZW4gZGVsZWdhdGluZyB3b3JrIHRvIHRoZVxuICAgKiB3b3JrZXIgdGhyZWFkcy5cbiAgICpcbiAgICogRWFjaCB3b3JrZXIgcmVjZWl2ZXMgb25lIGZpbGUsIGFuZCBhcyB3b3JrZXJzIGJlY29tZSBhdmFpbGFibGUsIHRoZXkgdGFrZSBhXG4gICAqIGZpbGUgZnJvbSB0aGUgcXVldWUgYW5kIHJ1biBpdC4gVGhlIHdvcmtlciB0aHJlYWQgZXhlY3V0aW9uIGlzIHRyZWF0ZWQgbGlrZVxuICAgKiBhbiBSUEMtLWl0IHJldHVybnMgYSBgUHJvbWlzZWAgY29udGFpbmluZyBzZXJpYWxpemVkIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICAgKiBydW4uICBUaGUgaW5mb3JtYXRpb24gaXMgcHJvY2Vzc2VkIGFzIGl0J3MgcmVjZWl2ZWQsIGFuZCBlbWl0dGVkIHRvIGFcbiAgICoge0BsaW5rIFJlcG9ydGVyfSwgd2hpY2ggaXMgbGlrZWx5IGxpc3RlbmluZyBmb3IgdGhlc2UgZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxlZCB3aXRoIGFuIGV4aXQgY29kZSBjb3JyZXNwb25kaW5nIHRvXG4gICAqIG51bWJlciBvZiB0ZXN0IGZhaWx1cmVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBvcHRzLmZpbGVzIC0gRmlsZXMgdG8gcnVuXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0cy5vcHRpb25zIC0gY29tbWFuZC1saW5lIG9wdGlvbnNcbiAgICovXG4gIHJ1bihjYWxsYmFjaywge2ZpbGVzLCBvcHRpb25zID0ge319ID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBMaXN0ZW5lciBvbiBgUHJvY2Vzcy5TSUdJTlRgIHdoaWNoIHRyaWVzIHRvIGNsZWFubHkgdGVybWluYXRlIHRoZSB3b3JrZXIgcG9vbC5cbiAgICAgKi9cbiAgICBsZXQgc2lnSW50TGlzdGVuZXI7XG5cbiAgICAvLyBhc3NpZ24gdGhlIHJlcG9ydGVyIHRoZSB3b3JrZXIgd2lsbCB1c2UsIHdoaWNoIHdpbGwgYmUgZGlmZmVyZW50IHRoYW4gdGhlXG4gICAgLy8gbWFpbiBwcm9jZXNzJyByZXBvcnRlclxuICAgIG9wdGlvbnMgPSB7Li4ub3B0aW9ucywgcmVwb3J0ZXI6IHRoaXMuX3dvcmtlclJlcG9ydGVyfTtcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gc2hvdWxkIF9ub3RfIHJldHVybiBhIGBQcm9taXNlYDsgaXRzIHBhcmVudCAoYFJ1bm5lciNydW5gKVxuICAgIC8vIHJldHVybnMgdGhpcyBpbnN0YW5jZSwgc28gdGhpcyBzaG91bGQgZG8gdGhlIHNhbWUuIEhvd2V2ZXIsIHdlIHdhbnQgdG8gbWFrZVxuICAgIC8vIHVzZSBvZiBgYXN5bmNgL2Bhd2FpdGAsIHNvIHdlIHVzZSB0aGlzIElJRkUuXG4gICAgKGFzeW5jICgpID0+IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBpcyBhbiBpbnRlcnZhbCB0aGF0IG91dHB1dHMgc3RhdHMgYWJvdXQgdGhlIHdvcmtlciBwb29sIGV2ZXJ5IHNvIG9mdGVuXG4gICAgICAgKi9cbiAgICAgIGxldCBkZWJ1Z0ludGVydmFsO1xuXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtCdWZmZXJlZFdvcmtlclBvb2x9XG4gICAgICAgKi9cbiAgICAgIGxldCBwb29sO1xuXG4gICAgICB0cnkge1xuICAgICAgICBwb29sID0gQnVmZmVyZWRXb3JrZXJQb29sLmNyZWF0ZSh7bWF4V29ya2Vyczogb3B0aW9ucy5qb2JzfSk7XG5cbiAgICAgICAgc2lnSW50TGlzdGVuZXIgPSB0aGlzLl9iaW5kU2lnSW50TGlzdGVuZXIocG9vbCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVidWdJbnRlcnZhbCA9IHNldEludGVydmFsKFxuICAgICAgICAgICgpID0+IGRlYnVnU3RhdHMocG9vbCksXG4gICAgICAgICAgREVCVUdfU1RBVFNfSU5URVJWQUxcbiAgICAgICAgKS51bnJlZigpO1xuXG4gICAgICAgIC8vIHRoaXMgaXMgc2V0IGZvciB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxpbmcgaW4gYFJ1bm5lciN1bmNhdWdodGBcbiAgICAgICAgLy8gVE9ETzogYFJ1bm5lcmAgc2hvdWxkIGJlIHVzaW5nIGEgc3RhdGUgbWFjaGluZSBpbnN0ZWFkLlxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IFJVTk5JTkc7XG5cbiAgICAgICAgdGhpcy5lbWl0KEVWRU5UX1JVTl9CRUdJTik7XG5cbiAgICAgICAgb3B0aW9ucyA9IHsuLi5vcHRpb25zfTtcbiAgICAgICAgREVOWV9PUFRJT05TLmZvckVhY2gob3B0ID0+IHtcbiAgICAgICAgICBkZWxldGUgb3B0aW9uc1tvcHRdO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKFxuICAgICAgICAgIGZpbGVzLm1hcCh0aGlzLl9jcmVhdGVGaWxlUnVubmVyKHBvb2wsIG9wdGlvbnMpKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIG5vdGUgdGhhdCBwb29sIG1heSBhbHJlYWR5IGJlIHRlcm1pbmF0ZWQgZHVlIHRvIC0tYmFpbFxuICAgICAgICBhd2FpdCBwb29sLnRlcm1pbmF0ZSgpO1xuXG4gICAgICAgIHJlc3VsdHNcbiAgICAgICAgICAuZmlsdGVyKCh7c3RhdHVzfSkgPT4gc3RhdHVzID09PSAncmVqZWN0ZWQnKVxuICAgICAgICAgIC5mb3JFYWNoKCh7cmVhc29ufSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dVbmNhdWdodCkge1xuICAgICAgICAgICAgICAvLyB5ZXAsIGp1c3QgdGhlIGZpcnN0IG9uZS5cbiAgICAgICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gXCJyZWplY3RlZFwiIHdpbGwgY29ycmVzcG9uZCB0byB1bmNhdWdodCBleGNlcHRpb25zLlxuICAgICAgICAgICAgLy8gdW5saWtlIHRoZSBzZXJpYWwgcnVubmVyLCB0aGUgcGFyYWxsZWwgcnVubmVyIGNhbiBhbHdheXMgcmVjb3Zlci5cbiAgICAgICAgICAgIHRoaXMudW5jYXVnaHQocmVhc29uKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IEFCT1JUSU5HKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KEVWRU5UX1JVTl9FTkQpO1xuICAgICAgICBkZWJ1ZygncnVuKCk6IGNvbXBsZXRpbmcgd2l0aCBmYWlsdXJlIGNvdW50ICVkJywgdGhpcy5mYWlsdXJlcyk7XG4gICAgICAgIGNhbGxiYWNrKHRoaXMuZmFpbHVyZXMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIHRoaXMgYG5leHRUaWNrYCB0YWtlcyB1cyBvdXQgb2YgdGhlIGBQcm9taXNlYCBzY29wZSwgc28gdGhlXG4gICAgICAgIC8vIGV4Y2VwdGlvbiB3aWxsIG5vdCBiZSBjYXVnaHQgYW5kIHJldHVybmVkIGFzIGEgcmVqZWN0ZWQgYFByb21pc2VgLFxuICAgICAgICAvLyB3aGljaCB3b3VsZCBsZWFkIHRvIGFuIGB1bmhhbmRsZWRSZWplY3Rpb25gIGV2ZW50LlxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICBkZWJ1ZygncnVuKCk6IHJlLXRocm93aW5nIHVuY2F1Z2h0IGV4Y2VwdGlvbicpO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjbGVhckludGVydmFsKGRlYnVnSW50ZXJ2YWwpO1xuICAgICAgICBwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKCdTSUdJTlQnLCBzaWdJbnRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGUgcGFydGlhbCBvYmplY3QgbGlua2luZyBiZWhhdmlvcjsgdXNlZCBmb3IgYnVpbGRpbmcgb2JqZWN0IHJlZmVyZW5jZXMgZnJvbVxuICAgKiB1bmlxdWUgSUQncy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbdmFsdWVdIC0gSWYgYHRydWVgLCBlbmFibGUgcGFydGlhbCBvYmplY3QgbGlua2luZywgb3RoZXJ3aXNlIGRpc2FibGVcbiAgICogQHJldHVybnMge1J1bm5lcn1cbiAgICogQGNoYWluYWJsZVxuICAgKiBAcHVibGljXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIHRoaXMgcmVwb3J0ZXIgbmVlZHMgcHJvcGVyIG9iamVjdCByZWZlcmVuY2VzIHdoZW4gcnVuIGluIHBhcmFsbGVsIG1vZGVcbiAgICogY2xhc3MgTXlSZXBvcnRlcigpIHtcbiAgICogICBjb25zdHJ1Y3RvcihydW5uZXIpIHtcbiAgICogICAgIHRoaXMucnVubmVyLmxpbmtQYXJ0aWFsT2JqZWN0cyh0cnVlKVxuICAgKiAgICAgICAub24oRVZFTlRfU1VJVEVfQkVHSU4sIHN1aXRlID0+IHtcbiAgICAgICAgICAgICAvLyB0aGlzIFN1aXRlIG1heSBiZSB0aGUgc2FtZSBvYmplY3QuLi5cbiAgKiAgICAgICB9KVxuICAqICAgICAgIC5vbihFVkVOVF9URVNUX0JFR0lOLCB0ZXN0ID0+IHtcbiAgKiAgICAgICAgIC8vIC4uLmFzIHRoZSBgdGVzdC5wYXJlbnRgIHByb3BlcnR5XG4gICogICAgICAgfSk7XG4gICogICB9XG4gICogfVxuICAqL1xuICBsaW5rUGFydGlhbE9iamVjdHModmFsdWUpIHtcbiAgICB0aGlzLl9saW5rUGFydGlhbE9iamVjdHMgPSBCb29sZWFuKHZhbHVlKTtcbiAgICByZXR1cm4gc3VwZXIubGlua1BhcnRpYWxPYmplY3RzKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGlzIGNsYXNzIGlzIHRoZSBgUnVubmVyYCBpbiB1c2UsIHRoZW4gdGhpcyBpcyBnb2luZyB0byByZXR1cm4gYHRydWVgLlxuICAgKlxuICAgKiBGb3IgdXNlIGJ5IHJlcG9ydGVycy5cbiAgICogQHJldHVybnMge3RydWV9XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGlzUGFyYWxsZWxNb2RlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgYW4gYWx0ZXJuYXRlIHJlcG9ydGVyIGZvciB3b3JrZXIgcHJvY2Vzc2VzIHRvIHVzZS4gU3ViY2xhc3Nlc1xuICAgKiB1c2luZyB3b3JrZXIgcHJvY2Vzc2VzIHNob3VsZCBpbXBsZW1lbnQgdGhpcy5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIEFic29sdXRlIHBhdGggdG8gYWx0ZXJuYXRlIHJlcG9ydGVyIGZvciB3b3JrZXIgcHJvY2Vzc2VzIHRvIHVzZVxuICAgKiBAcmV0dXJucyB7UnVubmVyfVxuICAgKiBAdGhyb3dzIFdoZW4gaW4gc2VyaWFsIG1vZGVcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgd29ya2VyUmVwb3J0ZXIocmVwb3J0ZXIpIHtcbiAgICB0aGlzLl93b3JrZXJSZXBvcnRlciA9IHJlcG9ydGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGFyYWxsZWxCdWZmZXJlZFJ1bm5lcjtcblxuLyoqXG4gKiBMaXN0ZW5lciBmdW5jdGlvbiBpbnRlbmRlZCB0byBiZSBib3VuZCB0byBgUHJvY2Vzcy5TSUdJTlRgIGV2ZW50XG4gKiBAcHJpdmF0ZVxuICogQGNhbGxiYWNrIFNpZ0ludExpc3RlbmVyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gYWNjZXB0aW5nIGEgdGVzdCBmaWxlIHBhdGggYW5kIHJldHVybmluZyB0aGUgcmVzdWx0cyBvZiBhIHRlc3QgcnVuXG4gKiBAcHJpdmF0ZVxuICogQGNhbGxiYWNrIEZpbGVSdW5uZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZSAtIEZpbGUgdG8gcnVuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxTZXJpYWxpemVkV29ya2VyUmVzdWx0Pn1cbiAqL1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/nodejs/parallel-buffered-runner.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/nodejs/reporters/parallel-buffered.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mocha/lib/nodejs/reporters/parallel-buffered.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * \"Buffered\" reporter used internally by a worker process when running in parallel mode.\n * @module nodejs/reporters/parallel-buffered\n * @public\n */\n\n\n\n/**\n * Module dependencies.\n */\n\nconst {\n  EVENT_SUITE_BEGIN,\n  EVENT_SUITE_END,\n  EVENT_TEST_FAIL,\n  EVENT_TEST_PASS,\n  EVENT_TEST_PENDING,\n  EVENT_TEST_BEGIN,\n  EVENT_TEST_END,\n  EVENT_TEST_RETRY,\n  EVENT_DELAY_BEGIN,\n  EVENT_DELAY_END,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_RUN_END\n} = (__webpack_require__(/*! ../../runner */ \"(ssr)/./node_modules/mocha/lib/runner.js\").constants);\nconst {SerializableEvent, SerializableWorkerResult} = __webpack_require__(/*! ../serializer */ \"(ssr)/./node_modules/mocha/lib/nodejs/serializer.js\");\nconst debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")('mocha:reporters:buffered');\nconst Base = __webpack_require__(/*! ../../reporters/base */ \"(ssr)/./node_modules/mocha/lib/reporters/base.js\");\n\n/**\n * List of events to listen to; these will be buffered and sent\n * when `Mocha#run` is complete (via {@link ParallelBuffered#done}).\n */\nconst EVENT_NAMES = [\n  EVENT_SUITE_BEGIN,\n  EVENT_SUITE_END,\n  EVENT_TEST_BEGIN,\n  EVENT_TEST_PENDING,\n  EVENT_TEST_FAIL,\n  EVENT_TEST_PASS,\n  EVENT_TEST_RETRY,\n  EVENT_TEST_END,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END\n];\n\n/**\n * Like {@link EVENT_NAMES}, except we expect these events to only be emitted\n * by the `Runner` once.\n */\nconst ONCE_EVENT_NAMES = [EVENT_DELAY_BEGIN, EVENT_DELAY_END];\n\n/**\n * The `ParallelBuffered` reporter is used by each worker process in \"parallel\"\n * mode, by default.  Instead of reporting to `STDOUT`, etc., it retains a\n * list of events it receives and hands these off to the callback passed into\n * {@link Mocha#run}. That callback will then return the data to the main\n * process.\n * @public\n */\nclass ParallelBuffered extends Base {\n  /**\n   * Calls {@link ParallelBuffered#createListeners}\n   * @param {Runner} runner\n   */\n  constructor(runner, opts) {\n    super(runner, opts);\n\n    /**\n     * Retained list of events emitted from the {@link Runner} instance.\n     * @type {BufferedEvent[]}\n     * @public\n     */\n    this.events = [];\n\n    /**\n     * Map of `Runner` event names to listeners (for later teardown)\n     * @public\n     * @type {Map<string,EventListener>}\n     */\n    this.listeners = new Map();\n\n    this.createListeners(runner);\n  }\n\n  /**\n   * Returns a new listener which saves event data in memory to\n   * {@link ParallelBuffered#events}. Listeners are indexed by `eventName` and stored\n   * in {@link ParallelBuffered#listeners}. This is a defensive measure, so that we\n   * don't a) leak memory or b) remove _other_ listeners that may not be\n   * associated with this reporter.\n   *\n   * Subclasses could override this behavior.\n   *\n   * @public\n   * @param {string} eventName - Name of event to create listener for\n   * @returns {EventListener}\n   */\n  createListener(eventName) {\n    const listener = (runnable, err) => {\n      this.events.push(SerializableEvent.create(eventName, runnable, err));\n    };\n    return this.listeners.set(eventName, listener).get(eventName);\n  }\n\n  /**\n   * Creates event listeners (using {@link ParallelBuffered#createListener}) for each\n   * reporter-relevant event emitted by a {@link Runner}. This array is drained when\n   * {@link ParallelBuffered#done} is called by {@link Runner#run}.\n   *\n   * Subclasses could override this behavior.\n   * @public\n   * @param {Runner} runner - Runner instance\n   * @returns {ParallelBuffered}\n   * @chainable\n   */\n  createListeners(runner) {\n    EVENT_NAMES.forEach(evt => {\n      runner.on(evt, this.createListener(evt));\n    });\n    ONCE_EVENT_NAMES.forEach(evt => {\n      runner.once(evt, this.createListener(evt));\n    });\n\n    runner.once(EVENT_RUN_END, () => {\n      debug('received EVENT_RUN_END');\n      this.listeners.forEach((listener, evt) => {\n        runner.removeListener(evt, listener);\n        this.listeners.delete(evt);\n      });\n    });\n\n    return this;\n  }\n\n  /**\n   * Calls the {@link Mocha#run} callback (`callback`) with the test failure\n   * count and the array of {@link BufferedEvent} objects. Resets the array.\n   *\n   * This is called directly by `Runner#run` and should not be called by any other consumer.\n   *\n   * Subclasses could override this.\n   *\n   * @param {number} failures - Number of failed tests\n   * @param {Function} callback - The callback passed to {@link Mocha#run}.\n   * @public\n   */\n  done(failures, callback) {\n    callback(SerializableWorkerResult.create(this.events, failures));\n    this.events = []; // defensive\n  }\n}\n\n/**\n * Serializable event data from a `Runner`.  Keys of the `data` property\n * beginning with `__` will be converted into a function which returns the value\n * upon deserialization.\n * @typedef {Object} BufferedEvent\n * @property {string} name - Event name\n * @property {object} data - Event parameters\n */\n\nmodule.exports = ParallelBuffered;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL25vZGVqcy9yZXBvcnRlcnMvcGFyYWxsZWwtYnVmZmVyZWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSwrRkFBaUM7QUFDckMsT0FBTyw2Q0FBNkMsRUFBRSxtQkFBTyxDQUFDLDBFQUFlO0FBQzdFLGNBQWMsbUJBQU8sQ0FBQyxzREFBTztBQUM3QixhQUFhLG1CQUFPLENBQUMsOEVBQXNCOztBQUUzQztBQUNBLGdDQUFnQztBQUNoQyxzQ0FBc0MsNEJBQTRCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxrQkFBa0I7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELGNBQWM7QUFDL0QsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLDhCQUE4QjtBQUNwQyxTQUFTLGlDQUFpQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLHNDQUFzQztBQUMzRSwyQ0FBMkMsYUFBYTtBQUN4RCxNQUFNLDZCQUE2QixjQUFjLGlCQUFpQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVUsbUNBQW1DLGdCQUFnQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9ub2RlanMvcmVwb3J0ZXJzL3BhcmFsbGVsLWJ1ZmZlcmVkLmpzPzE5NWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBcIkJ1ZmZlcmVkXCIgcmVwb3J0ZXIgdXNlZCBpbnRlcm5hbGx5IGJ5IGEgd29ya2VyIHByb2Nlc3Mgd2hlbiBydW5uaW5nIGluIHBhcmFsbGVsIG1vZGUuXG4gKiBAbW9kdWxlIG5vZGVqcy9yZXBvcnRlcnMvcGFyYWxsZWwtYnVmZmVyZWRcbiAqIEBwdWJsaWNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCB7XG4gIEVWRU5UX1NVSVRFX0JFR0lOLFxuICBFVkVOVF9TVUlURV9FTkQsXG4gIEVWRU5UX1RFU1RfRkFJTCxcbiAgRVZFTlRfVEVTVF9QQVNTLFxuICBFVkVOVF9URVNUX1BFTkRJTkcsXG4gIEVWRU5UX1RFU1RfQkVHSU4sXG4gIEVWRU5UX1RFU1RfRU5ELFxuICBFVkVOVF9URVNUX1JFVFJZLFxuICBFVkVOVF9ERUxBWV9CRUdJTixcbiAgRVZFTlRfREVMQVlfRU5ELFxuICBFVkVOVF9IT09LX0JFR0lOLFxuICBFVkVOVF9IT09LX0VORCxcbiAgRVZFTlRfUlVOX0VORFxufSA9IHJlcXVpcmUoJy4uLy4uL3J1bm5lcicpLmNvbnN0YW50cztcbmNvbnN0IHtTZXJpYWxpemFibGVFdmVudCwgU2VyaWFsaXphYmxlV29ya2VyUmVzdWx0fSA9IHJlcXVpcmUoJy4uL3NlcmlhbGl6ZXInKTtcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9jaGE6cmVwb3J0ZXJzOmJ1ZmZlcmVkJyk7XG5jb25zdCBCYXNlID0gcmVxdWlyZSgnLi4vLi4vcmVwb3J0ZXJzL2Jhc2UnKTtcblxuLyoqXG4gKiBMaXN0IG9mIGV2ZW50cyB0byBsaXN0ZW4gdG87IHRoZXNlIHdpbGwgYmUgYnVmZmVyZWQgYW5kIHNlbnRcbiAqIHdoZW4gYE1vY2hhI3J1bmAgaXMgY29tcGxldGUgKHZpYSB7QGxpbmsgUGFyYWxsZWxCdWZmZXJlZCNkb25lfSkuXG4gKi9cbmNvbnN0IEVWRU5UX05BTUVTID0gW1xuICBFVkVOVF9TVUlURV9CRUdJTixcbiAgRVZFTlRfU1VJVEVfRU5ELFxuICBFVkVOVF9URVNUX0JFR0lOLFxuICBFVkVOVF9URVNUX1BFTkRJTkcsXG4gIEVWRU5UX1RFU1RfRkFJTCxcbiAgRVZFTlRfVEVTVF9QQVNTLFxuICBFVkVOVF9URVNUX1JFVFJZLFxuICBFVkVOVF9URVNUX0VORCxcbiAgRVZFTlRfSE9PS19CRUdJTixcbiAgRVZFTlRfSE9PS19FTkRcbl07XG5cbi8qKlxuICogTGlrZSB7QGxpbmsgRVZFTlRfTkFNRVN9LCBleGNlcHQgd2UgZXhwZWN0IHRoZXNlIGV2ZW50cyB0byBvbmx5IGJlIGVtaXR0ZWRcbiAqIGJ5IHRoZSBgUnVubmVyYCBvbmNlLlxuICovXG5jb25zdCBPTkNFX0VWRU5UX05BTUVTID0gW0VWRU5UX0RFTEFZX0JFR0lOLCBFVkVOVF9ERUxBWV9FTkRdO1xuXG4vKipcbiAqIFRoZSBgUGFyYWxsZWxCdWZmZXJlZGAgcmVwb3J0ZXIgaXMgdXNlZCBieSBlYWNoIHdvcmtlciBwcm9jZXNzIGluIFwicGFyYWxsZWxcIlxuICogbW9kZSwgYnkgZGVmYXVsdC4gIEluc3RlYWQgb2YgcmVwb3J0aW5nIHRvIGBTVERPVVRgLCBldGMuLCBpdCByZXRhaW5zIGFcbiAqIGxpc3Qgb2YgZXZlbnRzIGl0IHJlY2VpdmVzIGFuZCBoYW5kcyB0aGVzZSBvZmYgdG8gdGhlIGNhbGxiYWNrIHBhc3NlZCBpbnRvXG4gKiB7QGxpbmsgTW9jaGEjcnVufS4gVGhhdCBjYWxsYmFjayB3aWxsIHRoZW4gcmV0dXJuIHRoZSBkYXRhIHRvIHRoZSBtYWluXG4gKiBwcm9jZXNzLlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBQYXJhbGxlbEJ1ZmZlcmVkIGV4dGVuZHMgQmFzZSB7XG4gIC8qKlxuICAgKiBDYWxscyB7QGxpbmsgUGFyYWxsZWxCdWZmZXJlZCNjcmVhdGVMaXN0ZW5lcnN9XG4gICAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJ1bm5lciwgb3B0cykge1xuICAgIHN1cGVyKHJ1bm5lciwgb3B0cyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXRhaW5lZCBsaXN0IG9mIGV2ZW50cyBlbWl0dGVkIGZyb20gdGhlIHtAbGluayBSdW5uZXJ9IGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtCdWZmZXJlZEV2ZW50W119XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMuZXZlbnRzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBNYXAgb2YgYFJ1bm5lcmAgZXZlbnQgbmFtZXMgdG8gbGlzdGVuZXJzIChmb3IgbGF0ZXIgdGVhcmRvd24pXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLEV2ZW50TGlzdGVuZXI+fVxuICAgICAqL1xuICAgIHRoaXMubGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuXG4gICAgdGhpcy5jcmVhdGVMaXN0ZW5lcnMocnVubmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IGxpc3RlbmVyIHdoaWNoIHNhdmVzIGV2ZW50IGRhdGEgaW4gbWVtb3J5IHRvXG4gICAqIHtAbGluayBQYXJhbGxlbEJ1ZmZlcmVkI2V2ZW50c30uIExpc3RlbmVycyBhcmUgaW5kZXhlZCBieSBgZXZlbnROYW1lYCBhbmQgc3RvcmVkXG4gICAqIGluIHtAbGluayBQYXJhbGxlbEJ1ZmZlcmVkI2xpc3RlbmVyc30uIFRoaXMgaXMgYSBkZWZlbnNpdmUgbWVhc3VyZSwgc28gdGhhdCB3ZVxuICAgKiBkb24ndCBhKSBsZWFrIG1lbW9yeSBvciBiKSByZW1vdmUgX290aGVyXyBsaXN0ZW5lcnMgdGhhdCBtYXkgbm90IGJlXG4gICAqIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJlcG9ydGVyLlxuICAgKlxuICAgKiBTdWJjbGFzc2VzIGNvdWxkIG92ZXJyaWRlIHRoaXMgYmVoYXZpb3IuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIE5hbWUgb2YgZXZlbnQgdG8gY3JlYXRlIGxpc3RlbmVyIGZvclxuICAgKiBAcmV0dXJucyB7RXZlbnRMaXN0ZW5lcn1cbiAgICovXG4gIGNyZWF0ZUxpc3RlbmVyKGV2ZW50TmFtZSkge1xuICAgIGNvbnN0IGxpc3RlbmVyID0gKHJ1bm5hYmxlLCBlcnIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLnB1c2goU2VyaWFsaXphYmxlRXZlbnQuY3JlYXRlKGV2ZW50TmFtZSwgcnVubmFibGUsIGVycikpO1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLnNldChldmVudE5hbWUsIGxpc3RlbmVyKS5nZXQoZXZlbnROYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGV2ZW50IGxpc3RlbmVycyAodXNpbmcge0BsaW5rIFBhcmFsbGVsQnVmZmVyZWQjY3JlYXRlTGlzdGVuZXJ9KSBmb3IgZWFjaFxuICAgKiByZXBvcnRlci1yZWxldmFudCBldmVudCBlbWl0dGVkIGJ5IGEge0BsaW5rIFJ1bm5lcn0uIFRoaXMgYXJyYXkgaXMgZHJhaW5lZCB3aGVuXG4gICAqIHtAbGluayBQYXJhbGxlbEJ1ZmZlcmVkI2RvbmV9IGlzIGNhbGxlZCBieSB7QGxpbmsgUnVubmVyI3J1bn0uXG4gICAqXG4gICAqIFN1YmNsYXNzZXMgY291bGQgb3ZlcnJpZGUgdGhpcyBiZWhhdmlvci5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyIC0gUnVubmVyIGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtQYXJhbGxlbEJ1ZmZlcmVkfVxuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBjcmVhdGVMaXN0ZW5lcnMocnVubmVyKSB7XG4gICAgRVZFTlRfTkFNRVMuZm9yRWFjaChldnQgPT4ge1xuICAgICAgcnVubmVyLm9uKGV2dCwgdGhpcy5jcmVhdGVMaXN0ZW5lcihldnQpKTtcbiAgICB9KTtcbiAgICBPTkNFX0VWRU5UX05BTUVTLmZvckVhY2goZXZ0ID0+IHtcbiAgICAgIHJ1bm5lci5vbmNlKGV2dCwgdGhpcy5jcmVhdGVMaXN0ZW5lcihldnQpKTtcbiAgICB9KTtcblxuICAgIHJ1bm5lci5vbmNlKEVWRU5UX1JVTl9FTkQsICgpID0+IHtcbiAgICAgIGRlYnVnKCdyZWNlaXZlZCBFVkVOVF9SVU5fRU5EJyk7XG4gICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lciwgZXZ0KSA9PiB7XG4gICAgICAgIHJ1bm5lci5yZW1vdmVMaXN0ZW5lcihldnQsIGxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuZGVsZXRlKGV2dCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIHRoZSB7QGxpbmsgTW9jaGEjcnVufSBjYWxsYmFjayAoYGNhbGxiYWNrYCkgd2l0aCB0aGUgdGVzdCBmYWlsdXJlXG4gICAqIGNvdW50IGFuZCB0aGUgYXJyYXkgb2Yge0BsaW5rIEJ1ZmZlcmVkRXZlbnR9IG9iamVjdHMuIFJlc2V0cyB0aGUgYXJyYXkuXG4gICAqXG4gICAqIFRoaXMgaXMgY2FsbGVkIGRpcmVjdGx5IGJ5IGBSdW5uZXIjcnVuYCBhbmQgc2hvdWxkIG5vdCBiZSBjYWxsZWQgYnkgYW55IG90aGVyIGNvbnN1bWVyLlxuICAgKlxuICAgKiBTdWJjbGFzc2VzIGNvdWxkIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmYWlsdXJlcyAtIE51bWJlciBvZiBmYWlsZWQgdGVzdHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgcGFzc2VkIHRvIHtAbGluayBNb2NoYSNydW59LlxuICAgKiBAcHVibGljXG4gICAqL1xuICBkb25lKGZhaWx1cmVzLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKFNlcmlhbGl6YWJsZVdvcmtlclJlc3VsdC5jcmVhdGUodGhpcy5ldmVudHMsIGZhaWx1cmVzKSk7XG4gICAgdGhpcy5ldmVudHMgPSBbXTsgLy8gZGVmZW5zaXZlXG4gIH1cbn1cblxuLyoqXG4gKiBTZXJpYWxpemFibGUgZXZlbnQgZGF0YSBmcm9tIGEgYFJ1bm5lcmAuICBLZXlzIG9mIHRoZSBgZGF0YWAgcHJvcGVydHlcbiAqIGJlZ2lubmluZyB3aXRoIGBfX2Agd2lsbCBiZSBjb252ZXJ0ZWQgaW50byBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlIHZhbHVlXG4gKiB1cG9uIGRlc2VyaWFsaXphdGlvbi5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IEJ1ZmZlcmVkRXZlbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gRXZlbnQgbmFtZVxuICogQHByb3BlcnR5IHtvYmplY3R9IGRhdGEgLSBFdmVudCBwYXJhbWV0ZXJzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJhbGxlbEJ1ZmZlcmVkO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/nodejs/reporters/parallel-buffered.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/nodejs/serializer.js":
/*!*****************************************************!*\
  !*** ./node_modules/mocha/lib/nodejs/serializer.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * Serialization/deserialization classes and functions for communication between a main Mocha process and worker processes.\n * @module serializer\n * @private\n */\n\n\n\nconst {type, breakCircularDeps} = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\");\nconst {createInvalidArgumentTypeError} = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/mocha/lib/errors.js\");\n// this is not named `mocha:parallel:serializer` because it's noisy and it's\n// helpful to be able to write `DEBUG=mocha:parallel*` and get everything else.\nconst debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")('mocha:serializer');\n\nconst SERIALIZABLE_RESULT_NAME = 'SerializableWorkerResult';\nconst SERIALIZABLE_TYPES = new Set(['object', 'array', 'function', 'error']);\n\n/**\n * The serializable result of a test file run from a worker.\n * @private\n */\nclass SerializableWorkerResult {\n  /**\n   * Creates instance props; of note, the `__type` prop.\n   *\n   * Note that the failure count is _redundant_ and could be derived from the\n   * list of events; but since we're already doing the work, might as well use\n   * it.\n   * @param {SerializableEvent[]} [events=[]] - Events to eventually serialize\n   * @param {number} [failureCount=0] - Failure count\n   */\n  constructor(events = [], failureCount = 0) {\n    /**\n     * The number of failures in this run\n     * @type {number}\n     */\n    this.failureCount = failureCount;\n    /**\n     * All relevant events emitted from the {@link Runner}.\n     * @type {SerializableEvent[]}\n     */\n    this.events = events;\n\n    /**\n     * Symbol-like value needed to distinguish when attempting to deserialize\n     * this object (once it's been received over IPC).\n     * @type {Readonly<\"SerializableWorkerResult\">}\n     */\n    Object.defineProperty(this, '__type', {\n      value: SERIALIZABLE_RESULT_NAME,\n      enumerable: true,\n      writable: false\n    });\n  }\n\n  /**\n   * Instantiates a new {@link SerializableWorkerResult}.\n   * @param {...any} args - Args to constructor\n   * @returns {SerializableWorkerResult}\n   */\n  static create(...args) {\n    return new SerializableWorkerResult(...args);\n  }\n\n  /**\n   * Serializes each {@link SerializableEvent} in our `events` prop;\n   * makes this object read-only.\n   * @returns {Readonly<SerializableWorkerResult>}\n   */\n  serialize() {\n    this.events.forEach(event => {\n      event.serialize();\n    });\n    return Object.freeze(this);\n  }\n\n  /**\n   * Deserializes a {@link SerializedWorkerResult} into something reporters can\n   * use; calls {@link SerializableEvent.deserialize} on each item in its\n   * `events` prop.\n   * @param {SerializedWorkerResult} obj\n   * @returns {SerializedWorkerResult}\n   */\n  static deserialize(obj) {\n    obj.events.forEach(event => {\n      SerializableEvent.deserialize(event);\n    });\n    return obj;\n  }\n\n  /**\n   * Returns `true` if this is a {@link SerializedWorkerResult} or a\n   * {@link SerializableWorkerResult}.\n   * @param {*} value - A value to check\n   * @returns {boolean} If true, it's deserializable\n   */\n  static isSerializedWorkerResult(value) {\n    return (\n      value instanceof SerializableWorkerResult ||\n      (type(value) === 'object' && value.__type === SERIALIZABLE_RESULT_NAME)\n    );\n  }\n}\n\n/**\n * Represents an event, emitted by a {@link Runner}, which is to be transmitted\n * over IPC.\n *\n * Due to the contents of the event data, it's not possible to send them\n * verbatim. When received by the main process--and handled by reporters--these\n * objects are expected to contain {@link Runnable} instances.  This class\n * provides facilities to perform the translation via serialization and\n * deserialization.\n * @private\n */\nclass SerializableEvent {\n  /**\n   * Constructs a `SerializableEvent`, throwing if we receive unexpected data.\n   *\n   * Practically, events emitted from `Runner` have a minimum of zero (0)\n   * arguments-- (for example, {@link Runnable.constants.EVENT_RUN_BEGIN}) and a\n   * maximum of two (2) (for example,\n   * {@link Runnable.constants.EVENT_TEST_FAIL}, where the second argument is an\n   * `Error`).  The first argument, if present, is a {@link Runnable}. This\n   * constructor's arguments adhere to this convention.\n   * @param {string} eventName - A non-empty event name.\n   * @param {any} [originalValue] - Some data. Corresponds to extra arguments\n   * passed to `EventEmitter#emit`.\n   * @param {Error} [originalError] - An error, if there's an error.\n   * @throws If `eventName` is empty, or `originalValue` is a non-object.\n   */\n  constructor(eventName, originalValue, originalError) {\n    if (!eventName) {\n      throw createInvalidArgumentTypeError(\n        'Empty `eventName` string argument',\n        'eventName',\n        'string'\n      );\n    }\n    /**\n     * The event name.\n     * @memberof SerializableEvent\n     */\n    this.eventName = eventName;\n    const originalValueType = type(originalValue);\n    if (originalValueType !== 'object' && originalValueType !== 'undefined') {\n      throw createInvalidArgumentTypeError(\n        `Expected object but received ${originalValueType}`,\n        'originalValue',\n        'object'\n      );\n    }\n    /**\n     * An error, if present.\n     * @memberof SerializableEvent\n     */\n    Object.defineProperty(this, 'originalError', {\n      value: originalError,\n      enumerable: false\n    });\n\n    /**\n     * The raw value.\n     *\n     * We don't want this value sent via IPC; making it non-enumerable will do that.\n     *\n     * @memberof SerializableEvent\n     */\n    Object.defineProperty(this, 'originalValue', {\n      value: originalValue,\n      enumerable: false\n    });\n  }\n\n  /**\n   * In case you hated using `new` (I do).\n   *\n   * @param  {...any} args - Args for {@link SerializableEvent#constructor}.\n   * @returns {SerializableEvent} A new `SerializableEvent`\n   */\n  static create(...args) {\n    return new SerializableEvent(...args);\n  }\n\n  /**\n   * Used internally by {@link SerializableEvent#serialize}.\n   * @ignore\n   * @param {Array<object|string>} pairs - List of parent/key tuples to process; modified in-place. This JSDoc type is an approximation\n   * @param {object} parent - Some parent object\n   * @param {string} key - Key to inspect\n   */\n  static _serialize(pairs, parent, key) {\n    let value = parent[key];\n    let _type = type(value);\n    if (_type === 'error') {\n      // we need to reference the stack prop b/c it's lazily-loaded.\n      // `__type` is necessary for deserialization to create an `Error` later.\n      // `message` is apparently not enumerable, so we must handle it specifically.\n      value = Object.assign(Object.create(null), value, {\n        stack: value.stack,\n        message: value.message,\n        __type: 'Error'\n      });\n      parent[key] = value;\n      // after this, set the result of type(value) to be `object`, and we'll throw\n      // whatever other junk is in the original error into the new `value`.\n      _type = 'object';\n    }\n    switch (_type) {\n      case 'object':\n        if (type(value.serialize) === 'function') {\n          parent[key] = value.serialize();\n        } else {\n          // by adding props to the `pairs` array, we will process it further\n          pairs.push(\n            ...Object.keys(value)\n              .filter(key => SERIALIZABLE_TYPES.has(type(value[key])))\n              .map(key => [value, key])\n          );\n        }\n        break;\n      case 'function':\n        // we _may_ want to dig in to functions for some assertion libraries\n        // that might put a usable property on a function.\n        // for now, just zap it.\n        delete parent[key];\n        break;\n      case 'array':\n        pairs.push(\n          ...value\n            .filter(value => SERIALIZABLE_TYPES.has(type(value)))\n            .map((value, index) => [value, index])\n        );\n        break;\n    }\n  }\n\n  /**\n   * Modifies this object *in place* (for theoretical memory consumption &\n   * performance reasons); serializes `SerializableEvent#originalValue` (placing\n   * the result in `SerializableEvent#data`) and `SerializableEvent#error`.\n   * Freezes this object. The result is an object that can be transmitted over\n   * IPC.\n   * If this quickly becomes unmaintainable, we will want to move towards immutable\n   * objects post-haste.\n   */\n  serialize() {\n    // given a parent object and a key, inspect the value and decide whether\n    // to replace it, remove it, or add it to our `pairs` array to further process.\n    // this is recursion in loop form.\n    const originalValue = this.originalValue;\n    const result = Object.assign(Object.create(null), {\n      data:\n        type(originalValue) === 'object' &&\n        type(originalValue.serialize) === 'function'\n          ? originalValue.serialize()\n          : originalValue,\n      error: this.originalError\n    });\n\n    // mutates the object\n    breakCircularDeps(result.error);\n\n    const pairs = Object.keys(result).map(key => [result, key]);\n    const seenPairs = new Set();\n    let pair;\n\n    while ((pair = pairs.shift())) {\n      if (seenPairs.has(pair[1])) {\n        continue;\n      }\n\n      seenPairs.add(pair[1]);\n      SerializableEvent._serialize(pairs, ...pair);\n    }\n\n    this.data = result.data;\n    this.error = result.error;\n\n    return Object.freeze(this);\n  }\n\n  /**\n   * Used internally by {@link SerializableEvent.deserialize}; creates an `Error`\n   * from an `Error`-like (serialized) object\n   * @ignore\n   * @param {Object} value - An Error-like value\n   * @returns {Error} Real error\n   */\n  static _deserializeError(value) {\n    const error = new Error(value.message);\n    error.stack = value.stack;\n    Object.assign(error, value);\n    delete error.__type;\n    return error;\n  }\n\n  /**\n   * Used internally by {@link SerializableEvent.deserialize}; recursively\n   * deserializes an object in-place.\n   * @param {object|Array} parent - Some object or array\n   * @param {string|number} key - Some prop name or array index within `parent`\n   */\n  static _deserializeObject(parent, key) {\n    if (key === '__proto__') {\n      delete parent[key];\n      return;\n    }\n    const value = parent[key];\n    // keys beginning with `$$` are converted into functions returning the value\n    // and renamed, stripping the `$$` prefix.\n    // functions defined this way cannot be array members!\n    if (type(key) === 'string' && key.startsWith('$$')) {\n      const newKey = key.slice(2);\n      parent[newKey] = () => value;\n      delete parent[key];\n      key = newKey;\n    }\n    if (type(value) === 'array') {\n      value.forEach((_, idx) => {\n        SerializableEvent._deserializeObject(value, idx);\n      });\n    } else if (type(value) === 'object') {\n      if (value.__type === 'Error') {\n        parent[key] = SerializableEvent._deserializeError(value);\n      } else {\n        Object.keys(value).forEach(key => {\n          SerializableEvent._deserializeObject(value, key);\n        });\n      }\n    }\n  }\n\n  /**\n   * Deserialize value returned from a worker into something more useful.\n   * Does not return the same object.\n   * @todo do this in a loop instead of with recursion (if necessary)\n   * @param {SerializedEvent} obj - Object returned from worker\n   * @returns {SerializedEvent} Deserialized result\n   */\n  static deserialize(obj) {\n    if (!obj) {\n      throw createInvalidArgumentTypeError('Expected value', obj);\n    }\n\n    obj = Object.assign(Object.create(null), obj);\n\n    if (obj.data) {\n      Object.keys(obj.data).forEach(key => {\n        SerializableEvent._deserializeObject(obj.data, key);\n      });\n    }\n\n    if (obj.error) {\n      obj.error = SerializableEvent._deserializeError(obj.error);\n    }\n\n    return obj;\n  }\n}\n\n/**\n * \"Serializes\" a value for transmission over IPC as a message.\n *\n * If value is an object and has a `serialize()` method, call that method; otherwise return the object and hope for the best.\n *\n * @param {*} [value] - A value to serialize\n */\nexports.serialize = function serialize(value) {\n  const result =\n    type(value) === 'object' && type(value.serialize) === 'function'\n      ? value.serialize()\n      : value;\n  debug('serialized: %O', result);\n  return result;\n};\n\n/**\n * \"Deserializes\" a \"message\" received over IPC.\n *\n * This could be expanded with other objects that need deserialization,\n * but at present time we only care about {@link SerializableWorkerResult} objects.\n *\n * @param {*} [value] - A \"message\" to deserialize\n */\nexports.deserialize = function deserialize(value) {\n  const result = SerializableWorkerResult.isSerializedWorkerResult(value)\n    ? SerializableWorkerResult.deserialize(value)\n    : value;\n  debug('deserialized: %O', result);\n  return result;\n};\n\nexports.SerializableEvent = SerializableEvent;\nexports.SerializableWorkerResult = SerializableWorkerResult;\n\n/**\n * The result of calling `SerializableEvent.serialize`, as received\n * by the deserializer.\n * @private\n * @typedef {Object} SerializedEvent\n * @property {object?} data - Optional serialized data\n * @property {object?} error - Optional serialized `Error`\n */\n\n/**\n * The result of calling `SerializableWorkerResult.serialize` as received\n * by the deserializer.\n * @private\n * @typedef {Object} SerializedWorkerResult\n * @property {number} failureCount - Number of failures\n * @property {SerializedEvent[]} events - Serialized events\n * @property {\"SerializedWorkerResult\"} __type - Symbol-like to denote the type of object this is\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL25vZGVqcy9zZXJpYWxpemVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsT0FBTyx5QkFBeUIsRUFBRSxtQkFBTyxDQUFDLHlEQUFVO0FBQ3BELE9BQU8sZ0NBQWdDLEVBQUUsbUJBQU8sQ0FBQywyREFBVztBQUM1RDtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHNEQUFPOztBQUU3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxhQUFhO0FBQzFELGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EseUJBQXlCLCtCQUErQjtBQUN4RCxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLDhCQUE4QjtBQUNuRCxVQUFVLE9BQU8scUNBQXFDO0FBQ3REO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckMsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsOEJBQThCO0FBQ2hFLE1BQU0sK0JBQStCO0FBQ3JDLGFBQWEsR0FBRztBQUNoQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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LHlCQUF5QjtBQUN6QixnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsbUJBQW1CO0FBQ2pDLGNBQWMsMEJBQTBCO0FBQ3hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvbm9kZWpzL3NlcmlhbGl6ZXIuanM/OGIxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNlcmlhbGl6YXRpb24vZGVzZXJpYWxpemF0aW9uIGNsYXNzZXMgYW5kIGZ1bmN0aW9ucyBmb3IgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIGEgbWFpbiBNb2NoYSBwcm9jZXNzIGFuZCB3b3JrZXIgcHJvY2Vzc2VzLlxuICogQG1vZHVsZSBzZXJpYWxpemVyXG4gKiBAcHJpdmF0ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3Qge3R5cGUsIGJyZWFrQ2lyY3VsYXJEZXBzfSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5jb25zdCB7Y3JlYXRlSW52YWxpZEFyZ3VtZW50VHlwZUVycm9yfSA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuLy8gdGhpcyBpcyBub3QgbmFtZWQgYG1vY2hhOnBhcmFsbGVsOnNlcmlhbGl6ZXJgIGJlY2F1c2UgaXQncyBub2lzeSBhbmQgaXQnc1xuLy8gaGVscGZ1bCB0byBiZSBhYmxlIHRvIHdyaXRlIGBERUJVRz1tb2NoYTpwYXJhbGxlbCpgIGFuZCBnZXQgZXZlcnl0aGluZyBlbHNlLlxuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb2NoYTpzZXJpYWxpemVyJyk7XG5cbmNvbnN0IFNFUklBTElaQUJMRV9SRVNVTFRfTkFNRSA9ICdTZXJpYWxpemFibGVXb3JrZXJSZXN1bHQnO1xuY29uc3QgU0VSSUFMSVpBQkxFX1RZUEVTID0gbmV3IFNldChbJ29iamVjdCcsICdhcnJheScsICdmdW5jdGlvbicsICdlcnJvciddKTtcblxuLyoqXG4gKiBUaGUgc2VyaWFsaXphYmxlIHJlc3VsdCBvZiBhIHRlc3QgZmlsZSBydW4gZnJvbSBhIHdvcmtlci5cbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFNlcmlhbGl6YWJsZVdvcmtlclJlc3VsdCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGluc3RhbmNlIHByb3BzOyBvZiBub3RlLCB0aGUgYF9fdHlwZWAgcHJvcC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBmYWlsdXJlIGNvdW50IGlzIF9yZWR1bmRhbnRfIGFuZCBjb3VsZCBiZSBkZXJpdmVkIGZyb20gdGhlXG4gICAqIGxpc3Qgb2YgZXZlbnRzOyBidXQgc2luY2Ugd2UncmUgYWxyZWFkeSBkb2luZyB0aGUgd29yaywgbWlnaHQgYXMgd2VsbCB1c2VcbiAgICogaXQuXG4gICAqIEBwYXJhbSB7U2VyaWFsaXphYmxlRXZlbnRbXX0gW2V2ZW50cz1bXV0gLSBFdmVudHMgdG8gZXZlbnR1YWxseSBzZXJpYWxpemVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtmYWlsdXJlQ291bnQ9MF0gLSBGYWlsdXJlIGNvdW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihldmVudHMgPSBbXSwgZmFpbHVyZUNvdW50ID0gMCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZmFpbHVyZXMgaW4gdGhpcyBydW5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZmFpbHVyZUNvdW50ID0gZmFpbHVyZUNvdW50O1xuICAgIC8qKlxuICAgICAqIEFsbCByZWxldmFudCBldmVudHMgZW1pdHRlZCBmcm9tIHRoZSB7QGxpbmsgUnVubmVyfS5cbiAgICAgKiBAdHlwZSB7U2VyaWFsaXphYmxlRXZlbnRbXX1cbiAgICAgKi9cbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcblxuICAgIC8qKlxuICAgICAqIFN5bWJvbC1saWtlIHZhbHVlIG5lZWRlZCB0byBkaXN0aW5ndWlzaCB3aGVuIGF0dGVtcHRpbmcgdG8gZGVzZXJpYWxpemVcbiAgICAgKiB0aGlzIG9iamVjdCAob25jZSBpdCdzIGJlZW4gcmVjZWl2ZWQgb3ZlciBJUEMpLlxuICAgICAqIEB0eXBlIHtSZWFkb25seTxcIlNlcmlhbGl6YWJsZVdvcmtlclJlc3VsdFwiPn1cbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19fdHlwZScsIHtcbiAgICAgIHZhbHVlOiBTRVJJQUxJWkFCTEVfUkVTVUxUX05BTUUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW5zdGFudGlhdGVzIGEgbmV3IHtAbGluayBTZXJpYWxpemFibGVXb3JrZXJSZXN1bHR9LlxuICAgKiBAcGFyYW0gey4uLmFueX0gYXJncyAtIEFyZ3MgdG8gY29uc3RydWN0b3JcbiAgICogQHJldHVybnMge1NlcmlhbGl6YWJsZVdvcmtlclJlc3VsdH1cbiAgICovXG4gIHN0YXRpYyBjcmVhdGUoLi4uYXJncykge1xuICAgIHJldHVybiBuZXcgU2VyaWFsaXphYmxlV29ya2VyUmVzdWx0KC4uLmFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgZWFjaCB7QGxpbmsgU2VyaWFsaXphYmxlRXZlbnR9IGluIG91ciBgZXZlbnRzYCBwcm9wO1xuICAgKiBtYWtlcyB0aGlzIG9iamVjdCByZWFkLW9ubHkuXG4gICAqIEByZXR1cm5zIHtSZWFkb25seTxTZXJpYWxpemFibGVXb3JrZXJSZXN1bHQ+fVxuICAgKi9cbiAgc2VyaWFsaXplKCkge1xuICAgIHRoaXMuZXZlbnRzLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgZXZlbnQuc2VyaWFsaXplKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIGEge0BsaW5rIFNlcmlhbGl6ZWRXb3JrZXJSZXN1bHR9IGludG8gc29tZXRoaW5nIHJlcG9ydGVycyBjYW5cbiAgICogdXNlOyBjYWxscyB7QGxpbmsgU2VyaWFsaXphYmxlRXZlbnQuZGVzZXJpYWxpemV9IG9uIGVhY2ggaXRlbSBpbiBpdHNcbiAgICogYGV2ZW50c2AgcHJvcC5cbiAgICogQHBhcmFtIHtTZXJpYWxpemVkV29ya2VyUmVzdWx0fSBvYmpcbiAgICogQHJldHVybnMge1NlcmlhbGl6ZWRXb3JrZXJSZXN1bHR9XG4gICAqL1xuICBzdGF0aWMgZGVzZXJpYWxpemUob2JqKSB7XG4gICAgb2JqLmV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgIFNlcmlhbGl6YWJsZUV2ZW50LmRlc2VyaWFsaXplKGV2ZW50KTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgaXMgYSB7QGxpbmsgU2VyaWFsaXplZFdvcmtlclJlc3VsdH0gb3IgYVxuICAgKiB7QGxpbmsgU2VyaWFsaXphYmxlV29ya2VyUmVzdWx0fS5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIEEgdmFsdWUgdG8gY2hlY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59IElmIHRydWUsIGl0J3MgZGVzZXJpYWxpemFibGVcbiAgICovXG4gIHN0YXRpYyBpc1NlcmlhbGl6ZWRXb3JrZXJSZXN1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdmFsdWUgaW5zdGFuY2VvZiBTZXJpYWxpemFibGVXb3JrZXJSZXN1bHQgfHxcbiAgICAgICh0eXBlKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuX190eXBlID09PSBTRVJJQUxJWkFCTEVfUkVTVUxUX05BTUUpXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXZlbnQsIGVtaXR0ZWQgYnkgYSB7QGxpbmsgUnVubmVyfSwgd2hpY2ggaXMgdG8gYmUgdHJhbnNtaXR0ZWRcbiAqIG92ZXIgSVBDLlxuICpcbiAqIER1ZSB0byB0aGUgY29udGVudHMgb2YgdGhlIGV2ZW50IGRhdGEsIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHNlbmQgdGhlbVxuICogdmVyYmF0aW0uIFdoZW4gcmVjZWl2ZWQgYnkgdGhlIG1haW4gcHJvY2Vzcy0tYW5kIGhhbmRsZWQgYnkgcmVwb3J0ZXJzLS10aGVzZVxuICogb2JqZWN0cyBhcmUgZXhwZWN0ZWQgdG8gY29udGFpbiB7QGxpbmsgUnVubmFibGV9IGluc3RhbmNlcy4gIFRoaXMgY2xhc3NcbiAqIHByb3ZpZGVzIGZhY2lsaXRpZXMgdG8gcGVyZm9ybSB0aGUgdHJhbnNsYXRpb24gdmlhIHNlcmlhbGl6YXRpb24gYW5kXG4gKiBkZXNlcmlhbGl6YXRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBTZXJpYWxpemFibGVFdmVudCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgYFNlcmlhbGl6YWJsZUV2ZW50YCwgdGhyb3dpbmcgaWYgd2UgcmVjZWl2ZSB1bmV4cGVjdGVkIGRhdGEuXG4gICAqXG4gICAqIFByYWN0aWNhbGx5LCBldmVudHMgZW1pdHRlZCBmcm9tIGBSdW5uZXJgIGhhdmUgYSBtaW5pbXVtIG9mIHplcm8gKDApXG4gICAqIGFyZ3VtZW50cy0tIChmb3IgZXhhbXBsZSwge0BsaW5rIFJ1bm5hYmxlLmNvbnN0YW50cy5FVkVOVF9SVU5fQkVHSU59KSBhbmQgYVxuICAgKiBtYXhpbXVtIG9mIHR3byAoMikgKGZvciBleGFtcGxlLFxuICAgKiB7QGxpbmsgUnVubmFibGUuY29uc3RhbnRzLkVWRU5UX1RFU1RfRkFJTH0sIHdoZXJlIHRoZSBzZWNvbmQgYXJndW1lbnQgaXMgYW5cbiAgICogYEVycm9yYCkuICBUaGUgZmlyc3QgYXJndW1lbnQsIGlmIHByZXNlbnQsIGlzIGEge0BsaW5rIFJ1bm5hYmxlfS4gVGhpc1xuICAgKiBjb25zdHJ1Y3RvcidzIGFyZ3VtZW50cyBhZGhlcmUgdG8gdGhpcyBjb252ZW50aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gQSBub24tZW1wdHkgZXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIHthbnl9IFtvcmlnaW5hbFZhbHVlXSAtIFNvbWUgZGF0YS4gQ29ycmVzcG9uZHMgdG8gZXh0cmEgYXJndW1lbnRzXG4gICAqIHBhc3NlZCB0byBgRXZlbnRFbWl0dGVyI2VtaXRgLlxuICAgKiBAcGFyYW0ge0Vycm9yfSBbb3JpZ2luYWxFcnJvcl0gLSBBbiBlcnJvciwgaWYgdGhlcmUncyBhbiBlcnJvci5cbiAgICogQHRocm93cyBJZiBgZXZlbnROYW1lYCBpcyBlbXB0eSwgb3IgYG9yaWdpbmFsVmFsdWVgIGlzIGEgbm9uLW9iamVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGV2ZW50TmFtZSwgb3JpZ2luYWxWYWx1ZSwgb3JpZ2luYWxFcnJvcikge1xuICAgIGlmICghZXZlbnROYW1lKSB7XG4gICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkQXJndW1lbnRUeXBlRXJyb3IoXG4gICAgICAgICdFbXB0eSBgZXZlbnROYW1lYCBzdHJpbmcgYXJndW1lbnQnLFxuICAgICAgICAnZXZlbnROYW1lJyxcbiAgICAgICAgJ3N0cmluZydcbiAgICAgICk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBuYW1lLlxuICAgICAqIEBtZW1iZXJvZiBTZXJpYWxpemFibGVFdmVudFxuICAgICAqL1xuICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lO1xuICAgIGNvbnN0IG9yaWdpbmFsVmFsdWVUeXBlID0gdHlwZShvcmlnaW5hbFZhbHVlKTtcbiAgICBpZiAob3JpZ2luYWxWYWx1ZVR5cGUgIT09ICdvYmplY3QnICYmIG9yaWdpbmFsVmFsdWVUeXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZEFyZ3VtZW50VHlwZUVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgb2JqZWN0IGJ1dCByZWNlaXZlZCAke29yaWdpbmFsVmFsdWVUeXBlfWAsXG4gICAgICAgICdvcmlnaW5hbFZhbHVlJyxcbiAgICAgICAgJ29iamVjdCdcbiAgICAgICk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIGVycm9yLCBpZiBwcmVzZW50LlxuICAgICAqIEBtZW1iZXJvZiBTZXJpYWxpemFibGVFdmVudFxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnb3JpZ2luYWxFcnJvcicsIHtcbiAgICAgIHZhbHVlOiBvcmlnaW5hbEVycm9yLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByYXcgdmFsdWUuXG4gICAgICpcbiAgICAgKiBXZSBkb24ndCB3YW50IHRoaXMgdmFsdWUgc2VudCB2aWEgSVBDOyBtYWtpbmcgaXQgbm9uLWVudW1lcmFibGUgd2lsbCBkbyB0aGF0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFNlcmlhbGl6YWJsZUV2ZW50XG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdvcmlnaW5hbFZhbHVlJywge1xuICAgICAgdmFsdWU6IG9yaWdpbmFsVmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEluIGNhc2UgeW91IGhhdGVkIHVzaW5nIGBuZXdgIChJIGRvKS5cbiAgICpcbiAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzIC0gQXJncyBmb3Ige0BsaW5rIFNlcmlhbGl6YWJsZUV2ZW50I2NvbnN0cnVjdG9yfS5cbiAgICogQHJldHVybnMge1NlcmlhbGl6YWJsZUV2ZW50fSBBIG5ldyBgU2VyaWFsaXphYmxlRXZlbnRgXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFNlcmlhbGl6YWJsZUV2ZW50KC4uLmFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgaW50ZXJuYWxseSBieSB7QGxpbmsgU2VyaWFsaXphYmxlRXZlbnQjc2VyaWFsaXplfS5cbiAgICogQGlnbm9yZVxuICAgKiBAcGFyYW0ge0FycmF5PG9iamVjdHxzdHJpbmc+fSBwYWlycyAtIExpc3Qgb2YgcGFyZW50L2tleSB0dXBsZXMgdG8gcHJvY2VzczsgbW9kaWZpZWQgaW4tcGxhY2UuIFRoaXMgSlNEb2MgdHlwZSBpcyBhbiBhcHByb3hpbWF0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnQgLSBTb21lIHBhcmVudCBvYmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIEtleSB0byBpbnNwZWN0XG4gICAqL1xuICBzdGF0aWMgX3NlcmlhbGl6ZShwYWlycywgcGFyZW50LCBrZXkpIHtcbiAgICBsZXQgdmFsdWUgPSBwYXJlbnRba2V5XTtcbiAgICBsZXQgX3R5cGUgPSB0eXBlKHZhbHVlKTtcbiAgICBpZiAoX3R5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIC8vIHdlIG5lZWQgdG8gcmVmZXJlbmNlIHRoZSBzdGFjayBwcm9wIGIvYyBpdCdzIGxhemlseS1sb2FkZWQuXG4gICAgICAvLyBgX190eXBlYCBpcyBuZWNlc3NhcnkgZm9yIGRlc2VyaWFsaXphdGlvbiB0byBjcmVhdGUgYW4gYEVycm9yYCBsYXRlci5cbiAgICAgIC8vIGBtZXNzYWdlYCBpcyBhcHBhcmVudGx5IG5vdCBlbnVtZXJhYmxlLCBzbyB3ZSBtdXN0IGhhbmRsZSBpdCBzcGVjaWZpY2FsbHkuXG4gICAgICB2YWx1ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgdmFsdWUsIHtcbiAgICAgICAgc3RhY2s6IHZhbHVlLnN0YWNrLFxuICAgICAgICBtZXNzYWdlOiB2YWx1ZS5tZXNzYWdlLFxuICAgICAgICBfX3R5cGU6ICdFcnJvcidcbiAgICAgIH0pO1xuICAgICAgcGFyZW50W2tleV0gPSB2YWx1ZTtcbiAgICAgIC8vIGFmdGVyIHRoaXMsIHNldCB0aGUgcmVzdWx0IG9mIHR5cGUodmFsdWUpIHRvIGJlIGBvYmplY3RgLCBhbmQgd2UnbGwgdGhyb3dcbiAgICAgIC8vIHdoYXRldmVyIG90aGVyIGp1bmsgaXMgaW4gdGhlIG9yaWdpbmFsIGVycm9yIGludG8gdGhlIG5ldyBgdmFsdWVgLlxuICAgICAgX3R5cGUgPSAnb2JqZWN0JztcbiAgICB9XG4gICAgc3dpdGNoIChfdHlwZSkge1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKHR5cGUodmFsdWUuc2VyaWFsaXplKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHBhcmVudFtrZXldID0gdmFsdWUuc2VyaWFsaXplKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYnkgYWRkaW5nIHByb3BzIHRvIHRoZSBgcGFpcnNgIGFycmF5LCB3ZSB3aWxsIHByb2Nlc3MgaXQgZnVydGhlclxuICAgICAgICAgIHBhaXJzLnB1c2goXG4gICAgICAgICAgICAuLi5PYmplY3Qua2V5cyh2YWx1ZSlcbiAgICAgICAgICAgICAgLmZpbHRlcihrZXkgPT4gU0VSSUFMSVpBQkxFX1RZUEVTLmhhcyh0eXBlKHZhbHVlW2tleV0pKSlcbiAgICAgICAgICAgICAgLm1hcChrZXkgPT4gW3ZhbHVlLCBrZXldKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgIC8vIHdlIF9tYXlfIHdhbnQgdG8gZGlnIGluIHRvIGZ1bmN0aW9ucyBmb3Igc29tZSBhc3NlcnRpb24gbGlicmFyaWVzXG4gICAgICAgIC8vIHRoYXQgbWlnaHQgcHV0IGEgdXNhYmxlIHByb3BlcnR5IG9uIGEgZnVuY3Rpb24uXG4gICAgICAgIC8vIGZvciBub3csIGp1c3QgemFwIGl0LlxuICAgICAgICBkZWxldGUgcGFyZW50W2tleV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICBwYWlycy5wdXNoKFxuICAgICAgICAgIC4uLnZhbHVlXG4gICAgICAgICAgICAuZmlsdGVyKHZhbHVlID0+IFNFUklBTElaQUJMRV9UWVBFUy5oYXModHlwZSh2YWx1ZSkpKVxuICAgICAgICAgICAgLm1hcCgodmFsdWUsIGluZGV4KSA9PiBbdmFsdWUsIGluZGV4XSlcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmaWVzIHRoaXMgb2JqZWN0ICppbiBwbGFjZSogKGZvciB0aGVvcmV0aWNhbCBtZW1vcnkgY29uc3VtcHRpb24gJlxuICAgKiBwZXJmb3JtYW5jZSByZWFzb25zKTsgc2VyaWFsaXplcyBgU2VyaWFsaXphYmxlRXZlbnQjb3JpZ2luYWxWYWx1ZWAgKHBsYWNpbmdcbiAgICogdGhlIHJlc3VsdCBpbiBgU2VyaWFsaXphYmxlRXZlbnQjZGF0YWApIGFuZCBgU2VyaWFsaXphYmxlRXZlbnQjZXJyb3JgLlxuICAgKiBGcmVlemVzIHRoaXMgb2JqZWN0LiBUaGUgcmVzdWx0IGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB0cmFuc21pdHRlZCBvdmVyXG4gICAqIElQQy5cbiAgICogSWYgdGhpcyBxdWlja2x5IGJlY29tZXMgdW5tYWludGFpbmFibGUsIHdlIHdpbGwgd2FudCB0byBtb3ZlIHRvd2FyZHMgaW1tdXRhYmxlXG4gICAqIG9iamVjdHMgcG9zdC1oYXN0ZS5cbiAgICovXG4gIHNlcmlhbGl6ZSgpIHtcbiAgICAvLyBnaXZlbiBhIHBhcmVudCBvYmplY3QgYW5kIGEga2V5LCBpbnNwZWN0IHRoZSB2YWx1ZSBhbmQgZGVjaWRlIHdoZXRoZXJcbiAgICAvLyB0byByZXBsYWNlIGl0LCByZW1vdmUgaXQsIG9yIGFkZCBpdCB0byBvdXIgYHBhaXJzYCBhcnJheSB0byBmdXJ0aGVyIHByb2Nlc3MuXG4gICAgLy8gdGhpcyBpcyByZWN1cnNpb24gaW4gbG9vcCBmb3JtLlxuICAgIGNvbnN0IG9yaWdpbmFsVmFsdWUgPSB0aGlzLm9yaWdpbmFsVmFsdWU7XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgICBkYXRhOlxuICAgICAgICB0eXBlKG9yaWdpbmFsVmFsdWUpID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB0eXBlKG9yaWdpbmFsVmFsdWUuc2VyaWFsaXplKSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gb3JpZ2luYWxWYWx1ZS5zZXJpYWxpemUoKVxuICAgICAgICAgIDogb3JpZ2luYWxWYWx1ZSxcbiAgICAgIGVycm9yOiB0aGlzLm9yaWdpbmFsRXJyb3JcbiAgICB9KTtcblxuICAgIC8vIG11dGF0ZXMgdGhlIG9iamVjdFxuICAgIGJyZWFrQ2lyY3VsYXJEZXBzKHJlc3VsdC5lcnJvcik7XG5cbiAgICBjb25zdCBwYWlycyA9IE9iamVjdC5rZXlzKHJlc3VsdCkubWFwKGtleSA9PiBbcmVzdWx0LCBrZXldKTtcbiAgICBjb25zdCBzZWVuUGFpcnMgPSBuZXcgU2V0KCk7XG4gICAgbGV0IHBhaXI7XG5cbiAgICB3aGlsZSAoKHBhaXIgPSBwYWlycy5zaGlmdCgpKSkge1xuICAgICAgaWYgKHNlZW5QYWlycy5oYXMocGFpclsxXSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHNlZW5QYWlycy5hZGQocGFpclsxXSk7XG4gICAgICBTZXJpYWxpemFibGVFdmVudC5fc2VyaWFsaXplKHBhaXJzLCAuLi5wYWlyKTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGEgPSByZXN1bHQuZGF0YTtcbiAgICB0aGlzLmVycm9yID0gcmVzdWx0LmVycm9yO1xuXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBpbnRlcm5hbGx5IGJ5IHtAbGluayBTZXJpYWxpemFibGVFdmVudC5kZXNlcmlhbGl6ZX07IGNyZWF0ZXMgYW4gYEVycm9yYFxuICAgKiBmcm9tIGFuIGBFcnJvcmAtbGlrZSAoc2VyaWFsaXplZCkgb2JqZWN0XG4gICAqIEBpZ25vcmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIC0gQW4gRXJyb3ItbGlrZSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7RXJyb3J9IFJlYWwgZXJyb3JcbiAgICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemVFcnJvcih2YWx1ZSkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKHZhbHVlLm1lc3NhZ2UpO1xuICAgIGVycm9yLnN0YWNrID0gdmFsdWUuc3RhY2s7XG4gICAgT2JqZWN0LmFzc2lnbihlcnJvciwgdmFsdWUpO1xuICAgIGRlbGV0ZSBlcnJvci5fX3R5cGU7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgaW50ZXJuYWxseSBieSB7QGxpbmsgU2VyaWFsaXphYmxlRXZlbnQuZGVzZXJpYWxpemV9OyByZWN1cnNpdmVseVxuICAgKiBkZXNlcmlhbGl6ZXMgYW4gb2JqZWN0IGluLXBsYWNlLlxuICAgKiBAcGFyYW0ge29iamVjdHxBcnJheX0gcGFyZW50IC0gU29tZSBvYmplY3Qgb3IgYXJyYXlcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBrZXkgLSBTb21lIHByb3AgbmFtZSBvciBhcnJheSBpbmRleCB3aXRoaW4gYHBhcmVudGBcbiAgICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemVPYmplY3QocGFyZW50LCBrZXkpIHtcbiAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJykge1xuICAgICAgZGVsZXRlIHBhcmVudFtrZXldO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHBhcmVudFtrZXldO1xuICAgIC8vIGtleXMgYmVnaW5uaW5nIHdpdGggYCQkYCBhcmUgY29udmVydGVkIGludG8gZnVuY3Rpb25zIHJldHVybmluZyB0aGUgdmFsdWVcbiAgICAvLyBhbmQgcmVuYW1lZCwgc3RyaXBwaW5nIHRoZSBgJCRgIHByZWZpeC5cbiAgICAvLyBmdW5jdGlvbnMgZGVmaW5lZCB0aGlzIHdheSBjYW5ub3QgYmUgYXJyYXkgbWVtYmVycyFcbiAgICBpZiAodHlwZShrZXkpID09PSAnc3RyaW5nJyAmJiBrZXkuc3RhcnRzV2l0aCgnJCQnKSkge1xuICAgICAgY29uc3QgbmV3S2V5ID0ga2V5LnNsaWNlKDIpO1xuICAgICAgcGFyZW50W25ld0tleV0gPSAoKSA9PiB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBwYXJlbnRba2V5XTtcbiAgICAgIGtleSA9IG5ld0tleTtcbiAgICB9XG4gICAgaWYgKHR5cGUodmFsdWUpID09PSAnYXJyYXknKSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKChfLCBpZHgpID0+IHtcbiAgICAgICAgU2VyaWFsaXphYmxlRXZlbnQuX2Rlc2VyaWFsaXplT2JqZWN0KHZhbHVlLCBpZHgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlKHZhbHVlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh2YWx1ZS5fX3R5cGUgPT09ICdFcnJvcicpIHtcbiAgICAgICAgcGFyZW50W2tleV0gPSBTZXJpYWxpemFibGVFdmVudC5fZGVzZXJpYWxpemVFcnJvcih2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgIFNlcmlhbGl6YWJsZUV2ZW50Ll9kZXNlcmlhbGl6ZU9iamVjdCh2YWx1ZSwga2V5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIHZhbHVlIHJldHVybmVkIGZyb20gYSB3b3JrZXIgaW50byBzb21ldGhpbmcgbW9yZSB1c2VmdWwuXG4gICAqIERvZXMgbm90IHJldHVybiB0aGUgc2FtZSBvYmplY3QuXG4gICAqIEB0b2RvIGRvIHRoaXMgaW4gYSBsb29wIGluc3RlYWQgb2Ygd2l0aCByZWN1cnNpb24gKGlmIG5lY2Vzc2FyeSlcbiAgICogQHBhcmFtIHtTZXJpYWxpemVkRXZlbnR9IG9iaiAtIE9iamVjdCByZXR1cm5lZCBmcm9tIHdvcmtlclxuICAgKiBAcmV0dXJucyB7U2VyaWFsaXplZEV2ZW50fSBEZXNlcmlhbGl6ZWQgcmVzdWx0XG4gICAqL1xuICBzdGF0aWMgZGVzZXJpYWxpemUob2JqKSB7XG4gICAgaWYgKCFvYmopIHtcbiAgICAgIHRocm93IGNyZWF0ZUludmFsaWRBcmd1bWVudFR5cGVFcnJvcignRXhwZWN0ZWQgdmFsdWUnLCBvYmopO1xuICAgIH1cblxuICAgIG9iaiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgb2JqKTtcblxuICAgIGlmIChvYmouZGF0YSkge1xuICAgICAgT2JqZWN0LmtleXMob2JqLmRhdGEpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgU2VyaWFsaXphYmxlRXZlbnQuX2Rlc2VyaWFsaXplT2JqZWN0KG9iai5kYXRhLCBrZXkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9iai5lcnJvcikge1xuICAgICAgb2JqLmVycm9yID0gU2VyaWFsaXphYmxlRXZlbnQuX2Rlc2VyaWFsaXplRXJyb3Iob2JqLmVycm9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG59XG5cbi8qKlxuICogXCJTZXJpYWxpemVzXCIgYSB2YWx1ZSBmb3IgdHJhbnNtaXNzaW9uIG92ZXIgSVBDIGFzIGEgbWVzc2FnZS5cbiAqXG4gKiBJZiB2YWx1ZSBpcyBhbiBvYmplY3QgYW5kIGhhcyBhIGBzZXJpYWxpemUoKWAgbWV0aG9kLCBjYWxsIHRoYXQgbWV0aG9kOyBvdGhlcndpc2UgcmV0dXJuIHRoZSBvYmplY3QgYW5kIGhvcGUgZm9yIHRoZSBiZXN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSAtIEEgdmFsdWUgdG8gc2VyaWFsaXplXG4gKi9cbmV4cG9ydHMuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKHZhbHVlKSB7XG4gIGNvbnN0IHJlc3VsdCA9XG4gICAgdHlwZSh2YWx1ZSkgPT09ICdvYmplY3QnICYmIHR5cGUodmFsdWUuc2VyaWFsaXplKSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyB2YWx1ZS5zZXJpYWxpemUoKVxuICAgICAgOiB2YWx1ZTtcbiAgZGVidWcoJ3NlcmlhbGl6ZWQ6ICVPJywgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogXCJEZXNlcmlhbGl6ZXNcIiBhIFwibWVzc2FnZVwiIHJlY2VpdmVkIG92ZXIgSVBDLlxuICpcbiAqIFRoaXMgY291bGQgYmUgZXhwYW5kZWQgd2l0aCBvdGhlciBvYmplY3RzIHRoYXQgbmVlZCBkZXNlcmlhbGl6YXRpb24sXG4gKiBidXQgYXQgcHJlc2VudCB0aW1lIHdlIG9ubHkgY2FyZSBhYm91dCB7QGxpbmsgU2VyaWFsaXphYmxlV29ya2VyUmVzdWx0fSBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSAtIEEgXCJtZXNzYWdlXCIgdG8gZGVzZXJpYWxpemVcbiAqL1xuZXhwb3J0cy5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIGRlc2VyaWFsaXplKHZhbHVlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFNlcmlhbGl6YWJsZVdvcmtlclJlc3VsdC5pc1NlcmlhbGl6ZWRXb3JrZXJSZXN1bHQodmFsdWUpXG4gICAgPyBTZXJpYWxpemFibGVXb3JrZXJSZXN1bHQuZGVzZXJpYWxpemUodmFsdWUpXG4gICAgOiB2YWx1ZTtcbiAgZGVidWcoJ2Rlc2VyaWFsaXplZDogJU8nLCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0cy5TZXJpYWxpemFibGVFdmVudCA9IFNlcmlhbGl6YWJsZUV2ZW50O1xuZXhwb3J0cy5TZXJpYWxpemFibGVXb3JrZXJSZXN1bHQgPSBTZXJpYWxpemFibGVXb3JrZXJSZXN1bHQ7XG5cbi8qKlxuICogVGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBTZXJpYWxpemFibGVFdmVudC5zZXJpYWxpemVgLCBhcyByZWNlaXZlZFxuICogYnkgdGhlIGRlc2VyaWFsaXplci5cbiAqIEBwcml2YXRlXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTZXJpYWxpemVkRXZlbnRcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0P30gZGF0YSAtIE9wdGlvbmFsIHNlcmlhbGl6ZWQgZGF0YVxuICogQHByb3BlcnR5IHtvYmplY3Q/fSBlcnJvciAtIE9wdGlvbmFsIHNlcmlhbGl6ZWQgYEVycm9yYFxuICovXG5cbi8qKlxuICogVGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBTZXJpYWxpemFibGVXb3JrZXJSZXN1bHQuc2VyaWFsaXplYCBhcyByZWNlaXZlZFxuICogYnkgdGhlIGRlc2VyaWFsaXplci5cbiAqIEBwcml2YXRlXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTZXJpYWxpemVkV29ya2VyUmVzdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZmFpbHVyZUNvdW50IC0gTnVtYmVyIG9mIGZhaWx1cmVzXG4gKiBAcHJvcGVydHkge1NlcmlhbGl6ZWRFdmVudFtdfSBldmVudHMgLSBTZXJpYWxpemVkIGV2ZW50c1xuICogQHByb3BlcnR5IHtcIlNlcmlhbGl6ZWRXb3JrZXJSZXN1bHRcIn0gX190eXBlIC0gU3ltYm9sLWxpa2UgdG8gZGVub3RlIHRoZSB0eXBlIG9mIG9iamVjdCB0aGlzIGlzXG4gKi9cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/nodejs/serializer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/nodejs/worker.js":
/*!*************************************************!*\
  !*** ./node_modules/mocha/lib/nodejs/worker.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * A worker process.  Consumes {@link module:reporters/parallel-buffered} reporter.\n * @module worker\n * @private\n */\n\n\n\nconst {\n  createInvalidArgumentTypeError,\n  createInvalidArgumentValueError\n} = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/mocha/lib/errors.js\");\nconst workerpool = __webpack_require__(/*! workerpool */ \"(ssr)/./node_modules/workerpool/src/index.js\");\nconst Mocha = __webpack_require__(/*! ../mocha */ \"(ssr)/./node_modules/mocha/lib/mocha.js\");\nconst {handleRequires, validateLegacyPlugin} = __webpack_require__(/*! ../cli/run-helpers */ \"(ssr)/./node_modules/mocha/lib/cli/run-helpers.js\");\nconst d = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\nconst debug = d.debug(`mocha:parallel:worker:${process.pid}`);\nconst isDebugEnabled = d.enabled(`mocha:parallel:worker:${process.pid}`);\nconst {serialize} = __webpack_require__(/*! ./serializer */ \"(ssr)/./node_modules/mocha/lib/nodejs/serializer.js\");\nconst {setInterval, clearInterval} = global;\n\nlet rootHooks;\n\nif (workerpool.isMainThread) {\n  throw new Error(\n    'This script is intended to be run as a worker (by the `workerpool` package).'\n  );\n}\n\n/**\n * Initializes some stuff on the first call to {@link run}.\n *\n * Handles `--require` and `--ui`.  Does _not_ handle `--reporter`,\n * as only the `Buffered` reporter is used.\n *\n * **This function only runs once per worker**; it overwrites itself with a no-op\n * before returning.\n *\n * @param {Options} argv - Command-line options\n */\nlet bootstrap = async argv => {\n  // globalSetup and globalTeardown do not run in workers\n  const plugins = await handleRequires(argv.require, {\n    ignoredPlugins: ['mochaGlobalSetup', 'mochaGlobalTeardown']\n  });\n  validateLegacyPlugin(argv, 'ui', Mocha.interfaces);\n\n  rootHooks = plugins.rootHooks;\n  bootstrap = () => {};\n  debug('bootstrap(): finished with args: %O', argv);\n};\n\n/**\n * Runs a single test file in a worker thread.\n * @param {string} filepath - Filepath of test file\n * @param {string} [serializedOptions] - **Serialized** options. This string will be eval'd!\n * @see https://npm.im/serialize-javascript\n * @returns {Promise<{failures: number, events: BufferedEvent[]}>} - Test\n * failure count and list of events.\n */\nasync function run(filepath, serializedOptions = '{}') {\n  if (!filepath) {\n    throw createInvalidArgumentTypeError(\n      'Expected a non-empty \"filepath\" argument',\n      'file',\n      'string'\n    );\n  }\n\n  debug('run(): running test file %s', filepath);\n\n  if (typeof serializedOptions !== 'string') {\n    throw createInvalidArgumentTypeError(\n      'run() expects second parameter to be a string which was serialized by the `serialize-javascript` module',\n      'serializedOptions',\n      'string'\n    );\n  }\n  let argv;\n  try {\n    // eslint-disable-next-line no-eval\n    argv = eval('(' + serializedOptions + ')');\n  } catch (err) {\n    throw createInvalidArgumentValueError(\n      'run() was unable to deserialize the options',\n      'serializedOptions',\n      serializedOptions\n    );\n  }\n\n  const opts = Object.assign({ui: 'bdd'}, argv, {\n    // if this was true, it would cause infinite recursion.\n    parallel: false,\n    // this doesn't work in parallel mode\n    forbidOnly: true,\n    // it's useful for a Mocha instance to know if it's running in a worker process.\n    isWorker: true\n  });\n\n  await bootstrap(opts);\n\n  opts.rootHooks = rootHooks;\n\n  const mocha = new Mocha(opts).addFile(filepath);\n\n  try {\n    await mocha.loadFilesAsync();\n  } catch (err) {\n    debug('run(): could not load file %s: %s', filepath, err);\n    throw err;\n  }\n\n  return new Promise((resolve, reject) => {\n    let debugInterval;\n    /* istanbul ignore next */\n    if (isDebugEnabled) {\n      debugInterval = setInterval(() => {\n        debug('run(): still running %s...', filepath);\n      }, 5000).unref();\n    }\n    mocha.run(result => {\n      // Runner adds these; if we don't remove them, we'll get a leak.\n      process.removeAllListeners('uncaughtException');\n      process.removeAllListeners('unhandledRejection');\n\n      try {\n        const serialized = serialize(result);\n        debug(\n          'run(): completed run with %d test failures; returning to main process',\n          typeof result.failures === 'number' ? result.failures : 0\n        );\n        resolve(serialized);\n      } catch (err) {\n        // TODO: figure out exactly what the sad path looks like here.\n        // rejection should only happen if an error is \"unrecoverable\"\n        debug('run(): serialization failed; rejecting: %O', err);\n        reject(err);\n      } finally {\n        clearInterval(debugInterval);\n      }\n    });\n  });\n}\n\n// this registers the `run` function.\nworkerpool.worker({run});\n\ndebug('started worker process');\n\n// for testing\nexports.run = run;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL25vZGVqcy93b3JrZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxnQ0FBZ0MsMENBQTBDO0FBQzFFO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQywyREFBVztBQUN2QixtQkFBbUIsbUJBQU8sQ0FBQyxnRUFBWTtBQUN2QyxjQUFjLG1CQUFPLENBQUMseURBQVU7QUFDaEMsT0FBTyxzQ0FBc0MsRUFBRSxtQkFBTyxDQUFDLDZFQUFvQjtBQUMzRSxVQUFVLG1CQUFPLENBQUMsc0RBQU87QUFDekIsK0NBQStDLFlBQVk7QUFDM0QsMERBQTBELFlBQVk7QUFDdEUsT0FBTyxXQUFXLEVBQUUsbUJBQU8sQ0FBQyx5RUFBYztBQUMxQyxPQUFPLDRCQUE0Qjs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxVQUFVO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsU0FBUywwQ0FBMEMsR0FBRztBQUNuRTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxtQkFBbUIsSUFBSTs7QUFFdkI7O0FBRUE7QUFDQSxXQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvbm9kZWpzL3dvcmtlci5qcz8yNjQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSB3b3JrZXIgcHJvY2Vzcy4gIENvbnN1bWVzIHtAbGluayBtb2R1bGU6cmVwb3J0ZXJzL3BhcmFsbGVsLWJ1ZmZlcmVkfSByZXBvcnRlci5cbiAqIEBtb2R1bGUgd29ya2VyXG4gKiBAcHJpdmF0ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3Qge1xuICBjcmVhdGVJbnZhbGlkQXJndW1lbnRUeXBlRXJyb3IsXG4gIGNyZWF0ZUludmFsaWRBcmd1bWVudFZhbHVlRXJyb3Jcbn0gPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IHdvcmtlcnBvb2wgPSByZXF1aXJlKCd3b3JrZXJwb29sJyk7XG5jb25zdCBNb2NoYSA9IHJlcXVpcmUoJy4uL21vY2hhJyk7XG5jb25zdCB7aGFuZGxlUmVxdWlyZXMsIHZhbGlkYXRlTGVnYWN5UGx1Z2lufSA9IHJlcXVpcmUoJy4uL2NsaS9ydW4taGVscGVycycpO1xuY29uc3QgZCA9IHJlcXVpcmUoJ2RlYnVnJyk7XG5jb25zdCBkZWJ1ZyA9IGQuZGVidWcoYG1vY2hhOnBhcmFsbGVsOndvcmtlcjoke3Byb2Nlc3MucGlkfWApO1xuY29uc3QgaXNEZWJ1Z0VuYWJsZWQgPSBkLmVuYWJsZWQoYG1vY2hhOnBhcmFsbGVsOndvcmtlcjoke3Byb2Nlc3MucGlkfWApO1xuY29uc3Qge3NlcmlhbGl6ZX0gPSByZXF1aXJlKCcuL3NlcmlhbGl6ZXInKTtcbmNvbnN0IHtzZXRJbnRlcnZhbCwgY2xlYXJJbnRlcnZhbH0gPSBnbG9iYWw7XG5cbmxldCByb290SG9va3M7XG5cbmlmICh3b3JrZXJwb29sLmlzTWFpblRocmVhZCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ1RoaXMgc2NyaXB0IGlzIGludGVuZGVkIHRvIGJlIHJ1biBhcyBhIHdvcmtlciAoYnkgdGhlIGB3b3JrZXJwb29sYCBwYWNrYWdlKS4nXG4gICk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgc29tZSBzdHVmZiBvbiB0aGUgZmlyc3QgY2FsbCB0byB7QGxpbmsgcnVufS5cbiAqXG4gKiBIYW5kbGVzIGAtLXJlcXVpcmVgIGFuZCBgLS11aWAuICBEb2VzIF9ub3RfIGhhbmRsZSBgLS1yZXBvcnRlcmAsXG4gKiBhcyBvbmx5IHRoZSBgQnVmZmVyZWRgIHJlcG9ydGVyIGlzIHVzZWQuXG4gKlxuICogKipUaGlzIGZ1bmN0aW9uIG9ubHkgcnVucyBvbmNlIHBlciB3b3JrZXIqKjsgaXQgb3ZlcndyaXRlcyBpdHNlbGYgd2l0aCBhIG5vLW9wXG4gKiBiZWZvcmUgcmV0dXJuaW5nLlxuICpcbiAqIEBwYXJhbSB7T3B0aW9uc30gYXJndiAtIENvbW1hbmQtbGluZSBvcHRpb25zXG4gKi9cbmxldCBib290c3RyYXAgPSBhc3luYyBhcmd2ID0+IHtcbiAgLy8gZ2xvYmFsU2V0dXAgYW5kIGdsb2JhbFRlYXJkb3duIGRvIG5vdCBydW4gaW4gd29ya2Vyc1xuICBjb25zdCBwbHVnaW5zID0gYXdhaXQgaGFuZGxlUmVxdWlyZXMoYXJndi5yZXF1aXJlLCB7XG4gICAgaWdub3JlZFBsdWdpbnM6IFsnbW9jaGFHbG9iYWxTZXR1cCcsICdtb2NoYUdsb2JhbFRlYXJkb3duJ11cbiAgfSk7XG4gIHZhbGlkYXRlTGVnYWN5UGx1Z2luKGFyZ3YsICd1aScsIE1vY2hhLmludGVyZmFjZXMpO1xuXG4gIHJvb3RIb29rcyA9IHBsdWdpbnMucm9vdEhvb2tzO1xuICBib290c3RyYXAgPSAoKSA9PiB7fTtcbiAgZGVidWcoJ2Jvb3RzdHJhcCgpOiBmaW5pc2hlZCB3aXRoIGFyZ3M6ICVPJywgYXJndik7XG59O1xuXG4vKipcbiAqIFJ1bnMgYSBzaW5nbGUgdGVzdCBmaWxlIGluIGEgd29ya2VyIHRocmVhZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlcGF0aCAtIEZpbGVwYXRoIG9mIHRlc3QgZmlsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtzZXJpYWxpemVkT3B0aW9uc10gLSAqKlNlcmlhbGl6ZWQqKiBvcHRpb25zLiBUaGlzIHN0cmluZyB3aWxsIGJlIGV2YWwnZCFcbiAqIEBzZWUgaHR0cHM6Ly9ucG0uaW0vc2VyaWFsaXplLWphdmFzY3JpcHRcbiAqIEByZXR1cm5zIHtQcm9taXNlPHtmYWlsdXJlczogbnVtYmVyLCBldmVudHM6IEJ1ZmZlcmVkRXZlbnRbXX0+fSAtIFRlc3RcbiAqIGZhaWx1cmUgY291bnQgYW5kIGxpc3Qgb2YgZXZlbnRzLlxuICovXG5hc3luYyBmdW5jdGlvbiBydW4oZmlsZXBhdGgsIHNlcmlhbGl6ZWRPcHRpb25zID0gJ3t9Jykge1xuICBpZiAoIWZpbGVwYXRoKSB7XG4gICAgdGhyb3cgY3JlYXRlSW52YWxpZEFyZ3VtZW50VHlwZUVycm9yKFxuICAgICAgJ0V4cGVjdGVkIGEgbm9uLWVtcHR5IFwiZmlsZXBhdGhcIiBhcmd1bWVudCcsXG4gICAgICAnZmlsZScsXG4gICAgICAnc3RyaW5nJ1xuICAgICk7XG4gIH1cblxuICBkZWJ1ZygncnVuKCk6IHJ1bm5pbmcgdGVzdCBmaWxlICVzJywgZmlsZXBhdGgpO1xuXG4gIGlmICh0eXBlb2Ygc2VyaWFsaXplZE9wdGlvbnMgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgY3JlYXRlSW52YWxpZEFyZ3VtZW50VHlwZUVycm9yKFxuICAgICAgJ3J1bigpIGV4cGVjdHMgc2Vjb25kIHBhcmFtZXRlciB0byBiZSBhIHN0cmluZyB3aGljaCB3YXMgc2VyaWFsaXplZCBieSB0aGUgYHNlcmlhbGl6ZS1qYXZhc2NyaXB0YCBtb2R1bGUnLFxuICAgICAgJ3NlcmlhbGl6ZWRPcHRpb25zJyxcbiAgICAgICdzdHJpbmcnXG4gICAgKTtcbiAgfVxuICBsZXQgYXJndjtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXZhbFxuICAgIGFyZ3YgPSBldmFsKCcoJyArIHNlcmlhbGl6ZWRPcHRpb25zICsgJyknKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgY3JlYXRlSW52YWxpZEFyZ3VtZW50VmFsdWVFcnJvcihcbiAgICAgICdydW4oKSB3YXMgdW5hYmxlIHRvIGRlc2VyaWFsaXplIHRoZSBvcHRpb25zJyxcbiAgICAgICdzZXJpYWxpemVkT3B0aW9ucycsXG4gICAgICBzZXJpYWxpemVkT3B0aW9uc1xuICAgICk7XG4gIH1cblxuICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7dWk6ICdiZGQnfSwgYXJndiwge1xuICAgIC8vIGlmIHRoaXMgd2FzIHRydWUsIGl0IHdvdWxkIGNhdXNlIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgICBwYXJhbGxlbDogZmFsc2UsXG4gICAgLy8gdGhpcyBkb2Vzbid0IHdvcmsgaW4gcGFyYWxsZWwgbW9kZVxuICAgIGZvcmJpZE9ubHk6IHRydWUsXG4gICAgLy8gaXQncyB1c2VmdWwgZm9yIGEgTW9jaGEgaW5zdGFuY2UgdG8ga25vdyBpZiBpdCdzIHJ1bm5pbmcgaW4gYSB3b3JrZXIgcHJvY2Vzcy5cbiAgICBpc1dvcmtlcjogdHJ1ZVxuICB9KTtcblxuICBhd2FpdCBib290c3RyYXAob3B0cyk7XG5cbiAgb3B0cy5yb290SG9va3MgPSByb290SG9va3M7XG5cbiAgY29uc3QgbW9jaGEgPSBuZXcgTW9jaGEob3B0cykuYWRkRmlsZShmaWxlcGF0aCk7XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBtb2NoYS5sb2FkRmlsZXNBc3luYygpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWJ1ZygncnVuKCk6IGNvdWxkIG5vdCBsb2FkIGZpbGUgJXM6ICVzJywgZmlsZXBhdGgsIGVycik7XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBsZXQgZGVidWdJbnRlcnZhbDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmIChpc0RlYnVnRW5hYmxlZCkge1xuICAgICAgZGVidWdJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgZGVidWcoJ3J1bigpOiBzdGlsbCBydW5uaW5nICVzLi4uJywgZmlsZXBhdGgpO1xuICAgICAgfSwgNTAwMCkudW5yZWYoKTtcbiAgICB9XG4gICAgbW9jaGEucnVuKHJlc3VsdCA9PiB7XG4gICAgICAvLyBSdW5uZXIgYWRkcyB0aGVzZTsgaWYgd2UgZG9uJ3QgcmVtb3ZlIHRoZW0sIHdlJ2xsIGdldCBhIGxlYWsuXG4gICAgICBwcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycygndW5jYXVnaHRFeGNlcHRpb24nKTtcbiAgICAgIHByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzKCd1bmhhbmRsZWRSZWplY3Rpb24nKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHNlcmlhbGl6ZShyZXN1bHQpO1xuICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICAncnVuKCk6IGNvbXBsZXRlZCBydW4gd2l0aCAlZCB0ZXN0IGZhaWx1cmVzOyByZXR1cm5pbmcgdG8gbWFpbiBwcm9jZXNzJyxcbiAgICAgICAgICB0eXBlb2YgcmVzdWx0LmZhaWx1cmVzID09PSAnbnVtYmVyJyA/IHJlc3VsdC5mYWlsdXJlcyA6IDBcbiAgICAgICAgKTtcbiAgICAgICAgcmVzb2x2ZShzZXJpYWxpemVkKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBUT0RPOiBmaWd1cmUgb3V0IGV4YWN0bHkgd2hhdCB0aGUgc2FkIHBhdGggbG9va3MgbGlrZSBoZXJlLlxuICAgICAgICAvLyByZWplY3Rpb24gc2hvdWxkIG9ubHkgaGFwcGVuIGlmIGFuIGVycm9yIGlzIFwidW5yZWNvdmVyYWJsZVwiXG4gICAgICAgIGRlYnVnKCdydW4oKTogc2VyaWFsaXphdGlvbiBmYWlsZWQ7IHJlamVjdGluZzogJU8nLCBlcnIpO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoZGVidWdJbnRlcnZhbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyB0aGlzIHJlZ2lzdGVycyB0aGUgYHJ1bmAgZnVuY3Rpb24uXG53b3JrZXJwb29sLndvcmtlcih7cnVufSk7XG5cbmRlYnVnKCdzdGFydGVkIHdvcmtlciBwcm9jZXNzJyk7XG5cbi8vIGZvciB0ZXN0aW5nXG5leHBvcnRzLnJ1biA9IHJ1bjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/nodejs/worker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/pending.js":
/*!*******************************************!*\
  !*** ./node_modules/mocha/lib/pending.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n @module Pending\n*/\n\nmodule.exports = Pending;\n\n/**\n * Initialize a new `Pending` error with the given message.\n *\n * @param {string} message\n */\nfunction Pending(message) {\n  this.message = message;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3BlbmRpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3BlbmRpbmcuanM/N2Y1NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuIEBtb2R1bGUgUGVuZGluZ1xuKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQZW5kaW5nO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFBlbmRpbmdgIGVycm9yIHdpdGggdGhlIGdpdmVuIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gUGVuZGluZyhtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/pending.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/plugin-loader.js":
/*!*************************************************!*\
  !*** ./node_modules/mocha/lib/plugin-loader.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Provides a way to load \"plugins\" as provided by the user.\n *\n * Currently supports:\n *\n * - Root hooks\n * - Global fixtures (setup/teardown)\n * @private\n * @module plugin\n */\n\n\n\nconst debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")('mocha:plugin-loader');\nconst {\n  createInvalidPluginDefinitionError,\n  createInvalidPluginImplementationError\n} = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/mocha/lib/errors.js\");\nconst {castArray} = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\");\n\n/**\n * Built-in plugin definitions.\n */\nconst MochaPlugins = [\n  /**\n   * Root hook plugin definition\n   * @type {PluginDefinition}\n   */\n  {\n    exportName: 'mochaHooks',\n    optionName: 'rootHooks',\n    validate(value) {\n      if (\n        Array.isArray(value) ||\n        (typeof value !== 'function' && typeof value !== 'object')\n      ) {\n        throw createInvalidPluginImplementationError(\n          `mochaHooks must be an object or a function returning (or fulfilling with) an object`\n        );\n      }\n    },\n    async finalize(rootHooks) {\n      if (rootHooks.length) {\n        const rootHookObjects = await Promise.all(\n          rootHooks.map(async hook =>\n            typeof hook === 'function' ? hook() : hook\n          )\n        );\n\n        return rootHookObjects.reduce(\n          (acc, hook) => {\n            hook = {\n              beforeAll: [],\n              beforeEach: [],\n              afterAll: [],\n              afterEach: [],\n              ...hook\n            };\n            return {\n              beforeAll: [...acc.beforeAll, ...castArray(hook.beforeAll)],\n              beforeEach: [...acc.beforeEach, ...castArray(hook.beforeEach)],\n              afterAll: [...acc.afterAll, ...castArray(hook.afterAll)],\n              afterEach: [...acc.afterEach, ...castArray(hook.afterEach)]\n            };\n          },\n          {beforeAll: [], beforeEach: [], afterAll: [], afterEach: []}\n        );\n      }\n    }\n  },\n  /**\n   * Global setup fixture plugin definition\n   * @type {PluginDefinition}\n   */\n  {\n    exportName: 'mochaGlobalSetup',\n    optionName: 'globalSetup',\n    validate(value) {\n      let isValid = true;\n      if (Array.isArray(value)) {\n        if (value.some(item => typeof item !== 'function')) {\n          isValid = false;\n        }\n      } else if (typeof value !== 'function') {\n        isValid = false;\n      }\n      if (!isValid) {\n        throw createInvalidPluginImplementationError(\n          `mochaGlobalSetup must be a function or an array of functions`,\n          {pluginDef: this, pluginImpl: value}\n        );\n      }\n    }\n  },\n  /**\n   * Global teardown fixture plugin definition\n   * @type {PluginDefinition}\n   */\n  {\n    exportName: 'mochaGlobalTeardown',\n    optionName: 'globalTeardown',\n    validate(value) {\n      let isValid = true;\n      if (Array.isArray(value)) {\n        if (value.some(item => typeof item !== 'function')) {\n          isValid = false;\n        }\n      } else if (typeof value !== 'function') {\n        isValid = false;\n      }\n      if (!isValid) {\n        throw createInvalidPluginImplementationError(\n          `mochaGlobalTeardown must be a function or an array of functions`,\n          {pluginDef: this, pluginImpl: value}\n        );\n      }\n    }\n  }\n];\n\n/**\n * Contains a registry of [plugin definitions]{@link PluginDefinition} and discovers plugin implementations in user-supplied code.\n *\n * - [load()]{@link #load} should be called for all required modules\n * - The result of [finalize()]{@link #finalize} should be merged into the options for the [Mocha]{@link Mocha} constructor.\n * @private\n */\nclass PluginLoader {\n  /**\n   * Initializes plugin names, plugin map, etc.\n   * @param {PluginLoaderOptions} [opts] - Options\n   */\n  constructor({pluginDefs = MochaPlugins, ignore = []} = {}) {\n    /**\n     * Map of registered plugin defs\n     * @type {Map<string,PluginDefinition>}\n     */\n    this.registered = new Map();\n\n    /**\n     * Cache of known `optionName` values for checking conflicts\n     * @type {Set<string>}\n     */\n    this.knownOptionNames = new Set();\n\n    /**\n     * Cache of known `exportName` values for checking conflicts\n     * @type {Set<string>}\n     */\n    this.knownExportNames = new Set();\n\n    /**\n     * Map of user-supplied plugin implementations\n     * @type {Map<string,Array<*>>}\n     */\n    this.loaded = new Map();\n\n    /**\n     * Set of ignored plugins by export name\n     * @type {Set<string>}\n     */\n    this.ignoredExportNames = new Set(castArray(ignore));\n\n    castArray(pluginDefs).forEach(pluginDef => {\n      this.register(pluginDef);\n    });\n\n    debug(\n      'registered %d plugin defs (%d ignored)',\n      this.registered.size,\n      this.ignoredExportNames.size\n    );\n  }\n\n  /**\n   * Register a plugin\n   * @param {PluginDefinition} pluginDef - Plugin definition\n   */\n  register(pluginDef) {\n    if (!pluginDef || typeof pluginDef !== 'object') {\n      throw createInvalidPluginDefinitionError(\n        'pluginDef is non-object or falsy',\n        pluginDef\n      );\n    }\n    if (!pluginDef.exportName) {\n      throw createInvalidPluginDefinitionError(\n        `exportName is expected to be a non-empty string`,\n        pluginDef\n      );\n    }\n    let {exportName} = pluginDef;\n    if (this.ignoredExportNames.has(exportName)) {\n      debug(\n        'refusing to register ignored plugin with export name \"%s\"',\n        exportName\n      );\n      return;\n    }\n    exportName = String(exportName);\n    pluginDef.optionName = String(pluginDef.optionName || exportName);\n    if (this.knownExportNames.has(exportName)) {\n      throw createInvalidPluginDefinitionError(\n        `Plugin definition conflict: ${exportName}; exportName must be unique`,\n        pluginDef\n      );\n    }\n    this.loaded.set(exportName, []);\n    this.registered.set(exportName, pluginDef);\n    this.knownExportNames.add(exportName);\n    this.knownOptionNames.add(pluginDef.optionName);\n    debug('registered plugin def \"%s\"', exportName);\n  }\n\n  /**\n   * Inspects a module's exports for known plugins and keeps them in memory.\n   *\n   * @param {*} requiredModule - The exports of a module loaded via `--require`\n   * @returns {boolean} If one or more plugins was found, return `true`.\n   */\n  load(requiredModule) {\n    // we should explicitly NOT fail if other stuff is exported.\n    // we only care about the plugins we know about.\n    if (requiredModule && typeof requiredModule === 'object') {\n      return Array.from(this.knownExportNames).reduce(\n        (pluginImplFound, pluginName) => {\n          const pluginImpl = requiredModule[pluginName];\n          if (pluginImpl) {\n            const plugin = this.registered.get(pluginName);\n            if (typeof plugin.validate === 'function') {\n              plugin.validate(pluginImpl);\n            }\n            this.loaded.set(pluginName, [\n              ...this.loaded.get(pluginName),\n              ...castArray(pluginImpl)\n            ]);\n            return true;\n          }\n          return pluginImplFound;\n        },\n        false\n      );\n    }\n    return false;\n  }\n\n  /**\n   * Call the `finalize()` function of each known plugin definition on the plugins found by [load()]{@link PluginLoader#load}.\n   *\n   * Output suitable for passing as input into {@link Mocha} constructor.\n   * @returns {Promise<object>} Object having keys corresponding to registered plugin definitions' `optionName` prop (or `exportName`, if none), and the values are the implementations as provided by a user.\n   */\n  async finalize() {\n    const finalizedPlugins = Object.create(null);\n\n    for await (const [exportName, pluginImpls] of this.loaded.entries()) {\n      if (pluginImpls.length) {\n        const plugin = this.registered.get(exportName);\n        finalizedPlugins[plugin.optionName] =\n          typeof plugin.finalize === 'function'\n            ? await plugin.finalize(pluginImpls)\n            : pluginImpls;\n      }\n    }\n\n    debug('finalized plugins: %O', finalizedPlugins);\n    return finalizedPlugins;\n  }\n\n  /**\n   * Constructs a {@link PluginLoader}\n   * @param {PluginLoaderOptions} [opts] - Plugin loader options\n   */\n  static create({pluginDefs = MochaPlugins, ignore = []} = {}) {\n    return new PluginLoader({pluginDefs, ignore});\n  }\n}\n\nmodule.exports = PluginLoader;\n\n/**\n * Options for {@link PluginLoader}\n * @typedef {Object} PluginLoaderOptions\n * @property {PluginDefinition[]} [pluginDefs] - Plugin definitions\n * @property {string[]} [ignore] - A list of plugins to ignore when loading\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3BsdWdpbi1sb2FkZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLHNEQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDBEQUFVO0FBQ3RCLE9BQU8sV0FBVyxFQUFFLG1CQUFPLENBQUMsd0RBQVM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLHdCQUF3QjtBQUN2RTtBQUNBLGNBQWMsYUFBYTtBQUMzQixnQ0FBZ0MsaUJBQWlCLGtEQUFrRCxhQUFhO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBLGVBQWUsd0NBQXdDLElBQUk7QUFDM0Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFHQUFxRyx3QkFBd0I7QUFDN0g7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RCxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQixhQUFhLHFCQUFxQjtBQUNsQztBQUNBLGlCQUFpQix3Q0FBd0MsSUFBSTtBQUM3RCw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsb0JBQW9CO0FBQ2xDLGNBQWMsVUFBVTtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3BsdWdpbi1sb2FkZXIuanM/YWFlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFByb3ZpZGVzIGEgd2F5IHRvIGxvYWQgXCJwbHVnaW5zXCIgYXMgcHJvdmlkZWQgYnkgdGhlIHVzZXIuXG4gKlxuICogQ3VycmVudGx5IHN1cHBvcnRzOlxuICpcbiAqIC0gUm9vdCBob29rc1xuICogLSBHbG9iYWwgZml4dHVyZXMgKHNldHVwL3RlYXJkb3duKVxuICogQHByaXZhdGVcbiAqIEBtb2R1bGUgcGx1Z2luXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21vY2hhOnBsdWdpbi1sb2FkZXInKTtcbmNvbnN0IHtcbiAgY3JlYXRlSW52YWxpZFBsdWdpbkRlZmluaXRpb25FcnJvcixcbiAgY3JlYXRlSW52YWxpZFBsdWdpbkltcGxlbWVudGF0aW9uRXJyb3Jcbn0gPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3Qge2Nhc3RBcnJheX0gPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogQnVpbHQtaW4gcGx1Z2luIGRlZmluaXRpb25zLlxuICovXG5jb25zdCBNb2NoYVBsdWdpbnMgPSBbXG4gIC8qKlxuICAgKiBSb290IGhvb2sgcGx1Z2luIGRlZmluaXRpb25cbiAgICogQHR5cGUge1BsdWdpbkRlZmluaXRpb259XG4gICAqL1xuICB7XG4gICAgZXhwb3J0TmFtZTogJ21vY2hhSG9va3MnLFxuICAgIG9wdGlvbk5hbWU6ICdyb290SG9va3MnLFxuICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JylcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkUGx1Z2luSW1wbGVtZW50YXRpb25FcnJvcihcbiAgICAgICAgICBgbW9jaGFIb29rcyBtdXN0IGJlIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uIHJldHVybmluZyAob3IgZnVsZmlsbGluZyB3aXRoKSBhbiBvYmplY3RgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyBmaW5hbGl6ZShyb290SG9va3MpIHtcbiAgICAgIGlmIChyb290SG9va3MubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJvb3RIb29rT2JqZWN0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIHJvb3RIb29rcy5tYXAoYXN5bmMgaG9vayA9PlxuICAgICAgICAgICAgdHlwZW9mIGhvb2sgPT09ICdmdW5jdGlvbicgPyBob29rKCkgOiBob29rXG4gICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiByb290SG9va09iamVjdHMucmVkdWNlKFxuICAgICAgICAgIChhY2MsIGhvb2spID0+IHtcbiAgICAgICAgICAgIGhvb2sgPSB7XG4gICAgICAgICAgICAgIGJlZm9yZUFsbDogW10sXG4gICAgICAgICAgICAgIGJlZm9yZUVhY2g6IFtdLFxuICAgICAgICAgICAgICBhZnRlckFsbDogW10sXG4gICAgICAgICAgICAgIGFmdGVyRWFjaDogW10sXG4gICAgICAgICAgICAgIC4uLmhvb2tcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBiZWZvcmVBbGw6IFsuLi5hY2MuYmVmb3JlQWxsLCAuLi5jYXN0QXJyYXkoaG9vay5iZWZvcmVBbGwpXSxcbiAgICAgICAgICAgICAgYmVmb3JlRWFjaDogWy4uLmFjYy5iZWZvcmVFYWNoLCAuLi5jYXN0QXJyYXkoaG9vay5iZWZvcmVFYWNoKV0sXG4gICAgICAgICAgICAgIGFmdGVyQWxsOiBbLi4uYWNjLmFmdGVyQWxsLCAuLi5jYXN0QXJyYXkoaG9vay5hZnRlckFsbCldLFxuICAgICAgICAgICAgICBhZnRlckVhY2g6IFsuLi5hY2MuYWZ0ZXJFYWNoLCAuLi5jYXN0QXJyYXkoaG9vay5hZnRlckVhY2gpXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtiZWZvcmVBbGw6IFtdLCBiZWZvcmVFYWNoOiBbXSwgYWZ0ZXJBbGw6IFtdLCBhZnRlckVhY2g6IFtdfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIEdsb2JhbCBzZXR1cCBmaXh0dXJlIHBsdWdpbiBkZWZpbml0aW9uXG4gICAqIEB0eXBlIHtQbHVnaW5EZWZpbml0aW9ufVxuICAgKi9cbiAge1xuICAgIGV4cG9ydE5hbWU6ICdtb2NoYUdsb2JhbFNldHVwJyxcbiAgICBvcHRpb25OYW1lOiAnZ2xvYmFsU2V0dXAnLFxuICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICBsZXQgaXNWYWxpZCA9IHRydWU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHZhbHVlLnNvbWUoaXRlbSA9PiB0eXBlb2YgaXRlbSAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkUGx1Z2luSW1wbGVtZW50YXRpb25FcnJvcihcbiAgICAgICAgICBgbW9jaGFHbG9iYWxTZXR1cCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2YgZnVuY3Rpb25zYCxcbiAgICAgICAgICB7cGx1Z2luRGVmOiB0aGlzLCBwbHVnaW5JbXBsOiB2YWx1ZX1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBHbG9iYWwgdGVhcmRvd24gZml4dHVyZSBwbHVnaW4gZGVmaW5pdGlvblxuICAgKiBAdHlwZSB7UGx1Z2luRGVmaW5pdGlvbn1cbiAgICovXG4gIHtcbiAgICBleHBvcnROYW1lOiAnbW9jaGFHbG9iYWxUZWFyZG93bicsXG4gICAgb3B0aW9uTmFtZTogJ2dsb2JhbFRlYXJkb3duJyxcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgbGV0IGlzVmFsaWQgPSB0cnVlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5zb21lKGl0ZW0gPT4gdHlwZW9mIGl0ZW0gIT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFBsdWdpbkltcGxlbWVudGF0aW9uRXJyb3IoXG4gICAgICAgICAgYG1vY2hhR2xvYmFsVGVhcmRvd24gbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIGFycmF5IG9mIGZ1bmN0aW9uc2AsXG4gICAgICAgICAge3BsdWdpbkRlZjogdGhpcywgcGx1Z2luSW1wbDogdmFsdWV9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5dO1xuXG4vKipcbiAqIENvbnRhaW5zIGEgcmVnaXN0cnkgb2YgW3BsdWdpbiBkZWZpbml0aW9uc117QGxpbmsgUGx1Z2luRGVmaW5pdGlvbn0gYW5kIGRpc2NvdmVycyBwbHVnaW4gaW1wbGVtZW50YXRpb25zIGluIHVzZXItc3VwcGxpZWQgY29kZS5cbiAqXG4gKiAtIFtsb2FkKClde0BsaW5rICNsb2FkfSBzaG91bGQgYmUgY2FsbGVkIGZvciBhbGwgcmVxdWlyZWQgbW9kdWxlc1xuICogLSBUaGUgcmVzdWx0IG9mIFtmaW5hbGl6ZSgpXXtAbGluayAjZmluYWxpemV9IHNob3VsZCBiZSBtZXJnZWQgaW50byB0aGUgb3B0aW9ucyBmb3IgdGhlIFtNb2NoYV17QGxpbmsgTW9jaGF9IGNvbnN0cnVjdG9yLlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUGx1Z2luTG9hZGVyIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHBsdWdpbiBuYW1lcywgcGx1Z2luIG1hcCwgZXRjLlxuICAgKiBAcGFyYW0ge1BsdWdpbkxvYWRlck9wdGlvbnN9IFtvcHRzXSAtIE9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHtwbHVnaW5EZWZzID0gTW9jaGFQbHVnaW5zLCBpZ25vcmUgPSBbXX0gPSB7fSkge1xuICAgIC8qKlxuICAgICAqIE1hcCBvZiByZWdpc3RlcmVkIHBsdWdpbiBkZWZzXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsUGx1Z2luRGVmaW5pdGlvbj59XG4gICAgICovXG4gICAgdGhpcy5yZWdpc3RlcmVkID0gbmV3IE1hcCgpO1xuXG4gICAgLyoqXG4gICAgICogQ2FjaGUgb2Yga25vd24gYG9wdGlvbk5hbWVgIHZhbHVlcyBmb3IgY2hlY2tpbmcgY29uZmxpY3RzXG4gICAgICogQHR5cGUge1NldDxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMua25vd25PcHRpb25OYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIC8qKlxuICAgICAqIENhY2hlIG9mIGtub3duIGBleHBvcnROYW1lYCB2YWx1ZXMgZm9yIGNoZWNraW5nIGNvbmZsaWN0c1xuICAgICAqIEB0eXBlIHtTZXQ8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmtub3duRXhwb3J0TmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICAvKipcbiAgICAgKiBNYXAgb2YgdXNlci1zdXBwbGllZCBwbHVnaW4gaW1wbGVtZW50YXRpb25zXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsQXJyYXk8Kj4+fVxuICAgICAqL1xuICAgIHRoaXMubG9hZGVkID0gbmV3IE1hcCgpO1xuXG4gICAgLyoqXG4gICAgICogU2V0IG9mIGlnbm9yZWQgcGx1Z2lucyBieSBleHBvcnQgbmFtZVxuICAgICAqIEB0eXBlIHtTZXQ8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmlnbm9yZWRFeHBvcnROYW1lcyA9IG5ldyBTZXQoY2FzdEFycmF5KGlnbm9yZSkpO1xuXG4gICAgY2FzdEFycmF5KHBsdWdpbkRlZnMpLmZvckVhY2gocGx1Z2luRGVmID0+IHtcbiAgICAgIHRoaXMucmVnaXN0ZXIocGx1Z2luRGVmKTtcbiAgICB9KTtcblxuICAgIGRlYnVnKFxuICAgICAgJ3JlZ2lzdGVyZWQgJWQgcGx1Z2luIGRlZnMgKCVkIGlnbm9yZWQpJyxcbiAgICAgIHRoaXMucmVnaXN0ZXJlZC5zaXplLFxuICAgICAgdGhpcy5pZ25vcmVkRXhwb3J0TmFtZXMuc2l6ZVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBwbHVnaW5cbiAgICogQHBhcmFtIHtQbHVnaW5EZWZpbml0aW9ufSBwbHVnaW5EZWYgLSBQbHVnaW4gZGVmaW5pdGlvblxuICAgKi9cbiAgcmVnaXN0ZXIocGx1Z2luRGVmKSB7XG4gICAgaWYgKCFwbHVnaW5EZWYgfHwgdHlwZW9mIHBsdWdpbkRlZiAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IGNyZWF0ZUludmFsaWRQbHVnaW5EZWZpbml0aW9uRXJyb3IoXG4gICAgICAgICdwbHVnaW5EZWYgaXMgbm9uLW9iamVjdCBvciBmYWxzeScsXG4gICAgICAgIHBsdWdpbkRlZlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFwbHVnaW5EZWYuZXhwb3J0TmFtZSkge1xuICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFBsdWdpbkRlZmluaXRpb25FcnJvcihcbiAgICAgICAgYGV4cG9ydE5hbWUgaXMgZXhwZWN0ZWQgdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nYCxcbiAgICAgICAgcGx1Z2luRGVmXG4gICAgICApO1xuICAgIH1cbiAgICBsZXQge2V4cG9ydE5hbWV9ID0gcGx1Z2luRGVmO1xuICAgIGlmICh0aGlzLmlnbm9yZWRFeHBvcnROYW1lcy5oYXMoZXhwb3J0TmFtZSkpIHtcbiAgICAgIGRlYnVnKFxuICAgICAgICAncmVmdXNpbmcgdG8gcmVnaXN0ZXIgaWdub3JlZCBwbHVnaW4gd2l0aCBleHBvcnQgbmFtZSBcIiVzXCInLFxuICAgICAgICBleHBvcnROYW1lXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBleHBvcnROYW1lID0gU3RyaW5nKGV4cG9ydE5hbWUpO1xuICAgIHBsdWdpbkRlZi5vcHRpb25OYW1lID0gU3RyaW5nKHBsdWdpbkRlZi5vcHRpb25OYW1lIHx8IGV4cG9ydE5hbWUpO1xuICAgIGlmICh0aGlzLmtub3duRXhwb3J0TmFtZXMuaGFzKGV4cG9ydE5hbWUpKSB7XG4gICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkUGx1Z2luRGVmaW5pdGlvbkVycm9yKFxuICAgICAgICBgUGx1Z2luIGRlZmluaXRpb24gY29uZmxpY3Q6ICR7ZXhwb3J0TmFtZX07IGV4cG9ydE5hbWUgbXVzdCBiZSB1bmlxdWVgLFxuICAgICAgICBwbHVnaW5EZWZcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMubG9hZGVkLnNldChleHBvcnROYW1lLCBbXSk7XG4gICAgdGhpcy5yZWdpc3RlcmVkLnNldChleHBvcnROYW1lLCBwbHVnaW5EZWYpO1xuICAgIHRoaXMua25vd25FeHBvcnROYW1lcy5hZGQoZXhwb3J0TmFtZSk7XG4gICAgdGhpcy5rbm93bk9wdGlvbk5hbWVzLmFkZChwbHVnaW5EZWYub3B0aW9uTmFtZSk7XG4gICAgZGVidWcoJ3JlZ2lzdGVyZWQgcGx1Z2luIGRlZiBcIiVzXCInLCBleHBvcnROYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNwZWN0cyBhIG1vZHVsZSdzIGV4cG9ydHMgZm9yIGtub3duIHBsdWdpbnMgYW5kIGtlZXBzIHRoZW0gaW4gbWVtb3J5LlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHJlcXVpcmVkTW9kdWxlIC0gVGhlIGV4cG9ydHMgb2YgYSBtb2R1bGUgbG9hZGVkIHZpYSBgLS1yZXF1aXJlYFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgb25lIG9yIG1vcmUgcGx1Z2lucyB3YXMgZm91bmQsIHJldHVybiBgdHJ1ZWAuXG4gICAqL1xuICBsb2FkKHJlcXVpcmVkTW9kdWxlKSB7XG4gICAgLy8gd2Ugc2hvdWxkIGV4cGxpY2l0bHkgTk9UIGZhaWwgaWYgb3RoZXIgc3R1ZmYgaXMgZXhwb3J0ZWQuXG4gICAgLy8gd2Ugb25seSBjYXJlIGFib3V0IHRoZSBwbHVnaW5zIHdlIGtub3cgYWJvdXQuXG4gICAgaWYgKHJlcXVpcmVkTW9kdWxlICYmIHR5cGVvZiByZXF1aXJlZE1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMua25vd25FeHBvcnROYW1lcykucmVkdWNlKFxuICAgICAgICAocGx1Z2luSW1wbEZvdW5kLCBwbHVnaW5OYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3QgcGx1Z2luSW1wbCA9IHJlcXVpcmVkTW9kdWxlW3BsdWdpbk5hbWVdO1xuICAgICAgICAgIGlmIChwbHVnaW5JbXBsKSB7XG4gICAgICAgICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnJlZ2lzdGVyZWQuZ2V0KHBsdWdpbk5hbWUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwbHVnaW4udmFsaWRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcGx1Z2luLnZhbGlkYXRlKHBsdWdpbkltcGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2FkZWQuc2V0KHBsdWdpbk5hbWUsIFtcbiAgICAgICAgICAgICAgLi4udGhpcy5sb2FkZWQuZ2V0KHBsdWdpbk5hbWUpLFxuICAgICAgICAgICAgICAuLi5jYXN0QXJyYXkocGx1Z2luSW1wbClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwbHVnaW5JbXBsRm91bmQ7XG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCB0aGUgYGZpbmFsaXplKClgIGZ1bmN0aW9uIG9mIGVhY2gga25vd24gcGx1Z2luIGRlZmluaXRpb24gb24gdGhlIHBsdWdpbnMgZm91bmQgYnkgW2xvYWQoKV17QGxpbmsgUGx1Z2luTG9hZGVyI2xvYWR9LlxuICAgKlxuICAgKiBPdXRwdXQgc3VpdGFibGUgZm9yIHBhc3NpbmcgYXMgaW5wdXQgaW50byB7QGxpbmsgTW9jaGF9IGNvbnN0cnVjdG9yLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBPYmplY3QgaGF2aW5nIGtleXMgY29ycmVzcG9uZGluZyB0byByZWdpc3RlcmVkIHBsdWdpbiBkZWZpbml0aW9ucycgYG9wdGlvbk5hbWVgIHByb3AgKG9yIGBleHBvcnROYW1lYCwgaWYgbm9uZSksIGFuZCB0aGUgdmFsdWVzIGFyZSB0aGUgaW1wbGVtZW50YXRpb25zIGFzIHByb3ZpZGVkIGJ5IGEgdXNlci5cbiAgICovXG4gIGFzeW5jIGZpbmFsaXplKCkge1xuICAgIGNvbnN0IGZpbmFsaXplZFBsdWdpbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgZm9yIGF3YWl0IChjb25zdCBbZXhwb3J0TmFtZSwgcGx1Z2luSW1wbHNdIG9mIHRoaXMubG9hZGVkLmVudHJpZXMoKSkge1xuICAgICAgaWYgKHBsdWdpbkltcGxzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnJlZ2lzdGVyZWQuZ2V0KGV4cG9ydE5hbWUpO1xuICAgICAgICBmaW5hbGl6ZWRQbHVnaW5zW3BsdWdpbi5vcHRpb25OYW1lXSA9XG4gICAgICAgICAgdHlwZW9mIHBsdWdpbi5maW5hbGl6ZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBhd2FpdCBwbHVnaW4uZmluYWxpemUocGx1Z2luSW1wbHMpXG4gICAgICAgICAgICA6IHBsdWdpbkltcGxzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlYnVnKCdmaW5hbGl6ZWQgcGx1Z2luczogJU8nLCBmaW5hbGl6ZWRQbHVnaW5zKTtcbiAgICByZXR1cm4gZmluYWxpemVkUGx1Z2lucztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIFBsdWdpbkxvYWRlcn1cbiAgICogQHBhcmFtIHtQbHVnaW5Mb2FkZXJPcHRpb25zfSBbb3B0c10gLSBQbHVnaW4gbG9hZGVyIG9wdGlvbnNcbiAgICovXG4gIHN0YXRpYyBjcmVhdGUoe3BsdWdpbkRlZnMgPSBNb2NoYVBsdWdpbnMsIGlnbm9yZSA9IFtdfSA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW5Mb2FkZXIoe3BsdWdpbkRlZnMsIGlnbm9yZX0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGx1Z2luTG9hZGVyO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHtAbGluayBQbHVnaW5Mb2FkZXJ9XG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQbHVnaW5Mb2FkZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge1BsdWdpbkRlZmluaXRpb25bXX0gW3BsdWdpbkRlZnNdIC0gUGx1Z2luIGRlZmluaXRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBbaWdub3JlXSAtIEEgbGlzdCBvZiBwbHVnaW5zIHRvIGlnbm9yZSB3aGVuIGxvYWRpbmdcbiAqL1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/plugin-loader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/reporters/base.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/base.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * @module Base\n */\n/**\n * Module dependencies.\n */\n\nvar diff = __webpack_require__(/*! diff */ \"(ssr)/./node_modules/mocha/node_modules/diff/lib/index.js\");\nvar milliseconds = __webpack_require__(/*! ms */ \"(ssr)/./node_modules/ms/index.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\");\nvar supportsColor = __webpack_require__(/*! supports-color */ \"(ssr)/./node_modules/mocha/node_modules/supports-color/index.js\");\nvar symbols = __webpack_require__(/*! log-symbols */ \"(ssr)/./node_modules/log-symbols/index.js\");\nvar constants = (__webpack_require__(/*! ../runner */ \"(ssr)/./node_modules/mocha/lib/runner.js\").constants);\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\n\nconst isBrowser = utils.isBrowser();\n\nfunction getBrowserWindowSize() {\n  if ('innerHeight' in global) {\n    return [global.innerHeight, global.innerWidth];\n  }\n  // In a Web Worker, the DOM Window is not available.\n  return [640, 480];\n}\n\n/**\n * Expose `Base`.\n */\n\nexports = module.exports = Base;\n\n/**\n * Check if both stdio streams are associated with a tty.\n */\n\nvar isatty = isBrowser || (process.stdout.isTTY && process.stderr.isTTY);\n\n/**\n * Save log references to avoid tests interfering (see GH-3604).\n */\nvar consoleLog = console.log;\n\n/**\n * Enable coloring by default, except in the browser interface.\n */\n\nexports.useColors =\n  !isBrowser &&\n  (supportsColor.stdout || process.env.MOCHA_COLORS !== undefined);\n\n/**\n * Inline diffs instead of +/-\n */\n\nexports.inlineDiffs = false;\n\n/**\n * Truncate diffs longer than this value to avoid slow performance\n */\nexports.maxDiffSize = 8192;\n\n/**\n * Default color map.\n */\n\nexports.colors = {\n  pass: 90,\n  fail: 31,\n  'bright pass': 92,\n  'bright fail': 91,\n  'bright yellow': 93,\n  pending: 36,\n  suite: 0,\n  'error title': 0,\n  'error message': 31,\n  'error stack': 90,\n  checkmark: 32,\n  fast: 90,\n  medium: 33,\n  slow: 31,\n  green: 32,\n  light: 90,\n  'diff gutter': 90,\n  'diff added': 32,\n  'diff removed': 31,\n  'diff added inline': '30;42',\n  'diff removed inline': '30;41'\n};\n\n/**\n * Default symbol map.\n */\n\nexports.symbols = {\n  ok: symbols.success,\n  err: symbols.error,\n  dot: '.',\n  comma: ',',\n  bang: '!'\n};\n\n/**\n * Color `str` with the given `type`,\n * allowing colors to be disabled,\n * as well as user-defined color\n * schemes.\n *\n * @private\n * @param {string} type\n * @param {string} str\n * @return {string}\n */\nvar color = (exports.color = function (type, str) {\n  if (!exports.useColors) {\n    return String(str);\n  }\n  return '\\u001b[' + exports.colors[type] + 'm' + str + '\\u001b[0m';\n});\n\n/**\n * Expose term window size, with some defaults for when stderr is not a tty.\n */\n\nexports.window = {\n  width: 75\n};\n\nif (isatty) {\n  if (isBrowser) {\n    exports.window.width = getBrowserWindowSize()[1];\n  } else {\n    exports.window.width = process.stdout.getWindowSize(1)[0];\n  }\n}\n\n/**\n * Expose some basic cursor interactions that are common among reporters.\n */\n\nexports.cursor = {\n  hide: function () {\n    isatty && process.stdout.write('\\u001b[?25l');\n  },\n\n  show: function () {\n    isatty && process.stdout.write('\\u001b[?25h');\n  },\n\n  deleteLine: function () {\n    isatty && process.stdout.write('\\u001b[2K');\n  },\n\n  beginningOfLine: function () {\n    isatty && process.stdout.write('\\u001b[0G');\n  },\n\n  CR: function () {\n    if (isatty) {\n      exports.cursor.deleteLine();\n      exports.cursor.beginningOfLine();\n    } else {\n      process.stdout.write('\\r');\n    }\n  }\n};\n\nvar showDiff = (exports.showDiff = function (err) {\n  return (\n    err &&\n    err.showDiff !== false &&\n    sameType(err.actual, err.expected) &&\n    err.expected !== undefined\n  );\n});\n\nfunction stringifyDiffObjs(err) {\n  if (!utils.isString(err.actual) || !utils.isString(err.expected)) {\n    err.actual = utils.stringify(err.actual);\n    err.expected = utils.stringify(err.expected);\n  }\n}\n\n/**\n * Returns a diff between 2 strings with coloured ANSI output.\n *\n * @description\n * The diff will be either inline or unified dependent on the value\n * of `Base.inlineDiff`.\n *\n * @param {string} actual\n * @param {string} expected\n * @return {string} Diff\n */\n\nvar generateDiff = (exports.generateDiff = function (actual, expected) {\n  try {\n    var maxLen = exports.maxDiffSize;\n    var skipped = 0;\n    if (maxLen > 0) {\n      skipped = Math.max(actual.length - maxLen, expected.length - maxLen);\n      actual = actual.slice(0, maxLen);\n      expected = expected.slice(0, maxLen);\n    }\n    let result = exports.inlineDiffs\n      ? inlineDiff(actual, expected)\n      : unifiedDiff(actual, expected);\n    if (skipped > 0) {\n      result = `${result}\\n      [mocha] output truncated to ${maxLen} characters, see \"maxDiffSize\" reporter-option\\n`;\n    }\n    return result;\n  } catch (err) {\n    var msg =\n      '\\n      ' +\n      color('diff added', '+ expected') +\n      ' ' +\n      color('diff removed', '- actual:  failed to generate Mocha diff') +\n      '\\n';\n    return msg;\n  }\n});\n\n/**\n * Traverses err.cause and returns all stack traces\n *\n * @private\n * @param {Error} err\n * @param {Set<Error>} [seen]\n * @return {FullErrorStack}\n */\nvar getFullErrorStack = function (err, seen) {\n  if (seen && seen.has(err)) {\n    return { message: '', msg: '<circular>', stack: '' };\n  }\n\n  var message;\n\n  if (typeof err.inspect === 'function') {\n    message = err.inspect() + '';\n  } else if (err.message && typeof err.message.toString === 'function') {\n    message = err.message + '';\n  } else {\n    message = '';\n  }\n\n  var msg;\n  var stack = err.stack || message;\n  var index = message ? stack.indexOf(message) : -1;\n\n  if (index === -1) {\n    msg = message;\n  } else {\n    index += message.length;\n    msg = stack.slice(0, index);\n    // remove msg from stack\n    stack = stack.slice(index + 1);\n\n    if (err.cause) {\n      seen = seen || new Set();\n      seen.add(err);\n      const causeStack = getFullErrorStack(err.cause, seen)\n      stack += '\\n   Caused by: ' + causeStack.msg + (causeStack.stack ? '\\n' + causeStack.stack : '');\n    }\n  }\n\n  return {\n    message,\n    msg,\n    stack\n  };\n};\n\n/**\n * Outputs the given `failures` as a list.\n *\n * @public\n * @memberof Mocha.reporters.Base\n * @variation 1\n * @param {Object[]} failures - Each is Test instance with corresponding\n *     Error property\n */\nexports.list = function (failures) {\n  var multipleErr, multipleTest;\n  Base.consoleLog();\n  failures.forEach(function (test, i) {\n    // format\n    var fmt =\n      color('error title', '  %s) %s:\\n') +\n      color('error message', '     %s') +\n      color('error stack', '\\n%s\\n');\n\n    // msg\n    var err;\n    if (test.err && test.err.multiple) {\n      if (multipleTest !== test) {\n        multipleTest = test;\n        multipleErr = [test.err].concat(test.err.multiple);\n      }\n      err = multipleErr.shift();\n    } else {\n      err = test.err;\n    }\n\n    var { message, msg, stack } = getFullErrorStack(err);\n\n    // uncaught\n    if (err.uncaught) {\n      msg = 'Uncaught ' + msg;\n    }\n    // explicitly show diff\n    if (!exports.hideDiff && showDiff(err)) {\n      stringifyDiffObjs(err);\n      fmt =\n        color('error title', '  %s) %s:\\n%s') + color('error stack', '\\n%s\\n');\n      var match = message.match(/^([^:]+): expected/);\n      msg = '\\n      ' + color('error message', match ? match[1] : msg);\n\n      msg += generateDiff(err.actual, err.expected);\n    }\n\n    // indent stack trace\n    stack = stack.replace(/^/gm, '  ');\n\n    // indented test title\n    var testTitle = '';\n    test.titlePath().forEach(function (str, index) {\n      if (index !== 0) {\n        testTitle += '\\n     ';\n      }\n      for (var i = 0; i < index; i++) {\n        testTitle += '  ';\n      }\n      testTitle += str;\n    });\n\n    Base.consoleLog(fmt, i + 1, testTitle, msg, stack);\n  });\n};\n\n/**\n * Constructs a new `Base` reporter instance.\n *\n * @description\n * All other reporters generally inherit from this reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @param {Runner} runner - Instance triggers reporter actions.\n * @param {Object} [options] - runner options\n */\nfunction Base(runner, options) {\n  var failures = (this.failures = []);\n\n  if (!runner) {\n    throw new TypeError('Missing runner argument');\n  }\n  this.options = options || {};\n  this.runner = runner;\n  this.stats = runner.stats; // assigned so Reporters keep a closer reference\n\n  var maxDiffSizeOpt =\n    this.options.reporterOption && this.options.reporterOption.maxDiffSize;\n  if (maxDiffSizeOpt !== undefined && !isNaN(Number(maxDiffSizeOpt))) {\n    exports.maxDiffSize = Number(maxDiffSizeOpt);\n  }\n\n  runner.on(EVENT_TEST_PASS, function (test) {\n    if (test.duration > test.slow()) {\n      test.speed = 'slow';\n    } else if (test.duration > test.slow() / 2) {\n      test.speed = 'medium';\n    } else {\n      test.speed = 'fast';\n    }\n  });\n\n  runner.on(EVENT_TEST_FAIL, function (test, err) {\n    if (showDiff(err)) {\n      stringifyDiffObjs(err);\n    }\n    // more than one error per test\n    if (test.err && err instanceof Error) {\n      test.err.multiple = (test.err.multiple || []).concat(err);\n    } else {\n      test.err = err;\n    }\n    failures.push(test);\n  });\n}\n\n/**\n * Outputs common epilogue used by many of the bundled reporters.\n *\n * @public\n * @memberof Mocha.reporters\n */\nBase.prototype.epilogue = function () {\n  var stats = this.stats;\n  var fmt;\n\n  Base.consoleLog();\n\n  // passes\n  fmt =\n    color('bright pass', ' ') +\n    color('green', ' %d passing') +\n    color('light', ' (%s)');\n\n  Base.consoleLog(fmt, stats.passes || 0, milliseconds(stats.duration));\n\n  // pending\n  if (stats.pending) {\n    fmt = color('pending', ' ') + color('pending', ' %d pending');\n\n    Base.consoleLog(fmt, stats.pending);\n  }\n\n  // failures\n  if (stats.failures) {\n    fmt = color('fail', '  %d failing');\n\n    Base.consoleLog(fmt, stats.failures);\n\n    Base.list(this.failures);\n    Base.consoleLog();\n  }\n\n  Base.consoleLog();\n};\n\n/**\n * Pads the given `str` to `len`.\n *\n * @private\n * @param {string} str\n * @param {string} len\n * @return {string}\n */\nfunction pad(str, len) {\n  str = String(str);\n  return Array(len - str.length + 1).join(' ') + str;\n}\n\n/**\n * Returns inline diff between 2 strings with coloured ANSI output.\n *\n * @private\n * @param {String} actual\n * @param {String} expected\n * @return {string} Diff\n */\nfunction inlineDiff(actual, expected) {\n  var msg = errorDiff(actual, expected);\n\n  // linenos\n  var lines = msg.split('\\n');\n  if (lines.length > 4) {\n    var width = String(lines.length).length;\n    msg = lines\n      .map(function (str, i) {\n        return pad(++i, width) + ' |' + ' ' + str;\n      })\n      .join('\\n');\n  }\n\n  // legend\n  msg =\n    '\\n' +\n    color('diff removed inline', 'actual') +\n    ' ' +\n    color('diff added inline', 'expected') +\n    '\\n\\n' +\n    msg +\n    '\\n';\n\n  // indent\n  msg = msg.replace(/^/gm, '      ');\n  return msg;\n}\n\n/**\n * Returns unified diff between two strings with coloured ANSI output.\n *\n * @private\n * @param {String} actual\n * @param {String} expected\n * @return {string} The diff.\n */\nfunction unifiedDiff(actual, expected) {\n  var indent = '      ';\n  function cleanUp(line) {\n    if (line[0] === '+') {\n      return indent + colorLines('diff added', line);\n    }\n    if (line[0] === '-') {\n      return indent + colorLines('diff removed', line);\n    }\n    if (line.match(/@@/)) {\n      return '--';\n    }\n    if (line.match(/\\\\ No newline/)) {\n      return null;\n    }\n    return indent + line;\n  }\n  function notBlank(line) {\n    return typeof line !== 'undefined' && line !== null;\n  }\n  var msg = diff.createPatch('string', actual, expected);\n  var lines = msg.split('\\n').splice(5);\n  return (\n    '\\n      ' +\n    colorLines('diff added', '+ expected') +\n    ' ' +\n    colorLines('diff removed', '- actual') +\n    '\\n\\n' +\n    lines.map(cleanUp).filter(notBlank).join('\\n')\n  );\n}\n\n/**\n * Returns character diff for `err`.\n *\n * @private\n * @param {String} actual\n * @param {String} expected\n * @return {string} the diff\n */\nfunction errorDiff(actual, expected) {\n  return diff\n    .diffWordsWithSpace(actual, expected)\n    .map(function (str) {\n      if (str.added) {\n        return colorLines('diff added inline', str.value);\n      }\n      if (str.removed) {\n        return colorLines('diff removed inline', str.value);\n      }\n      return str.value;\n    })\n    .join('');\n}\n\n/**\n * Colors lines for `str`, using the color `name`.\n *\n * @private\n * @param {string} name\n * @param {string} str\n * @return {string}\n */\nfunction colorLines(name, str) {\n  return str\n    .split('\\n')\n    .map(function (str) {\n      return color(name, str);\n    })\n    .join('\\n');\n}\n\n/**\n * Object#toString reference.\n */\nvar objToString = Object.prototype.toString;\n\n/**\n * Checks that a / b have the same type.\n *\n * @private\n * @param {Object} a\n * @param {Object} b\n * @return {boolean}\n */\nfunction sameType(a, b) {\n  return objToString.call(a) === objToString.call(b);\n}\n\nBase.consoleLog = consoleLog;\n\nBase.abstract = true;\n\n/**\n * An object with all stack traces recursively mounted from each err.cause\n * @memberof module:lib/reporters/base\n * @typedef {Object} FullErrorStack\n * @property {string} message\n * @property {string} msg\n * @property {string} stack\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9iYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyx1RUFBTTtBQUN6QixtQkFBbUIsbUJBQU8sQ0FBQyw0Q0FBSTtBQUMvQixZQUFZLG1CQUFPLENBQUMseURBQVU7QUFDOUIsb0JBQW9CLG1CQUFPLENBQUMsdUZBQWdCO0FBQzVDLGNBQWMsbUJBQU8sQ0FBQyw4REFBYTtBQUNuQyxnQkFBZ0IsNEZBQThCO0FBQzlDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksb0JB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cy9tb2NoYS9saWIvcmVwb3J0ZXJzL2Jhc2UuanM/ZTJhNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBtb2R1bGUgQmFzZVxuICovXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGRpZmYgPSByZXF1aXJlKCdkaWZmJyk7XG52YXIgbWlsbGlzZWNvbmRzID0gcmVxdWlyZSgnbXMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgc3VwcG9ydHNDb2xvciA9IHJlcXVpcmUoJ3N1cHBvcnRzLWNvbG9yJyk7XG52YXIgc3ltYm9scyA9IHJlcXVpcmUoJ2xvZy1zeW1ib2xzJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vcnVubmVyJykuY29uc3RhbnRzO1xudmFyIEVWRU5UX1RFU1RfUEFTUyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BBU1M7XG52YXIgRVZFTlRfVEVTVF9GQUlMID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfRkFJTDtcblxuY29uc3QgaXNCcm93c2VyID0gdXRpbHMuaXNCcm93c2VyKCk7XG5cbmZ1bmN0aW9uIGdldEJyb3dzZXJXaW5kb3dTaXplKCkge1xuICBpZiAoJ2lubmVySGVpZ2h0JyBpbiBnbG9iYWwpIHtcbiAgICByZXR1cm4gW2dsb2JhbC5pbm5lckhlaWdodCwgZ2xvYmFsLmlubmVyV2lkdGhdO1xuICB9XG4gIC8vIEluIGEgV2ViIFdvcmtlciwgdGhlIERPTSBXaW5kb3cgaXMgbm90IGF2YWlsYWJsZS5cbiAgcmV0dXJuIFs2NDAsIDQ4MF07XG59XG5cbi8qKlxuICogRXhwb3NlIGBCYXNlYC5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBCYXNlO1xuXG4vKipcbiAqIENoZWNrIGlmIGJvdGggc3RkaW8gc3RyZWFtcyBhcmUgYXNzb2NpYXRlZCB3aXRoIGEgdHR5LlxuICovXG5cbnZhciBpc2F0dHkgPSBpc0Jyb3dzZXIgfHwgKHByb2Nlc3Muc3Rkb3V0LmlzVFRZICYmIHByb2Nlc3Muc3RkZXJyLmlzVFRZKTtcblxuLyoqXG4gKiBTYXZlIGxvZyByZWZlcmVuY2VzIHRvIGF2b2lkIHRlc3RzIGludGVyZmVyaW5nIChzZWUgR0gtMzYwNCkuXG4gKi9cbnZhciBjb25zb2xlTG9nID0gY29uc29sZS5sb2c7XG5cbi8qKlxuICogRW5hYmxlIGNvbG9yaW5nIGJ5IGRlZmF1bHQsIGV4Y2VwdCBpbiB0aGUgYnJvd3NlciBpbnRlcmZhY2UuXG4gKi9cblxuZXhwb3J0cy51c2VDb2xvcnMgPVxuICAhaXNCcm93c2VyICYmXG4gIChzdXBwb3J0c0NvbG9yLnN0ZG91dCB8fCBwcm9jZXNzLmVudi5NT0NIQV9DT0xPUlMgIT09IHVuZGVmaW5lZCk7XG5cbi8qKlxuICogSW5saW5lIGRpZmZzIGluc3RlYWQgb2YgKy8tXG4gKi9cblxuZXhwb3J0cy5pbmxpbmVEaWZmcyA9IGZhbHNlO1xuXG4vKipcbiAqIFRydW5jYXRlIGRpZmZzIGxvbmdlciB0aGFuIHRoaXMgdmFsdWUgdG8gYXZvaWQgc2xvdyBwZXJmb3JtYW5jZVxuICovXG5leHBvcnRzLm1heERpZmZTaXplID0gODE5MjtcblxuLyoqXG4gKiBEZWZhdWx0IGNvbG9yIG1hcC5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IHtcbiAgcGFzczogOTAsXG4gIGZhaWw6IDMxLFxuICAnYnJpZ2h0IHBhc3MnOiA5MixcbiAgJ2JyaWdodCBmYWlsJzogOTEsXG4gICdicmlnaHQgeWVsbG93JzogOTMsXG4gIHBlbmRpbmc6IDM2LFxuICBzdWl0ZTogMCxcbiAgJ2Vycm9yIHRpdGxlJzogMCxcbiAgJ2Vycm9yIG1lc3NhZ2UnOiAzMSxcbiAgJ2Vycm9yIHN0YWNrJzogOTAsXG4gIGNoZWNrbWFyazogMzIsXG4gIGZhc3Q6IDkwLFxuICBtZWRpdW06IDMzLFxuICBzbG93OiAzMSxcbiAgZ3JlZW46IDMyLFxuICBsaWdodDogOTAsXG4gICdkaWZmIGd1dHRlcic6IDkwLFxuICAnZGlmZiBhZGRlZCc6IDMyLFxuICAnZGlmZiByZW1vdmVkJzogMzEsXG4gICdkaWZmIGFkZGVkIGlubGluZSc6ICczMDs0MicsXG4gICdkaWZmIHJlbW92ZWQgaW5saW5lJzogJzMwOzQxJ1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IHN5bWJvbCBtYXAuXG4gKi9cblxuZXhwb3J0cy5zeW1ib2xzID0ge1xuICBvazogc3ltYm9scy5zdWNjZXNzLFxuICBlcnI6IHN5bWJvbHMuZXJyb3IsXG4gIGRvdDogJy4nLFxuICBjb21tYTogJywnLFxuICBiYW5nOiAnISdcbn07XG5cbi8qKlxuICogQ29sb3IgYHN0cmAgd2l0aCB0aGUgZ2l2ZW4gYHR5cGVgLFxuICogYWxsb3dpbmcgY29sb3JzIHRvIGJlIGRpc2FibGVkLFxuICogYXMgd2VsbCBhcyB1c2VyLWRlZmluZWQgY29sb3JcbiAqIHNjaGVtZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbnZhciBjb2xvciA9IChleHBvcnRzLmNvbG9yID0gZnVuY3Rpb24gKHR5cGUsIHN0cikge1xuICBpZiAoIWV4cG9ydHMudXNlQ29sb3JzKSB7XG4gICAgcmV0dXJuIFN0cmluZyhzdHIpO1xuICB9XG4gIHJldHVybiAnXFx1MDAxYlsnICsgZXhwb3J0cy5jb2xvcnNbdHlwZV0gKyAnbScgKyBzdHIgKyAnXFx1MDAxYlswbSc7XG59KTtcblxuLyoqXG4gKiBFeHBvc2UgdGVybSB3aW5kb3cgc2l6ZSwgd2l0aCBzb21lIGRlZmF1bHRzIGZvciB3aGVuIHN0ZGVyciBpcyBub3QgYSB0dHkuXG4gKi9cblxuZXhwb3J0cy53aW5kb3cgPSB7XG4gIHdpZHRoOiA3NVxufTtcblxuaWYgKGlzYXR0eSkge1xuICBpZiAoaXNCcm93c2VyKSB7XG4gICAgZXhwb3J0cy53aW5kb3cud2lkdGggPSBnZXRCcm93c2VyV2luZG93U2l6ZSgpWzFdO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMud2luZG93LndpZHRoID0gcHJvY2Vzcy5zdGRvdXQuZ2V0V2luZG93U2l6ZSgxKVswXTtcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBzb21lIGJhc2ljIGN1cnNvciBpbnRlcmFjdGlvbnMgdGhhdCBhcmUgY29tbW9uIGFtb25nIHJlcG9ydGVycy5cbiAqL1xuXG5leHBvcnRzLmN1cnNvciA9IHtcbiAgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgIGlzYXR0eSAmJiBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFx1MDAxYls/MjVsJyk7XG4gIH0sXG5cbiAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgIGlzYXR0eSAmJiBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFx1MDAxYls/MjVoJyk7XG4gIH0sXG5cbiAgZGVsZXRlTGluZTogZnVuY3Rpb24gKCkge1xuICAgIGlzYXR0eSAmJiBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFx1MDAxYlsySycpO1xuICB9LFxuXG4gIGJlZ2lubmluZ09mTGluZTogZnVuY3Rpb24gKCkge1xuICAgIGlzYXR0eSAmJiBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFx1MDAxYlswRycpO1xuICB9LFxuXG4gIENSOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGlzYXR0eSkge1xuICAgICAgZXhwb3J0cy5jdXJzb3IuZGVsZXRlTGluZSgpO1xuICAgICAgZXhwb3J0cy5jdXJzb3IuYmVnaW5uaW5nT2ZMaW5lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXHInKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBzaG93RGlmZiA9IChleHBvcnRzLnNob3dEaWZmID0gZnVuY3Rpb24gKGVycikge1xuICByZXR1cm4gKFxuICAgIGVyciAmJlxuICAgIGVyci5zaG93RGlmZiAhPT0gZmFsc2UgJiZcbiAgICBzYW1lVHlwZShlcnIuYWN0dWFsLCBlcnIuZXhwZWN0ZWQpICYmXG4gICAgZXJyLmV4cGVjdGVkICE9PSB1bmRlZmluZWRcbiAgKTtcbn0pO1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlEaWZmT2JqcyhlcnIpIHtcbiAgaWYgKCF1dGlscy5pc1N0cmluZyhlcnIuYWN0dWFsKSB8fCAhdXRpbHMuaXNTdHJpbmcoZXJyLmV4cGVjdGVkKSkge1xuICAgIGVyci5hY3R1YWwgPSB1dGlscy5zdHJpbmdpZnkoZXJyLmFjdHVhbCk7XG4gICAgZXJyLmV4cGVjdGVkID0gdXRpbHMuc3RyaW5naWZ5KGVyci5leHBlY3RlZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZGlmZiBiZXR3ZWVuIDIgc3RyaW5ncyB3aXRoIGNvbG91cmVkIEFOU0kgb3V0cHV0LlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIGRpZmYgd2lsbCBiZSBlaXRoZXIgaW5saW5lIG9yIHVuaWZpZWQgZGVwZW5kZW50IG9uIHRoZSB2YWx1ZVxuICogb2YgYEJhc2UuaW5saW5lRGlmZmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFjdHVhbFxuICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkXG4gKiBAcmV0dXJuIHtzdHJpbmd9IERpZmZcbiAqL1xuXG52YXIgZ2VuZXJhdGVEaWZmID0gKGV4cG9ydHMuZ2VuZXJhdGVEaWZmID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgdHJ5IHtcbiAgICB2YXIgbWF4TGVuID0gZXhwb3J0cy5tYXhEaWZmU2l6ZTtcbiAgICB2YXIgc2tpcHBlZCA9IDA7XG4gICAgaWYgKG1heExlbiA+IDApIHtcbiAgICAgIHNraXBwZWQgPSBNYXRoLm1heChhY3R1YWwubGVuZ3RoIC0gbWF4TGVuLCBleHBlY3RlZC5sZW5ndGggLSBtYXhMZW4pO1xuICAgICAgYWN0dWFsID0gYWN0dWFsLnNsaWNlKDAsIG1heExlbik7XG4gICAgICBleHBlY3RlZCA9IGV4cGVjdGVkLnNsaWNlKDAsIG1heExlbik7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBleHBvcnRzLmlubGluZURpZmZzXG4gICAgICA/IGlubGluZURpZmYoYWN0dWFsLCBleHBlY3RlZClcbiAgICAgIDogdW5pZmllZERpZmYoYWN0dWFsLCBleHBlY3RlZCk7XG4gICAgaWYgKHNraXBwZWQgPiAwKSB7XG4gICAgICByZXN1bHQgPSBgJHtyZXN1bHR9XFxuICAgICAgW21vY2hhXSBvdXRwdXQgdHJ1bmNhdGVkIHRvICR7bWF4TGVufSBjaGFyYWN0ZXJzLCBzZWUgXCJtYXhEaWZmU2l6ZVwiIHJlcG9ydGVyLW9wdGlvblxcbmA7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHZhciBtc2cgPVxuICAgICAgJ1xcbiAgICAgICcgK1xuICAgICAgY29sb3IoJ2RpZmYgYWRkZWQnLCAnKyBleHBlY3RlZCcpICtcbiAgICAgICcgJyArXG4gICAgICBjb2xvcignZGlmZiByZW1vdmVkJywgJy0gYWN0dWFsOiAgZmFpbGVkIHRvIGdlbmVyYXRlIE1vY2hhIGRpZmYnKSArXG4gICAgICAnXFxuJztcbiAgICByZXR1cm4gbXNnO1xuICB9XG59KTtcblxuLyoqXG4gKiBUcmF2ZXJzZXMgZXJyLmNhdXNlIGFuZCByZXR1cm5zIGFsbCBzdGFjayB0cmFjZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcGFyYW0ge1NldDxFcnJvcj59IFtzZWVuXVxuICogQHJldHVybiB7RnVsbEVycm9yU3RhY2t9XG4gKi9cbnZhciBnZXRGdWxsRXJyb3JTdGFjayA9IGZ1bmN0aW9uIChlcnIsIHNlZW4pIHtcbiAgaWYgKHNlZW4gJiYgc2Vlbi5oYXMoZXJyKSkge1xuICAgIHJldHVybiB7IG1lc3NhZ2U6ICcnLCBtc2c6ICc8Y2lyY3VsYXI+Jywgc3RhY2s6ICcnIH07XG4gIH1cblxuICB2YXIgbWVzc2FnZTtcblxuICBpZiAodHlwZW9mIGVyci5pbnNwZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbWVzc2FnZSA9IGVyci5pbnNwZWN0KCkgKyAnJztcbiAgfSBlbHNlIGlmIChlcnIubWVzc2FnZSAmJiB0eXBlb2YgZXJyLm1lc3NhZ2UudG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBtZXNzYWdlID0gZXJyLm1lc3NhZ2UgKyAnJztcbiAgfSBlbHNlIHtcbiAgICBtZXNzYWdlID0gJyc7XG4gIH1cblxuICB2YXIgbXNnO1xuICB2YXIgc3RhY2sgPSBlcnIuc3RhY2sgfHwgbWVzc2FnZTtcbiAgdmFyIGluZGV4ID0gbWVzc2FnZSA/IHN0YWNrLmluZGV4T2YobWVzc2FnZSkgOiAtMTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgbXNnID0gbWVzc2FnZTtcbiAgfSBlbHNlIHtcbiAgICBpbmRleCArPSBtZXNzYWdlLmxlbmd0aDtcbiAgICBtc2cgPSBzdGFjay5zbGljZSgwLCBpbmRleCk7XG4gICAgLy8gcmVtb3ZlIG1zZyBmcm9tIHN0YWNrXG4gICAgc3RhY2sgPSBzdGFjay5zbGljZShpbmRleCArIDEpO1xuXG4gICAgaWYgKGVyci5jYXVzZSkge1xuICAgICAgc2VlbiA9IHNlZW4gfHwgbmV3IFNldCgpO1xuICAgICAgc2Vlbi5hZGQoZXJyKTtcbiAgICAgIGNvbnN0IGNhdXNlU3RhY2sgPSBnZXRGdWxsRXJyb3JTdGFjayhlcnIuY2F1c2UsIHNlZW4pXG4gICAgICBzdGFjayArPSAnXFxuICAgQ2F1c2VkIGJ5OiAnICsgY2F1c2VTdGFjay5tc2cgKyAoY2F1c2VTdGFjay5zdGFjayA/ICdcXG4nICsgY2F1c2VTdGFjay5zdGFjayA6ICcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1lc3NhZ2UsXG4gICAgbXNnLFxuICAgIHN0YWNrXG4gIH07XG59O1xuXG4vKipcbiAqIE91dHB1dHMgdGhlIGdpdmVuIGBmYWlsdXJlc2AgYXMgYSBsaXN0LlxuICpcbiAqIEBwdWJsaWNcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnMuQmFzZVxuICogQHZhcmlhdGlvbiAxXG4gKiBAcGFyYW0ge09iamVjdFtdfSBmYWlsdXJlcyAtIEVhY2ggaXMgVGVzdCBpbnN0YW5jZSB3aXRoIGNvcnJlc3BvbmRpbmdcbiAqICAgICBFcnJvciBwcm9wZXJ0eVxuICovXG5leHBvcnRzLmxpc3QgPSBmdW5jdGlvbiAoZmFpbHVyZXMpIHtcbiAgdmFyIG11bHRpcGxlRXJyLCBtdWx0aXBsZVRlc3Q7XG4gIEJhc2UuY29uc29sZUxvZygpO1xuICBmYWlsdXJlcy5mb3JFYWNoKGZ1bmN0aW9uICh0ZXN0LCBpKSB7XG4gICAgLy8gZm9ybWF0XG4gICAgdmFyIGZtdCA9XG4gICAgICBjb2xvcignZXJyb3IgdGl0bGUnLCAnICAlcykgJXM6XFxuJykgK1xuICAgICAgY29sb3IoJ2Vycm9yIG1lc3NhZ2UnLCAnICAgICAlcycpICtcbiAgICAgIGNvbG9yKCdlcnJvciBzdGFjaycsICdcXG4lc1xcbicpO1xuXG4gICAgLy8gbXNnXG4gICAgdmFyIGVycjtcbiAgICBpZiAodGVzdC5lcnIgJiYgdGVzdC5lcnIubXVsdGlwbGUpIHtcbiAgICAgIGlmIChtdWx0aXBsZVRlc3QgIT09IHRlc3QpIHtcbiAgICAgICAgbXVsdGlwbGVUZXN0ID0gdGVzdDtcbiAgICAgICAgbXVsdGlwbGVFcnIgPSBbdGVzdC5lcnJdLmNvbmNhdCh0ZXN0LmVyci5tdWx0aXBsZSk7XG4gICAgICB9XG4gICAgICBlcnIgPSBtdWx0aXBsZUVyci5zaGlmdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnIgPSB0ZXN0LmVycjtcbiAgICB9XG5cbiAgICB2YXIgeyBtZXNzYWdlLCBtc2csIHN0YWNrIH0gPSBnZXRGdWxsRXJyb3JTdGFjayhlcnIpO1xuXG4gICAgLy8gdW5jYXVnaHRcbiAgICBpZiAoZXJyLnVuY2F1Z2h0KSB7XG4gICAgICBtc2cgPSAnVW5jYXVnaHQgJyArIG1zZztcbiAgICB9XG4gICAgLy8gZXhwbGljaXRseSBzaG93IGRpZmZcbiAgICBpZiAoIWV4cG9ydHMuaGlkZURpZmYgJiYgc2hvd0RpZmYoZXJyKSkge1xuICAgICAgc3RyaW5naWZ5RGlmZk9ianMoZXJyKTtcbiAgICAgIGZtdCA9XG4gICAgICAgIGNvbG9yKCdlcnJvciB0aXRsZScsICcgICVzKSAlczpcXG4lcycpICsgY29sb3IoJ2Vycm9yIHN0YWNrJywgJ1xcbiVzXFxuJyk7XG4gICAgICB2YXIgbWF0Y2ggPSBtZXNzYWdlLm1hdGNoKC9eKFteOl0rKTogZXhwZWN0ZWQvKTtcbiAgICAgIG1zZyA9ICdcXG4gICAgICAnICsgY29sb3IoJ2Vycm9yIG1lc3NhZ2UnLCBtYXRjaCA/IG1hdGNoWzFdIDogbXNnKTtcblxuICAgICAgbXNnICs9IGdlbmVyYXRlRGlmZihlcnIuYWN0dWFsLCBlcnIuZXhwZWN0ZWQpO1xuICAgIH1cblxuICAgIC8vIGluZGVudCBzdGFjayB0cmFjZVxuICAgIHN0YWNrID0gc3RhY2sucmVwbGFjZSgvXi9nbSwgJyAgJyk7XG5cbiAgICAvLyBpbmRlbnRlZCB0ZXN0IHRpdGxlXG4gICAgdmFyIHRlc3RUaXRsZSA9ICcnO1xuICAgIHRlc3QudGl0bGVQYXRoKCkuZm9yRWFjaChmdW5jdGlvbiAoc3RyLCBpbmRleCkge1xuICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICAgIHRlc3RUaXRsZSArPSAnXFxuICAgICAnO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICAgIHRlc3RUaXRsZSArPSAnICAnO1xuICAgICAgfVxuICAgICAgdGVzdFRpdGxlICs9IHN0cjtcbiAgICB9KTtcblxuICAgIEJhc2UuY29uc29sZUxvZyhmbXQsIGkgKyAxLCB0ZXN0VGl0bGUsIG1zZywgc3RhY2spO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBgQmFzZWAgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBbGwgb3RoZXIgcmVwb3J0ZXJzIGdlbmVyYWxseSBpbmhlcml0IGZyb20gdGhpcyByZXBvcnRlci5cbiAqXG4gKiBAcHVibGljXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXIgLSBJbnN0YW5jZSB0cmlnZ2VycyByZXBvcnRlciBhY3Rpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHJ1bm5lciBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIEJhc2UocnVubmVyLCBvcHRpb25zKSB7XG4gIHZhciBmYWlsdXJlcyA9ICh0aGlzLmZhaWx1cmVzID0gW10pO1xuXG4gIGlmICghcnVubmVyKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBydW5uZXIgYXJndW1lbnQnKTtcbiAgfVxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLnJ1bm5lciA9IHJ1bm5lcjtcbiAgdGhpcy5zdGF0cyA9IHJ1bm5lci5zdGF0czsgLy8gYXNzaWduZWQgc28gUmVwb3J0ZXJzIGtlZXAgYSBjbG9zZXIgcmVmZXJlbmNlXG5cbiAgdmFyIG1heERpZmZTaXplT3B0ID1cbiAgICB0aGlzLm9wdGlvbnMucmVwb3J0ZXJPcHRpb24gJiYgdGhpcy5vcHRpb25zLnJlcG9ydGVyT3B0aW9uLm1heERpZmZTaXplO1xuICBpZiAobWF4RGlmZlNpemVPcHQgIT09IHVuZGVmaW5lZCAmJiAhaXNOYU4oTnVtYmVyKG1heERpZmZTaXplT3B0KSkpIHtcbiAgICBleHBvcnRzLm1heERpZmZTaXplID0gTnVtYmVyKG1heERpZmZTaXplT3B0KTtcbiAgfVxuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BBU1MsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgaWYgKHRlc3QuZHVyYXRpb24gPiB0ZXN0LnNsb3coKSkge1xuICAgICAgdGVzdC5zcGVlZCA9ICdzbG93JztcbiAgICB9IGVsc2UgaWYgKHRlc3QuZHVyYXRpb24gPiB0ZXN0LnNsb3coKSAvIDIpIHtcbiAgICAgIHRlc3Quc3BlZWQgPSAnbWVkaXVtJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGVzdC5zcGVlZCA9ICdmYXN0JztcbiAgICB9XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX0ZBSUwsIGZ1bmN0aW9uICh0ZXN0LCBlcnIpIHtcbiAgICBpZiAoc2hvd0RpZmYoZXJyKSkge1xuICAgICAgc3RyaW5naWZ5RGlmZk9ianMoZXJyKTtcbiAgICB9XG4gICAgLy8gbW9yZSB0aGFuIG9uZSBlcnJvciBwZXIgdGVzdFxuICAgIGlmICh0ZXN0LmVyciAmJiBlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGVzdC5lcnIubXVsdGlwbGUgPSAodGVzdC5lcnIubXVsdGlwbGUgfHwgW10pLmNvbmNhdChlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXN0LmVyciA9IGVycjtcbiAgICB9XG4gICAgZmFpbHVyZXMucHVzaCh0ZXN0KTtcbiAgfSk7XG59XG5cbi8qKlxuICogT3V0cHV0cyBjb21tb24gZXBpbG9ndWUgdXNlZCBieSBtYW55IG9mIHRoZSBidW5kbGVkIHJlcG9ydGVycy5cbiAqXG4gKiBAcHVibGljXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXG4gKi9cbkJhc2UucHJvdG90eXBlLmVwaWxvZ3VlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICB2YXIgZm10O1xuXG4gIEJhc2UuY29uc29sZUxvZygpO1xuXG4gIC8vIHBhc3Nlc1xuICBmbXQgPVxuICAgIGNvbG9yKCdicmlnaHQgcGFzcycsICcgJykgK1xuICAgIGNvbG9yKCdncmVlbicsICcgJWQgcGFzc2luZycpICtcbiAgICBjb2xvcignbGlnaHQnLCAnICglcyknKTtcblxuICBCYXNlLmNvbnNvbGVMb2coZm10LCBzdGF0cy5wYXNzZXMgfHwgMCwgbWlsbGlzZWNvbmRzKHN0YXRzLmR1cmF0aW9uKSk7XG5cbiAgLy8gcGVuZGluZ1xuICBpZiAoc3RhdHMucGVuZGluZykge1xuICAgIGZtdCA9IGNvbG9yKCdwZW5kaW5nJywgJyAnKSArIGNvbG9yKCdwZW5kaW5nJywgJyAlZCBwZW5kaW5nJyk7XG5cbiAgICBCYXNlLmNvbnNvbGVMb2coZm10LCBzdGF0cy5wZW5kaW5nKTtcbiAgfVxuXG4gIC8vIGZhaWx1cmVzXG4gIGlmIChzdGF0cy5mYWlsdXJlcykge1xuICAgIGZtdCA9IGNvbG9yKCdmYWlsJywgJyAgJWQgZmFpbGluZycpO1xuXG4gICAgQmFzZS5jb25zb2xlTG9nKGZtdCwgc3RhdHMuZmFpbHVyZXMpO1xuXG4gICAgQmFzZS5saXN0KHRoaXMuZmFpbHVyZXMpO1xuICAgIEJhc2UuY29uc29sZUxvZygpO1xuICB9XG5cbiAgQmFzZS5jb25zb2xlTG9nKCk7XG59O1xuXG4vKipcbiAqIFBhZHMgdGhlIGdpdmVuIGBzdHJgIHRvIGBsZW5gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge3N0cmluZ30gbGVuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHBhZChzdHIsIGxlbikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgcmV0dXJuIEFycmF5KGxlbiAtIHN0ci5sZW5ndGggKyAxKS5qb2luKCcgJykgKyBzdHI7XG59XG5cbi8qKlxuICogUmV0dXJucyBpbmxpbmUgZGlmZiBiZXR3ZWVuIDIgc3RyaW5ncyB3aXRoIGNvbG91cmVkIEFOU0kgb3V0cHV0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0dWFsXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwZWN0ZWRcbiAqIEByZXR1cm4ge3N0cmluZ30gRGlmZlxuICovXG5mdW5jdGlvbiBpbmxpbmVEaWZmKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgdmFyIG1zZyA9IGVycm9yRGlmZihhY3R1YWwsIGV4cGVjdGVkKTtcblxuICAvLyBsaW5lbm9zXG4gIHZhciBsaW5lcyA9IG1zZy5zcGxpdCgnXFxuJyk7XG4gIGlmIChsaW5lcy5sZW5ndGggPiA0KSB7XG4gICAgdmFyIHdpZHRoID0gU3RyaW5nKGxpbmVzLmxlbmd0aCkubGVuZ3RoO1xuICAgIG1zZyA9IGxpbmVzXG4gICAgICAubWFwKGZ1bmN0aW9uIChzdHIsIGkpIHtcbiAgICAgICAgcmV0dXJuIHBhZCgrK2ksIHdpZHRoKSArICcgfCcgKyAnICcgKyBzdHI7XG4gICAgICB9KVxuICAgICAgLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgLy8gbGVnZW5kXG4gIG1zZyA9XG4gICAgJ1xcbicgK1xuICAgIGNvbG9yKCdkaWZmIHJlbW92ZWQgaW5saW5lJywgJ2FjdHVhbCcpICtcbiAgICAnICcgK1xuICAgIGNvbG9yKCdkaWZmIGFkZGVkIGlubGluZScsICdleHBlY3RlZCcpICtcbiAgICAnXFxuXFxuJyArXG4gICAgbXNnICtcbiAgICAnXFxuJztcblxuICAvLyBpbmRlbnRcbiAgbXNnID0gbXNnLnJlcGxhY2UoL14vZ20sICcgICAgICAnKTtcbiAgcmV0dXJuIG1zZztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHVuaWZpZWQgZGlmZiBiZXR3ZWVuIHR3byBzdHJpbmdzIHdpdGggY29sb3VyZWQgQU5TSSBvdXRwdXQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3R1YWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBlY3RlZFxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgZGlmZi5cbiAqL1xuZnVuY3Rpb24gdW5pZmllZERpZmYoYWN0dWFsLCBleHBlY3RlZCkge1xuICB2YXIgaW5kZW50ID0gJyAgICAgICc7XG4gIGZ1bmN0aW9uIGNsZWFuVXAobGluZSkge1xuICAgIGlmIChsaW5lWzBdID09PSAnKycpIHtcbiAgICAgIHJldHVybiBpbmRlbnQgKyBjb2xvckxpbmVzKCdkaWZmIGFkZGVkJywgbGluZSk7XG4gICAgfVxuICAgIGlmIChsaW5lWzBdID09PSAnLScpIHtcbiAgICAgIHJldHVybiBpbmRlbnQgKyBjb2xvckxpbmVzKCdkaWZmIHJlbW92ZWQnLCBsaW5lKTtcbiAgICB9XG4gICAgaWYgKGxpbmUubWF0Y2goL0BALykpIHtcbiAgICAgIHJldHVybiAnLS0nO1xuICAgIH1cbiAgICBpZiAobGluZS5tYXRjaCgvXFxcXCBObyBuZXdsaW5lLykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZW50ICsgbGluZTtcbiAgfVxuICBmdW5jdGlvbiBub3RCbGFuayhsaW5lKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBsaW5lICE9PSAndW5kZWZpbmVkJyAmJiBsaW5lICE9PSBudWxsO1xuICB9XG4gIHZhciBtc2cgPSBkaWZmLmNyZWF0ZVBhdGNoKCdzdHJpbmcnLCBhY3R1YWwsIGV4cGVjdGVkKTtcbiAgdmFyIGxpbmVzID0gbXNnLnNwbGl0KCdcXG4nKS5zcGxpY2UoNSk7XG4gIHJldHVybiAoXG4gICAgJ1xcbiAgICAgICcgK1xuICAgIGNvbG9yTGluZXMoJ2RpZmYgYWRkZWQnLCAnKyBleHBlY3RlZCcpICtcbiAgICAnICcgK1xuICAgIGNvbG9yTGluZXMoJ2RpZmYgcmVtb3ZlZCcsICctIGFjdHVhbCcpICtcbiAgICAnXFxuXFxuJyArXG4gICAgbGluZXMubWFwKGNsZWFuVXApLmZpbHRlcihub3RCbGFuaykuam9pbignXFxuJylcbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGNoYXJhY3RlciBkaWZmIGZvciBgZXJyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IGFjdHVhbFxuICogQHBhcmFtIHtTdHJpbmd9IGV4cGVjdGVkXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBkaWZmXG4gKi9cbmZ1bmN0aW9uIGVycm9yRGlmZihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIHJldHVybiBkaWZmXG4gICAgLmRpZmZXb3Jkc1dpdGhTcGFjZShhY3R1YWwsIGV4cGVjdGVkKVxuICAgIC5tYXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgaWYgKHN0ci5hZGRlZCkge1xuICAgICAgICByZXR1cm4gY29sb3JMaW5lcygnZGlmZiBhZGRlZCBpbmxpbmUnLCBzdHIudmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5yZW1vdmVkKSB7XG4gICAgICAgIHJldHVybiBjb2xvckxpbmVzKCdkaWZmIHJlbW92ZWQgaW5saW5lJywgc3RyLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHIudmFsdWU7XG4gICAgfSlcbiAgICAuam9pbignJyk7XG59XG5cbi8qKlxuICogQ29sb3JzIGxpbmVzIGZvciBgc3RyYCwgdXNpbmcgdGhlIGNvbG9yIGBuYW1lYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY29sb3JMaW5lcyhuYW1lLCBzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgIC5zcGxpdCgnXFxuJylcbiAgICAubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiBjb2xvcihuYW1lLCBzdHIpO1xuICAgIH0pXG4gICAgLmpvaW4oJ1xcbicpO1xufVxuXG4vKipcbiAqIE9iamVjdCN0b1N0cmluZyByZWZlcmVuY2UuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIHRoYXQgYSAvIGIgaGF2ZSB0aGUgc2FtZSB0eXBlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHNhbWVUeXBlKGEsIGIpIHtcbiAgcmV0dXJuIG9ialRvU3RyaW5nLmNhbGwoYSkgPT09IG9ialRvU3RyaW5nLmNhbGwoYik7XG59XG5cbkJhc2UuY29uc29sZUxvZyA9IGNvbnNvbGVMb2c7XG5cbkJhc2UuYWJzdHJhY3QgPSB0cnVlO1xuXG4vKipcbiAqIEFuIG9iamVjdCB3aXRoIGFsbCBzdGFjayB0cmFjZXMgcmVjdXJzaXZlbHkgbW91bnRlZCBmcm9tIGVhY2ggZXJyLmNhdXNlXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmxpYi9yZXBvcnRlcnMvYmFzZVxuICogQHR5cGVkZWYge09iamVjdH0gRnVsbEVycm9yU3RhY2tcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbXNnXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhY2tcbiAqL1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/reporters/base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/reporters/doc.js":
/*!*************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/doc.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * @module Doc\n */\n/**\n * Module dependencies.\n */\n\nvar Base = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/mocha/lib/reporters/base.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\");\nvar constants = (__webpack_require__(/*! ../runner */ \"(ssr)/./node_modules/mocha/lib/runner.js\").constants);\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\nvar EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;\nvar EVENT_SUITE_END = constants.EVENT_SUITE_END;\n\n/**\n * Expose `Doc`.\n */\n\nexports = module.exports = Doc;\n\n/**\n * Constructs a new `Doc` reporter instance.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @param {Runner} runner - Instance triggers reporter actions.\n * @param {Object} [options] - runner options\n */\nfunction Doc(runner, options) {\n  Base.call(this, runner, options);\n\n  var indents = 2;\n\n  function indent() {\n    return Array(indents).join('  ');\n  }\n\n  runner.on(EVENT_SUITE_BEGIN, function (suite) {\n    if (suite.root) {\n      return;\n    }\n    ++indents;\n    Base.consoleLog('%s<section class=\"suite\">', indent());\n    ++indents;\n    Base.consoleLog('%s<h1>%s</h1>', indent(), utils.escape(suite.title));\n    Base.consoleLog('%s<dl>', indent());\n  });\n\n  runner.on(EVENT_SUITE_END, function (suite) {\n    if (suite.root) {\n      return;\n    }\n    Base.consoleLog('%s</dl>', indent());\n    --indents;\n    Base.consoleLog('%s</section>', indent());\n    --indents;\n  });\n\n  runner.on(EVENT_TEST_PASS, function (test) {\n    Base.consoleLog('%s  <dt>%s</dt>', indent(), utils.escape(test.title));\n    Base.consoleLog('%s  <dt>%s</dt>', indent(), utils.escape(test.file));\n    var code = utils.escape(utils.clean(test.body));\n    Base.consoleLog('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code);\n  });\n\n  runner.on(EVENT_TEST_FAIL, function (test, err) {\n    Base.consoleLog(\n      '%s  <dt class=\"error\">%s</dt>',\n      indent(),\n      utils.escape(test.title)\n    );\n    Base.consoleLog(\n      '%s  <dt class=\"error\">%s</dt>',\n      indent(),\n      utils.escape(test.file)\n    );\n    var code = utils.escape(utils.clean(test.body));\n    Base.consoleLog(\n      '%s  <dd class=\"error\"><pre><code>%s</code></pre></dd>',\n      indent(),\n      code\n    );\n    Base.consoleLog(\n      '%s  <dd class=\"error\">%s</dd>',\n      indent(),\n      utils.escape(err)\n    );\n  });\n}\n\nDoc.description = 'HTML documentation';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9kb2MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLGdFQUFRO0FBQzNCLFlBQVksbUJBQU8sQ0FBQyx5REFBVTtBQUM5QixnQkFBZ0IsNEZBQThCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvcmVwb3J0ZXJzL2RvYy5qcz9lODMzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBEb2NcbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL3J1bm5lcicpLmNvbnN0YW50cztcbnZhciBFVkVOVF9URVNUX1BBU1MgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9QQVNTO1xudmFyIEVWRU5UX1RFU1RfRkFJTCA9IGNvbnN0YW50cy5FVkVOVF9URVNUX0ZBSUw7XG52YXIgRVZFTlRfU1VJVEVfQkVHSU4gPSBjb25zdGFudHMuRVZFTlRfU1VJVEVfQkVHSU47XG52YXIgRVZFTlRfU1VJVEVfRU5EID0gY29uc3RhbnRzLkVWRU5UX1NVSVRFX0VORDtcblxuLyoqXG4gKiBFeHBvc2UgYERvY2AuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRG9jO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYERvY2AgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lciAtIEluc3RhbmNlIHRyaWdnZXJzIHJlcG9ydGVyIGFjdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcnVubmVyIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gRG9jKHJ1bm5lciwgb3B0aW9ucykge1xuICBCYXNlLmNhbGwodGhpcywgcnVubmVyLCBvcHRpb25zKTtcblxuICB2YXIgaW5kZW50cyA9IDI7XG5cbiAgZnVuY3Rpb24gaW5kZW50KCkge1xuICAgIHJldHVybiBBcnJheShpbmRlbnRzKS5qb2luKCcgICcpO1xuICB9XG5cbiAgcnVubmVyLm9uKEVWRU5UX1NVSVRFX0JFR0lOLCBmdW5jdGlvbiAoc3VpdGUpIHtcbiAgICBpZiAoc3VpdGUucm9vdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICArK2luZGVudHM7XG4gICAgQmFzZS5jb25zb2xlTG9nKCclczxzZWN0aW9uIGNsYXNzPVwic3VpdGVcIj4nLCBpbmRlbnQoKSk7XG4gICAgKytpbmRlbnRzO1xuICAgIEJhc2UuY29uc29sZUxvZygnJXM8aDE+JXM8L2gxPicsIGluZGVudCgpLCB1dGlscy5lc2NhcGUoc3VpdGUudGl0bGUpKTtcbiAgICBCYXNlLmNvbnNvbGVMb2coJyVzPGRsPicsIGluZGVudCgpKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1NVSVRFX0VORCwgZnVuY3Rpb24gKHN1aXRlKSB7XG4gICAgaWYgKHN1aXRlLnJvb3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgQmFzZS5jb25zb2xlTG9nKCclczwvZGw+JywgaW5kZW50KCkpO1xuICAgIC0taW5kZW50cztcbiAgICBCYXNlLmNvbnNvbGVMb2coJyVzPC9zZWN0aW9uPicsIGluZGVudCgpKTtcbiAgICAtLWluZGVudHM7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BBU1MsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgQmFzZS5jb25zb2xlTG9nKCclcyAgPGR0PiVzPC9kdD4nLCBpbmRlbnQoKSwgdXRpbHMuZXNjYXBlKHRlc3QudGl0bGUpKTtcbiAgICBCYXNlLmNvbnNvbGVMb2coJyVzICA8ZHQ+JXM8L2R0PicsIGluZGVudCgpLCB1dGlscy5lc2NhcGUodGVzdC5maWxlKSk7XG4gICAgdmFyIGNvZGUgPSB1dGlscy5lc2NhcGUodXRpbHMuY2xlYW4odGVzdC5ib2R5KSk7XG4gICAgQmFzZS5jb25zb2xlTG9nKCclcyAgPGRkPjxwcmU+PGNvZGU+JXM8L2NvZGU+PC9wcmU+PC9kZD4nLCBpbmRlbnQoKSwgY29kZSk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX0ZBSUwsIGZ1bmN0aW9uICh0ZXN0LCBlcnIpIHtcbiAgICBCYXNlLmNvbnNvbGVMb2coXG4gICAgICAnJXMgIDxkdCBjbGFzcz1cImVycm9yXCI+JXM8L2R0PicsXG4gICAgICBpbmRlbnQoKSxcbiAgICAgIHV0aWxzLmVzY2FwZSh0ZXN0LnRpdGxlKVxuICAgICk7XG4gICAgQmFzZS5jb25zb2xlTG9nKFxuICAgICAgJyVzICA8ZHQgY2xhc3M9XCJlcnJvclwiPiVzPC9kdD4nLFxuICAgICAgaW5kZW50KCksXG4gICAgICB1dGlscy5lc2NhcGUodGVzdC5maWxlKVxuICAgICk7XG4gICAgdmFyIGNvZGUgPSB1dGlscy5lc2NhcGUodXRpbHMuY2xlYW4odGVzdC5ib2R5KSk7XG4gICAgQmFzZS5jb25zb2xlTG9nKFxuICAgICAgJyVzICA8ZGQgY2xhc3M9XCJlcnJvclwiPjxwcmU+PGNvZGU+JXM8L2NvZGU+PC9wcmU+PC9kZD4nLFxuICAgICAgaW5kZW50KCksXG4gICAgICBjb2RlXG4gICAgKTtcbiAgICBCYXNlLmNvbnNvbGVMb2coXG4gICAgICAnJXMgIDxkZCBjbGFzcz1cImVycm9yXCI+JXM8L2RkPicsXG4gICAgICBpbmRlbnQoKSxcbiAgICAgIHV0aWxzLmVzY2FwZShlcnIpXG4gICAgKTtcbiAgfSk7XG59XG5cbkRvYy5kZXNjcmlwdGlvbiA9ICdIVE1MIGRvY3VtZW50YXRpb24nO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/reporters/doc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/reporters/dot.js":
/*!*************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/dot.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * @module Dot\n */\n/**\n * Module dependencies.\n */\n\nvar Base = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/mocha/lib/reporters/base.js\");\nvar inherits = (__webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\").inherits);\nvar constants = (__webpack_require__(/*! ../runner */ \"(ssr)/./node_modules/mocha/lib/runner.js\").constants);\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\nvar EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\n\n/**\n * Expose `Dot`.\n */\n\nexports = module.exports = Dot;\n\n/**\n * Constructs a new `Dot` reporter instance.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @param {Runner} runner - Instance triggers reporter actions.\n * @param {Object} [options] - runner options\n */\nfunction Dot(runner, options) {\n  Base.call(this, runner, options);\n\n  var self = this;\n  var width = (Base.window.width * 0.75) | 0;\n  var n = -1;\n\n  runner.on(EVENT_RUN_BEGIN, function () {\n    process.stdout.write('\\n');\n  });\n\n  runner.on(EVENT_TEST_PENDING, function () {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    process.stdout.write(Base.color('pending', Base.symbols.comma));\n  });\n\n  runner.on(EVENT_TEST_PASS, function (test) {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    if (test.speed === 'slow') {\n      process.stdout.write(Base.color('bright yellow', Base.symbols.dot));\n    } else {\n      process.stdout.write(Base.color(test.speed, Base.symbols.dot));\n    }\n  });\n\n  runner.on(EVENT_TEST_FAIL, function () {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    process.stdout.write(Base.color('fail', Base.symbols.bang));\n  });\n\n  runner.once(EVENT_RUN_END, function () {\n    process.stdout.write('\\n');\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Dot, Base);\n\nDot.description = 'dot matrix representation';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9kb3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLGdFQUFRO0FBQzNCLGVBQWUseUZBQTRCO0FBQzNDLGdCQUFnQiw0RkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9kb3QuanM/YTA3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBtb2R1bGUgRG90XG4gKi9cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9ydW5uZXInKS5jb25zdGFudHM7XG52YXIgRVZFTlRfVEVTVF9QQVNTID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfUEFTUztcbnZhciBFVkVOVF9URVNUX0ZBSUwgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9GQUlMO1xudmFyIEVWRU5UX1JVTl9CRUdJTiA9IGNvbnN0YW50cy5FVkVOVF9SVU5fQkVHSU47XG52YXIgRVZFTlRfVEVTVF9QRU5ESU5HID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfUEVORElORztcbnZhciBFVkVOVF9SVU5fRU5EID0gY29uc3RhbnRzLkVWRU5UX1JVTl9FTkQ7XG5cbi8qKlxuICogRXhwb3NlIGBEb3RgLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IERvdDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGBEb3RgIHJlcG9ydGVyIGluc3RhbmNlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXIgLSBJbnN0YW5jZSB0cmlnZ2VycyByZXBvcnRlciBhY3Rpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHJ1bm5lciBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIERvdChydW5uZXIsIG9wdGlvbnMpIHtcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lciwgb3B0aW9ucyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgd2lkdGggPSAoQmFzZS53aW5kb3cud2lkdGggKiAwLjc1KSB8IDA7XG4gIHZhciBuID0gLTE7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1JVTl9CRUdJTiwgZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXG4nKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfUEVORElORywgZnVuY3Rpb24gKCkge1xuICAgIGlmICgrK24gJSB3aWR0aCA9PT0gMCkge1xuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcbiAgJyk7XG4gICAgfVxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKEJhc2UuY29sb3IoJ3BlbmRpbmcnLCBCYXNlLnN5bWJvbHMuY29tbWEpKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfUEFTUywgZnVuY3Rpb24gKHRlc3QpIHtcbiAgICBpZiAoKytuICUgd2lkdGggPT09IDApIHtcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXG4gICcpO1xuICAgIH1cbiAgICBpZiAodGVzdC5zcGVlZCA9PT0gJ3Nsb3cnKSB7XG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShCYXNlLmNvbG9yKCdicmlnaHQgeWVsbG93JywgQmFzZS5zeW1ib2xzLmRvdCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShCYXNlLmNvbG9yKHRlc3Quc3BlZWQsIEJhc2Uuc3ltYm9scy5kb3QpKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX0ZBSUwsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoKytuICUgd2lkdGggPT09IDApIHtcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXG4gICcpO1xuICAgIH1cbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShCYXNlLmNvbG9yKCdmYWlsJywgQmFzZS5zeW1ib2xzLmJhbmcpKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uY2UoRVZFTlRfUlVOX0VORCwgZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXG4nKTtcbiAgICBzZWxmLmVwaWxvZ3VlKCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxuICovXG5pbmhlcml0cyhEb3QsIEJhc2UpO1xuXG5Eb3QuZGVzY3JpcHRpb24gPSAnZG90IG1hdHJpeCByZXByZXNlbnRhdGlvbic7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/reporters/dot.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/reporters/html.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/html.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint-env browser */\n/**\n * @module HTML\n */\n/**\n * Module dependencies.\n */\n\nvar Base = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/mocha/lib/reporters/base.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\");\nvar escapeRe = __webpack_require__(/*! escape-string-regexp */ \"(ssr)/./node_modules/mocha/node_modules/escape-string-regexp/index.js\");\nvar constants = (__webpack_require__(/*! ../runner */ \"(ssr)/./node_modules/mocha/lib/runner.js\").constants);\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\nvar EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;\nvar EVENT_SUITE_END = constants.EVENT_SUITE_END;\nvar EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;\nvar escape = utils.escape;\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\nvar Date = global.Date;\n\n/**\n * Expose `HTML`.\n */\n\nexports = module.exports = HTML;\n\n/**\n * Stats template: Result, progress, passes, failures, and duration.\n */\n\nvar statsTemplate =\n  '<ul id=\"mocha-stats\">' +\n  '<li class=\"result\"></li>' +\n  '<li class=\"progress-contain\"><progress class=\"progress-element\" max=\"100\" value=\"0\"></progress><svg class=\"progress-ring\"><circle class=\"ring-flatlight\" stroke-dasharray=\"100%,0%\"/><circle class=\"ring-highlight\" stroke-dasharray=\"0%,100%\"/></svg><div class=\"progress-text\">0%</div></li>' +\n  '<li class=\"passes\"><a href=\"javascript:void(0);\">passes:</a> <em>0</em></li>' +\n  '<li class=\"failures\"><a href=\"javascript:void(0);\">failures:</a> <em>0</em></li>' +\n  '<li class=\"duration\">duration: <em>0</em>s</li>' +\n  '</ul>';\n\nvar playIcon = '&#x2023;';\n\n/**\n * Constructs a new `HTML` reporter instance.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @param {Runner} runner - Instance triggers reporter actions.\n * @param {Object} [options] - runner options\n */\nfunction HTML(runner, options) {\n  Base.call(this, runner, options);\n\n  var self = this;\n  var stats = this.stats;\n  var stat = fragment(statsTemplate);\n  var items = stat.getElementsByTagName('li');\n  const resultIndex = 0;\n  const progressIndex = 1;\n  const passesIndex = 2;\n  const failuresIndex = 3;\n  const durationIndex = 4;\n  /** Stat item containing the root suite pass or fail indicator (hasFailures ? '' : '') */\n  var resultIndicator = items[resultIndex];\n  /** Passes text and count */\n  const passesStat = items[passesIndex];\n  /** Stat item containing the pass count (not the word, just the number) */\n  const passesCount = passesStat.getElementsByTagName('em')[0];\n  /** Stat item linking to filter to show only passing tests */\n  const passesLink = passesStat.getElementsByTagName('a')[0];\n  /** Failures text and count */\n  const failuresStat = items[failuresIndex];\n  /** Stat item containing the failure count (not the word, just the number) */\n  const failuresCount = failuresStat.getElementsByTagName('em')[0];\n  /** Stat item linking to filter to show only failing tests */\n  const failuresLink = failuresStat.getElementsByTagName('a')[0];\n  /** Stat item linking to the duration time (not the word or unit, just the number) */\n  var duration = items[durationIndex].getElementsByTagName('em')[0];\n  var report = fragment('<ul id=\"mocha-report\"></ul>');\n  var stack = [report];\n  var progressText = items[progressIndex].getElementsByTagName('div')[0];\n  var progressBar = items[progressIndex].getElementsByTagName('progress')[0];\n  var progressRing = [\n    items[progressIndex].getElementsByClassName('ring-flatlight')[0],\n    items[progressIndex].getElementsByClassName('ring-highlight')[0]\n  ];\n  var progressRingRadius = null; // computed CSS unavailable now, so set later\n  var root = document.getElementById('mocha');\n\n  if (!root) {\n    return error('#mocha div missing, add it to your document');\n  }\n\n  // pass toggle\n  on(passesLink, 'click', function (evt) {\n    evt.preventDefault();\n    unhide();\n    var name = /pass/.test(report.className) ? '' : ' pass';\n    report.className = report.className.replace(/fail|pass/g, '') + name;\n    if (report.className.trim()) {\n      hideSuitesWithout('test pass');\n    }\n  });\n\n  // failure toggle\n  on(failuresLink, 'click', function (evt) {\n    evt.preventDefault();\n    unhide();\n    var name = /fail/.test(report.className) ? '' : ' fail';\n    report.className = report.className.replace(/fail|pass/g, '') + name;\n    if (report.className.trim()) {\n      hideSuitesWithout('test fail');\n    }\n  });\n\n  root.appendChild(stat);\n  root.appendChild(report);\n\n  runner.on(EVENT_SUITE_BEGIN, function (suite) {\n    if (suite.root) {\n      return;\n    }\n\n    // suite\n    var url = self.suiteURL(suite);\n    var el = fragment(\n      '<li class=\"suite\"><h1><a href=\"%s\">%s</a></h1></li>',\n      url,\n      escape(suite.title)\n    );\n\n    // container\n    stack[0].appendChild(el);\n    stack.unshift(document.createElement('ul'));\n    el.appendChild(stack[0]);\n  });\n\n  runner.on(EVENT_SUITE_END, function (suite) {\n    if (suite.root) {\n      if (stats.failures === 0) {\n        text(resultIndicator, '');\n        stat.className += ' pass';\n      }\n      updateStats();\n      return;\n    }\n    stack.shift();\n  });\n\n  runner.on(EVENT_TEST_PASS, function (test) {\n    var url = self.testURL(test);\n    var markup =\n      '<li class=\"test pass %e\"><h2>%e<span class=\"duration\">%ems</span> ' +\n      '<a href=\"%s\" class=\"replay\">' +\n      playIcon +\n      '</a></h2></li>';\n    var el = fragment(markup, test.speed, test.title, test.duration, url);\n    self.addCodeToggle(el, test.body);\n    appendToStack(el);\n    updateStats();\n  });\n\n  runner.on(EVENT_TEST_FAIL, function (test) {\n    // Update stat items\n    text(resultIndicator, '');\n    stat.className += ' fail';\n\n    var el = fragment(\n      '<li class=\"test fail\"><h2>%e <a href=\"%e\" class=\"replay\">' +\n        playIcon +\n        '</a></h2></li>',\n      test.title,\n      self.testURL(test)\n    );\n    var stackString; // Note: Includes leading newline\n    var message = test.err.toString();\n\n    // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we\n    // check for the result of the stringifying.\n    if (message === '[object Error]') {\n      message = test.err.message;\n    }\n\n    if (test.err.stack) {\n      var indexOfMessage = test.err.stack.indexOf(test.err.message);\n      if (indexOfMessage === -1) {\n        stackString = test.err.stack;\n      } else {\n        stackString = test.err.stack.slice(\n          test.err.message.length + indexOfMessage\n        );\n      }\n    } else if (test.err.sourceURL && test.err.line !== undefined) {\n      // Safari doesn't give you a stack. Let's at least provide a source line.\n      stackString = '\\n(' + test.err.sourceURL + ':' + test.err.line + ')';\n    }\n\n    stackString = stackString || '';\n\n    if (test.err.htmlMessage && stackString) {\n      el.appendChild(\n        fragment(\n          '<div class=\"html-error\">%s\\n<pre class=\"error\">%e</pre></div>',\n          test.err.htmlMessage,\n          stackString\n        )\n      );\n    } else if (test.err.htmlMessage) {\n      el.appendChild(\n        fragment('<div class=\"html-error\">%s</div>', test.err.htmlMessage)\n      );\n    } else {\n      el.appendChild(\n        fragment('<pre class=\"error\">%e%e</pre>', message, stackString)\n      );\n    }\n\n    self.addCodeToggle(el, test.body);\n    appendToStack(el);\n    updateStats();\n  });\n\n  runner.on(EVENT_TEST_PENDING, function (test) {\n    var el = fragment(\n      '<li class=\"test pass pending\"><h2>%e</h2></li>',\n      test.title\n    );\n    appendToStack(el);\n    updateStats();\n  });\n\n  function appendToStack(el) {\n    // Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.\n    if (stack[0]) {\n      stack[0].appendChild(el);\n    }\n  }\n\n  function updateStats() {\n    var percent = ((stats.tests / runner.total) * 100) | 0;\n    progressBar.value = percent;\n    if (progressText) {\n      // setting a toFixed that is too low, makes small changes to progress not shown\n      // setting it too high, makes the progress text longer then it needs to\n      // to address this, calculate the toFixed based on the magnitude of total\n      var decimalPlaces = Math.ceil(Math.log10(runner.total / 100));\n      text(\n        progressText,\n        percent.toFixed(Math.min(Math.max(decimalPlaces, 0), 100)) + '%'\n      );\n    }\n    if (progressRing) {\n      var radius = parseFloat(getComputedStyle(progressRing[0]).getPropertyValue('r'));\n      var wholeArc = Math.PI * 2 * radius;\n      var highlightArc = percent * (wholeArc / 100);\n      // The progress ring is in 2 parts, the flatlight color and highlight color.\n      // Rendering both on top of the other, seems to make a 3rd color on the edges.\n      // To create 1 whole ring with 2 colors, both parts are inverse of the other.\n      progressRing[0].style['stroke-dasharray'] = `0,${highlightArc}px,${wholeArc}px`;\n      progressRing[1].style['stroke-dasharray'] = `${highlightArc}px,${wholeArc}px`;\n    }\n\n    // update stats\n    var ms = new Date() - stats.start;\n    text(passesCount, stats.passes);\n    text(failuresCount, stats.failures);\n    text(duration, (ms / 1000).toFixed(2));\n  }\n}\n\n/**\n * Makes a URL, preserving querystring (\"search\") parameters.\n *\n * @param {string} s\n * @return {string} A new URL.\n */\nfunction makeUrl(s) {\n  var search = window.location.search;\n\n  // Remove previous {grep, fgrep, invert} query parameters if present\n  if (search) {\n    search = search.replace(/[?&](?:f?grep|invert)=[^&\\s]*/g, '').replace(/^&/, '?');\n  }\n\n  return (\n    window.location.pathname +\n    (search ? search + '&' : '?') +\n    'grep=' +\n    encodeURIComponent(s)\n  );\n}\n\n/**\n * Provide suite URL.\n *\n * @param {Object} [suite]\n */\nHTML.prototype.suiteURL = function (suite) {\n  return makeUrl('^' + escapeRe(suite.fullTitle()) + ' ');\n};\n\n/**\n * Provide test URL.\n *\n * @param {Object} [test]\n */\nHTML.prototype.testURL = function (test) {\n  return makeUrl('^' + escapeRe(test.fullTitle()) + '$');\n};\n\n/**\n * Adds code toggle functionality for the provided test's list element.\n *\n * @param {HTMLLIElement} el\n * @param {string} contents\n */\nHTML.prototype.addCodeToggle = function (el, contents) {\n  var h2 = el.getElementsByTagName('h2')[0];\n\n  on(h2, 'click', function () {\n    pre.style.display = pre.style.display === 'none' ? 'block' : 'none';\n  });\n\n  var pre = fragment('<pre><code>%e</code></pre>', utils.clean(contents));\n  el.appendChild(pre);\n  pre.style.display = 'none';\n};\n\n/**\n * Display error `msg`.\n *\n * @param {string} msg\n */\nfunction error(msg) {\n  document.body.appendChild(fragment('<div id=\"mocha-error\">%s</div>', msg));\n}\n\n/**\n * Return a DOM fragment from `html`.\n *\n * @param {string} html\n */\nfunction fragment(html) {\n  var args = arguments;\n  var div = document.createElement('div');\n  var i = 1;\n\n  div.innerHTML = html.replace(/%([se])/g, function (_, type) {\n    switch (type) {\n      case 's':\n        return String(args[i++]);\n      case 'e':\n        return escape(args[i++]);\n      // no default\n    }\n  });\n\n  return div.firstChild;\n}\n\n/**\n * Check for suites that do not have elements\n * with `classname`, and hide them.\n *\n * @param {text} classname\n */\nfunction hideSuitesWithout(classname) {\n  var suites = document.getElementsByClassName('suite');\n  for (var i = 0; i < suites.length; i++) {\n    var els = suites[i].getElementsByClassName(classname);\n    if (!els.length) {\n      suites[i].className += ' hidden';\n    }\n  }\n}\n\n/**\n * Unhide .hidden suites.\n */\nfunction unhide() {\n  var els = document.getElementsByClassName('suite hidden');\n  while (els.length > 0) {\n    els[0].className = els[0].className.replace('suite hidden', 'suite');\n  }\n}\n\n/**\n * Set an element's text contents.\n *\n * @param {HTMLElement} el\n * @param {string} contents\n */\nfunction text(el, contents) {\n  if (el.textContent) {\n    el.textContent = contents;\n  } else {\n    el.innerText = contents;\n  }\n}\n\n/**\n * Listen on `event` with callback `fn`.\n */\nfunction on(el, event, fn) {\n  if (el.addEventListener) {\n    el.addEventListener(event, fn, false);\n  } else {\n    el.attachEvent('on' + event, fn);\n  }\n}\n\nHTML.browserOnly = true;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9odG1sLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxnRUFBUTtBQUMzQixZQUFZLG1CQUFPLENBQUMseURBQVU7QUFDOUIsZUFBZSxtQkFBTyxDQUFDLG1HQUFzQjtBQUM3QyxnQkFBZ0IsNEZBQThCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGFBQWEsS0FBSyxTQUFTO0FBQ2xGLHFEQUFxRCxhQUFhLEtBQUssU0FBUztBQUNoRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvcmVwb3J0ZXJzL2h0bWwuanM/MTEwZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuLyoqXG4gKiBAbW9kdWxlIEhUTUxcbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGVzY2FwZVJlID0gcmVxdWlyZSgnZXNjYXBlLXN0cmluZy1yZWdleHAnKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9ydW5uZXInKS5jb25zdGFudHM7XG52YXIgRVZFTlRfVEVTVF9QQVNTID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfUEFTUztcbnZhciBFVkVOVF9URVNUX0ZBSUwgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9GQUlMO1xudmFyIEVWRU5UX1NVSVRFX0JFR0lOID0gY29uc3RhbnRzLkVWRU5UX1NVSVRFX0JFR0lOO1xudmFyIEVWRU5UX1NVSVRFX0VORCA9IGNvbnN0YW50cy5FVkVOVF9TVUlURV9FTkQ7XG52YXIgRVZFTlRfVEVTVF9QRU5ESU5HID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfUEVORElORztcbnZhciBlc2NhcGUgPSB1dGlscy5lc2NhcGU7XG5cbi8qKlxuICogU2F2ZSB0aW1lciByZWZlcmVuY2VzIHRvIGF2b2lkIFNpbm9uIGludGVyZmVyaW5nIChzZWUgR0gtMjM3KS5cbiAqL1xuXG52YXIgRGF0ZSA9IGdsb2JhbC5EYXRlO1xuXG4vKipcbiAqIEV4cG9zZSBgSFRNTGAuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gSFRNTDtcblxuLyoqXG4gKiBTdGF0cyB0ZW1wbGF0ZTogUmVzdWx0LCBwcm9ncmVzcywgcGFzc2VzLCBmYWlsdXJlcywgYW5kIGR1cmF0aW9uLlxuICovXG5cbnZhciBzdGF0c1RlbXBsYXRlID1cbiAgJzx1bCBpZD1cIm1vY2hhLXN0YXRzXCI+JyArXG4gICc8bGkgY2xhc3M9XCJyZXN1bHRcIj48L2xpPicgK1xuICAnPGxpIGNsYXNzPVwicHJvZ3Jlc3MtY29udGFpblwiPjxwcm9ncmVzcyBjbGFzcz1cInByb2dyZXNzLWVsZW1lbnRcIiBtYXg9XCIxMDBcIiB2YWx1ZT1cIjBcIj48L3Byb2dyZXNzPjxzdmcgY2xhc3M9XCJwcm9ncmVzcy1yaW5nXCI+PGNpcmNsZSBjbGFzcz1cInJpbmctZmxhdGxpZ2h0XCIgc3Ryb2tlLWRhc2hhcnJheT1cIjEwMCUsMCVcIi8+PGNpcmNsZSBjbGFzcz1cInJpbmctaGlnaGxpZ2h0XCIgc3Ryb2tlLWRhc2hhcnJheT1cIjAlLDEwMCVcIi8+PC9zdmc+PGRpdiBjbGFzcz1cInByb2dyZXNzLXRleHRcIj4wJTwvZGl2PjwvbGk+JyArXG4gICc8bGkgY2xhc3M9XCJwYXNzZXNcIj48YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApO1wiPnBhc3Nlczo8L2E+IDxlbT4wPC9lbT48L2xpPicgK1xuICAnPGxpIGNsYXNzPVwiZmFpbHVyZXNcIj48YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApO1wiPmZhaWx1cmVzOjwvYT4gPGVtPjA8L2VtPjwvbGk+JyArXG4gICc8bGkgY2xhc3M9XCJkdXJhdGlvblwiPmR1cmF0aW9uOiA8ZW0+MDwvZW0+czwvbGk+JyArXG4gICc8L3VsPic7XG5cbnZhciBwbGF5SWNvbiA9ICcmI3gyMDIzOyc7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBgSFRNTGAgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lciAtIEluc3RhbmNlIHRyaWdnZXJzIHJlcG9ydGVyIGFjdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcnVubmVyIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gSFRNTChydW5uZXIsIG9wdGlvbnMpIHtcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lciwgb3B0aW9ucyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICB2YXIgc3RhdCA9IGZyYWdtZW50KHN0YXRzVGVtcGxhdGUpO1xuICB2YXIgaXRlbXMgPSBzdGF0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdsaScpO1xuICBjb25zdCByZXN1bHRJbmRleCA9IDA7XG4gIGNvbnN0IHByb2dyZXNzSW5kZXggPSAxO1xuICBjb25zdCBwYXNzZXNJbmRleCA9IDI7XG4gIGNvbnN0IGZhaWx1cmVzSW5kZXggPSAzO1xuICBjb25zdCBkdXJhdGlvbkluZGV4ID0gNDtcbiAgLyoqIFN0YXQgaXRlbSBjb250YWluaW5nIHRoZSByb290IHN1aXRlIHBhc3Mgb3IgZmFpbCBpbmRpY2F0b3IgKGhhc0ZhaWx1cmVzID8gJ+KclicgOiAn4pyTJykgKi9cbiAgdmFyIHJlc3VsdEluZGljYXRvciA9IGl0ZW1zW3Jlc3VsdEluZGV4XTtcbiAgLyoqIFBhc3NlcyB0ZXh0IGFuZCBjb3VudCAqL1xuICBjb25zdCBwYXNzZXNTdGF0ID0gaXRlbXNbcGFzc2VzSW5kZXhdO1xuICAvKiogU3RhdCBpdGVtIGNvbnRhaW5pbmcgdGhlIHBhc3MgY291bnQgKG5vdCB0aGUgd29yZCwganVzdCB0aGUgbnVtYmVyKSAqL1xuICBjb25zdCBwYXNzZXNDb3VudCA9IHBhc3Nlc1N0YXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2VtJylbMF07XG4gIC8qKiBTdGF0IGl0ZW0gbGlua2luZyB0byBmaWx0ZXIgdG8gc2hvdyBvbmx5IHBhc3NpbmcgdGVzdHMgKi9cbiAgY29uc3QgcGFzc2VzTGluayA9IHBhc3Nlc1N0YXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2EnKVswXTtcbiAgLyoqIEZhaWx1cmVzIHRleHQgYW5kIGNvdW50ICovXG4gIGNvbnN0IGZhaWx1cmVzU3RhdCA9IGl0ZW1zW2ZhaWx1cmVzSW5kZXhdO1xuICAvKiogU3RhdCBpdGVtIGNvbnRhaW5pbmcgdGhlIGZhaWx1cmUgY291bnQgKG5vdCB0aGUgd29yZCwganVzdCB0aGUgbnVtYmVyKSAqL1xuICBjb25zdCBmYWlsdXJlc0NvdW50ID0gZmFpbHVyZXNTdGF0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdlbScpWzBdO1xuICAvKiogU3RhdCBpdGVtIGxpbmtpbmcgdG8gZmlsdGVyIHRvIHNob3cgb25seSBmYWlsaW5nIHRlc3RzICovXG4gIGNvbnN0IGZhaWx1cmVzTGluayA9IGZhaWx1cmVzU3RhdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpWzBdO1xuICAvKiogU3RhdCBpdGVtIGxpbmtpbmcgdG8gdGhlIGR1cmF0aW9uIHRpbWUgKG5vdCB0aGUgd29yZCBvciB1bml0LCBqdXN0IHRoZSBudW1iZXIpICovXG4gIHZhciBkdXJhdGlvbiA9IGl0ZW1zW2R1cmF0aW9uSW5kZXhdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdlbScpWzBdO1xuICB2YXIgcmVwb3J0ID0gZnJhZ21lbnQoJzx1bCBpZD1cIm1vY2hhLXJlcG9ydFwiPjwvdWw+Jyk7XG4gIHZhciBzdGFjayA9IFtyZXBvcnRdO1xuICB2YXIgcHJvZ3Jlc3NUZXh0ID0gaXRlbXNbcHJvZ3Jlc3NJbmRleF0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2RpdicpWzBdO1xuICB2YXIgcHJvZ3Jlc3NCYXIgPSBpdGVtc1twcm9ncmVzc0luZGV4XS5nZXRFbGVtZW50c0J5VGFnTmFtZSgncHJvZ3Jlc3MnKVswXTtcbiAgdmFyIHByb2dyZXNzUmluZyA9IFtcbiAgICBpdGVtc1twcm9ncmVzc0luZGV4XS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdyaW5nLWZsYXRsaWdodCcpWzBdLFxuICAgIGl0ZW1zW3Byb2dyZXNzSW5kZXhdLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3JpbmctaGlnaGxpZ2h0JylbMF1cbiAgXTtcbiAgdmFyIHByb2dyZXNzUmluZ1JhZGl1cyA9IG51bGw7IC8vIGNvbXB1dGVkIENTUyB1bmF2YWlsYWJsZSBub3csIHNvIHNldCBsYXRlclxuICB2YXIgcm9vdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2NoYScpO1xuXG4gIGlmICghcm9vdCkge1xuICAgIHJldHVybiBlcnJvcignI21vY2hhIGRpdiBtaXNzaW5nLCBhZGQgaXQgdG8geW91ciBkb2N1bWVudCcpO1xuICB9XG5cbiAgLy8gcGFzcyB0b2dnbGVcbiAgb24ocGFzc2VzTGluaywgJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHVuaGlkZSgpO1xuICAgIHZhciBuYW1lID0gL3Bhc3MvLnRlc3QocmVwb3J0LmNsYXNzTmFtZSkgPyAnJyA6ICcgcGFzcyc7XG4gICAgcmVwb3J0LmNsYXNzTmFtZSA9IHJlcG9ydC5jbGFzc05hbWUucmVwbGFjZSgvZmFpbHxwYXNzL2csICcnKSArIG5hbWU7XG4gICAgaWYgKHJlcG9ydC5jbGFzc05hbWUudHJpbSgpKSB7XG4gICAgICBoaWRlU3VpdGVzV2l0aG91dCgndGVzdCBwYXNzJyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBmYWlsdXJlIHRvZ2dsZVxuICBvbihmYWlsdXJlc0xpbmssICdjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB1bmhpZGUoKTtcbiAgICB2YXIgbmFtZSA9IC9mYWlsLy50ZXN0KHJlcG9ydC5jbGFzc05hbWUpID8gJycgOiAnIGZhaWwnO1xuICAgIHJlcG9ydC5jbGFzc05hbWUgPSByZXBvcnQuY2xhc3NOYW1lLnJlcGxhY2UoL2ZhaWx8cGFzcy9nLCAnJykgKyBuYW1lO1xuICAgIGlmIChyZXBvcnQuY2xhc3NOYW1lLnRyaW0oKSkge1xuICAgICAgaGlkZVN1aXRlc1dpdGhvdXQoJ3Rlc3QgZmFpbCcpO1xuICAgIH1cbiAgfSk7XG5cbiAgcm9vdC5hcHBlbmRDaGlsZChzdGF0KTtcbiAgcm9vdC5hcHBlbmRDaGlsZChyZXBvcnQpO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9TVUlURV9CRUdJTiwgZnVuY3Rpb24gKHN1aXRlKSB7XG4gICAgaWYgKHN1aXRlLnJvb3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzdWl0ZVxuICAgIHZhciB1cmwgPSBzZWxmLnN1aXRlVVJMKHN1aXRlKTtcbiAgICB2YXIgZWwgPSBmcmFnbWVudChcbiAgICAgICc8bGkgY2xhc3M9XCJzdWl0ZVwiPjxoMT48YSBocmVmPVwiJXNcIj4lczwvYT48L2gxPjwvbGk+JyxcbiAgICAgIHVybCxcbiAgICAgIGVzY2FwZShzdWl0ZS50aXRsZSlcbiAgICApO1xuXG4gICAgLy8gY29udGFpbmVyXG4gICAgc3RhY2tbMF0uYXBwZW5kQ2hpbGQoZWwpO1xuICAgIHN0YWNrLnVuc2hpZnQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKSk7XG4gICAgZWwuYXBwZW5kQ2hpbGQoc3RhY2tbMF0pO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfU1VJVEVfRU5ELCBmdW5jdGlvbiAoc3VpdGUpIHtcbiAgICBpZiAoc3VpdGUucm9vdCkge1xuICAgICAgaWYgKHN0YXRzLmZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgIHRleHQocmVzdWx0SW5kaWNhdG9yLCAn4pyTJyk7XG4gICAgICAgIHN0YXQuY2xhc3NOYW1lICs9ICcgcGFzcyc7XG4gICAgICB9XG4gICAgICB1cGRhdGVTdGF0cygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGFjay5zaGlmdCgpO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9QQVNTLCBmdW5jdGlvbiAodGVzdCkge1xuICAgIHZhciB1cmwgPSBzZWxmLnRlc3RVUkwodGVzdCk7XG4gICAgdmFyIG1hcmt1cCA9XG4gICAgICAnPGxpIGNsYXNzPVwidGVzdCBwYXNzICVlXCI+PGgyPiVlPHNwYW4gY2xhc3M9XCJkdXJhdGlvblwiPiVlbXM8L3NwYW4+ICcgK1xuICAgICAgJzxhIGhyZWY9XCIlc1wiIGNsYXNzPVwicmVwbGF5XCI+JyArXG4gICAgICBwbGF5SWNvbiArXG4gICAgICAnPC9hPjwvaDI+PC9saT4nO1xuICAgIHZhciBlbCA9IGZyYWdtZW50KG1hcmt1cCwgdGVzdC5zcGVlZCwgdGVzdC50aXRsZSwgdGVzdC5kdXJhdGlvbiwgdXJsKTtcbiAgICBzZWxmLmFkZENvZGVUb2dnbGUoZWwsIHRlc3QuYm9keSk7XG4gICAgYXBwZW5kVG9TdGFjayhlbCk7XG4gICAgdXBkYXRlU3RhdHMoKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfRkFJTCwgZnVuY3Rpb24gKHRlc3QpIHtcbiAgICAvLyBVcGRhdGUgc3RhdCBpdGVtc1xuICAgIHRleHQocmVzdWx0SW5kaWNhdG9yLCAn4pyWJyk7XG4gICAgc3RhdC5jbGFzc05hbWUgKz0gJyBmYWlsJztcblxuICAgIHZhciBlbCA9IGZyYWdtZW50KFxuICAgICAgJzxsaSBjbGFzcz1cInRlc3QgZmFpbFwiPjxoMj4lZSA8YSBocmVmPVwiJWVcIiBjbGFzcz1cInJlcGxheVwiPicgK1xuICAgICAgICBwbGF5SWNvbiArXG4gICAgICAgICc8L2E+PC9oMj48L2xpPicsXG4gICAgICB0ZXN0LnRpdGxlLFxuICAgICAgc2VsZi50ZXN0VVJMKHRlc3QpXG4gICAgKTtcbiAgICB2YXIgc3RhY2tTdHJpbmc7IC8vIE5vdGU6IEluY2x1ZGVzIGxlYWRpbmcgbmV3bGluZVxuICAgIHZhciBtZXNzYWdlID0gdGVzdC5lcnIudG9TdHJpbmcoKTtcblxuICAgIC8vIDw9SUU3IHN0cmluZ2lmaWVzIHRvIFtPYmplY3QgRXJyb3JdLiBTaW5jZSBpdCBjYW4gYmUgb3ZlcmxvYWRlZCwgd2VcbiAgICAvLyBjaGVjayBmb3IgdGhlIHJlc3VsdCBvZiB0aGUgc3RyaW5naWZ5aW5nLlxuICAgIGlmIChtZXNzYWdlID09PSAnW29iamVjdCBFcnJvcl0nKSB7XG4gICAgICBtZXNzYWdlID0gdGVzdC5lcnIubWVzc2FnZTtcbiAgICB9XG5cbiAgICBpZiAodGVzdC5lcnIuc3RhY2spIHtcbiAgICAgIHZhciBpbmRleE9mTWVzc2FnZSA9IHRlc3QuZXJyLnN0YWNrLmluZGV4T2YodGVzdC5lcnIubWVzc2FnZSk7XG4gICAgICBpZiAoaW5kZXhPZk1lc3NhZ2UgPT09IC0xKSB7XG4gICAgICAgIHN0YWNrU3RyaW5nID0gdGVzdC5lcnIuc3RhY2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFja1N0cmluZyA9IHRlc3QuZXJyLnN0YWNrLnNsaWNlKFxuICAgICAgICAgIHRlc3QuZXJyLm1lc3NhZ2UubGVuZ3RoICsgaW5kZXhPZk1lc3NhZ2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRlc3QuZXJyLnNvdXJjZVVSTCAmJiB0ZXN0LmVyci5saW5lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFNhZmFyaSBkb2Vzbid0IGdpdmUgeW91IGEgc3RhY2suIExldCdzIGF0IGxlYXN0IHByb3ZpZGUgYSBzb3VyY2UgbGluZS5cbiAgICAgIHN0YWNrU3RyaW5nID0gJ1xcbignICsgdGVzdC5lcnIuc291cmNlVVJMICsgJzonICsgdGVzdC5lcnIubGluZSArICcpJztcbiAgICB9XG5cbiAgICBzdGFja1N0cmluZyA9IHN0YWNrU3RyaW5nIHx8ICcnO1xuXG4gICAgaWYgKHRlc3QuZXJyLmh0bWxNZXNzYWdlICYmIHN0YWNrU3RyaW5nKSB7XG4gICAgICBlbC5hcHBlbmRDaGlsZChcbiAgICAgICAgZnJhZ21lbnQoXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCJodG1sLWVycm9yXCI+JXNcXG48cHJlIGNsYXNzPVwiZXJyb3JcIj4lZTwvcHJlPjwvZGl2PicsXG4gICAgICAgICAgdGVzdC5lcnIuaHRtbE1lc3NhZ2UsXG4gICAgICAgICAgc3RhY2tTdHJpbmdcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHRlc3QuZXJyLmh0bWxNZXNzYWdlKSB7XG4gICAgICBlbC5hcHBlbmRDaGlsZChcbiAgICAgICAgZnJhZ21lbnQoJzxkaXYgY2xhc3M9XCJodG1sLWVycm9yXCI+JXM8L2Rpdj4nLCB0ZXN0LmVyci5odG1sTWVzc2FnZSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmFwcGVuZENoaWxkKFxuICAgICAgICBmcmFnbWVudCgnPHByZSBjbGFzcz1cImVycm9yXCI+JWUlZTwvcHJlPicsIG1lc3NhZ2UsIHN0YWNrU3RyaW5nKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBzZWxmLmFkZENvZGVUb2dnbGUoZWwsIHRlc3QuYm9keSk7XG4gICAgYXBwZW5kVG9TdGFjayhlbCk7XG4gICAgdXBkYXRlU3RhdHMoKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfUEVORElORywgZnVuY3Rpb24gKHRlc3QpIHtcbiAgICB2YXIgZWwgPSBmcmFnbWVudChcbiAgICAgICc8bGkgY2xhc3M9XCJ0ZXN0IHBhc3MgcGVuZGluZ1wiPjxoMj4lZTwvaDI+PC9saT4nLFxuICAgICAgdGVzdC50aXRsZVxuICAgICk7XG4gICAgYXBwZW5kVG9TdGFjayhlbCk7XG4gICAgdXBkYXRlU3RhdHMoKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYXBwZW5kVG9TdGFjayhlbCkge1xuICAgIC8vIERvbid0IGNhbGwgLmFwcGVuZENoaWxkIGlmICNtb2NoYS1yZXBvcnQgd2FzIGFscmVhZHkgLnNoaWZ0KCknZWQgb2ZmIHRoZSBzdGFjay5cbiAgICBpZiAoc3RhY2tbMF0pIHtcbiAgICAgIHN0YWNrWzBdLmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVTdGF0cygpIHtcbiAgICB2YXIgcGVyY2VudCA9ICgoc3RhdHMudGVzdHMgLyBydW5uZXIudG90YWwpICogMTAwKSB8IDA7XG4gICAgcHJvZ3Jlc3NCYXIudmFsdWUgPSBwZXJjZW50O1xuICAgIGlmIChwcm9ncmVzc1RleHQpIHtcbiAgICAgIC8vIHNldHRpbmcgYSB0b0ZpeGVkIHRoYXQgaXMgdG9vIGxvdywgbWFrZXMgc21hbGwgY2hhbmdlcyB0byBwcm9ncmVzcyBub3Qgc2hvd25cbiAgICAgIC8vIHNldHRpbmcgaXQgdG9vIGhpZ2gsIG1ha2VzIHRoZSBwcm9ncmVzcyB0ZXh0IGxvbmdlciB0aGVuIGl0IG5lZWRzIHRvXG4gICAgICAvLyB0byBhZGRyZXNzIHRoaXMsIGNhbGN1bGF0ZSB0aGUgdG9GaXhlZCBiYXNlZCBvbiB0aGUgbWFnbml0dWRlIG9mIHRvdGFsXG4gICAgICB2YXIgZGVjaW1hbFBsYWNlcyA9IE1hdGguY2VpbChNYXRoLmxvZzEwKHJ1bm5lci50b3RhbCAvIDEwMCkpO1xuICAgICAgdGV4dChcbiAgICAgICAgcHJvZ3Jlc3NUZXh0LFxuICAgICAgICBwZXJjZW50LnRvRml4ZWQoTWF0aC5taW4oTWF0aC5tYXgoZGVjaW1hbFBsYWNlcywgMCksIDEwMCkpICsgJyUnXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAocHJvZ3Jlc3NSaW5nKSB7XG4gICAgICB2YXIgcmFkaXVzID0gcGFyc2VGbG9hdChnZXRDb21wdXRlZFN0eWxlKHByb2dyZXNzUmluZ1swXSkuZ2V0UHJvcGVydHlWYWx1ZSgncicpKTtcbiAgICAgIHZhciB3aG9sZUFyYyA9IE1hdGguUEkgKiAyICogcmFkaXVzO1xuICAgICAgdmFyIGhpZ2hsaWdodEFyYyA9IHBlcmNlbnQgKiAod2hvbGVBcmMgLyAxMDApO1xuICAgICAgLy8gVGhlIHByb2dyZXNzIHJpbmcgaXMgaW4gMiBwYXJ0cywgdGhlIGZsYXRsaWdodCBjb2xvciBhbmQgaGlnaGxpZ2h0IGNvbG9yLlxuICAgICAgLy8gUmVuZGVyaW5nIGJvdGggb24gdG9wIG9mIHRoZSBvdGhlciwgc2VlbXMgdG8gbWFrZSBhIDNyZCBjb2xvciBvbiB0aGUgZWRnZXMuXG4gICAgICAvLyBUbyBjcmVhdGUgMSB3aG9sZSByaW5nIHdpdGggMiBjb2xvcnMsIGJvdGggcGFydHMgYXJlIGludmVyc2Ugb2YgdGhlIG90aGVyLlxuICAgICAgcHJvZ3Jlc3NSaW5nWzBdLnN0eWxlWydzdHJva2UtZGFzaGFycmF5J10gPSBgMCwke2hpZ2hsaWdodEFyY31weCwke3dob2xlQXJjfXB4YDtcbiAgICAgIHByb2dyZXNzUmluZ1sxXS5zdHlsZVsnc3Ryb2tlLWRhc2hhcnJheSddID0gYCR7aGlnaGxpZ2h0QXJjfXB4LCR7d2hvbGVBcmN9cHhgO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBzdGF0c1xuICAgIHZhciBtcyA9IG5ldyBEYXRlKCkgLSBzdGF0cy5zdGFydDtcbiAgICB0ZXh0KHBhc3Nlc0NvdW50LCBzdGF0cy5wYXNzZXMpO1xuICAgIHRleHQoZmFpbHVyZXNDb3VudCwgc3RhdHMuZmFpbHVyZXMpO1xuICAgIHRleHQoZHVyYXRpb24sIChtcyAvIDEwMDApLnRvRml4ZWQoMikpO1xuICB9XG59XG5cbi8qKlxuICogTWFrZXMgYSBVUkwsIHByZXNlcnZpbmcgcXVlcnlzdHJpbmcgKFwic2VhcmNoXCIpIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBuZXcgVVJMLlxuICovXG5mdW5jdGlvbiBtYWtlVXJsKHMpIHtcbiAgdmFyIHNlYXJjaCA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7XG5cbiAgLy8gUmVtb3ZlIHByZXZpb3VzIHtncmVwLCBmZ3JlcCwgaW52ZXJ0fSBxdWVyeSBwYXJhbWV0ZXJzIGlmIHByZXNlbnRcbiAgaWYgKHNlYXJjaCkge1xuICAgIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKC9bPyZdKD86Zj9ncmVwfGludmVydCk9W14mXFxzXSovZywgJycpLnJlcGxhY2UoL14mLywgJz8nKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICtcbiAgICAoc2VhcmNoID8gc2VhcmNoICsgJyYnIDogJz8nKSArXG4gICAgJ2dyZXA9JyArXG4gICAgZW5jb2RlVVJJQ29tcG9uZW50KHMpXG4gICk7XG59XG5cbi8qKlxuICogUHJvdmlkZSBzdWl0ZSBVUkwuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtzdWl0ZV1cbiAqL1xuSFRNTC5wcm90b3R5cGUuc3VpdGVVUkwgPSBmdW5jdGlvbiAoc3VpdGUpIHtcbiAgcmV0dXJuIG1ha2VVcmwoJ14nICsgZXNjYXBlUmUoc3VpdGUuZnVsbFRpdGxlKCkpICsgJyAnKTtcbn07XG5cbi8qKlxuICogUHJvdmlkZSB0ZXN0IFVSTC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW3Rlc3RdXG4gKi9cbkhUTUwucHJvdG90eXBlLnRlc3RVUkwgPSBmdW5jdGlvbiAodGVzdCkge1xuICByZXR1cm4gbWFrZVVybCgnXicgKyBlc2NhcGVSZSh0ZXN0LmZ1bGxUaXRsZSgpKSArICckJyk7XG59O1xuXG4vKipcbiAqIEFkZHMgY29kZSB0b2dnbGUgZnVuY3Rpb25hbGl0eSBmb3IgdGhlIHByb3ZpZGVkIHRlc3QncyBsaXN0IGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtIVE1MTElFbGVtZW50fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRzXG4gKi9cbkhUTUwucHJvdG90eXBlLmFkZENvZGVUb2dnbGUgPSBmdW5jdGlvbiAoZWwsIGNvbnRlbnRzKSB7XG4gIHZhciBoMiA9IGVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoMicpWzBdO1xuXG4gIG9uKGgyLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgcHJlLnN0eWxlLmRpc3BsYXkgPSBwcmUuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJ2Jsb2NrJyA6ICdub25lJztcbiAgfSk7XG5cbiAgdmFyIHByZSA9IGZyYWdtZW50KCc8cHJlPjxjb2RlPiVlPC9jb2RlPjwvcHJlPicsIHV0aWxzLmNsZWFuKGNvbnRlbnRzKSk7XG4gIGVsLmFwcGVuZENoaWxkKHByZSk7XG4gIHByZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xufTtcblxuLyoqXG4gKiBEaXNwbGF5IGVycm9yIGBtc2dgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtc2dcbiAqL1xuZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZnJhZ21lbnQoJzxkaXYgaWQ9XCJtb2NoYS1lcnJvclwiPiVzPC9kaXY+JywgbXNnKSk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgRE9NIGZyYWdtZW50IGZyb20gYGh0bWxgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKi9cbmZ1bmN0aW9uIGZyYWdtZW50KGh0bWwpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIGkgPSAxO1xuXG4gIGRpdi5pbm5lckhUTUwgPSBodG1sLnJlcGxhY2UoLyUoW3NlXSkvZywgZnVuY3Rpb24gKF8sIHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3MnOlxuICAgICAgICByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICdlJzpcbiAgICAgICAgcmV0dXJuIGVzY2FwZShhcmdzW2krK10pO1xuICAgICAgLy8gbm8gZGVmYXVsdFxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRpdi5maXJzdENoaWxkO1xufVxuXG4vKipcbiAqIENoZWNrIGZvciBzdWl0ZXMgdGhhdCBkbyBub3QgaGF2ZSBlbGVtZW50c1xuICogd2l0aCBgY2xhc3NuYW1lYCwgYW5kIGhpZGUgdGhlbS5cbiAqXG4gKiBAcGFyYW0ge3RleHR9IGNsYXNzbmFtZVxuICovXG5mdW5jdGlvbiBoaWRlU3VpdGVzV2l0aG91dChjbGFzc25hbWUpIHtcbiAgdmFyIHN1aXRlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3N1aXRlJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3VpdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVscyA9IHN1aXRlc1tpXS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzbmFtZSk7XG4gICAgaWYgKCFlbHMubGVuZ3RoKSB7XG4gICAgICBzdWl0ZXNbaV0uY2xhc3NOYW1lICs9ICcgaGlkZGVuJztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBVbmhpZGUgLmhpZGRlbiBzdWl0ZXMuXG4gKi9cbmZ1bmN0aW9uIHVuaGlkZSgpIHtcbiAgdmFyIGVscyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3N1aXRlIGhpZGRlbicpO1xuICB3aGlsZSAoZWxzLmxlbmd0aCA+IDApIHtcbiAgICBlbHNbMF0uY2xhc3NOYW1lID0gZWxzWzBdLmNsYXNzTmFtZS5yZXBsYWNlKCdzdWl0ZSBoaWRkZW4nLCAnc3VpdGUnKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldCBhbiBlbGVtZW50J3MgdGV4dCBjb250ZW50cy5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRzXG4gKi9cbmZ1bmN0aW9uIHRleHQoZWwsIGNvbnRlbnRzKSB7XG4gIGlmIChlbC50ZXh0Q29udGVudCkge1xuICAgIGVsLnRleHRDb250ZW50ID0gY29udGVudHM7XG4gIH0gZWxzZSB7XG4gICAgZWwuaW5uZXJUZXh0ID0gY29udGVudHM7XG4gIH1cbn1cblxuLyoqXG4gKiBMaXN0ZW4gb24gYGV2ZW50YCB3aXRoIGNhbGxiYWNrIGBmbmAuXG4gKi9cbmZ1bmN0aW9uIG9uKGVsLCBldmVudCwgZm4pIHtcbiAgaWYgKGVsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmbiwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgZm4pO1xuICB9XG59XG5cbkhUTUwuYnJvd3Nlck9ubHkgPSB0cnVlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/reporters/html.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/reporters/index.js":
/*!***************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n// Alias exports to a their normalized format Mocha#reporter to prevent a need\n// for dynamic (try/catch) requires, which Browserify doesn't handle.\nexports.Base = exports.base = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/mocha/lib/reporters/base.js\");\nexports.Dot = exports.dot = __webpack_require__(/*! ./dot */ \"(ssr)/./node_modules/mocha/lib/reporters/dot.js\");\nexports.Doc = exports.doc = __webpack_require__(/*! ./doc */ \"(ssr)/./node_modules/mocha/lib/reporters/doc.js\");\nexports.TAP = exports.tap = __webpack_require__(/*! ./tap */ \"(ssr)/./node_modules/mocha/lib/reporters/tap.js\");\nexports.JSON = exports.json = __webpack_require__(/*! ./json */ \"(ssr)/./node_modules/mocha/lib/reporters/json.js\");\nexports.HTML = exports.html = __webpack_require__(/*! ./html */ \"(ssr)/./node_modules/mocha/lib/reporters/html.js\");\nexports.List = exports.list = __webpack_require__(/*! ./list */ \"(ssr)/./node_modules/mocha/lib/reporters/list.js\");\nexports.Min = exports.min = __webpack_require__(/*! ./min */ \"(ssr)/./node_modules/mocha/lib/reporters/min.js\");\nexports.Spec = exports.spec = __webpack_require__(/*! ./spec */ \"(ssr)/./node_modules/mocha/lib/reporters/spec.js\");\nexports.Nyan = exports.nyan = __webpack_require__(/*! ./nyan */ \"(ssr)/./node_modules/mocha/lib/reporters/nyan.js\");\nexports.XUnit = exports.xunit = __webpack_require__(/*! ./xunit */ \"(ssr)/./node_modules/mocha/lib/reporters/xunit.js\");\nexports.Markdown = exports.markdown = __webpack_require__(/*! ./markdown */ \"(ssr)/./node_modules/mocha/lib/reporters/markdown.js\");\nexports.Progress = exports.progress = __webpack_require__(/*! ./progress */ \"(ssr)/./node_modules/mocha/lib/reporters/progress.js\");\nexports.Landing = exports.landing = __webpack_require__(/*! ./landing */ \"(ssr)/./node_modules/mocha/lib/reporters/landing.js\");\nexports.JSONStream = exports[\"json-stream\"] = __webpack_require__(/*! ./json-stream */ \"(ssr)/./node_modules/mocha/lib/reporters/json-stream.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0EsWUFBWSxHQUFHLG9HQUFnQztBQUMvQyxXQUFXLEdBQUcsaUdBQThCO0FBQzVDLFdBQVcsR0FBRyxpR0FBOEI7QUFDNUMsV0FBVyxHQUFHLGlHQUE4QjtBQUM1QyxZQUFZLEdBQUcsb0dBQWdDO0FBQy9DLFlBQVksR0FBRyxvR0FBZ0M7QUFDL0MsWUFBWSxHQUFHLG9HQUFnQztBQUMvQyxXQUFXLEdBQUcsaUdBQThCO0FBQzVDLFlBQVksR0FBRyxvR0FBZ0M7QUFDL0MsWUFBWSxHQUFHLG9HQUFnQztBQUMvQyxhQUFhLEdBQUcsdUdBQWtDO0FBQ2xELGdCQUFnQixHQUFHLGdIQUF3QztBQUMzRCxnQkFBZ0IsR0FBRyxnSEFBd0M7QUFDM0QsZUFBZSxHQUFHLDZHQUFzQztBQUN4RCxrQkFBa0IsR0FBRyw0SEFBaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMvaW5kZXguanM/NTMyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIEFsaWFzIGV4cG9ydHMgdG8gYSB0aGVpciBub3JtYWxpemVkIGZvcm1hdCBNb2NoYSNyZXBvcnRlciB0byBwcmV2ZW50IGEgbmVlZFxuLy8gZm9yIGR5bmFtaWMgKHRyeS9jYXRjaCkgcmVxdWlyZXMsIHdoaWNoIEJyb3dzZXJpZnkgZG9lc24ndCBoYW5kbGUuXG5leHBvcnRzLkJhc2UgPSBleHBvcnRzLmJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbmV4cG9ydHMuRG90ID0gZXhwb3J0cy5kb3QgPSByZXF1aXJlKCcuL2RvdCcpO1xuZXhwb3J0cy5Eb2MgPSBleHBvcnRzLmRvYyA9IHJlcXVpcmUoJy4vZG9jJyk7XG5leHBvcnRzLlRBUCA9IGV4cG9ydHMudGFwID0gcmVxdWlyZSgnLi90YXAnKTtcbmV4cG9ydHMuSlNPTiA9IGV4cG9ydHMuanNvbiA9IHJlcXVpcmUoJy4vanNvbicpO1xuZXhwb3J0cy5IVE1MID0gZXhwb3J0cy5odG1sID0gcmVxdWlyZSgnLi9odG1sJyk7XG5leHBvcnRzLkxpc3QgPSBleHBvcnRzLmxpc3QgPSByZXF1aXJlKCcuL2xpc3QnKTtcbmV4cG9ydHMuTWluID0gZXhwb3J0cy5taW4gPSByZXF1aXJlKCcuL21pbicpO1xuZXhwb3J0cy5TcGVjID0gZXhwb3J0cy5zcGVjID0gcmVxdWlyZSgnLi9zcGVjJyk7XG5leHBvcnRzLk55YW4gPSBleHBvcnRzLm55YW4gPSByZXF1aXJlKCcuL255YW4nKTtcbmV4cG9ydHMuWFVuaXQgPSBleHBvcnRzLnh1bml0ID0gcmVxdWlyZSgnLi94dW5pdCcpO1xuZXhwb3J0cy5NYXJrZG93biA9IGV4cG9ydHMubWFya2Rvd24gPSByZXF1aXJlKCcuL21hcmtkb3duJyk7XG5leHBvcnRzLlByb2dyZXNzID0gZXhwb3J0cy5wcm9ncmVzcyA9IHJlcXVpcmUoJy4vcHJvZ3Jlc3MnKTtcbmV4cG9ydHMuTGFuZGluZyA9IGV4cG9ydHMubGFuZGluZyA9IHJlcXVpcmUoJy4vbGFuZGluZycpO1xuZXhwb3J0cy5KU09OU3RyZWFtID0gZXhwb3J0c1snanNvbi1zdHJlYW0nXSA9IHJlcXVpcmUoJy4vanNvbi1zdHJlYW0nKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/reporters/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/reporters/json-stream.js":
/*!*********************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/json-stream.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * @module JSONStream\n */\n/**\n * Module dependencies.\n */\n\nvar Base = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/mocha/lib/reporters/base.js\");\nvar constants = (__webpack_require__(/*! ../runner */ \"(ssr)/./node_modules/mocha/lib/runner.js\").constants);\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\n\n/**\n * Expose `JSONStream`.\n */\n\nexports = module.exports = JSONStream;\n\n/**\n * Constructs a new `JSONStream` reporter instance.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @param {Runner} runner - Instance triggers reporter actions.\n * @param {Object} [options] - runner options\n */\nfunction JSONStream(runner, options) {\n  Base.call(this, runner, options);\n\n  var self = this;\n  var total = runner.total;\n\n  runner.once(EVENT_RUN_BEGIN, function () {\n    writeEvent(['start', {total}]);\n  });\n\n  runner.on(EVENT_TEST_PASS, function (test) {\n    writeEvent(['pass', clean(test)]);\n  });\n\n  runner.on(EVENT_TEST_FAIL, function (test, err) {\n    test = clean(test);\n    test.err = err.message;\n    test.stack = err.stack || null;\n    writeEvent(['fail', test]);\n  });\n\n  runner.once(EVENT_RUN_END, function () {\n    writeEvent(['end', self.stats]);\n  });\n}\n\n/**\n * Mocha event to be written to the output stream.\n * @typedef {Array} JSONStream~MochaEvent\n */\n\n/**\n * Writes Mocha event to reporter output stream.\n *\n * @private\n * @param {JSONStream~MochaEvent} event - Mocha event to be output.\n */\nfunction writeEvent(event) {\n  process.stdout.write(JSON.stringify(event) + '\\n');\n}\n\n/**\n * Returns an object literal representation of `test`\n * free of cyclic properties, etc.\n *\n * @private\n * @param {Test} test - Instance used as data source.\n * @return {Object} object containing pared-down test instance data\n */\nfunction clean(test) {\n  return {\n    title: test.title,\n    fullTitle: test.fullTitle(),\n    file: test.file,\n    duration: test.duration,\n    currentRetry: test.currentRetry(),\n    speed: test.speed\n  };\n}\n\nJSONStream.description = 'newline delimited JSON events';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9qc29uLXN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsZ0VBQVE7QUFDM0IsZ0JBQWdCLDRGQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEMsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvcmVwb3J0ZXJzL2pzb24tc3RyZWFtLmpzP2FkMzYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIEpTT05TdHJlYW1cbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vcnVubmVyJykuY29uc3RhbnRzO1xudmFyIEVWRU5UX1RFU1RfUEFTUyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BBU1M7XG52YXIgRVZFTlRfVEVTVF9GQUlMID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfRkFJTDtcbnZhciBFVkVOVF9SVU5fQkVHSU4gPSBjb25zdGFudHMuRVZFTlRfUlVOX0JFR0lOO1xudmFyIEVWRU5UX1JVTl9FTkQgPSBjb25zdGFudHMuRVZFTlRfUlVOX0VORDtcblxuLyoqXG4gKiBFeHBvc2UgYEpTT05TdHJlYW1gLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEpTT05TdHJlYW07XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBgSlNPTlN0cmVhbWAgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lciAtIEluc3RhbmNlIHRyaWdnZXJzIHJlcG9ydGVyIGFjdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcnVubmVyIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gSlNPTlN0cmVhbShydW5uZXIsIG9wdGlvbnMpIHtcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lciwgb3B0aW9ucyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdG90YWwgPSBydW5uZXIudG90YWw7XG5cbiAgcnVubmVyLm9uY2UoRVZFTlRfUlVOX0JFR0lOLCBmdW5jdGlvbiAoKSB7XG4gICAgd3JpdGVFdmVudChbJ3N0YXJ0Jywge3RvdGFsfV0pO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9QQVNTLCBmdW5jdGlvbiAodGVzdCkge1xuICAgIHdyaXRlRXZlbnQoWydwYXNzJywgY2xlYW4odGVzdCldKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfRkFJTCwgZnVuY3Rpb24gKHRlc3QsIGVycikge1xuICAgIHRlc3QgPSBjbGVhbih0ZXN0KTtcbiAgICB0ZXN0LmVyciA9IGVyci5tZXNzYWdlO1xuICAgIHRlc3Quc3RhY2sgPSBlcnIuc3RhY2sgfHwgbnVsbDtcbiAgICB3cml0ZUV2ZW50KFsnZmFpbCcsIHRlc3RdKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uY2UoRVZFTlRfUlVOX0VORCwgZnVuY3Rpb24gKCkge1xuICAgIHdyaXRlRXZlbnQoWydlbmQnLCBzZWxmLnN0YXRzXSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIE1vY2hhIGV2ZW50IHRvIGJlIHdyaXR0ZW4gdG8gdGhlIG91dHB1dCBzdHJlYW0uXG4gKiBAdHlwZWRlZiB7QXJyYXl9IEpTT05TdHJlYW1+TW9jaGFFdmVudFxuICovXG5cbi8qKlxuICogV3JpdGVzIE1vY2hhIGV2ZW50IHRvIHJlcG9ydGVyIG91dHB1dCBzdHJlYW0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7SlNPTlN0cmVhbX5Nb2NoYUV2ZW50fSBldmVudCAtIE1vY2hhIGV2ZW50IHRvIGJlIG91dHB1dC5cbiAqL1xuZnVuY3Rpb24gd3JpdGVFdmVudChldmVudCkge1xuICBwcm9jZXNzLnN0ZG91dC53cml0ZShKU09OLnN0cmluZ2lmeShldmVudCkgKyAnXFxuJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgbGl0ZXJhbCByZXByZXNlbnRhdGlvbiBvZiBgdGVzdGBcbiAqIGZyZWUgb2YgY3ljbGljIHByb3BlcnRpZXMsIGV0Yy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtUZXN0fSB0ZXN0IC0gSW5zdGFuY2UgdXNlZCBhcyBkYXRhIHNvdXJjZS5cbiAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgcGFyZWQtZG93biB0ZXN0IGluc3RhbmNlIGRhdGFcbiAqL1xuZnVuY3Rpb24gY2xlYW4odGVzdCkge1xuICByZXR1cm4ge1xuICAgIHRpdGxlOiB0ZXN0LnRpdGxlLFxuICAgIGZ1bGxUaXRsZTogdGVzdC5mdWxsVGl0bGUoKSxcbiAgICBmaWxlOiB0ZXN0LmZpbGUsXG4gICAgZHVyYXRpb246IHRlc3QuZHVyYXRpb24sXG4gICAgY3VycmVudFJldHJ5OiB0ZXN0LmN1cnJlbnRSZXRyeSgpLFxuICAgIHNwZWVkOiB0ZXN0LnNwZWVkXG4gIH07XG59XG5cbkpTT05TdHJlYW0uZGVzY3JpcHRpb24gPSAnbmV3bGluZSBkZWxpbWl0ZWQgSlNPTiBldmVudHMnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/reporters/json-stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/reporters/json.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/json.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * @module JSON\n */\n/**\n * Module dependencies.\n */\n\nvar Base = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/mocha/lib/reporters/base.js\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\nconst createUnsupportedError = (__webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/mocha/lib/errors.js\").createUnsupportedError);\nconst utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\");\nvar constants = (__webpack_require__(/*! ../runner */ \"(ssr)/./node_modules/mocha/lib/runner.js\").constants);\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\nvar EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\nvar EVENT_TEST_END = constants.EVENT_TEST_END;\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\n\n/**\n * Expose `JSON`.\n */\n\nexports = module.exports = JSONReporter;\n\n/**\n * Constructs a new `JSON` reporter instance.\n *\n * @public\n * @class JSON\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @param {Runner} runner - Instance triggers reporter actions.\n * @param {Object} [options] - runner options\n */\nfunction JSONReporter(runner, options = {}) {\n  Base.call(this, runner, options);\n\n  var self = this;\n  var tests = [];\n  var pending = [];\n  var failures = [];\n  var passes = [];\n  var output;\n\n  if (options.reporterOption && options.reporterOption.output) {\n    if (utils.isBrowser()) {\n      throw createUnsupportedError('file output not supported in browser');\n    }\n    output = options.reporterOption.output;\n  }\n\n  runner.on(EVENT_TEST_END, function (test) {\n    tests.push(test);\n  });\n\n  runner.on(EVENT_TEST_PASS, function (test) {\n    passes.push(test);\n  });\n\n  runner.on(EVENT_TEST_FAIL, function (test) {\n    failures.push(test);\n  });\n\n  runner.on(EVENT_TEST_PENDING, function (test) {\n    pending.push(test);\n  });\n\n  runner.once(EVENT_RUN_END, function () {\n    var obj = {\n      stats: self.stats,\n      tests: tests.map(clean),\n      pending: pending.map(clean),\n      failures: failures.map(clean),\n      passes: passes.map(clean)\n    };\n\n    runner.testResults = obj;\n\n    var json = JSON.stringify(obj, null, 2);\n    if (output) {\n      try {\n        fs.mkdirSync(path.dirname(output), {recursive: true});\n        fs.writeFileSync(output, json);\n      } catch (err) {\n        console.error(\n          `${Base.symbols.err} [mocha] writing output to \"${output}\" failed: ${err.message}\\n`\n        );\n        process.stdout.write(json);\n      }\n    } else {\n      process.stdout.write(json);\n    }\n  });\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @private\n * @param {Object} test\n * @return {Object}\n */\nfunction clean(test) {\n  var err = test.err || {};\n  if (err instanceof Error) {\n    err = errorJSON(err);\n  }\n\n  return {\n    title: test.title,\n    fullTitle: test.fullTitle(),\n    file: test.file,\n    duration: test.duration,\n    currentRetry: test.currentRetry(),\n    speed: test.speed,\n    err: cleanCycles(err)\n  };\n}\n\n/**\n * Replaces any circular references inside `obj` with '[object Object]'\n *\n * @private\n * @param {Object} obj\n * @return {Object}\n */\nfunction cleanCycles(obj) {\n  var cache = [];\n  return JSON.parse(\n    JSON.stringify(obj, function (key, value) {\n      if (typeof value === 'object' && value !== null) {\n        if (cache.indexOf(value) !== -1) {\n          // Instead of going in a circle, we'll print [object Object]\n          return '' + value;\n        }\n        cache.push(value);\n      }\n\n      return value;\n    })\n  );\n}\n\n/**\n * Transform an Error object into a JSON object.\n *\n * @private\n * @param {Error} err\n * @return {Object}\n */\nfunction errorJSON(err) {\n  var res = {};\n  Object.getOwnPropertyNames(err).forEach(function (key) {\n    res[key] = err[key];\n  }, err);\n  return res;\n}\n\nJSONReporter.description = 'single JSON object';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9qc29uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxnRUFBUTtBQUMzQixTQUFTLG1CQUFPLENBQUMsY0FBSTtBQUNyQixXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsK0JBQStCLHlHQUEyQztBQUMxRSxjQUFjLG1CQUFPLENBQUMseURBQVU7QUFDaEMsZ0JBQWdCLDRGQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0I7QUFDNUQ7QUFDQSxRQUFRO0FBQ1I7QUFDQSxhQUFhLGtCQUFrQiw2QkFBNkIsT0FBTyxZQUFZLFlBQVk7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvcmVwb3J0ZXJzL2pzb24uanM/YzEzOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBtb2R1bGUgSlNPTlxuICovXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGNyZWF0ZVVuc3VwcG9ydGVkRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jcmVhdGVVbnN1cHBvcnRlZEVycm9yO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL3J1bm5lcicpLmNvbnN0YW50cztcbnZhciBFVkVOVF9URVNUX1BBU1MgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9QQVNTO1xudmFyIEVWRU5UX1RFU1RfUEVORElORyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BFTkRJTkc7XG52YXIgRVZFTlRfVEVTVF9GQUlMID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfRkFJTDtcbnZhciBFVkVOVF9URVNUX0VORCA9IGNvbnN0YW50cy5FVkVOVF9URVNUX0VORDtcbnZhciBFVkVOVF9SVU5fRU5EID0gY29uc3RhbnRzLkVWRU5UX1JVTl9FTkQ7XG5cbi8qKlxuICogRXhwb3NlIGBKU09OYC5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBKU09OUmVwb3J0ZXI7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBgSlNPTmAgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzIEpTT05cbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyIC0gSW5zdGFuY2UgdHJpZ2dlcnMgcmVwb3J0ZXIgYWN0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBydW5uZXIgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBKU09OUmVwb3J0ZXIocnVubmVyLCBvcHRpb25zID0ge30pIHtcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lciwgb3B0aW9ucyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdGVzdHMgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBbXTtcbiAgdmFyIGZhaWx1cmVzID0gW107XG4gIHZhciBwYXNzZXMgPSBbXTtcbiAgdmFyIG91dHB1dDtcblxuICBpZiAob3B0aW9ucy5yZXBvcnRlck9wdGlvbiAmJiBvcHRpb25zLnJlcG9ydGVyT3B0aW9uLm91dHB1dCkge1xuICAgIGlmICh1dGlscy5pc0Jyb3dzZXIoKSkge1xuICAgICAgdGhyb3cgY3JlYXRlVW5zdXBwb3J0ZWRFcnJvcignZmlsZSBvdXRwdXQgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyJyk7XG4gICAgfVxuICAgIG91dHB1dCA9IG9wdGlvbnMucmVwb3J0ZXJPcHRpb24ub3V0cHV0O1xuICB9XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfRU5ELCBmdW5jdGlvbiAodGVzdCkge1xuICAgIHRlc3RzLnB1c2godGVzdCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BBU1MsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgcGFzc2VzLnB1c2godGVzdCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX0ZBSUwsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgZmFpbHVyZXMucHVzaCh0ZXN0KTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfUEVORElORywgZnVuY3Rpb24gKHRlc3QpIHtcbiAgICBwZW5kaW5nLnB1c2godGVzdCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbmNlKEVWRU5UX1JVTl9FTkQsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgc3RhdHM6IHNlbGYuc3RhdHMsXG4gICAgICB0ZXN0czogdGVzdHMubWFwKGNsZWFuKSxcbiAgICAgIHBlbmRpbmc6IHBlbmRpbmcubWFwKGNsZWFuKSxcbiAgICAgIGZhaWx1cmVzOiBmYWlsdXJlcy5tYXAoY2xlYW4pLFxuICAgICAgcGFzc2VzOiBwYXNzZXMubWFwKGNsZWFuKVxuICAgIH07XG5cbiAgICBydW5uZXIudGVzdFJlc3VsdHMgPSBvYmo7XG5cbiAgICB2YXIganNvbiA9IEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMik7XG4gICAgaWYgKG91dHB1dCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZnMubWtkaXJTeW5jKHBhdGguZGlybmFtZShvdXRwdXQpLCB7cmVjdXJzaXZlOiB0cnVlfSk7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMob3V0cHV0LCBqc29uKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIGAke0Jhc2Uuc3ltYm9scy5lcnJ9IFttb2NoYV0gd3JpdGluZyBvdXRwdXQgdG8gXCIke291dHB1dH1cIiBmYWlsZWQ6ICR7ZXJyLm1lc3NhZ2V9XFxuYFxuICAgICAgICApO1xuICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShqc29uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoanNvbik7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBwbGFpbi1vYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYHRlc3RgXG4gKiBmcmVlIG9mIGN5Y2xpYyBwcm9wZXJ0aWVzIGV0Yy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHRlc3RcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gY2xlYW4odGVzdCkge1xuICB2YXIgZXJyID0gdGVzdC5lcnIgfHwge307XG4gIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIGVyciA9IGVycm9ySlNPTihlcnIpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0aXRsZTogdGVzdC50aXRsZSxcbiAgICBmdWxsVGl0bGU6IHRlc3QuZnVsbFRpdGxlKCksXG4gICAgZmlsZTogdGVzdC5maWxlLFxuICAgIGR1cmF0aW9uOiB0ZXN0LmR1cmF0aW9uLFxuICAgIGN1cnJlbnRSZXRyeTogdGVzdC5jdXJyZW50UmV0cnkoKSxcbiAgICBzcGVlZDogdGVzdC5zcGVlZCxcbiAgICBlcnI6IGNsZWFuQ3ljbGVzKGVycilcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXBsYWNlcyBhbnkgY2lyY3VsYXIgcmVmZXJlbmNlcyBpbnNpZGUgYG9iamAgd2l0aCAnW29iamVjdCBPYmplY3RdJ1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNsZWFuQ3ljbGVzKG9iaikge1xuICB2YXIgY2FjaGUgPSBbXTtcbiAgcmV0dXJuIEpTT04ucGFyc2UoXG4gICAgSlNPTi5zdHJpbmdpZnkob2JqLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKGNhY2hlLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgIC8vIEluc3RlYWQgb2YgZ29pbmcgaW4gYSBjaXJjbGUsIHdlJ2xsIHByaW50IFtvYmplY3QgT2JqZWN0XVxuICAgICAgICAgIHJldHVybiAnJyArIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlLnB1c2godmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gRXJyb3Igb2JqZWN0IGludG8gYSBKU09OIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGVycm9ySlNPTihlcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlcnIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHJlc1trZXldID0gZXJyW2tleV07XG4gIH0sIGVycik7XG4gIHJldHVybiByZXM7XG59XG5cbkpTT05SZXBvcnRlci5kZXNjcmlwdGlvbiA9ICdzaW5nbGUgSlNPTiBvYmplY3QnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/reporters/json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/reporters/landing.js":
/*!*****************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/landing.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * @module Landing\n */\n/**\n * Module dependencies.\n */\n\nvar Base = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/mocha/lib/reporters/base.js\");\nvar inherits = (__webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\").inherits);\nvar constants = (__webpack_require__(/*! ../runner */ \"(ssr)/./node_modules/mocha/lib/runner.js\").constants);\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\nvar EVENT_TEST_END = constants.EVENT_TEST_END;\nvar STATE_FAILED = (__webpack_require__(/*! ../runnable */ \"(ssr)/./node_modules/mocha/lib/runnable.js\").constants).STATE_FAILED;\n\nvar cursor = Base.cursor;\nvar color = Base.color;\n\n/**\n * Expose `Landing`.\n */\n\nexports = module.exports = Landing;\n\n/**\n * Airplane color.\n */\n\nBase.colors.plane = 0;\n\n/**\n * Airplane crash color.\n */\n\nBase.colors['plane crash'] = 31;\n\n/**\n * Runway color.\n */\n\nBase.colors.runway = 90;\n\n/**\n * Constructs a new `Landing` reporter instance.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @param {Runner} runner - Instance triggers reporter actions.\n * @param {Object} [options] - runner options\n */\nfunction Landing(runner, options) {\n  Base.call(this, runner, options);\n\n  var self = this;\n  var width = (Base.window.width * 0.75) | 0;\n  var stream = process.stdout;\n\n  var plane = color('plane', '');\n  var crashed = -1;\n  var n = 0;\n  var total = 0;\n\n  function runway() {\n    var buf = Array(width).join('-');\n    return '  ' + color('runway', buf);\n  }\n\n  runner.on(EVENT_RUN_BEGIN, function () {\n    stream.write('\\n\\n\\n  ');\n    cursor.hide();\n  });\n\n  runner.on(EVENT_TEST_END, function (test) {\n    // check if the plane crashed\n    var col = crashed === -1 ? ((width * ++n) / ++total) | 0 : crashed;\n    // show the crash\n    if (test.state === STATE_FAILED) {\n      plane = color('plane crash', '');\n      crashed = col;\n    }\n\n    // render landing strip\n    stream.write('\\u001b[' + (width + 1) + 'D\\u001b[2A');\n    stream.write(runway());\n    stream.write('\\n  ');\n    stream.write(color('runway', Array(col).join('')));\n    stream.write(plane);\n    stream.write(color('runway', Array(width - col).join('') + '\\n'));\n    stream.write(runway());\n    stream.write('\\u001b[0m');\n  });\n\n  runner.once(EVENT_RUN_END, function () {\n    cursor.show();\n    process.stdout.write('\\n');\n    self.epilogue();\n  });\n\n  // if cursor is hidden when we ctrl-C, then it will remain hidden unless...\n  process.once('SIGINT', function () {\n    cursor.show();\n    process.nextTick(function () {\n      process.kill(process.pid, 'SIGINT');\n    });\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Landing, Base);\n\nLanding.description = 'Unicode landing strip';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9sYW5kaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxnRUFBUTtBQUMzQixlQUFlLHlGQUE0QjtBQUMzQyxnQkFBZ0IsNEZBQThCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnR0FBZ0M7O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9sYW5kaW5nLmpzP2RiZTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIExhbmRpbmdcbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL3J1bm5lcicpLmNvbnN0YW50cztcbnZhciBFVkVOVF9SVU5fQkVHSU4gPSBjb25zdGFudHMuRVZFTlRfUlVOX0JFR0lOO1xudmFyIEVWRU5UX1JVTl9FTkQgPSBjb25zdGFudHMuRVZFTlRfUlVOX0VORDtcbnZhciBFVkVOVF9URVNUX0VORCA9IGNvbnN0YW50cy5FVkVOVF9URVNUX0VORDtcbnZhciBTVEFURV9GQUlMRUQgPSByZXF1aXJlKCcuLi9ydW5uYWJsZScpLmNvbnN0YW50cy5TVEFURV9GQUlMRUQ7XG5cbnZhciBjdXJzb3IgPSBCYXNlLmN1cnNvcjtcbnZhciBjb2xvciA9IEJhc2UuY29sb3I7XG5cbi8qKlxuICogRXhwb3NlIGBMYW5kaW5nYC5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBMYW5kaW5nO1xuXG4vKipcbiAqIEFpcnBsYW5lIGNvbG9yLlxuICovXG5cbkJhc2UuY29sb3JzLnBsYW5lID0gMDtcblxuLyoqXG4gKiBBaXJwbGFuZSBjcmFzaCBjb2xvci5cbiAqL1xuXG5CYXNlLmNvbG9yc1sncGxhbmUgY3Jhc2gnXSA9IDMxO1xuXG4vKipcbiAqIFJ1bndheSBjb2xvci5cbiAqL1xuXG5CYXNlLmNvbG9ycy5ydW53YXkgPSA5MDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGBMYW5kaW5nYCByZXBvcnRlciBpbnN0YW5jZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyIC0gSW5zdGFuY2UgdHJpZ2dlcnMgcmVwb3J0ZXIgYWN0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBydW5uZXIgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBMYW5kaW5nKHJ1bm5lciwgb3B0aW9ucykge1xuICBCYXNlLmNhbGwodGhpcywgcnVubmVyLCBvcHRpb25zKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB3aWR0aCA9IChCYXNlLndpbmRvdy53aWR0aCAqIDAuNzUpIHwgMDtcbiAgdmFyIHN0cmVhbSA9IHByb2Nlc3Muc3Rkb3V0O1xuXG4gIHZhciBwbGFuZSA9IGNvbG9yKCdwbGFuZScsICfinIgnKTtcbiAgdmFyIGNyYXNoZWQgPSAtMTtcbiAgdmFyIG4gPSAwO1xuICB2YXIgdG90YWwgPSAwO1xuXG4gIGZ1bmN0aW9uIHJ1bndheSgpIHtcbiAgICB2YXIgYnVmID0gQXJyYXkod2lkdGgpLmpvaW4oJy0nKTtcbiAgICByZXR1cm4gJyAgJyArIGNvbG9yKCdydW53YXknLCBidWYpO1xuICB9XG5cbiAgcnVubmVyLm9uKEVWRU5UX1JVTl9CRUdJTiwgZnVuY3Rpb24gKCkge1xuICAgIHN0cmVhbS53cml0ZSgnXFxuXFxuXFxuICAnKTtcbiAgICBjdXJzb3IuaGlkZSgpO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9FTkQsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgLy8gY2hlY2sgaWYgdGhlIHBsYW5lIGNyYXNoZWRcbiAgICB2YXIgY29sID0gY3Jhc2hlZCA9PT0gLTEgPyAoKHdpZHRoICogKytuKSAvICsrdG90YWwpIHwgMCA6IGNyYXNoZWQ7XG4gICAgLy8gc2hvdyB0aGUgY3Jhc2hcbiAgICBpZiAodGVzdC5zdGF0ZSA9PT0gU1RBVEVfRkFJTEVEKSB7XG4gICAgICBwbGFuZSA9IGNvbG9yKCdwbGFuZSBjcmFzaCcsICfinIgnKTtcbiAgICAgIGNyYXNoZWQgPSBjb2w7XG4gICAgfVxuXG4gICAgLy8gcmVuZGVyIGxhbmRpbmcgc3RyaXBcbiAgICBzdHJlYW0ud3JpdGUoJ1xcdTAwMWJbJyArICh3aWR0aCArIDEpICsgJ0RcXHUwMDFiWzJBJyk7XG4gICAgc3RyZWFtLndyaXRlKHJ1bndheSgpKTtcbiAgICBzdHJlYW0ud3JpdGUoJ1xcbiAgJyk7XG4gICAgc3RyZWFtLndyaXRlKGNvbG9yKCdydW53YXknLCBBcnJheShjb2wpLmpvaW4oJ+KLhScpKSk7XG4gICAgc3RyZWFtLndyaXRlKHBsYW5lKTtcbiAgICBzdHJlYW0ud3JpdGUoY29sb3IoJ3J1bndheScsIEFycmF5KHdpZHRoIC0gY29sKS5qb2luKCfii4UnKSArICdcXG4nKSk7XG4gICAgc3RyZWFtLndyaXRlKHJ1bndheSgpKTtcbiAgICBzdHJlYW0ud3JpdGUoJ1xcdTAwMWJbMG0nKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uY2UoRVZFTlRfUlVOX0VORCwgZnVuY3Rpb24gKCkge1xuICAgIGN1cnNvci5zaG93KCk7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcbicpO1xuICAgIHNlbGYuZXBpbG9ndWUoKTtcbiAgfSk7XG5cbiAgLy8gaWYgY3Vyc29yIGlzIGhpZGRlbiB3aGVuIHdlIGN0cmwtQywgdGhlbiBpdCB3aWxsIHJlbWFpbiBoaWRkZW4gdW5sZXNzLi4uXG4gIHByb2Nlc3Mub25jZSgnU0lHSU5UJywgZnVuY3Rpb24gKCkge1xuICAgIGN1cnNvci5zaG93KCk7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLmtpbGwocHJvY2Vzcy5waWQsICdTSUdJTlQnKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKExhbmRpbmcsIEJhc2UpO1xuXG5MYW5kaW5nLmRlc2NyaXB0aW9uID0gJ1VuaWNvZGUgbGFuZGluZyBzdHJpcCc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/reporters/landing.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/reporters/list.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/list.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * @module List\n */\n/**\n * Module dependencies.\n */\n\nvar Base = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/mocha/lib/reporters/base.js\");\nvar inherits = (__webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\").inherits);\nvar constants = (__webpack_require__(/*! ../runner */ \"(ssr)/./node_modules/mocha/lib/runner.js\").constants);\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\nvar EVENT_TEST_BEGIN = constants.EVENT_TEST_BEGIN;\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\nvar EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;\nvar color = Base.color;\nvar cursor = Base.cursor;\n\n/**\n * Expose `List`.\n */\n\nexports = module.exports = List;\n\n/**\n * Constructs a new `List` reporter instance.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @param {Runner} runner - Instance triggers reporter actions.\n * @param {Object} [options] - runner options\n */\nfunction List(runner, options) {\n  Base.call(this, runner, options);\n\n  var self = this;\n  var n = 0;\n\n  runner.on(EVENT_RUN_BEGIN, function () {\n    Base.consoleLog();\n  });\n\n  runner.on(EVENT_TEST_BEGIN, function (test) {\n    process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '));\n  });\n\n  runner.on(EVENT_TEST_PENDING, function (test) {\n    var fmt = color('checkmark', '  -') + color('pending', ' %s');\n    Base.consoleLog(fmt, test.fullTitle());\n  });\n\n  runner.on(EVENT_TEST_PASS, function (test) {\n    var fmt =\n      color('checkmark', '  ' + Base.symbols.ok) +\n      color('pass', ' %s: ') +\n      color(test.speed, '%dms');\n    cursor.CR();\n    Base.consoleLog(fmt, test.fullTitle(), test.duration);\n  });\n\n  runner.on(EVENT_TEST_FAIL, function (test) {\n    cursor.CR();\n    Base.consoleLog(color('fail', '  %d) %s'), ++n, test.fullTitle());\n  });\n\n  runner.once(EVENT_RUN_END, self.epilogue.bind(self));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(List, Base);\n\nList.description = 'like \"spec\" reporter but flat';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9saXN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxnRUFBUTtBQUMzQixlQUFlLHlGQUE0QjtBQUMzQyxnQkFBZ0IsNEZBQThCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMvbGlzdC5qcz9mODY5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBMaXN0XG4gKi9cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9ydW5uZXInKS5jb25zdGFudHM7XG52YXIgRVZFTlRfUlVOX0JFR0lOID0gY29uc3RhbnRzLkVWRU5UX1JVTl9CRUdJTjtcbnZhciBFVkVOVF9SVU5fRU5EID0gY29uc3RhbnRzLkVWRU5UX1JVTl9FTkQ7XG52YXIgRVZFTlRfVEVTVF9CRUdJTiA9IGNvbnN0YW50cy5FVkVOVF9URVNUX0JFR0lOO1xudmFyIEVWRU5UX1RFU1RfRkFJTCA9IGNvbnN0YW50cy5FVkVOVF9URVNUX0ZBSUw7XG52YXIgRVZFTlRfVEVTVF9QQVNTID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfUEFTUztcbnZhciBFVkVOVF9URVNUX1BFTkRJTkcgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9QRU5ESU5HO1xudmFyIGNvbG9yID0gQmFzZS5jb2xvcjtcbnZhciBjdXJzb3IgPSBCYXNlLmN1cnNvcjtcblxuLyoqXG4gKiBFeHBvc2UgYExpc3RgLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IExpc3Q7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBgTGlzdGAgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lciAtIEluc3RhbmNlIHRyaWdnZXJzIHJlcG9ydGVyIGFjdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcnVubmVyIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gTGlzdChydW5uZXIsIG9wdGlvbnMpIHtcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lciwgb3B0aW9ucyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbiA9IDA7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1JVTl9CRUdJTiwgZnVuY3Rpb24gKCkge1xuICAgIEJhc2UuY29uc29sZUxvZygpO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9CRUdJTiwgZnVuY3Rpb24gKHRlc3QpIHtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShjb2xvcigncGFzcycsICcgICAgJyArIHRlc3QuZnVsbFRpdGxlKCkgKyAnOiAnKSk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BFTkRJTkcsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgdmFyIGZtdCA9IGNvbG9yKCdjaGVja21hcmsnLCAnICAtJykgKyBjb2xvcigncGVuZGluZycsICcgJXMnKTtcbiAgICBCYXNlLmNvbnNvbGVMb2coZm10LCB0ZXN0LmZ1bGxUaXRsZSgpKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfUEFTUywgZnVuY3Rpb24gKHRlc3QpIHtcbiAgICB2YXIgZm10ID1cbiAgICAgIGNvbG9yKCdjaGVja21hcmsnLCAnICAnICsgQmFzZS5zeW1ib2xzLm9rKSArXG4gICAgICBjb2xvcigncGFzcycsICcgJXM6ICcpICtcbiAgICAgIGNvbG9yKHRlc3Quc3BlZWQsICclZG1zJyk7XG4gICAgY3Vyc29yLkNSKCk7XG4gICAgQmFzZS5jb25zb2xlTG9nKGZtdCwgdGVzdC5mdWxsVGl0bGUoKSwgdGVzdC5kdXJhdGlvbik7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX0ZBSUwsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgY3Vyc29yLkNSKCk7XG4gICAgQmFzZS5jb25zb2xlTG9nKGNvbG9yKCdmYWlsJywgJyAgJWQpICVzJyksICsrbiwgdGVzdC5mdWxsVGl0bGUoKSk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbmNlKEVWRU5UX1JVTl9FTkQsIHNlbGYuZXBpbG9ndWUuYmluZChzZWxmKSk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKExpc3QsIEJhc2UpO1xuXG5MaXN0LmRlc2NyaXB0aW9uID0gJ2xpa2UgXCJzcGVjXCIgcmVwb3J0ZXIgYnV0IGZsYXQnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/reporters/list.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/reporters/markdown.js":
/*!******************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/markdown.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * @module Markdown\n */\n/**\n * Module dependencies.\n */\n\nvar Base = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/mocha/lib/reporters/base.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\");\nvar constants = (__webpack_require__(/*! ../runner */ \"(ssr)/./node_modules/mocha/lib/runner.js\").constants);\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\nvar EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;\nvar EVENT_SUITE_END = constants.EVENT_SUITE_END;\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\n\n/**\n * Constants\n */\n\nvar SUITE_PREFIX = '$';\n\n/**\n * Expose `Markdown`.\n */\n\nexports = module.exports = Markdown;\n\n/**\n * Constructs a new `Markdown` reporter instance.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @param {Runner} runner - Instance triggers reporter actions.\n * @param {Object} [options] - runner options\n */\nfunction Markdown(runner, options) {\n  Base.call(this, runner, options);\n\n  var level = 0;\n  var buf = '';\n\n  function title(str) {\n    return Array(level).join('#') + ' ' + str;\n  }\n\n  function mapTOC(suite, obj) {\n    var ret = obj;\n    var key = SUITE_PREFIX + suite.title;\n\n    obj = obj[key] = obj[key] || {suite};\n    suite.suites.forEach(function (suite) {\n      mapTOC(suite, obj);\n    });\n\n    return ret;\n  }\n\n  function stringifyTOC(obj, level) {\n    ++level;\n    var buf = '';\n    var link;\n    for (var key in obj) {\n      if (key === 'suite') {\n        continue;\n      }\n      if (key !== SUITE_PREFIX) {\n        link = ' - [' + key.substring(1) + ']';\n        link += '(#' + utils.slug(obj[key].suite.fullTitle()) + ')\\n';\n        buf += Array(level).join('  ') + link;\n      }\n      buf += stringifyTOC(obj[key], level);\n    }\n    return buf;\n  }\n\n  function generateTOC(suite) {\n    var obj = mapTOC(suite, {});\n    return stringifyTOC(obj, 0);\n  }\n\n  generateTOC(runner.suite);\n\n  runner.on(EVENT_SUITE_BEGIN, function (suite) {\n    ++level;\n    var slug = utils.slug(suite.fullTitle());\n    buf += '<a name=\"' + slug + '\"></a>' + '\\n';\n    buf += title(suite.title) + '\\n';\n  });\n\n  runner.on(EVENT_SUITE_END, function () {\n    --level;\n  });\n\n  runner.on(EVENT_TEST_PASS, function (test) {\n    var code = utils.clean(test.body);\n    buf += test.title + '.\\n';\n    buf += '\\n```js\\n';\n    buf += code + '\\n';\n    buf += '```\\n\\n';\n  });\n\n  runner.once(EVENT_RUN_END, function () {\n    process.stdout.write('# TOC\\n');\n    process.stdout.write(generateTOC(runner.suite));\n    process.stdout.write(buf);\n  });\n}\n\nMarkdown.description = 'GitHub Flavored Markdown';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9tYXJrZG93bi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsZ0VBQVE7QUFDM0IsWUFBWSxtQkFBTyxDQUFDLHlEQUFVO0FBQzlCLGdCQUFnQiw0RkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9tYXJrZG93bi5qcz8yOGExIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBNYXJrZG93blxuICovXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vcnVubmVyJykuY29uc3RhbnRzO1xudmFyIEVWRU5UX1JVTl9FTkQgPSBjb25zdGFudHMuRVZFTlRfUlVOX0VORDtcbnZhciBFVkVOVF9TVUlURV9CRUdJTiA9IGNvbnN0YW50cy5FVkVOVF9TVUlURV9CRUdJTjtcbnZhciBFVkVOVF9TVUlURV9FTkQgPSBjb25zdGFudHMuRVZFTlRfU1VJVEVfRU5EO1xudmFyIEVWRU5UX1RFU1RfUEFTUyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BBU1M7XG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxudmFyIFNVSVRFX1BSRUZJWCA9ICckJztcblxuLyoqXG4gKiBFeHBvc2UgYE1hcmtkb3duYC5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBNYXJrZG93bjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGBNYXJrZG93bmAgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lciAtIEluc3RhbmNlIHRyaWdnZXJzIHJlcG9ydGVyIGFjdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcnVubmVyIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gTWFya2Rvd24ocnVubmVyLCBvcHRpb25zKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIsIG9wdGlvbnMpO1xuXG4gIHZhciBsZXZlbCA9IDA7XG4gIHZhciBidWYgPSAnJztcblxuICBmdW5jdGlvbiB0aXRsZShzdHIpIHtcbiAgICByZXR1cm4gQXJyYXkobGV2ZWwpLmpvaW4oJyMnKSArICcgJyArIHN0cjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcFRPQyhzdWl0ZSwgb2JqKSB7XG4gICAgdmFyIHJldCA9IG9iajtcbiAgICB2YXIga2V5ID0gU1VJVEVfUFJFRklYICsgc3VpdGUudGl0bGU7XG5cbiAgICBvYmogPSBvYmpba2V5XSA9IG9ialtrZXldIHx8IHtzdWl0ZX07XG4gICAgc3VpdGUuc3VpdGVzLmZvckVhY2goZnVuY3Rpb24gKHN1aXRlKSB7XG4gICAgICBtYXBUT0Moc3VpdGUsIG9iaik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5VE9DKG9iaiwgbGV2ZWwpIHtcbiAgICArK2xldmVsO1xuICAgIHZhciBidWYgPSAnJztcbiAgICB2YXIgbGluaztcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoa2V5ID09PSAnc3VpdGUnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGtleSAhPT0gU1VJVEVfUFJFRklYKSB7XG4gICAgICAgIGxpbmsgPSAnIC0gWycgKyBrZXkuc3Vic3RyaW5nKDEpICsgJ10nO1xuICAgICAgICBsaW5rICs9ICcoIycgKyB1dGlscy5zbHVnKG9ialtrZXldLnN1aXRlLmZ1bGxUaXRsZSgpKSArICcpXFxuJztcbiAgICAgICAgYnVmICs9IEFycmF5KGxldmVsKS5qb2luKCcgICcpICsgbGluaztcbiAgICAgIH1cbiAgICAgIGJ1ZiArPSBzdHJpbmdpZnlUT0Mob2JqW2tleV0sIGxldmVsKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlVE9DKHN1aXRlKSB7XG4gICAgdmFyIG9iaiA9IG1hcFRPQyhzdWl0ZSwge30pO1xuICAgIHJldHVybiBzdHJpbmdpZnlUT0Mob2JqLCAwKTtcbiAgfVxuXG4gIGdlbmVyYXRlVE9DKHJ1bm5lci5zdWl0ZSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1NVSVRFX0JFR0lOLCBmdW5jdGlvbiAoc3VpdGUpIHtcbiAgICArK2xldmVsO1xuICAgIHZhciBzbHVnID0gdXRpbHMuc2x1ZyhzdWl0ZS5mdWxsVGl0bGUoKSk7XG4gICAgYnVmICs9ICc8YSBuYW1lPVwiJyArIHNsdWcgKyAnXCI+PC9hPicgKyAnXFxuJztcbiAgICBidWYgKz0gdGl0bGUoc3VpdGUudGl0bGUpICsgJ1xcbic7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9TVUlURV9FTkQsIGZ1bmN0aW9uICgpIHtcbiAgICAtLWxldmVsO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9QQVNTLCBmdW5jdGlvbiAodGVzdCkge1xuICAgIHZhciBjb2RlID0gdXRpbHMuY2xlYW4odGVzdC5ib2R5KTtcbiAgICBidWYgKz0gdGVzdC50aXRsZSArICcuXFxuJztcbiAgICBidWYgKz0gJ1xcbmBgYGpzXFxuJztcbiAgICBidWYgKz0gY29kZSArICdcXG4nO1xuICAgIGJ1ZiArPSAnYGBgXFxuXFxuJztcbiAgfSk7XG5cbiAgcnVubmVyLm9uY2UoRVZFTlRfUlVOX0VORCwgZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCcjIFRPQ1xcbicpO1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGdlbmVyYXRlVE9DKHJ1bm5lci5zdWl0ZSkpO1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGJ1Zik7XG4gIH0pO1xufVxuXG5NYXJrZG93bi5kZXNjcmlwdGlvbiA9ICdHaXRIdWIgRmxhdm9yZWQgTWFya2Rvd24nO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/reporters/markdown.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/reporters/min.js":
/*!*************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/min.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * @module Min\n */\n/**\n * Module dependencies.\n */\n\nvar Base = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/mocha/lib/reporters/base.js\");\nvar inherits = (__webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\").inherits);\nvar constants = (__webpack_require__(/*! ../runner */ \"(ssr)/./node_modules/mocha/lib/runner.js\").constants);\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\n\n/**\n * Expose `Min`.\n */\n\nexports = module.exports = Min;\n\n/**\n * Constructs a new `Min` reporter instance.\n *\n * @description\n * This minimal test reporter is best used with '--watch'.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @param {Runner} runner - Instance triggers reporter actions.\n * @param {Object} [options] - runner options\n */\nfunction Min(runner, options) {\n  Base.call(this, runner, options);\n\n  runner.on(EVENT_RUN_BEGIN, function () {\n    // clear screen\n    process.stdout.write('\\u001b[2J');\n    // set cursor position\n    process.stdout.write('\\u001b[1;3H');\n  });\n\n  runner.once(EVENT_RUN_END, this.epilogue.bind(this));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Min, Base);\n\nMin.description = 'essentially just a summary';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9taW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLGdFQUFRO0FBQzNCLGVBQWUseUZBQTRCO0FBQzNDLGdCQUFnQiw0RkFBOEI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMvbWluLmpzPzVlMTAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIE1pblxuICovXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWxzJykuaW5oZXJpdHM7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vcnVubmVyJykuY29uc3RhbnRzO1xudmFyIEVWRU5UX1JVTl9FTkQgPSBjb25zdGFudHMuRVZFTlRfUlVOX0VORDtcbnZhciBFVkVOVF9SVU5fQkVHSU4gPSBjb25zdGFudHMuRVZFTlRfUlVOX0JFR0lOO1xuXG4vKipcbiAqIEV4cG9zZSBgTWluYC5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBNaW47XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBgTWluYCByZXBvcnRlciBpbnN0YW5jZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgbWluaW1hbCB0ZXN0IHJlcG9ydGVyIGlzIGJlc3QgdXNlZCB3aXRoICctLXdhdGNoJy5cbiAqXG4gKiBAcHVibGljXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyIC0gSW5zdGFuY2UgdHJpZ2dlcnMgcmVwb3J0ZXIgYWN0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBydW5uZXIgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBNaW4ocnVubmVyLCBvcHRpb25zKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIsIG9wdGlvbnMpO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9SVU5fQkVHSU4sIGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjbGVhciBzY3JlZW5cbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFx1MDAxYlsySicpO1xuICAgIC8vIHNldCBjdXJzb3IgcG9zaXRpb25cbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFx1MDAxYlsxOzNIJyk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbmNlKEVWRU5UX1JVTl9FTkQsIHRoaXMuZXBpbG9ndWUuYmluZCh0aGlzKSk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKE1pbiwgQmFzZSk7XG5cbk1pbi5kZXNjcmlwdGlvbiA9ICdlc3NlbnRpYWxseSBqdXN0IGEgc3VtbWFyeSc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/reporters/min.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/reporters/nyan.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/nyan.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * @module Nyan\n */\n/**\n * Module dependencies.\n */\n\nvar Base = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/mocha/lib/reporters/base.js\");\nvar constants = (__webpack_require__(/*! ../runner */ \"(ssr)/./node_modules/mocha/lib/runner.js\").constants);\nvar inherits = (__webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\").inherits);\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\nvar EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\n\n/**\n * Expose `Dot`.\n */\n\nexports = module.exports = NyanCat;\n\n/**\n * Constructs a new `Nyan` reporter instance.\n *\n * @public\n * @class Nyan\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @param {Runner} runner - Instance triggers reporter actions.\n * @param {Object} [options] - runner options\n */\nfunction NyanCat(runner, options) {\n  Base.call(this, runner, options);\n\n  var self = this;\n  var width = (Base.window.width * 0.75) | 0;\n  var nyanCatWidth = (this.nyanCatWidth = 11);\n\n  this.colorIndex = 0;\n  this.numberOfLines = 4;\n  this.rainbowColors = self.generateColors();\n  this.scoreboardWidth = 5;\n  this.tick = 0;\n  this.trajectories = [[], [], [], []];\n  this.trajectoryWidthMax = width - nyanCatWidth;\n\n  runner.on(EVENT_RUN_BEGIN, function () {\n    Base.cursor.hide();\n    self.draw();\n  });\n\n  runner.on(EVENT_TEST_PENDING, function () {\n    self.draw();\n  });\n\n  runner.on(EVENT_TEST_PASS, function () {\n    self.draw();\n  });\n\n  runner.on(EVENT_TEST_FAIL, function () {\n    self.draw();\n  });\n\n  runner.once(EVENT_RUN_END, function () {\n    Base.cursor.show();\n    for (var i = 0; i < self.numberOfLines; i++) {\n      process.stdout.write('\\n');\n    }\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(NyanCat, Base);\n\n/**\n * Draw the nyan cat\n *\n * @private\n */\n\nNyanCat.prototype.draw = function () {\n  this.appendRainbow();\n  this.drawScoreboard();\n  this.drawRainbow();\n  this.drawNyanCat();\n  this.tick = !this.tick;\n};\n\n/**\n * Draw the \"scoreboard\" showing the number\n * of passes, failures and pending tests.\n *\n * @private\n */\n\nNyanCat.prototype.drawScoreboard = function () {\n  var stats = this.stats;\n\n  function draw(type, n) {\n    process.stdout.write(' ');\n    process.stdout.write(Base.color(type, n));\n    process.stdout.write('\\n');\n  }\n\n  draw('green', stats.passes);\n  draw('fail', stats.failures);\n  draw('pending', stats.pending);\n  process.stdout.write('\\n');\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Append the rainbow.\n *\n * @private\n */\n\nNyanCat.prototype.appendRainbow = function () {\n  var segment = this.tick ? '_' : '-';\n  var rainbowified = this.rainbowify(segment);\n\n  for (var index = 0; index < this.numberOfLines; index++) {\n    var trajectory = this.trajectories[index];\n    if (trajectory.length >= this.trajectoryWidthMax) {\n      trajectory.shift();\n    }\n    trajectory.push(rainbowified);\n  }\n};\n\n/**\n * Draw the rainbow.\n *\n * @private\n */\n\nNyanCat.prototype.drawRainbow = function () {\n  var self = this;\n\n  this.trajectories.forEach(function (line) {\n    process.stdout.write('\\u001b[' + self.scoreboardWidth + 'C');\n    process.stdout.write(line.join(''));\n    process.stdout.write('\\n');\n  });\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Draw the nyan cat\n *\n * @private\n */\nNyanCat.prototype.drawNyanCat = function () {\n  var self = this;\n  var startWidth = this.scoreboardWidth + this.trajectories[0].length;\n  var dist = '\\u001b[' + startWidth + 'C';\n  var padding = '';\n\n  process.stdout.write(dist);\n  process.stdout.write('_,------,');\n  process.stdout.write('\\n');\n\n  process.stdout.write(dist);\n  padding = self.tick ? '  ' : '   ';\n  process.stdout.write('_|' + padding + '/\\\\_/\\\\ ');\n  process.stdout.write('\\n');\n\n  process.stdout.write(dist);\n  padding = self.tick ? '_' : '__';\n  var tail = self.tick ? '~' : '^';\n  process.stdout.write(tail + '|' + padding + this.face() + ' ');\n  process.stdout.write('\\n');\n\n  process.stdout.write(dist);\n  padding = self.tick ? ' ' : '  ';\n  process.stdout.write(padding + '\"\"  \"\" ');\n  process.stdout.write('\\n');\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Draw nyan cat face.\n *\n * @private\n * @return {string}\n */\n\nNyanCat.prototype.face = function () {\n  var stats = this.stats;\n  if (stats.failures) {\n    return '( x .x)';\n  } else if (stats.pending) {\n    return '( o .o)';\n  } else if (stats.passes) {\n    return '( ^ .^)';\n  }\n  return '( - .-)';\n};\n\n/**\n * Move cursor up `n`.\n *\n * @private\n * @param {number} n\n */\n\nNyanCat.prototype.cursorUp = function (n) {\n  process.stdout.write('\\u001b[' + n + 'A');\n};\n\n/**\n * Move cursor down `n`.\n *\n * @private\n * @param {number} n\n */\n\nNyanCat.prototype.cursorDown = function (n) {\n  process.stdout.write('\\u001b[' + n + 'B');\n};\n\n/**\n * Generate rainbow colors.\n *\n * @private\n * @return {Array}\n */\nNyanCat.prototype.generateColors = function () {\n  var colors = [];\n\n  for (var i = 0; i < 6 * 7; i++) {\n    var pi3 = Math.floor(Math.PI / 3);\n    var n = i * (1.0 / 6);\n    var r = Math.floor(3 * Math.sin(n) + 3);\n    var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);\n    var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);\n    colors.push(36 * r + 6 * g + b + 16);\n  }\n\n  return colors;\n};\n\n/**\n * Apply rainbow to the given `str`.\n *\n * @private\n * @param {string} str\n * @return {string}\n */\nNyanCat.prototype.rainbowify = function (str) {\n  if (!Base.useColors) {\n    return str;\n  }\n  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];\n  this.colorIndex += 1;\n  return '\\u001b[38;5;' + color + 'm' + str + '\\u001b[0m';\n};\n\nNyanCat.description = '\"nyan cat\"';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9ueWFuLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxnRUFBUTtBQUMzQixnQkFBZ0IsNEZBQThCO0FBQzlDLGVBQWUseUZBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsRUFBRTtBQUN0Qjs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9ueWFuLmpzP2ZkMjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIE55YW5cbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vcnVubmVyJykuY29uc3RhbnRzO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcbnZhciBFVkVOVF9SVU5fQkVHSU4gPSBjb25zdGFudHMuRVZFTlRfUlVOX0JFR0lOO1xudmFyIEVWRU5UX1RFU1RfUEVORElORyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BFTkRJTkc7XG52YXIgRVZFTlRfVEVTVF9QQVNTID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfUEFTUztcbnZhciBFVkVOVF9SVU5fRU5EID0gY29uc3RhbnRzLkVWRU5UX1JVTl9FTkQ7XG52YXIgRVZFTlRfVEVTVF9GQUlMID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfRkFJTDtcblxuLyoqXG4gKiBFeHBvc2UgYERvdGAuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTnlhbkNhdDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGBOeWFuYCByZXBvcnRlciBpbnN0YW5jZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAY2xhc3MgTnlhblxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXIgLSBJbnN0YW5jZSB0cmlnZ2VycyByZXBvcnRlciBhY3Rpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHJ1bm5lciBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIE55YW5DYXQocnVubmVyLCBvcHRpb25zKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIsIG9wdGlvbnMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHdpZHRoID0gKEJhc2Uud2luZG93LndpZHRoICogMC43NSkgfCAwO1xuICB2YXIgbnlhbkNhdFdpZHRoID0gKHRoaXMubnlhbkNhdFdpZHRoID0gMTEpO1xuXG4gIHRoaXMuY29sb3JJbmRleCA9IDA7XG4gIHRoaXMubnVtYmVyT2ZMaW5lcyA9IDQ7XG4gIHRoaXMucmFpbmJvd0NvbG9ycyA9IHNlbGYuZ2VuZXJhdGVDb2xvcnMoKTtcbiAgdGhpcy5zY29yZWJvYXJkV2lkdGggPSA1O1xuICB0aGlzLnRpY2sgPSAwO1xuICB0aGlzLnRyYWplY3RvcmllcyA9IFtbXSwgW10sIFtdLCBbXV07XG4gIHRoaXMudHJhamVjdG9yeVdpZHRoTWF4ID0gd2lkdGggLSBueWFuQ2F0V2lkdGg7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1JVTl9CRUdJTiwgZnVuY3Rpb24gKCkge1xuICAgIEJhc2UuY3Vyc29yLmhpZGUoKTtcbiAgICBzZWxmLmRyYXcoKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfUEVORElORywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZHJhdygpO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9QQVNTLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5kcmF3KCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX0ZBSUwsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmRyYXcoKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uY2UoRVZFTlRfUlVOX0VORCwgZnVuY3Rpb24gKCkge1xuICAgIEJhc2UuY3Vyc29yLnNob3coKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubnVtYmVyT2ZMaW5lczsgaSsrKSB7XG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxuJyk7XG4gICAgfVxuICAgIHNlbGYuZXBpbG9ndWUoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKE55YW5DYXQsIEJhc2UpO1xuXG4vKipcbiAqIERyYXcgdGhlIG55YW4gY2F0XG4gKlxuICogQHByaXZhdGVcbiAqL1xuXG5OeWFuQ2F0LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmFwcGVuZFJhaW5ib3coKTtcbiAgdGhpcy5kcmF3U2NvcmVib2FyZCgpO1xuICB0aGlzLmRyYXdSYWluYm93KCk7XG4gIHRoaXMuZHJhd055YW5DYXQoKTtcbiAgdGhpcy50aWNrID0gIXRoaXMudGljaztcbn07XG5cbi8qKlxuICogRHJhdyB0aGUgXCJzY29yZWJvYXJkXCIgc2hvd2luZyB0aGUgbnVtYmVyXG4gKiBvZiBwYXNzZXMsIGZhaWx1cmVzIGFuZCBwZW5kaW5nIHRlc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxuTnlhbkNhdC5wcm90b3R5cGUuZHJhd1Njb3JlYm9hcmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XG5cbiAgZnVuY3Rpb24gZHJhdyh0eXBlLCBuKSB7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJyAnKTtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShCYXNlLmNvbG9yKHR5cGUsIG4pKTtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxuJyk7XG4gIH1cblxuICBkcmF3KCdncmVlbicsIHN0YXRzLnBhc3Nlcyk7XG4gIGRyYXcoJ2ZhaWwnLCBzdGF0cy5mYWlsdXJlcyk7XG4gIGRyYXcoJ3BlbmRpbmcnLCBzdGF0cy5wZW5kaW5nKTtcbiAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcbicpO1xuXG4gIHRoaXMuY3Vyc29yVXAodGhpcy5udW1iZXJPZkxpbmVzKTtcbn07XG5cbi8qKlxuICogQXBwZW5kIHRoZSByYWluYm93LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxuTnlhbkNhdC5wcm90b3R5cGUuYXBwZW5kUmFpbmJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlZ21lbnQgPSB0aGlzLnRpY2sgPyAnXycgOiAnLSc7XG4gIHZhciByYWluYm93aWZpZWQgPSB0aGlzLnJhaW5ib3dpZnkoc2VnbWVudCk7XG5cbiAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMubnVtYmVyT2ZMaW5lczsgaW5kZXgrKykge1xuICAgIHZhciB0cmFqZWN0b3J5ID0gdGhpcy50cmFqZWN0b3JpZXNbaW5kZXhdO1xuICAgIGlmICh0cmFqZWN0b3J5Lmxlbmd0aCA+PSB0aGlzLnRyYWplY3RvcnlXaWR0aE1heCkge1xuICAgICAgdHJhamVjdG9yeS5zaGlmdCgpO1xuICAgIH1cbiAgICB0cmFqZWN0b3J5LnB1c2gocmFpbmJvd2lmaWVkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEcmF3IHRoZSByYWluYm93LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxuTnlhbkNhdC5wcm90b3R5cGUuZHJhd1JhaW5ib3cgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLnRyYWplY3Rvcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcdTAwMWJbJyArIHNlbGYuc2NvcmVib2FyZFdpZHRoICsgJ0MnKTtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShsaW5lLmpvaW4oJycpKTtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxuJyk7XG4gIH0pO1xuXG4gIHRoaXMuY3Vyc29yVXAodGhpcy5udW1iZXJPZkxpbmVzKTtcbn07XG5cbi8qKlxuICogRHJhdyB0aGUgbnlhbiBjYXRcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5OeWFuQ2F0LnByb3RvdHlwZS5kcmF3TnlhbkNhdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc3RhcnRXaWR0aCA9IHRoaXMuc2NvcmVib2FyZFdpZHRoICsgdGhpcy50cmFqZWN0b3JpZXNbMF0ubGVuZ3RoO1xuICB2YXIgZGlzdCA9ICdcXHUwMDFiWycgKyBzdGFydFdpZHRoICsgJ0MnO1xuICB2YXIgcGFkZGluZyA9ICcnO1xuXG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGRpc3QpO1xuICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXywtLS0tLS0sJyk7XG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXG4nKTtcblxuICBwcm9jZXNzLnN0ZG91dC53cml0ZShkaXN0KTtcbiAgcGFkZGluZyA9IHNlbGYudGljayA/ICcgICcgOiAnICAgJztcbiAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ198JyArIHBhZGRpbmcgKyAnL1xcXFxfL1xcXFwgJyk7XG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXG4nKTtcblxuICBwcm9jZXNzLnN0ZG91dC53cml0ZShkaXN0KTtcbiAgcGFkZGluZyA9IHNlbGYudGljayA/ICdfJyA6ICdfXyc7XG4gIHZhciB0YWlsID0gc2VsZi50aWNrID8gJ34nIDogJ14nO1xuICBwcm9jZXNzLnN0ZG91dC53cml0ZSh0YWlsICsgJ3wnICsgcGFkZGluZyArIHRoaXMuZmFjZSgpICsgJyAnKTtcbiAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcbicpO1xuXG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGRpc3QpO1xuICBwYWRkaW5nID0gc2VsZi50aWNrID8gJyAnIDogJyAgJztcbiAgcHJvY2Vzcy5zdGRvdXQud3JpdGUocGFkZGluZyArICdcIlwiICBcIlwiICcpO1xuICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxuJyk7XG5cbiAgdGhpcy5jdXJzb3JVcCh0aGlzLm51bWJlck9mTGluZXMpO1xufTtcblxuLyoqXG4gKiBEcmF3IG55YW4gY2F0IGZhY2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5OeWFuQ2F0LnByb3RvdHlwZS5mYWNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICBpZiAoc3RhdHMuZmFpbHVyZXMpIHtcbiAgICByZXR1cm4gJyggeCAueCknO1xuICB9IGVsc2UgaWYgKHN0YXRzLnBlbmRpbmcpIHtcbiAgICByZXR1cm4gJyggbyAubyknO1xuICB9IGVsc2UgaWYgKHN0YXRzLnBhc3Nlcykge1xuICAgIHJldHVybiAnKCBeIC5eKSc7XG4gIH1cbiAgcmV0dXJuICcoIC0gLi0pJztcbn07XG5cbi8qKlxuICogTW92ZSBjdXJzb3IgdXAgYG5gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gblxuICovXG5cbk55YW5DYXQucHJvdG90eXBlLmN1cnNvclVwID0gZnVuY3Rpb24gKG4pIHtcbiAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcdTAwMWJbJyArIG4gKyAnQScpO1xufTtcblxuLyoqXG4gKiBNb3ZlIGN1cnNvciBkb3duIGBuYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG5cbiAqL1xuXG5OeWFuQ2F0LnByb3RvdHlwZS5jdXJzb3JEb3duID0gZnVuY3Rpb24gKG4pIHtcbiAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcdTAwMWJbJyArIG4gKyAnQicpO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSByYWluYm93IGNvbG9ycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbk55YW5DYXQucHJvdG90eXBlLmdlbmVyYXRlQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY29sb3JzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA2ICogNzsgaSsrKSB7XG4gICAgdmFyIHBpMyA9IE1hdGguZmxvb3IoTWF0aC5QSSAvIDMpO1xuICAgIHZhciBuID0gaSAqICgxLjAgLyA2KTtcbiAgICB2YXIgciA9IE1hdGguZmxvb3IoMyAqIE1hdGguc2luKG4pICsgMyk7XG4gICAgdmFyIGcgPSBNYXRoLmZsb29yKDMgKiBNYXRoLnNpbihuICsgMiAqIHBpMykgKyAzKTtcbiAgICB2YXIgYiA9IE1hdGguZmxvb3IoMyAqIE1hdGguc2luKG4gKyA0ICogcGkzKSArIDMpO1xuICAgIGNvbG9ycy5wdXNoKDM2ICogciArIDYgKiBnICsgYiArIDE2KTtcbiAgfVxuXG4gIHJldHVybiBjb2xvcnM7XG59O1xuXG4vKipcbiAqIEFwcGx5IHJhaW5ib3cgdG8gdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbk55YW5DYXQucHJvdG90eXBlLnJhaW5ib3dpZnkgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIGlmICghQmFzZS51c2VDb2xvcnMpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIHZhciBjb2xvciA9IHRoaXMucmFpbmJvd0NvbG9yc1t0aGlzLmNvbG9ySW5kZXggJSB0aGlzLnJhaW5ib3dDb2xvcnMubGVuZ3RoXTtcbiAgdGhpcy5jb2xvckluZGV4ICs9IDE7XG4gIHJldHVybiAnXFx1MDAxYlszODs1OycgKyBjb2xvciArICdtJyArIHN0ciArICdcXHUwMDFiWzBtJztcbn07XG5cbk55YW5DYXQuZGVzY3JpcHRpb24gPSAnXCJueWFuIGNhdFwiJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/reporters/nyan.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/reporters/progress.js":
/*!******************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/progress.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * @module Progress\n */\n/**\n * Module dependencies.\n */\n\nvar Base = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/mocha/lib/reporters/base.js\");\nvar constants = (__webpack_require__(/*! ../runner */ \"(ssr)/./node_modules/mocha/lib/runner.js\").constants);\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\nvar EVENT_TEST_END = constants.EVENT_TEST_END;\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\nvar inherits = (__webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\").inherits);\nvar color = Base.color;\nvar cursor = Base.cursor;\n\n/**\n * Expose `Progress`.\n */\n\nexports = module.exports = Progress;\n\n/**\n * General progress bar color.\n */\n\nBase.colors.progress = 90;\n\n/**\n * Constructs a new `Progress` reporter instance.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @param {Runner} runner - Instance triggers reporter actions.\n * @param {Object} [options] - runner options\n */\nfunction Progress(runner, options) {\n  Base.call(this, runner, options);\n\n  var self = this;\n  var width = (Base.window.width * 0.5) | 0;\n  var total = runner.total;\n  var complete = 0;\n  var lastN = -1;\n\n  // default chars\n  options = options || {};\n  var reporterOptions = options.reporterOptions || {};\n\n  options.open = reporterOptions.open || '[';\n  options.complete = reporterOptions.complete || '';\n  options.incomplete = reporterOptions.incomplete || Base.symbols.dot;\n  options.close = reporterOptions.close || ']';\n  options.verbose = reporterOptions.verbose || false;\n\n  // tests started\n  runner.on(EVENT_RUN_BEGIN, function () {\n    process.stdout.write('\\n');\n    cursor.hide();\n  });\n\n  // tests complete\n  runner.on(EVENT_TEST_END, function () {\n    complete++;\n\n    var percent = complete / total;\n    var n = (width * percent) | 0;\n    var i = width - n;\n\n    if (n === lastN && !options.verbose) {\n      // Don't re-render the line if it hasn't changed\n      return;\n    }\n    lastN = n;\n\n    cursor.CR();\n    process.stdout.write('\\u001b[J');\n    process.stdout.write(color('progress', '  ' + options.open));\n    process.stdout.write(Array(n).join(options.complete));\n    process.stdout.write(Array(i).join(options.incomplete));\n    process.stdout.write(color('progress', options.close));\n    if (options.verbose) {\n      process.stdout.write(color('progress', ' ' + complete + ' of ' + total));\n    }\n  });\n\n  // tests are complete, output some stats\n  // and the failures if any\n  runner.once(EVENT_RUN_END, function () {\n    cursor.show();\n    process.stdout.write('\\n');\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Progress, Base);\n\nProgress.description = 'a progress bar';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9wcm9ncmVzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsZ0VBQVE7QUFDM0IsZ0JBQWdCLDRGQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxlQUFlLHlGQUE0QjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMvcHJvZ3Jlc3MuanM/NzczZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBtb2R1bGUgUHJvZ3Jlc3NcbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vcnVubmVyJykuY29uc3RhbnRzO1xudmFyIEVWRU5UX1JVTl9CRUdJTiA9IGNvbnN0YW50cy5FVkVOVF9SVU5fQkVHSU47XG52YXIgRVZFTlRfVEVTVF9FTkQgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9FTkQ7XG52YXIgRVZFTlRfUlVOX0VORCA9IGNvbnN0YW50cy5FVkVOVF9SVU5fRU5EO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcbnZhciBjb2xvciA9IEJhc2UuY29sb3I7XG52YXIgY3Vyc29yID0gQmFzZS5jdXJzb3I7XG5cbi8qKlxuICogRXhwb3NlIGBQcm9ncmVzc2AuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gUHJvZ3Jlc3M7XG5cbi8qKlxuICogR2VuZXJhbCBwcm9ncmVzcyBiYXIgY29sb3IuXG4gKi9cblxuQmFzZS5jb2xvcnMucHJvZ3Jlc3MgPSA5MDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGBQcm9ncmVzc2AgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lciAtIEluc3RhbmNlIHRyaWdnZXJzIHJlcG9ydGVyIGFjdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcnVubmVyIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUHJvZ3Jlc3MocnVubmVyLCBvcHRpb25zKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIsIG9wdGlvbnMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHdpZHRoID0gKEJhc2Uud2luZG93LndpZHRoICogMC41KSB8IDA7XG4gIHZhciB0b3RhbCA9IHJ1bm5lci50b3RhbDtcbiAgdmFyIGNvbXBsZXRlID0gMDtcbiAgdmFyIGxhc3ROID0gLTE7XG5cbiAgLy8gZGVmYXVsdCBjaGFyc1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHJlcG9ydGVyT3B0aW9ucyA9IG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zIHx8IHt9O1xuXG4gIG9wdGlvbnMub3BlbiA9IHJlcG9ydGVyT3B0aW9ucy5vcGVuIHx8ICdbJztcbiAgb3B0aW9ucy5jb21wbGV0ZSA9IHJlcG9ydGVyT3B0aW9ucy5jb21wbGV0ZSB8fCAn4pasJztcbiAgb3B0aW9ucy5pbmNvbXBsZXRlID0gcmVwb3J0ZXJPcHRpb25zLmluY29tcGxldGUgfHwgQmFzZS5zeW1ib2xzLmRvdDtcbiAgb3B0aW9ucy5jbG9zZSA9IHJlcG9ydGVyT3B0aW9ucy5jbG9zZSB8fCAnXSc7XG4gIG9wdGlvbnMudmVyYm9zZSA9IHJlcG9ydGVyT3B0aW9ucy52ZXJib3NlIHx8IGZhbHNlO1xuXG4gIC8vIHRlc3RzIHN0YXJ0ZWRcbiAgcnVubmVyLm9uKEVWRU5UX1JVTl9CRUdJTiwgZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXG4nKTtcbiAgICBjdXJzb3IuaGlkZSgpO1xuICB9KTtcblxuICAvLyB0ZXN0cyBjb21wbGV0ZVxuICBydW5uZXIub24oRVZFTlRfVEVTVF9FTkQsIGZ1bmN0aW9uICgpIHtcbiAgICBjb21wbGV0ZSsrO1xuXG4gICAgdmFyIHBlcmNlbnQgPSBjb21wbGV0ZSAvIHRvdGFsO1xuICAgIHZhciBuID0gKHdpZHRoICogcGVyY2VudCkgfCAwO1xuICAgIHZhciBpID0gd2lkdGggLSBuO1xuXG4gICAgaWYgKG4gPT09IGxhc3ROICYmICFvcHRpb25zLnZlcmJvc2UpIHtcbiAgICAgIC8vIERvbid0IHJlLXJlbmRlciB0aGUgbGluZSBpZiBpdCBoYXNuJ3QgY2hhbmdlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsYXN0TiA9IG47XG5cbiAgICBjdXJzb3IuQ1IoKTtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFx1MDAxYltKJyk7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3Byb2dyZXNzJywgJyAgJyArIG9wdGlvbnMub3BlbikpO1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKEFycmF5KG4pLmpvaW4ob3B0aW9ucy5jb21wbGV0ZSkpO1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKEFycmF5KGkpLmpvaW4ob3B0aW9ucy5pbmNvbXBsZXRlKSk7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3Byb2dyZXNzJywgb3B0aW9ucy5jbG9zZSkpO1xuICAgIGlmIChvcHRpb25zLnZlcmJvc2UpIHtcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdwcm9ncmVzcycsICcgJyArIGNvbXBsZXRlICsgJyBvZiAnICsgdG90YWwpKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHRlc3RzIGFyZSBjb21wbGV0ZSwgb3V0cHV0IHNvbWUgc3RhdHNcbiAgLy8gYW5kIHRoZSBmYWlsdXJlcyBpZiBhbnlcbiAgcnVubmVyLm9uY2UoRVZFTlRfUlVOX0VORCwgZnVuY3Rpb24gKCkge1xuICAgIGN1cnNvci5zaG93KCk7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcbicpO1xuICAgIHNlbGYuZXBpbG9ndWUoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKFByb2dyZXNzLCBCYXNlKTtcblxuUHJvZ3Jlc3MuZGVzY3JpcHRpb24gPSAnYSBwcm9ncmVzcyBiYXInO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/reporters/progress.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/reporters/spec.js":
/*!**************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/spec.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * @module Spec\n */\n/**\n * Module dependencies.\n */\n\nvar Base = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/mocha/lib/reporters/base.js\");\nvar constants = (__webpack_require__(/*! ../runner */ \"(ssr)/./node_modules/mocha/lib/runner.js\").constants);\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\nvar EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;\nvar EVENT_SUITE_END = constants.EVENT_SUITE_END;\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\nvar EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;\nvar inherits = (__webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\").inherits);\nvar color = Base.color;\n\n/**\n * Expose `Spec`.\n */\n\nexports = module.exports = Spec;\n\n/**\n * Constructs a new `Spec` reporter instance.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @param {Runner} runner - Instance triggers reporter actions.\n * @param {Object} [options] - runner options\n */\nfunction Spec(runner, options) {\n  Base.call(this, runner, options);\n\n  var self = this;\n  var indents = 0;\n  var n = 0;\n\n  function indent() {\n    return Array(indents).join('  ');\n  }\n\n  runner.on(EVENT_RUN_BEGIN, function () {\n    Base.consoleLog();\n  });\n\n  runner.on(EVENT_SUITE_BEGIN, function (suite) {\n    ++indents;\n    Base.consoleLog(color('suite', '%s%s'), indent(), suite.title);\n  });\n\n  runner.on(EVENT_SUITE_END, function () {\n    --indents;\n    if (indents === 1) {\n      Base.consoleLog();\n    }\n  });\n\n  runner.on(EVENT_TEST_PENDING, function (test) {\n    var fmt = indent() + color('pending', '  - %s');\n    Base.consoleLog(fmt, test.title);\n  });\n\n  runner.on(EVENT_TEST_PASS, function (test) {\n    var fmt;\n    if (test.speed === 'fast') {\n      fmt =\n        indent() +\n        color('checkmark', '  ' + Base.symbols.ok) +\n        color('pass', ' %s');\n      Base.consoleLog(fmt, test.title);\n    } else {\n      fmt =\n        indent() +\n        color('checkmark', '  ' + Base.symbols.ok) +\n        color('pass', ' %s') +\n        color(test.speed, ' (%dms)');\n      Base.consoleLog(fmt, test.title, test.duration);\n    }\n  });\n\n  runner.on(EVENT_TEST_FAIL, function (test) {\n    Base.consoleLog(indent() + color('fail', '  %d) %s'), ++n, test.title);\n  });\n\n  runner.once(EVENT_RUN_END, self.epilogue.bind(self));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Spec, Base);\n\nSpec.description = 'hierarchical & verbose [default]';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9zcGVjLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxnRUFBUTtBQUMzQixnQkFBZ0IsNEZBQThCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5RkFBNEI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9zcGVjLmpzP2Q4YjgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIFNwZWNcbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vcnVubmVyJykuY29uc3RhbnRzO1xudmFyIEVWRU5UX1JVTl9CRUdJTiA9IGNvbnN0YW50cy5FVkVOVF9SVU5fQkVHSU47XG52YXIgRVZFTlRfUlVOX0VORCA9IGNvbnN0YW50cy5FVkVOVF9SVU5fRU5EO1xudmFyIEVWRU5UX1NVSVRFX0JFR0lOID0gY29uc3RhbnRzLkVWRU5UX1NVSVRFX0JFR0lOO1xudmFyIEVWRU5UX1NVSVRFX0VORCA9IGNvbnN0YW50cy5FVkVOVF9TVUlURV9FTkQ7XG52YXIgRVZFTlRfVEVTVF9GQUlMID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfRkFJTDtcbnZhciBFVkVOVF9URVNUX1BBU1MgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9QQVNTO1xudmFyIEVWRU5UX1RFU1RfUEVORElORyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BFTkRJTkc7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xudmFyIGNvbG9yID0gQmFzZS5jb2xvcjtcblxuLyoqXG4gKiBFeHBvc2UgYFNwZWNgLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFNwZWM7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBgU3BlY2AgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lciAtIEluc3RhbmNlIHRyaWdnZXJzIHJlcG9ydGVyIGFjdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcnVubmVyIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gU3BlYyhydW5uZXIsIG9wdGlvbnMpIHtcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lciwgb3B0aW9ucyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgaW5kZW50cyA9IDA7XG4gIHZhciBuID0gMDtcblxuICBmdW5jdGlvbiBpbmRlbnQoKSB7XG4gICAgcmV0dXJuIEFycmF5KGluZGVudHMpLmpvaW4oJyAgJyk7XG4gIH1cblxuICBydW5uZXIub24oRVZFTlRfUlVOX0JFR0lOLCBmdW5jdGlvbiAoKSB7XG4gICAgQmFzZS5jb25zb2xlTG9nKCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9TVUlURV9CRUdJTiwgZnVuY3Rpb24gKHN1aXRlKSB7XG4gICAgKytpbmRlbnRzO1xuICAgIEJhc2UuY29uc29sZUxvZyhjb2xvcignc3VpdGUnLCAnJXMlcycpLCBpbmRlbnQoKSwgc3VpdGUudGl0bGUpO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfU1VJVEVfRU5ELCBmdW5jdGlvbiAoKSB7XG4gICAgLS1pbmRlbnRzO1xuICAgIGlmIChpbmRlbnRzID09PSAxKSB7XG4gICAgICBCYXNlLmNvbnNvbGVMb2coKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BFTkRJTkcsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgdmFyIGZtdCA9IGluZGVudCgpICsgY29sb3IoJ3BlbmRpbmcnLCAnICAtICVzJyk7XG4gICAgQmFzZS5jb25zb2xlTG9nKGZtdCwgdGVzdC50aXRsZSk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BBU1MsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgdmFyIGZtdDtcbiAgICBpZiAodGVzdC5zcGVlZCA9PT0gJ2Zhc3QnKSB7XG4gICAgICBmbXQgPVxuICAgICAgICBpbmRlbnQoKSArXG4gICAgICAgIGNvbG9yKCdjaGVja21hcmsnLCAnICAnICsgQmFzZS5zeW1ib2xzLm9rKSArXG4gICAgICAgIGNvbG9yKCdwYXNzJywgJyAlcycpO1xuICAgICAgQmFzZS5jb25zb2xlTG9nKGZtdCwgdGVzdC50aXRsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZtdCA9XG4gICAgICAgIGluZGVudCgpICtcbiAgICAgICAgY29sb3IoJ2NoZWNrbWFyaycsICcgICcgKyBCYXNlLnN5bWJvbHMub2spICtcbiAgICAgICAgY29sb3IoJ3Bhc3MnLCAnICVzJykgK1xuICAgICAgICBjb2xvcih0ZXN0LnNwZWVkLCAnICglZG1zKScpO1xuICAgICAgQmFzZS5jb25zb2xlTG9nKGZtdCwgdGVzdC50aXRsZSwgdGVzdC5kdXJhdGlvbik7XG4gICAgfVxuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9GQUlMLCBmdW5jdGlvbiAodGVzdCkge1xuICAgIEJhc2UuY29uc29sZUxvZyhpbmRlbnQoKSArIGNvbG9yKCdmYWlsJywgJyAgJWQpICVzJyksICsrbiwgdGVzdC50aXRsZSk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbmNlKEVWRU5UX1JVTl9FTkQsIHNlbGYuZXBpbG9ndWUuYmluZChzZWxmKSk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKFNwZWMsIEJhc2UpO1xuXG5TcGVjLmRlc2NyaXB0aW9uID0gJ2hpZXJhcmNoaWNhbCAmIHZlcmJvc2UgW2RlZmF1bHRdJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/reporters/spec.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/reporters/tap.js":
/*!*************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/tap.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * @module TAP\n */\n/**\n * Module dependencies.\n */\n\nvar util = __webpack_require__(/*! util */ \"util\");\nvar Base = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/mocha/lib/reporters/base.js\");\nvar constants = (__webpack_require__(/*! ../runner */ \"(ssr)/./node_modules/mocha/lib/runner.js\").constants);\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\nvar EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;\nvar EVENT_TEST_END = constants.EVENT_TEST_END;\nvar inherits = (__webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\").inherits);\nvar sprintf = util.format;\n\n/**\n * Expose `TAP`.\n */\n\nexports = module.exports = TAP;\n\n/**\n * Constructs a new `TAP` reporter instance.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @param {Runner} runner - Instance triggers reporter actions.\n * @param {Object} [options] - runner options\n */\nfunction TAP(runner, options) {\n  Base.call(this, runner, options);\n\n  var self = this;\n  var n = 1;\n\n  var tapVersion = '12';\n  if (options && options.reporterOptions) {\n    if (options.reporterOptions.tapVersion) {\n      tapVersion = options.reporterOptions.tapVersion.toString();\n    }\n  }\n\n  this._producer = createProducer(tapVersion);\n\n  runner.once(EVENT_RUN_BEGIN, function () {\n    self._producer.writeVersion();\n  });\n\n  runner.on(EVENT_TEST_END, function () {\n    ++n;\n  });\n\n  runner.on(EVENT_TEST_PENDING, function (test) {\n    self._producer.writePending(n, test);\n  });\n\n  runner.on(EVENT_TEST_PASS, function (test) {\n    self._producer.writePass(n, test);\n  });\n\n  runner.on(EVENT_TEST_FAIL, function (test, err) {\n    self._producer.writeFail(n, test, err);\n  });\n\n  runner.once(EVENT_RUN_END, function () {\n    self._producer.writeEpilogue(runner.stats);\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(TAP, Base);\n\n/**\n * Returns a TAP-safe title of `test`.\n *\n * @private\n * @param {Test} test - Test instance.\n * @return {String} title with any hash character removed\n */\nfunction title(test) {\n  return test.fullTitle().replace(/#/g, '');\n}\n\n/**\n * Writes newline-terminated formatted string to reporter output stream.\n *\n * @private\n * @param {string} format - `printf`-like format string\n * @param {...*} [varArgs] - Format string arguments\n */\nfunction println(format, varArgs) {\n  var vargs = Array.from(arguments);\n  vargs[0] += '\\n';\n  process.stdout.write(sprintf.apply(null, vargs));\n}\n\n/**\n * Returns a `tapVersion`-appropriate TAP producer instance, if possible.\n *\n * @private\n * @param {string} tapVersion - Version of TAP specification to produce.\n * @returns {TAPProducer} specification-appropriate instance\n * @throws {Error} if specification version has no associated producer.\n */\nfunction createProducer(tapVersion) {\n  var producers = {\n    12: new TAP12Producer(),\n    13: new TAP13Producer()\n  };\n  var producer = producers[tapVersion];\n\n  if (!producer) {\n    throw new Error(\n      'invalid or unsupported TAP version: ' + JSON.stringify(tapVersion)\n    );\n  }\n\n  return producer;\n}\n\n/**\n * @summary\n * Constructs a new TAPProducer.\n *\n * @description\n * <em>Only</em> to be used as an abstract base class.\n *\n * @private\n * @constructor\n */\nfunction TAPProducer() {}\n\n/**\n * Writes the TAP version to reporter output stream.\n *\n * @abstract\n */\nTAPProducer.prototype.writeVersion = function () {};\n\n/**\n * Writes the plan to reporter output stream.\n *\n * @abstract\n * @param {number} ntests - Number of tests that are planned to run.\n */\nTAPProducer.prototype.writePlan = function (ntests) {\n  println('%d..%d', 1, ntests);\n};\n\n/**\n * Writes that test passed to reporter output stream.\n *\n * @abstract\n * @param {number} n - Index of test that passed.\n * @param {Test} test - Instance containing test information.\n */\nTAPProducer.prototype.writePass = function (n, test) {\n  println('ok %d %s', n, title(test));\n};\n\n/**\n * Writes that test was skipped to reporter output stream.\n *\n * @abstract\n * @param {number} n - Index of test that was skipped.\n * @param {Test} test - Instance containing test information.\n */\nTAPProducer.prototype.writePending = function (n, test) {\n  println('ok %d %s # SKIP -', n, title(test));\n};\n\n/**\n * Writes that test failed to reporter output stream.\n *\n * @abstract\n * @param {number} n - Index of test that failed.\n * @param {Test} test - Instance containing test information.\n * @param {Error} err - Reason the test failed.\n */\nTAPProducer.prototype.writeFail = function (n, test, err) {\n  println('not ok %d %s', n, title(test));\n};\n\n/**\n * Writes the summary epilogue to reporter output stream.\n *\n * @abstract\n * @param {Object} stats - Object containing run statistics.\n */\nTAPProducer.prototype.writeEpilogue = function (stats) {\n  // :TBD: Why is this not counting pending tests?\n  println('# tests ' + (stats.passes + stats.failures));\n  println('# pass ' + stats.passes);\n  // :TBD: Why are we not showing pending results?\n  println('# fail ' + stats.failures);\n  this.writePlan(stats.passes + stats.failures + stats.pending);\n};\n\n/**\n * @summary\n * Constructs a new TAP12Producer.\n *\n * @description\n * Produces output conforming to the TAP12 specification.\n *\n * @private\n * @constructor\n * @extends TAPProducer\n * @see {@link https://testanything.org/tap-specification.html|Specification}\n */\nfunction TAP12Producer() {\n  /**\n   * Writes that test failed to reporter output stream, with error formatting.\n   * @override\n   */\n  this.writeFail = function (n, test, err) {\n    TAPProducer.prototype.writeFail.call(this, n, test, err);\n    if (err.message) {\n      println(err.message.replace(/^/gm, '  '));\n    }\n    if (err.stack) {\n      println(err.stack.replace(/^/gm, '  '));\n    }\n  };\n}\n\n/**\n * Inherit from `TAPProducer.prototype`.\n */\ninherits(TAP12Producer, TAPProducer);\n\n/**\n * @summary\n * Constructs a new TAP13Producer.\n *\n * @description\n * Produces output conforming to the TAP13 specification.\n *\n * @private\n * @constructor\n * @extends TAPProducer\n * @see {@link https://testanything.org/tap-version-13-specification.html|Specification}\n */\nfunction TAP13Producer() {\n  /**\n   * Writes the TAP version to reporter output stream.\n   * @override\n   */\n  this.writeVersion = function () {\n    println('TAP version 13');\n  };\n\n  /**\n   * Writes that test failed to reporter output stream, with error formatting.\n   * @override\n   */\n  this.writeFail = function (n, test, err) {\n    TAPProducer.prototype.writeFail.call(this, n, test, err);\n    var emitYamlBlock = err.message != null || err.stack != null;\n    if (emitYamlBlock) {\n      println(indent(1) + '---');\n      if (err.message) {\n        println(indent(2) + 'message: |-');\n        println(err.message.replace(/^/gm, indent(3)));\n      }\n      if (err.stack) {\n        println(indent(2) + 'stack: |-');\n        println(err.stack.replace(/^/gm, indent(3)));\n      }\n      println(indent(1) + '...');\n    }\n  };\n\n  function indent(level) {\n    return Array(level + 1).join('  ');\n  }\n}\n\n/**\n * Inherit from `TAPProducer.prototype`.\n */\ninherits(TAP13Producer, TAPProducer);\n\nTAP.description = 'TAP-compatible output';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy90YXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLFdBQVcsbUJBQU8sQ0FBQyxnRUFBUTtBQUMzQixnQkFBZ0IsNEZBQThCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUZBQTRCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxhQUFhO0FBQzFCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE1BQU07QUFDakIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy90YXAuanM/N2ZmOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBtb2R1bGUgVEFQXG4gKi9cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vcnVubmVyJykuY29uc3RhbnRzO1xudmFyIEVWRU5UX1RFU1RfUEFTUyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BBU1M7XG52YXIgRVZFTlRfVEVTVF9GQUlMID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfRkFJTDtcbnZhciBFVkVOVF9SVU5fQkVHSU4gPSBjb25zdGFudHMuRVZFTlRfUlVOX0JFR0lOO1xudmFyIEVWRU5UX1JVTl9FTkQgPSBjb25zdGFudHMuRVZFTlRfUlVOX0VORDtcbnZhciBFVkVOVF9URVNUX1BFTkRJTkcgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9QRU5ESU5HO1xudmFyIEVWRU5UX1RFU1RfRU5EID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfRU5EO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcbnZhciBzcHJpbnRmID0gdXRpbC5mb3JtYXQ7XG5cbi8qKlxuICogRXhwb3NlIGBUQVBgLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFRBUDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGBUQVBgIHJlcG9ydGVyIGluc3RhbmNlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXIgLSBJbnN0YW5jZSB0cmlnZ2VycyByZXBvcnRlciBhY3Rpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHJ1bm5lciBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFRBUChydW5uZXIsIG9wdGlvbnMpIHtcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lciwgb3B0aW9ucyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbiA9IDE7XG5cbiAgdmFyIHRhcFZlcnNpb24gPSAnMTInO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcG9ydGVyT3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnJlcG9ydGVyT3B0aW9ucy50YXBWZXJzaW9uKSB7XG4gICAgICB0YXBWZXJzaW9uID0gb3B0aW9ucy5yZXBvcnRlck9wdGlvbnMudGFwVmVyc2lvbi50b1N0cmluZygpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX3Byb2R1Y2VyID0gY3JlYXRlUHJvZHVjZXIodGFwVmVyc2lvbik7XG5cbiAgcnVubmVyLm9uY2UoRVZFTlRfUlVOX0JFR0lOLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fcHJvZHVjZXIud3JpdGVWZXJzaW9uKCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX0VORCwgZnVuY3Rpb24gKCkge1xuICAgICsrbjtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfUEVORElORywgZnVuY3Rpb24gKHRlc3QpIHtcbiAgICBzZWxmLl9wcm9kdWNlci53cml0ZVBlbmRpbmcobiwgdGVzdCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BBU1MsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgc2VsZi5fcHJvZHVjZXIud3JpdGVQYXNzKG4sIHRlc3QpO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9GQUlMLCBmdW5jdGlvbiAodGVzdCwgZXJyKSB7XG4gICAgc2VsZi5fcHJvZHVjZXIud3JpdGVGYWlsKG4sIHRlc3QsIGVycik7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbmNlKEVWRU5UX1JVTl9FTkQsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9wcm9kdWNlci53cml0ZUVwaWxvZ3VlKHJ1bm5lci5zdGF0cyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxuICovXG5pbmhlcml0cyhUQVAsIEJhc2UpO1xuXG4vKipcbiAqIFJldHVybnMgYSBUQVAtc2FmZSB0aXRsZSBvZiBgdGVzdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7VGVzdH0gdGVzdCAtIFRlc3QgaW5zdGFuY2UuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRpdGxlIHdpdGggYW55IGhhc2ggY2hhcmFjdGVyIHJlbW92ZWRcbiAqL1xuZnVuY3Rpb24gdGl0bGUodGVzdCkge1xuICByZXR1cm4gdGVzdC5mdWxsVGl0bGUoKS5yZXBsYWNlKC8jL2csICcnKTtcbn1cblxuLyoqXG4gKiBXcml0ZXMgbmV3bGluZS10ZXJtaW5hdGVkIGZvcm1hdHRlZCBzdHJpbmcgdG8gcmVwb3J0ZXIgb3V0cHV0IHN0cmVhbS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIGBwcmludGZgLWxpa2UgZm9ybWF0IHN0cmluZ1xuICogQHBhcmFtIHsuLi4qfSBbdmFyQXJnc10gLSBGb3JtYXQgc3RyaW5nIGFyZ3VtZW50c1xuICovXG5mdW5jdGlvbiBwcmludGxuKGZvcm1hdCwgdmFyQXJncykge1xuICB2YXIgdmFyZ3MgPSBBcnJheS5mcm9tKGFyZ3VtZW50cyk7XG4gIHZhcmdzWzBdICs9ICdcXG4nO1xuICBwcm9jZXNzLnN0ZG91dC53cml0ZShzcHJpbnRmLmFwcGx5KG51bGwsIHZhcmdzKSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGB0YXBWZXJzaW9uYC1hcHByb3ByaWF0ZSBUQVAgcHJvZHVjZXIgaW5zdGFuY2UsIGlmIHBvc3NpYmxlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFwVmVyc2lvbiAtIFZlcnNpb24gb2YgVEFQIHNwZWNpZmljYXRpb24gdG8gcHJvZHVjZS5cbiAqIEByZXR1cm5zIHtUQVBQcm9kdWNlcn0gc3BlY2lmaWNhdGlvbi1hcHByb3ByaWF0ZSBpbnN0YW5jZVxuICogQHRocm93cyB7RXJyb3J9IGlmIHNwZWNpZmljYXRpb24gdmVyc2lvbiBoYXMgbm8gYXNzb2NpYXRlZCBwcm9kdWNlci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJvZHVjZXIodGFwVmVyc2lvbikge1xuICB2YXIgcHJvZHVjZXJzID0ge1xuICAgIDEyOiBuZXcgVEFQMTJQcm9kdWNlcigpLFxuICAgIDEzOiBuZXcgVEFQMTNQcm9kdWNlcigpXG4gIH07XG4gIHZhciBwcm9kdWNlciA9IHByb2R1Y2Vyc1t0YXBWZXJzaW9uXTtcblxuICBpZiAoIXByb2R1Y2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2ludmFsaWQgb3IgdW5zdXBwb3J0ZWQgVEFQIHZlcnNpb246ICcgKyBKU09OLnN0cmluZ2lmeSh0YXBWZXJzaW9uKVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcHJvZHVjZXI7XG59XG5cbi8qKlxuICogQHN1bW1hcnlcbiAqIENvbnN0cnVjdHMgYSBuZXcgVEFQUHJvZHVjZXIuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiA8ZW0+T25seTwvZW0+IHRvIGJlIHVzZWQgYXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRBUFByb2R1Y2VyKCkge31cblxuLyoqXG4gKiBXcml0ZXMgdGhlIFRBUCB2ZXJzaW9uIHRvIHJlcG9ydGVyIG91dHB1dCBzdHJlYW0uXG4gKlxuICogQGFic3RyYWN0XG4gKi9cblRBUFByb2R1Y2VyLnByb3RvdHlwZS53cml0ZVZlcnNpb24gPSBmdW5jdGlvbiAoKSB7fTtcblxuLyoqXG4gKiBXcml0ZXMgdGhlIHBsYW4gdG8gcmVwb3J0ZXIgb3V0cHV0IHN0cmVhbS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBudGVzdHMgLSBOdW1iZXIgb2YgdGVzdHMgdGhhdCBhcmUgcGxhbm5lZCB0byBydW4uXG4gKi9cblRBUFByb2R1Y2VyLnByb3RvdHlwZS53cml0ZVBsYW4gPSBmdW5jdGlvbiAobnRlc3RzKSB7XG4gIHByaW50bG4oJyVkLi4lZCcsIDEsIG50ZXN0cyk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyB0aGF0IHRlc3QgcGFzc2VkIHRvIHJlcG9ydGVyIG91dHB1dCBzdHJlYW0uXG4gKlxuICogQGFic3RyYWN0XG4gKiBAcGFyYW0ge251bWJlcn0gbiAtIEluZGV4IG9mIHRlc3QgdGhhdCBwYXNzZWQuXG4gKiBAcGFyYW0ge1Rlc3R9IHRlc3QgLSBJbnN0YW5jZSBjb250YWluaW5nIHRlc3QgaW5mb3JtYXRpb24uXG4gKi9cblRBUFByb2R1Y2VyLnByb3RvdHlwZS53cml0ZVBhc3MgPSBmdW5jdGlvbiAobiwgdGVzdCkge1xuICBwcmludGxuKCdvayAlZCAlcycsIG4sIHRpdGxlKHRlc3QpKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIHRoYXQgdGVzdCB3YXMgc2tpcHBlZCB0byByZXBvcnRlciBvdXRwdXQgc3RyZWFtLlxuICpcbiAqIEBhYnN0cmFjdFxuICogQHBhcmFtIHtudW1iZXJ9IG4gLSBJbmRleCBvZiB0ZXN0IHRoYXQgd2FzIHNraXBwZWQuXG4gKiBAcGFyYW0ge1Rlc3R9IHRlc3QgLSBJbnN0YW5jZSBjb250YWluaW5nIHRlc3QgaW5mb3JtYXRpb24uXG4gKi9cblRBUFByb2R1Y2VyLnByb3RvdHlwZS53cml0ZVBlbmRpbmcgPSBmdW5jdGlvbiAobiwgdGVzdCkge1xuICBwcmludGxuKCdvayAlZCAlcyAjIFNLSVAgLScsIG4sIHRpdGxlKHRlc3QpKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIHRoYXQgdGVzdCBmYWlsZWQgdG8gcmVwb3J0ZXIgb3V0cHV0IHN0cmVhbS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIC0gSW5kZXggb2YgdGVzdCB0aGF0IGZhaWxlZC5cbiAqIEBwYXJhbSB7VGVzdH0gdGVzdCAtIEluc3RhbmNlIGNvbnRhaW5pbmcgdGVzdCBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIFJlYXNvbiB0aGUgdGVzdCBmYWlsZWQuXG4gKi9cblRBUFByb2R1Y2VyLnByb3RvdHlwZS53cml0ZUZhaWwgPSBmdW5jdGlvbiAobiwgdGVzdCwgZXJyKSB7XG4gIHByaW50bG4oJ25vdCBvayAlZCAlcycsIG4sIHRpdGxlKHRlc3QpKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIHRoZSBzdW1tYXJ5IGVwaWxvZ3VlIHRvIHJlcG9ydGVyIG91dHB1dCBzdHJlYW0uXG4gKlxuICogQGFic3RyYWN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdHMgLSBPYmplY3QgY29udGFpbmluZyBydW4gc3RhdGlzdGljcy5cbiAqL1xuVEFQUHJvZHVjZXIucHJvdG90eXBlLndyaXRlRXBpbG9ndWUgPSBmdW5jdGlvbiAoc3RhdHMpIHtcbiAgLy8gOlRCRDogV2h5IGlzIHRoaXMgbm90IGNvdW50aW5nIHBlbmRpbmcgdGVzdHM/XG4gIHByaW50bG4oJyMgdGVzdHMgJyArIChzdGF0cy5wYXNzZXMgKyBzdGF0cy5mYWlsdXJlcykpO1xuICBwcmludGxuKCcjIHBhc3MgJyArIHN0YXRzLnBhc3Nlcyk7XG4gIC8vIDpUQkQ6IFdoeSBhcmUgd2Ugbm90IHNob3dpbmcgcGVuZGluZyByZXN1bHRzP1xuICBwcmludGxuKCcjIGZhaWwgJyArIHN0YXRzLmZhaWx1cmVzKTtcbiAgdGhpcy53cml0ZVBsYW4oc3RhdHMucGFzc2VzICsgc3RhdHMuZmFpbHVyZXMgKyBzdGF0cy5wZW5kaW5nKTtcbn07XG5cbi8qKlxuICogQHN1bW1hcnlcbiAqIENvbnN0cnVjdHMgYSBuZXcgVEFQMTJQcm9kdWNlci5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByb2R1Y2VzIG91dHB1dCBjb25mb3JtaW5nIHRvIHRoZSBUQVAxMiBzcGVjaWZpY2F0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFRBUFByb2R1Y2VyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3Rlc3Rhbnl0aGluZy5vcmcvdGFwLXNwZWNpZmljYXRpb24uaHRtbHxTcGVjaWZpY2F0aW9ufVxuICovXG5mdW5jdGlvbiBUQVAxMlByb2R1Y2VyKCkge1xuICAvKipcbiAgICogV3JpdGVzIHRoYXQgdGVzdCBmYWlsZWQgdG8gcmVwb3J0ZXIgb3V0cHV0IHN0cmVhbSwgd2l0aCBlcnJvciBmb3JtYXR0aW5nLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHRoaXMud3JpdGVGYWlsID0gZnVuY3Rpb24gKG4sIHRlc3QsIGVycikge1xuICAgIFRBUFByb2R1Y2VyLnByb3RvdHlwZS53cml0ZUZhaWwuY2FsbCh0aGlzLCBuLCB0ZXN0LCBlcnIpO1xuICAgIGlmIChlcnIubWVzc2FnZSkge1xuICAgICAgcHJpbnRsbihlcnIubWVzc2FnZS5yZXBsYWNlKC9eL2dtLCAnICAnKSk7XG4gICAgfVxuICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgIHByaW50bG4oZXJyLnN0YWNrLnJlcGxhY2UoL14vZ20sICcgICcpKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBUQVBQcm9kdWNlci5wcm90b3R5cGVgLlxuICovXG5pbmhlcml0cyhUQVAxMlByb2R1Y2VyLCBUQVBQcm9kdWNlcik7XG5cbi8qKlxuICogQHN1bW1hcnlcbiAqIENvbnN0cnVjdHMgYSBuZXcgVEFQMTNQcm9kdWNlci5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByb2R1Y2VzIG91dHB1dCBjb25mb3JtaW5nIHRvIHRoZSBUQVAxMyBzcGVjaWZpY2F0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFRBUFByb2R1Y2VyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3Rlc3Rhbnl0aGluZy5vcmcvdGFwLXZlcnNpb24tMTMtc3BlY2lmaWNhdGlvbi5odG1sfFNwZWNpZmljYXRpb259XG4gKi9cbmZ1bmN0aW9uIFRBUDEzUHJvZHVjZXIoKSB7XG4gIC8qKlxuICAgKiBXcml0ZXMgdGhlIFRBUCB2ZXJzaW9uIHRvIHJlcG9ydGVyIG91dHB1dCBzdHJlYW0uXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgdGhpcy53cml0ZVZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJpbnRsbignVEFQIHZlcnNpb24gMTMnKTtcbiAgfTtcblxuICAvKipcbiAgICogV3JpdGVzIHRoYXQgdGVzdCBmYWlsZWQgdG8gcmVwb3J0ZXIgb3V0cHV0IHN0cmVhbSwgd2l0aCBlcnJvciBmb3JtYXR0aW5nLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHRoaXMud3JpdGVGYWlsID0gZnVuY3Rpb24gKG4sIHRlc3QsIGVycikge1xuICAgIFRBUFByb2R1Y2VyLnByb3RvdHlwZS53cml0ZUZhaWwuY2FsbCh0aGlzLCBuLCB0ZXN0LCBlcnIpO1xuICAgIHZhciBlbWl0WWFtbEJsb2NrID0gZXJyLm1lc3NhZ2UgIT0gbnVsbCB8fCBlcnIuc3RhY2sgIT0gbnVsbDtcbiAgICBpZiAoZW1pdFlhbWxCbG9jaykge1xuICAgICAgcHJpbnRsbihpbmRlbnQoMSkgKyAnLS0tJyk7XG4gICAgICBpZiAoZXJyLm1lc3NhZ2UpIHtcbiAgICAgICAgcHJpbnRsbihpbmRlbnQoMikgKyAnbWVzc2FnZTogfC0nKTtcbiAgICAgICAgcHJpbnRsbihlcnIubWVzc2FnZS5yZXBsYWNlKC9eL2dtLCBpbmRlbnQoMykpKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgICAgcHJpbnRsbihpbmRlbnQoMikgKyAnc3RhY2s6IHwtJyk7XG4gICAgICAgIHByaW50bG4oZXJyLnN0YWNrLnJlcGxhY2UoL14vZ20sIGluZGVudCgzKSkpO1xuICAgICAgfVxuICAgICAgcHJpbnRsbihpbmRlbnQoMSkgKyAnLi4uJyk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGluZGVudChsZXZlbCkge1xuICAgIHJldHVybiBBcnJheShsZXZlbCArIDEpLmpvaW4oJyAgJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0IGZyb20gYFRBUFByb2R1Y2VyLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKFRBUDEzUHJvZHVjZXIsIFRBUFByb2R1Y2VyKTtcblxuVEFQLmRlc2NyaXB0aW9uID0gJ1RBUC1jb21wYXRpYmxlIG91dHB1dCc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/reporters/tap.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/reporters/xunit.js":
/*!***************************************************!*\
  !*** ./node_modules/mocha/lib/reporters/xunit.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * @module XUnit\n */\n/**\n * Module dependencies.\n */\n\nvar Base = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/mocha/lib/reporters/base.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar errors = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/mocha/lib/errors.js\");\nvar createUnsupportedError = errors.createUnsupportedError;\nvar constants = (__webpack_require__(/*! ../runner */ \"(ssr)/./node_modules/mocha/lib/runner.js\").constants);\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\nvar EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;\nvar STATE_FAILED = (__webpack_require__(/*! ../runnable */ \"(ssr)/./node_modules/mocha/lib/runnable.js\").constants).STATE_FAILED;\nvar inherits = utils.inherits;\nvar escape = utils.escape;\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\nvar Date = global.Date;\n\n/**\n * Expose `XUnit`.\n */\n\nexports = module.exports = XUnit;\n\n/**\n * Constructs a new `XUnit` reporter instance.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @param {Runner} runner - Instance triggers reporter actions.\n * @param {Object} [options] - runner options\n */\nfunction XUnit(runner, options) {\n  Base.call(this, runner, options);\n\n  var stats = this.stats;\n  var tests = [];\n  var self = this;\n\n  // the name of the test suite, as it will appear in the resulting XML file\n  var suiteName;\n\n  // the default name of the test suite if none is provided\n  var DEFAULT_SUITE_NAME = 'Mocha Tests';\n\n  if (options && options.reporterOptions) {\n    if (options.reporterOptions.output) {\n      if (!fs.createWriteStream) {\n        throw createUnsupportedError('file output not supported in browser');\n      }\n\n      fs.mkdirSync(path.dirname(options.reporterOptions.output), {\n        recursive: true\n      });\n      self.fileStream = fs.createWriteStream(options.reporterOptions.output);\n    }\n\n    // get the suite name from the reporter options (if provided)\n    suiteName = options.reporterOptions.suiteName;\n  }\n\n  // fall back to the default suite name\n  suiteName = suiteName || DEFAULT_SUITE_NAME;\n\n  runner.on(EVENT_TEST_PENDING, function (test) {\n    tests.push(test);\n  });\n\n  runner.on(EVENT_TEST_PASS, function (test) {\n    tests.push(test);\n  });\n\n  runner.on(EVENT_TEST_FAIL, function (test) {\n    tests.push(test);\n  });\n\n  runner.once(EVENT_RUN_END, function () {\n    self.write(\n      tag(\n        'testsuite',\n        {\n          name: suiteName,\n          tests: stats.tests,\n          failures: 0,\n          errors: stats.failures,\n          skipped: stats.tests - stats.failures - stats.passes,\n          timestamp: new Date().toUTCString(),\n          time: stats.duration / 1000 || 0\n        },\n        false\n      )\n    );\n\n    tests.forEach(function (t) {\n      self.test(t);\n    });\n\n    self.write('</testsuite>');\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(XUnit, Base);\n\n/**\n * Override done to close the stream (if it's a file).\n *\n * @param failures\n * @param {Function} fn\n */\nXUnit.prototype.done = function (failures, fn) {\n  if (this.fileStream) {\n    this.fileStream.end(function () {\n      fn(failures);\n    });\n  } else {\n    fn(failures);\n  }\n};\n\n/**\n * Write out the given line.\n *\n * @param {string} line\n */\nXUnit.prototype.write = function (line) {\n  if (this.fileStream) {\n    this.fileStream.write(line + '\\n');\n  } else if (typeof process === 'object' && process.stdout) {\n    process.stdout.write(line + '\\n');\n  } else {\n    Base.consoleLog(line);\n  }\n};\n\n/**\n * Output tag for the given `test.`\n *\n * @param {Test} test\n */\nXUnit.prototype.test = function (test) {\n  Base.useColors = false;\n\n  var attrs = {\n    classname: test.parent.fullTitle(),\n    name: test.title,\n    file: test.file,\n    time: test.duration / 1000 || 0\n  };\n\n  if (test.state === STATE_FAILED) {\n    var err = test.err;\n    var diff =\n      !Base.hideDiff && Base.showDiff(err)\n        ? '\\n' + Base.generateDiff(err.actual, err.expected)\n        : '';\n    this.write(\n      tag(\n        'testcase',\n        attrs,\n        false,\n        tag(\n          'failure',\n          {},\n          false,\n          escape(err.message) + escape(diff) + '\\n' + escape(err.stack)\n        )\n      )\n    );\n  } else if (test.isPending()) {\n    this.write(tag('testcase', attrs, false, tag('skipped', {}, true)));\n  } else {\n    this.write(tag('testcase', attrs, true));\n  }\n};\n\n/**\n * HTML tag helper.\n *\n * @param name\n * @param attrs\n * @param close\n * @param content\n * @return {string}\n */\nfunction tag(name, attrs, close, content) {\n  var end = close ? '/>' : '>';\n  var pairs = [];\n  var tag;\n\n  for (var key in attrs) {\n    if (Object.prototype.hasOwnProperty.call(attrs, key)) {\n      pairs.push(key + '=\"' + escape(attrs[key]) + '\"');\n    }\n  }\n\n  tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;\n  if (content) {\n    tag += content + '</' + name + end;\n  }\n  return tag;\n}\n\nXUnit.description = 'XUnit-compatible XML output';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy94dW5pdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsZ0VBQVE7QUFDM0IsWUFBWSxtQkFBTyxDQUFDLHlEQUFVO0FBQzlCLFNBQVMsbUJBQU8sQ0FBQyxjQUFJO0FBQ3JCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixhQUFhLG1CQUFPLENBQUMsMkRBQVc7QUFDaEM7QUFDQSxnQkFBZ0IsNEZBQThCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdHQUFnQztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDhEQUE4RDtBQUM5RCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMveHVuaXQuanM/NzJmZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBtb2R1bGUgWFVuaXRcbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xudmFyIGNyZWF0ZVVuc3VwcG9ydGVkRXJyb3IgPSBlcnJvcnMuY3JlYXRlVW5zdXBwb3J0ZWRFcnJvcjtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9ydW5uZXInKS5jb25zdGFudHM7XG52YXIgRVZFTlRfVEVTVF9QQVNTID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfUEFTUztcbnZhciBFVkVOVF9URVNUX0ZBSUwgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9GQUlMO1xudmFyIEVWRU5UX1JVTl9FTkQgPSBjb25zdGFudHMuRVZFTlRfUlVOX0VORDtcbnZhciBFVkVOVF9URVNUX1BFTkRJTkcgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9QRU5ESU5HO1xudmFyIFNUQVRFX0ZBSUxFRCA9IHJlcXVpcmUoJy4uL3J1bm5hYmxlJykuY29uc3RhbnRzLlNUQVRFX0ZBSUxFRDtcbnZhciBpbmhlcml0cyA9IHV0aWxzLmluaGVyaXRzO1xudmFyIGVzY2FwZSA9IHV0aWxzLmVzY2FwZTtcblxuLyoqXG4gKiBTYXZlIHRpbWVyIHJlZmVyZW5jZXMgdG8gYXZvaWQgU2lub24gaW50ZXJmZXJpbmcgKHNlZSBHSC0yMzcpLlxuICovXG52YXIgRGF0ZSA9IGdsb2JhbC5EYXRlO1xuXG4vKipcbiAqIEV4cG9zZSBgWFVuaXRgLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFhVbml0O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYFhVbml0YCByZXBvcnRlciBpbnN0YW5jZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyIC0gSW5zdGFuY2UgdHJpZ2dlcnMgcmVwb3J0ZXIgYWN0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBydW5uZXIgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBYVW5pdChydW5uZXIsIG9wdGlvbnMpIHtcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lciwgb3B0aW9ucyk7XG5cbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgdmFyIHRlc3RzID0gW107XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyB0aGUgbmFtZSBvZiB0aGUgdGVzdCBzdWl0ZSwgYXMgaXQgd2lsbCBhcHBlYXIgaW4gdGhlIHJlc3VsdGluZyBYTUwgZmlsZVxuICB2YXIgc3VpdGVOYW1lO1xuXG4gIC8vIHRoZSBkZWZhdWx0IG5hbWUgb2YgdGhlIHRlc3Qgc3VpdGUgaWYgbm9uZSBpcyBwcm92aWRlZFxuICB2YXIgREVGQVVMVF9TVUlURV9OQU1FID0gJ01vY2hhIFRlc3RzJztcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcG9ydGVyT3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnJlcG9ydGVyT3B0aW9ucy5vdXRwdXQpIHtcbiAgICAgIGlmICghZnMuY3JlYXRlV3JpdGVTdHJlYW0pIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlVW5zdXBwb3J0ZWRFcnJvcignZmlsZSBvdXRwdXQgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyJyk7XG4gICAgICB9XG5cbiAgICAgIGZzLm1rZGlyU3luYyhwYXRoLmRpcm5hbWUob3B0aW9ucy5yZXBvcnRlck9wdGlvbnMub3V0cHV0KSwge1xuICAgICAgICByZWN1cnNpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgc2VsZi5maWxlU3RyZWFtID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0ob3B0aW9ucy5yZXBvcnRlck9wdGlvbnMub3V0cHV0KTtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIHN1aXRlIG5hbWUgZnJvbSB0aGUgcmVwb3J0ZXIgb3B0aW9ucyAoaWYgcHJvdmlkZWQpXG4gICAgc3VpdGVOYW1lID0gb3B0aW9ucy5yZXBvcnRlck9wdGlvbnMuc3VpdGVOYW1lO1xuICB9XG5cbiAgLy8gZmFsbCBiYWNrIHRvIHRoZSBkZWZhdWx0IHN1aXRlIG5hbWVcbiAgc3VpdGVOYW1lID0gc3VpdGVOYW1lIHx8IERFRkFVTFRfU1VJVEVfTkFNRTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9QRU5ESU5HLCBmdW5jdGlvbiAodGVzdCkge1xuICAgIHRlc3RzLnB1c2godGVzdCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BBU1MsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgdGVzdHMucHVzaCh0ZXN0KTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfRkFJTCwgZnVuY3Rpb24gKHRlc3QpIHtcbiAgICB0ZXN0cy5wdXNoKHRlc3QpO1xuICB9KTtcblxuICBydW5uZXIub25jZShFVkVOVF9SVU5fRU5ELCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi53cml0ZShcbiAgICAgIHRhZyhcbiAgICAgICAgJ3Rlc3RzdWl0ZScsXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBzdWl0ZU5hbWUsXG4gICAgICAgICAgdGVzdHM6IHN0YXRzLnRlc3RzLFxuICAgICAgICAgIGZhaWx1cmVzOiAwLFxuICAgICAgICAgIGVycm9yczogc3RhdHMuZmFpbHVyZXMsXG4gICAgICAgICAgc2tpcHBlZDogc3RhdHMudGVzdHMgLSBzdGF0cy5mYWlsdXJlcyAtIHN0YXRzLnBhc3NlcyxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9VVENTdHJpbmcoKSxcbiAgICAgICAgICB0aW1lOiBzdGF0cy5kdXJhdGlvbiAvIDEwMDAgfHwgMFxuICAgICAgICB9LFxuICAgICAgICBmYWxzZVxuICAgICAgKVxuICAgICk7XG5cbiAgICB0ZXN0cy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICBzZWxmLnRlc3QodCk7XG4gICAgfSk7XG5cbiAgICBzZWxmLndyaXRlKCc8L3Rlc3RzdWl0ZT4nKTtcbiAgfSk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKFhVbml0LCBCYXNlKTtcblxuLyoqXG4gKiBPdmVycmlkZSBkb25lIHRvIGNsb3NlIHRoZSBzdHJlYW0gKGlmIGl0J3MgYSBmaWxlKS5cbiAqXG4gKiBAcGFyYW0gZmFpbHVyZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cblhVbml0LnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24gKGZhaWx1cmVzLCBmbikge1xuICBpZiAodGhpcy5maWxlU3RyZWFtKSB7XG4gICAgdGhpcy5maWxlU3RyZWFtLmVuZChmdW5jdGlvbiAoKSB7XG4gICAgICBmbihmYWlsdXJlcyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZm4oZmFpbHVyZXMpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlIG91dCB0aGUgZ2l2ZW4gbGluZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbGluZVxuICovXG5YVW5pdC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAobGluZSkge1xuICBpZiAodGhpcy5maWxlU3RyZWFtKSB7XG4gICAgdGhpcy5maWxlU3RyZWFtLndyaXRlKGxpbmUgKyAnXFxuJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3Muc3Rkb3V0KSB7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUobGluZSArICdcXG4nKTtcbiAgfSBlbHNlIHtcbiAgICBCYXNlLmNvbnNvbGVMb2cobGluZSk7XG4gIH1cbn07XG5cbi8qKlxuICogT3V0cHV0IHRhZyBmb3IgdGhlIGdpdmVuIGB0ZXN0LmBcbiAqXG4gKiBAcGFyYW0ge1Rlc3R9IHRlc3RcbiAqL1xuWFVuaXQucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiAodGVzdCkge1xuICBCYXNlLnVzZUNvbG9ycyA9IGZhbHNlO1xuXG4gIHZhciBhdHRycyA9IHtcbiAgICBjbGFzc25hbWU6IHRlc3QucGFyZW50LmZ1bGxUaXRsZSgpLFxuICAgIG5hbWU6IHRlc3QudGl0bGUsXG4gICAgZmlsZTogdGVzdC5maWxlLFxuICAgIHRpbWU6IHRlc3QuZHVyYXRpb24gLyAxMDAwIHx8IDBcbiAgfTtcblxuICBpZiAodGVzdC5zdGF0ZSA9PT0gU1RBVEVfRkFJTEVEKSB7XG4gICAgdmFyIGVyciA9IHRlc3QuZXJyO1xuICAgIHZhciBkaWZmID1cbiAgICAgICFCYXNlLmhpZGVEaWZmICYmIEJhc2Uuc2hvd0RpZmYoZXJyKVxuICAgICAgICA/ICdcXG4nICsgQmFzZS5nZW5lcmF0ZURpZmYoZXJyLmFjdHVhbCwgZXJyLmV4cGVjdGVkKVxuICAgICAgICA6ICcnO1xuICAgIHRoaXMud3JpdGUoXG4gICAgICB0YWcoXG4gICAgICAgICd0ZXN0Y2FzZScsXG4gICAgICAgIGF0dHJzLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGFnKFxuICAgICAgICAgICdmYWlsdXJlJyxcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBlc2NhcGUoZXJyLm1lc3NhZ2UpICsgZXNjYXBlKGRpZmYpICsgJ1xcbicgKyBlc2NhcGUoZXJyLnN0YWNrKVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfSBlbHNlIGlmICh0ZXN0LmlzUGVuZGluZygpKSB7XG4gICAgdGhpcy53cml0ZSh0YWcoJ3Rlc3RjYXNlJywgYXR0cnMsIGZhbHNlLCB0YWcoJ3NraXBwZWQnLCB7fSwgdHJ1ZSkpKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndyaXRlKHRhZygndGVzdGNhc2UnLCBhdHRycywgdHJ1ZSkpO1xuICB9XG59O1xuXG4vKipcbiAqIEhUTUwgdGFnIGhlbHBlci5cbiAqXG4gKiBAcGFyYW0gbmFtZVxuICogQHBhcmFtIGF0dHJzXG4gKiBAcGFyYW0gY2xvc2VcbiAqIEBwYXJhbSBjb250ZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHRhZyhuYW1lLCBhdHRycywgY2xvc2UsIGNvbnRlbnQpIHtcbiAgdmFyIGVuZCA9IGNsb3NlID8gJy8+JyA6ICc+JztcbiAgdmFyIHBhaXJzID0gW107XG4gIHZhciB0YWc7XG5cbiAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRycywga2V5KSkge1xuICAgICAgcGFpcnMucHVzaChrZXkgKyAnPVwiJyArIGVzY2FwZShhdHRyc1trZXldKSArICdcIicpO1xuICAgIH1cbiAgfVxuXG4gIHRhZyA9ICc8JyArIG5hbWUgKyAocGFpcnMubGVuZ3RoID8gJyAnICsgcGFpcnMuam9pbignICcpIDogJycpICsgZW5kO1xuICBpZiAoY29udGVudCkge1xuICAgIHRhZyArPSBjb250ZW50ICsgJzwvJyArIG5hbWUgKyBlbmQ7XG4gIH1cbiAgcmV0dXJuIHRhZztcbn1cblxuWFVuaXQuZGVzY3JpcHRpb24gPSAnWFVuaXQtY29tcGF0aWJsZSBYTUwgb3V0cHV0JztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/reporters/xunit.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/runnable.js":
/*!********************************************!*\
  !*** ./node_modules/mocha/lib/runnable.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar Pending = __webpack_require__(/*! ./pending */ \"(ssr)/./node_modules/mocha/lib/pending.js\");\nvar debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")('mocha:runnable');\nvar milliseconds = __webpack_require__(/*! ms */ \"(ssr)/./node_modules/ms/index.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\");\nconst {\n  createInvalidExceptionError,\n  createMultipleDoneError,\n  createTimeoutError\n} = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/mocha/lib/errors.js\");\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n * @private\n */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar clearTimeout = global.clearTimeout;\nvar toString = Object.prototype.toString;\n\nvar MAX_TIMEOUT = Math.pow(2, 31) - 1;\n\nmodule.exports = Runnable;\n\n/**\n * Initialize a new `Runnable` with the given `title` and callback `fn`.\n *\n * @class\n * @extends external:EventEmitter\n * @public\n * @param {String} title\n * @param {Function} fn\n */\nfunction Runnable(title, fn) {\n  this.title = title;\n  this.fn = fn;\n  this.body = (fn || '').toString();\n  this.async = fn && fn.length;\n  this.sync = !this.async;\n  this._timeout = 2000;\n  this._slow = 75;\n  this._retries = -1;\n  utils.assignNewMochaID(this);\n  Object.defineProperty(this, 'id', {\n    get() {\n      return utils.getMochaID(this);\n    }\n  });\n  this.reset();\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\nutils.inherits(Runnable, EventEmitter);\n\n/**\n * Resets the state initially or for a next run.\n */\nRunnable.prototype.reset = function () {\n  this.timedOut = false;\n  this._currentRetry = 0;\n  this.pending = false;\n  delete this.state;\n  delete this.err;\n};\n\n/**\n * Get current timeout value in msecs.\n *\n * @private\n * @returns {number} current timeout threshold value\n */\n/**\n * @summary\n * Set timeout threshold value (msecs).\n *\n * @description\n * A string argument can use shorthand (e.g., \"2s\") and will be converted.\n * The value will be clamped to range [<code>0</code>, <code>2^<sup>31</sup>-1</code>].\n * If clamped value matches either range endpoint, timeouts will be disabled.\n *\n * @private\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout#Maximum_delay_value}\n * @param {number|string} ms - Timeout threshold value.\n * @returns {Runnable} this\n * @chainable\n */\nRunnable.prototype.timeout = function (ms) {\n  if (!arguments.length) {\n    return this._timeout;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n\n  // Clamp to range\n  var range = [0, MAX_TIMEOUT];\n  ms = utils.clamp(ms, range);\n\n  // see #1652 for reasoning\n  if (ms === range[0] || ms === range[1]) {\n    this._timeout = 0;\n  } else {\n    this._timeout = ms;\n  }\n  debug('timeout %d', this._timeout);\n\n  if (this.timer) {\n    this.resetTimeout();\n  }\n  return this;\n};\n\n/**\n * Set or get slow `ms`.\n *\n * @private\n * @param {number|string} ms\n * @return {Runnable|number} ms or Runnable instance.\n */\nRunnable.prototype.slow = function (ms) {\n  if (!arguments.length || typeof ms === 'undefined') {\n    return this._slow;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('slow %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Halt and mark as pending.\n *\n * @memberof Mocha.Runnable\n * @public\n */\nRunnable.prototype.skip = function () {\n  this.pending = true;\n  throw new Pending('sync skip; aborting execution');\n};\n\n/**\n * Check if this runnable or its parent suite is marked as pending.\n *\n * @private\n */\nRunnable.prototype.isPending = function () {\n  return this.pending || (this.parent && this.parent.isPending());\n};\n\n/**\n * Return `true` if this Runnable has failed.\n * @return {boolean}\n * @private\n */\nRunnable.prototype.isFailed = function () {\n  return !this.isPending() && this.state === constants.STATE_FAILED;\n};\n\n/**\n * Return `true` if this Runnable has passed.\n * @return {boolean}\n * @private\n */\nRunnable.prototype.isPassed = function () {\n  return !this.isPending() && this.state === constants.STATE_PASSED;\n};\n\n/**\n * Set or get number of retries.\n *\n * @private\n */\nRunnable.prototype.retries = function (n) {\n  if (!arguments.length) {\n    return this._retries;\n  }\n  this._retries = n;\n};\n\n/**\n * Set or get current retry\n *\n * @private\n */\nRunnable.prototype.currentRetry = function (n) {\n  if (!arguments.length) {\n    return this._currentRetry;\n  }\n  this._currentRetry = n;\n};\n\n/**\n * Return the full title generated by recursively concatenating the parent's\n * full title.\n *\n * @memberof Mocha.Runnable\n * @public\n * @return {string}\n */\nRunnable.prototype.fullTitle = function () {\n  return this.titlePath().join(' ');\n};\n\n/**\n * Return the title path generated by concatenating the parent's title path with the title.\n *\n * @memberof Mocha.Runnable\n * @public\n * @return {string[]}\n */\nRunnable.prototype.titlePath = function () {\n  return this.parent.titlePath().concat([this.title]);\n};\n\n/**\n * Clear the timeout.\n *\n * @private\n */\nRunnable.prototype.clearTimeout = function () {\n  clearTimeout(this.timer);\n};\n\n/**\n * Reset the timeout.\n *\n * @private\n */\nRunnable.prototype.resetTimeout = function () {\n  var self = this;\n  var ms = this.timeout() || MAX_TIMEOUT;\n\n  this.clearTimeout();\n  this.timer = setTimeout(function () {\n    if (self.timeout() === 0) {\n      return;\n    }\n    self.callback(self._timeoutError(ms));\n    self.timedOut = true;\n  }, ms);\n};\n\n/**\n * Set or get a list of whitelisted globals for this test run.\n *\n * @private\n * @param {string[]} globals\n */\nRunnable.prototype.globals = function (globals) {\n  if (!arguments.length) {\n    return this._allowedGlobals;\n  }\n  this._allowedGlobals = globals;\n};\n\n/**\n * Run the test and invoke `fn(err)`.\n *\n * @param {Function} fn\n * @private\n */\nRunnable.prototype.run = function (fn) {\n  var self = this;\n  var start = new Date();\n  var ctx = this.ctx;\n  var finished;\n  var errorWasHandled = false;\n\n  if (this.isPending()) return fn();\n\n  // Sometimes the ctx exists, but it is not runnable\n  if (ctx && ctx.runnable) {\n    ctx.runnable(this);\n  }\n\n  // called multiple times\n  function multiple(err) {\n    if (errorWasHandled) {\n      return;\n    }\n    errorWasHandled = true;\n    self.emit('error', createMultipleDoneError(self, err));\n  }\n\n  // finished\n  function done(err) {\n    var ms = self.timeout();\n    if (self.timedOut) {\n      return;\n    }\n\n    if (finished) {\n      return multiple(err);\n    }\n\n    self.clearTimeout();\n    self.duration = new Date() - start;\n    finished = true;\n    if (!err && self.duration > ms && ms > 0) {\n      err = self._timeoutError(ms);\n    }\n    fn(err);\n  }\n\n  // for .resetTimeout() and Runner#uncaught()\n  this.callback = done;\n\n  if (this.fn && typeof this.fn.call !== 'function') {\n    done(\n      new TypeError(\n        'A runnable must be passed a function as its second argument.'\n      )\n    );\n    return;\n  }\n\n  // explicit async with `done` argument\n  if (this.async) {\n    this.resetTimeout();\n\n    // allows skip() to be used in an explicit async context\n    this.skip = function asyncSkip() {\n      this.pending = true;\n      done();\n      // halt execution, the uncaught handler will ignore the failure.\n      throw new Pending('async skip; aborting execution');\n    };\n\n    try {\n      callFnAsync(this.fn);\n    } catch (err) {\n      // handles async runnables which actually run synchronously\n      errorWasHandled = true;\n      if (err instanceof Pending) {\n        return; // done() is already called in this.skip()\n      } else if (this.allowUncaught) {\n        throw err;\n      }\n      done(Runnable.toValueOrError(err));\n    }\n    return;\n  }\n\n  // sync or promise-returning\n  try {\n    callFn(this.fn);\n  } catch (err) {\n    errorWasHandled = true;\n    if (err instanceof Pending) {\n      return done();\n    } else if (this.allowUncaught) {\n      throw err;\n    }\n    done(Runnable.toValueOrError(err));\n  }\n\n  function callFn(fn) {\n    var result = fn.call(ctx);\n    if (result && typeof result.then === 'function') {\n      self.resetTimeout();\n      result.then(\n        function () {\n          done();\n          // Return null so libraries like bluebird do not warn about\n          // subsequently constructed Promises.\n          return null;\n        },\n        function (reason) {\n          done(reason || new Error('Promise rejected with no or falsy reason'));\n        }\n      );\n    } else {\n      if (self.asyncOnly) {\n        return done(\n          new Error(\n            '--async-only option in use without declaring `done()` or returning a promise'\n          )\n        );\n      }\n\n      done();\n    }\n  }\n\n  function callFnAsync(fn) {\n    var result = fn.call(ctx, function (err) {\n      if (err instanceof Error || toString.call(err) === '[object Error]') {\n        return done(err);\n      }\n      if (err) {\n        if (Object.prototype.toString.call(err) === '[object Object]') {\n          return done(\n            new Error('done() invoked with non-Error: ' + JSON.stringify(err))\n          );\n        }\n        return done(new Error('done() invoked with non-Error: ' + err));\n      }\n      if (result && utils.isPromise(result)) {\n        return done(\n          new Error(\n            'Resolution method is overspecified. Specify a callback *or* return a Promise; not both.'\n          )\n        );\n      }\n\n      done();\n    });\n  }\n};\n\n/**\n * Instantiates a \"timeout\" error\n *\n * @param {number} ms - Timeout (in milliseconds)\n * @returns {Error} a \"timeout\" error\n * @private\n */\nRunnable.prototype._timeoutError = function (ms) {\n  let msg = `Timeout of ${ms}ms exceeded. For async tests and hooks, ensure \"done()\" is called; if returning a Promise, ensure it resolves.`;\n  if (this.file) {\n    msg += ' (' + this.file + ')';\n  }\n  return createTimeoutError(msg, ms, this.file);\n};\n\nvar constants = utils.defineConstants(\n  /**\n   * {@link Runnable}-related constants.\n   * @public\n   * @memberof Runnable\n   * @readonly\n   * @static\n   * @alias constants\n   * @enum {string}\n   */\n  {\n    /**\n     * Value of `state` prop when a `Runnable` has failed\n     */\n    STATE_FAILED: 'failed',\n    /**\n     * Value of `state` prop when a `Runnable` has passed\n     */\n    STATE_PASSED: 'passed',\n    /**\n     * Value of `state` prop when a `Runnable` has been skipped by user\n     */\n    STATE_PENDING: 'pending'\n  }\n);\n\n/**\n * Given `value`, return identity if truthy, otherwise create an \"invalid exception\" error and return that.\n * @param {*} [value] - Value to return, if present\n * @returns {*|Error} `value`, otherwise an `Error`\n * @private\n */\nRunnable.toValueOrError = function (value) {\n  return (\n    value ||\n    createInvalidExceptionError(\n      'Runnable failed with falsy or undefined exception. Please throw an Error instead.',\n      value\n    )\n  );\n};\n\nRunnable.constants = constants;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3J1bm5hYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG1CQUFtQiwwREFBOEI7QUFDakQsY0FBYyxtQkFBTyxDQUFDLDREQUFXO0FBQ2pDLFlBQVksbUJBQU8sQ0FBQyxzREFBTztBQUMzQixtQkFBbUIsbUJBQU8sQ0FBQyw0Q0FBSTtBQUMvQixZQUFZLG1CQUFPLENBQUMsd0RBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQywwREFBVTs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsV0FBVyxlQUFlO0FBQzFCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixHQUFHLG1FQUFtRTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGVBQWU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9ydW5uYWJsZS5qcz8yMWI5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBQZW5kaW5nID0gcmVxdWlyZSgnLi9wZW5kaW5nJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb2NoYTpydW5uYWJsZScpO1xudmFyIG1pbGxpc2Vjb25kcyA9IHJlcXVpcmUoJ21zJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCB7XG4gIGNyZWF0ZUludmFsaWRFeGNlcHRpb25FcnJvcixcbiAgY3JlYXRlTXVsdGlwbGVEb25lRXJyb3IsXG4gIGNyZWF0ZVRpbWVvdXRFcnJvclxufSA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cbi8qKlxuICogU2F2ZSB0aW1lciByZWZlcmVuY2VzIHRvIGF2b2lkIFNpbm9uIGludGVyZmVyaW5nIChzZWUgR0gtMjM3KS5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBEYXRlID0gZ2xvYmFsLkRhdGU7XG52YXIgc2V0VGltZW91dCA9IGdsb2JhbC5zZXRUaW1lb3V0O1xudmFyIGNsZWFyVGltZW91dCA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG52YXIgTUFYX1RJTUVPVVQgPSBNYXRoLnBvdygyLCAzMSkgLSAxO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJ1bm5hYmxlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJ1bm5hYmxlYCB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgZXh0ZXJuYWw6RXZlbnRFbWl0dGVyXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge1N0cmluZ30gdGl0bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIFJ1bm5hYmxlKHRpdGxlLCBmbikge1xuICB0aGlzLnRpdGxlID0gdGl0bGU7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5ib2R5ID0gKGZuIHx8ICcnKS50b1N0cmluZygpO1xuICB0aGlzLmFzeW5jID0gZm4gJiYgZm4ubGVuZ3RoO1xuICB0aGlzLnN5bmMgPSAhdGhpcy5hc3luYztcbiAgdGhpcy5fdGltZW91dCA9IDIwMDA7XG4gIHRoaXMuX3Nsb3cgPSA3NTtcbiAgdGhpcy5fcmV0cmllcyA9IC0xO1xuICB1dGlscy5hc3NpZ25OZXdNb2NoYUlEKHRoaXMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkJywge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB1dGlscy5nZXRNb2NoYUlEKHRoaXMpO1xuICAgIH1cbiAgfSk7XG4gIHRoaXMucmVzZXQoKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0IGZyb20gYEV2ZW50RW1pdHRlci5wcm90b3R5cGVgLlxuICovXG51dGlscy5pbmhlcml0cyhSdW5uYWJsZSwgRXZlbnRFbWl0dGVyKTtcblxuLyoqXG4gKiBSZXNldHMgdGhlIHN0YXRlIGluaXRpYWxseSBvciBmb3IgYSBuZXh0IHJ1bi5cbiAqL1xuUnVubmFibGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnRpbWVkT3V0ID0gZmFsc2U7XG4gIHRoaXMuX2N1cnJlbnRSZXRyeSA9IDA7XG4gIHRoaXMucGVuZGluZyA9IGZhbHNlO1xuICBkZWxldGUgdGhpcy5zdGF0ZTtcbiAgZGVsZXRlIHRoaXMuZXJyO1xufTtcblxuLyoqXG4gKiBHZXQgY3VycmVudCB0aW1lb3V0IHZhbHVlIGluIG1zZWNzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBjdXJyZW50IHRpbWVvdXQgdGhyZXNob2xkIHZhbHVlXG4gKi9cbi8qKlxuICogQHN1bW1hcnlcbiAqIFNldCB0aW1lb3V0IHRocmVzaG9sZCB2YWx1ZSAobXNlY3MpLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSBzdHJpbmcgYXJndW1lbnQgY2FuIHVzZSBzaG9ydGhhbmQgKGUuZy4sIFwiMnNcIikgYW5kIHdpbGwgYmUgY29udmVydGVkLlxuICogVGhlIHZhbHVlIHdpbGwgYmUgY2xhbXBlZCB0byByYW5nZSBbPGNvZGU+MDwvY29kZT4sIDxjb2RlPjJePHN1cD4zMTwvc3VwPi0xPC9jb2RlPl0uXG4gKiBJZiBjbGFtcGVkIHZhbHVlIG1hdGNoZXMgZWl0aGVyIHJhbmdlIGVuZHBvaW50LCB0aW1lb3V0cyB3aWxsIGJlIGRpc2FibGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93T3JXb3JrZXJHbG9iYWxTY29wZS9zZXRUaW1lb3V0I01heGltdW1fZGVsYXlfdmFsdWV9XG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG1zIC0gVGltZW91dCB0aHJlc2hvbGQgdmFsdWUuXG4gKiBAcmV0dXJucyB7UnVubmFibGV9IHRoaXNcbiAqIEBjaGFpbmFibGVcbiAqL1xuUnVubmFibGUucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAobXMpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBtcyA9PT0gJ3N0cmluZycpIHtcbiAgICBtcyA9IG1pbGxpc2Vjb25kcyhtcyk7XG4gIH1cblxuICAvLyBDbGFtcCB0byByYW5nZVxuICB2YXIgcmFuZ2UgPSBbMCwgTUFYX1RJTUVPVVRdO1xuICBtcyA9IHV0aWxzLmNsYW1wKG1zLCByYW5nZSk7XG5cbiAgLy8gc2VlICMxNjUyIGZvciByZWFzb25pbmdcbiAgaWYgKG1zID09PSByYW5nZVswXSB8fCBtcyA9PT0gcmFuZ2VbMV0pIHtcbiAgICB0aGlzLl90aW1lb3V0ID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl90aW1lb3V0ID0gbXM7XG4gIH1cbiAgZGVidWcoJ3RpbWVvdXQgJWQnLCB0aGlzLl90aW1lb3V0KTtcblxuICBpZiAodGhpcy50aW1lcikge1xuICAgIHRoaXMucmVzZXRUaW1lb3V0KCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBvciBnZXQgc2xvdyBgbXNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG1zXG4gKiBAcmV0dXJuIHtSdW5uYWJsZXxudW1iZXJ9IG1zIG9yIFJ1bm5hYmxlIGluc3RhbmNlLlxuICovXG5SdW5uYWJsZS5wcm90b3R5cGUuc2xvdyA9IGZ1bmN0aW9uIChtcykge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGggfHwgdHlwZW9mIG1zID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB0aGlzLl9zbG93O1xuICB9XG4gIGlmICh0eXBlb2YgbXMgPT09ICdzdHJpbmcnKSB7XG4gICAgbXMgPSBtaWxsaXNlY29uZHMobXMpO1xuICB9XG4gIGRlYnVnKCdzbG93ICVkJywgbXMpO1xuICB0aGlzLl9zbG93ID0gbXM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBIYWx0IGFuZCBtYXJrIGFzIHBlbmRpbmcuXG4gKlxuICogQG1lbWJlcm9mIE1vY2hhLlJ1bm5hYmxlXG4gKiBAcHVibGljXG4gKi9cblJ1bm5hYmxlLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnBlbmRpbmcgPSB0cnVlO1xuICB0aHJvdyBuZXcgUGVuZGluZygnc3luYyBza2lwOyBhYm9ydGluZyBleGVjdXRpb24nKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBydW5uYWJsZSBvciBpdHMgcGFyZW50IHN1aXRlIGlzIG1hcmtlZCBhcyBwZW5kaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblJ1bm5hYmxlLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnBlbmRpbmcgfHwgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmlzUGVuZGluZygpKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGlzIFJ1bm5hYmxlIGhhcyBmYWlsZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuUnVubmFibGUucHJvdG90eXBlLmlzRmFpbGVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIXRoaXMuaXNQZW5kaW5nKCkgJiYgdGhpcy5zdGF0ZSA9PT0gY29uc3RhbnRzLlNUQVRFX0ZBSUxFRDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGlzIFJ1bm5hYmxlIGhhcyBwYXNzZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuUnVubmFibGUucHJvdG90eXBlLmlzUGFzc2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIXRoaXMuaXNQZW5kaW5nKCkgJiYgdGhpcy5zdGF0ZSA9PT0gY29uc3RhbnRzLlNUQVRFX1BBU1NFRDtcbn07XG5cbi8qKlxuICogU2V0IG9yIGdldCBudW1iZXIgb2YgcmV0cmllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5SdW5uYWJsZS5wcm90b3R5cGUucmV0cmllcyA9IGZ1bmN0aW9uIChuKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLl9yZXRyaWVzO1xuICB9XG4gIHRoaXMuX3JldHJpZXMgPSBuO1xufTtcblxuLyoqXG4gKiBTZXQgb3IgZ2V0IGN1cnJlbnQgcmV0cnlcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5SdW5uYWJsZS5wcm90b3R5cGUuY3VycmVudFJldHJ5ID0gZnVuY3Rpb24gKG4pIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRSZXRyeTtcbiAgfVxuICB0aGlzLl9jdXJyZW50UmV0cnkgPSBuO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGZ1bGwgdGl0bGUgZ2VuZXJhdGVkIGJ5IHJlY3Vyc2l2ZWx5IGNvbmNhdGVuYXRpbmcgdGhlIHBhcmVudCdzXG4gKiBmdWxsIHRpdGxlLlxuICpcbiAqIEBtZW1iZXJvZiBNb2NoYS5SdW5uYWJsZVxuICogQHB1YmxpY1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5SdW5uYWJsZS5wcm90b3R5cGUuZnVsbFRpdGxlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy50aXRsZVBhdGgoKS5qb2luKCcgJyk7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgdGl0bGUgcGF0aCBnZW5lcmF0ZWQgYnkgY29uY2F0ZW5hdGluZyB0aGUgcGFyZW50J3MgdGl0bGUgcGF0aCB3aXRoIHRoZSB0aXRsZS5cbiAqXG4gKiBAbWVtYmVyb2YgTW9jaGEuUnVubmFibGVcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm4ge3N0cmluZ1tdfVxuICovXG5SdW5uYWJsZS5wcm90b3R5cGUudGl0bGVQYXRoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wYXJlbnQudGl0bGVQYXRoKCkuY29uY2F0KFt0aGlzLnRpdGxlXSk7XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSB0aW1lb3V0LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblJ1bm5hYmxlLnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIHRpbWVvdXQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuUnVubmFibGUucHJvdG90eXBlLnJlc2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbXMgPSB0aGlzLnRpbWVvdXQoKSB8fCBNQVhfVElNRU9VVDtcblxuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICB0aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGYudGltZW91dCgpID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGYuY2FsbGJhY2soc2VsZi5fdGltZW91dEVycm9yKG1zKSk7XG4gICAgc2VsZi50aW1lZE91dCA9IHRydWU7XG4gIH0sIG1zKTtcbn07XG5cbi8qKlxuICogU2V0IG9yIGdldCBhIGxpc3Qgb2Ygd2hpdGVsaXN0ZWQgZ2xvYmFscyBmb3IgdGhpcyB0ZXN0IHJ1bi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmdbXX0gZ2xvYmFsc1xuICovXG5SdW5uYWJsZS5wcm90b3R5cGUuZ2xvYmFscyA9IGZ1bmN0aW9uIChnbG9iYWxzKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLl9hbGxvd2VkR2xvYmFscztcbiAgfVxuICB0aGlzLl9hbGxvd2VkR2xvYmFscyA9IGdsb2JhbHM7XG59O1xuXG4vKipcbiAqIFJ1biB0aGUgdGVzdCBhbmQgaW52b2tlIGBmbihlcnIpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHByaXZhdGVcbiAqL1xuUnVubmFibGUucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzdGFydCA9IG5ldyBEYXRlKCk7XG4gIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgdmFyIGZpbmlzaGVkO1xuICB2YXIgZXJyb3JXYXNIYW5kbGVkID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuaXNQZW5kaW5nKCkpIHJldHVybiBmbigpO1xuXG4gIC8vIFNvbWV0aW1lcyB0aGUgY3R4IGV4aXN0cywgYnV0IGl0IGlzIG5vdCBydW5uYWJsZVxuICBpZiAoY3R4ICYmIGN0eC5ydW5uYWJsZSkge1xuICAgIGN0eC5ydW5uYWJsZSh0aGlzKTtcbiAgfVxuXG4gIC8vIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1xuICBmdW5jdGlvbiBtdWx0aXBsZShlcnIpIHtcbiAgICBpZiAoZXJyb3JXYXNIYW5kbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVycm9yV2FzSGFuZGxlZCA9IHRydWU7XG4gICAgc2VsZi5lbWl0KCdlcnJvcicsIGNyZWF0ZU11bHRpcGxlRG9uZUVycm9yKHNlbGYsIGVycikpO1xuICB9XG5cbiAgLy8gZmluaXNoZWRcbiAgZnVuY3Rpb24gZG9uZShlcnIpIHtcbiAgICB2YXIgbXMgPSBzZWxmLnRpbWVvdXQoKTtcbiAgICBpZiAoc2VsZi50aW1lZE91dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgcmV0dXJuIG11bHRpcGxlKGVycik7XG4gICAgfVxuXG4gICAgc2VsZi5jbGVhclRpbWVvdXQoKTtcbiAgICBzZWxmLmR1cmF0aW9uID0gbmV3IERhdGUoKSAtIHN0YXJ0O1xuICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICBpZiAoIWVyciAmJiBzZWxmLmR1cmF0aW9uID4gbXMgJiYgbXMgPiAwKSB7XG4gICAgICBlcnIgPSBzZWxmLl90aW1lb3V0RXJyb3IobXMpO1xuICAgIH1cbiAgICBmbihlcnIpO1xuICB9XG5cbiAgLy8gZm9yIC5yZXNldFRpbWVvdXQoKSBhbmQgUnVubmVyI3VuY2F1Z2h0KClcbiAgdGhpcy5jYWxsYmFjayA9IGRvbmU7XG5cbiAgaWYgKHRoaXMuZm4gJiYgdHlwZW9mIHRoaXMuZm4uY2FsbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGRvbmUoXG4gICAgICBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnQSBydW5uYWJsZSBtdXN0IGJlIHBhc3NlZCBhIGZ1bmN0aW9uIGFzIGl0cyBzZWNvbmQgYXJndW1lbnQuJ1xuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZXhwbGljaXQgYXN5bmMgd2l0aCBgZG9uZWAgYXJndW1lbnRcbiAgaWYgKHRoaXMuYXN5bmMpIHtcbiAgICB0aGlzLnJlc2V0VGltZW91dCgpO1xuXG4gICAgLy8gYWxsb3dzIHNraXAoKSB0byBiZSB1c2VkIGluIGFuIGV4cGxpY2l0IGFzeW5jIGNvbnRleHRcbiAgICB0aGlzLnNraXAgPSBmdW5jdGlvbiBhc3luY1NraXAoKSB7XG4gICAgICB0aGlzLnBlbmRpbmcgPSB0cnVlO1xuICAgICAgZG9uZSgpO1xuICAgICAgLy8gaGFsdCBleGVjdXRpb24sIHRoZSB1bmNhdWdodCBoYW5kbGVyIHdpbGwgaWdub3JlIHRoZSBmYWlsdXJlLlxuICAgICAgdGhyb3cgbmV3IFBlbmRpbmcoJ2FzeW5jIHNraXA7IGFib3J0aW5nIGV4ZWN1dGlvbicpO1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgY2FsbEZuQXN5bmModGhpcy5mbik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBoYW5kbGVzIGFzeW5jIHJ1bm5hYmxlcyB3aGljaCBhY3R1YWxseSBydW4gc3luY2hyb25vdXNseVxuICAgICAgZXJyb3JXYXNIYW5kbGVkID0gdHJ1ZTtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBQZW5kaW5nKSB7XG4gICAgICAgIHJldHVybjsgLy8gZG9uZSgpIGlzIGFscmVhZHkgY2FsbGVkIGluIHRoaXMuc2tpcCgpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYWxsb3dVbmNhdWdodCkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICBkb25lKFJ1bm5hYmxlLnRvVmFsdWVPckVycm9yKGVycikpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzeW5jIG9yIHByb21pc2UtcmV0dXJuaW5nXG4gIHRyeSB7XG4gICAgY2FsbEZuKHRoaXMuZm4pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvcldhc0hhbmRsZWQgPSB0cnVlO1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBQZW5kaW5nKSB7XG4gICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hbGxvd1VuY2F1Z2h0KSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIGRvbmUoUnVubmFibGUudG9WYWx1ZU9yRXJyb3IoZXJyKSk7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsRm4oZm4pIHtcbiAgICB2YXIgcmVzdWx0ID0gZm4uY2FsbChjdHgpO1xuICAgIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzZWxmLnJlc2V0VGltZW91dCgpO1xuICAgICAgcmVzdWx0LnRoZW4oXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgLy8gUmV0dXJuIG51bGwgc28gbGlicmFyaWVzIGxpa2UgYmx1ZWJpcmQgZG8gbm90IHdhcm4gYWJvdXRcbiAgICAgICAgICAvLyBzdWJzZXF1ZW50bHkgY29uc3RydWN0ZWQgUHJvbWlzZXMuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBkb25lKHJlYXNvbiB8fCBuZXcgRXJyb3IoJ1Byb21pc2UgcmVqZWN0ZWQgd2l0aCBubyBvciBmYWxzeSByZWFzb24nKSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzZWxmLmFzeW5jT25seSkge1xuICAgICAgICByZXR1cm4gZG9uZShcbiAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnLS1hc3luYy1vbmx5IG9wdGlvbiBpbiB1c2Ugd2l0aG91dCBkZWNsYXJpbmcgYGRvbmUoKWAgb3IgcmV0dXJuaW5nIGEgcHJvbWlzZSdcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGRvbmUoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsRm5Bc3luYyhmbikge1xuICAgIHZhciByZXN1bHQgPSBmbi5jYWxsKGN0eCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yIHx8IHRvU3RyaW5nLmNhbGwoZXJyKSA9PT0gJ1tvYmplY3QgRXJyb3JdJykge1xuICAgICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgfVxuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVycikgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbmUoXG4gICAgICAgICAgICBuZXcgRXJyb3IoJ2RvbmUoKSBpbnZva2VkIHdpdGggbm9uLUVycm9yOiAnICsgSlNPTi5zdHJpbmdpZnkoZXJyKSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignZG9uZSgpIGludm9rZWQgd2l0aCBub24tRXJyb3I6ICcgKyBlcnIpKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgJiYgdXRpbHMuaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoXG4gICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1Jlc29sdXRpb24gbWV0aG9kIGlzIG92ZXJzcGVjaWZpZWQuIFNwZWNpZnkgYSBjYWxsYmFjayAqb3IqIHJldHVybiBhIFByb21pc2U7IG5vdCBib3RoLidcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGRvbmUoKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBJbnN0YW50aWF0ZXMgYSBcInRpbWVvdXRcIiBlcnJvclxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBtcyAtIFRpbWVvdXQgKGluIG1pbGxpc2Vjb25kcylcbiAqIEByZXR1cm5zIHtFcnJvcn0gYSBcInRpbWVvdXRcIiBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuUnVubmFibGUucHJvdG90eXBlLl90aW1lb3V0RXJyb3IgPSBmdW5jdGlvbiAobXMpIHtcbiAgbGV0IG1zZyA9IGBUaW1lb3V0IG9mICR7bXN9bXMgZXhjZWVkZWQuIEZvciBhc3luYyB0ZXN0cyBhbmQgaG9va3MsIGVuc3VyZSBcImRvbmUoKVwiIGlzIGNhbGxlZDsgaWYgcmV0dXJuaW5nIGEgUHJvbWlzZSwgZW5zdXJlIGl0IHJlc29sdmVzLmA7XG4gIGlmICh0aGlzLmZpbGUpIHtcbiAgICBtc2cgKz0gJyAoJyArIHRoaXMuZmlsZSArICcpJztcbiAgfVxuICByZXR1cm4gY3JlYXRlVGltZW91dEVycm9yKG1zZywgbXMsIHRoaXMuZmlsZSk7XG59O1xuXG52YXIgY29uc3RhbnRzID0gdXRpbHMuZGVmaW5lQ29uc3RhbnRzKFxuICAvKipcbiAgICoge0BsaW5rIFJ1bm5hYmxlfS1yZWxhdGVkIGNvbnN0YW50cy5cbiAgICogQHB1YmxpY1xuICAgKiBAbWVtYmVyb2YgUnVubmFibGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEBzdGF0aWNcbiAgICogQGFsaWFzIGNvbnN0YW50c1xuICAgKiBAZW51bSB7c3RyaW5nfVxuICAgKi9cbiAge1xuICAgIC8qKlxuICAgICAqIFZhbHVlIG9mIGBzdGF0ZWAgcHJvcCB3aGVuIGEgYFJ1bm5hYmxlYCBoYXMgZmFpbGVkXG4gICAgICovXG4gICAgU1RBVEVfRkFJTEVEOiAnZmFpbGVkJyxcbiAgICAvKipcbiAgICAgKiBWYWx1ZSBvZiBgc3RhdGVgIHByb3Agd2hlbiBhIGBSdW5uYWJsZWAgaGFzIHBhc3NlZFxuICAgICAqL1xuICAgIFNUQVRFX1BBU1NFRDogJ3Bhc3NlZCcsXG4gICAgLyoqXG4gICAgICogVmFsdWUgb2YgYHN0YXRlYCBwcm9wIHdoZW4gYSBgUnVubmFibGVgIGhhcyBiZWVuIHNraXBwZWQgYnkgdXNlclxuICAgICAqL1xuICAgIFNUQVRFX1BFTkRJTkc6ICdwZW5kaW5nJ1xuICB9XG4pO1xuXG4vKipcbiAqIEdpdmVuIGB2YWx1ZWAsIHJldHVybiBpZGVudGl0eSBpZiB0cnV0aHksIG90aGVyd2lzZSBjcmVhdGUgYW4gXCJpbnZhbGlkIGV4Y2VwdGlvblwiIGVycm9yIGFuZCByZXR1cm4gdGhhdC5cbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSAtIFZhbHVlIHRvIHJldHVybiwgaWYgcHJlc2VudFxuICogQHJldHVybnMgeyp8RXJyb3J9IGB2YWx1ZWAsIG90aGVyd2lzZSBhbiBgRXJyb3JgXG4gKiBAcHJpdmF0ZVxuICovXG5SdW5uYWJsZS50b1ZhbHVlT3JFcnJvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlIHx8XG4gICAgY3JlYXRlSW52YWxpZEV4Y2VwdGlvbkVycm9yKFxuICAgICAgJ1J1bm5hYmxlIGZhaWxlZCB3aXRoIGZhbHN5IG9yIHVuZGVmaW5lZCBleGNlcHRpb24uIFBsZWFzZSB0aHJvdyBhbiBFcnJvciBpbnN0ZWFkLicsXG4gICAgICB2YWx1ZVxuICAgIClcbiAgKTtcbn07XG5cblJ1bm5hYmxlLmNvbnN0YW50cyA9IGNvbnN0YW50cztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/runnable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/runner.js":
/*!******************************************!*\
  !*** ./node_modules/mocha/lib/runner.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n * Module dependencies.\n * @private\n */\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar Pending = __webpack_require__(/*! ./pending */ \"(ssr)/./node_modules/mocha/lib/pending.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\");\nvar debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")('mocha:runner');\nvar Runnable = __webpack_require__(/*! ./runnable */ \"(ssr)/./node_modules/mocha/lib/runnable.js\");\nvar Suite = __webpack_require__(/*! ./suite */ \"(ssr)/./node_modules/mocha/lib/suite.js\");\nvar HOOK_TYPE_BEFORE_EACH = Suite.constants.HOOK_TYPE_BEFORE_EACH;\nvar HOOK_TYPE_AFTER_EACH = Suite.constants.HOOK_TYPE_AFTER_EACH;\nvar HOOK_TYPE_AFTER_ALL = Suite.constants.HOOK_TYPE_AFTER_ALL;\nvar HOOK_TYPE_BEFORE_ALL = Suite.constants.HOOK_TYPE_BEFORE_ALL;\nvar EVENT_ROOT_SUITE_RUN = Suite.constants.EVENT_ROOT_SUITE_RUN;\nvar STATE_FAILED = Runnable.constants.STATE_FAILED;\nvar STATE_PASSED = Runnable.constants.STATE_PASSED;\nvar STATE_PENDING = Runnable.constants.STATE_PENDING;\nvar stackFilter = utils.stackTraceFilter();\nvar stringify = utils.stringify;\n\nconst {\n  createInvalidExceptionError,\n  createUnsupportedError,\n  createFatalError,\n  isMochaError,\n  constants: errorConstants\n} = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/mocha/lib/errors.js\");\n\n/**\n * Non-enumerable globals.\n * @private\n * @readonly\n */\nvar globals = [\n  'setTimeout',\n  'clearTimeout',\n  'setInterval',\n  'clearInterval',\n  'XMLHttpRequest',\n  'Date',\n  'setImmediate',\n  'clearImmediate'\n];\n\nvar constants = utils.defineConstants(\n  /**\n   * {@link Runner}-related constants.\n   * @public\n   * @memberof Runner\n   * @readonly\n   * @alias constants\n   * @static\n   * @enum {string}\n   */\n  {\n    /**\n     * Emitted when {@link Hook} execution begins\n     */\n    EVENT_HOOK_BEGIN: 'hook',\n    /**\n     * Emitted when {@link Hook} execution ends\n     */\n    EVENT_HOOK_END: 'hook end',\n    /**\n     * Emitted when Root {@link Suite} execution begins (all files have been parsed and hooks/tests are ready for execution)\n     */\n    EVENT_RUN_BEGIN: 'start',\n    /**\n     * Emitted when Root {@link Suite} execution has been delayed via `delay` option\n     */\n    EVENT_DELAY_BEGIN: 'waiting',\n    /**\n     * Emitted when delayed Root {@link Suite} execution is triggered by user via `global.run()`\n     */\n    EVENT_DELAY_END: 'ready',\n    /**\n     * Emitted when Root {@link Suite} execution ends\n     */\n    EVENT_RUN_END: 'end',\n    /**\n     * Emitted when {@link Suite} execution begins\n     */\n    EVENT_SUITE_BEGIN: 'suite',\n    /**\n     * Emitted when {@link Suite} execution ends\n     */\n    EVENT_SUITE_END: 'suite end',\n    /**\n     * Emitted when {@link Test} execution begins\n     */\n    EVENT_TEST_BEGIN: 'test',\n    /**\n     * Emitted when {@link Test} execution ends\n     */\n    EVENT_TEST_END: 'test end',\n    /**\n     * Emitted when {@link Test} execution fails\n     */\n    EVENT_TEST_FAIL: 'fail',\n    /**\n     * Emitted when {@link Test} execution succeeds\n     */\n    EVENT_TEST_PASS: 'pass',\n    /**\n     * Emitted when {@link Test} becomes pending\n     */\n    EVENT_TEST_PENDING: 'pending',\n    /**\n     * Emitted when {@link Test} execution has failed, but will retry\n     */\n    EVENT_TEST_RETRY: 'retry',\n    /**\n     * Initial state of Runner\n     */\n    STATE_IDLE: 'idle',\n    /**\n     * State set to this value when the Runner has started running\n     */\n    STATE_RUNNING: 'running',\n    /**\n     * State set to this value when the Runner has stopped\n     */\n    STATE_STOPPED: 'stopped'\n  }\n);\n\nclass Runner extends EventEmitter {\n  /**\n   * Initialize a `Runner` at the Root {@link Suite}, which represents a hierarchy of {@link Suite|Suites} and {@link Test|Tests}.\n   *\n   * @extends external:EventEmitter\n   * @public\n   * @class\n   * @param {Suite} suite - Root suite\n   * @param {Object} [opts] - Settings object\n   * @param {boolean} [opts.cleanReferencesAfterRun] - Whether to clean references to test fns and hooks when a suite is done.\n   * @param {boolean} [opts.delay] - Whether to delay execution of root suite until ready.\n   * @param {boolean} [opts.dryRun] - Whether to report tests without running them.\n   * @param {boolean} [opts.failZero] - Whether to fail test run if zero tests encountered.\n   */\n  constructor(suite, opts = {}) {\n    super();\n\n    var self = this;\n    this._globals = [];\n    this._abort = false;\n    this.suite = suite;\n    this._opts = opts;\n    this.state = constants.STATE_IDLE;\n    this.total = suite.total();\n    this.failures = 0;\n    /**\n     * @type {Map<EventEmitter,Map<string,Set<EventListener>>>}\n     */\n    this._eventListeners = new Map();\n    this.on(constants.EVENT_TEST_END, function (test) {\n      if (test.type === 'test' && test.retriedTest() && test.parent) {\n        var idx =\n          test.parent.tests && test.parent.tests.indexOf(test.retriedTest());\n        if (idx > -1) test.parent.tests[idx] = test;\n      }\n      self.checkGlobals(test);\n    });\n    this.on(constants.EVENT_HOOK_END, function (hook) {\n      self.checkGlobals(hook);\n    });\n    this._defaultGrep = /.*/;\n    this.grep(this._defaultGrep);\n    this.globals(this.globalProps());\n\n    this.uncaught = this._uncaught.bind(this);\n    this.unhandled = (reason, promise) => {\n      if (isMochaError(reason)) {\n        debug(\n          'trapped unhandled rejection coming out of Mocha; forwarding to uncaught handler:',\n          reason\n        );\n        this.uncaught(reason);\n      } else {\n        debug(\n          'trapped unhandled rejection from (probably) user code; re-emitting on process'\n        );\n        this._removeEventListener(\n          process,\n          'unhandledRejection',\n          this.unhandled\n        );\n        try {\n          process.emit('unhandledRejection', reason, promise);\n        } finally {\n          this._addEventListener(process, 'unhandledRejection', this.unhandled);\n        }\n      }\n    };\n  }\n}\n\n/**\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\n *\n * @param {Function} fn\n * @private\n */\nRunner.immediately = global.setImmediate || process.nextTick;\n\n/**\n * Replacement for `target.on(eventName, listener)` that does bookkeeping to remove them when this runner instance is disposed.\n * @param {EventEmitter} target - The `EventEmitter`\n * @param {string} eventName - The event name\n * @param {string} fn - Listener function\n * @private\n */\nRunner.prototype._addEventListener = function (target, eventName, listener) {\n  debug(\n    '_addEventListener(): adding for event %s; %d current listeners',\n    eventName,\n    target.listenerCount(eventName)\n  );\n  /* istanbul ignore next */\n  if (\n    this._eventListeners.has(target) &&\n    this._eventListeners.get(target).has(eventName) &&\n    this._eventListeners.get(target).get(eventName).has(listener)\n  ) {\n    debug(\n      'warning: tried to attach duplicate event listener for %s',\n      eventName\n    );\n    return;\n  }\n  target.on(eventName, listener);\n  const targetListeners = this._eventListeners.has(target)\n    ? this._eventListeners.get(target)\n    : new Map();\n  const targetEventListeners = targetListeners.has(eventName)\n    ? targetListeners.get(eventName)\n    : new Set();\n  targetEventListeners.add(listener);\n  targetListeners.set(eventName, targetEventListeners);\n  this._eventListeners.set(target, targetListeners);\n};\n\n/**\n * Replacement for `target.removeListener(eventName, listener)` that also updates the bookkeeping.\n * @param {EventEmitter} target - The `EventEmitter`\n * @param {string} eventName - The event name\n * @param {function} listener - Listener function\n * @private\n */\nRunner.prototype._removeEventListener = function (target, eventName, listener) {\n  target.removeListener(eventName, listener);\n\n  if (this._eventListeners.has(target)) {\n    const targetListeners = this._eventListeners.get(target);\n    if (targetListeners.has(eventName)) {\n      const targetEventListeners = targetListeners.get(eventName);\n      targetEventListeners.delete(listener);\n      if (!targetEventListeners.size) {\n        targetListeners.delete(eventName);\n      }\n    }\n    if (!targetListeners.size) {\n      this._eventListeners.delete(target);\n    }\n  } else {\n    debug('trying to remove listener for untracked object %s', target);\n  }\n};\n\n/**\n * Removes all event handlers set during a run on this instance.\n * Remark: this does _not_ clean/dispose the tests or suites themselves.\n */\nRunner.prototype.dispose = function () {\n  this.removeAllListeners();\n  this._eventListeners.forEach((targetListeners, target) => {\n    targetListeners.forEach((targetEventListeners, eventName) => {\n      targetEventListeners.forEach(listener => {\n        target.removeListener(eventName, listener);\n      });\n    });\n  });\n  this._eventListeners.clear();\n};\n\n/**\n * Run tests with full titles matching `re`. Updates runner.total\n * with number of tests matched.\n *\n * @public\n * @memberof Runner\n * @param {RegExp} re\n * @param {boolean} invert\n * @return {Runner} Runner instance.\n */\nRunner.prototype.grep = function (re, invert) {\n  debug('grep(): setting to %s', re);\n  this._grep = re;\n  this._invert = invert;\n  this.total = this.grepTotal(this.suite);\n  return this;\n};\n\n/**\n * Returns the number of tests matching the grep search for the\n * given suite.\n *\n * @memberof Runner\n * @public\n * @param {Suite} suite\n * @return {number}\n */\nRunner.prototype.grepTotal = function (suite) {\n  var self = this;\n  var total = 0;\n\n  suite.eachTest(function (test) {\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (match) {\n      total++;\n    }\n  });\n\n  return total;\n};\n\n/**\n * Return a list of global properties.\n *\n * @return {Array}\n * @private\n */\nRunner.prototype.globalProps = function () {\n  var props = Object.keys(global);\n\n  // non-enumerables\n  for (var i = 0; i < globals.length; ++i) {\n    if (~props.indexOf(globals[i])) {\n      continue;\n    }\n    props.push(globals[i]);\n  }\n\n  return props;\n};\n\n/**\n * Allow the given `arr` of globals.\n *\n * @public\n * @memberof Runner\n * @param {Array} arr\n * @return {Runner} Runner instance.\n */\nRunner.prototype.globals = function (arr) {\n  if (!arguments.length) {\n    return this._globals;\n  }\n  debug('globals(): setting to %O', arr);\n  this._globals = this._globals.concat(arr);\n  return this;\n};\n\n/**\n * Check for global variable leaks.\n *\n * @private\n */\nRunner.prototype.checkGlobals = function (test) {\n  if (!this.checkLeaks) {\n    return;\n  }\n  var ok = this._globals;\n\n  var globals = this.globalProps();\n  var leaks;\n\n  if (test) {\n    ok = ok.concat(test._allowedGlobals || []);\n  }\n\n  if (this.prevGlobalsLength === globals.length) {\n    return;\n  }\n  this.prevGlobalsLength = globals.length;\n\n  leaks = filterLeaks(ok, globals);\n  this._globals = this._globals.concat(leaks);\n\n  if (leaks.length) {\n    var msg = `global leak(s) detected: ${leaks.map(e => `'${e}'`).join(', ')}`;\n    this.fail(test, new Error(msg));\n  }\n};\n\n/**\n * Fail the given `test`.\n *\n * If `test` is a hook, failures work in the following pattern:\n * - If bail, run corresponding `after each` and `after` hooks,\n *   then exit\n * - Failed `before` hook skips all tests in a suite and subsuites,\n *   but jumps to corresponding `after` hook\n * - Failed `before each` hook skips remaining tests in a\n *   suite and jumps to corresponding `after each` hook,\n *   which is run only once\n * - Failed `after` hook does not alter execution order\n * - Failed `after each` hook skips remaining tests in a\n *   suite and subsuites, but executes other `after each`\n *   hooks\n *\n * @private\n * @param {Runnable} test\n * @param {Error} err\n * @param {boolean} [force=false] - Whether to fail a pending test.\n */\nRunner.prototype.fail = function (test, err, force) {\n  force = force === true;\n  if (test.isPending() && !force) {\n    return;\n  }\n  if (this.state === constants.STATE_STOPPED) {\n    if (err.code === errorConstants.MULTIPLE_DONE) {\n      throw err;\n    }\n    throw createFatalError(\n      'Test failed after root suite execution completed!',\n      err\n    );\n  }\n\n  ++this.failures;\n  debug('total number of failures: %d', this.failures);\n  test.state = STATE_FAILED;\n\n  if (!isError(err)) {\n    err = thrown2Error(err);\n  }\n\n  // Filter the stack traces\n  if (!this.fullStackTrace) {\n    const alreadyFiltered = new Set();\n    let currentErr = err;\n\n    while (currentErr && currentErr.stack && !alreadyFiltered.has(currentErr)) {\n      alreadyFiltered.add(currentErr);\n\n      try {\n        currentErr.stack = stackFilter(currentErr.stack);\n      } catch (ignore) {\n        // some environments do not take kindly to monkeying with the stack\n      }\n\n      currentErr = currentErr.cause;\n    }\n  }\n\n  this.emit(constants.EVENT_TEST_FAIL, test, err);\n};\n\n/**\n * Run hook `name` callbacks and then invoke `fn()`.\n *\n * @private\n * @param {string} name\n * @param {Function} fn\n */\n\nRunner.prototype.hook = function (name, fn) {\n  if (this._opts.dryRun) return fn();\n\n  var suite = this.suite;\n  var hooks = suite.getHooks(name);\n  var self = this;\n\n  function next(i) {\n    var hook = hooks[i];\n    if (!hook) {\n      return fn();\n    }\n    self.currentRunnable = hook;\n\n    if (name === HOOK_TYPE_BEFORE_ALL) {\n      hook.ctx.currentTest = hook.parent.tests[0];\n    } else if (name === HOOK_TYPE_AFTER_ALL) {\n      hook.ctx.currentTest = hook.parent.tests[hook.parent.tests.length - 1];\n    } else {\n      hook.ctx.currentTest = self.test;\n    }\n\n    setHookTitle(hook);\n\n    hook.allowUncaught = self.allowUncaught;\n\n    self.emit(constants.EVENT_HOOK_BEGIN, hook);\n\n    if (!hook.listeners('error').length) {\n      self._addEventListener(hook, 'error', function (err) {\n        self.fail(hook, err);\n      });\n    }\n\n    hook.run(function cbHookRun(err) {\n      var testError = hook.error();\n      if (testError) {\n        self.fail(self.test, testError);\n      }\n      // conditional skip\n      if (hook.pending) {\n        if (name === HOOK_TYPE_AFTER_EACH) {\n          // TODO define and implement use case\n          if (self.test) {\n            self.test.pending = true;\n          }\n        } else if (name === HOOK_TYPE_BEFORE_EACH) {\n          if (self.test) {\n            self.test.pending = true;\n          }\n          self.emit(constants.EVENT_HOOK_END, hook);\n          hook.pending = false; // activates hook for next test\n          return fn(new Error('abort hookDown'));\n        } else if (name === HOOK_TYPE_BEFORE_ALL) {\n          suite.tests.forEach(function (test) {\n            test.pending = true;\n          });\n          suite.suites.forEach(function (suite) {\n            suite.pending = true;\n          });\n          hooks = [];\n        } else {\n          hook.pending = false;\n          var errForbid = createUnsupportedError('`this.skip` forbidden');\n          self.fail(hook, errForbid);\n          return fn(errForbid);\n        }\n      } else if (err) {\n        self.fail(hook, err);\n        // stop executing hooks, notify callee of hook err\n        return fn(err);\n      }\n      self.emit(constants.EVENT_HOOK_END, hook);\n      delete hook.ctx.currentTest;\n      setHookTitle(hook);\n      next(++i);\n    });\n\n    function setHookTitle(hook) {\n      hook.originalTitle = hook.originalTitle || hook.title;\n      if (hook.ctx && hook.ctx.currentTest) {\n        hook.title = `${hook.originalTitle} for \"${hook.ctx.currentTest.title}\"`;\n      } else {\n        var parentTitle;\n        if (hook.parent.title) {\n          parentTitle = hook.parent.title;\n        } else {\n          parentTitle = hook.parent.root ? '{root}' : '';\n        }\n        hook.title = `${hook.originalTitle} in \"${parentTitle}\"`;\n      }\n    }\n  }\n\n  Runner.immediately(function () {\n    next(0);\n  });\n};\n\n/**\n * Run hook `name` for the given array of `suites`\n * in order, and callback `fn(err, errSuite)`.\n *\n * @private\n * @param {string} name\n * @param {Array} suites\n * @param {Function} fn\n */\nRunner.prototype.hooks = function (name, suites, fn) {\n  var self = this;\n  var orig = this.suite;\n\n  function next(suite) {\n    self.suite = suite;\n\n    if (!suite) {\n      self.suite = orig;\n      return fn();\n    }\n\n    self.hook(name, function (err) {\n      if (err) {\n        var errSuite = self.suite;\n        self.suite = orig;\n        return fn(err, errSuite);\n      }\n\n      next(suites.pop());\n    });\n  }\n\n  next(suites.pop());\n};\n\n/**\n * Run 'afterEach' hooks from bottom up.\n *\n * @param {String} name\n * @param {Function} fn\n * @private\n */\nRunner.prototype.hookUp = function (name, fn) {\n  var suites = [this.suite].concat(this.parents()).reverse();\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Run 'beforeEach' hooks from top level down.\n *\n * @param {String} name\n * @param {Function} fn\n * @private\n */\nRunner.prototype.hookDown = function (name, fn) {\n  var suites = [this.suite].concat(this.parents());\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Return an array of parent Suites from\n * closest to furthest.\n *\n * @return {Array}\n * @private\n */\nRunner.prototype.parents = function () {\n  var suite = this.suite;\n  var suites = [];\n  while (suite.parent) {\n    suite = suite.parent;\n    suites.push(suite);\n  }\n  return suites;\n};\n\n/**\n * Run the current test and callback `fn(err)`.\n *\n * @param {Function} fn\n * @private\n */\nRunner.prototype.runTest = function (fn) {\n  if (this._opts.dryRun) return Runner.immediately(fn);\n\n  var self = this;\n  var test = this.test;\n\n  if (!test) {\n    return;\n  }\n\n  if (this.asyncOnly) {\n    test.asyncOnly = true;\n  }\n  this._addEventListener(test, 'error', function (err) {\n    self.fail(test, err);\n  });\n  if (this.allowUncaught) {\n    test.allowUncaught = true;\n    return test.run(fn);\n  }\n  try {\n    test.run(fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Run tests in the given `suite` and invoke the callback `fn()` when complete.\n *\n * @private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runTests = function (suite, fn) {\n  var self = this;\n  var tests = suite.tests.slice();\n  var test;\n\n  function hookErr(_, errSuite, after) {\n    // before/after Each hook for errSuite failed:\n    var orig = self.suite;\n\n    // for failed 'after each' hook start from errSuite parent,\n    // otherwise start from errSuite itself\n    self.suite = after ? errSuite.parent : errSuite;\n\n    if (self.suite) {\n      self.hookUp(HOOK_TYPE_AFTER_EACH, function (err2, errSuite2) {\n        self.suite = orig;\n        // some hooks may fail even now\n        if (err2) {\n          return hookErr(err2, errSuite2, true);\n        }\n        // report error suite\n        fn(errSuite);\n      });\n    } else {\n      // there is no need calling other 'after each' hooks\n      self.suite = orig;\n      fn(errSuite);\n    }\n  }\n\n  function next(err, errSuite) {\n    // if we bail after first err\n    if (self.failures && suite._bail) {\n      tests = [];\n    }\n\n    if (self._abort) {\n      return fn();\n    }\n\n    if (err) {\n      return hookErr(err, errSuite, true);\n    }\n\n    // next test\n    test = tests.shift();\n\n    // all done\n    if (!test) {\n      return fn();\n    }\n\n    // grep\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (!match) {\n      // Run immediately only if we have defined a grep. When we\n      // define a grep  It can cause maximum callstack error if\n      // the grep is doing a large recursive loop by neglecting\n      // all tests. The run immediately function also comes with\n      // a performance cost. So we don't want to run immediately\n      // if we run the whole test suite, because running the whole\n      // test suite don't do any immediate recursive loops. Thus,\n      // allowing a JS runtime to breathe.\n      if (self._grep !== self._defaultGrep) {\n        Runner.immediately(next);\n      } else {\n        next();\n      }\n      return;\n    }\n\n    // static skip, no hooks are executed\n    if (test.isPending()) {\n      if (self.forbidPending) {\n        self.fail(test, new Error('Pending test forbidden'), true);\n      } else {\n        test.state = STATE_PENDING;\n        self.emit(constants.EVENT_TEST_PENDING, test);\n      }\n      self.emit(constants.EVENT_TEST_END, test);\n      return next();\n    }\n\n    // execute test and hook(s)\n    self.emit(constants.EVENT_TEST_BEGIN, (self.test = test));\n    self.hookDown(HOOK_TYPE_BEFORE_EACH, function (err, errSuite) {\n      // conditional skip within beforeEach\n      if (test.isPending()) {\n        if (self.forbidPending) {\n          self.fail(test, new Error('Pending test forbidden'), true);\n        } else {\n          test.state = STATE_PENDING;\n          self.emit(constants.EVENT_TEST_PENDING, test);\n        }\n        self.emit(constants.EVENT_TEST_END, test);\n        // skip inner afterEach hooks below errSuite level\n        var origSuite = self.suite;\n        self.suite = errSuite || self.suite;\n        return self.hookUp(HOOK_TYPE_AFTER_EACH, function (e, eSuite) {\n          self.suite = origSuite;\n          next(e, eSuite);\n        });\n      }\n      if (err) {\n        return hookErr(err, errSuite, false);\n      }\n      self.currentRunnable = self.test;\n      self.runTest(function (err) {\n        test = self.test;\n        // conditional skip within it\n        if (test.pending) {\n          if (self.forbidPending) {\n            self.fail(test, new Error('Pending test forbidden'), true);\n          } else {\n            test.state = STATE_PENDING;\n            self.emit(constants.EVENT_TEST_PENDING, test);\n          }\n          self.emit(constants.EVENT_TEST_END, test);\n          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n        } else if (err) {\n          var retry = test.currentRetry();\n          if (retry < test.retries()) {\n            var clonedTest = test.clone();\n            clonedTest.currentRetry(retry + 1);\n            tests.unshift(clonedTest);\n\n            self.emit(constants.EVENT_TEST_RETRY, test, err);\n\n            // Early return + hook trigger so that it doesn't\n            // increment the count wrong\n            return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n          } else {\n            self.fail(test, err);\n          }\n          self.emit(constants.EVENT_TEST_END, test);\n          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n        }\n\n        test.state = STATE_PASSED;\n        self.emit(constants.EVENT_TEST_PASS, test);\n        self.emit(constants.EVENT_TEST_END, test);\n        self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n      });\n    });\n  }\n\n  this.next = next;\n  this.hookErr = hookErr;\n  next();\n};\n\n/**\n * Run the given `suite` and invoke the callback `fn()` when complete.\n *\n * @private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runSuite = function (suite, fn) {\n  var i = 0;\n  var self = this;\n  var total = this.grepTotal(suite);\n\n  debug('runSuite(): running %s', suite.fullTitle());\n\n  if (!total || (self.failures && suite._bail)) {\n    debug('runSuite(): bailing');\n    return fn();\n  }\n\n  this.emit(constants.EVENT_SUITE_BEGIN, (this.suite = suite));\n\n  function next(errSuite) {\n    if (errSuite) {\n      // current suite failed on a hook from errSuite\n      if (errSuite === suite) {\n        // if errSuite is current suite\n        // continue to the next sibling suite\n        return done();\n      }\n      // errSuite is among the parents of current suite\n      // stop execution of errSuite and all sub-suites\n      return done(errSuite);\n    }\n\n    if (self._abort) {\n      return done();\n    }\n\n    var curr = suite.suites[i++];\n    if (!curr) {\n      return done();\n    }\n\n    // Avoid grep neglecting large number of tests causing a\n    // huge recursive loop and thus a maximum call stack error.\n    // See comment in `this.runTests()` for more information.\n    if (self._grep !== self._defaultGrep) {\n      Runner.immediately(function () {\n        self.runSuite(curr, next);\n      });\n    } else {\n      self.runSuite(curr, next);\n    }\n  }\n\n  function done(errSuite) {\n    self.suite = suite;\n    self.nextSuite = next;\n\n    // remove reference to test\n    delete self.test;\n\n    self.hook(HOOK_TYPE_AFTER_ALL, function () {\n      self.emit(constants.EVENT_SUITE_END, suite);\n      fn(errSuite);\n    });\n  }\n\n  this.nextSuite = next;\n\n  this.hook(HOOK_TYPE_BEFORE_ALL, function (err) {\n    if (err) {\n      return done();\n    }\n    self.runTests(suite, next);\n  });\n};\n\n/**\n * Handle uncaught exceptions within runner.\n *\n * This function is bound to the instance as `Runner#uncaught` at instantiation\n * time. It's intended to be listening on the `Process.uncaughtException` event.\n * In order to not leak EE listeners, we need to ensure no more than a single\n * `uncaughtException` listener exists per `Runner`.  The only way to do\n * this--because this function needs the context (and we don't have lambdas)--is\n * to use `Function.prototype.bind`. We need strict equality to unregister and\n * _only_ unregister the _one_ listener we set from the\n * `Process.uncaughtException` event; would be poor form to just remove\n * everything. See {@link Runner#run} for where the event listener is registered\n * and unregistered.\n * @param {Error} err - Some uncaught error\n * @private\n */\nRunner.prototype._uncaught = function (err) {\n  // this is defensive to prevent future developers from mis-calling this function.\n  // it's more likely that it'd be called with the incorrect context--say, the global\n  // `process` object--than it would to be called with a context that is not a \"subclass\"\n  // of `Runner`.\n  if (!(this instanceof Runner)) {\n    throw createFatalError(\n      'Runner#uncaught() called with invalid context',\n      this\n    );\n  }\n  if (err instanceof Pending) {\n    debug('uncaught(): caught a Pending');\n    return;\n  }\n  // browser does not exit script when throwing in global.onerror()\n  if (this.allowUncaught && !utils.isBrowser()) {\n    debug('uncaught(): bubbling exception due to --allow-uncaught');\n    throw err;\n  }\n\n  if (this.state === constants.STATE_STOPPED) {\n    debug('uncaught(): throwing after run has completed!');\n    throw err;\n  }\n\n  if (err) {\n    debug('uncaught(): got truthy exception %O', err);\n  } else {\n    debug('uncaught(): undefined/falsy exception');\n    err = createInvalidExceptionError(\n      'Caught falsy/undefined exception which would otherwise be uncaught. No stack trace found; try a debugger',\n      err\n    );\n  }\n\n  if (!isError(err)) {\n    err = thrown2Error(err);\n    debug('uncaught(): converted \"error\" %o to Error', err);\n  }\n  err.uncaught = true;\n\n  var runnable = this.currentRunnable;\n\n  if (!runnable) {\n    runnable = new Runnable('Uncaught error outside test suite');\n    debug('uncaught(): no current Runnable; created a phony one');\n    runnable.parent = this.suite;\n\n    if (this.state === constants.STATE_RUNNING) {\n      debug('uncaught(): failing gracefully');\n      this.fail(runnable, err);\n    } else {\n      // Can't recover from this failure\n      debug('uncaught(): test run has not yet started; unrecoverable');\n      this.emit(constants.EVENT_RUN_BEGIN);\n      this.fail(runnable, err);\n      this.emit(constants.EVENT_RUN_END);\n    }\n\n    return;\n  }\n\n  runnable.clearTimeout();\n\n  if (runnable.isFailed()) {\n    debug('uncaught(): Runnable has already failed');\n    // Ignore error if already failed\n    return;\n  } else if (runnable.isPending()) {\n    debug('uncaught(): pending Runnable wound up failing!');\n    // report 'pending test' retrospectively as failed\n    this.fail(runnable, err, true);\n    return;\n  }\n\n  // we cannot recover gracefully if a Runnable has already passed\n  // then fails asynchronously\n  if (runnable.isPassed()) {\n    debug('uncaught(): Runnable has already passed; bailing gracefully');\n    this.fail(runnable, err);\n    this.abort();\n  } else {\n    debug('uncaught(): forcing Runnable to complete with Error');\n    return runnable.callback(err);\n  }\n};\n\n/**\n * Run the root suite and invoke `fn(failures)`\n * on completion.\n *\n * @public\n * @memberof Runner\n * @param {Function} fn - Callback when finished\n * @param {Object} [opts] - For subclasses\n * @param {string[]} opts.files - Files to run\n * @param {Options} opts.options - command-line options\n * @returns {Runner} Runner instance.\n */\nRunner.prototype.run = function (fn, opts = {}) {\n  var rootSuite = this.suite;\n  var options = opts.options || {};\n\n  debug('run(): got options: %O', options);\n  fn = fn || function () {};\n\n  const end = () => {\n    if (!this.total && this._opts.failZero) this.failures = 1;\n\n    debug('run(): root suite completed; emitting %s', constants.EVENT_RUN_END);\n    this.emit(constants.EVENT_RUN_END);\n  };\n\n  const begin = () => {\n    debug('run(): emitting %s', constants.EVENT_RUN_BEGIN);\n    this.emit(constants.EVENT_RUN_BEGIN);\n    debug('run(): emitted %s', constants.EVENT_RUN_BEGIN);\n\n    this.runSuite(rootSuite, end);\n  };\n\n  const prepare = () => {\n    debug('run(): starting');\n    // If there is an `only` filter\n    if (rootSuite.hasOnly()) {\n      rootSuite.filterOnly();\n      debug('run(): filtered exclusive Runnables');\n    }\n    this.state = constants.STATE_RUNNING;\n    if (this._opts.delay) {\n      this.emit(constants.EVENT_DELAY_END);\n      debug('run(): \"delay\" ended');\n    }\n\n    return begin();\n  };\n\n  // references cleanup to avoid memory leaks\n  if (this._opts.cleanReferencesAfterRun) {\n    this.on(constants.EVENT_SUITE_END, suite => {\n      suite.cleanReferences();\n    });\n  }\n\n  // callback\n  this.on(constants.EVENT_RUN_END, function () {\n    this.state = constants.STATE_STOPPED;\n    debug('run(): emitted %s', constants.EVENT_RUN_END);\n    fn(this.failures);\n  });\n\n  this._removeEventListener(process, 'uncaughtException', this.uncaught);\n  this._removeEventListener(process, 'unhandledRejection', this.unhandled);\n  this._addEventListener(process, 'uncaughtException', this.uncaught);\n  this._addEventListener(process, 'unhandledRejection', this.unhandled);\n\n  if (this._opts.delay) {\n    // for reporters, I guess.\n    // might be nice to debounce some dots while we wait.\n    this.emit(constants.EVENT_DELAY_BEGIN, rootSuite);\n    rootSuite.once(EVENT_ROOT_SUITE_RUN, prepare);\n    debug('run(): waiting for green light due to --delay');\n  } else {\n    Runner.immediately(prepare);\n  }\n\n  return this;\n};\n\n/**\n * Toggle partial object linking behavior; used for building object references from\n * unique ID's. Does nothing in serial mode, because the object references already exist.\n * Subclasses can implement this (e.g., `ParallelBufferedRunner`)\n * @abstract\n * @param {boolean} [value] - If `true`, enable partial object linking, otherwise disable\n * @returns {Runner}\n * @chainable\n * @public\n * @example\n * // this reporter needs proper object references when run in parallel mode\n * class MyReporter() {\n *   constructor(runner) {\n *     this.runner.linkPartialObjects(true)\n *       .on(EVENT_SUITE_BEGIN, suite => {\n           // this Suite may be the same object...\n *       })\n *       .on(EVENT_TEST_BEGIN, test => {\n *         // ...as the `test.parent` property\n *       });\n *   }\n * }\n */\nRunner.prototype.linkPartialObjects = function (value) {\n  return this;\n};\n\n/*\n * Like {@link Runner#run}, but does not accept a callback and returns a `Promise` instead of a `Runner`.\n * This function cannot reject; an `unhandledRejection` event will bubble up to the `process` object instead.\n * @public\n * @memberof Runner\n * @param {Object} [opts] - Options for {@link Runner#run}\n * @returns {Promise<number>} Failure count\n */\nRunner.prototype.runAsync = async function runAsync(opts = {}) {\n  return new Promise(resolve => {\n    this.run(resolve, opts);\n  });\n};\n\n/**\n * Cleanly abort execution.\n *\n * @memberof Runner\n * @public\n * @return {Runner} Runner instance.\n */\nRunner.prototype.abort = function () {\n  debug('abort(): aborting');\n  this._abort = true;\n\n  return this;\n};\n\n/**\n * Returns `true` if Mocha is running in parallel mode.  For reporters.\n *\n * Subclasses should return an appropriate value.\n * @public\n * @returns {false}\n */\nRunner.prototype.isParallelMode = function isParallelMode() {\n  return false;\n};\n\n/**\n * Configures an alternate reporter for worker processes to use. Subclasses\n * using worker processes should implement this.\n * @public\n * @param {string} path - Absolute path to alternate reporter for worker processes to use\n * @returns {Runner}\n * @throws When in serial mode\n * @chainable\n * @abstract\n */\nRunner.prototype.workerReporter = function () {\n  throw createUnsupportedError('workerReporter() not supported in serial mode');\n};\n\n/**\n * Filter leaks with the given globals flagged as `ok`.\n *\n * @private\n * @param {Array} ok\n * @param {Array} globals\n * @return {Array}\n */\nfunction filterLeaks(ok, globals) {\n  return globals.filter(function (key) {\n    // Firefox and Chrome exposes iframes as index inside the window object\n    if (/^\\d+/.test(key)) {\n      return false;\n    }\n\n    // in firefox\n    // if runner runs in an iframe, this iframe's window.getInterface method\n    // not init at first it is assigned in some seconds\n    if (global.navigator && /^getInterface/.test(key)) {\n      return false;\n    }\n\n    // an iframe could be approached by window[iframeIndex]\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\n    if (global.navigator && /^\\d+/.test(key)) {\n      return false;\n    }\n\n    // Opera and IE expose global variables for HTML element IDs (issue #243)\n    if (/^mocha-/.test(key)) {\n      return false;\n    }\n\n    var matched = ok.filter(function (ok) {\n      if (~ok.indexOf('*')) {\n        return key.indexOf(ok.split('*')[0]) === 0;\n      }\n      return key === ok;\n    });\n    return !matched.length && (!global.navigator || key !== 'onerror');\n  });\n}\n\n/**\n * Check if argument is an instance of Error object or a duck-typed equivalent.\n *\n * @private\n * @param {Object} err - object to check\n * @param {string} err.message - error message\n * @returns {boolean}\n */\nfunction isError(err) {\n  return err instanceof Error || (err && typeof err.message === 'string');\n}\n\n/**\n *\n * Converts thrown non-extensible type into proper Error.\n *\n * @private\n * @param {*} thrown - Non-extensible type thrown by code\n * @return {Error}\n */\nfunction thrown2Error(err) {\n  return new Error(\n    `the ${utils.canonicalType(err)} ${stringify(\n      err\n    )} was thrown, throw an Error :)`\n  );\n}\n\nRunner.constants = constants;\n\n/**\n * Node.js' `EventEmitter`\n * @external EventEmitter\n * @see {@link https://nodejs.org/api/events.html#events_class_eventemitter}\n */\n\nmodule.exports = Runner;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3J1bm5lci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwREFBOEI7QUFDakQsY0FBYyxtQkFBTyxDQUFDLDREQUFXO0FBQ2pDLFlBQVksbUJBQU8sQ0FBQyx3REFBUztBQUM3QixZQUFZLG1CQUFPLENBQUMsc0RBQU87QUFDM0IsZUFBZSxtQkFBTyxDQUFDLDhEQUFZO0FBQ25DLFlBQVksbUJBQU8sQ0FBQyx3REFBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQywwREFBVTs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxxQkFB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVB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QUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQkFBMEIsRUFBRTtBQUN2QztBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3J1bm5lci5qcz8wZDc2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICogQHByaXZhdGVcbiAqL1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBQZW5kaW5nID0gcmVxdWlyZSgnLi9wZW5kaW5nJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb2NoYTpydW5uZXInKTtcbnZhciBSdW5uYWJsZSA9IHJlcXVpcmUoJy4vcnVubmFibGUnKTtcbnZhciBTdWl0ZSA9IHJlcXVpcmUoJy4vc3VpdGUnKTtcbnZhciBIT09LX1RZUEVfQkVGT1JFX0VBQ0ggPSBTdWl0ZS5jb25zdGFudHMuSE9PS19UWVBFX0JFRk9SRV9FQUNIO1xudmFyIEhPT0tfVFlQRV9BRlRFUl9FQUNIID0gU3VpdGUuY29uc3RhbnRzLkhPT0tfVFlQRV9BRlRFUl9FQUNIO1xudmFyIEhPT0tfVFlQRV9BRlRFUl9BTEwgPSBTdWl0ZS5jb25zdGFudHMuSE9PS19UWVBFX0FGVEVSX0FMTDtcbnZhciBIT09LX1RZUEVfQkVGT1JFX0FMTCA9IFN1aXRlLmNvbnN0YW50cy5IT09LX1RZUEVfQkVGT1JFX0FMTDtcbnZhciBFVkVOVF9ST09UX1NVSVRFX1JVTiA9IFN1aXRlLmNvbnN0YW50cy5FVkVOVF9ST09UX1NVSVRFX1JVTjtcbnZhciBTVEFURV9GQUlMRUQgPSBSdW5uYWJsZS5jb25zdGFudHMuU1RBVEVfRkFJTEVEO1xudmFyIFNUQVRFX1BBU1NFRCA9IFJ1bm5hYmxlLmNvbnN0YW50cy5TVEFURV9QQVNTRUQ7XG52YXIgU1RBVEVfUEVORElORyA9IFJ1bm5hYmxlLmNvbnN0YW50cy5TVEFURV9QRU5ESU5HO1xudmFyIHN0YWNrRmlsdGVyID0gdXRpbHMuc3RhY2tUcmFjZUZpbHRlcigpO1xudmFyIHN0cmluZ2lmeSA9IHV0aWxzLnN0cmluZ2lmeTtcblxuY29uc3Qge1xuICBjcmVhdGVJbnZhbGlkRXhjZXB0aW9uRXJyb3IsXG4gIGNyZWF0ZVVuc3VwcG9ydGVkRXJyb3IsXG4gIGNyZWF0ZUZhdGFsRXJyb3IsXG4gIGlzTW9jaGFFcnJvcixcbiAgY29uc3RhbnRzOiBlcnJvckNvbnN0YW50c1xufSA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cbi8qKlxuICogTm9uLWVudW1lcmFibGUgZ2xvYmFscy5cbiAqIEBwcml2YXRlXG4gKiBAcmVhZG9ubHlcbiAqL1xudmFyIGdsb2JhbHMgPSBbXG4gICdzZXRUaW1lb3V0JyxcbiAgJ2NsZWFyVGltZW91dCcsXG4gICdzZXRJbnRlcnZhbCcsXG4gICdjbGVhckludGVydmFsJyxcbiAgJ1hNTEh0dHBSZXF1ZXN0JyxcbiAgJ0RhdGUnLFxuICAnc2V0SW1tZWRpYXRlJyxcbiAgJ2NsZWFySW1tZWRpYXRlJ1xuXTtcblxudmFyIGNvbnN0YW50cyA9IHV0aWxzLmRlZmluZUNvbnN0YW50cyhcbiAgLyoqXG4gICAqIHtAbGluayBSdW5uZXJ9LXJlbGF0ZWQgY29uc3RhbnRzLlxuICAgKiBAcHVibGljXG4gICAqIEBtZW1iZXJvZiBSdW5uZXJcbiAgICogQHJlYWRvbmx5XG4gICAqIEBhbGlhcyBjb25zdGFudHNcbiAgICogQHN0YXRpY1xuICAgKiBAZW51bSB7c3RyaW5nfVxuICAgKi9cbiAge1xuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiB7QGxpbmsgSG9va30gZXhlY3V0aW9uIGJlZ2luc1xuICAgICAqL1xuICAgIEVWRU5UX0hPT0tfQkVHSU46ICdob29rJyxcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4ge0BsaW5rIEhvb2t9IGV4ZWN1dGlvbiBlbmRzXG4gICAgICovXG4gICAgRVZFTlRfSE9PS19FTkQ6ICdob29rIGVuZCcsXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIFJvb3Qge0BsaW5rIFN1aXRlfSBleGVjdXRpb24gYmVnaW5zIChhbGwgZmlsZXMgaGF2ZSBiZWVuIHBhcnNlZCBhbmQgaG9va3MvdGVzdHMgYXJlIHJlYWR5IGZvciBleGVjdXRpb24pXG4gICAgICovXG4gICAgRVZFTlRfUlVOX0JFR0lOOiAnc3RhcnQnLFxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBSb290IHtAbGluayBTdWl0ZX0gZXhlY3V0aW9uIGhhcyBiZWVuIGRlbGF5ZWQgdmlhIGBkZWxheWAgb3B0aW9uXG4gICAgICovXG4gICAgRVZFTlRfREVMQVlfQkVHSU46ICd3YWl0aW5nJyxcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gZGVsYXllZCBSb290IHtAbGluayBTdWl0ZX0gZXhlY3V0aW9uIGlzIHRyaWdnZXJlZCBieSB1c2VyIHZpYSBgZ2xvYmFsLnJ1bigpYFxuICAgICAqL1xuICAgIEVWRU5UX0RFTEFZX0VORDogJ3JlYWR5JyxcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gUm9vdCB7QGxpbmsgU3VpdGV9IGV4ZWN1dGlvbiBlbmRzXG4gICAgICovXG4gICAgRVZFTlRfUlVOX0VORDogJ2VuZCcsXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHtAbGluayBTdWl0ZX0gZXhlY3V0aW9uIGJlZ2luc1xuICAgICAqL1xuICAgIEVWRU5UX1NVSVRFX0JFR0lOOiAnc3VpdGUnLFxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiB7QGxpbmsgU3VpdGV9IGV4ZWN1dGlvbiBlbmRzXG4gICAgICovXG4gICAgRVZFTlRfU1VJVEVfRU5EOiAnc3VpdGUgZW5kJyxcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4ge0BsaW5rIFRlc3R9IGV4ZWN1dGlvbiBiZWdpbnNcbiAgICAgKi9cbiAgICBFVkVOVF9URVNUX0JFR0lOOiAndGVzdCcsXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHtAbGluayBUZXN0fSBleGVjdXRpb24gZW5kc1xuICAgICAqL1xuICAgIEVWRU5UX1RFU1RfRU5EOiAndGVzdCBlbmQnLFxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiB7QGxpbmsgVGVzdH0gZXhlY3V0aW9uIGZhaWxzXG4gICAgICovXG4gICAgRVZFTlRfVEVTVF9GQUlMOiAnZmFpbCcsXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHtAbGluayBUZXN0fSBleGVjdXRpb24gc3VjY2VlZHNcbiAgICAgKi9cbiAgICBFVkVOVF9URVNUX1BBU1M6ICdwYXNzJyxcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4ge0BsaW5rIFRlc3R9IGJlY29tZXMgcGVuZGluZ1xuICAgICAqL1xuICAgIEVWRU5UX1RFU1RfUEVORElORzogJ3BlbmRpbmcnLFxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiB7QGxpbmsgVGVzdH0gZXhlY3V0aW9uIGhhcyBmYWlsZWQsIGJ1dCB3aWxsIHJldHJ5XG4gICAgICovXG4gICAgRVZFTlRfVEVTVF9SRVRSWTogJ3JldHJ5JyxcbiAgICAvKipcbiAgICAgKiBJbml0aWFsIHN0YXRlIG9mIFJ1bm5lclxuICAgICAqL1xuICAgIFNUQVRFX0lETEU6ICdpZGxlJyxcbiAgICAvKipcbiAgICAgKiBTdGF0ZSBzZXQgdG8gdGhpcyB2YWx1ZSB3aGVuIHRoZSBSdW5uZXIgaGFzIHN0YXJ0ZWQgcnVubmluZ1xuICAgICAqL1xuICAgIFNUQVRFX1JVTk5JTkc6ICdydW5uaW5nJyxcbiAgICAvKipcbiAgICAgKiBTdGF0ZSBzZXQgdG8gdGhpcyB2YWx1ZSB3aGVuIHRoZSBSdW5uZXIgaGFzIHN0b3BwZWRcbiAgICAgKi9cbiAgICBTVEFURV9TVE9QUEVEOiAnc3RvcHBlZCdcbiAgfVxuKTtcblxuY2xhc3MgUnVubmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYSBgUnVubmVyYCBhdCB0aGUgUm9vdCB7QGxpbmsgU3VpdGV9LCB3aGljaCByZXByZXNlbnRzIGEgaGllcmFyY2h5IG9mIHtAbGluayBTdWl0ZXxTdWl0ZXN9IGFuZCB7QGxpbmsgVGVzdHxUZXN0c30uXG4gICAqXG4gICAqIEBleHRlbmRzIGV4dGVybmFsOkV2ZW50RW1pdHRlclxuICAgKiBAcHVibGljXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSAtIFJvb3Qgc3VpdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIFNldHRpbmdzIG9iamVjdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmNsZWFuUmVmZXJlbmNlc0FmdGVyUnVuXSAtIFdoZXRoZXIgdG8gY2xlYW4gcmVmZXJlbmNlcyB0byB0ZXN0IGZucyBhbmQgaG9va3Mgd2hlbiBhIHN1aXRlIGlzIGRvbmUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZGVsYXldIC0gV2hldGhlciB0byBkZWxheSBleGVjdXRpb24gb2Ygcm9vdCBzdWl0ZSB1bnRpbCByZWFkeS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5kcnlSdW5dIC0gV2hldGhlciB0byByZXBvcnQgdGVzdHMgd2l0aG91dCBydW5uaW5nIHRoZW0uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZmFpbFplcm9dIC0gV2hldGhlciB0byBmYWlsIHRlc3QgcnVuIGlmIHplcm8gdGVzdHMgZW5jb3VudGVyZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzdWl0ZSwgb3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9nbG9iYWxzID0gW107XG4gICAgdGhpcy5fYWJvcnQgPSBmYWxzZTtcbiAgICB0aGlzLnN1aXRlID0gc3VpdGU7XG4gICAgdGhpcy5fb3B0cyA9IG9wdHM7XG4gICAgdGhpcy5zdGF0ZSA9IGNvbnN0YW50cy5TVEFURV9JRExFO1xuICAgIHRoaXMudG90YWwgPSBzdWl0ZS50b3RhbCgpO1xuICAgIHRoaXMuZmFpbHVyZXMgPSAwO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8RXZlbnRFbWl0dGVyLE1hcDxzdHJpbmcsU2V0PEV2ZW50TGlzdGVuZXI+Pj59XG4gICAgICovXG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5vbihjb25zdGFudHMuRVZFTlRfVEVTVF9FTkQsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgICBpZiAodGVzdC50eXBlID09PSAndGVzdCcgJiYgdGVzdC5yZXRyaWVkVGVzdCgpICYmIHRlc3QucGFyZW50KSB7XG4gICAgICAgIHZhciBpZHggPVxuICAgICAgICAgIHRlc3QucGFyZW50LnRlc3RzICYmIHRlc3QucGFyZW50LnRlc3RzLmluZGV4T2YodGVzdC5yZXRyaWVkVGVzdCgpKTtcbiAgICAgICAgaWYgKGlkeCA+IC0xKSB0ZXN0LnBhcmVudC50ZXN0c1tpZHhdID0gdGVzdDtcbiAgICAgIH1cbiAgICAgIHNlbGYuY2hlY2tHbG9iYWxzKHRlc3QpO1xuICAgIH0pO1xuICAgIHRoaXMub24oY29uc3RhbnRzLkVWRU5UX0hPT0tfRU5ELCBmdW5jdGlvbiAoaG9vaykge1xuICAgICAgc2VsZi5jaGVja0dsb2JhbHMoaG9vayk7XG4gICAgfSk7XG4gICAgdGhpcy5fZGVmYXVsdEdyZXAgPSAvLiovO1xuICAgIHRoaXMuZ3JlcCh0aGlzLl9kZWZhdWx0R3JlcCk7XG4gICAgdGhpcy5nbG9iYWxzKHRoaXMuZ2xvYmFsUHJvcHMoKSk7XG5cbiAgICB0aGlzLnVuY2F1Z2h0ID0gdGhpcy5fdW5jYXVnaHQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnVuaGFuZGxlZCA9IChyZWFzb24sIHByb21pc2UpID0+IHtcbiAgICAgIGlmIChpc01vY2hhRXJyb3IocmVhc29uKSkge1xuICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICAndHJhcHBlZCB1bmhhbmRsZWQgcmVqZWN0aW9uIGNvbWluZyBvdXQgb2YgTW9jaGE7IGZvcndhcmRpbmcgdG8gdW5jYXVnaHQgaGFuZGxlcjonLFxuICAgICAgICAgIHJlYXNvblxuICAgICAgICApO1xuICAgICAgICB0aGlzLnVuY2F1Z2h0KHJlYXNvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICAndHJhcHBlZCB1bmhhbmRsZWQgcmVqZWN0aW9uIGZyb20gKHByb2JhYmx5KSB1c2VyIGNvZGU7IHJlLWVtaXR0aW5nIG9uIHByb2Nlc3MnXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgcHJvY2VzcyxcbiAgICAgICAgICAndW5oYW5kbGVkUmVqZWN0aW9uJyxcbiAgICAgICAgICB0aGlzLnVuaGFuZGxlZFxuICAgICAgICApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgcmVhc29uLCBwcm9taXNlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVyKHByb2Nlc3MsICd1bmhhbmRsZWRSZWplY3Rpb24nLCB0aGlzLnVuaGFuZGxlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogV3JhcHBlciBmb3Igc2V0SW1tZWRpYXRlLCBwcm9jZXNzLm5leHRUaWNrLCBvciBicm93c2VyIHBvbHlmaWxsLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcHJpdmF0ZVxuICovXG5SdW5uZXIuaW1tZWRpYXRlbHkgPSBnbG9iYWwuc2V0SW1tZWRpYXRlIHx8IHByb2Nlc3MubmV4dFRpY2s7XG5cbi8qKlxuICogUmVwbGFjZW1lbnQgZm9yIGB0YXJnZXQub24oZXZlbnROYW1lLCBsaXN0ZW5lcilgIHRoYXQgZG9lcyBib29ra2VlcGluZyB0byByZW1vdmUgdGhlbSB3aGVuIHRoaXMgcnVubmVyIGluc3RhbmNlIGlzIGRpc3Bvc2VkLlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IHRhcmdldCAtIFRoZSBgRXZlbnRFbWl0dGVyYFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIFRoZSBldmVudCBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gZm4gLSBMaXN0ZW5lciBmdW5jdGlvblxuICogQHByaXZhdGVcbiAqL1xuUnVubmVyLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgZGVidWcoXG4gICAgJ19hZGRFdmVudExpc3RlbmVyKCk6IGFkZGluZyBmb3IgZXZlbnQgJXM7ICVkIGN1cnJlbnQgbGlzdGVuZXJzJyxcbiAgICBldmVudE5hbWUsXG4gICAgdGFyZ2V0Lmxpc3RlbmVyQ291bnQoZXZlbnROYW1lKVxuICApO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoXG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMuaGFzKHRhcmdldCkgJiZcbiAgICB0aGlzLl9ldmVudExpc3RlbmVycy5nZXQodGFyZ2V0KS5oYXMoZXZlbnROYW1lKSAmJlxuICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzLmdldCh0YXJnZXQpLmdldChldmVudE5hbWUpLmhhcyhsaXN0ZW5lcilcbiAgKSB7XG4gICAgZGVidWcoXG4gICAgICAnd2FybmluZzogdHJpZWQgdG8gYXR0YWNoIGR1cGxpY2F0ZSBldmVudCBsaXN0ZW5lciBmb3IgJXMnLFxuICAgICAgZXZlbnROYW1lXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdGFyZ2V0Lm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICBjb25zdCB0YXJnZXRMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudExpc3RlbmVycy5oYXModGFyZ2V0KVxuICAgID8gdGhpcy5fZXZlbnRMaXN0ZW5lcnMuZ2V0KHRhcmdldClcbiAgICA6IG5ldyBNYXAoKTtcbiAgY29uc3QgdGFyZ2V0RXZlbnRMaXN0ZW5lcnMgPSB0YXJnZXRMaXN0ZW5lcnMuaGFzKGV2ZW50TmFtZSlcbiAgICA/IHRhcmdldExpc3RlbmVycy5nZXQoZXZlbnROYW1lKVxuICAgIDogbmV3IFNldCgpO1xuICB0YXJnZXRFdmVudExpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICB0YXJnZXRMaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgdGFyZ2V0RXZlbnRMaXN0ZW5lcnMpO1xuICB0aGlzLl9ldmVudExpc3RlbmVycy5zZXQodGFyZ2V0LCB0YXJnZXRMaXN0ZW5lcnMpO1xufTtcblxuLyoqXG4gKiBSZXBsYWNlbWVudCBmb3IgYHRhcmdldC5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKWAgdGhhdCBhbHNvIHVwZGF0ZXMgdGhlIGJvb2trZWVwaW5nLlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IHRhcmdldCAtIFRoZSBgRXZlbnRFbWl0dGVyYFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIFRoZSBldmVudCBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIExpc3RlbmVyIGZ1bmN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5SdW5uZXIucHJvdG90eXBlLl9yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICB0YXJnZXQucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG5cbiAgaWYgKHRoaXMuX2V2ZW50TGlzdGVuZXJzLmhhcyh0YXJnZXQpKSB7XG4gICAgY29uc3QgdGFyZ2V0TGlzdGVuZXJzID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnMuZ2V0KHRhcmdldCk7XG4gICAgaWYgKHRhcmdldExpc3RlbmVycy5oYXMoZXZlbnROYW1lKSkge1xuICAgICAgY29uc3QgdGFyZ2V0RXZlbnRMaXN0ZW5lcnMgPSB0YXJnZXRMaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICB0YXJnZXRFdmVudExpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgaWYgKCF0YXJnZXRFdmVudExpc3RlbmVycy5zaXplKSB7XG4gICAgICAgIHRhcmdldExpc3RlbmVycy5kZWxldGUoZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0YXJnZXRMaXN0ZW5lcnMuc2l6ZSkge1xuICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMuZGVsZXRlKHRhcmdldCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCd0cnlpbmcgdG8gcmVtb3ZlIGxpc3RlbmVyIGZvciB1bnRyYWNrZWQgb2JqZWN0ICVzJywgdGFyZ2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBldmVudCBoYW5kbGVycyBzZXQgZHVyaW5nIGEgcnVuIG9uIHRoaXMgaW5zdGFuY2UuXG4gKiBSZW1hcms6IHRoaXMgZG9lcyBfbm90XyBjbGVhbi9kaXNwb3NlIHRoZSB0ZXN0cyBvciBzdWl0ZXMgdGhlbXNlbHZlcy5cbiAqL1xuUnVubmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLl9ldmVudExpc3RlbmVycy5mb3JFYWNoKCh0YXJnZXRMaXN0ZW5lcnMsIHRhcmdldCkgPT4ge1xuICAgIHRhcmdldExpc3RlbmVycy5mb3JFYWNoKCh0YXJnZXRFdmVudExpc3RlbmVycywgZXZlbnROYW1lKSA9PiB7XG4gICAgICB0YXJnZXRFdmVudExpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICB0aGlzLl9ldmVudExpc3RlbmVycy5jbGVhcigpO1xufTtcblxuLyoqXG4gKiBSdW4gdGVzdHMgd2l0aCBmdWxsIHRpdGxlcyBtYXRjaGluZyBgcmVgLiBVcGRhdGVzIHJ1bm5lci50b3RhbFxuICogd2l0aCBudW1iZXIgb2YgdGVzdHMgbWF0Y2hlZC5cbiAqXG4gKiBAcHVibGljXG4gKiBAbWVtYmVyb2YgUnVubmVyXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW52ZXJ0XG4gKiBAcmV0dXJuIHtSdW5uZXJ9IFJ1bm5lciBpbnN0YW5jZS5cbiAqL1xuUnVubmVyLnByb3RvdHlwZS5ncmVwID0gZnVuY3Rpb24gKHJlLCBpbnZlcnQpIHtcbiAgZGVidWcoJ2dyZXAoKTogc2V0dGluZyB0byAlcycsIHJlKTtcbiAgdGhpcy5fZ3JlcCA9IHJlO1xuICB0aGlzLl9pbnZlcnQgPSBpbnZlcnQ7XG4gIHRoaXMudG90YWwgPSB0aGlzLmdyZXBUb3RhbCh0aGlzLnN1aXRlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiB0ZXN0cyBtYXRjaGluZyB0aGUgZ3JlcCBzZWFyY2ggZm9yIHRoZVxuICogZ2l2ZW4gc3VpdGUuXG4gKlxuICogQG1lbWJlcm9mIFJ1bm5lclxuICogQHB1YmxpY1xuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuUnVubmVyLnByb3RvdHlwZS5ncmVwVG90YWwgPSBmdW5jdGlvbiAoc3VpdGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdG90YWwgPSAwO1xuXG4gIHN1aXRlLmVhY2hUZXN0KGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgdmFyIG1hdGNoID0gc2VsZi5fZ3JlcC50ZXN0KHRlc3QuZnVsbFRpdGxlKCkpO1xuICAgIGlmIChzZWxmLl9pbnZlcnQpIHtcbiAgICAgIG1hdGNoID0gIW1hdGNoO1xuICAgIH1cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHRvdGFsKys7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdG90YWw7XG59O1xuXG4vKipcbiAqIFJldHVybiBhIGxpc3Qgb2YgZ2xvYmFsIHByb3BlcnRpZXMuXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5SdW5uZXIucHJvdG90eXBlLmdsb2JhbFByb3BzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcHJvcHMgPSBPYmplY3Qua2V5cyhnbG9iYWwpO1xuXG4gIC8vIG5vbi1lbnVtZXJhYmxlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGdsb2JhbHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAofnByb3BzLmluZGV4T2YoZ2xvYmFsc1tpXSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBwcm9wcy5wdXNoKGdsb2JhbHNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHByb3BzO1xufTtcblxuLyoqXG4gKiBBbGxvdyB0aGUgZ2l2ZW4gYGFycmAgb2YgZ2xvYmFscy5cbiAqXG4gKiBAcHVibGljXG4gKiBAbWVtYmVyb2YgUnVubmVyXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEByZXR1cm4ge1J1bm5lcn0gUnVubmVyIGluc3RhbmNlLlxuICovXG5SdW5uZXIucHJvdG90eXBlLmdsb2JhbHMgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLl9nbG9iYWxzO1xuICB9XG4gIGRlYnVnKCdnbG9iYWxzKCk6IHNldHRpbmcgdG8gJU8nLCBhcnIpO1xuICB0aGlzLl9nbG9iYWxzID0gdGhpcy5fZ2xvYmFscy5jb25jYXQoYXJyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENoZWNrIGZvciBnbG9iYWwgdmFyaWFibGUgbGVha3MuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuUnVubmVyLnByb3RvdHlwZS5jaGVja0dsb2JhbHMgPSBmdW5jdGlvbiAodGVzdCkge1xuICBpZiAoIXRoaXMuY2hlY2tMZWFrcykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb2sgPSB0aGlzLl9nbG9iYWxzO1xuXG4gIHZhciBnbG9iYWxzID0gdGhpcy5nbG9iYWxQcm9wcygpO1xuICB2YXIgbGVha3M7XG5cbiAgaWYgKHRlc3QpIHtcbiAgICBvayA9IG9rLmNvbmNhdCh0ZXN0Ll9hbGxvd2VkR2xvYmFscyB8fCBbXSk7XG4gIH1cblxuICBpZiAodGhpcy5wcmV2R2xvYmFsc0xlbmd0aCA9PT0gZ2xvYmFscy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5wcmV2R2xvYmFsc0xlbmd0aCA9IGdsb2JhbHMubGVuZ3RoO1xuXG4gIGxlYWtzID0gZmlsdGVyTGVha3Mob2ssIGdsb2JhbHMpO1xuICB0aGlzLl9nbG9iYWxzID0gdGhpcy5fZ2xvYmFscy5jb25jYXQobGVha3MpO1xuXG4gIGlmIChsZWFrcy5sZW5ndGgpIHtcbiAgICB2YXIgbXNnID0gYGdsb2JhbCBsZWFrKHMpIGRldGVjdGVkOiAke2xlYWtzLm1hcChlID0+IGAnJHtlfSdgKS5qb2luKCcsICcpfWA7XG4gICAgdGhpcy5mYWlsKHRlc3QsIG5ldyBFcnJvcihtc2cpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGYWlsIHRoZSBnaXZlbiBgdGVzdGAuXG4gKlxuICogSWYgYHRlc3RgIGlzIGEgaG9vaywgZmFpbHVyZXMgd29yayBpbiB0aGUgZm9sbG93aW5nIHBhdHRlcm46XG4gKiAtIElmIGJhaWwsIHJ1biBjb3JyZXNwb25kaW5nIGBhZnRlciBlYWNoYCBhbmQgYGFmdGVyYCBob29rcyxcbiAqICAgdGhlbiBleGl0XG4gKiAtIEZhaWxlZCBgYmVmb3JlYCBob29rIHNraXBzIGFsbCB0ZXN0cyBpbiBhIHN1aXRlIGFuZCBzdWJzdWl0ZXMsXG4gKiAgIGJ1dCBqdW1wcyB0byBjb3JyZXNwb25kaW5nIGBhZnRlcmAgaG9va1xuICogLSBGYWlsZWQgYGJlZm9yZSBlYWNoYCBob29rIHNraXBzIHJlbWFpbmluZyB0ZXN0cyBpbiBhXG4gKiAgIHN1aXRlIGFuZCBqdW1wcyB0byBjb3JyZXNwb25kaW5nIGBhZnRlciBlYWNoYCBob29rLFxuICogICB3aGljaCBpcyBydW4gb25seSBvbmNlXG4gKiAtIEZhaWxlZCBgYWZ0ZXJgIGhvb2sgZG9lcyBub3QgYWx0ZXIgZXhlY3V0aW9uIG9yZGVyXG4gKiAtIEZhaWxlZCBgYWZ0ZXIgZWFjaGAgaG9vayBza2lwcyByZW1haW5pbmcgdGVzdHMgaW4gYVxuICogICBzdWl0ZSBhbmQgc3Vic3VpdGVzLCBidXQgZXhlY3V0ZXMgb3RoZXIgYGFmdGVyIGVhY2hgXG4gKiAgIGhvb2tzXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UnVubmFibGV9IHRlc3RcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHBhcmFtIHtib29sZWFufSBbZm9yY2U9ZmFsc2VdIC0gV2hldGhlciB0byBmYWlsIGEgcGVuZGluZyB0ZXN0LlxuICovXG5SdW5uZXIucHJvdG90eXBlLmZhaWwgPSBmdW5jdGlvbiAodGVzdCwgZXJyLCBmb3JjZSkge1xuICBmb3JjZSA9IGZvcmNlID09PSB0cnVlO1xuICBpZiAodGVzdC5pc1BlbmRpbmcoKSAmJiAhZm9yY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHRoaXMuc3RhdGUgPT09IGNvbnN0YW50cy5TVEFURV9TVE9QUEVEKSB7XG4gICAgaWYgKGVyci5jb2RlID09PSBlcnJvckNvbnN0YW50cy5NVUxUSVBMRV9ET05FKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHRocm93IGNyZWF0ZUZhdGFsRXJyb3IoXG4gICAgICAnVGVzdCBmYWlsZWQgYWZ0ZXIgcm9vdCBzdWl0ZSBleGVjdXRpb24gY29tcGxldGVkIScsXG4gICAgICBlcnJcbiAgICApO1xuICB9XG5cbiAgKyt0aGlzLmZhaWx1cmVzO1xuICBkZWJ1ZygndG90YWwgbnVtYmVyIG9mIGZhaWx1cmVzOiAlZCcsIHRoaXMuZmFpbHVyZXMpO1xuICB0ZXN0LnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuXG4gIGlmICghaXNFcnJvcihlcnIpKSB7XG4gICAgZXJyID0gdGhyb3duMkVycm9yKGVycik7XG4gIH1cblxuICAvLyBGaWx0ZXIgdGhlIHN0YWNrIHRyYWNlc1xuICBpZiAoIXRoaXMuZnVsbFN0YWNrVHJhY2UpIHtcbiAgICBjb25zdCBhbHJlYWR5RmlsdGVyZWQgPSBuZXcgU2V0KCk7XG4gICAgbGV0IGN1cnJlbnRFcnIgPSBlcnI7XG5cbiAgICB3aGlsZSAoY3VycmVudEVyciAmJiBjdXJyZW50RXJyLnN0YWNrICYmICFhbHJlYWR5RmlsdGVyZWQuaGFzKGN1cnJlbnRFcnIpKSB7XG4gICAgICBhbHJlYWR5RmlsdGVyZWQuYWRkKGN1cnJlbnRFcnIpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjdXJyZW50RXJyLnN0YWNrID0gc3RhY2tGaWx0ZXIoY3VycmVudEVyci5zdGFjayk7XG4gICAgICB9IGNhdGNoIChpZ25vcmUpIHtcbiAgICAgICAgLy8gc29tZSBlbnZpcm9ubWVudHMgZG8gbm90IHRha2Uga2luZGx5IHRvIG1vbmtleWluZyB3aXRoIHRoZSBzdGFja1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50RXJyID0gY3VycmVudEVyci5jYXVzZTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVtaXQoY29uc3RhbnRzLkVWRU5UX1RFU1RfRkFJTCwgdGVzdCwgZXJyKTtcbn07XG5cbi8qKlxuICogUnVuIGhvb2sgYG5hbWVgIGNhbGxiYWNrcyBhbmQgdGhlbiBpbnZva2UgYGZuKClgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuXG5SdW5uZXIucHJvdG90eXBlLmhvb2sgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgaWYgKHRoaXMuX29wdHMuZHJ5UnVuKSByZXR1cm4gZm4oKTtcblxuICB2YXIgc3VpdGUgPSB0aGlzLnN1aXRlO1xuICB2YXIgaG9va3MgPSBzdWl0ZS5nZXRIb29rcyhuYW1lKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG5leHQoaSkge1xuICAgIHZhciBob29rID0gaG9va3NbaV07XG4gICAgaWYgKCFob29rKSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG4gICAgc2VsZi5jdXJyZW50UnVubmFibGUgPSBob29rO1xuXG4gICAgaWYgKG5hbWUgPT09IEhPT0tfVFlQRV9CRUZPUkVfQUxMKSB7XG4gICAgICBob29rLmN0eC5jdXJyZW50VGVzdCA9IGhvb2sucGFyZW50LnRlc3RzWzBdO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gSE9PS19UWVBFX0FGVEVSX0FMTCkge1xuICAgICAgaG9vay5jdHguY3VycmVudFRlc3QgPSBob29rLnBhcmVudC50ZXN0c1tob29rLnBhcmVudC50ZXN0cy5sZW5ndGggLSAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaG9vay5jdHguY3VycmVudFRlc3QgPSBzZWxmLnRlc3Q7XG4gICAgfVxuXG4gICAgc2V0SG9va1RpdGxlKGhvb2spO1xuXG4gICAgaG9vay5hbGxvd1VuY2F1Z2h0ID0gc2VsZi5hbGxvd1VuY2F1Z2h0O1xuXG4gICAgc2VsZi5lbWl0KGNvbnN0YW50cy5FVkVOVF9IT09LX0JFR0lOLCBob29rKTtcblxuICAgIGlmICghaG9vay5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoKSB7XG4gICAgICBzZWxmLl9hZGRFdmVudExpc3RlbmVyKGhvb2ssICdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgc2VsZi5mYWlsKGhvb2ssIGVycik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBob29rLnJ1bihmdW5jdGlvbiBjYkhvb2tSdW4oZXJyKSB7XG4gICAgICB2YXIgdGVzdEVycm9yID0gaG9vay5lcnJvcigpO1xuICAgICAgaWYgKHRlc3RFcnJvcikge1xuICAgICAgICBzZWxmLmZhaWwoc2VsZi50ZXN0LCB0ZXN0RXJyb3IpO1xuICAgICAgfVxuICAgICAgLy8gY29uZGl0aW9uYWwgc2tpcFxuICAgICAgaWYgKGhvb2sucGVuZGluZykge1xuICAgICAgICBpZiAobmFtZSA9PT0gSE9PS19UWVBFX0FGVEVSX0VBQ0gpIHtcbiAgICAgICAgICAvLyBUT0RPIGRlZmluZSBhbmQgaW1wbGVtZW50IHVzZSBjYXNlXG4gICAgICAgICAgaWYgKHNlbGYudGVzdCkge1xuICAgICAgICAgICAgc2VsZi50ZXN0LnBlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSBIT09LX1RZUEVfQkVGT1JFX0VBQ0gpIHtcbiAgICAgICAgICBpZiAoc2VsZi50ZXN0KSB7XG4gICAgICAgICAgICBzZWxmLnRlc3QucGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuZW1pdChjb25zdGFudHMuRVZFTlRfSE9PS19FTkQsIGhvb2spO1xuICAgICAgICAgIGhvb2sucGVuZGluZyA9IGZhbHNlOyAvLyBhY3RpdmF0ZXMgaG9vayBmb3IgbmV4dCB0ZXN0XG4gICAgICAgICAgcmV0dXJuIGZuKG5ldyBFcnJvcignYWJvcnQgaG9va0Rvd24nKSk7XG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gSE9PS19UWVBFX0JFRk9SRV9BTEwpIHtcbiAgICAgICAgICBzdWl0ZS50ZXN0cy5mb3JFYWNoKGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgICAgICAgICB0ZXN0LnBlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN1aXRlLnN1aXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdWl0ZSkge1xuICAgICAgICAgICAgc3VpdGUucGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaG9va3MgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBob29rLnBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgZXJyRm9yYmlkID0gY3JlYXRlVW5zdXBwb3J0ZWRFcnJvcignYHRoaXMuc2tpcGAgZm9yYmlkZGVuJyk7XG4gICAgICAgICAgc2VsZi5mYWlsKGhvb2ssIGVyckZvcmJpZCk7XG4gICAgICAgICAgcmV0dXJuIGZuKGVyckZvcmJpZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICAgIHNlbGYuZmFpbChob29rLCBlcnIpO1xuICAgICAgICAvLyBzdG9wIGV4ZWN1dGluZyBob29rcywgbm90aWZ5IGNhbGxlZSBvZiBob29rIGVyclxuICAgICAgICByZXR1cm4gZm4oZXJyKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW1pdChjb25zdGFudHMuRVZFTlRfSE9PS19FTkQsIGhvb2spO1xuICAgICAgZGVsZXRlIGhvb2suY3R4LmN1cnJlbnRUZXN0O1xuICAgICAgc2V0SG9va1RpdGxlKGhvb2spO1xuICAgICAgbmV4dCgrK2kpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gc2V0SG9va1RpdGxlKGhvb2spIHtcbiAgICAgIGhvb2sub3JpZ2luYWxUaXRsZSA9IGhvb2sub3JpZ2luYWxUaXRsZSB8fCBob29rLnRpdGxlO1xuICAgICAgaWYgKGhvb2suY3R4ICYmIGhvb2suY3R4LmN1cnJlbnRUZXN0KSB7XG4gICAgICAgIGhvb2sudGl0bGUgPSBgJHtob29rLm9yaWdpbmFsVGl0bGV9IGZvciBcIiR7aG9vay5jdHguY3VycmVudFRlc3QudGl0bGV9XCJgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBhcmVudFRpdGxlO1xuICAgICAgICBpZiAoaG9vay5wYXJlbnQudGl0bGUpIHtcbiAgICAgICAgICBwYXJlbnRUaXRsZSA9IGhvb2sucGFyZW50LnRpdGxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudFRpdGxlID0gaG9vay5wYXJlbnQucm9vdCA/ICd7cm9vdH0nIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgaG9vay50aXRsZSA9IGAke2hvb2sub3JpZ2luYWxUaXRsZX0gaW4gXCIke3BhcmVudFRpdGxlfVwiYDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBSdW5uZXIuaW1tZWRpYXRlbHkoZnVuY3Rpb24gKCkge1xuICAgIG5leHQoMCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSdW4gaG9vayBgbmFtZWAgZm9yIHRoZSBnaXZlbiBhcnJheSBvZiBgc3VpdGVzYFxuICogaW4gb3JkZXIsIGFuZCBjYWxsYmFjayBgZm4oZXJyLCBlcnJTdWl0ZSlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtBcnJheX0gc3VpdGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5SdW5uZXIucHJvdG90eXBlLmhvb2tzID0gZnVuY3Rpb24gKG5hbWUsIHN1aXRlcywgZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgb3JpZyA9IHRoaXMuc3VpdGU7XG5cbiAgZnVuY3Rpb24gbmV4dChzdWl0ZSkge1xuICAgIHNlbGYuc3VpdGUgPSBzdWl0ZTtcblxuICAgIGlmICghc3VpdGUpIHtcbiAgICAgIHNlbGYuc3VpdGUgPSBvcmlnO1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxuXG4gICAgc2VsZi5ob29rKG5hbWUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdmFyIGVyclN1aXRlID0gc2VsZi5zdWl0ZTtcbiAgICAgICAgc2VsZi5zdWl0ZSA9IG9yaWc7XG4gICAgICAgIHJldHVybiBmbihlcnIsIGVyclN1aXRlKTtcbiAgICAgIH1cblxuICAgICAgbmV4dChzdWl0ZXMucG9wKCkpO1xuICAgIH0pO1xuICB9XG5cbiAgbmV4dChzdWl0ZXMucG9wKCkpO1xufTtcblxuLyoqXG4gKiBSdW4gJ2FmdGVyRWFjaCcgaG9va3MgZnJvbSBib3R0b20gdXAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcHJpdmF0ZVxuICovXG5SdW5uZXIucHJvdG90eXBlLmhvb2tVcCA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICB2YXIgc3VpdGVzID0gW3RoaXMuc3VpdGVdLmNvbmNhdCh0aGlzLnBhcmVudHMoKSkucmV2ZXJzZSgpO1xuICB0aGlzLmhvb2tzKG5hbWUsIHN1aXRlcywgZm4pO1xufTtcblxuLyoqXG4gKiBSdW4gJ2JlZm9yZUVhY2gnIGhvb2tzIGZyb20gdG9wIGxldmVsIGRvd24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcHJpdmF0ZVxuICovXG5SdW5uZXIucHJvdG90eXBlLmhvb2tEb3duID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gIHZhciBzdWl0ZXMgPSBbdGhpcy5zdWl0ZV0uY29uY2F0KHRoaXMucGFyZW50cygpKTtcbiAgdGhpcy5ob29rcyhuYW1lLCBzdWl0ZXMsIGZuKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IG9mIHBhcmVudCBTdWl0ZXMgZnJvbVxuICogY2xvc2VzdCB0byBmdXJ0aGVzdC5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cblJ1bm5lci5wcm90b3R5cGUucGFyZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN1aXRlID0gdGhpcy5zdWl0ZTtcbiAgdmFyIHN1aXRlcyA9IFtdO1xuICB3aGlsZSAoc3VpdGUucGFyZW50KSB7XG4gICAgc3VpdGUgPSBzdWl0ZS5wYXJlbnQ7XG4gICAgc3VpdGVzLnB1c2goc3VpdGUpO1xuICB9XG4gIHJldHVybiBzdWl0ZXM7XG59O1xuXG4vKipcbiAqIFJ1biB0aGUgY3VycmVudCB0ZXN0IGFuZCBjYWxsYmFjayBgZm4oZXJyKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwcml2YXRlXG4gKi9cblJ1bm5lci5wcm90b3R5cGUucnVuVGVzdCA9IGZ1bmN0aW9uIChmbikge1xuICBpZiAodGhpcy5fb3B0cy5kcnlSdW4pIHJldHVybiBSdW5uZXIuaW1tZWRpYXRlbHkoZm4pO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHRlc3QgPSB0aGlzLnRlc3Q7XG5cbiAgaWYgKCF0ZXN0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuYXN5bmNPbmx5KSB7XG4gICAgdGVzdC5hc3luY09ubHkgPSB0cnVlO1xuICB9XG4gIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIodGVzdCwgJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYuZmFpbCh0ZXN0LCBlcnIpO1xuICB9KTtcbiAgaWYgKHRoaXMuYWxsb3dVbmNhdWdodCkge1xuICAgIHRlc3QuYWxsb3dVbmNhdWdodCA9IHRydWU7XG4gICAgcmV0dXJuIHRlc3QucnVuKGZuKTtcbiAgfVxuICB0cnkge1xuICAgIHRlc3QucnVuKGZuKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZm4oZXJyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSdW4gdGVzdHMgaW4gdGhlIGdpdmVuIGBzdWl0ZWAgYW5kIGludm9rZSB0aGUgY2FsbGJhY2sgYGZuKClgIHdoZW4gY29tcGxldGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5SdW5uZXIucHJvdG90eXBlLnJ1blRlc3RzID0gZnVuY3Rpb24gKHN1aXRlLCBmbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0ZXN0cyA9IHN1aXRlLnRlc3RzLnNsaWNlKCk7XG4gIHZhciB0ZXN0O1xuXG4gIGZ1bmN0aW9uIGhvb2tFcnIoXywgZXJyU3VpdGUsIGFmdGVyKSB7XG4gICAgLy8gYmVmb3JlL2FmdGVyIEVhY2ggaG9vayBmb3IgZXJyU3VpdGUgZmFpbGVkOlxuICAgIHZhciBvcmlnID0gc2VsZi5zdWl0ZTtcblxuICAgIC8vIGZvciBmYWlsZWQgJ2FmdGVyIGVhY2gnIGhvb2sgc3RhcnQgZnJvbSBlcnJTdWl0ZSBwYXJlbnQsXG4gICAgLy8gb3RoZXJ3aXNlIHN0YXJ0IGZyb20gZXJyU3VpdGUgaXRzZWxmXG4gICAgc2VsZi5zdWl0ZSA9IGFmdGVyID8gZXJyU3VpdGUucGFyZW50IDogZXJyU3VpdGU7XG5cbiAgICBpZiAoc2VsZi5zdWl0ZSkge1xuICAgICAgc2VsZi5ob29rVXAoSE9PS19UWVBFX0FGVEVSX0VBQ0gsIGZ1bmN0aW9uIChlcnIyLCBlcnJTdWl0ZTIpIHtcbiAgICAgICAgc2VsZi5zdWl0ZSA9IG9yaWc7XG4gICAgICAgIC8vIHNvbWUgaG9va3MgbWF5IGZhaWwgZXZlbiBub3dcbiAgICAgICAgaWYgKGVycjIpIHtcbiAgICAgICAgICByZXR1cm4gaG9va0VycihlcnIyLCBlcnJTdWl0ZTIsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlcG9ydCBlcnJvciBzdWl0ZVxuICAgICAgICBmbihlcnJTdWl0ZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhlcmUgaXMgbm8gbmVlZCBjYWxsaW5nIG90aGVyICdhZnRlciBlYWNoJyBob29rc1xuICAgICAgc2VsZi5zdWl0ZSA9IG9yaWc7XG4gICAgICBmbihlcnJTdWl0ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbmV4dChlcnIsIGVyclN1aXRlKSB7XG4gICAgLy8gaWYgd2UgYmFpbCBhZnRlciBmaXJzdCBlcnJcbiAgICBpZiAoc2VsZi5mYWlsdXJlcyAmJiBzdWl0ZS5fYmFpbCkge1xuICAgICAgdGVzdHMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fYWJvcnQpIHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH1cblxuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBob29rRXJyKGVyciwgZXJyU3VpdGUsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIG5leHQgdGVzdFxuICAgIHRlc3QgPSB0ZXN0cy5zaGlmdCgpO1xuXG4gICAgLy8gYWxsIGRvbmVcbiAgICBpZiAoIXRlc3QpIHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH1cblxuICAgIC8vIGdyZXBcbiAgICB2YXIgbWF0Y2ggPSBzZWxmLl9ncmVwLnRlc3QodGVzdC5mdWxsVGl0bGUoKSk7XG4gICAgaWYgKHNlbGYuX2ludmVydCkge1xuICAgICAgbWF0Y2ggPSAhbWF0Y2g7XG4gICAgfVxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIC8vIFJ1biBpbW1lZGlhdGVseSBvbmx5IGlmIHdlIGhhdmUgZGVmaW5lZCBhIGdyZXAuIFdoZW4gd2VcbiAgICAgIC8vIGRlZmluZSBhIGdyZXAg4oCUIEl0IGNhbiBjYXVzZSBtYXhpbXVtIGNhbGxzdGFjayBlcnJvciBpZlxuICAgICAgLy8gdGhlIGdyZXAgaXMgZG9pbmcgYSBsYXJnZSByZWN1cnNpdmUgbG9vcCBieSBuZWdsZWN0aW5nXG4gICAgICAvLyBhbGwgdGVzdHMuIFRoZSBydW4gaW1tZWRpYXRlbHkgZnVuY3Rpb24gYWxzbyBjb21lcyB3aXRoXG4gICAgICAvLyBhIHBlcmZvcm1hbmNlIGNvc3QuIFNvIHdlIGRvbid0IHdhbnQgdG8gcnVuIGltbWVkaWF0ZWx5XG4gICAgICAvLyBpZiB3ZSBydW4gdGhlIHdob2xlIHRlc3Qgc3VpdGUsIGJlY2F1c2UgcnVubmluZyB0aGUgd2hvbGVcbiAgICAgIC8vIHRlc3Qgc3VpdGUgZG9uJ3QgZG8gYW55IGltbWVkaWF0ZSByZWN1cnNpdmUgbG9vcHMuIFRodXMsXG4gICAgICAvLyBhbGxvd2luZyBhIEpTIHJ1bnRpbWUgdG8gYnJlYXRoZS5cbiAgICAgIGlmIChzZWxmLl9ncmVwICE9PSBzZWxmLl9kZWZhdWx0R3JlcCkge1xuICAgICAgICBSdW5uZXIuaW1tZWRpYXRlbHkobmV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc3RhdGljIHNraXAsIG5vIGhvb2tzIGFyZSBleGVjdXRlZFxuICAgIGlmICh0ZXN0LmlzUGVuZGluZygpKSB7XG4gICAgICBpZiAoc2VsZi5mb3JiaWRQZW5kaW5nKSB7XG4gICAgICAgIHNlbGYuZmFpbCh0ZXN0LCBuZXcgRXJyb3IoJ1BlbmRpbmcgdGVzdCBmb3JiaWRkZW4nKSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXN0LnN0YXRlID0gU1RBVEVfUEVORElORztcbiAgICAgICAgc2VsZi5lbWl0KGNvbnN0YW50cy5FVkVOVF9URVNUX1BFTkRJTkcsIHRlc3QpO1xuICAgICAgfVxuICAgICAgc2VsZi5lbWl0KGNvbnN0YW50cy5FVkVOVF9URVNUX0VORCwgdGVzdCk7XG4gICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH1cblxuICAgIC8vIGV4ZWN1dGUgdGVzdCBhbmQgaG9vayhzKVxuICAgIHNlbGYuZW1pdChjb25zdGFudHMuRVZFTlRfVEVTVF9CRUdJTiwgKHNlbGYudGVzdCA9IHRlc3QpKTtcbiAgICBzZWxmLmhvb2tEb3duKEhPT0tfVFlQRV9CRUZPUkVfRUFDSCwgZnVuY3Rpb24gKGVyciwgZXJyU3VpdGUpIHtcbiAgICAgIC8vIGNvbmRpdGlvbmFsIHNraXAgd2l0aGluIGJlZm9yZUVhY2hcbiAgICAgIGlmICh0ZXN0LmlzUGVuZGluZygpKSB7XG4gICAgICAgIGlmIChzZWxmLmZvcmJpZFBlbmRpbmcpIHtcbiAgICAgICAgICBzZWxmLmZhaWwodGVzdCwgbmV3IEVycm9yKCdQZW5kaW5nIHRlc3QgZm9yYmlkZGVuJyksIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRlc3Quc3RhdGUgPSBTVEFURV9QRU5ESU5HO1xuICAgICAgICAgIHNlbGYuZW1pdChjb25zdGFudHMuRVZFTlRfVEVTVF9QRU5ESU5HLCB0ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmVtaXQoY29uc3RhbnRzLkVWRU5UX1RFU1RfRU5ELCB0ZXN0KTtcbiAgICAgICAgLy8gc2tpcCBpbm5lciBhZnRlckVhY2ggaG9va3MgYmVsb3cgZXJyU3VpdGUgbGV2ZWxcbiAgICAgICAgdmFyIG9yaWdTdWl0ZSA9IHNlbGYuc3VpdGU7XG4gICAgICAgIHNlbGYuc3VpdGUgPSBlcnJTdWl0ZSB8fCBzZWxmLnN1aXRlO1xuICAgICAgICByZXR1cm4gc2VsZi5ob29rVXAoSE9PS19UWVBFX0FGVEVSX0VBQ0gsIGZ1bmN0aW9uIChlLCBlU3VpdGUpIHtcbiAgICAgICAgICBzZWxmLnN1aXRlID0gb3JpZ1N1aXRlO1xuICAgICAgICAgIG5leHQoZSwgZVN1aXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBob29rRXJyKGVyciwgZXJyU3VpdGUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuY3VycmVudFJ1bm5hYmxlID0gc2VsZi50ZXN0O1xuICAgICAgc2VsZi5ydW5UZXN0KGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGVzdCA9IHNlbGYudGVzdDtcbiAgICAgICAgLy8gY29uZGl0aW9uYWwgc2tpcCB3aXRoaW4gaXRcbiAgICAgICAgaWYgKHRlc3QucGVuZGluZykge1xuICAgICAgICAgIGlmIChzZWxmLmZvcmJpZFBlbmRpbmcpIHtcbiAgICAgICAgICAgIHNlbGYuZmFpbCh0ZXN0LCBuZXcgRXJyb3IoJ1BlbmRpbmcgdGVzdCBmb3JiaWRkZW4nKSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlc3Quc3RhdGUgPSBTVEFURV9QRU5ESU5HO1xuICAgICAgICAgICAgc2VsZi5lbWl0KGNvbnN0YW50cy5FVkVOVF9URVNUX1BFTkRJTkcsIHRlc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmVtaXQoY29uc3RhbnRzLkVWRU5UX1RFU1RfRU5ELCB0ZXN0KTtcbiAgICAgICAgICByZXR1cm4gc2VsZi5ob29rVXAoSE9PS19UWVBFX0FGVEVSX0VBQ0gsIG5leHQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgICAgIHZhciByZXRyeSA9IHRlc3QuY3VycmVudFJldHJ5KCk7XG4gICAgICAgICAgaWYgKHJldHJ5IDwgdGVzdC5yZXRyaWVzKCkpIHtcbiAgICAgICAgICAgIHZhciBjbG9uZWRUZXN0ID0gdGVzdC5jbG9uZSgpO1xuICAgICAgICAgICAgY2xvbmVkVGVzdC5jdXJyZW50UmV0cnkocmV0cnkgKyAxKTtcbiAgICAgICAgICAgIHRlc3RzLnVuc2hpZnQoY2xvbmVkVGVzdCk7XG5cbiAgICAgICAgICAgIHNlbGYuZW1pdChjb25zdGFudHMuRVZFTlRfVEVTVF9SRVRSWSwgdGVzdCwgZXJyKTtcblxuICAgICAgICAgICAgLy8gRWFybHkgcmV0dXJuICsgaG9vayB0cmlnZ2VyIHNvIHRoYXQgaXQgZG9lc24ndFxuICAgICAgICAgICAgLy8gaW5jcmVtZW50IHRoZSBjb3VudCB3cm9uZ1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaG9va1VwKEhPT0tfVFlQRV9BRlRFUl9FQUNILCBuZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5mYWlsKHRlc3QsIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuZW1pdChjb25zdGFudHMuRVZFTlRfVEVTVF9FTkQsIHRlc3QpO1xuICAgICAgICAgIHJldHVybiBzZWxmLmhvb2tVcChIT09LX1RZUEVfQUZURVJfRUFDSCwgbmV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXN0LnN0YXRlID0gU1RBVEVfUEFTU0VEO1xuICAgICAgICBzZWxmLmVtaXQoY29uc3RhbnRzLkVWRU5UX1RFU1RfUEFTUywgdGVzdCk7XG4gICAgICAgIHNlbGYuZW1pdChjb25zdGFudHMuRVZFTlRfVEVTVF9FTkQsIHRlc3QpO1xuICAgICAgICBzZWxmLmhvb2tVcChIT09LX1RZUEVfQUZURVJfRUFDSCwgbmV4dCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMubmV4dCA9IG5leHQ7XG4gIHRoaXMuaG9va0VyciA9IGhvb2tFcnI7XG4gIG5leHQoKTtcbn07XG5cbi8qKlxuICogUnVuIHRoZSBnaXZlbiBgc3VpdGVgIGFuZCBpbnZva2UgdGhlIGNhbGxiYWNrIGBmbigpYCB3aGVuIGNvbXBsZXRlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuUnVubmVyLnByb3RvdHlwZS5ydW5TdWl0ZSA9IGZ1bmN0aW9uIChzdWl0ZSwgZm4pIHtcbiAgdmFyIGkgPSAwO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0b3RhbCA9IHRoaXMuZ3JlcFRvdGFsKHN1aXRlKTtcblxuICBkZWJ1ZygncnVuU3VpdGUoKTogcnVubmluZyAlcycsIHN1aXRlLmZ1bGxUaXRsZSgpKTtcblxuICBpZiAoIXRvdGFsIHx8IChzZWxmLmZhaWx1cmVzICYmIHN1aXRlLl9iYWlsKSkge1xuICAgIGRlYnVnKCdydW5TdWl0ZSgpOiBiYWlsaW5nJyk7XG4gICAgcmV0dXJuIGZuKCk7XG4gIH1cblxuICB0aGlzLmVtaXQoY29uc3RhbnRzLkVWRU5UX1NVSVRFX0JFR0lOLCAodGhpcy5zdWl0ZSA9IHN1aXRlKSk7XG5cbiAgZnVuY3Rpb24gbmV4dChlcnJTdWl0ZSkge1xuICAgIGlmIChlcnJTdWl0ZSkge1xuICAgICAgLy8gY3VycmVudCBzdWl0ZSBmYWlsZWQgb24gYSBob29rIGZyb20gZXJyU3VpdGVcbiAgICAgIGlmIChlcnJTdWl0ZSA9PT0gc3VpdGUpIHtcbiAgICAgICAgLy8gaWYgZXJyU3VpdGUgaXMgY3VycmVudCBzdWl0ZVxuICAgICAgICAvLyBjb250aW51ZSB0byB0aGUgbmV4dCBzaWJsaW5nIHN1aXRlXG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICB9XG4gICAgICAvLyBlcnJTdWl0ZSBpcyBhbW9uZyB0aGUgcGFyZW50cyBvZiBjdXJyZW50IHN1aXRlXG4gICAgICAvLyBzdG9wIGV4ZWN1dGlvbiBvZiBlcnJTdWl0ZSBhbmQgYWxsIHN1Yi1zdWl0ZXNcbiAgICAgIHJldHVybiBkb25lKGVyclN1aXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fYWJvcnQpIHtcbiAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuXG4gICAgdmFyIGN1cnIgPSBzdWl0ZS5zdWl0ZXNbaSsrXTtcbiAgICBpZiAoIWN1cnIpIHtcbiAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuXG4gICAgLy8gQXZvaWQgZ3JlcCBuZWdsZWN0aW5nIGxhcmdlIG51bWJlciBvZiB0ZXN0cyBjYXVzaW5nIGFcbiAgICAvLyBodWdlIHJlY3Vyc2l2ZSBsb29wIGFuZCB0aHVzIGEgbWF4aW11bSBjYWxsIHN0YWNrIGVycm9yLlxuICAgIC8vIFNlZSBjb21tZW50IGluIGB0aGlzLnJ1blRlc3RzKClgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgIGlmIChzZWxmLl9ncmVwICE9PSBzZWxmLl9kZWZhdWx0R3JlcCkge1xuICAgICAgUnVubmVyLmltbWVkaWF0ZWx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5ydW5TdWl0ZShjdXJyLCBuZXh0KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnJ1blN1aXRlKGN1cnIsIG5leHQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbmUoZXJyU3VpdGUpIHtcbiAgICBzZWxmLnN1aXRlID0gc3VpdGU7XG4gICAgc2VsZi5uZXh0U3VpdGUgPSBuZXh0O1xuXG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byB0ZXN0XG4gICAgZGVsZXRlIHNlbGYudGVzdDtcblxuICAgIHNlbGYuaG9vayhIT09LX1RZUEVfQUZURVJfQUxMLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmVtaXQoY29uc3RhbnRzLkVWRU5UX1NVSVRFX0VORCwgc3VpdGUpO1xuICAgICAgZm4oZXJyU3VpdGUpO1xuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5uZXh0U3VpdGUgPSBuZXh0O1xuXG4gIHRoaXMuaG9vayhIT09LX1RZUEVfQkVGT1JFX0FMTCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuICAgIHNlbGYucnVuVGVzdHMoc3VpdGUsIG5leHQpO1xuICB9KTtcbn07XG5cbi8qKlxuICogSGFuZGxlIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgd2l0aGluIHJ1bm5lci5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGJvdW5kIHRvIHRoZSBpbnN0YW5jZSBhcyBgUnVubmVyI3VuY2F1Z2h0YCBhdCBpbnN0YW50aWF0aW9uXG4gKiB0aW1lLiBJdCdzIGludGVuZGVkIHRvIGJlIGxpc3RlbmluZyBvbiB0aGUgYFByb2Nlc3MudW5jYXVnaHRFeGNlcHRpb25gIGV2ZW50LlxuICogSW4gb3JkZXIgdG8gbm90IGxlYWsgRUUgbGlzdGVuZXJzLCB3ZSBuZWVkIHRvIGVuc3VyZSBubyBtb3JlIHRoYW4gYSBzaW5nbGVcbiAqIGB1bmNhdWdodEV4Y2VwdGlvbmAgbGlzdGVuZXIgZXhpc3RzIHBlciBgUnVubmVyYC4gIFRoZSBvbmx5IHdheSB0byBkb1xuICogdGhpcy0tYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRoZSBjb250ZXh0IChhbmQgd2UgZG9uJ3QgaGF2ZSBsYW1iZGFzKS0taXNcbiAqIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRgLiBXZSBuZWVkIHN0cmljdCBlcXVhbGl0eSB0byB1bnJlZ2lzdGVyIGFuZFxuICogX29ubHlfIHVucmVnaXN0ZXIgdGhlIF9vbmVfIGxpc3RlbmVyIHdlIHNldCBmcm9tIHRoZVxuICogYFByb2Nlc3MudW5jYXVnaHRFeGNlcHRpb25gIGV2ZW50OyB3b3VsZCBiZSBwb29yIGZvcm0gdG8ganVzdCByZW1vdmVcbiAqIGV2ZXJ5dGhpbmcuIFNlZSB7QGxpbmsgUnVubmVyI3J1bn0gZm9yIHdoZXJlIHRoZSBldmVudCBsaXN0ZW5lciBpcyByZWdpc3RlcmVkXG4gKiBhbmQgdW5yZWdpc3RlcmVkLlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gU29tZSB1bmNhdWdodCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuUnVubmVyLnByb3RvdHlwZS5fdW5jYXVnaHQgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIC8vIHRoaXMgaXMgZGVmZW5zaXZlIHRvIHByZXZlbnQgZnV0dXJlIGRldmVsb3BlcnMgZnJvbSBtaXMtY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICAvLyBpdCdzIG1vcmUgbGlrZWx5IHRoYXQgaXQnZCBiZSBjYWxsZWQgd2l0aCB0aGUgaW5jb3JyZWN0IGNvbnRleHQtLXNheSwgdGhlIGdsb2JhbFxuICAvLyBgcHJvY2Vzc2Agb2JqZWN0LS10aGFuIGl0IHdvdWxkIHRvIGJlIGNhbGxlZCB3aXRoIGEgY29udGV4dCB0aGF0IGlzIG5vdCBhIFwic3ViY2xhc3NcIlxuICAvLyBvZiBgUnVubmVyYC5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJ1bm5lcikpIHtcbiAgICB0aHJvdyBjcmVhdGVGYXRhbEVycm9yKFxuICAgICAgJ1J1bm5lciN1bmNhdWdodCgpIGNhbGxlZCB3aXRoIGludmFsaWQgY29udGV4dCcsXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxuICBpZiAoZXJyIGluc3RhbmNlb2YgUGVuZGluZykge1xuICAgIGRlYnVnKCd1bmNhdWdodCgpOiBjYXVnaHQgYSBQZW5kaW5nJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGJyb3dzZXIgZG9lcyBub3QgZXhpdCBzY3JpcHQgd2hlbiB0aHJvd2luZyBpbiBnbG9iYWwub25lcnJvcigpXG4gIGlmICh0aGlzLmFsbG93VW5jYXVnaHQgJiYgIXV0aWxzLmlzQnJvd3NlcigpKSB7XG4gICAgZGVidWcoJ3VuY2F1Z2h0KCk6IGJ1YmJsaW5nIGV4Y2VwdGlvbiBkdWUgdG8gLS1hbGxvdy11bmNhdWdodCcpO1xuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIGlmICh0aGlzLnN0YXRlID09PSBjb25zdGFudHMuU1RBVEVfU1RPUFBFRCkge1xuICAgIGRlYnVnKCd1bmNhdWdodCgpOiB0aHJvd2luZyBhZnRlciBydW4gaGFzIGNvbXBsZXRlZCEnKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cblxuICBpZiAoZXJyKSB7XG4gICAgZGVidWcoJ3VuY2F1Z2h0KCk6IGdvdCB0cnV0aHkgZXhjZXB0aW9uICVPJywgZXJyKTtcbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygndW5jYXVnaHQoKTogdW5kZWZpbmVkL2ZhbHN5IGV4Y2VwdGlvbicpO1xuICAgIGVyciA9IGNyZWF0ZUludmFsaWRFeGNlcHRpb25FcnJvcihcbiAgICAgICdDYXVnaHQgZmFsc3kvdW5kZWZpbmVkIGV4Y2VwdGlvbiB3aGljaCB3b3VsZCBvdGhlcndpc2UgYmUgdW5jYXVnaHQuIE5vIHN0YWNrIHRyYWNlIGZvdW5kOyB0cnkgYSBkZWJ1Z2dlcicsXG4gICAgICBlcnJcbiAgICApO1xuICB9XG5cbiAgaWYgKCFpc0Vycm9yKGVycikpIHtcbiAgICBlcnIgPSB0aHJvd24yRXJyb3IoZXJyKTtcbiAgICBkZWJ1ZygndW5jYXVnaHQoKTogY29udmVydGVkIFwiZXJyb3JcIiAlbyB0byBFcnJvcicsIGVycik7XG4gIH1cbiAgZXJyLnVuY2F1Z2h0ID0gdHJ1ZTtcblxuICB2YXIgcnVubmFibGUgPSB0aGlzLmN1cnJlbnRSdW5uYWJsZTtcblxuICBpZiAoIXJ1bm5hYmxlKSB7XG4gICAgcnVubmFibGUgPSBuZXcgUnVubmFibGUoJ1VuY2F1Z2h0IGVycm9yIG91dHNpZGUgdGVzdCBzdWl0ZScpO1xuICAgIGRlYnVnKCd1bmNhdWdodCgpOiBubyBjdXJyZW50IFJ1bm5hYmxlOyBjcmVhdGVkIGEgcGhvbnkgb25lJyk7XG4gICAgcnVubmFibGUucGFyZW50ID0gdGhpcy5zdWl0ZTtcblxuICAgIGlmICh0aGlzLnN0YXRlID09PSBjb25zdGFudHMuU1RBVEVfUlVOTklORykge1xuICAgICAgZGVidWcoJ3VuY2F1Z2h0KCk6IGZhaWxpbmcgZ3JhY2VmdWxseScpO1xuICAgICAgdGhpcy5mYWlsKHJ1bm5hYmxlLCBlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDYW4ndCByZWNvdmVyIGZyb20gdGhpcyBmYWlsdXJlXG4gICAgICBkZWJ1ZygndW5jYXVnaHQoKTogdGVzdCBydW4gaGFzIG5vdCB5ZXQgc3RhcnRlZDsgdW5yZWNvdmVyYWJsZScpO1xuICAgICAgdGhpcy5lbWl0KGNvbnN0YW50cy5FVkVOVF9SVU5fQkVHSU4pO1xuICAgICAgdGhpcy5mYWlsKHJ1bm5hYmxlLCBlcnIpO1xuICAgICAgdGhpcy5lbWl0KGNvbnN0YW50cy5FVkVOVF9SVU5fRU5EKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBydW5uYWJsZS5jbGVhclRpbWVvdXQoKTtcblxuICBpZiAocnVubmFibGUuaXNGYWlsZWQoKSkge1xuICAgIGRlYnVnKCd1bmNhdWdodCgpOiBSdW5uYWJsZSBoYXMgYWxyZWFkeSBmYWlsZWQnKTtcbiAgICAvLyBJZ25vcmUgZXJyb3IgaWYgYWxyZWFkeSBmYWlsZWRcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAocnVubmFibGUuaXNQZW5kaW5nKCkpIHtcbiAgICBkZWJ1ZygndW5jYXVnaHQoKTogcGVuZGluZyBSdW5uYWJsZSB3b3VuZCB1cCBmYWlsaW5nIScpO1xuICAgIC8vIHJlcG9ydCAncGVuZGluZyB0ZXN0JyByZXRyb3NwZWN0aXZlbHkgYXMgZmFpbGVkXG4gICAgdGhpcy5mYWlsKHJ1bm5hYmxlLCBlcnIsIHRydWUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHdlIGNhbm5vdCByZWNvdmVyIGdyYWNlZnVsbHkgaWYgYSBSdW5uYWJsZSBoYXMgYWxyZWFkeSBwYXNzZWRcbiAgLy8gdGhlbiBmYWlscyBhc3luY2hyb25vdXNseVxuICBpZiAocnVubmFibGUuaXNQYXNzZWQoKSkge1xuICAgIGRlYnVnKCd1bmNhdWdodCgpOiBSdW5uYWJsZSBoYXMgYWxyZWFkeSBwYXNzZWQ7IGJhaWxpbmcgZ3JhY2VmdWxseScpO1xuICAgIHRoaXMuZmFpbChydW5uYWJsZSwgZXJyKTtcbiAgICB0aGlzLmFib3J0KCk7XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ3VuY2F1Z2h0KCk6IGZvcmNpbmcgUnVubmFibGUgdG8gY29tcGxldGUgd2l0aCBFcnJvcicpO1xuICAgIHJldHVybiBydW5uYWJsZS5jYWxsYmFjayhlcnIpO1xuICB9XG59O1xuXG4vKipcbiAqIFJ1biB0aGUgcm9vdCBzdWl0ZSBhbmQgaW52b2tlIGBmbihmYWlsdXJlcylgXG4gKiBvbiBjb21wbGV0aW9uLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBtZW1iZXJvZiBSdW5uZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gQ2FsbGJhY2sgd2hlbiBmaW5pc2hlZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIEZvciBzdWJjbGFzc2VzXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvcHRzLmZpbGVzIC0gRmlsZXMgdG8gcnVuXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdHMub3B0aW9ucyAtIGNvbW1hbmQtbGluZSBvcHRpb25zXG4gKiBAcmV0dXJucyB7UnVubmVyfSBSdW5uZXIgaW5zdGFuY2UuXG4gKi9cblJ1bm5lci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKGZuLCBvcHRzID0ge30pIHtcbiAgdmFyIHJvb3RTdWl0ZSA9IHRoaXMuc3VpdGU7XG4gIHZhciBvcHRpb25zID0gb3B0cy5vcHRpb25zIHx8IHt9O1xuXG4gIGRlYnVnKCdydW4oKTogZ290IG9wdGlvbnM6ICVPJywgb3B0aW9ucyk7XG4gIGZuID0gZm4gfHwgZnVuY3Rpb24gKCkge307XG5cbiAgY29uc3QgZW5kID0gKCkgPT4ge1xuICAgIGlmICghdGhpcy50b3RhbCAmJiB0aGlzLl9vcHRzLmZhaWxaZXJvKSB0aGlzLmZhaWx1cmVzID0gMTtcblxuICAgIGRlYnVnKCdydW4oKTogcm9vdCBzdWl0ZSBjb21wbGV0ZWQ7IGVtaXR0aW5nICVzJywgY29uc3RhbnRzLkVWRU5UX1JVTl9FTkQpO1xuICAgIHRoaXMuZW1pdChjb25zdGFudHMuRVZFTlRfUlVOX0VORCk7XG4gIH07XG5cbiAgY29uc3QgYmVnaW4gPSAoKSA9PiB7XG4gICAgZGVidWcoJ3J1bigpOiBlbWl0dGluZyAlcycsIGNvbnN0YW50cy5FVkVOVF9SVU5fQkVHSU4pO1xuICAgIHRoaXMuZW1pdChjb25zdGFudHMuRVZFTlRfUlVOX0JFR0lOKTtcbiAgICBkZWJ1ZygncnVuKCk6IGVtaXR0ZWQgJXMnLCBjb25zdGFudHMuRVZFTlRfUlVOX0JFR0lOKTtcblxuICAgIHRoaXMucnVuU3VpdGUocm9vdFN1aXRlLCBlbmQpO1xuICB9O1xuXG4gIGNvbnN0IHByZXBhcmUgPSAoKSA9PiB7XG4gICAgZGVidWcoJ3J1bigpOiBzdGFydGluZycpO1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIGBvbmx5YCBmaWx0ZXJcbiAgICBpZiAocm9vdFN1aXRlLmhhc09ubHkoKSkge1xuICAgICAgcm9vdFN1aXRlLmZpbHRlck9ubHkoKTtcbiAgICAgIGRlYnVnKCdydW4oKTogZmlsdGVyZWQgZXhjbHVzaXZlIFJ1bm5hYmxlcycpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gY29uc3RhbnRzLlNUQVRFX1JVTk5JTkc7XG4gICAgaWYgKHRoaXMuX29wdHMuZGVsYXkpIHtcbiAgICAgIHRoaXMuZW1pdChjb25zdGFudHMuRVZFTlRfREVMQVlfRU5EKTtcbiAgICAgIGRlYnVnKCdydW4oKTogXCJkZWxheVwiIGVuZGVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJlZ2luKCk7XG4gIH07XG5cbiAgLy8gcmVmZXJlbmNlcyBjbGVhbnVwIHRvIGF2b2lkIG1lbW9yeSBsZWFrc1xuICBpZiAodGhpcy5fb3B0cy5jbGVhblJlZmVyZW5jZXNBZnRlclJ1bikge1xuICAgIHRoaXMub24oY29uc3RhbnRzLkVWRU5UX1NVSVRFX0VORCwgc3VpdGUgPT4ge1xuICAgICAgc3VpdGUuY2xlYW5SZWZlcmVuY2VzKCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBjYWxsYmFja1xuICB0aGlzLm9uKGNvbnN0YW50cy5FVkVOVF9SVU5fRU5ELCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IGNvbnN0YW50cy5TVEFURV9TVE9QUEVEO1xuICAgIGRlYnVnKCdydW4oKTogZW1pdHRlZCAlcycsIGNvbnN0YW50cy5FVkVOVF9SVU5fRU5EKTtcbiAgICBmbih0aGlzLmZhaWx1cmVzKTtcbiAgfSk7XG5cbiAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcihwcm9jZXNzLCAndW5jYXVnaHRFeGNlcHRpb24nLCB0aGlzLnVuY2F1Z2h0KTtcbiAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcihwcm9jZXNzLCAndW5oYW5kbGVkUmVqZWN0aW9uJywgdGhpcy51bmhhbmRsZWQpO1xuICB0aGlzLl9hZGRFdmVudExpc3RlbmVyKHByb2Nlc3MsICd1bmNhdWdodEV4Y2VwdGlvbicsIHRoaXMudW5jYXVnaHQpO1xuICB0aGlzLl9hZGRFdmVudExpc3RlbmVyKHByb2Nlc3MsICd1bmhhbmRsZWRSZWplY3Rpb24nLCB0aGlzLnVuaGFuZGxlZCk7XG5cbiAgaWYgKHRoaXMuX29wdHMuZGVsYXkpIHtcbiAgICAvLyBmb3IgcmVwb3J0ZXJzLCBJIGd1ZXNzLlxuICAgIC8vIG1pZ2h0IGJlIG5pY2UgdG8gZGVib3VuY2Ugc29tZSBkb3RzIHdoaWxlIHdlIHdhaXQuXG4gICAgdGhpcy5lbWl0KGNvbnN0YW50cy5FVkVOVF9ERUxBWV9CRUdJTiwgcm9vdFN1aXRlKTtcbiAgICByb290U3VpdGUub25jZShFVkVOVF9ST09UX1NVSVRFX1JVTiwgcHJlcGFyZSk7XG4gICAgZGVidWcoJ3J1bigpOiB3YWl0aW5nIGZvciBncmVlbiBsaWdodCBkdWUgdG8gLS1kZWxheScpO1xuICB9IGVsc2Uge1xuICAgIFJ1bm5lci5pbW1lZGlhdGVseShwcmVwYXJlKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUb2dnbGUgcGFydGlhbCBvYmplY3QgbGlua2luZyBiZWhhdmlvcjsgdXNlZCBmb3IgYnVpbGRpbmcgb2JqZWN0IHJlZmVyZW5jZXMgZnJvbVxuICogdW5pcXVlIElEJ3MuIERvZXMgbm90aGluZyBpbiBzZXJpYWwgbW9kZSwgYmVjYXVzZSB0aGUgb2JqZWN0IHJlZmVyZW5jZXMgYWxyZWFkeSBleGlzdC5cbiAqIFN1YmNsYXNzZXMgY2FuIGltcGxlbWVudCB0aGlzIChlLmcuLCBgUGFyYWxsZWxCdWZmZXJlZFJ1bm5lcmApXG4gKiBAYWJzdHJhY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZhbHVlXSAtIElmIGB0cnVlYCwgZW5hYmxlIHBhcnRpYWwgb2JqZWN0IGxpbmtpbmcsIG90aGVyd2lzZSBkaXNhYmxlXG4gKiBAcmV0dXJucyB7UnVubmVyfVxuICogQGNoYWluYWJsZVxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqIC8vIHRoaXMgcmVwb3J0ZXIgbmVlZHMgcHJvcGVyIG9iamVjdCByZWZlcmVuY2VzIHdoZW4gcnVuIGluIHBhcmFsbGVsIG1vZGVcbiAqIGNsYXNzIE15UmVwb3J0ZXIoKSB7XG4gKiAgIGNvbnN0cnVjdG9yKHJ1bm5lcikge1xuICogICAgIHRoaXMucnVubmVyLmxpbmtQYXJ0aWFsT2JqZWN0cyh0cnVlKVxuICogICAgICAgLm9uKEVWRU5UX1NVSVRFX0JFR0lOLCBzdWl0ZSA9PiB7XG4gICAgICAgICAgIC8vIHRoaXMgU3VpdGUgbWF5IGJlIHRoZSBzYW1lIG9iamVjdC4uLlxuICogICAgICAgfSlcbiAqICAgICAgIC5vbihFVkVOVF9URVNUX0JFR0lOLCB0ZXN0ID0+IHtcbiAqICAgICAgICAgLy8gLi4uYXMgdGhlIGB0ZXN0LnBhcmVudGAgcHJvcGVydHlcbiAqICAgICAgIH0pO1xuICogICB9XG4gKiB9XG4gKi9cblJ1bm5lci5wcm90b3R5cGUubGlua1BhcnRpYWxPYmplY3RzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLypcbiAqIExpa2Uge0BsaW5rIFJ1bm5lciNydW59LCBidXQgZG9lcyBub3QgYWNjZXB0IGEgY2FsbGJhY2sgYW5kIHJldHVybnMgYSBgUHJvbWlzZWAgaW5zdGVhZCBvZiBhIGBSdW5uZXJgLlxuICogVGhpcyBmdW5jdGlvbiBjYW5ub3QgcmVqZWN0OyBhbiBgdW5oYW5kbGVkUmVqZWN0aW9uYCBldmVudCB3aWxsIGJ1YmJsZSB1cCB0byB0aGUgYHByb2Nlc3NgIG9iamVjdCBpbnN0ZWFkLlxuICogQHB1YmxpY1xuICogQG1lbWJlcm9mIFJ1bm5lclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIE9wdGlvbnMgZm9yIHtAbGluayBSdW5uZXIjcnVufVxuICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn0gRmFpbHVyZSBjb3VudFxuICovXG5SdW5uZXIucHJvdG90eXBlLnJ1bkFzeW5jID0gYXN5bmMgZnVuY3Rpb24gcnVuQXN5bmMob3B0cyA9IHt9KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICB0aGlzLnJ1bihyZXNvbHZlLCBvcHRzKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENsZWFubHkgYWJvcnQgZXhlY3V0aW9uLlxuICpcbiAqIEBtZW1iZXJvZiBSdW5uZXJcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm4ge1J1bm5lcn0gUnVubmVyIGluc3RhbmNlLlxuICovXG5SdW5uZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnYWJvcnQoKTogYWJvcnRpbmcnKTtcbiAgdGhpcy5fYWJvcnQgPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBNb2NoYSBpcyBydW5uaW5nIGluIHBhcmFsbGVsIG1vZGUuICBGb3IgcmVwb3J0ZXJzLlxuICpcbiAqIFN1YmNsYXNzZXMgc2hvdWxkIHJldHVybiBhbiBhcHByb3ByaWF0ZSB2YWx1ZS5cbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIHtmYWxzZX1cbiAqL1xuUnVubmVyLnByb3RvdHlwZS5pc1BhcmFsbGVsTW9kZSA9IGZ1bmN0aW9uIGlzUGFyYWxsZWxNb2RlKCkge1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIENvbmZpZ3VyZXMgYW4gYWx0ZXJuYXRlIHJlcG9ydGVyIGZvciB3b3JrZXIgcHJvY2Vzc2VzIHRvIHVzZS4gU3ViY2xhc3Nlc1xuICogdXNpbmcgd29ya2VyIHByb2Nlc3NlcyBzaG91bGQgaW1wbGVtZW50IHRoaXMuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIEFic29sdXRlIHBhdGggdG8gYWx0ZXJuYXRlIHJlcG9ydGVyIGZvciB3b3JrZXIgcHJvY2Vzc2VzIHRvIHVzZVxuICogQHJldHVybnMge1J1bm5lcn1cbiAqIEB0aHJvd3MgV2hlbiBpbiBzZXJpYWwgbW9kZVxuICogQGNoYWluYWJsZVxuICogQGFic3RyYWN0XG4gKi9cblJ1bm5lci5wcm90b3R5cGUud29ya2VyUmVwb3J0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IGNyZWF0ZVVuc3VwcG9ydGVkRXJyb3IoJ3dvcmtlclJlcG9ydGVyKCkgbm90IHN1cHBvcnRlZCBpbiBzZXJpYWwgbW9kZScpO1xufTtcblxuLyoqXG4gKiBGaWx0ZXIgbGVha3Mgd2l0aCB0aGUgZ2l2ZW4gZ2xvYmFscyBmbGFnZ2VkIGFzIGBva2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IG9rXG4gKiBAcGFyYW0ge0FycmF5fSBnbG9iYWxzXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gZmlsdGVyTGVha3Mob2ssIGdsb2JhbHMpIHtcbiAgcmV0dXJuIGdsb2JhbHMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAvLyBGaXJlZm94IGFuZCBDaHJvbWUgZXhwb3NlcyBpZnJhbWVzIGFzIGluZGV4IGluc2lkZSB0aGUgd2luZG93IG9iamVjdFxuICAgIGlmICgvXlxcZCsvLnRlc3Qoa2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGluIGZpcmVmb3hcbiAgICAvLyBpZiBydW5uZXIgcnVucyBpbiBhbiBpZnJhbWUsIHRoaXMgaWZyYW1lJ3Mgd2luZG93LmdldEludGVyZmFjZSBtZXRob2RcbiAgICAvLyBub3QgaW5pdCBhdCBmaXJzdCBpdCBpcyBhc3NpZ25lZCBpbiBzb21lIHNlY29uZHNcbiAgICBpZiAoZ2xvYmFsLm5hdmlnYXRvciAmJiAvXmdldEludGVyZmFjZS8udGVzdChrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gYW4gaWZyYW1lIGNvdWxkIGJlIGFwcHJvYWNoZWQgYnkgd2luZG93W2lmcmFtZUluZGV4XVxuICAgIC8vIGluIGllNiw3LDggYW5kIG9wZXJhLCBpZnJhbWVJbmRleCBpcyBlbnVtZXJhYmxlLCB0aGlzIGNvdWxkIGNhdXNlIGxlYWtcbiAgICBpZiAoZ2xvYmFsLm5hdmlnYXRvciAmJiAvXlxcZCsvLnRlc3Qoa2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIE9wZXJhIGFuZCBJRSBleHBvc2UgZ2xvYmFsIHZhcmlhYmxlcyBmb3IgSFRNTCBlbGVtZW50IElEcyAoaXNzdWUgIzI0MylcbiAgICBpZiAoL15tb2NoYS0vLnRlc3Qoa2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBtYXRjaGVkID0gb2suZmlsdGVyKGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKH5vay5pbmRleE9mKCcqJykpIHtcbiAgICAgICAgcmV0dXJuIGtleS5pbmRleE9mKG9rLnNwbGl0KCcqJylbMF0pID09PSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleSA9PT0gb2s7XG4gICAgfSk7XG4gICAgcmV0dXJuICFtYXRjaGVkLmxlbmd0aCAmJiAoIWdsb2JhbC5uYXZpZ2F0b3IgfHwga2V5ICE9PSAnb25lcnJvcicpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhcmd1bWVudCBpcyBhbiBpbnN0YW5jZSBvZiBFcnJvciBvYmplY3Qgb3IgYSBkdWNrLXR5cGVkIGVxdWl2YWxlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBlcnIgLSBvYmplY3QgdG8gY2hlY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBlcnIubWVzc2FnZSAtIGVycm9yIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0Vycm9yKGVycikge1xuICByZXR1cm4gZXJyIGluc3RhbmNlb2YgRXJyb3IgfHwgKGVyciAmJiB0eXBlb2YgZXJyLm1lc3NhZ2UgPT09ICdzdHJpbmcnKTtcbn1cblxuLyoqXG4gKlxuICogQ29udmVydHMgdGhyb3duIG5vbi1leHRlbnNpYmxlIHR5cGUgaW50byBwcm9wZXIgRXJyb3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdGhyb3duIC0gTm9uLWV4dGVuc2libGUgdHlwZSB0aHJvd24gYnkgY29kZVxuICogQHJldHVybiB7RXJyb3J9XG4gKi9cbmZ1bmN0aW9uIHRocm93bjJFcnJvcihlcnIpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICBgdGhlICR7dXRpbHMuY2Fub25pY2FsVHlwZShlcnIpfSAke3N0cmluZ2lmeShcbiAgICAgIGVyclxuICAgICl9IHdhcyB0aHJvd24sIHRocm93IGFuIEVycm9yIDopYFxuICApO1xufVxuXG5SdW5uZXIuY29uc3RhbnRzID0gY29uc3RhbnRzO1xuXG4vKipcbiAqIE5vZGUuanMnIGBFdmVudEVtaXR0ZXJgXG4gKiBAZXh0ZXJuYWwgRXZlbnRFbWl0dGVyXG4gKiBAc2VlIHtAbGluayBodHRwczovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sI2V2ZW50c19jbGFzc19ldmVudGVtaXR0ZXJ9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBSdW5uZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/runner.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/stats-collector.js":
/*!***************************************************!*\
  !*** ./node_modules/mocha/lib/stats-collector.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n * Provides a factory function for a {@link StatsCollector} object.\n * @module\n */\n\nvar constants = (__webpack_require__(/*! ./runner */ \"(ssr)/./node_modules/mocha/lib/runner.js\").constants);\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\nvar EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\nvar EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\nvar EVENT_TEST_END = constants.EVENT_TEST_END;\n\n/**\n * Test statistics collector.\n *\n * @public\n * @typedef {Object} StatsCollector\n * @property {number} suites - integer count of suites run.\n * @property {number} tests - integer count of tests run.\n * @property {number} passes - integer count of passing tests.\n * @property {number} pending - integer count of pending tests.\n * @property {number} failures - integer count of failed tests.\n * @property {Date} start - time when testing began.\n * @property {Date} end - time when testing concluded.\n * @property {number} duration - number of msecs that testing took.\n */\n\nvar Date = global.Date;\n\n/**\n * Provides stats such as test duration, number of tests passed / failed etc., by listening for events emitted by `runner`.\n *\n * @private\n * @param {Runner} runner - Runner instance\n * @throws {TypeError} If falsy `runner`\n */\nfunction createStatsCollector(runner) {\n  /**\n   * @type StatsCollector\n   */\n  var stats = {\n    suites: 0,\n    tests: 0,\n    passes: 0,\n    pending: 0,\n    failures: 0\n  };\n\n  if (!runner) {\n    throw new TypeError('Missing runner argument');\n  }\n\n  runner.stats = stats;\n\n  runner.once(EVENT_RUN_BEGIN, function () {\n    stats.start = new Date();\n  });\n  runner.on(EVENT_SUITE_BEGIN, function (suite) {\n    suite.root || stats.suites++;\n  });\n  runner.on(EVENT_TEST_PASS, function () {\n    stats.passes++;\n  });\n  runner.on(EVENT_TEST_FAIL, function () {\n    stats.failures++;\n  });\n  runner.on(EVENT_TEST_PENDING, function () {\n    stats.pending++;\n  });\n  runner.on(EVENT_TEST_END, function () {\n    stats.tests++;\n  });\n  runner.once(EVENT_RUN_END, function () {\n    stats.end = new Date();\n    stats.duration = stats.end - stats.start;\n  });\n}\n\nmodule.exports = createStatsCollector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3N0YXRzLWNvbGxlY3Rvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTs7QUFFQSxnQkFBZ0IsMkZBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxNQUFNO0FBQ3BCLGNBQWMsTUFBTTtBQUNwQixjQUFjLFFBQVE7QUFDdEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvc3RhdHMtY29sbGVjdG9yLmpzP2Q2ZGYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgYSB7QGxpbmsgU3RhdHNDb2xsZWN0b3J9IG9iamVjdC5cbiAqIEBtb2R1bGVcbiAqL1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9ydW5uZXInKS5jb25zdGFudHM7XG52YXIgRVZFTlRfVEVTVF9QQVNTID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfUEFTUztcbnZhciBFVkVOVF9URVNUX0ZBSUwgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9GQUlMO1xudmFyIEVWRU5UX1NVSVRFX0JFR0lOID0gY29uc3RhbnRzLkVWRU5UX1NVSVRFX0JFR0lOO1xudmFyIEVWRU5UX1JVTl9CRUdJTiA9IGNvbnN0YW50cy5FVkVOVF9SVU5fQkVHSU47XG52YXIgRVZFTlRfVEVTVF9QRU5ESU5HID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfUEVORElORztcbnZhciBFVkVOVF9SVU5fRU5EID0gY29uc3RhbnRzLkVWRU5UX1JVTl9FTkQ7XG52YXIgRVZFTlRfVEVTVF9FTkQgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9FTkQ7XG5cbi8qKlxuICogVGVzdCBzdGF0aXN0aWNzIGNvbGxlY3Rvci5cbiAqXG4gKiBAcHVibGljXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdGF0c0NvbGxlY3RvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN1aXRlcyAtIGludGVnZXIgY291bnQgb2Ygc3VpdGVzIHJ1bi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0ZXN0cyAtIGludGVnZXIgY291bnQgb2YgdGVzdHMgcnVuLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBhc3NlcyAtIGludGVnZXIgY291bnQgb2YgcGFzc2luZyB0ZXN0cy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwZW5kaW5nIC0gaW50ZWdlciBjb3VudCBvZiBwZW5kaW5nIHRlc3RzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZhaWx1cmVzIC0gaW50ZWdlciBjb3VudCBvZiBmYWlsZWQgdGVzdHMuXG4gKiBAcHJvcGVydHkge0RhdGV9IHN0YXJ0IC0gdGltZSB3aGVuIHRlc3RpbmcgYmVnYW4uXG4gKiBAcHJvcGVydHkge0RhdGV9IGVuZCAtIHRpbWUgd2hlbiB0ZXN0aW5nIGNvbmNsdWRlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkdXJhdGlvbiAtIG51bWJlciBvZiBtc2VjcyB0aGF0IHRlc3RpbmcgdG9vay5cbiAqL1xuXG52YXIgRGF0ZSA9IGdsb2JhbC5EYXRlO1xuXG4vKipcbiAqIFByb3ZpZGVzIHN0YXRzIHN1Y2ggYXMgdGVzdCBkdXJhdGlvbiwgbnVtYmVyIG9mIHRlc3RzIHBhc3NlZCAvIGZhaWxlZCBldGMuLCBieSBsaXN0ZW5pbmcgZm9yIGV2ZW50cyBlbWl0dGVkIGJ5IGBydW5uZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyIC0gUnVubmVyIGluc3RhbmNlXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGZhbHN5IGBydW5uZXJgXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRzQ29sbGVjdG9yKHJ1bm5lcikge1xuICAvKipcbiAgICogQHR5cGUgU3RhdHNDb2xsZWN0b3JcbiAgICovXG4gIHZhciBzdGF0cyA9IHtcbiAgICBzdWl0ZXM6IDAsXG4gICAgdGVzdHM6IDAsXG4gICAgcGFzc2VzOiAwLFxuICAgIHBlbmRpbmc6IDAsXG4gICAgZmFpbHVyZXM6IDBcbiAgfTtcblxuICBpZiAoIXJ1bm5lcikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgcnVubmVyIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBydW5uZXIuc3RhdHMgPSBzdGF0cztcblxuICBydW5uZXIub25jZShFVkVOVF9SVU5fQkVHSU4sIGZ1bmN0aW9uICgpIHtcbiAgICBzdGF0cy5zdGFydCA9IG5ldyBEYXRlKCk7XG4gIH0pO1xuICBydW5uZXIub24oRVZFTlRfU1VJVEVfQkVHSU4sIGZ1bmN0aW9uIChzdWl0ZSkge1xuICAgIHN1aXRlLnJvb3QgfHwgc3RhdHMuc3VpdGVzKys7XG4gIH0pO1xuICBydW5uZXIub24oRVZFTlRfVEVTVF9QQVNTLCBmdW5jdGlvbiAoKSB7XG4gICAgc3RhdHMucGFzc2VzKys7XG4gIH0pO1xuICBydW5uZXIub24oRVZFTlRfVEVTVF9GQUlMLCBmdW5jdGlvbiAoKSB7XG4gICAgc3RhdHMuZmFpbHVyZXMrKztcbiAgfSk7XG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BFTkRJTkcsIGZ1bmN0aW9uICgpIHtcbiAgICBzdGF0cy5wZW5kaW5nKys7XG4gIH0pO1xuICBydW5uZXIub24oRVZFTlRfVEVTVF9FTkQsIGZ1bmN0aW9uICgpIHtcbiAgICBzdGF0cy50ZXN0cysrO1xuICB9KTtcbiAgcnVubmVyLm9uY2UoRVZFTlRfUlVOX0VORCwgZnVuY3Rpb24gKCkge1xuICAgIHN0YXRzLmVuZCA9IG5ldyBEYXRlKCk7XG4gICAgc3RhdHMuZHVyYXRpb24gPSBzdGF0cy5lbmQgLSBzdGF0cy5zdGFydDtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU3RhdHNDb2xsZWN0b3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/stats-collector.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/suite.js":
/*!*****************************************!*\
  !*** ./node_modules/mocha/lib/suite.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n * Module dependencies.\n * @private\n */\nconst {EventEmitter} = __webpack_require__(/*! events */ \"events\");\nconst Hook = __webpack_require__(/*! ./hook */ \"(ssr)/./node_modules/mocha/lib/hook.js\");\nvar {\n  assignNewMochaID,\n  clamp,\n  constants: utilsConstants,\n  defineConstants,\n  getMochaID,\n  inherits,\n  isString\n} = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\");\nconst debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")('mocha:suite');\nconst milliseconds = __webpack_require__(/*! ms */ \"(ssr)/./node_modules/ms/index.js\");\nconst errors = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/mocha/lib/errors.js\");\n\nconst {MOCHA_ID_PROP_NAME} = utilsConstants;\n\n/**\n * Expose `Suite`.\n */\n\nexports = module.exports = Suite;\n\n/**\n * Create a new `Suite` with the given `title` and parent `Suite`.\n *\n * @public\n * @param {Suite} parent - Parent suite (required!)\n * @param {string} title - Title\n * @return {Suite}\n */\nSuite.create = function (parent, title) {\n  var suite = new Suite(title, parent.ctx);\n  suite.parent = parent;\n  title = suite.fullTitle();\n  parent.addSuite(suite);\n  return suite;\n};\n\n/**\n * Constructs a new `Suite` instance with the given `title`, `ctx`, and `isRoot`.\n *\n * @public\n * @class\n * @extends EventEmitter\n * @see {@link https://nodejs.org/api/events.html#events_class_eventemitter|EventEmitter}\n * @param {string} title - Suite title.\n * @param {Context} parentContext - Parent context instance.\n * @param {boolean} [isRoot=false] - Whether this is the root suite.\n */\nfunction Suite(title, parentContext, isRoot) {\n  if (!isString(title)) {\n    throw errors.createInvalidArgumentTypeError(\n      'Suite argument \"title\" must be a string. Received type \"' +\n        typeof title +\n        '\"',\n      'title',\n      'string'\n    );\n  }\n  this.title = title;\n  function Context() {}\n  Context.prototype = parentContext;\n  this.ctx = new Context();\n  this.suites = [];\n  this.tests = [];\n  this.root = isRoot === true;\n  this.pending = false;\n  this._retries = -1;\n  this._beforeEach = [];\n  this._beforeAll = [];\n  this._afterEach = [];\n  this._afterAll = [];\n  this._timeout = 2000;\n  this._slow = 75;\n  this._bail = false;\n  this._onlyTests = [];\n  this._onlySuites = [];\n  assignNewMochaID(this);\n\n  Object.defineProperty(this, 'id', {\n    get() {\n      return getMochaID(this);\n    }\n  });\n\n  this.reset();\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\ninherits(Suite, EventEmitter);\n\n/**\n * Resets the state initially or for a next run.\n */\nSuite.prototype.reset = function () {\n  this.delayed = false;\n  function doReset(thingToReset) {\n    thingToReset.reset();\n  }\n  this.suites.forEach(doReset);\n  this.tests.forEach(doReset);\n  this._beforeEach.forEach(doReset);\n  this._afterEach.forEach(doReset);\n  this._beforeAll.forEach(doReset);\n  this._afterAll.forEach(doReset);\n};\n\n/**\n * Return a clone of this `Suite`.\n *\n * @private\n * @return {Suite}\n */\nSuite.prototype.clone = function () {\n  var suite = new Suite(this.title);\n  debug('clone');\n  suite.ctx = this.ctx;\n  suite.root = this.root;\n  suite.timeout(this.timeout());\n  suite.retries(this.retries());\n  suite.slow(this.slow());\n  suite.bail(this.bail());\n  return suite;\n};\n\n/**\n * Set or get timeout `ms` or short-hand such as \"2s\".\n *\n * @private\n * @todo Do not attempt to set value if `ms` is undefined\n * @param {number|string} ms\n * @return {Suite|number} for chaining\n */\nSuite.prototype.timeout = function (ms) {\n  if (!arguments.length) {\n    return this._timeout;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n\n  // Clamp to range\n  var INT_MAX = Math.pow(2, 31) - 1;\n  var range = [0, INT_MAX];\n  ms = clamp(ms, range);\n\n  debug('timeout %d', ms);\n  this._timeout = parseInt(ms, 10);\n  return this;\n};\n\n/**\n * Set or get number of times to retry a failed test.\n *\n * @private\n * @param {number|string} n\n * @return {Suite|number} for chaining\n */\nSuite.prototype.retries = function (n) {\n  if (!arguments.length) {\n    return this._retries;\n  }\n  debug('retries %d', n);\n  this._retries = parseInt(n, 10) || 0;\n  return this;\n};\n\n/**\n * Set or get slow `ms` or short-hand such as \"2s\".\n *\n * @private\n * @param {number|string} ms\n * @return {Suite|number} for chaining\n */\nSuite.prototype.slow = function (ms) {\n  if (!arguments.length) {\n    return this._slow;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('slow %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Set or get whether to bail after first error.\n *\n * @private\n * @param {boolean} bail\n * @return {Suite|number} for chaining\n */\nSuite.prototype.bail = function (bail) {\n  if (!arguments.length) {\n    return this._bail;\n  }\n  debug('bail %s', bail);\n  this._bail = bail;\n  return this;\n};\n\n/**\n * Check if this suite or its parent suite is marked as pending.\n *\n * @private\n */\nSuite.prototype.isPending = function () {\n  return this.pending || (this.parent && this.parent.isPending());\n};\n\n/**\n * Generic hook-creator.\n * @private\n * @param {string} title - Title of hook\n * @param {Function} fn - Hook callback\n * @returns {Hook} A new hook\n */\nSuite.prototype._createHook = function (title, fn) {\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.retries(this.retries());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  hook.file = this.file;\n  return hook;\n};\n\n/**\n * Run `fn(test[, done])` before running tests.\n *\n * @private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.beforeAll = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"before all\" hook' + (title ? ': ' + title : '');\n\n  var hook = this._createHook(title, fn);\n  this._beforeAll.push(hook);\n  this.emit(constants.EVENT_SUITE_ADD_HOOK_BEFORE_ALL, hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` after running tests.\n *\n * @private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.afterAll = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"after all\" hook' + (title ? ': ' + title : '');\n\n  var hook = this._createHook(title, fn);\n  this._afterAll.push(hook);\n  this.emit(constants.EVENT_SUITE_ADD_HOOK_AFTER_ALL, hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` before each test case.\n *\n * @private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.beforeEach = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"before each\" hook' + (title ? ': ' + title : '');\n\n  var hook = this._createHook(title, fn);\n  this._beforeEach.push(hook);\n  this.emit(constants.EVENT_SUITE_ADD_HOOK_BEFORE_EACH, hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` after each test case.\n *\n * @private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.afterEach = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"after each\" hook' + (title ? ': ' + title : '');\n\n  var hook = this._createHook(title, fn);\n  this._afterEach.push(hook);\n  this.emit(constants.EVENT_SUITE_ADD_HOOK_AFTER_EACH, hook);\n  return this;\n};\n\n/**\n * Add a test `suite`.\n *\n * @private\n * @param {Suite} suite\n * @return {Suite} for chaining\n */\nSuite.prototype.addSuite = function (suite) {\n  suite.parent = this;\n  suite.root = false;\n  suite.timeout(this.timeout());\n  suite.retries(this.retries());\n  suite.slow(this.slow());\n  suite.bail(this.bail());\n  this.suites.push(suite);\n  this.emit(constants.EVENT_SUITE_ADD_SUITE, suite);\n  return this;\n};\n\n/**\n * Add a `test` to this suite.\n *\n * @private\n * @param {Test} test\n * @return {Suite} for chaining\n */\nSuite.prototype.addTest = function (test) {\n  test.parent = this;\n  test.timeout(this.timeout());\n  test.retries(this.retries());\n  test.slow(this.slow());\n  test.ctx = this.ctx;\n  this.tests.push(test);\n  this.emit(constants.EVENT_SUITE_ADD_TEST, test);\n  return this;\n};\n\n/**\n * Return the full title generated by recursively concatenating the parent's\n * full title.\n *\n * @memberof Suite\n * @public\n * @return {string}\n */\nSuite.prototype.fullTitle = function () {\n  return this.titlePath().join(' ');\n};\n\n/**\n * Return the title path generated by recursively concatenating the parent's\n * title path.\n *\n * @memberof Suite\n * @public\n * @return {string[]}\n */\nSuite.prototype.titlePath = function () {\n  var result = [];\n  if (this.parent) {\n    result = result.concat(this.parent.titlePath());\n  }\n  if (!this.root) {\n    result.push(this.title);\n  }\n  return result;\n};\n\n/**\n * Return the total number of tests.\n *\n * @memberof Suite\n * @public\n * @return {number}\n */\nSuite.prototype.total = function () {\n  return (\n    this.suites.reduce(function (sum, suite) {\n      return sum + suite.total();\n    }, 0) + this.tests.length\n  );\n};\n\n/**\n * Iterates through each suite recursively to find all tests. Applies a\n * function in the format `fn(test)`.\n *\n * @private\n * @param {Function} fn\n * @return {Suite}\n */\nSuite.prototype.eachTest = function (fn) {\n  this.tests.forEach(fn);\n  this.suites.forEach(function (suite) {\n    suite.eachTest(fn);\n  });\n  return this;\n};\n\n/**\n * This will run the root suite if we happen to be running in delayed mode.\n * @private\n */\nSuite.prototype.run = function run() {\n  if (this.root) {\n    this.emit(constants.EVENT_ROOT_SUITE_RUN);\n  }\n};\n\n/**\n * Determines whether a suite has an `only` test or suite as a descendant.\n *\n * @private\n * @returns {Boolean}\n */\nSuite.prototype.hasOnly = function hasOnly() {\n  return (\n    this._onlyTests.length > 0 ||\n    this._onlySuites.length > 0 ||\n    this.suites.some(function (suite) {\n      return suite.hasOnly();\n    })\n  );\n};\n\n/**\n * Filter suites based on `isOnly` logic.\n *\n * @private\n * @returns {Boolean}\n */\nSuite.prototype.filterOnly = function filterOnly() {\n  if (this._onlyTests.length) {\n    // If the suite contains `only` tests, run those and ignore any nested suites.\n    this.tests = this._onlyTests;\n    this.suites = [];\n  } else {\n    // Otherwise, do not run any of the tests in this suite.\n    this.tests = [];\n    this._onlySuites.forEach(function (onlySuite) {\n      // If there are other `only` tests/suites nested in the current `only` suite, then filter that `only` suite.\n      // Otherwise, all of the tests on this `only` suite should be run, so don't filter it.\n      if (onlySuite.hasOnly()) {\n        onlySuite.filterOnly();\n      }\n    });\n    // Run the `only` suites, as well as any other suites that have `only` tests/suites as descendants.\n    var onlySuites = this._onlySuites;\n    this.suites = this.suites.filter(function (childSuite) {\n      return onlySuites.indexOf(childSuite) !== -1 || childSuite.filterOnly();\n    });\n  }\n  // Keep the suite only if there is something to run\n  return this.tests.length > 0 || this.suites.length > 0;\n};\n\n/**\n * Adds a suite to the list of subsuites marked `only`.\n *\n * @private\n * @param {Suite} suite\n */\nSuite.prototype.appendOnlySuite = function (suite) {\n  this._onlySuites.push(suite);\n};\n\n/**\n * Marks a suite to be `only`.\n *\n * @private\n */\nSuite.prototype.markOnly = function () {\n  this.parent && this.parent.appendOnlySuite(this);\n};\n\n/**\n * Adds a test to the list of tests marked `only`.\n *\n * @private\n * @param {Test} test\n */\nSuite.prototype.appendOnlyTest = function (test) {\n  this._onlyTests.push(test);\n};\n\n/**\n * Returns the array of hooks by hook name; see `HOOK_TYPE_*` constants.\n * @private\n */\nSuite.prototype.getHooks = function getHooks(name) {\n  return this['_' + name];\n};\n\n/**\n * cleans all references from this suite and all child suites.\n */\nSuite.prototype.dispose = function () {\n  this.suites.forEach(function (suite) {\n    suite.dispose();\n  });\n  this.cleanReferences();\n};\n\n/**\n * Cleans up the references to all the deferred functions\n * (before/after/beforeEach/afterEach) and tests of a Suite.\n * These must be deleted otherwise a memory leak can happen,\n * as those functions may reference variables from closures,\n * thus those variables can never be garbage collected as long\n * as the deferred functions exist.\n *\n * @private\n */\nSuite.prototype.cleanReferences = function cleanReferences() {\n  function cleanArrReferences(arr) {\n    for (var i = 0; i < arr.length; i++) {\n      delete arr[i].fn;\n    }\n  }\n\n  if (Array.isArray(this._beforeAll)) {\n    cleanArrReferences(this._beforeAll);\n  }\n\n  if (Array.isArray(this._beforeEach)) {\n    cleanArrReferences(this._beforeEach);\n  }\n\n  if (Array.isArray(this._afterAll)) {\n    cleanArrReferences(this._afterAll);\n  }\n\n  if (Array.isArray(this._afterEach)) {\n    cleanArrReferences(this._afterEach);\n  }\n\n  for (var i = 0; i < this.tests.length; i++) {\n    delete this.tests[i].fn;\n  }\n};\n\n/**\n * Returns an object suitable for IPC.\n * Functions are represented by keys beginning with `$$`.\n * @private\n * @returns {Object}\n */\nSuite.prototype.serialize = function serialize() {\n  return {\n    _bail: this._bail,\n    $$fullTitle: this.fullTitle(),\n    $$isPending: Boolean(this.isPending()),\n    root: this.root,\n    title: this.title,\n    [MOCHA_ID_PROP_NAME]: this.id,\n    parent: this.parent ? {[MOCHA_ID_PROP_NAME]: this.parent.id} : null\n  };\n};\n\nvar constants = defineConstants(\n  /**\n   * {@link Suite}-related constants.\n   * @public\n   * @memberof Suite\n   * @alias constants\n   * @readonly\n   * @static\n   * @enum {string}\n   */\n  {\n    /**\n     * Event emitted after a test file has been loaded. Not emitted in browser.\n     */\n    EVENT_FILE_POST_REQUIRE: 'post-require',\n    /**\n     * Event emitted before a test file has been loaded. In browser, this is emitted once an interface has been selected.\n     */\n    EVENT_FILE_PRE_REQUIRE: 'pre-require',\n    /**\n     * Event emitted immediately after a test file has been loaded. Not emitted in browser.\n     */\n    EVENT_FILE_REQUIRE: 'require',\n    /**\n     * Event emitted when `global.run()` is called (use with `delay` option).\n     */\n    EVENT_ROOT_SUITE_RUN: 'run',\n\n    /**\n     * Namespace for collection of a `Suite`'s \"after all\" hooks.\n     */\n    HOOK_TYPE_AFTER_ALL: 'afterAll',\n    /**\n     * Namespace for collection of a `Suite`'s \"after each\" hooks.\n     */\n    HOOK_TYPE_AFTER_EACH: 'afterEach',\n    /**\n     * Namespace for collection of a `Suite`'s \"before all\" hooks.\n     */\n    HOOK_TYPE_BEFORE_ALL: 'beforeAll',\n    /**\n     * Namespace for collection of a `Suite`'s \"before each\" hooks.\n     */\n    HOOK_TYPE_BEFORE_EACH: 'beforeEach',\n\n    /**\n     * Emitted after a child `Suite` has been added to a `Suite`.\n     */\n    EVENT_SUITE_ADD_SUITE: 'suite',\n    /**\n     * Emitted after an \"after all\" `Hook` has been added to a `Suite`.\n     */\n    EVENT_SUITE_ADD_HOOK_AFTER_ALL: 'afterAll',\n    /**\n     * Emitted after an \"after each\" `Hook` has been added to a `Suite`.\n     */\n    EVENT_SUITE_ADD_HOOK_AFTER_EACH: 'afterEach',\n    /**\n     * Emitted after an \"before all\" `Hook` has been added to a `Suite`.\n     */\n    EVENT_SUITE_ADD_HOOK_BEFORE_ALL: 'beforeAll',\n    /**\n     * Emitted after an \"before each\" `Hook` has been added to a `Suite`.\n     */\n    EVENT_SUITE_ADD_HOOK_BEFORE_EACH: 'beforeEach',\n    /**\n     * Emitted after a `Test` has been added to a `Suite`.\n     */\n    EVENT_SUITE_ADD_TEST: 'test'\n  }\n);\n\nSuite.constants = constants;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3N1aXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxjQUFjLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUN2QyxhQUFhLG1CQUFPLENBQUMsc0RBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHdEQUFTO0FBQ3JCLGNBQWMsbUJBQU8sQ0FBQyxzREFBTztBQUM3QixxQkFBcUIsbUJBQU8sQ0FBQyw0Q0FBSTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsMERBQVU7O0FBRWpDLE9BQU8sb0JBQW9COztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3N1aXRlLmpzPzQ1NDgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB7RXZlbnRFbWl0dGVyfSA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgSG9vayA9IHJlcXVpcmUoJy4vaG9vaycpO1xudmFyIHtcbiAgYXNzaWduTmV3TW9jaGFJRCxcbiAgY2xhbXAsXG4gIGNvbnN0YW50czogdXRpbHNDb25zdGFudHMsXG4gIGRlZmluZUNvbnN0YW50cyxcbiAgZ2V0TW9jaGFJRCxcbiAgaW5oZXJpdHMsXG4gIGlzU3RyaW5nXG59ID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb2NoYTpzdWl0ZScpO1xuY29uc3QgbWlsbGlzZWNvbmRzID0gcmVxdWlyZSgnbXMnKTtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cbmNvbnN0IHtNT0NIQV9JRF9QUk9QX05BTUV9ID0gdXRpbHNDb25zdGFudHM7XG5cbi8qKlxuICogRXhwb3NlIGBTdWl0ZWAuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gU3VpdGU7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGBTdWl0ZWAgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgcGFyZW50IGBTdWl0ZWAuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtTdWl0ZX0gcGFyZW50IC0gUGFyZW50IHN1aXRlIChyZXF1aXJlZCEpXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGUgLSBUaXRsZVxuICogQHJldHVybiB7U3VpdGV9XG4gKi9cblN1aXRlLmNyZWF0ZSA9IGZ1bmN0aW9uIChwYXJlbnQsIHRpdGxlKSB7XG4gIHZhciBzdWl0ZSA9IG5ldyBTdWl0ZSh0aXRsZSwgcGFyZW50LmN0eCk7XG4gIHN1aXRlLnBhcmVudCA9IHBhcmVudDtcbiAgdGl0bGUgPSBzdWl0ZS5mdWxsVGl0bGUoKTtcbiAgcGFyZW50LmFkZFN1aXRlKHN1aXRlKTtcbiAgcmV0dXJuIHN1aXRlO1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGBTdWl0ZWAgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCwgYGN0eGAsIGFuZCBgaXNSb290YC5cbiAqXG4gKiBAcHVibGljXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9ldmVudHMuaHRtbCNldmVudHNfY2xhc3NfZXZlbnRlbWl0dGVyfEV2ZW50RW1pdHRlcn1cbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZSAtIFN1aXRlIHRpdGxlLlxuICogQHBhcmFtIHtDb250ZXh0fSBwYXJlbnRDb250ZXh0IC0gUGFyZW50IGNvbnRleHQgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1Jvb3Q9ZmFsc2VdIC0gV2hldGhlciB0aGlzIGlzIHRoZSByb290IHN1aXRlLlxuICovXG5mdW5jdGlvbiBTdWl0ZSh0aXRsZSwgcGFyZW50Q29udGV4dCwgaXNSb290KSB7XG4gIGlmICghaXNTdHJpbmcodGl0bGUpKSB7XG4gICAgdGhyb3cgZXJyb3JzLmNyZWF0ZUludmFsaWRBcmd1bWVudFR5cGVFcnJvcihcbiAgICAgICdTdWl0ZSBhcmd1bWVudCBcInRpdGxlXCIgbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBcIicgK1xuICAgICAgICB0eXBlb2YgdGl0bGUgK1xuICAgICAgICAnXCInLFxuICAgICAgJ3RpdGxlJyxcbiAgICAgICdzdHJpbmcnXG4gICAgKTtcbiAgfVxuICB0aGlzLnRpdGxlID0gdGl0bGU7XG4gIGZ1bmN0aW9uIENvbnRleHQoKSB7fVxuICBDb250ZXh0LnByb3RvdHlwZSA9IHBhcmVudENvbnRleHQ7XG4gIHRoaXMuY3R4ID0gbmV3IENvbnRleHQoKTtcbiAgdGhpcy5zdWl0ZXMgPSBbXTtcbiAgdGhpcy50ZXN0cyA9IFtdO1xuICB0aGlzLnJvb3QgPSBpc1Jvb3QgPT09IHRydWU7XG4gIHRoaXMucGVuZGluZyA9IGZhbHNlO1xuICB0aGlzLl9yZXRyaWVzID0gLTE7XG4gIHRoaXMuX2JlZm9yZUVhY2ggPSBbXTtcbiAgdGhpcy5fYmVmb3JlQWxsID0gW107XG4gIHRoaXMuX2FmdGVyRWFjaCA9IFtdO1xuICB0aGlzLl9hZnRlckFsbCA9IFtdO1xuICB0aGlzLl90aW1lb3V0ID0gMjAwMDtcbiAgdGhpcy5fc2xvdyA9IDc1O1xuICB0aGlzLl9iYWlsID0gZmFsc2U7XG4gIHRoaXMuX29ubHlUZXN0cyA9IFtdO1xuICB0aGlzLl9vbmx5U3VpdGVzID0gW107XG4gIGFzc2lnbk5ld01vY2hhSUQodGhpcyk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpZCcsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gZ2V0TW9jaGFJRCh0aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMucmVzZXQoKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0IGZyb20gYEV2ZW50RW1pdHRlci5wcm90b3R5cGVgLlxuICovXG5pbmhlcml0cyhTdWl0ZSwgRXZlbnRFbWl0dGVyKTtcblxuLyoqXG4gKiBSZXNldHMgdGhlIHN0YXRlIGluaXRpYWxseSBvciBmb3IgYSBuZXh0IHJ1bi5cbiAqL1xuU3VpdGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmRlbGF5ZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZG9SZXNldCh0aGluZ1RvUmVzZXQpIHtcbiAgICB0aGluZ1RvUmVzZXQucmVzZXQoKTtcbiAgfVxuICB0aGlzLnN1aXRlcy5mb3JFYWNoKGRvUmVzZXQpO1xuICB0aGlzLnRlc3RzLmZvckVhY2goZG9SZXNldCk7XG4gIHRoaXMuX2JlZm9yZUVhY2guZm9yRWFjaChkb1Jlc2V0KTtcbiAgdGhpcy5fYWZ0ZXJFYWNoLmZvckVhY2goZG9SZXNldCk7XG4gIHRoaXMuX2JlZm9yZUFsbC5mb3JFYWNoKGRvUmVzZXQpO1xuICB0aGlzLl9hZnRlckFsbC5mb3JFYWNoKGRvUmVzZXQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBjbG9uZSBvZiB0aGlzIGBTdWl0ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge1N1aXRlfVxuICovXG5TdWl0ZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdWl0ZSA9IG5ldyBTdWl0ZSh0aGlzLnRpdGxlKTtcbiAgZGVidWcoJ2Nsb25lJyk7XG4gIHN1aXRlLmN0eCA9IHRoaXMuY3R4O1xuICBzdWl0ZS5yb290ID0gdGhpcy5yb290O1xuICBzdWl0ZS50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcbiAgc3VpdGUucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XG4gIHN1aXRlLnNsb3codGhpcy5zbG93KCkpO1xuICBzdWl0ZS5iYWlsKHRoaXMuYmFpbCgpKTtcbiAgcmV0dXJuIHN1aXRlO1xufTtcblxuLyoqXG4gKiBTZXQgb3IgZ2V0IHRpbWVvdXQgYG1zYCBvciBzaG9ydC1oYW5kIHN1Y2ggYXMgXCIyc1wiLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAdG9kbyBEbyBub3QgYXR0ZW1wdCB0byBzZXQgdmFsdWUgaWYgYG1zYCBpcyB1bmRlZmluZWRcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbXNcbiAqIEByZXR1cm4ge1N1aXRlfG51bWJlcn0gZm9yIGNoYWluaW5nXG4gKi9cblN1aXRlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lb3V0O1xuICB9XG4gIGlmICh0eXBlb2YgbXMgPT09ICdzdHJpbmcnKSB7XG4gICAgbXMgPSBtaWxsaXNlY29uZHMobXMpO1xuICB9XG5cbiAgLy8gQ2xhbXAgdG8gcmFuZ2VcbiAgdmFyIElOVF9NQVggPSBNYXRoLnBvdygyLCAzMSkgLSAxO1xuICB2YXIgcmFuZ2UgPSBbMCwgSU5UX01BWF07XG4gIG1zID0gY2xhbXAobXMsIHJhbmdlKTtcblxuICBkZWJ1ZygndGltZW91dCAlZCcsIG1zKTtcbiAgdGhpcy5fdGltZW91dCA9IHBhcnNlSW50KG1zLCAxMCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgb3IgZ2V0IG51bWJlciBvZiB0aW1lcyB0byByZXRyeSBhIGZhaWxlZCB0ZXN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG5cbiAqIEByZXR1cm4ge1N1aXRlfG51bWJlcn0gZm9yIGNoYWluaW5nXG4gKi9cblN1aXRlLnByb3RvdHlwZS5yZXRyaWVzID0gZnVuY3Rpb24gKG4pIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JldHJpZXM7XG4gIH1cbiAgZGVidWcoJ3JldHJpZXMgJWQnLCBuKTtcbiAgdGhpcy5fcmV0cmllcyA9IHBhcnNlSW50KG4sIDEwKSB8fCAwO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IG9yIGdldCBzbG93IGBtc2Agb3Igc2hvcnQtaGFuZCBzdWNoIGFzIFwiMnNcIi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBtc1xuICogQHJldHVybiB7U3VpdGV8bnVtYmVyfSBmb3IgY2hhaW5pbmdcbiAqL1xuU3VpdGUucHJvdG90eXBlLnNsb3cgPSBmdW5jdGlvbiAobXMpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nsb3c7XG4gIH1cbiAgaWYgKHR5cGVvZiBtcyA9PT0gJ3N0cmluZycpIHtcbiAgICBtcyA9IG1pbGxpc2Vjb25kcyhtcyk7XG4gIH1cbiAgZGVidWcoJ3Nsb3cgJWQnLCBtcyk7XG4gIHRoaXMuX3Nsb3cgPSBtcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBvciBnZXQgd2hldGhlciB0byBiYWlsIGFmdGVyIGZpcnN0IGVycm9yLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJhaWxcbiAqIEByZXR1cm4ge1N1aXRlfG51bWJlcn0gZm9yIGNoYWluaW5nXG4gKi9cblN1aXRlLnByb3RvdHlwZS5iYWlsID0gZnVuY3Rpb24gKGJhaWwpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhaWw7XG4gIH1cbiAgZGVidWcoJ2JhaWwgJXMnLCBiYWlsKTtcbiAgdGhpcy5fYmFpbCA9IGJhaWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIHN1aXRlIG9yIGl0cyBwYXJlbnQgc3VpdGUgaXMgbWFya2VkIGFzIHBlbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuU3VpdGUucHJvdG90eXBlLmlzUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGVuZGluZyB8fCAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaXNQZW5kaW5nKCkpO1xufTtcblxuLyoqXG4gKiBHZW5lcmljIGhvb2stY3JlYXRvci5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGUgLSBUaXRsZSBvZiBob29rXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIEhvb2sgY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtIb29rfSBBIG5ldyBob29rXG4gKi9cblN1aXRlLnByb3RvdHlwZS5fY3JlYXRlSG9vayA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcbiAgdmFyIGhvb2sgPSBuZXcgSG9vayh0aXRsZSwgZm4pO1xuICBob29rLnBhcmVudCA9IHRoaXM7XG4gIGhvb2sudGltZW91dCh0aGlzLnRpbWVvdXQoKSk7XG4gIGhvb2sucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XG4gIGhvb2suc2xvdyh0aGlzLnNsb3coKSk7XG4gIGhvb2suY3R4ID0gdGhpcy5jdHg7XG4gIGhvb2suZmlsZSA9IHRoaXMuZmlsZTtcbiAgcmV0dXJuIGhvb2s7XG59O1xuXG4vKipcbiAqIFJ1biBgZm4odGVzdFssIGRvbmVdKWAgYmVmb3JlIHJ1bm5pbmcgdGVzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1N1aXRlfSBmb3IgY2hhaW5pbmdcbiAqL1xuU3VpdGUucHJvdG90eXBlLmJlZm9yZUFsbCA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcbiAgaWYgKHRoaXMuaXNQZW5kaW5nKCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpZiAodHlwZW9mIHRpdGxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSB0aXRsZTtcbiAgICB0aXRsZSA9IGZuLm5hbWU7XG4gIH1cbiAgdGl0bGUgPSAnXCJiZWZvcmUgYWxsXCIgaG9vaycgKyAodGl0bGUgPyAnOiAnICsgdGl0bGUgOiAnJyk7XG5cbiAgdmFyIGhvb2sgPSB0aGlzLl9jcmVhdGVIb29rKHRpdGxlLCBmbik7XG4gIHRoaXMuX2JlZm9yZUFsbC5wdXNoKGhvb2spO1xuICB0aGlzLmVtaXQoY29uc3RhbnRzLkVWRU5UX1NVSVRFX0FERF9IT09LX0JFRk9SRV9BTEwsIGhvb2spO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUnVuIGBmbih0ZXN0WywgZG9uZV0pYCBhZnRlciBydW5uaW5nIHRlc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtTdWl0ZX0gZm9yIGNoYWluaW5nXG4gKi9cblN1aXRlLnByb3RvdHlwZS5hZnRlckFsbCA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcbiAgaWYgKHRoaXMuaXNQZW5kaW5nKCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpZiAodHlwZW9mIHRpdGxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSB0aXRsZTtcbiAgICB0aXRsZSA9IGZuLm5hbWU7XG4gIH1cbiAgdGl0bGUgPSAnXCJhZnRlciBhbGxcIiBob29rJyArICh0aXRsZSA/ICc6ICcgKyB0aXRsZSA6ICcnKTtcblxuICB2YXIgaG9vayA9IHRoaXMuX2NyZWF0ZUhvb2sodGl0bGUsIGZuKTtcbiAgdGhpcy5fYWZ0ZXJBbGwucHVzaChob29rKTtcbiAgdGhpcy5lbWl0KGNvbnN0YW50cy5FVkVOVF9TVUlURV9BRERfSE9PS19BRlRFUl9BTEwsIGhvb2spO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUnVuIGBmbih0ZXN0WywgZG9uZV0pYCBiZWZvcmUgZWFjaCB0ZXN0IGNhc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1N1aXRlfSBmb3IgY2hhaW5pbmdcbiAqL1xuU3VpdGUucHJvdG90eXBlLmJlZm9yZUVhY2ggPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XG4gIGlmICh0aGlzLmlzUGVuZGluZygpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKHR5cGVvZiB0aXRsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gdGl0bGU7XG4gICAgdGl0bGUgPSBmbi5uYW1lO1xuICB9XG4gIHRpdGxlID0gJ1wiYmVmb3JlIGVhY2hcIiBob29rJyArICh0aXRsZSA/ICc6ICcgKyB0aXRsZSA6ICcnKTtcblxuICB2YXIgaG9vayA9IHRoaXMuX2NyZWF0ZUhvb2sodGl0bGUsIGZuKTtcbiAgdGhpcy5fYmVmb3JlRWFjaC5wdXNoKGhvb2spO1xuICB0aGlzLmVtaXQoY29uc3RhbnRzLkVWRU5UX1NVSVRFX0FERF9IT09LX0JFRk9SRV9FQUNILCBob29rKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJ1biBgZm4odGVzdFssIGRvbmVdKWAgYWZ0ZXIgZWFjaCB0ZXN0IGNhc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1N1aXRlfSBmb3IgY2hhaW5pbmdcbiAqL1xuU3VpdGUucHJvdG90eXBlLmFmdGVyRWFjaCA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcbiAgaWYgKHRoaXMuaXNQZW5kaW5nKCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpZiAodHlwZW9mIHRpdGxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSB0aXRsZTtcbiAgICB0aXRsZSA9IGZuLm5hbWU7XG4gIH1cbiAgdGl0bGUgPSAnXCJhZnRlciBlYWNoXCIgaG9vaycgKyAodGl0bGUgPyAnOiAnICsgdGl0bGUgOiAnJyk7XG5cbiAgdmFyIGhvb2sgPSB0aGlzLl9jcmVhdGVIb29rKHRpdGxlLCBmbik7XG4gIHRoaXMuX2FmdGVyRWFjaC5wdXNoKGhvb2spO1xuICB0aGlzLmVtaXQoY29uc3RhbnRzLkVWRU5UX1NVSVRFX0FERF9IT09LX0FGVEVSX0VBQ0gsIGhvb2spO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEgdGVzdCBgc3VpdGVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZVxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xuICovXG5TdWl0ZS5wcm90b3R5cGUuYWRkU3VpdGUgPSBmdW5jdGlvbiAoc3VpdGUpIHtcbiAgc3VpdGUucGFyZW50ID0gdGhpcztcbiAgc3VpdGUucm9vdCA9IGZhbHNlO1xuICBzdWl0ZS50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcbiAgc3VpdGUucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XG4gIHN1aXRlLnNsb3codGhpcy5zbG93KCkpO1xuICBzdWl0ZS5iYWlsKHRoaXMuYmFpbCgpKTtcbiAgdGhpcy5zdWl0ZXMucHVzaChzdWl0ZSk7XG4gIHRoaXMuZW1pdChjb25zdGFudHMuRVZFTlRfU1VJVEVfQUREX1NVSVRFLCBzdWl0ZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBgdGVzdGAgdG8gdGhpcyBzdWl0ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtUZXN0fSB0ZXN0XG4gKiBAcmV0dXJuIHtTdWl0ZX0gZm9yIGNoYWluaW5nXG4gKi9cblN1aXRlLnByb3RvdHlwZS5hZGRUZXN0ID0gZnVuY3Rpb24gKHRlc3QpIHtcbiAgdGVzdC5wYXJlbnQgPSB0aGlzO1xuICB0ZXN0LnRpbWVvdXQodGhpcy50aW1lb3V0KCkpO1xuICB0ZXN0LnJldHJpZXModGhpcy5yZXRyaWVzKCkpO1xuICB0ZXN0LnNsb3codGhpcy5zbG93KCkpO1xuICB0ZXN0LmN0eCA9IHRoaXMuY3R4O1xuICB0aGlzLnRlc3RzLnB1c2godGVzdCk7XG4gIHRoaXMuZW1pdChjb25zdGFudHMuRVZFTlRfU1VJVEVfQUREX1RFU1QsIHRlc3QpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBmdWxsIHRpdGxlIGdlbmVyYXRlZCBieSByZWN1cnNpdmVseSBjb25jYXRlbmF0aW5nIHRoZSBwYXJlbnQnc1xuICogZnVsbCB0aXRsZS5cbiAqXG4gKiBAbWVtYmVyb2YgU3VpdGVcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuU3VpdGUucHJvdG90eXBlLmZ1bGxUaXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudGl0bGVQYXRoKCkuam9pbignICcpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHRpdGxlIHBhdGggZ2VuZXJhdGVkIGJ5IHJlY3Vyc2l2ZWx5IGNvbmNhdGVuYXRpbmcgdGhlIHBhcmVudCdzXG4gKiB0aXRsZSBwYXRoLlxuICpcbiAqIEBtZW1iZXJvZiBTdWl0ZVxuICogQHB1YmxpY1xuICogQHJldHVybiB7c3RyaW5nW119XG4gKi9cblN1aXRlLnByb3RvdHlwZS50aXRsZVBhdGggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzLnBhcmVudC50aXRsZVBhdGgoKSk7XG4gIH1cbiAgaWYgKCF0aGlzLnJvb3QpIHtcbiAgICByZXN1bHQucHVzaCh0aGlzLnRpdGxlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHRvdGFsIG51bWJlciBvZiB0ZXN0cy5cbiAqXG4gKiBAbWVtYmVyb2YgU3VpdGVcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuU3VpdGUucHJvdG90eXBlLnRvdGFsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKFxuICAgIHRoaXMuc3VpdGVzLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBzdWl0ZSkge1xuICAgICAgcmV0dXJuIHN1bSArIHN1aXRlLnRvdGFsKCk7XG4gICAgfSwgMCkgKyB0aGlzLnRlc3RzLmxlbmd0aFxuICApO1xufTtcblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGVhY2ggc3VpdGUgcmVjdXJzaXZlbHkgdG8gZmluZCBhbGwgdGVzdHMuIEFwcGxpZXMgYVxuICogZnVuY3Rpb24gaW4gdGhlIGZvcm1hdCBgZm4odGVzdClgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7U3VpdGV9XG4gKi9cblN1aXRlLnByb3RvdHlwZS5lYWNoVGVzdCA9IGZ1bmN0aW9uIChmbikge1xuICB0aGlzLnRlc3RzLmZvckVhY2goZm4pO1xuICB0aGlzLnN1aXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdWl0ZSkge1xuICAgIHN1aXRlLmVhY2hUZXN0KGZuKTtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUaGlzIHdpbGwgcnVuIHRoZSByb290IHN1aXRlIGlmIHdlIGhhcHBlbiB0byBiZSBydW5uaW5nIGluIGRlbGF5ZWQgbW9kZS5cbiAqIEBwcml2YXRlXG4gKi9cblN1aXRlLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4oKSB7XG4gIGlmICh0aGlzLnJvb3QpIHtcbiAgICB0aGlzLmVtaXQoY29uc3RhbnRzLkVWRU5UX1JPT1RfU1VJVEVfUlVOKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBzdWl0ZSBoYXMgYW4gYG9ubHlgIHRlc3Qgb3Igc3VpdGUgYXMgYSBkZXNjZW5kYW50LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuU3VpdGUucHJvdG90eXBlLmhhc09ubHkgPSBmdW5jdGlvbiBoYXNPbmx5KCkge1xuICByZXR1cm4gKFxuICAgIHRoaXMuX29ubHlUZXN0cy5sZW5ndGggPiAwIHx8XG4gICAgdGhpcy5fb25seVN1aXRlcy5sZW5ndGggPiAwIHx8XG4gICAgdGhpcy5zdWl0ZXMuc29tZShmdW5jdGlvbiAoc3VpdGUpIHtcbiAgICAgIHJldHVybiBzdWl0ZS5oYXNPbmx5KCk7XG4gICAgfSlcbiAgKTtcbn07XG5cbi8qKlxuICogRmlsdGVyIHN1aXRlcyBiYXNlZCBvbiBgaXNPbmx5YCBsb2dpYy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblN1aXRlLnByb3RvdHlwZS5maWx0ZXJPbmx5ID0gZnVuY3Rpb24gZmlsdGVyT25seSgpIHtcbiAgaWYgKHRoaXMuX29ubHlUZXN0cy5sZW5ndGgpIHtcbiAgICAvLyBJZiB0aGUgc3VpdGUgY29udGFpbnMgYG9ubHlgIHRlc3RzLCBydW4gdGhvc2UgYW5kIGlnbm9yZSBhbnkgbmVzdGVkIHN1aXRlcy5cbiAgICB0aGlzLnRlc3RzID0gdGhpcy5fb25seVRlc3RzO1xuICAgIHRoaXMuc3VpdGVzID0gW107XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlLCBkbyBub3QgcnVuIGFueSBvZiB0aGUgdGVzdHMgaW4gdGhpcyBzdWl0ZS5cbiAgICB0aGlzLnRlc3RzID0gW107XG4gICAgdGhpcy5fb25seVN1aXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChvbmx5U3VpdGUpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBvdGhlciBgb25seWAgdGVzdHMvc3VpdGVzIG5lc3RlZCBpbiB0aGUgY3VycmVudCBgb25seWAgc3VpdGUsIHRoZW4gZmlsdGVyIHRoYXQgYG9ubHlgIHN1aXRlLlxuICAgICAgLy8gT3RoZXJ3aXNlLCBhbGwgb2YgdGhlIHRlc3RzIG9uIHRoaXMgYG9ubHlgIHN1aXRlIHNob3VsZCBiZSBydW4sIHNvIGRvbid0IGZpbHRlciBpdC5cbiAgICAgIGlmIChvbmx5U3VpdGUuaGFzT25seSgpKSB7XG4gICAgICAgIG9ubHlTdWl0ZS5maWx0ZXJPbmx5KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gUnVuIHRoZSBgb25seWAgc3VpdGVzLCBhcyB3ZWxsIGFzIGFueSBvdGhlciBzdWl0ZXMgdGhhdCBoYXZlIGBvbmx5YCB0ZXN0cy9zdWl0ZXMgYXMgZGVzY2VuZGFudHMuXG4gICAgdmFyIG9ubHlTdWl0ZXMgPSB0aGlzLl9vbmx5U3VpdGVzO1xuICAgIHRoaXMuc3VpdGVzID0gdGhpcy5zdWl0ZXMuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZFN1aXRlKSB7XG4gICAgICByZXR1cm4gb25seVN1aXRlcy5pbmRleE9mKGNoaWxkU3VpdGUpICE9PSAtMSB8fCBjaGlsZFN1aXRlLmZpbHRlck9ubHkoKTtcbiAgICB9KTtcbiAgfVxuICAvLyBLZWVwIHRoZSBzdWl0ZSBvbmx5IGlmIHRoZXJlIGlzIHNvbWV0aGluZyB0byBydW5cbiAgcmV0dXJuIHRoaXMudGVzdHMubGVuZ3RoID4gMCB8fCB0aGlzLnN1aXRlcy5sZW5ndGggPiAwO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgc3VpdGUgdG8gdGhlIGxpc3Qgb2Ygc3Vic3VpdGVzIG1hcmtlZCBgb25seWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXG4gKi9cblN1aXRlLnByb3RvdHlwZS5hcHBlbmRPbmx5U3VpdGUgPSBmdW5jdGlvbiAoc3VpdGUpIHtcbiAgdGhpcy5fb25seVN1aXRlcy5wdXNoKHN1aXRlKTtcbn07XG5cbi8qKlxuICogTWFya3MgYSBzdWl0ZSB0byBiZSBgb25seWAuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuU3VpdGUucHJvdG90eXBlLm1hcmtPbmx5ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5hcHBlbmRPbmx5U3VpdGUodGhpcyk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSB0ZXN0IHRvIHRoZSBsaXN0IG9mIHRlc3RzIG1hcmtlZCBgb25seWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7VGVzdH0gdGVzdFxuICovXG5TdWl0ZS5wcm90b3R5cGUuYXBwZW5kT25seVRlc3QgPSBmdW5jdGlvbiAodGVzdCkge1xuICB0aGlzLl9vbmx5VGVzdHMucHVzaCh0ZXN0KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYXJyYXkgb2YgaG9va3MgYnkgaG9vayBuYW1lOyBzZWUgYEhPT0tfVFlQRV8qYCBjb25zdGFudHMuXG4gKiBAcHJpdmF0ZVxuICovXG5TdWl0ZS5wcm90b3R5cGUuZ2V0SG9va3MgPSBmdW5jdGlvbiBnZXRIb29rcyhuYW1lKSB7XG4gIHJldHVybiB0aGlzWydfJyArIG5hbWVdO1xufTtcblxuLyoqXG4gKiBjbGVhbnMgYWxsIHJlZmVyZW5jZXMgZnJvbSB0aGlzIHN1aXRlIGFuZCBhbGwgY2hpbGQgc3VpdGVzLlxuICovXG5TdWl0ZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zdWl0ZXMuZm9yRWFjaChmdW5jdGlvbiAoc3VpdGUpIHtcbiAgICBzdWl0ZS5kaXNwb3NlKCk7XG4gIH0pO1xuICB0aGlzLmNsZWFuUmVmZXJlbmNlcygpO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgdGhlIHJlZmVyZW5jZXMgdG8gYWxsIHRoZSBkZWZlcnJlZCBmdW5jdGlvbnNcbiAqIChiZWZvcmUvYWZ0ZXIvYmVmb3JlRWFjaC9hZnRlckVhY2gpIGFuZCB0ZXN0cyBvZiBhIFN1aXRlLlxuICogVGhlc2UgbXVzdCBiZSBkZWxldGVkIG90aGVyd2lzZSBhIG1lbW9yeSBsZWFrIGNhbiBoYXBwZW4sXG4gKiBhcyB0aG9zZSBmdW5jdGlvbnMgbWF5IHJlZmVyZW5jZSB2YXJpYWJsZXMgZnJvbSBjbG9zdXJlcyxcbiAqIHRodXMgdGhvc2UgdmFyaWFibGVzIGNhbiBuZXZlciBiZSBnYXJiYWdlIGNvbGxlY3RlZCBhcyBsb25nXG4gKiBhcyB0aGUgZGVmZXJyZWQgZnVuY3Rpb25zIGV4aXN0LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblN1aXRlLnByb3RvdHlwZS5jbGVhblJlZmVyZW5jZXMgPSBmdW5jdGlvbiBjbGVhblJlZmVyZW5jZXMoKSB7XG4gIGZ1bmN0aW9uIGNsZWFuQXJyUmVmZXJlbmNlcyhhcnIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgZGVsZXRlIGFycltpXS5mbjtcbiAgICB9XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLl9iZWZvcmVBbGwpKSB7XG4gICAgY2xlYW5BcnJSZWZlcmVuY2VzKHRoaXMuX2JlZm9yZUFsbCk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLl9iZWZvcmVFYWNoKSkge1xuICAgIGNsZWFuQXJyUmVmZXJlbmNlcyh0aGlzLl9iZWZvcmVFYWNoKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHRoaXMuX2FmdGVyQWxsKSkge1xuICAgIGNsZWFuQXJyUmVmZXJlbmNlcyh0aGlzLl9hZnRlckFsbCk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLl9hZnRlckVhY2gpKSB7XG4gICAgY2xlYW5BcnJSZWZlcmVuY2VzKHRoaXMuX2FmdGVyRWFjaCk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWxldGUgdGhpcy50ZXN0c1tpXS5mbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBzdWl0YWJsZSBmb3IgSVBDLlxuICogRnVuY3Rpb25zIGFyZSByZXByZXNlbnRlZCBieSBrZXlzIGJlZ2lubmluZyB3aXRoIGAkJGAuXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuU3VpdGUucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBfYmFpbDogdGhpcy5fYmFpbCxcbiAgICAkJGZ1bGxUaXRsZTogdGhpcy5mdWxsVGl0bGUoKSxcbiAgICAkJGlzUGVuZGluZzogQm9vbGVhbih0aGlzLmlzUGVuZGluZygpKSxcbiAgICByb290OiB0aGlzLnJvb3QsXG4gICAgdGl0bGU6IHRoaXMudGl0bGUsXG4gICAgW01PQ0hBX0lEX1BST1BfTkFNRV06IHRoaXMuaWQsXG4gICAgcGFyZW50OiB0aGlzLnBhcmVudCA/IHtbTU9DSEFfSURfUFJPUF9OQU1FXTogdGhpcy5wYXJlbnQuaWR9IDogbnVsbFxuICB9O1xufTtcblxudmFyIGNvbnN0YW50cyA9IGRlZmluZUNvbnN0YW50cyhcbiAgLyoqXG4gICAqIHtAbGluayBTdWl0ZX0tcmVsYXRlZCBjb25zdGFudHMuXG4gICAqIEBwdWJsaWNcbiAgICogQG1lbWJlcm9mIFN1aXRlXG4gICAqIEBhbGlhcyBjb25zdGFudHNcbiAgICogQHJlYWRvbmx5XG4gICAqIEBzdGF0aWNcbiAgICogQGVudW0ge3N0cmluZ31cbiAgICovXG4gIHtcbiAgICAvKipcbiAgICAgKiBFdmVudCBlbWl0dGVkIGFmdGVyIGEgdGVzdCBmaWxlIGhhcyBiZWVuIGxvYWRlZC4gTm90IGVtaXR0ZWQgaW4gYnJvd3Nlci5cbiAgICAgKi9cbiAgICBFVkVOVF9GSUxFX1BPU1RfUkVRVUlSRTogJ3Bvc3QtcmVxdWlyZScsXG4gICAgLyoqXG4gICAgICogRXZlbnQgZW1pdHRlZCBiZWZvcmUgYSB0ZXN0IGZpbGUgaGFzIGJlZW4gbG9hZGVkLiBJbiBicm93c2VyLCB0aGlzIGlzIGVtaXR0ZWQgb25jZSBhbiBpbnRlcmZhY2UgaGFzIGJlZW4gc2VsZWN0ZWQuXG4gICAgICovXG4gICAgRVZFTlRfRklMRV9QUkVfUkVRVUlSRTogJ3ByZS1yZXF1aXJlJyxcbiAgICAvKipcbiAgICAgKiBFdmVudCBlbWl0dGVkIGltbWVkaWF0ZWx5IGFmdGVyIGEgdGVzdCBmaWxlIGhhcyBiZWVuIGxvYWRlZC4gTm90IGVtaXR0ZWQgaW4gYnJvd3Nlci5cbiAgICAgKi9cbiAgICBFVkVOVF9GSUxFX1JFUVVJUkU6ICdyZXF1aXJlJyxcbiAgICAvKipcbiAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gYGdsb2JhbC5ydW4oKWAgaXMgY2FsbGVkICh1c2Ugd2l0aCBgZGVsYXlgIG9wdGlvbikuXG4gICAgICovXG4gICAgRVZFTlRfUk9PVF9TVUlURV9SVU46ICdydW4nLFxuXG4gICAgLyoqXG4gICAgICogTmFtZXNwYWNlIGZvciBjb2xsZWN0aW9uIG9mIGEgYFN1aXRlYCdzIFwiYWZ0ZXIgYWxsXCIgaG9va3MuXG4gICAgICovXG4gICAgSE9PS19UWVBFX0FGVEVSX0FMTDogJ2FmdGVyQWxsJyxcbiAgICAvKipcbiAgICAgKiBOYW1lc3BhY2UgZm9yIGNvbGxlY3Rpb24gb2YgYSBgU3VpdGVgJ3MgXCJhZnRlciBlYWNoXCIgaG9va3MuXG4gICAgICovXG4gICAgSE9PS19UWVBFX0FGVEVSX0VBQ0g6ICdhZnRlckVhY2gnLFxuICAgIC8qKlxuICAgICAqIE5hbWVzcGFjZSBmb3IgY29sbGVjdGlvbiBvZiBhIGBTdWl0ZWAncyBcImJlZm9yZSBhbGxcIiBob29rcy5cbiAgICAgKi9cbiAgICBIT09LX1RZUEVfQkVGT1JFX0FMTDogJ2JlZm9yZUFsbCcsXG4gICAgLyoqXG4gICAgICogTmFtZXNwYWNlIGZvciBjb2xsZWN0aW9uIG9mIGEgYFN1aXRlYCdzIFwiYmVmb3JlIGVhY2hcIiBob29rcy5cbiAgICAgKi9cbiAgICBIT09LX1RZUEVfQkVGT1JFX0VBQ0g6ICdiZWZvcmVFYWNoJyxcblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgYWZ0ZXIgYSBjaGlsZCBgU3VpdGVgIGhhcyBiZWVuIGFkZGVkIHRvIGEgYFN1aXRlYC5cbiAgICAgKi9cbiAgICBFVkVOVF9TVUlURV9BRERfU1VJVEU6ICdzdWl0ZScsXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCBhZnRlciBhbiBcImFmdGVyIGFsbFwiIGBIb29rYCBoYXMgYmVlbiBhZGRlZCB0byBhIGBTdWl0ZWAuXG4gICAgICovXG4gICAgRVZFTlRfU1VJVEVfQUREX0hPT0tfQUZURVJfQUxMOiAnYWZ0ZXJBbGwnLFxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgYWZ0ZXIgYW4gXCJhZnRlciBlYWNoXCIgYEhvb2tgIGhhcyBiZWVuIGFkZGVkIHRvIGEgYFN1aXRlYC5cbiAgICAgKi9cbiAgICBFVkVOVF9TVUlURV9BRERfSE9PS19BRlRFUl9FQUNIOiAnYWZ0ZXJFYWNoJyxcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIGFmdGVyIGFuIFwiYmVmb3JlIGFsbFwiIGBIb29rYCBoYXMgYmVlbiBhZGRlZCB0byBhIGBTdWl0ZWAuXG4gICAgICovXG4gICAgRVZFTlRfU1VJVEVfQUREX0hPT0tfQkVGT1JFX0FMTDogJ2JlZm9yZUFsbCcsXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCBhZnRlciBhbiBcImJlZm9yZSBlYWNoXCIgYEhvb2tgIGhhcyBiZWVuIGFkZGVkIHRvIGEgYFN1aXRlYC5cbiAgICAgKi9cbiAgICBFVkVOVF9TVUlURV9BRERfSE9PS19CRUZPUkVfRUFDSDogJ2JlZm9yZUVhY2gnLFxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgYWZ0ZXIgYSBgVGVzdGAgaGFzIGJlZW4gYWRkZWQgdG8gYSBgU3VpdGVgLlxuICAgICAqL1xuICAgIEVWRU5UX1NVSVRFX0FERF9URVNUOiAndGVzdCdcbiAgfVxuKTtcblxuU3VpdGUuY29uc3RhbnRzID0gY29uc3RhbnRzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/suite.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/test.js":
/*!****************************************!*\
  !*** ./node_modules/mocha/lib/test.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar Runnable = __webpack_require__(/*! ./runnable */ \"(ssr)/./node_modules/mocha/lib/runnable.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/mocha/lib/utils.js\");\nvar errors = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/mocha/lib/errors.js\");\nvar createInvalidArgumentTypeError = errors.createInvalidArgumentTypeError;\nvar isString = utils.isString;\n\nconst {MOCHA_ID_PROP_NAME} = utils.constants;\n\nmodule.exports = Test;\n\n/**\n * Initialize a new `Test` with the given `title` and callback `fn`.\n *\n * @public\n * @class\n * @extends Runnable\n * @param {String} title - Test title (required)\n * @param {Function} [fn] - Test callback.  If omitted, the Test is considered \"pending\"\n */\nfunction Test(title, fn) {\n  if (!isString(title)) {\n    throw createInvalidArgumentTypeError(\n      'Test argument \"title\" should be a string. Received type \"' +\n        typeof title +\n        '\"',\n      'title',\n      'string'\n    );\n  }\n  this.type = 'test';\n  Runnable.call(this, title, fn);\n  this.reset();\n}\n\n/**\n * Inherit from `Runnable.prototype`.\n */\nutils.inherits(Test, Runnable);\n\n/**\n * Resets the state initially or for a next run.\n */\nTest.prototype.reset = function () {\n  Runnable.prototype.reset.call(this);\n  this.pending = !this.fn;\n  delete this.state;\n};\n\n/**\n * Set or get retried test\n *\n * @private\n */\nTest.prototype.retriedTest = function (n) {\n  if (!arguments.length) {\n    return this._retriedTest;\n  }\n  this._retriedTest = n;\n};\n\n/**\n * Add test to the list of tests marked `only`.\n *\n * @private\n */\nTest.prototype.markOnly = function () {\n  this.parent.appendOnlyTest(this);\n};\n\nTest.prototype.clone = function () {\n  var test = new Test(this.title, this.fn);\n  test.timeout(this.timeout());\n  test.slow(this.slow());\n  test.retries(this.retries());\n  test.currentRetry(this.currentRetry());\n  test.retriedTest(this.retriedTest() || this);\n  test.globals(this.globals());\n  test.parent = this.parent;\n  test.file = this.file;\n  test.ctx = this.ctx;\n  return test;\n};\n\n/**\n * Returns an minimal object suitable for transmission over IPC.\n * Functions are represented by keys beginning with `$$`.\n * @private\n * @returns {Object}\n */\nTest.prototype.serialize = function serialize() {\n  return {\n    $$currentRetry: this._currentRetry,\n    $$fullTitle: this.fullTitle(),\n    $$isPending: Boolean(this.pending),\n    $$retriedTest: this._retriedTest || null,\n    $$slow: this._slow,\n    $$titlePath: this.titlePath(),\n    body: this.body,\n    duration: this.duration,\n    err: this.err,\n    parent: {\n      $$fullTitle: this.parent.fullTitle(),\n      [MOCHA_ID_PROP_NAME]: this.parent.id\n    },\n    speed: this.speed,\n    state: this.state,\n    title: this.title,\n    type: this.type,\n    file: this.file,\n    [MOCHA_ID_PROP_NAME]: this.id\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3Rlc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixlQUFlLG1CQUFPLENBQUMsOERBQVk7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLHdEQUFTO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQywwREFBVTtBQUMvQjtBQUNBOztBQUVBLE9BQU8sb0JBQW9COztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3Rlc3QuanM/ZTM3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgUnVubmFibGUgPSByZXF1aXJlKCcuL3J1bm5hYmxlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbnZhciBjcmVhdGVJbnZhbGlkQXJndW1lbnRUeXBlRXJyb3IgPSBlcnJvcnMuY3JlYXRlSW52YWxpZEFyZ3VtZW50VHlwZUVycm9yO1xudmFyIGlzU3RyaW5nID0gdXRpbHMuaXNTdHJpbmc7XG5cbmNvbnN0IHtNT0NIQV9JRF9QUk9QX05BTUV9ID0gdXRpbHMuY29uc3RhbnRzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRlc3Q7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgVGVzdGAgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgY2FsbGJhY2sgYGZuYC5cbiAqXG4gKiBAcHVibGljXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFJ1bm5hYmxlXG4gKiBAcGFyYW0ge1N0cmluZ30gdGl0bGUgLSBUZXN0IHRpdGxlIChyZXF1aXJlZClcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl0gLSBUZXN0IGNhbGxiYWNrLiAgSWYgb21pdHRlZCwgdGhlIFRlc3QgaXMgY29uc2lkZXJlZCBcInBlbmRpbmdcIlxuICovXG5mdW5jdGlvbiBUZXN0KHRpdGxlLCBmbikge1xuICBpZiAoIWlzU3RyaW5nKHRpdGxlKSkge1xuICAgIHRocm93IGNyZWF0ZUludmFsaWRBcmd1bWVudFR5cGVFcnJvcihcbiAgICAgICdUZXN0IGFyZ3VtZW50IFwidGl0bGVcIiBzaG91bGQgYmUgYSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgXCInICtcbiAgICAgICAgdHlwZW9mIHRpdGxlICtcbiAgICAgICAgJ1wiJyxcbiAgICAgICd0aXRsZScsXG4gICAgICAnc3RyaW5nJ1xuICAgICk7XG4gIH1cbiAgdGhpcy50eXBlID0gJ3Rlc3QnO1xuICBSdW5uYWJsZS5jYWxsKHRoaXMsIHRpdGxlLCBmbik7XG4gIHRoaXMucmVzZXQoKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0IGZyb20gYFJ1bm5hYmxlLnByb3RvdHlwZWAuXG4gKi9cbnV0aWxzLmluaGVyaXRzKFRlc3QsIFJ1bm5hYmxlKTtcblxuLyoqXG4gKiBSZXNldHMgdGhlIHN0YXRlIGluaXRpYWxseSBvciBmb3IgYSBuZXh0IHJ1bi5cbiAqL1xuVGVzdC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIFJ1bm5hYmxlLnByb3RvdHlwZS5yZXNldC5jYWxsKHRoaXMpO1xuICB0aGlzLnBlbmRpbmcgPSAhdGhpcy5mbjtcbiAgZGVsZXRlIHRoaXMuc3RhdGU7XG59O1xuXG4vKipcbiAqIFNldCBvciBnZXQgcmV0cmllZCB0ZXN0XG4gKlxuICogQHByaXZhdGVcbiAqL1xuVGVzdC5wcm90b3R5cGUucmV0cmllZFRlc3QgPSBmdW5jdGlvbiAobikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmV0cmllZFRlc3Q7XG4gIH1cbiAgdGhpcy5fcmV0cmllZFRlc3QgPSBuO1xufTtcblxuLyoqXG4gKiBBZGQgdGVzdCB0byB0aGUgbGlzdCBvZiB0ZXN0cyBtYXJrZWQgYG9ubHlgLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblRlc3QucHJvdG90eXBlLm1hcmtPbmx5ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnBhcmVudC5hcHBlbmRPbmx5VGVzdCh0aGlzKTtcbn07XG5cblRlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGVzdCA9IG5ldyBUZXN0KHRoaXMudGl0bGUsIHRoaXMuZm4pO1xuICB0ZXN0LnRpbWVvdXQodGhpcy50aW1lb3V0KCkpO1xuICB0ZXN0LnNsb3codGhpcy5zbG93KCkpO1xuICB0ZXN0LnJldHJpZXModGhpcy5yZXRyaWVzKCkpO1xuICB0ZXN0LmN1cnJlbnRSZXRyeSh0aGlzLmN1cnJlbnRSZXRyeSgpKTtcbiAgdGVzdC5yZXRyaWVkVGVzdCh0aGlzLnJldHJpZWRUZXN0KCkgfHwgdGhpcyk7XG4gIHRlc3QuZ2xvYmFscyh0aGlzLmdsb2JhbHMoKSk7XG4gIHRlc3QucGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gIHRlc3QuZmlsZSA9IHRoaXMuZmlsZTtcbiAgdGVzdC5jdHggPSB0aGlzLmN0eDtcbiAgcmV0dXJuIHRlc3Q7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gbWluaW1hbCBvYmplY3Qgc3VpdGFibGUgZm9yIHRyYW5zbWlzc2lvbiBvdmVyIElQQy5cbiAqIEZ1bmN0aW9ucyBhcmUgcmVwcmVzZW50ZWQgYnkga2V5cyBiZWdpbm5pbmcgd2l0aCBgJCRgLlxuICogQHByaXZhdGVcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cblRlc3QucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICAkJGN1cnJlbnRSZXRyeTogdGhpcy5fY3VycmVudFJldHJ5LFxuICAgICQkZnVsbFRpdGxlOiB0aGlzLmZ1bGxUaXRsZSgpLFxuICAgICQkaXNQZW5kaW5nOiBCb29sZWFuKHRoaXMucGVuZGluZyksXG4gICAgJCRyZXRyaWVkVGVzdDogdGhpcy5fcmV0cmllZFRlc3QgfHwgbnVsbCxcbiAgICAkJHNsb3c6IHRoaXMuX3Nsb3csXG4gICAgJCR0aXRsZVBhdGg6IHRoaXMudGl0bGVQYXRoKCksXG4gICAgYm9keTogdGhpcy5ib2R5LFxuICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgIGVycjogdGhpcy5lcnIsXG4gICAgcGFyZW50OiB7XG4gICAgICAkJGZ1bGxUaXRsZTogdGhpcy5wYXJlbnQuZnVsbFRpdGxlKCksXG4gICAgICBbTU9DSEFfSURfUFJPUF9OQU1FXTogdGhpcy5wYXJlbnQuaWRcbiAgICB9LFxuICAgIHNwZWVkOiB0aGlzLnNwZWVkLFxuICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgIHRpdGxlOiB0aGlzLnRpdGxlLFxuICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICBmaWxlOiB0aGlzLmZpbGUsXG4gICAgW01PQ0hBX0lEX1BST1BfTkFNRV06IHRoaXMuaWRcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/test.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/mocha/lib/utils.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n * Various utility functions used throughout Mocha's codebase.\n * @module utils\n */\n\n/**\n * Module dependencies.\n */\nvar path = __webpack_require__(/*! path */ \"path\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar he = __webpack_require__(/*! he */ \"(ssr)/./node_modules/he/he.js\");\n\nconst MOCHA_ID_PROP_NAME = '__mocha_id__';\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * @param {function} ctor - Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor - Constructor function to inherit prototype from.\n * @throws {TypeError} if either constructor is null, or if super constructor\n *     lacks a prototype.\n */\nexports.inherits = util.inherits;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @private\n * @param  {string} html\n * @return {string}\n */\nexports.escape = function (html) {\n  return he.encode(String(html), {useNamedReferences: false});\n};\n\n/**\n * Test if the given obj is type of string.\n *\n * @private\n * @param {Object} obj\n * @return {boolean}\n */\nexports.isString = function (obj) {\n  return typeof obj === 'string';\n};\n\n/**\n * Compute a slug from the given `str`.\n *\n * @private\n * @param {string} str\n * @return {string}\n */\nexports.slug = function (str) {\n  return str\n    .toLowerCase()\n    .replace(/\\s+/g, '-')\n    .replace(/[^-\\w]/g, '')\n    .replace(/-{2,}/g, '-');\n};\n\n/**\n * Strip the function definition from `str`, and re-indent for pre whitespace.\n *\n * @param {string} str\n * @return {string}\n */\nexports.clean = function (str) {\n  str = str\n    .replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, '\\n')\n    .replace(/^\\uFEFF/, '')\n    // (traditional)->  space/name     parameters    body     (lambda)-> parameters       body   multi-statement/single          keep body content\n    .replace(\n      /^function(?:\\s*|\\s[^(]*)\\([^)]*\\)\\s*\\{((?:.|\\n)*?)\\}$|^\\([^)]*\\)\\s*=>\\s*(?:\\{((?:.|\\n)*?)\\}|((?:.|\\n)*))$/,\n      '$1$2$3'\n    );\n\n  var spaces = str.match(/^\\n?( *)/)[1].length;\n  var tabs = str.match(/^\\n?(\\t*)/)[1].length;\n  var re = new RegExp(\n    '^\\n?' + (tabs ? '\\t' : ' ') + '{' + (tabs || spaces) + '}',\n    'gm'\n  );\n\n  str = str.replace(re, '');\n\n  return str.trim();\n};\n\n/**\n * If a value could have properties, and has none, this function is called,\n * which returns a string representation of the empty value.\n *\n * Functions w/ no properties return `'[Function]'`\n * Arrays w/ length === 0 return `'[]'`\n * Objects w/ no properties return `'{}'`\n * All else: return result of `value.toString()`\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {string} typeHint The type of the value\n * @returns {string}\n */\nfunction emptyRepresentation(value, typeHint) {\n  switch (typeHint) {\n    case 'function':\n      return '[Function]';\n    case 'object':\n      return '{}';\n    case 'array':\n      return '[]';\n    default:\n      return value.toString();\n  }\n}\n\n/**\n * Takes some variable and asks `Object.prototype.toString()` what it thinks it\n * is.\n *\n * @private\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\n * @param {*} value The value to test.\n * @returns {string} Computed type\n * @example\n * canonicalType({}) // 'object'\n * canonicalType([]) // 'array'\n * canonicalType(1) // 'number'\n * canonicalType(false) // 'boolean'\n * canonicalType(Infinity) // 'number'\n * canonicalType(null) // 'null'\n * canonicalType(new Date()) // 'date'\n * canonicalType(/foo/) // 'regexp'\n * canonicalType('type') // 'string'\n * canonicalType(global) // 'global'\n * canonicalType(new String('foo') // 'object'\n * canonicalType(async function() {}) // 'asyncfunction'\n * canonicalType(Object.create(null)) // 'null-prototype'\n */\nvar canonicalType = (exports.canonicalType = function canonicalType(value) {\n  if (value === undefined) {\n    return 'undefined';\n  } else if (value === null) {\n    return 'null';\n  } else if (Buffer.isBuffer(value)) {\n    return 'buffer';\n  } else if (Object.getPrototypeOf(value) === null) {\n    return 'null-prototype';\n  }\n\n  return Object.prototype.toString\n    .call(value)\n    .replace(/^\\[.+\\s(.+?)]$/, '$1')\n    .toLowerCase();\n});\n\n/**\n *\n * Returns a general type or data structure of a variable\n * @private\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures\n * @param {*} value The value to test.\n * @returns {string} One of undefined, boolean, number, string, bigint, symbol, object\n * @example\n * type({}) // 'object'\n * type([]) // 'array'\n * type(1) // 'number'\n * type(false) // 'boolean'\n * type(Infinity) // 'number'\n * type(null) // 'null'\n * type(new Date()) // 'object'\n * type(/foo/) // 'object'\n * type('type') // 'string'\n * type(global) // 'object'\n * type(new String('foo') // 'string'\n */\nexports.type = function type(value) {\n  // Null is special\n  if (value === null) return 'null';\n  const primitives = new Set([\n    'undefined',\n    'boolean',\n    'number',\n    'string',\n    'bigint',\n    'symbol'\n  ]);\n  const _type = typeof value;\n  if (_type === 'function') return _type;\n  if (primitives.has(_type)) return _type;\n  if (value instanceof String) return 'string';\n  if (value instanceof Error) return 'error';\n  if (Array.isArray(value)) return 'array';\n\n  return _type;\n};\n\n/**\n * Stringify `value`. Different behavior depending on type of value:\n *\n * - If `value` is undefined or null, return `'[undefined]'` or `'[null]'`, respectively.\n * - If `value` is not an object, function or array, return result of `value.toString()` wrapped in double-quotes.\n * - If `value` is an *empty* object, function, or array, return result of function\n *   {@link emptyRepresentation}.\n * - If `value` has properties, call {@link exports.canonicalize} on it, then return result of\n *   JSON.stringify().\n *\n * @private\n * @see exports.type\n * @param {*} value\n * @return {string}\n */\nexports.stringify = function (value) {\n  var typeHint = canonicalType(value);\n\n  if (!~['object', 'array', 'function', 'null-prototype'].indexOf(typeHint)) {\n    if (typeHint === 'buffer') {\n      var json = Buffer.prototype.toJSON.call(value);\n      // Based on the toJSON result\n      return jsonStringify(\n        json.data && json.type ? json.data : json,\n        2\n      ).replace(/,(\\n|$)/g, '$1');\n    }\n\n    // IE7/IE8 has a bizarre String constructor; needs to be coerced\n    // into an array and back to obj.\n    if (typeHint === 'string' && typeof value === 'object') {\n      value = value.split('').reduce(function (acc, char, idx) {\n        acc[idx] = char;\n        return acc;\n      }, {});\n      typeHint = 'object';\n    } else {\n      return jsonStringify(value);\n    }\n  }\n\n  for (var prop in value) {\n    if (Object.prototype.hasOwnProperty.call(value, prop)) {\n      return jsonStringify(\n        exports.canonicalize(value, null, typeHint),\n        2\n      ).replace(/,(\\n|$)/g, '$1');\n    }\n  }\n\n  return emptyRepresentation(value, typeHint);\n};\n\n/**\n * like JSON.stringify but more sense.\n *\n * @private\n * @param {Object}  object\n * @param {number=} spaces\n * @param {number=} depth\n * @returns {*}\n */\nfunction jsonStringify(object, spaces, depth) {\n  if (typeof spaces === 'undefined') {\n    // primitive types\n    return _stringify(object);\n  }\n\n  depth = depth || 1;\n  var space = spaces * depth;\n  var str = Array.isArray(object) ? '[' : '{';\n  var end = Array.isArray(object) ? ']' : '}';\n  var length =\n    typeof object.length === 'number'\n      ? object.length\n      : Object.keys(object).length;\n  // `.repeat()` polyfill\n  function repeat(s, n) {\n    return new Array(n).join(s);\n  }\n\n  function _stringify(val) {\n    switch (canonicalType(val)) {\n      case 'null':\n      case 'undefined':\n        val = '[' + val + ']';\n        break;\n      case 'array':\n      case 'object':\n        val = jsonStringify(val, spaces, depth + 1);\n        break;\n      case 'boolean':\n      case 'regexp':\n      case 'symbol':\n      case 'number':\n        val =\n          val === 0 && 1 / val === -Infinity // `-0`\n            ? '-0'\n            : val.toString();\n        break;\n      case 'bigint':\n        val = val.toString() + 'n';\n        break;\n      case 'date':\n        var sDate = isNaN(val.getTime()) ? val.toString() : val.toISOString();\n        val = '[Date: ' + sDate + ']';\n        break;\n      case 'buffer':\n        var json = val.toJSON();\n        // Based on the toJSON result\n        json = json.data && json.type ? json.data : json;\n        val = '[Buffer: ' + jsonStringify(json, 2, depth + 1) + ']';\n        break;\n      default:\n        val =\n          val === '[Function]' || val === '[Circular]'\n            ? val\n            : JSON.stringify(val); // string\n    }\n    return val;\n  }\n\n  for (var i in object) {\n    if (!Object.prototype.hasOwnProperty.call(object, i)) {\n      continue; // not my business\n    }\n    --length;\n    str +=\n      '\\n ' +\n      repeat(' ', space) +\n      (Array.isArray(object) ? '' : '\"' + i + '\": ') + // key\n      _stringify(object[i]) + // value\n      (length ? ',' : ''); // comma\n  }\n\n  return (\n    str +\n    // [], {}\n    (str.length !== 1 ? '\\n' + repeat(' ', --space) + end : end)\n  );\n}\n\n/**\n * Return a new Thing that has the keys in sorted order. Recursive.\n *\n * If the Thing...\n * - has already been seen, return string `'[Circular]'`\n * - is `undefined`, return string `'[undefined]'`\n * - is `null`, return value `null`\n * - is some other primitive, return the value\n * - is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing's `toString()` method\n * - is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again.\n * - is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()`\n *\n * @private\n * @see {@link exports.stringify}\n * @param {*} value Thing to inspect.  May or may not have properties.\n * @param {Array} [stack=[]] Stack of seen values\n * @param {string} [typeHint] Type hint\n * @return {(Object|Array|Function|string|undefined)}\n */\nexports.canonicalize = function canonicalize(value, stack, typeHint) {\n  var canonicalizedObj;\n  /* eslint-disable no-unused-vars */\n  var prop;\n  /* eslint-enable no-unused-vars */\n  typeHint = typeHint || canonicalType(value);\n  function withStack(value, fn) {\n    stack.push(value);\n    fn();\n    stack.pop();\n  }\n\n  stack = stack || [];\n\n  if (stack.indexOf(value) !== -1) {\n    return '[Circular]';\n  }\n\n  switch (typeHint) {\n    case 'undefined':\n    case 'buffer':\n    case 'null':\n      canonicalizedObj = value;\n      break;\n    case 'array':\n      withStack(value, function () {\n        canonicalizedObj = value.map(function (item) {\n          return exports.canonicalize(item, stack);\n        });\n      });\n      break;\n    case 'function':\n      /* eslint-disable-next-line no-unused-vars, no-unreachable-loop */\n      for (prop in value) {\n        canonicalizedObj = {};\n        break;\n      }\n      /* eslint-enable guard-for-in */\n      if (!canonicalizedObj) {\n        canonicalizedObj = emptyRepresentation(value, typeHint);\n        break;\n      }\n    /* falls through */\n    case 'null-prototype':\n    case 'object':\n      canonicalizedObj = canonicalizedObj || {};\n      if (typeHint === 'null-prototype' && Symbol.toStringTag in value) {\n        canonicalizedObj['[Symbol.toStringTag]'] = value[Symbol.toStringTag];\n      }\n      withStack(value, function () {\n        Object.keys(value)\n          .sort()\n          .forEach(function (key) {\n            canonicalizedObj[key] = exports.canonicalize(value[key], stack);\n          });\n      });\n      break;\n    case 'date':\n    case 'number':\n    case 'regexp':\n    case 'boolean':\n    case 'symbol':\n      canonicalizedObj = value;\n      break;\n    default:\n      canonicalizedObj = value + '';\n  }\n\n  return canonicalizedObj;\n};\n\n/**\n * @summary\n * This Filter based on `mocha-clean` module.(see: `github.com/rstacruz/mocha-clean`)\n * @description\n * When invoking this function you get a filter function that get the Error.stack as an input,\n * and return a prettify output.\n * (i.e: strip Mocha and internal node functions from stack trace).\n * @returns {Function}\n */\nexports.stackTraceFilter = function () {\n  // TODO: Replace with `process.browser`\n  var is = typeof document === 'undefined' ? {node: true} : {browser: true};\n  var slash = path.sep;\n  var cwd;\n  if (is.node) {\n    cwd = exports.cwd() + slash;\n  } else {\n    cwd = (\n      typeof location === 'undefined' ? window.location : location\n    ).href.replace(/\\/[^/]*$/, '/');\n    slash = '/';\n  }\n\n  function isMochaInternal(line) {\n    return (\n      ~line.indexOf('node_modules' + slash + 'mocha' + slash) ||\n      ~line.indexOf(slash + 'mocha.js') ||\n      ~line.indexOf(slash + 'mocha.min.js')\n    );\n  }\n\n  function isNodeInternal(line) {\n    return (\n      ~line.indexOf('(timers.js:') ||\n      ~line.indexOf('(events.js:') ||\n      ~line.indexOf('(node.js:') ||\n      ~line.indexOf('(module.js:') ||\n      ~line.indexOf('GeneratorFunctionPrototype.next (native)') ||\n      false\n    );\n  }\n\n  return function (stack) {\n    stack = stack.split('\\n');\n\n    stack = stack.reduce(function (list, line) {\n      if (isMochaInternal(line)) {\n        return list;\n      }\n\n      if (is.node && isNodeInternal(line)) {\n        return list;\n      }\n\n      // Clean up cwd(absolute)\n      if (/:\\d+:\\d+\\)?$/.test(line)) {\n        line = line.replace('(' + cwd, '(');\n      }\n\n      list.push(line);\n      return list;\n    }, []);\n\n    return stack.join('\\n');\n  };\n};\n\n/**\n * Crude, but effective.\n * @public\n * @param {*} value\n * @returns {boolean} Whether or not `value` is a Promise\n */\nexports.isPromise = function isPromise(value) {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.then === 'function'\n  );\n};\n\n/**\n * Clamps a numeric value to an inclusive range.\n *\n * @param {number} value - Value to be clamped.\n * @param {number[]} range - Two element array specifying [min, max] range.\n * @returns {number} clamped value\n */\nexports.clamp = function clamp(value, range) {\n  return Math.min(Math.max(value, range[0]), range[1]);\n};\n\n/**\n * It's a noop.\n * @public\n */\nexports.noop = function () {};\n\n/**\n * Creates a map-like object.\n *\n * @description\n * A \"map\" is an object with no prototype, for our purposes. In some cases\n * this would be more appropriate than a `Map`, especially if your environment\n * doesn't support it. Recommended for use in Mocha's public APIs.\n *\n * @public\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Custom_and_Null_objects|MDN:Map}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Custom_and_Null_objects|MDN:Object.create - Custom objects}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Custom_and_Null_objects|MDN:Object.assign}\n * @param {...*} [obj] - Arguments to `Object.assign()`.\n * @returns {Object} An object with no prototype, having `...obj` properties\n */\nexports.createMap = function (obj) {\n  return Object.assign.apply(\n    null,\n    [Object.create(null)].concat(Array.prototype.slice.call(arguments))\n  );\n};\n\n/**\n * Creates a read-only map-like object.\n *\n * @description\n * This differs from {@link module:utils.createMap createMap} only in that\n * the argument must be non-empty, because the result is frozen.\n *\n * @see {@link module:utils.createMap createMap}\n * @param {...*} [obj] - Arguments to `Object.assign()`.\n * @returns {Object} A frozen object with no prototype, having `...obj` properties\n * @throws {TypeError} if argument is not a non-empty object.\n */\nexports.defineConstants = function (obj) {\n  if (canonicalType(obj) !== 'object' || !Object.keys(obj).length) {\n    throw new TypeError('Invalid argument; expected a non-empty object');\n  }\n  return Object.freeze(exports.createMap(obj));\n};\n\n/**\n * Returns current working directory\n *\n * Wrapper around `process.cwd()` for isolation\n * @private\n */\nexports.cwd = function cwd() {\n  return process.cwd();\n};\n\n/**\n * Returns `true` if Mocha is running in a browser.\n * Checks for `process.browser`.\n * @returns {boolean}\n * @private\n */\nexports.isBrowser = function isBrowser() {\n  return Boolean(false);\n};\n\n/*\n * Casts `value` to an array; useful for optionally accepting array parameters\n *\n * It follows these rules, depending on `value`.  If `value` is...\n * 1. `undefined`: return an empty Array\n * 2. `null`: return an array with a single `null` element\n * 3. Any other object: return the value of `Array.from()` _if_ the object is iterable\n * 4. otherwise: return an array with a single element, `value`\n * @param {*} value - Something to cast to an Array\n * @returns {Array<*>}\n */\nexports.castArray = function castArray(value) {\n  if (value === undefined) {\n    return [];\n  }\n  if (value === null) {\n    return [null];\n  }\n  if (\n    typeof value === 'object' &&\n    (typeof value[Symbol.iterator] === 'function' || value.length !== undefined)\n  ) {\n    return Array.from(value);\n  }\n  return [value];\n};\n\nexports.constants = exports.defineConstants({\n  MOCHA_ID_PROP_NAME\n});\n\nconst uniqueIDBase =\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_';\n\n/**\n * Creates a new unique identifier\n * Does not create cryptographically safe ids.\n * Trivial copy of nanoid/non-secure\n * @returns {string} Unique identifier\n */\nexports.uniqueID = () => {\n  let id = '';\n  for (let i = 0; i < 21; i++) {\n    id += uniqueIDBase[(Math.random() * 64) | 0];\n  }\n  return id;\n};\n\nexports.assignNewMochaID = obj => {\n  const id = exports.uniqueID();\n  Object.defineProperty(obj, MOCHA_ID_PROP_NAME, {\n    get() {\n      return id;\n    }\n  });\n  return obj;\n};\n\n/**\n * Retrieves a Mocha ID from an object, if present.\n * @param {*} [obj] - Object\n * @returns {string|void}\n */\nexports.getMochaID = obj =>\n  obj && typeof obj === 'object' ? obj[MOCHA_ID_PROP_NAME] : undefined;\n\n/**\n * Replaces any detected circular dependency with the string '[Circular]'\n * Mutates original object\n * @param inputObj {*}\n * @returns {*}\n */\nexports.breakCircularDeps = inputObj => {\n  const seen = new Set();\n\n  function _breakCircularDeps(obj) {\n    if (obj && typeof obj !== 'object') {\n      return obj;\n    }\n\n    if (seen.has(obj)) {\n      return '[Circular]';\n    }\n\n    seen.add(obj);\n    for (const k in obj) {\n      const descriptor = Object.getOwnPropertyDescriptor(obj, k);\n\n      if (descriptor && descriptor.writable) {\n        obj[k] = _breakCircularDeps(obj[k], k);\n      }\n    }\n\n    // deleting means only a seen object that is its own child will be detected\n    seen.delete(obj);\n    return obj;\n  }\n\n  return _breakCircularDeps(inputObj);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsU0FBUyxtQkFBTyxDQUFDLHlDQUFJOztBQUVyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBLGNBQWM7QUFDZCxrQ0FBa0MsMEJBQTBCO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixHQUFHO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjLHlCQUF5QixjQUFjO0FBQ2xHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHlCQUF5QjtBQUM5RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCLEtBQWU7QUFDaEM7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixhQUFhO0FBQ2I7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvdXRpbHMuanM/N2YyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyB1c2VkIHRocm91Z2hvdXQgTW9jaGEncyBjb2RlYmFzZS5cbiAqIEBtb2R1bGUgdXRpbHNcbiAqL1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgaGUgPSByZXF1aXJlKCdoZScpO1xuXG5jb25zdCBNT0NIQV9JRF9QUk9QX05BTUUgPSAnX19tb2NoYV9pZF9fJztcblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciAtIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIC0gQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgZWl0aGVyIGNvbnN0cnVjdG9yIGlzIG51bGwsIG9yIGlmIHN1cGVyIGNvbnN0cnVjdG9yXG4gKiAgICAgbGFja3MgYSBwcm90b3R5cGUuXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSB1dGlsLmluaGVyaXRzO1xuXG4vKipcbiAqIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHN0cmluZyBvZiBodG1sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5lc2NhcGUgPSBmdW5jdGlvbiAoaHRtbCkge1xuICByZXR1cm4gaGUuZW5jb2RlKFN0cmluZyhodG1sKSwge3VzZU5hbWVkUmVmZXJlbmNlczogZmFsc2V9KTtcbn07XG5cbi8qKlxuICogVGVzdCBpZiB0aGUgZ2l2ZW4gb2JqIGlzIHR5cGUgb2Ygc3RyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzU3RyaW5nID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ3N0cmluZyc7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgYSBzbHVnIGZyb20gdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuc2x1ZyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgLnJlcGxhY2UoL1xccysvZywgJy0nKVxuICAgIC5yZXBsYWNlKC9bXi1cXHddL2csICcnKVxuICAgIC5yZXBsYWNlKC8tezIsfS9nLCAnLScpO1xufTtcblxuLyoqXG4gKiBTdHJpcCB0aGUgZnVuY3Rpb24gZGVmaW5pdGlvbiBmcm9tIGBzdHJgLCBhbmQgcmUtaW5kZW50IGZvciBwcmUgd2hpdGVzcGFjZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuY2xlYW4gPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHN0ciA9IHN0clxuICAgIC5yZXBsYWNlKC9cXHJcXG4/fFtcXG5cXHUyMDI4XFx1MjAyOV0vZywgJ1xcbicpXG4gICAgLnJlcGxhY2UoL15cXHVGRUZGLywgJycpXG4gICAgLy8gKHRyYWRpdGlvbmFsKS0+ICBzcGFjZS9uYW1lICAgICBwYXJhbWV0ZXJzICAgIGJvZHkgICAgIChsYW1iZGEpLT4gcGFyYW1ldGVycyAgICAgICBib2R5ICAgbXVsdGktc3RhdGVtZW50L3NpbmdsZSAgICAgICAgICBrZWVwIGJvZHkgY29udGVudFxuICAgIC5yZXBsYWNlKFxuICAgICAgL15mdW5jdGlvbig/Olxccyp8XFxzW14oXSopXFwoW14pXSpcXClcXHMqXFx7KCg/Oi58XFxuKSo/KVxcfSR8XlxcKFteKV0qXFwpXFxzKj0+XFxzKig/OlxceygoPzoufFxcbikqPylcXH18KCg/Oi58XFxuKSopKSQvLFxuICAgICAgJyQxJDIkMydcbiAgICApO1xuXG4gIHZhciBzcGFjZXMgPSBzdHIubWF0Y2goL15cXG4/KCAqKS8pWzFdLmxlbmd0aDtcbiAgdmFyIHRhYnMgPSBzdHIubWF0Y2goL15cXG4/KFxcdCopLylbMV0ubGVuZ3RoO1xuICB2YXIgcmUgPSBuZXcgUmVnRXhwKFxuICAgICdeXFxuPycgKyAodGFicyA/ICdcXHQnIDogJyAnKSArICd7JyArICh0YWJzIHx8IHNwYWNlcykgKyAnfScsXG4gICAgJ2dtJ1xuICApO1xuXG4gIHN0ciA9IHN0ci5yZXBsYWNlKHJlLCAnJyk7XG5cbiAgcmV0dXJuIHN0ci50cmltKCk7XG59O1xuXG4vKipcbiAqIElmIGEgdmFsdWUgY291bGQgaGF2ZSBwcm9wZXJ0aWVzLCBhbmQgaGFzIG5vbmUsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLFxuICogd2hpY2ggcmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZW1wdHkgdmFsdWUuXG4gKlxuICogRnVuY3Rpb25zIHcvIG5vIHByb3BlcnRpZXMgcmV0dXJuIGAnW0Z1bmN0aW9uXSdgXG4gKiBBcnJheXMgdy8gbGVuZ3RoID09PSAwIHJldHVybiBgJ1tdJ2BcbiAqIE9iamVjdHMgdy8gbm8gcHJvcGVydGllcyByZXR1cm4gYCd7fSdgXG4gKiBBbGwgZWxzZTogcmV0dXJuIHJlc3VsdCBvZiBgdmFsdWUudG9TdHJpbmcoKWBcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlSGludCBUaGUgdHlwZSBvZiB0aGUgdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVtcHR5UmVwcmVzZW50YXRpb24odmFsdWUsIHR5cGVIaW50KSB7XG4gIHN3aXRjaCAodHlwZUhpbnQpIHtcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gJ1tGdW5jdGlvbl0nO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gJ3t9JztcbiAgICBjYXNlICdhcnJheSc6XG4gICAgICByZXR1cm4gJ1tdJztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUYWtlcyBzb21lIHZhcmlhYmxlIGFuZCBhc2tzIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClgIHdoYXQgaXQgdGhpbmtzIGl0XG4gKiBpcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvdG9TdHJpbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb21wdXRlZCB0eXBlXG4gKiBAZXhhbXBsZVxuICogY2Fub25pY2FsVHlwZSh7fSkgLy8gJ29iamVjdCdcbiAqIGNhbm9uaWNhbFR5cGUoW10pIC8vICdhcnJheSdcbiAqIGNhbm9uaWNhbFR5cGUoMSkgLy8gJ251bWJlcidcbiAqIGNhbm9uaWNhbFR5cGUoZmFsc2UpIC8vICdib29sZWFuJ1xuICogY2Fub25pY2FsVHlwZShJbmZpbml0eSkgLy8gJ251bWJlcidcbiAqIGNhbm9uaWNhbFR5cGUobnVsbCkgLy8gJ251bGwnXG4gKiBjYW5vbmljYWxUeXBlKG5ldyBEYXRlKCkpIC8vICdkYXRlJ1xuICogY2Fub25pY2FsVHlwZSgvZm9vLykgLy8gJ3JlZ2V4cCdcbiAqIGNhbm9uaWNhbFR5cGUoJ3R5cGUnKSAvLyAnc3RyaW5nJ1xuICogY2Fub25pY2FsVHlwZShnbG9iYWwpIC8vICdnbG9iYWwnXG4gKiBjYW5vbmljYWxUeXBlKG5ldyBTdHJpbmcoJ2ZvbycpIC8vICdvYmplY3QnXG4gKiBjYW5vbmljYWxUeXBlKGFzeW5jIGZ1bmN0aW9uKCkge30pIC8vICdhc3luY2Z1bmN0aW9uJ1xuICogY2Fub25pY2FsVHlwZShPYmplY3QuY3JlYXRlKG51bGwpKSAvLyAnbnVsbC1wcm90b3R5cGUnXG4gKi9cbnZhciBjYW5vbmljYWxUeXBlID0gKGV4cG9ydHMuY2Fub25pY2FsVHlwZSA9IGZ1bmN0aW9uIGNhbm9uaWNhbFR5cGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gJ2J1ZmZlcic7XG4gIH0gZWxzZSBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnbnVsbC1wcm90b3R5cGUnO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAuY2FsbCh2YWx1ZSlcbiAgICAucmVwbGFjZSgvXlxcWy4rXFxzKC4rPyldJC8sICckMScpXG4gICAgLnRvTG93ZXJDYXNlKCk7XG59KTtcblxuLyoqXG4gKlxuICogUmV0dXJucyBhIGdlbmVyYWwgdHlwZSBvciBkYXRhIHN0cnVjdHVyZSBvZiBhIHZhcmlhYmxlXG4gKiBAcHJpdmF0ZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0RhdGFfc3RydWN0dXJlc1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IE9uZSBvZiB1bmRlZmluZWQsIGJvb2xlYW4sIG51bWJlciwgc3RyaW5nLCBiaWdpbnQsIHN5bWJvbCwgb2JqZWN0XG4gKiBAZXhhbXBsZVxuICogdHlwZSh7fSkgLy8gJ29iamVjdCdcbiAqIHR5cGUoW10pIC8vICdhcnJheSdcbiAqIHR5cGUoMSkgLy8gJ251bWJlcidcbiAqIHR5cGUoZmFsc2UpIC8vICdib29sZWFuJ1xuICogdHlwZShJbmZpbml0eSkgLy8gJ251bWJlcidcbiAqIHR5cGUobnVsbCkgLy8gJ251bGwnXG4gKiB0eXBlKG5ldyBEYXRlKCkpIC8vICdvYmplY3QnXG4gKiB0eXBlKC9mb28vKSAvLyAnb2JqZWN0J1xuICogdHlwZSgndHlwZScpIC8vICdzdHJpbmcnXG4gKiB0eXBlKGdsb2JhbCkgLy8gJ29iamVjdCdcbiAqIHR5cGUobmV3IFN0cmluZygnZm9vJykgLy8gJ3N0cmluZydcbiAqL1xuZXhwb3J0cy50eXBlID0gZnVuY3Rpb24gdHlwZSh2YWx1ZSkge1xuICAvLyBOdWxsIGlzIHNwZWNpYWxcbiAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuICBjb25zdCBwcmltaXRpdmVzID0gbmV3IFNldChbXG4gICAgJ3VuZGVmaW5lZCcsXG4gICAgJ2Jvb2xlYW4nLFxuICAgICdudW1iZXInLFxuICAgICdzdHJpbmcnLFxuICAgICdiaWdpbnQnLFxuICAgICdzeW1ib2wnXG4gIF0pO1xuICBjb25zdCBfdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKF90eXBlID09PSAnZnVuY3Rpb24nKSByZXR1cm4gX3R5cGU7XG4gIGlmIChwcmltaXRpdmVzLmhhcyhfdHlwZSkpIHJldHVybiBfdHlwZTtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSByZXR1cm4gJ3N0cmluZyc7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gJ2Vycm9yJztcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm4gJ2FycmF5JztcblxuICByZXR1cm4gX3R5cGU7XG59O1xuXG4vKipcbiAqIFN0cmluZ2lmeSBgdmFsdWVgLiBEaWZmZXJlbnQgYmVoYXZpb3IgZGVwZW5kaW5nIG9uIHR5cGUgb2YgdmFsdWU6XG4gKlxuICogLSBJZiBgdmFsdWVgIGlzIHVuZGVmaW5lZCBvciBudWxsLCByZXR1cm4gYCdbdW5kZWZpbmVkXSdgIG9yIGAnW251bGxdJ2AsIHJlc3BlY3RpdmVseS5cbiAqIC0gSWYgYHZhbHVlYCBpcyBub3QgYW4gb2JqZWN0LCBmdW5jdGlvbiBvciBhcnJheSwgcmV0dXJuIHJlc3VsdCBvZiBgdmFsdWUudG9TdHJpbmcoKWAgd3JhcHBlZCBpbiBkb3VibGUtcXVvdGVzLlxuICogLSBJZiBgdmFsdWVgIGlzIGFuICplbXB0eSogb2JqZWN0LCBmdW5jdGlvbiwgb3IgYXJyYXksIHJldHVybiByZXN1bHQgb2YgZnVuY3Rpb25cbiAqICAge0BsaW5rIGVtcHR5UmVwcmVzZW50YXRpb259LlxuICogLSBJZiBgdmFsdWVgIGhhcyBwcm9wZXJ0aWVzLCBjYWxsIHtAbGluayBleHBvcnRzLmNhbm9uaWNhbGl6ZX0gb24gaXQsIHRoZW4gcmV0dXJuIHJlc3VsdCBvZlxuICogICBKU09OLnN0cmluZ2lmeSgpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAc2VlIGV4cG9ydHMudHlwZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgdHlwZUhpbnQgPSBjYW5vbmljYWxUeXBlKHZhbHVlKTtcblxuICBpZiAoIX5bJ29iamVjdCcsICdhcnJheScsICdmdW5jdGlvbicsICdudWxsLXByb3RvdHlwZSddLmluZGV4T2YodHlwZUhpbnQpKSB7XG4gICAgaWYgKHR5cGVIaW50ID09PSAnYnVmZmVyJykge1xuICAgICAgdmFyIGpzb24gPSBCdWZmZXIucHJvdG90eXBlLnRvSlNPTi5jYWxsKHZhbHVlKTtcbiAgICAgIC8vIEJhc2VkIG9uIHRoZSB0b0pTT04gcmVzdWx0XG4gICAgICByZXR1cm4ganNvblN0cmluZ2lmeShcbiAgICAgICAganNvbi5kYXRhICYmIGpzb24udHlwZSA/IGpzb24uZGF0YSA6IGpzb24sXG4gICAgICAgIDJcbiAgICAgICkucmVwbGFjZSgvLChcXG58JCkvZywgJyQxJyk7XG4gICAgfVxuXG4gICAgLy8gSUU3L0lFOCBoYXMgYSBiaXphcnJlIFN0cmluZyBjb25zdHJ1Y3RvcjsgbmVlZHMgdG8gYmUgY29lcmNlZFxuICAgIC8vIGludG8gYW4gYXJyYXkgYW5kIGJhY2sgdG8gb2JqLlxuICAgIGlmICh0eXBlSGludCA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnJykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGNoYXIsIGlkeCkge1xuICAgICAgICBhY2NbaWR4XSA9IGNoYXI7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSk7XG4gICAgICB0eXBlSGludCA9ICdvYmplY3QnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ganNvblN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgcHJvcCBpbiB2YWx1ZSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHByb3ApKSB7XG4gICAgICByZXR1cm4ganNvblN0cmluZ2lmeShcbiAgICAgICAgZXhwb3J0cy5jYW5vbmljYWxpemUodmFsdWUsIG51bGwsIHR5cGVIaW50KSxcbiAgICAgICAgMlxuICAgICAgKS5yZXBsYWNlKC8sKFxcbnwkKS9nLCAnJDEnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZW1wdHlSZXByZXNlbnRhdGlvbih2YWx1ZSwgdHlwZUhpbnQpO1xufTtcblxuLyoqXG4gKiBsaWtlIEpTT04uc3RyaW5naWZ5IGJ1dCBtb3JlIHNlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gIG9iamVjdFxuICogQHBhcmFtIHtudW1iZXI9fSBzcGFjZXNcbiAqIEBwYXJhbSB7bnVtYmVyPX0gZGVwdGhcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBqc29uU3RyaW5naWZ5KG9iamVjdCwgc3BhY2VzLCBkZXB0aCkge1xuICBpZiAodHlwZW9mIHNwYWNlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBwcmltaXRpdmUgdHlwZXNcbiAgICByZXR1cm4gX3N0cmluZ2lmeShvYmplY3QpO1xuICB9XG5cbiAgZGVwdGggPSBkZXB0aCB8fCAxO1xuICB2YXIgc3BhY2UgPSBzcGFjZXMgKiBkZXB0aDtcbiAgdmFyIHN0ciA9IEFycmF5LmlzQXJyYXkob2JqZWN0KSA/ICdbJyA6ICd7JztcbiAgdmFyIGVuZCA9IEFycmF5LmlzQXJyYXkob2JqZWN0KSA/ICddJyA6ICd9JztcbiAgdmFyIGxlbmd0aCA9XG4gICAgdHlwZW9mIG9iamVjdC5sZW5ndGggPT09ICdudW1iZXInXG4gICAgICA/IG9iamVjdC5sZW5ndGhcbiAgICAgIDogT2JqZWN0LmtleXMob2JqZWN0KS5sZW5ndGg7XG4gIC8vIGAucmVwZWF0KClgIHBvbHlmaWxsXG4gIGZ1bmN0aW9uIHJlcGVhdChzLCBuKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheShuKS5qb2luKHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3N0cmluZ2lmeSh2YWwpIHtcbiAgICBzd2l0Y2ggKGNhbm9uaWNhbFR5cGUodmFsKSkge1xuICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICB2YWwgPSAnWycgKyB2YWwgKyAnXSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgdmFsID0ganNvblN0cmluZ2lmeSh2YWwsIHNwYWNlcywgZGVwdGggKyAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgdmFsID1cbiAgICAgICAgICB2YWwgPT09IDAgJiYgMSAvIHZhbCA9PT0gLUluZmluaXR5IC8vIGAtMGBcbiAgICAgICAgICAgID8gJy0wJ1xuICAgICAgICAgICAgOiB2YWwudG9TdHJpbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICB2YWwgPSB2YWwudG9TdHJpbmcoKSArICduJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgdmFyIHNEYXRlID0gaXNOYU4odmFsLmdldFRpbWUoKSkgPyB2YWwudG9TdHJpbmcoKSA6IHZhbC50b0lTT1N0cmluZygpO1xuICAgICAgICB2YWwgPSAnW0RhdGU6ICcgKyBzRGF0ZSArICddJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdidWZmZXInOlxuICAgICAgICB2YXIganNvbiA9IHZhbC50b0pTT04oKTtcbiAgICAgICAgLy8gQmFzZWQgb24gdGhlIHRvSlNPTiByZXN1bHRcbiAgICAgICAganNvbiA9IGpzb24uZGF0YSAmJiBqc29uLnR5cGUgPyBqc29uLmRhdGEgOiBqc29uO1xuICAgICAgICB2YWwgPSAnW0J1ZmZlcjogJyArIGpzb25TdHJpbmdpZnkoanNvbiwgMiwgZGVwdGggKyAxKSArICddJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YWwgPVxuICAgICAgICAgIHZhbCA9PT0gJ1tGdW5jdGlvbl0nIHx8IHZhbCA9PT0gJ1tDaXJjdWxhcl0nXG4gICAgICAgICAgICA/IHZhbFxuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh2YWwpOyAvLyBzdHJpbmdcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGZvciAodmFyIGkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBpKSkge1xuICAgICAgY29udGludWU7IC8vIG5vdCBteSBidXNpbmVzc1xuICAgIH1cbiAgICAtLWxlbmd0aDtcbiAgICBzdHIgKz1cbiAgICAgICdcXG4gJyArXG4gICAgICByZXBlYXQoJyAnLCBzcGFjZSkgK1xuICAgICAgKEFycmF5LmlzQXJyYXkob2JqZWN0KSA/ICcnIDogJ1wiJyArIGkgKyAnXCI6ICcpICsgLy8ga2V5XG4gICAgICBfc3RyaW5naWZ5KG9iamVjdFtpXSkgKyAvLyB2YWx1ZVxuICAgICAgKGxlbmd0aCA/ICcsJyA6ICcnKTsgLy8gY29tbWFcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgc3RyICtcbiAgICAvLyBbXSwge31cbiAgICAoc3RyLmxlbmd0aCAhPT0gMSA/ICdcXG4nICsgcmVwZWF0KCcgJywgLS1zcGFjZSkgKyBlbmQgOiBlbmQpXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgbmV3IFRoaW5nIHRoYXQgaGFzIHRoZSBrZXlzIGluIHNvcnRlZCBvcmRlci4gUmVjdXJzaXZlLlxuICpcbiAqIElmIHRoZSBUaGluZy4uLlxuICogLSBoYXMgYWxyZWFkeSBiZWVuIHNlZW4sIHJldHVybiBzdHJpbmcgYCdbQ2lyY3VsYXJdJ2BcbiAqIC0gaXMgYHVuZGVmaW5lZGAsIHJldHVybiBzdHJpbmcgYCdbdW5kZWZpbmVkXSdgXG4gKiAtIGlzIGBudWxsYCwgcmV0dXJuIHZhbHVlIGBudWxsYFxuICogLSBpcyBzb21lIG90aGVyIHByaW1pdGl2ZSwgcmV0dXJuIHRoZSB2YWx1ZVxuICogLSBpcyBub3QgYSBwcmltaXRpdmUgb3IgYW4gYEFycmF5YCwgYE9iamVjdGAsIG9yIGBGdW5jdGlvbmAsIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIFRoaW5nJ3MgYHRvU3RyaW5nKClgIG1ldGhvZFxuICogLSBpcyBhIG5vbi1lbXB0eSBgQXJyYXlgLCBgT2JqZWN0YCwgb3IgYEZ1bmN0aW9uYCwgcmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIGFnYWluLlxuICogLSBpcyBhbiBlbXB0eSBgQXJyYXlgLCBgT2JqZWN0YCwgb3IgYEZ1bmN0aW9uYCwgcmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZW1wdHlSZXByZXNlbnRhdGlvbigpYFxuICpcbiAqIEBwcml2YXRlXG4gKiBAc2VlIHtAbGluayBleHBvcnRzLnN0cmluZ2lmeX1cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhpbmcgdG8gaW5zcGVjdC4gIE1heSBvciBtYXkgbm90IGhhdmUgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFjaz1bXV0gU3RhY2sgb2Ygc2VlbiB2YWx1ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZUhpbnRdIFR5cGUgaGludFxuICogQHJldHVybiB7KE9iamVjdHxBcnJheXxGdW5jdGlvbnxzdHJpbmd8dW5kZWZpbmVkKX1cbiAqL1xuZXhwb3J0cy5jYW5vbmljYWxpemUgPSBmdW5jdGlvbiBjYW5vbmljYWxpemUodmFsdWUsIHN0YWNrLCB0eXBlSGludCkge1xuICB2YXIgY2Fub25pY2FsaXplZE9iajtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgdmFyIHByb3A7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgdHlwZUhpbnQgPSB0eXBlSGludCB8fCBjYW5vbmljYWxUeXBlKHZhbHVlKTtcbiAgZnVuY3Rpb24gd2l0aFN0YWNrKHZhbHVlLCBmbikge1xuICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgIGZuKCk7XG4gICAgc3RhY2sucG9wKCk7XG4gIH1cblxuICBzdGFjayA9IHN0YWNrIHx8IFtdO1xuXG4gIGlmIChzdGFjay5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlSGludCkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgY2FzZSAnYnVmZmVyJzpcbiAgICBjYXNlICdudWxsJzpcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIHdpdGhTdGFjayh2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjYW5vbmljYWxpemVkT2JqID0gdmFsdWUubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cG9ydHMuY2Fub25pY2FsaXplKGl0ZW0sIHN0YWNrKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycywgbm8tdW5yZWFjaGFibGUtbG9vcCAqL1xuICAgICAgZm9yIChwcm9wIGluIHZhbHVlKSB7XG4gICAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB7fTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIGd1YXJkLWZvci1pbiAqL1xuICAgICAgaWYgKCFjYW5vbmljYWxpemVkT2JqKSB7XG4gICAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBlbXB0eVJlcHJlc2VudGF0aW9uKHZhbHVlLCB0eXBlSGludCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlICdudWxsLXByb3RvdHlwZSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBjYW5vbmljYWxpemVkT2JqIHx8IHt9O1xuICAgICAgaWYgKHR5cGVIaW50ID09PSAnbnVsbC1wcm90b3R5cGUnICYmIFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkge1xuICAgICAgICBjYW5vbmljYWxpemVkT2JqWydbU3ltYm9sLnRvU3RyaW5nVGFnXSddID0gdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXTtcbiAgICAgIH1cbiAgICAgIHdpdGhTdGFjayh2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSlcbiAgICAgICAgICAuc29ydCgpXG4gICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY2Fub25pY2FsaXplZE9ialtrZXldID0gZXhwb3J0cy5jYW5vbmljYWxpemUodmFsdWVba2V5XSwgc3RhY2spO1xuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkYXRlJzpcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBjYW5vbmljYWxpemVkT2JqID0gdmFsdWUgKyAnJztcbiAgfVxuXG4gIHJldHVybiBjYW5vbmljYWxpemVkT2JqO1xufTtcblxuLyoqXG4gKiBAc3VtbWFyeVxuICogVGhpcyBGaWx0ZXIgYmFzZWQgb24gYG1vY2hhLWNsZWFuYCBtb2R1bGUuKHNlZTogYGdpdGh1Yi5jb20vcnN0YWNydXovbW9jaGEtY2xlYW5gKVxuICogQGRlc2NyaXB0aW9uXG4gKiBXaGVuIGludm9raW5nIHRoaXMgZnVuY3Rpb24geW91IGdldCBhIGZpbHRlciBmdW5jdGlvbiB0aGF0IGdldCB0aGUgRXJyb3Iuc3RhY2sgYXMgYW4gaW5wdXQsXG4gKiBhbmQgcmV0dXJuIGEgcHJldHRpZnkgb3V0cHV0LlxuICogKGkuZTogc3RyaXAgTW9jaGEgYW5kIGludGVybmFsIG5vZGUgZnVuY3Rpb25zIGZyb20gc3RhY2sgdHJhY2UpLlxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnRzLnN0YWNrVHJhY2VGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRPRE86IFJlcGxhY2Ugd2l0aCBgcHJvY2Vzcy5icm93c2VyYFxuICB2YXIgaXMgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8ge25vZGU6IHRydWV9IDoge2Jyb3dzZXI6IHRydWV9O1xuICB2YXIgc2xhc2ggPSBwYXRoLnNlcDtcbiAgdmFyIGN3ZDtcbiAgaWYgKGlzLm5vZGUpIHtcbiAgICBjd2QgPSBleHBvcnRzLmN3ZCgpICsgc2xhc2g7XG4gIH0gZWxzZSB7XG4gICAgY3dkID0gKFxuICAgICAgdHlwZW9mIGxvY2F0aW9uID09PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5sb2NhdGlvbiA6IGxvY2F0aW9uXG4gICAgKS5ocmVmLnJlcGxhY2UoL1xcL1teL10qJC8sICcvJyk7XG4gICAgc2xhc2ggPSAnLyc7XG4gIH1cblxuICBmdW5jdGlvbiBpc01vY2hhSW50ZXJuYWwobGluZSkge1xuICAgIHJldHVybiAoXG4gICAgICB+bGluZS5pbmRleE9mKCdub2RlX21vZHVsZXMnICsgc2xhc2ggKyAnbW9jaGEnICsgc2xhc2gpIHx8XG4gICAgICB+bGluZS5pbmRleE9mKHNsYXNoICsgJ21vY2hhLmpzJykgfHxcbiAgICAgIH5saW5lLmluZGV4T2Yoc2xhc2ggKyAnbW9jaGEubWluLmpzJylcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlSW50ZXJuYWwobGluZSkge1xuICAgIHJldHVybiAoXG4gICAgICB+bGluZS5pbmRleE9mKCcodGltZXJzLmpzOicpIHx8XG4gICAgICB+bGluZS5pbmRleE9mKCcoZXZlbnRzLmpzOicpIHx8XG4gICAgICB+bGluZS5pbmRleE9mKCcobm9kZS5qczonKSB8fFxuICAgICAgfmxpbmUuaW5kZXhPZignKG1vZHVsZS5qczonKSB8fFxuICAgICAgfmxpbmUuaW5kZXhPZignR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUubmV4dCAobmF0aXZlKScpIHx8XG4gICAgICBmYWxzZVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAgc3RhY2sgPSBzdGFjay5zcGxpdCgnXFxuJyk7XG5cbiAgICBzdGFjayA9IHN0YWNrLnJlZHVjZShmdW5jdGlvbiAobGlzdCwgbGluZSkge1xuICAgICAgaWYgKGlzTW9jaGFJbnRlcm5hbChsaW5lKSkge1xuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzLm5vZGUgJiYgaXNOb2RlSW50ZXJuYWwobGluZSkpIHtcbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFuIHVwIGN3ZChhYnNvbHV0ZSlcbiAgICAgIGlmICgvOlxcZCs6XFxkK1xcKT8kLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoJygnICsgY3dkLCAnKCcpO1xuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2gobGluZSk7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gc3RhY2suam9pbignXFxuJyk7XG4gIH07XG59O1xuXG4vKipcbiAqIENydWRlLCBidXQgZWZmZWN0aXZlLlxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IGB2YWx1ZWAgaXMgYSBQcm9taXNlXG4gKi9cbmV4cG9ydHMuaXNQcm9taXNlID0gZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgIHZhbHVlICE9PSBudWxsICYmXG4gICAgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbidcbiAgKTtcbn07XG5cbi8qKlxuICogQ2xhbXBzIGEgbnVtZXJpYyB2YWx1ZSB0byBhbiBpbmNsdXNpdmUgcmFuZ2UuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVmFsdWUgdG8gYmUgY2xhbXBlZC5cbiAqIEBwYXJhbSB7bnVtYmVyW119IHJhbmdlIC0gVHdvIGVsZW1lbnQgYXJyYXkgc3BlY2lmeWluZyBbbWluLCBtYXhdIHJhbmdlLlxuICogQHJldHVybnMge251bWJlcn0gY2xhbXBlZCB2YWx1ZVxuICovXG5leHBvcnRzLmNsYW1wID0gZnVuY3Rpb24gY2xhbXAodmFsdWUsIHJhbmdlKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgcmFuZ2VbMF0pLCByYW5nZVsxXSk7XG59O1xuXG4vKipcbiAqIEl0J3MgYSBub29wLlxuICogQHB1YmxpY1xuICovXG5leHBvcnRzLm5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwLWxpa2Ugb2JqZWN0LlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSBcIm1hcFwiIGlzIGFuIG9iamVjdCB3aXRoIG5vIHByb3RvdHlwZSwgZm9yIG91ciBwdXJwb3Nlcy4gSW4gc29tZSBjYXNlc1xuICogdGhpcyB3b3VsZCBiZSBtb3JlIGFwcHJvcHJpYXRlIHRoYW4gYSBgTWFwYCwgZXNwZWNpYWxseSBpZiB5b3VyIGVudmlyb25tZW50XG4gKiBkb2Vzbid0IHN1cHBvcnQgaXQuIFJlY29tbWVuZGVkIGZvciB1c2UgaW4gTW9jaGEncyBwdWJsaWMgQVBJcy5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXAjQ3VzdG9tX2FuZF9OdWxsX29iamVjdHN8TUROOk1hcH1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9jcmVhdGUjQ3VzdG9tX2FuZF9OdWxsX29iamVjdHN8TUROOk9iamVjdC5jcmVhdGUgLSBDdXN0b20gb2JqZWN0c31cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24jQ3VzdG9tX2FuZF9OdWxsX29iamVjdHN8TUROOk9iamVjdC5hc3NpZ259XG4gKiBAcGFyYW0gey4uLip9IFtvYmpdIC0gQXJndW1lbnRzIHRvIGBPYmplY3QuYXNzaWduKClgLlxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHdpdGggbm8gcHJvdG90eXBlLCBoYXZpbmcgYC4uLm9iamAgcHJvcGVydGllc1xuICovXG5leHBvcnRzLmNyZWF0ZU1hcCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24uYXBwbHkoXG4gICAgbnVsbCxcbiAgICBbT2JqZWN0LmNyZWF0ZShudWxsKV0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSByZWFkLW9ubHkgbWFwLWxpa2Ugb2JqZWN0LlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBkaWZmZXJzIGZyb20ge0BsaW5rIG1vZHVsZTp1dGlscy5jcmVhdGVNYXAgY3JlYXRlTWFwfSBvbmx5IGluIHRoYXRcbiAqIHRoZSBhcmd1bWVudCBtdXN0IGJlIG5vbi1lbXB0eSwgYmVjYXVzZSB0aGUgcmVzdWx0IGlzIGZyb3plbi5cbiAqXG4gKiBAc2VlIHtAbGluayBtb2R1bGU6dXRpbHMuY3JlYXRlTWFwIGNyZWF0ZU1hcH1cbiAqIEBwYXJhbSB7Li4uKn0gW29ial0gLSBBcmd1bWVudHMgdG8gYE9iamVjdC5hc3NpZ24oKWAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBIGZyb3plbiBvYmplY3Qgd2l0aCBubyBwcm90b3R5cGUsIGhhdmluZyBgLi4ub2JqYCBwcm9wZXJ0aWVzXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIGFyZ3VtZW50IGlzIG5vdCBhIG5vbi1lbXB0eSBvYmplY3QuXG4gKi9cbmV4cG9ydHMuZGVmaW5lQ29uc3RhbnRzID0gZnVuY3Rpb24gKG9iaikge1xuICBpZiAoY2Fub25pY2FsVHlwZShvYmopICE9PSAnb2JqZWN0JyB8fCAhT2JqZWN0LmtleXMob2JqKS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50OyBleHBlY3RlZCBhIG5vbi1lbXB0eSBvYmplY3QnKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShleHBvcnRzLmNyZWF0ZU1hcChvYmopKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5XG4gKlxuICogV3JhcHBlciBhcm91bmQgYHByb2Nlc3MuY3dkKClgIGZvciBpc29sYXRpb25cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuY3dkID0gZnVuY3Rpb24gY3dkKCkge1xuICByZXR1cm4gcHJvY2Vzcy5jd2QoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgTW9jaGEgaXMgcnVubmluZyBpbiBhIGJyb3dzZXIuXG4gKiBDaGVja3MgZm9yIGBwcm9jZXNzLmJyb3dzZXJgLlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmlzQnJvd3NlciA9IGZ1bmN0aW9uIGlzQnJvd3NlcigpIHtcbiAgcmV0dXJuIEJvb2xlYW4ocHJvY2Vzcy5icm93c2VyKTtcbn07XG5cbi8qXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGFuIGFycmF5OyB1c2VmdWwgZm9yIG9wdGlvbmFsbHkgYWNjZXB0aW5nIGFycmF5IHBhcmFtZXRlcnNcbiAqXG4gKiBJdCBmb2xsb3dzIHRoZXNlIHJ1bGVzLCBkZXBlbmRpbmcgb24gYHZhbHVlYC4gIElmIGB2YWx1ZWAgaXMuLi5cbiAqIDEuIGB1bmRlZmluZWRgOiByZXR1cm4gYW4gZW1wdHkgQXJyYXlcbiAqIDIuIGBudWxsYDogcmV0dXJuIGFuIGFycmF5IHdpdGggYSBzaW5nbGUgYG51bGxgIGVsZW1lbnRcbiAqIDMuIEFueSBvdGhlciBvYmplY3Q6IHJldHVybiB0aGUgdmFsdWUgb2YgYEFycmF5LmZyb20oKWAgX2lmXyB0aGUgb2JqZWN0IGlzIGl0ZXJhYmxlXG4gKiA0LiBvdGhlcndpc2U6IHJldHVybiBhbiBhcnJheSB3aXRoIGEgc2luZ2xlIGVsZW1lbnQsIGB2YWx1ZWBcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBTb21ldGhpbmcgdG8gY2FzdCB0byBhbiBBcnJheVxuICogQHJldHVybnMge0FycmF5PCo+fVxuICovXG5leHBvcnRzLmNhc3RBcnJheSA9IGZ1bmN0aW9uIGNhc3RBcnJheSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gW251bGxdO1xuICB9XG4gIGlmIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgKHR5cGVvZiB2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nIHx8IHZhbHVlLmxlbmd0aCAhPT0gdW5kZWZpbmVkKVxuICApIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIFt2YWx1ZV07XG59O1xuXG5leHBvcnRzLmNvbnN0YW50cyA9IGV4cG9ydHMuZGVmaW5lQ29uc3RhbnRzKHtcbiAgTU9DSEFfSURfUFJPUF9OQU1FXG59KTtcblxuY29uc3QgdW5pcXVlSURCYXNlID1cbiAgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVowMTIzNDU2Nzg5LV8nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdW5pcXVlIGlkZW50aWZpZXJcbiAqIERvZXMgbm90IGNyZWF0ZSBjcnlwdG9ncmFwaGljYWxseSBzYWZlIGlkcy5cbiAqIFRyaXZpYWwgY29weSBvZiBuYW5vaWQvbm9uLXNlY3VyZVxuICogQHJldHVybnMge3N0cmluZ30gVW5pcXVlIGlkZW50aWZpZXJcbiAqL1xuZXhwb3J0cy51bmlxdWVJRCA9ICgpID0+IHtcbiAgbGV0IGlkID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMjE7IGkrKykge1xuICAgIGlkICs9IHVuaXF1ZUlEQmFzZVsoTWF0aC5yYW5kb20oKSAqIDY0KSB8IDBdO1xuICB9XG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuYXNzaWduTmV3TW9jaGFJRCA9IG9iaiA9PiB7XG4gIGNvbnN0IGlkID0gZXhwb3J0cy51bmlxdWVJRCgpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBNT0NIQV9JRF9QUk9QX05BTUUsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG9iajtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGEgTW9jaGEgSUQgZnJvbSBhbiBvYmplY3QsIGlmIHByZXNlbnQuXG4gKiBAcGFyYW0geyp9IFtvYmpdIC0gT2JqZWN0XG4gKiBAcmV0dXJucyB7c3RyaW5nfHZvaWR9XG4gKi9cbmV4cG9ydHMuZ2V0TW9jaGFJRCA9IG9iaiA9PlxuICBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgPyBvYmpbTU9DSEFfSURfUFJPUF9OQU1FXSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBSZXBsYWNlcyBhbnkgZGV0ZWN0ZWQgY2lyY3VsYXIgZGVwZW5kZW5jeSB3aXRoIHRoZSBzdHJpbmcgJ1tDaXJjdWxhcl0nXG4gKiBNdXRhdGVzIG9yaWdpbmFsIG9iamVjdFxuICogQHBhcmFtIGlucHV0T2JqIHsqfVxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydHMuYnJlYWtDaXJjdWxhckRlcHMgPSBpbnB1dE9iaiA9PiB7XG4gIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG5cbiAgZnVuY3Rpb24gX2JyZWFrQ2lyY3VsYXJEZXBzKG9iaikge1xuICAgIGlmIChvYmogJiYgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgaWYgKHNlZW4uaGFzKG9iaikpIHtcbiAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgfVxuXG4gICAgc2Vlbi5hZGQob2JqKTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gb2JqKSB7XG4gICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGspO1xuXG4gICAgICBpZiAoZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLndyaXRhYmxlKSB7XG4gICAgICAgIG9ialtrXSA9IF9icmVha0NpcmN1bGFyRGVwcyhvYmpba10sIGspO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRlbGV0aW5nIG1lYW5zIG9ubHkgYSBzZWVuIG9iamVjdCB0aGF0IGlzIGl0cyBvd24gY2hpbGQgd2lsbCBiZSBkZXRlY3RlZFxuICAgIHNlZW4uZGVsZXRlKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHJldHVybiBfYnJlYWtDaXJjdWxhckRlcHMoaW5wdXRPYmopO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mocha/lib/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mocha/lib/mocharc.json":
/*!*********************************************!*\
  !*** ./node_modules/mocha/lib/mocharc.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"diff":true,"extension":["js","cjs","mjs"],"package":"./package.json","reporter":"spec","slow":75,"timeout":2000,"ui":"bdd","watch-ignore":["node_modules",".git"]}');

/***/ }),

/***/ "(ssr)/./node_modules/mocha/package.json":
/*!*****************************************!*\
  !*** ./node_modules/mocha/package.json ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"mocha","version":"10.8.2","type":"commonjs","description":"simple, flexible, fun test framework","keywords":["mocha","test","bdd","tdd","tap","testing","chai","assertion","ava","jest","tape","jasmine","karma"],"author":"TJ Holowaychuk <tj@vision-media.ca>","license":"MIT","repository":{"type":"git","url":"https://github.com/mochajs/mocha.git"},"bugs":{"url":"https://github.com/mochajs/mocha/issues/"},"discord":"https://discord.gg/KeDn2uXhER","homepage":"https://mochajs.org/","logo":"https://cldup.com/S9uQ-cOLYz.svg","notifyLogo":"https://ibin.co/4QuRuGjXvl36.png","bin":{"mocha":"./bin/mocha.js","_mocha":"./bin/_mocha"},"directories":{"lib":"./lib","test":"./test"},"engines":{"node":">= 14.0.0"},"scripts":{"build":"rollup -c ./rollup.config.js","clean":"rimraf mocha.js mocha.js.map","docs-clean":"rimraf docs/_site docs/api","docs-watch":"eleventy --serve","docs:api":"jsdoc -c jsdoc.conf.json","docs:site":"eleventy","docs":"run-s docs-clean docs:*","format:eslint":"eslint --fix . \\"bin/*\\"","format:prettier":"prettier --write \\"!(package*).json\\" \\".*.json\\" \\"lib/**/*.json\\" \\"*.yml\\"","format":"run-s format:*","lint:knip":"knip --cache","lint:code":"eslint . \\"bin/*\\" --max-warnings 0","lint:markdown":"markdownlint \\"*.md\\" \\"docs/**/*.md\\" \\".github/*.md\\" \\"lib/**/*.md\\" \\"test/**/*.md\\" \\"example/**/*.md\\" -i CHANGELOG.md","lint":"run-p lint:*","prepublishOnly":"run-s clean build","test-browser-run":"cross-env NODE_PATH=. karma start ./karma.conf.js --single-run","test-browser:reporters:bdd":"cross-env MOCHA_TEST=bdd npm run -s test-browser-run","test-browser:reporters:esm":"cross-env MOCHA_TEST=esm npm run -s test-browser-run","test-browser:reporters:qunit":"cross-env MOCHA_TEST=qunit npm run -s test-browser-run","test-browser:reporters:tdd":"cross-env MOCHA_TEST=tdd npm run -s test-browser-run","test-browser:reporters":"run-s test-browser:reporters:*","test-browser:webpack-compat":"webpack --mode development --config ./test/browser-specific/fixtures/webpack/webpack.config.js","test-browser":"run-s clean build test-browser:*","test-coverage-clean":"rimraf .nyc_output coverage","test-coverage-generate":"nyc report --reporter=lcov --reporter=text","test-node-run-only":"nyc --no-clean --reporter=json node bin/mocha.js","test-node-run":"nyc --no-clean --reporter=json node bin/mocha.js --forbid-only","test-node:integration":"run-s clean build && npm run -s test-node-run -- --parallel --timeout 10000 --slow 3750 \\"test/integration/**/*.spec.js\\"","test-node:interfaces:bdd":"npm run -s test-node-run -- --ui bdd test/interfaces/bdd.spec","test-node:interfaces:exports":"npm run -s test-node-run -- --ui exports test/interfaces/exports.spec","test-node:interfaces:qunit":"npm run -s test-node-run -- --ui qunit test/interfaces/qunit.spec","test-node:interfaces:tdd":"npm run -s test-node-run -- --ui tdd test/interfaces/tdd.spec","test-node:interfaces":"run-p test-node:interfaces:*","test-node:jsapi":"node test/jsapi/index.js","test-node:only:bddRequire":"npm run -s test-node-run-only -- --ui qunit test/only/bdd-require.spec --no-parallel","test-node:only:globalBdd":"npm run -s test-node-run-only -- --ui bdd test/only/global/bdd.spec --no-parallel","test-node:only:globalQunit":"npm run -s test-node-run-only -- --ui qunit test/only/global/qunit.spec --no-parallel","test-node:only:globalTdd":"npm run -s test-node-run-only -- --ui tdd test/only/global/tdd.spec --no-parallel","test-node:only":"run-p test-node:only:*","test-node:reporters":"npm run -s test-node-run -- \\"test/reporters/*.spec.js\\"","test-node:requires":"npm run -s test-node-run -- --require coffeescript/register --require test/require/a.js --require test/require/b.coffee --require test/require/c.js --require test/require/d.coffee test/require/require.spec.js","test-node:unit":"npm run -s test-node-run -- \\"test/unit/*.spec.js\\" \\"test/node-unit/**/*.spec.js\\"","test-node":"run-s test-coverage-clean test-node:* test-coverage-generate","test-smoke":"node ./bin/mocha --no-config test/smoke/smoke.spec.js","test":"run-s lint test-node test-browser","version:linkify-changelog":"node scripts/linkify-changelog.mjs","version:update-authors":"node scripts/update-authors.js","version":"run-p version:* && git add -A ./AUTHORS ./CHANGELOG.md"},"dependencies":{"ansi-colors":"^4.1.3","browser-stdout":"^1.3.1","chokidar":"^3.5.3","debug":"^4.3.5","diff":"^5.2.0","escape-string-regexp":"^4.0.0","find-up":"^5.0.0","glob":"^8.1.0","he":"^1.2.0","js-yaml":"^4.1.0","log-symbols":"^4.1.0","minimatch":"^5.1.6","ms":"^2.1.3","serialize-javascript":"^6.0.2","strip-json-comments":"^3.1.1","supports-color":"^8.1.1","workerpool":"^6.5.1","yargs":"^16.2.0","yargs-parser":"^20.2.9","yargs-unparser":"^2.0.0"},"devDependencies":{"@11ty/eleventy":"^1.0.0","@11ty/eleventy-plugin-inclusive-language":"^1.0.3","@eslint/js":"^8.56.0","@mocha/docdash":"^4.0.1","@rollup/plugin-commonjs":"^21.0.2","@rollup/plugin-json":"^4.1.0","@rollup/plugin-multi-entry":"^4.0.1","@rollup/plugin-node-resolve":"^13.1.3","chai":"^4.3.4","coffeescript":"^2.6.1","cross-env":"^7.0.2","eslint":"^8.56.0","fail-on-errors-webpack-plugin":"^3.0.0","fs-extra":"^10.0.0","globals":"^13.24.0","jsdoc":"^3.6.7","jsdoc-ts-utils":"^2.0.1","karma":"^6.4.2","karma-chrome-launcher":"^3.2.0","karma-mocha":"^2.0.1","karma-mocha-reporter":"^2.2.5","karma-sauce-launcher":"^4.3.6","knip":"^5.27.0","markdown-it":"^12.3.2","markdown-it-anchor":"^8.4.1","markdown-it-attrs":"^4.1.3","markdown-it-emoji":"^2.0.0","markdown-it-prism":"^2.2.2","markdown-toc":"^1.2.0","markdownlint-cli":"^0.30.0","needle":"^2.5.0","npm-run-all2":"^6.2.0","nyc":"^15.1.0","pidtree":"^0.5.0","prettier":"^2.4.1","remark":"^14.0.2","remark-github":"^11.2.2","remark-inline-links":"^6.0.1","rewiremock":"^3.14.3","rimraf":"^3.0.2","rollup":"^2.70.1","rollup-plugin-node-globals":"^1.4.0","rollup-plugin-polyfill-node":"^0.8.0","rollup-plugin-visualizer":"^5.6.0","sinon":"^9.0.3","strip-ansi":"^6.0.0","unexpected":"^11.14.0","unexpected-eventemitter":"^2.2.0","unexpected-map":"^2.0.0","unexpected-set":"^3.0.0","unexpected-sinon":"^10.11.2","uslug":"^1.0.4","webpack":"^5.67.0","webpack-cli":"^4.9.1"},"files":["bin/*mocha*","lib/**/*.{js,html,json}","index.js","mocha.css","mocha.js","mocha.js.map","browser-entry.js"],"browser":{"./index.js":"./browser-entry.js","fs":false,"path":false,"supports-color":false,"./lib/nodejs/buffered-worker-pool.js":false,"./lib/nodejs/esm-utils.js":false,"./lib/nodejs/file-unloader.js":false,"./lib/nodejs/parallel-buffered-runner.js":false,"./lib/nodejs/serializer.js":false,"./lib/nodejs/worker.js":false,"./lib/nodejs/reporters/parallel-buffered.js":false,"./lib/cli/index.js":false},"prettier":{"arrowParens":"avoid","bracketSpacing":false,"endOfLine":"auto","singleQuote":true,"trailingComma":"none"},"overrides":{"webdriverio":"^7.33.0"}}');

/***/ })

};
;