"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/chai-as-promised";
exports.ids = ["vendor-chunks/chai-as-promised"];
exports.modules = {

/***/ "(ssr)/./node_modules/chai-as-promised/lib/chai-as-promised.js":
/*!***************************************************************!*\
  !*** ./node_modules/chai-as-promised/lib/chai-as-promised.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/* eslint-disable no-invalid-this */\nlet checkError = __webpack_require__(/*! check-error */ \"(ssr)/./node_modules/check-error/index.js\");\n\nmodule.exports = (chai, utils) => {\n    const Assertion = chai.Assertion;\n    const assert = chai.assert;\n    const proxify = utils.proxify;\n\n    // If we are using a version of Chai that has checkError on it,\n    // we want to use that version to be consistent. Otherwise, we use\n    // what was passed to the factory.\n    if (utils.checkError) {\n        checkError = utils.checkError;\n    }\n\n    function isLegacyJQueryPromise(thenable) {\n        // jQuery promises are Promises/A+-compatible since 3.0.0. jQuery 3.0.0 is also the first version\n        // to define the catch method.\n        return typeof thenable.catch !== \"function\" &&\n               typeof thenable.always === \"function\" &&\n               typeof thenable.done === \"function\" &&\n               typeof thenable.fail === \"function\" &&\n               typeof thenable.pipe === \"function\" &&\n               typeof thenable.progress === \"function\" &&\n               typeof thenable.state === \"function\";\n    }\n\n    function assertIsAboutPromise(assertion) {\n        if (typeof assertion._obj.then !== \"function\") {\n            throw new TypeError(utils.inspect(assertion._obj) + \" is not a thenable.\");\n        }\n        if (isLegacyJQueryPromise(assertion._obj)) {\n            throw new TypeError(\"Chai as Promised is incompatible with thenables of jQuery<3.0.0, sorry! Please \" +\n                                \"upgrade jQuery or use another Promises/A+ compatible library (see \" +\n                                \"http://promisesaplus.com/).\");\n        }\n    }\n\n    function proxifyIfSupported(assertion) {\n        return proxify === undefined ? assertion : proxify(assertion);\n    }\n\n    function method(name, asserter) {\n        utils.addMethod(Assertion.prototype, name, function () {\n            assertIsAboutPromise(this);\n            return asserter.apply(this, arguments);\n        });\n    }\n\n    function property(name, asserter) {\n        utils.addProperty(Assertion.prototype, name, function () {\n            assertIsAboutPromise(this);\n            return proxifyIfSupported(asserter.apply(this, arguments));\n        });\n    }\n\n    function doNotify(promise, done) {\n        promise.then(() => done(), done);\n    }\n\n    // These are for clarity and to bypass Chai refusing to allow `undefined` as actual when used with `assert`.\n    function assertIfNegated(assertion, message, extra) {\n        assertion.assert(true, null, message, extra.expected, extra.actual);\n    }\n\n    function assertIfNotNegated(assertion, message, extra) {\n        assertion.assert(false, message, null, extra.expected, extra.actual);\n    }\n\n    function getBasePromise(assertion) {\n        // We need to chain subsequent asserters on top of ones in the chain already (consider\n        // `eventually.have.property(\"foo\").that.equals(\"bar\")`), only running them after the existing ones pass.\n        // So the first base-promise is `assertion._obj`, but after that we use the assertions themselves, i.e.\n        // previously derived promises, to chain off of.\n        return typeof assertion.then === \"function\" ? assertion : assertion._obj;\n    }\n\n    function getReasonName(reason) {\n        return reason instanceof Error ? reason.toString() : checkError.getConstructorName(reason);\n    }\n\n    // Grab these first, before we modify `Assertion.prototype`.\n\n    const propertyNames = Object.getOwnPropertyNames(Assertion.prototype);\n\n    const propertyDescs = {};\n    for (const name of propertyNames) {\n        propertyDescs[name] = Object.getOwnPropertyDescriptor(Assertion.prototype, name);\n    }\n\n    property(\"fulfilled\", function () {\n        const derivedPromise = getBasePromise(this).then(\n            value => {\n                assertIfNegated(this,\n                                \"expected promise not to be fulfilled but it was fulfilled with #{act}\",\n                                { actual: value });\n                return value;\n            },\n            reason => {\n                assertIfNotNegated(this,\n                                   \"expected promise to be fulfilled but it was rejected with #{act}\",\n                                   { actual: getReasonName(reason) });\n                return reason;\n            }\n        );\n\n        module.exports.transferPromiseness(this, derivedPromise);\n        return this;\n    });\n\n    property(\"rejected\", function () {\n        const derivedPromise = getBasePromise(this).then(\n            value => {\n                assertIfNotNegated(this,\n                                   \"expected promise to be rejected but it was fulfilled with #{act}\",\n                                   { actual: value });\n                return value;\n            },\n            reason => {\n                assertIfNegated(this,\n                                \"expected promise not to be rejected but it was rejected with #{act}\",\n                                { actual: getReasonName(reason) });\n\n                // Return the reason, transforming this into a fulfillment, to allow further assertions, e.g.\n                // `promise.should.be.rejected.and.eventually.equal(\"reason\")`.\n                return reason;\n            }\n        );\n\n        module.exports.transferPromiseness(this, derivedPromise);\n        return this;\n    });\n\n    method(\"rejectedWith\", function (errorLike, errMsgMatcher, message) {\n        let errorLikeName = null;\n        const negate = utils.flag(this, \"negate\") || false;\n\n        // rejectedWith with that is called without arguments is\n        // the same as a plain \".rejected\" use.\n        if (errorLike === undefined && errMsgMatcher === undefined &&\n            message === undefined) {\n            /* eslint-disable no-unused-expressions */\n            return this.rejected;\n            /* eslint-enable no-unused-expressions */\n        }\n\n        if (message !== undefined) {\n            utils.flag(this, \"message\", message);\n        }\n\n        if (errorLike instanceof RegExp || typeof errorLike === \"string\") {\n            errMsgMatcher = errorLike;\n            errorLike = null;\n        } else if (errorLike && errorLike instanceof Error) {\n            errorLikeName = errorLike.toString();\n        } else if (typeof errorLike === \"function\") {\n            errorLikeName = checkError.getConstructorName(errorLike);\n        } else {\n            errorLike = null;\n        }\n        const everyArgIsDefined = Boolean(errorLike && errMsgMatcher);\n\n        let matcherRelation = \"including\";\n        if (errMsgMatcher instanceof RegExp) {\n            matcherRelation = \"matching\";\n        }\n\n        const derivedPromise = getBasePromise(this).then(\n            value => {\n                let assertionMessage = null;\n                let expected = null;\n\n                if (errorLike) {\n                    assertionMessage = \"expected promise to be rejected with #{exp} but it was fulfilled with #{act}\";\n                    expected = errorLikeName;\n                } else if (errMsgMatcher) {\n                    assertionMessage = `expected promise to be rejected with an error ${matcherRelation} #{exp} but ` +\n                                       `it was fulfilled with #{act}`;\n                    expected = errMsgMatcher;\n                }\n\n                assertIfNotNegated(this, assertionMessage, { expected, actual: value });\n                return value;\n            },\n            reason => {\n                const errorLikeCompatible = errorLike && (errorLike instanceof Error ?\n                                                        checkError.compatibleInstance(reason, errorLike) :\n                                                        checkError.compatibleConstructor(reason, errorLike));\n\n                const errMsgMatcherCompatible = errMsgMatcher && checkError.compatibleMessage(reason, errMsgMatcher);\n\n                const reasonName = getReasonName(reason);\n\n                if (negate && everyArgIsDefined) {\n                    if (errorLikeCompatible && errMsgMatcherCompatible) {\n                        this.assert(true,\n                                    null,\n                                    \"expected promise not to be rejected with #{exp} but it was rejected \" +\n                                    \"with #{act}\",\n                                    errorLikeName,\n                                    reasonName);\n                    }\n                } else {\n                    if (errorLike) {\n                        this.assert(errorLikeCompatible,\n                                    \"expected promise to be rejected with #{exp} but it was rejected with #{act}\",\n                                    \"expected promise not to be rejected with #{exp} but it was rejected \" +\n                                    \"with #{act}\",\n                                    errorLikeName,\n                                    reasonName);\n                    }\n\n                    if (errMsgMatcher) {\n                        this.assert(errMsgMatcherCompatible,\n                                    `expected promise to be rejected with an error ${matcherRelation} #{exp} but got ` +\n                                    `#{act}`,\n                                    `expected promise not to be rejected with an error ${matcherRelation} #{exp}`,\n                                    errMsgMatcher,\n                                    checkError.getMessage(reason));\n                    }\n                }\n\n                return reason;\n            }\n        );\n\n        module.exports.transferPromiseness(this, derivedPromise);\n        return this;\n    });\n\n    property(\"eventually\", function () {\n        utils.flag(this, \"eventually\", true);\n        return this;\n    });\n\n    method(\"notify\", function (done) {\n        doNotify(getBasePromise(this), done);\n        return this;\n    });\n\n    method(\"become\", function (value, message) {\n        return this.eventually.deep.equal(value, message);\n    });\n\n    // ### `eventually`\n\n    // We need to be careful not to trigger any getters, thus `Object.getOwnPropertyDescriptor` usage.\n    const methodNames = propertyNames.filter(name => {\n        return name !== \"assert\" && typeof propertyDescs[name].value === \"function\";\n    });\n\n    methodNames.forEach(methodName => {\n        Assertion.overwriteMethod(methodName, originalMethod => function () {\n            return doAsserterAsyncAndAddThen(originalMethod, this, arguments);\n        });\n    });\n\n    const getterNames = propertyNames.filter(name => {\n        return name !== \"_obj\" && typeof propertyDescs[name].get === \"function\";\n    });\n\n    getterNames.forEach(getterName => {\n        // Chainable methods are things like `an`, which can work both for `.should.be.an.instanceOf` and as\n        // `should.be.an(\"object\")`. We need to handle those specially.\n        const isChainableMethod = Assertion.prototype.__methods.hasOwnProperty(getterName);\n\n        if (isChainableMethod) {\n            Assertion.overwriteChainableMethod(\n                getterName,\n                originalMethod => function () {\n                    return doAsserterAsyncAndAddThen(originalMethod, this, arguments);\n                },\n                originalGetter => function () {\n                    return doAsserterAsyncAndAddThen(originalGetter, this);\n                }\n            );\n        } else {\n            Assertion.overwriteProperty(getterName, originalGetter => function () {\n                return proxifyIfSupported(doAsserterAsyncAndAddThen(originalGetter, this));\n            });\n        }\n    });\n\n    function doAsserterAsyncAndAddThen(asserter, assertion, args) {\n        // Since we're intercepting all methods/properties, we need to just pass through if they don't want\n        // `eventually`, or if we've already fulfilled the promise (see below).\n        if (!utils.flag(assertion, \"eventually\")) {\n            asserter.apply(assertion, args);\n            return assertion;\n        }\n\n        const derivedPromise = getBasePromise(assertion).then(value => {\n            // Set up the environment for the asserter to actually run: `_obj` should be the fulfillment value, and\n            // now that we have the value, we're no longer in \"eventually\" mode, so we won't run any of this code,\n            // just the base Chai code that we get to via the short-circuit above.\n            assertion._obj = value;\n            utils.flag(assertion, \"eventually\", false);\n\n            return args ? module.exports.transformAsserterArgs(args) : args;\n        }).then(newArgs => {\n            asserter.apply(assertion, newArgs);\n\n            // Because asserters, for example `property`, can change the value of `_obj` (i.e. change the \"object\"\n            // flag), we need to communicate this value change to subsequent chained asserters. Since we build a\n            // promise chain paralleling the asserter chain, we can use it to communicate such changes.\n            return assertion._obj;\n        });\n\n        module.exports.transferPromiseness(assertion, derivedPromise);\n        return assertion;\n    }\n\n    // ### Now use the `Assertion` framework to build an `assert` interface.\n    const originalAssertMethods = Object.getOwnPropertyNames(assert).filter(propName => {\n        return typeof assert[propName] === \"function\";\n    });\n\n    assert.isFulfilled = (promise, message) => (new Assertion(promise, message)).to.be.fulfilled;\n\n    assert.isRejected = (promise, errorLike, errMsgMatcher, message) => {\n        const assertion = new Assertion(promise, message);\n        return assertion.to.be.rejectedWith(errorLike, errMsgMatcher, message);\n    };\n\n    assert.becomes = (promise, value, message) => assert.eventually.deepEqual(promise, value, message);\n\n    assert.doesNotBecome = (promise, value, message) => assert.eventually.notDeepEqual(promise, value, message);\n\n    assert.eventually = {};\n    originalAssertMethods.forEach(assertMethodName => {\n        assert.eventually[assertMethodName] = function (promise) {\n            const otherArgs = Array.prototype.slice.call(arguments, 1);\n\n            let customRejectionHandler;\n            const message = arguments[assert[assertMethodName].length - 1];\n            if (typeof message === \"string\") {\n                customRejectionHandler = reason => {\n                    throw new chai.AssertionError(`${message}\\n\\nOriginal reason: ${utils.inspect(reason)}`);\n                };\n            }\n\n            const returnedPromise = promise.then(\n                fulfillmentValue => assert[assertMethodName].apply(assert, [fulfillmentValue].concat(otherArgs)),\n                customRejectionHandler\n            );\n\n            returnedPromise.notify = done => {\n                doNotify(returnedPromise, done);\n            };\n\n            return returnedPromise;\n        };\n    });\n};\n\nmodule.exports.transferPromiseness = (assertion, promise) => {\n    assertion.then = promise.then.bind(promise);\n};\n\nmodule.exports.transformAsserterArgs = values => values;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hhaS1hcy1wcm9taXNlZC9saWIvY2hhaS1hcy1wcm9taXNlZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsOERBQWE7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyxJQUFJO0FBQ3RHLGtDQUFrQyxlQUFlO0FBQ2pEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnR0FBZ0csSUFBSTtBQUNwRyxxQ0FBcUMsK0JBQStCO0FBQ3BFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxJQUFJO0FBQ3BHLHFDQUFxQyxlQUFlO0FBQ3BEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnR0FBZ0csSUFBSTtBQUNwRyxrQ0FBa0MsK0JBQStCOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0VBQStFLEtBQUssNEJBQTRCLElBQUk7QUFDcEg7QUFDQSxrQkFBa0I7QUFDbEIsd0ZBQXdGLGlCQUFpQixFQUFFLEtBQUs7QUFDaEgsZ0VBQWdFLElBQUk7QUFDcEU7QUFDQTs7QUFFQSw2REFBNkQseUJBQXlCO0FBQ3RGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLEtBQUs7QUFDckYsNENBQTRDLElBQUk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSw0RUFBNEUsS0FBSywyQkFBMkIsSUFBSTtBQUNoSCxnRkFBZ0YsS0FBSztBQUNyRiw0Q0FBNEMsSUFBSTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFGQUFxRixpQkFBaUIsRUFBRSxLQUFLO0FBQzdHLHVDQUF1QyxJQUFJO0FBQzNDLHlGQUF5RixpQkFBaUIsRUFBRSxJQUFJO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsUUFBUSx1QkFBdUIsc0JBQXNCO0FBQzFHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7O0FBRUEsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9jaGFpLWFzLXByb21pc2VkL2xpYi9jaGFpLWFzLXByb21pc2VkLmpzPzU2MDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cbmxldCBjaGVja0Vycm9yID0gcmVxdWlyZShcImNoZWNrLWVycm9yXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChjaGFpLCB1dGlscykgPT4ge1xuICAgIGNvbnN0IEFzc2VydGlvbiA9IGNoYWkuQXNzZXJ0aW9uO1xuICAgIGNvbnN0IGFzc2VydCA9IGNoYWkuYXNzZXJ0O1xuICAgIGNvbnN0IHByb3hpZnkgPSB1dGlscy5wcm94aWZ5O1xuXG4gICAgLy8gSWYgd2UgYXJlIHVzaW5nIGEgdmVyc2lvbiBvZiBDaGFpIHRoYXQgaGFzIGNoZWNrRXJyb3Igb24gaXQsXG4gICAgLy8gd2Ugd2FudCB0byB1c2UgdGhhdCB2ZXJzaW9uIHRvIGJlIGNvbnNpc3RlbnQuIE90aGVyd2lzZSwgd2UgdXNlXG4gICAgLy8gd2hhdCB3YXMgcGFzc2VkIHRvIHRoZSBmYWN0b3J5LlxuICAgIGlmICh1dGlscy5jaGVja0Vycm9yKSB7XG4gICAgICAgIGNoZWNrRXJyb3IgPSB1dGlscy5jaGVja0Vycm9yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGVnYWN5SlF1ZXJ5UHJvbWlzZSh0aGVuYWJsZSkge1xuICAgICAgICAvLyBqUXVlcnkgcHJvbWlzZXMgYXJlIFByb21pc2VzL0ErLWNvbXBhdGlibGUgc2luY2UgMy4wLjAuIGpRdWVyeSAzLjAuMCBpcyBhbHNvIHRoZSBmaXJzdCB2ZXJzaW9uXG4gICAgICAgIC8vIHRvIGRlZmluZSB0aGUgY2F0Y2ggbWV0aG9kLlxuICAgICAgICByZXR1cm4gdHlwZW9mIHRoZW5hYmxlLmNhdGNoICE9PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgIHR5cGVvZiB0aGVuYWJsZS5hbHdheXMgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgdHlwZW9mIHRoZW5hYmxlLmRvbmUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgdHlwZW9mIHRoZW5hYmxlLmZhaWwgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgdHlwZW9mIHRoZW5hYmxlLnBpcGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgdHlwZW9mIHRoZW5hYmxlLnByb2dyZXNzID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgIHR5cGVvZiB0aGVuYWJsZS5zdGF0ZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzc2VydElzQWJvdXRQcm9taXNlKGFzc2VydGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIGFzc2VydGlvbi5fb2JqLnRoZW4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcih1dGlscy5pbnNwZWN0KGFzc2VydGlvbi5fb2JqKSArIFwiIGlzIG5vdCBhIHRoZW5hYmxlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMZWdhY3lKUXVlcnlQcm9taXNlKGFzc2VydGlvbi5fb2JqKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNoYWkgYXMgUHJvbWlzZWQgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlbmFibGVzIG9mIGpRdWVyeTwzLjAuMCwgc29ycnkhIFBsZWFzZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidXBncmFkZSBqUXVlcnkgb3IgdXNlIGFub3RoZXIgUHJvbWlzZXMvQSsgY29tcGF0aWJsZSBsaWJyYXJ5IChzZWUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImh0dHA6Ly9wcm9taXNlc2FwbHVzLmNvbS8pLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb3hpZnlJZlN1cHBvcnRlZChhc3NlcnRpb24pIHtcbiAgICAgICAgcmV0dXJuIHByb3hpZnkgPT09IHVuZGVmaW5lZCA/IGFzc2VydGlvbiA6IHByb3hpZnkoYXNzZXJ0aW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXRob2QobmFtZSwgYXNzZXJ0ZXIpIHtcbiAgICAgICAgdXRpbHMuYWRkTWV0aG9kKEFzc2VydGlvbi5wcm90b3R5cGUsIG5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFzc2VydElzQWJvdXRQcm9taXNlKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIGFzc2VydGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb3BlcnR5KG5hbWUsIGFzc2VydGVyKSB7XG4gICAgICAgIHV0aWxzLmFkZFByb3BlcnR5KEFzc2VydGlvbi5wcm90b3R5cGUsIG5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFzc2VydElzQWJvdXRQcm9taXNlKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHByb3hpZnlJZlN1cHBvcnRlZChhc3NlcnRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9Ob3RpZnkocHJvbWlzZSwgZG9uZSkge1xuICAgICAgICBwcm9taXNlLnRoZW4oKCkgPT4gZG9uZSgpLCBkb25lKTtcbiAgICB9XG5cbiAgICAvLyBUaGVzZSBhcmUgZm9yIGNsYXJpdHkgYW5kIHRvIGJ5cGFzcyBDaGFpIHJlZnVzaW5nIHRvIGFsbG93IGB1bmRlZmluZWRgIGFzIGFjdHVhbCB3aGVuIHVzZWQgd2l0aCBgYXNzZXJ0YC5cbiAgICBmdW5jdGlvbiBhc3NlcnRJZk5lZ2F0ZWQoYXNzZXJ0aW9uLCBtZXNzYWdlLCBleHRyYSkge1xuICAgICAgICBhc3NlcnRpb24uYXNzZXJ0KHRydWUsIG51bGwsIG1lc3NhZ2UsIGV4dHJhLmV4cGVjdGVkLCBleHRyYS5hY3R1YWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzc2VydElmTm90TmVnYXRlZChhc3NlcnRpb24sIG1lc3NhZ2UsIGV4dHJhKSB7XG4gICAgICAgIGFzc2VydGlvbi5hc3NlcnQoZmFsc2UsIG1lc3NhZ2UsIG51bGwsIGV4dHJhLmV4cGVjdGVkLCBleHRyYS5hY3R1YWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJhc2VQcm9taXNlKGFzc2VydGlvbikge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGNoYWluIHN1YnNlcXVlbnQgYXNzZXJ0ZXJzIG9uIHRvcCBvZiBvbmVzIGluIHRoZSBjaGFpbiBhbHJlYWR5IChjb25zaWRlclxuICAgICAgICAvLyBgZXZlbnR1YWxseS5oYXZlLnByb3BlcnR5KFwiZm9vXCIpLnRoYXQuZXF1YWxzKFwiYmFyXCIpYCksIG9ubHkgcnVubmluZyB0aGVtIGFmdGVyIHRoZSBleGlzdGluZyBvbmVzIHBhc3MuXG4gICAgICAgIC8vIFNvIHRoZSBmaXJzdCBiYXNlLXByb21pc2UgaXMgYGFzc2VydGlvbi5fb2JqYCwgYnV0IGFmdGVyIHRoYXQgd2UgdXNlIHRoZSBhc3NlcnRpb25zIHRoZW1zZWx2ZXMsIGkuZS5cbiAgICAgICAgLy8gcHJldmlvdXNseSBkZXJpdmVkIHByb21pc2VzLCB0byBjaGFpbiBvZmYgb2YuXG4gICAgICAgIHJldHVybiB0eXBlb2YgYXNzZXJ0aW9uLnRoZW4gPT09IFwiZnVuY3Rpb25cIiA/IGFzc2VydGlvbiA6IGFzc2VydGlvbi5fb2JqO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFJlYXNvbk5hbWUocmVhc29uKSB7XG4gICAgICAgIHJldHVybiByZWFzb24gaW5zdGFuY2VvZiBFcnJvciA/IHJlYXNvbi50b1N0cmluZygpIDogY2hlY2tFcnJvci5nZXRDb25zdHJ1Y3Rvck5hbWUocmVhc29uKTtcbiAgICB9XG5cbiAgICAvLyBHcmFiIHRoZXNlIGZpcnN0LCBiZWZvcmUgd2UgbW9kaWZ5IGBBc3NlcnRpb24ucHJvdG90eXBlYC5cblxuICAgIGNvbnN0IHByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhBc3NlcnRpb24ucHJvdG90eXBlKTtcblxuICAgIGNvbnN0IHByb3BlcnR5RGVzY3MgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgcHJvcGVydHlOYW1lcykge1xuICAgICAgICBwcm9wZXJ0eURlc2NzW25hbWVdID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihBc3NlcnRpb24ucHJvdG90eXBlLCBuYW1lKTtcbiAgICB9XG5cbiAgICBwcm9wZXJ0eShcImZ1bGZpbGxlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRlcml2ZWRQcm9taXNlID0gZ2V0QmFzZVByb21pc2UodGhpcykudGhlbihcbiAgICAgICAgICAgIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnRJZk5lZ2F0ZWQodGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJleHBlY3RlZCBwcm9taXNlIG5vdCB0byBiZSBmdWxmaWxsZWQgYnV0IGl0IHdhcyBmdWxmaWxsZWQgd2l0aCAje2FjdH1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBhY3R1YWw6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWFzb24gPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydElmTm90TmVnYXRlZCh0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImV4cGVjdGVkIHByb21pc2UgdG8gYmUgZnVsZmlsbGVkIGJ1dCBpdCB3YXMgcmVqZWN0ZWQgd2l0aCAje2FjdH1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBhY3R1YWw6IGdldFJlYXNvbk5hbWUocmVhc29uKSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhc29uO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzLnRyYW5zZmVyUHJvbWlzZW5lc3ModGhpcywgZGVyaXZlZFByb21pc2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcblxuICAgIHByb3BlcnR5KFwicmVqZWN0ZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBkZXJpdmVkUHJvbWlzZSA9IGdldEJhc2VQcm9taXNlKHRoaXMpLnRoZW4oXG4gICAgICAgICAgICB2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0SWZOb3ROZWdhdGVkKHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhwZWN0ZWQgcHJvbWlzZSB0byBiZSByZWplY3RlZCBidXQgaXQgd2FzIGZ1bGZpbGxlZCB3aXRoICN7YWN0fVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGFjdHVhbDogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlYXNvbiA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0SWZOZWdhdGVkKHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhwZWN0ZWQgcHJvbWlzZSBub3QgdG8gYmUgcmVqZWN0ZWQgYnV0IGl0IHdhcyByZWplY3RlZCB3aXRoICN7YWN0fVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGFjdHVhbDogZ2V0UmVhc29uTmFtZShyZWFzb24pIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSByZWFzb24sIHRyYW5zZm9ybWluZyB0aGlzIGludG8gYSBmdWxmaWxsbWVudCwgdG8gYWxsb3cgZnVydGhlciBhc3NlcnRpb25zLCBlLmcuXG4gICAgICAgICAgICAgICAgLy8gYHByb21pc2Uuc2hvdWxkLmJlLnJlamVjdGVkLmFuZC5ldmVudHVhbGx5LmVxdWFsKFwicmVhc29uXCIpYC5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhc29uO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzLnRyYW5zZmVyUHJvbWlzZW5lc3ModGhpcywgZGVyaXZlZFByb21pc2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcblxuICAgIG1ldGhvZChcInJlamVjdGVkV2l0aFwiLCBmdW5jdGlvbiAoZXJyb3JMaWtlLCBlcnJNc2dNYXRjaGVyLCBtZXNzYWdlKSB7XG4gICAgICAgIGxldCBlcnJvckxpa2VOYW1lID0gbnVsbDtcbiAgICAgICAgY29uc3QgbmVnYXRlID0gdXRpbHMuZmxhZyh0aGlzLCBcIm5lZ2F0ZVwiKSB8fCBmYWxzZTtcblxuICAgICAgICAvLyByZWplY3RlZFdpdGggd2l0aCB0aGF0IGlzIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50cyBpc1xuICAgICAgICAvLyB0aGUgc2FtZSBhcyBhIHBsYWluIFwiLnJlamVjdGVkXCIgdXNlLlxuICAgICAgICBpZiAoZXJyb3JMaWtlID09PSB1bmRlZmluZWQgJiYgZXJyTXNnTWF0Y2hlciA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBtZXNzYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVqZWN0ZWQ7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXRpbHMuZmxhZyh0aGlzLCBcIm1lc3NhZ2VcIiwgbWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3JMaWtlIGluc3RhbmNlb2YgUmVnRXhwIHx8IHR5cGVvZiBlcnJvckxpa2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGVyck1zZ01hdGNoZXIgPSBlcnJvckxpa2U7XG4gICAgICAgICAgICBlcnJvckxpa2UgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yTGlrZSAmJiBlcnJvckxpa2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgZXJyb3JMaWtlTmFtZSA9IGVycm9yTGlrZS50b1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlcnJvckxpa2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZXJyb3JMaWtlTmFtZSA9IGNoZWNrRXJyb3IuZ2V0Q29uc3RydWN0b3JOYW1lKGVycm9yTGlrZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvckxpa2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZXJ5QXJnSXNEZWZpbmVkID0gQm9vbGVhbihlcnJvckxpa2UgJiYgZXJyTXNnTWF0Y2hlcik7XG5cbiAgICAgICAgbGV0IG1hdGNoZXJSZWxhdGlvbiA9IFwiaW5jbHVkaW5nXCI7XG4gICAgICAgIGlmIChlcnJNc2dNYXRjaGVyIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICBtYXRjaGVyUmVsYXRpb24gPSBcIm1hdGNoaW5nXCI7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZXJpdmVkUHJvbWlzZSA9IGdldEJhc2VQcm9taXNlKHRoaXMpLnRoZW4oXG4gICAgICAgICAgICB2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGFzc2VydGlvbk1lc3NhZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBleHBlY3RlZCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JMaWtlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydGlvbk1lc3NhZ2UgPSBcImV4cGVjdGVkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQgd2l0aCAje2V4cH0gYnV0IGl0IHdhcyBmdWxmaWxsZWQgd2l0aCAje2FjdH1cIjtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQgPSBlcnJvckxpa2VOYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyTXNnTWF0Y2hlcikge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnRpb25NZXNzYWdlID0gYGV4cGVjdGVkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvciAke21hdGNoZXJSZWxhdGlvbn0gI3tleHB9IGJ1dCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBpdCB3YXMgZnVsZmlsbGVkIHdpdGggI3thY3R9YDtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQgPSBlcnJNc2dNYXRjaGVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFzc2VydElmTm90TmVnYXRlZCh0aGlzLCBhc3NlcnRpb25NZXNzYWdlLCB7IGV4cGVjdGVkLCBhY3R1YWw6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWFzb24gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTGlrZUNvbXBhdGlibGUgPSBlcnJvckxpa2UgJiYgKGVycm9yTGlrZSBpbnN0YW5jZW9mIEVycm9yID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tFcnJvci5jb21wYXRpYmxlSW5zdGFuY2UocmVhc29uLCBlcnJvckxpa2UpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tFcnJvci5jb21wYXRpYmxlQ29uc3RydWN0b3IocmVhc29uLCBlcnJvckxpa2UpKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZ01hdGNoZXJDb21wYXRpYmxlID0gZXJyTXNnTWF0Y2hlciAmJiBjaGVja0Vycm9yLmNvbXBhdGlibGVNZXNzYWdlKHJlYXNvbiwgZXJyTXNnTWF0Y2hlcik7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZWFzb25OYW1lID0gZ2V0UmVhc29uTmFtZShyZWFzb24pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5lZ2F0ZSAmJiBldmVyeUFyZ0lzRGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JMaWtlQ29tcGF0aWJsZSAmJiBlcnJNc2dNYXRjaGVyQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hc3NlcnQodHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImV4cGVjdGVkIHByb21pc2Ugbm90IHRvIGJlIHJlamVjdGVkIHdpdGggI3tleHB9IGJ1dCBpdCB3YXMgcmVqZWN0ZWQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aXRoICN7YWN0fVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JMaWtlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbk5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yTGlrZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hc3NlcnQoZXJyb3JMaWtlQ29tcGF0aWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhwZWN0ZWQgcHJvbWlzZSB0byBiZSByZWplY3RlZCB3aXRoICN7ZXhwfSBidXQgaXQgd2FzIHJlamVjdGVkIHdpdGggI3thY3R9XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImV4cGVjdGVkIHByb21pc2Ugbm90IHRvIGJlIHJlamVjdGVkIHdpdGggI3tleHB9IGJ1dCBpdCB3YXMgcmVqZWN0ZWQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aXRoICN7YWN0fVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JMaWtlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbk5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyck1zZ01hdGNoZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXNzZXJ0KGVyck1zZ01hdGNoZXJDb21wYXRpYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGV4cGVjdGVkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvciAke21hdGNoZXJSZWxhdGlvbn0gI3tleHB9IGJ1dCBnb3QgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgI3thY3R9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBleHBlY3RlZCBwcm9taXNlIG5vdCB0byBiZSByZWplY3RlZCB3aXRoIGFuIGVycm9yICR7bWF0Y2hlclJlbGF0aW9ufSAje2V4cH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyTXNnTWF0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRXJyb3IuZ2V0TWVzc2FnZShyZWFzb24pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZWFzb247XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMudHJhbnNmZXJQcm9taXNlbmVzcyh0aGlzLCBkZXJpdmVkUHJvbWlzZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuXG4gICAgcHJvcGVydHkoXCJldmVudHVhbGx5XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbHMuZmxhZyh0aGlzLCBcImV2ZW50dWFsbHlcIiwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuXG4gICAgbWV0aG9kKFwibm90aWZ5XCIsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgIGRvTm90aWZ5KGdldEJhc2VQcm9taXNlKHRoaXMpLCBkb25lKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG5cbiAgICBtZXRob2QoXCJiZWNvbWVcIiwgZnVuY3Rpb24gKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50dWFsbHkuZGVlcC5lcXVhbCh2YWx1ZSwgbWVzc2FnZSk7XG4gICAgfSk7XG5cbiAgICAvLyAjIyMgYGV2ZW50dWFsbHlgXG5cbiAgICAvLyBXZSBuZWVkIHRvIGJlIGNhcmVmdWwgbm90IHRvIHRyaWdnZXIgYW55IGdldHRlcnMsIHRodXMgYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIHVzYWdlLlxuICAgIGNvbnN0IG1ldGhvZE5hbWVzID0gcHJvcGVydHlOYW1lcy5maWx0ZXIobmFtZSA9PiB7XG4gICAgICAgIHJldHVybiBuYW1lICE9PSBcImFzc2VydFwiICYmIHR5cGVvZiBwcm9wZXJ0eURlc2NzW25hbWVdLnZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgfSk7XG5cbiAgICBtZXRob2ROYW1lcy5mb3JFYWNoKG1ldGhvZE5hbWUgPT4ge1xuICAgICAgICBBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKG1ldGhvZE5hbWUsIG9yaWdpbmFsTWV0aG9kID0+IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkb0Fzc2VydGVyQXN5bmNBbmRBZGRUaGVuKG9yaWdpbmFsTWV0aG9kLCB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGdldHRlck5hbWVzID0gcHJvcGVydHlOYW1lcy5maWx0ZXIobmFtZSA9PiB7XG4gICAgICAgIHJldHVybiBuYW1lICE9PSBcIl9vYmpcIiAmJiB0eXBlb2YgcHJvcGVydHlEZXNjc1tuYW1lXS5nZXQgPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9KTtcblxuICAgIGdldHRlck5hbWVzLmZvckVhY2goZ2V0dGVyTmFtZSA9PiB7XG4gICAgICAgIC8vIENoYWluYWJsZSBtZXRob2RzIGFyZSB0aGluZ3MgbGlrZSBgYW5gLCB3aGljaCBjYW4gd29yayBib3RoIGZvciBgLnNob3VsZC5iZS5hbi5pbnN0YW5jZU9mYCBhbmQgYXNcbiAgICAgICAgLy8gYHNob3VsZC5iZS5hbihcIm9iamVjdFwiKWAuIFdlIG5lZWQgdG8gaGFuZGxlIHRob3NlIHNwZWNpYWxseS5cbiAgICAgICAgY29uc3QgaXNDaGFpbmFibGVNZXRob2QgPSBBc3NlcnRpb24ucHJvdG90eXBlLl9fbWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShnZXR0ZXJOYW1lKTtcblxuICAgICAgICBpZiAoaXNDaGFpbmFibGVNZXRob2QpIHtcbiAgICAgICAgICAgIEFzc2VydGlvbi5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QoXG4gICAgICAgICAgICAgICAgZ2V0dGVyTmFtZSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbE1ldGhvZCA9PiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb0Fzc2VydGVyQXN5bmNBbmRBZGRUaGVuKG9yaWdpbmFsTWV0aG9kLCB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxHZXR0ZXIgPT4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9Bc3NlcnRlckFzeW5jQW5kQWRkVGhlbihvcmlnaW5hbEdldHRlciwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEFzc2VydGlvbi5vdmVyd3JpdGVQcm9wZXJ0eShnZXR0ZXJOYW1lLCBvcmlnaW5hbEdldHRlciA9PiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3hpZnlJZlN1cHBvcnRlZChkb0Fzc2VydGVyQXN5bmNBbmRBZGRUaGVuKG9yaWdpbmFsR2V0dGVyLCB0aGlzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZG9Bc3NlcnRlckFzeW5jQW5kQWRkVGhlbihhc3NlcnRlciwgYXNzZXJ0aW9uLCBhcmdzKSB7XG4gICAgICAgIC8vIFNpbmNlIHdlJ3JlIGludGVyY2VwdGluZyBhbGwgbWV0aG9kcy9wcm9wZXJ0aWVzLCB3ZSBuZWVkIHRvIGp1c3QgcGFzcyB0aHJvdWdoIGlmIHRoZXkgZG9uJ3Qgd2FudFxuICAgICAgICAvLyBgZXZlbnR1YWxseWAsIG9yIGlmIHdlJ3ZlIGFscmVhZHkgZnVsZmlsbGVkIHRoZSBwcm9taXNlIChzZWUgYmVsb3cpLlxuICAgICAgICBpZiAoIXV0aWxzLmZsYWcoYXNzZXJ0aW9uLCBcImV2ZW50dWFsbHlcIikpIHtcbiAgICAgICAgICAgIGFzc2VydGVyLmFwcGx5KGFzc2VydGlvbiwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gYXNzZXJ0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGVyaXZlZFByb21pc2UgPSBnZXRCYXNlUHJvbWlzZShhc3NlcnRpb24pLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgLy8gU2V0IHVwIHRoZSBlbnZpcm9ubWVudCBmb3IgdGhlIGFzc2VydGVyIHRvIGFjdHVhbGx5IHJ1bjogYF9vYmpgIHNob3VsZCBiZSB0aGUgZnVsZmlsbG1lbnQgdmFsdWUsIGFuZFxuICAgICAgICAgICAgLy8gbm93IHRoYXQgd2UgaGF2ZSB0aGUgdmFsdWUsIHdlJ3JlIG5vIGxvbmdlciBpbiBcImV2ZW50dWFsbHlcIiBtb2RlLCBzbyB3ZSB3b24ndCBydW4gYW55IG9mIHRoaXMgY29kZSxcbiAgICAgICAgICAgIC8vIGp1c3QgdGhlIGJhc2UgQ2hhaSBjb2RlIHRoYXQgd2UgZ2V0IHRvIHZpYSB0aGUgc2hvcnQtY2lyY3VpdCBhYm92ZS5cbiAgICAgICAgICAgIGFzc2VydGlvbi5fb2JqID0gdmFsdWU7XG4gICAgICAgICAgICB1dGlscy5mbGFnKGFzc2VydGlvbiwgXCJldmVudHVhbGx5XCIsIGZhbHNlKTtcblxuICAgICAgICAgICAgcmV0dXJuIGFyZ3MgPyBtb2R1bGUuZXhwb3J0cy50cmFuc2Zvcm1Bc3NlcnRlckFyZ3MoYXJncykgOiBhcmdzO1xuICAgICAgICB9KS50aGVuKG5ld0FyZ3MgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0ZXIuYXBwbHkoYXNzZXJ0aW9uLCBuZXdBcmdzKTtcblxuICAgICAgICAgICAgLy8gQmVjYXVzZSBhc3NlcnRlcnMsIGZvciBleGFtcGxlIGBwcm9wZXJ0eWAsIGNhbiBjaGFuZ2UgdGhlIHZhbHVlIG9mIGBfb2JqYCAoaS5lLiBjaGFuZ2UgdGhlIFwib2JqZWN0XCJcbiAgICAgICAgICAgIC8vIGZsYWcpLCB3ZSBuZWVkIHRvIGNvbW11bmljYXRlIHRoaXMgdmFsdWUgY2hhbmdlIHRvIHN1YnNlcXVlbnQgY2hhaW5lZCBhc3NlcnRlcnMuIFNpbmNlIHdlIGJ1aWxkIGFcbiAgICAgICAgICAgIC8vIHByb21pc2UgY2hhaW4gcGFyYWxsZWxpbmcgdGhlIGFzc2VydGVyIGNoYWluLCB3ZSBjYW4gdXNlIGl0IHRvIGNvbW11bmljYXRlIHN1Y2ggY2hhbmdlcy5cbiAgICAgICAgICAgIHJldHVybiBhc3NlcnRpb24uX29iajtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMudHJhbnNmZXJQcm9taXNlbmVzcyhhc3NlcnRpb24sIGRlcml2ZWRQcm9taXNlKTtcbiAgICAgICAgcmV0dXJuIGFzc2VydGlvbjtcbiAgICB9XG5cbiAgICAvLyAjIyMgTm93IHVzZSB0aGUgYEFzc2VydGlvbmAgZnJhbWV3b3JrIHRvIGJ1aWxkIGFuIGBhc3NlcnRgIGludGVyZmFjZS5cbiAgICBjb25zdCBvcmlnaW5hbEFzc2VydE1ldGhvZHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhc3NlcnQpLmZpbHRlcihwcm9wTmFtZSA9PiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYXNzZXJ0W3Byb3BOYW1lXSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH0pO1xuXG4gICAgYXNzZXJ0LmlzRnVsZmlsbGVkID0gKHByb21pc2UsIG1lc3NhZ2UpID0+IChuZXcgQXNzZXJ0aW9uKHByb21pc2UsIG1lc3NhZ2UpKS50by5iZS5mdWxmaWxsZWQ7XG5cbiAgICBhc3NlcnQuaXNSZWplY3RlZCA9IChwcm9taXNlLCBlcnJvckxpa2UsIGVyck1zZ01hdGNoZXIsIG1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29uc3QgYXNzZXJ0aW9uID0gbmV3IEFzc2VydGlvbihwcm9taXNlLCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGFzc2VydGlvbi50by5iZS5yZWplY3RlZFdpdGgoZXJyb3JMaWtlLCBlcnJNc2dNYXRjaGVyLCBtZXNzYWdlKTtcbiAgICB9O1xuXG4gICAgYXNzZXJ0LmJlY29tZXMgPSAocHJvbWlzZSwgdmFsdWUsIG1lc3NhZ2UpID0+IGFzc2VydC5ldmVudHVhbGx5LmRlZXBFcXVhbChwcm9taXNlLCB2YWx1ZSwgbWVzc2FnZSk7XG5cbiAgICBhc3NlcnQuZG9lc05vdEJlY29tZSA9IChwcm9taXNlLCB2YWx1ZSwgbWVzc2FnZSkgPT4gYXNzZXJ0LmV2ZW50dWFsbHkubm90RGVlcEVxdWFsKHByb21pc2UsIHZhbHVlLCBtZXNzYWdlKTtcblxuICAgIGFzc2VydC5ldmVudHVhbGx5ID0ge307XG4gICAgb3JpZ2luYWxBc3NlcnRNZXRob2RzLmZvckVhY2goYXNzZXJ0TWV0aG9kTmFtZSA9PiB7XG4gICAgICAgIGFzc2VydC5ldmVudHVhbGx5W2Fzc2VydE1ldGhvZE5hbWVdID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICAgICAgICAgIGxldCBjdXN0b21SZWplY3Rpb25IYW5kbGVyO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGFyZ3VtZW50c1thc3NlcnRbYXNzZXJ0TWV0aG9kTmFtZV0ubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBjdXN0b21SZWplY3Rpb25IYW5kbGVyID0gcmVhc29uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNoYWkuQXNzZXJ0aW9uRXJyb3IoYCR7bWVzc2FnZX1cXG5cXG5PcmlnaW5hbCByZWFzb246ICR7dXRpbHMuaW5zcGVjdChyZWFzb24pfWApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJldHVybmVkUHJvbWlzZSA9IHByb21pc2UudGhlbihcbiAgICAgICAgICAgICAgICBmdWxmaWxsbWVudFZhbHVlID0+IGFzc2VydFthc3NlcnRNZXRob2ROYW1lXS5hcHBseShhc3NlcnQsIFtmdWxmaWxsbWVudFZhbHVlXS5jb25jYXQob3RoZXJBcmdzKSksXG4gICAgICAgICAgICAgICAgY3VzdG9tUmVqZWN0aW9uSGFuZGxlclxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcmV0dXJuZWRQcm9taXNlLm5vdGlmeSA9IGRvbmUgPT4ge1xuICAgICAgICAgICAgICAgIGRvTm90aWZ5KHJldHVybmVkUHJvbWlzZSwgZG9uZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuZWRQcm9taXNlO1xuICAgICAgICB9O1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMudHJhbnNmZXJQcm9taXNlbmVzcyA9IChhc3NlcnRpb24sIHByb21pc2UpID0+IHtcbiAgICBhc3NlcnRpb24udGhlbiA9IHByb21pc2UudGhlbi5iaW5kKHByb21pc2UpO1xufTtcblxubW9kdWxlLmV4cG9ydHMudHJhbnNmb3JtQXNzZXJ0ZXJBcmdzID0gdmFsdWVzID0+IHZhbHVlcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chai-as-promised/lib/chai-as-promised.js\n");

/***/ })

};
;