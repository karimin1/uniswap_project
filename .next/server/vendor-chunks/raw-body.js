"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/raw-body";
exports.ids = ["vendor-chunks/raw-body"];
exports.modules = {

/***/ "(ssr)/./node_modules/raw-body/index.js":
/*!****************************************!*\
  !*** ./node_modules/raw-body/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * raw-body\n * Copyright(c) 2013-2014 Jonathan Ong\n * Copyright(c) 2014-2022 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar asyncHooks = tryRequireAsyncHooks()\nvar bytes = __webpack_require__(/*! bytes */ \"(ssr)/./node_modules/bytes/index.js\")\nvar createError = __webpack_require__(/*! http-errors */ \"(ssr)/./node_modules/http-errors/index.js\")\nvar iconv = __webpack_require__(/*! iconv-lite */ \"(ssr)/./node_modules/iconv-lite/lib/index.js\")\nvar unpipe = __webpack_require__(/*! unpipe */ \"(ssr)/./node_modules/unpipe/index.js\")\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = getRawBody\n\n/**\n * Module variables.\n * @private\n */\n\nvar ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /\n\n/**\n * Get the decoder for a given encoding.\n *\n * @param {string} encoding\n * @private\n */\n\nfunction getDecoder (encoding) {\n  if (!encoding) return null\n\n  try {\n    return iconv.getDecoder(encoding)\n  } catch (e) {\n    // error getting decoder\n    if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e\n\n    // the encoding was not found\n    throw createError(415, 'specified encoding unsupported', {\n      encoding: encoding,\n      type: 'encoding.unsupported'\n    })\n  }\n}\n\n/**\n * Get the raw body of a stream (typically HTTP).\n *\n * @param {object} stream\n * @param {object|string|function} [options]\n * @param {function} [callback]\n * @public\n */\n\nfunction getRawBody (stream, options, callback) {\n  var done = callback\n  var opts = options || {}\n\n  // light validation\n  if (stream === undefined) {\n    throw new TypeError('argument stream is required')\n  } else if (typeof stream !== 'object' || stream === null || typeof stream.on !== 'function') {\n    throw new TypeError('argument stream must be a stream')\n  }\n\n  if (options === true || typeof options === 'string') {\n    // short cut for encoding\n    opts = {\n      encoding: options\n    }\n  }\n\n  if (typeof options === 'function') {\n    done = options\n    opts = {}\n  }\n\n  // validate callback is a function, if provided\n  if (done !== undefined && typeof done !== 'function') {\n    throw new TypeError('argument callback must be a function')\n  }\n\n  // require the callback without promises\n  if (!done && !global.Promise) {\n    throw new TypeError('argument callback is required')\n  }\n\n  // get encoding\n  var encoding = opts.encoding !== true\n    ? opts.encoding\n    : 'utf-8'\n\n  // convert the limit to an integer\n  var limit = bytes.parse(opts.limit)\n\n  // convert the expected length to an integer\n  var length = opts.length != null && !isNaN(opts.length)\n    ? parseInt(opts.length, 10)\n    : null\n\n  if (done) {\n    // classic callback style\n    return readStream(stream, encoding, length, limit, wrap(done))\n  }\n\n  return new Promise(function executor (resolve, reject) {\n    readStream(stream, encoding, length, limit, function onRead (err, buf) {\n      if (err) return reject(err)\n      resolve(buf)\n    })\n  })\n}\n\n/**\n * Halt a stream.\n *\n * @param {Object} stream\n * @private\n */\n\nfunction halt (stream) {\n  // unpipe everything from the stream\n  unpipe(stream)\n\n  // pause stream\n  if (typeof stream.pause === 'function') {\n    stream.pause()\n  }\n}\n\n/**\n * Read the data from the stream.\n *\n * @param {object} stream\n * @param {string} encoding\n * @param {number} length\n * @param {number} limit\n * @param {function} callback\n * @public\n */\n\nfunction readStream (stream, encoding, length, limit, callback) {\n  var complete = false\n  var sync = true\n\n  // check the length and limit options.\n  // note: we intentionally leave the stream paused,\n  // so users should handle the stream themselves.\n  if (limit !== null && length !== null && length > limit) {\n    return done(createError(413, 'request entity too large', {\n      expected: length,\n      length: length,\n      limit: limit,\n      type: 'entity.too.large'\n    }))\n  }\n\n  // streams1: assert request encoding is buffer.\n  // streams2+: assert the stream encoding is buffer.\n  //   stream._decoder: streams1\n  //   state.encoding: streams2\n  //   state.decoder: streams2, specifically < 0.10.6\n  var state = stream._readableState\n  if (stream._decoder || (state && (state.encoding || state.decoder))) {\n    // developer error\n    return done(createError(500, 'stream encoding should not be set', {\n      type: 'stream.encoding.set'\n    }))\n  }\n\n  if (typeof stream.readable !== 'undefined' && !stream.readable) {\n    return done(createError(500, 'stream is not readable', {\n      type: 'stream.not.readable'\n    }))\n  }\n\n  var received = 0\n  var decoder\n\n  try {\n    decoder = getDecoder(encoding)\n  } catch (err) {\n    return done(err)\n  }\n\n  var buffer = decoder\n    ? ''\n    : []\n\n  // attach listeners\n  stream.on('aborted', onAborted)\n  stream.on('close', cleanup)\n  stream.on('data', onData)\n  stream.on('end', onEnd)\n  stream.on('error', onEnd)\n\n  // mark sync section complete\n  sync = false\n\n  function done () {\n    var args = new Array(arguments.length)\n\n    // copy arguments\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n\n    // mark complete\n    complete = true\n\n    if (sync) {\n      process.nextTick(invokeCallback)\n    } else {\n      invokeCallback()\n    }\n\n    function invokeCallback () {\n      cleanup()\n\n      if (args[0]) {\n        // halt the stream on error\n        halt(stream)\n      }\n\n      callback.apply(null, args)\n    }\n  }\n\n  function onAborted () {\n    if (complete) return\n\n    done(createError(400, 'request aborted', {\n      code: 'ECONNABORTED',\n      expected: length,\n      length: length,\n      received: received,\n      type: 'request.aborted'\n    }))\n  }\n\n  function onData (chunk) {\n    if (complete) return\n\n    received += chunk.length\n\n    if (limit !== null && received > limit) {\n      done(createError(413, 'request entity too large', {\n        limit: limit,\n        received: received,\n        type: 'entity.too.large'\n      }))\n    } else if (decoder) {\n      buffer += decoder.write(chunk)\n    } else {\n      buffer.push(chunk)\n    }\n  }\n\n  function onEnd (err) {\n    if (complete) return\n    if (err) return done(err)\n\n    if (length !== null && received !== length) {\n      done(createError(400, 'request size did not match content length', {\n        expected: length,\n        length: length,\n        received: received,\n        type: 'request.size.invalid'\n      }))\n    } else {\n      var string = decoder\n        ? buffer + (decoder.end() || '')\n        : Buffer.concat(buffer)\n      done(null, string)\n    }\n  }\n\n  function cleanup () {\n    buffer = null\n\n    stream.removeListener('aborted', onAborted)\n    stream.removeListener('data', onData)\n    stream.removeListener('end', onEnd)\n    stream.removeListener('error', onEnd)\n    stream.removeListener('close', cleanup)\n  }\n}\n\n/**\n * Try to require async_hooks\n * @private\n */\n\nfunction tryRequireAsyncHooks () {\n  try {\n    return __webpack_require__(/*! async_hooks */ \"async_hooks\")\n  } catch (e) {\n    return {}\n  }\n}\n\n/**\n * Wrap function with async resource, if possible.\n * AsyncResource.bind static method backported.\n * @private\n */\n\nfunction wrap (fn) {\n  var res\n\n  // create anonymous resource\n  if (asyncHooks.AsyncResource) {\n    res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn')\n  }\n\n  // incompatible node.js\n  if (!res || !res.runInAsyncScope) {\n    return fn\n  }\n\n  // return bound function\n  return res.runInAsyncScope.bind(res, fn, null)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmF3LWJvZHkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLGtEQUFPO0FBQzNCLGtCQUFrQixtQkFBTyxDQUFDLDhEQUFhO0FBQ3ZDLFlBQVksbUJBQU8sQ0FBQyxnRUFBWTtBQUNoQyxhQUFhLG1CQUFPLENBQUMsb0RBQVE7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsd0JBQXdCO0FBQ25DLFdBQVcsVUFBVTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsZ0NBQWE7QUFDaEMsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9yYXctYm9keS9pbmRleC5qcz9jMzJjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogcmF3LWJvZHlcbiAqIENvcHlyaWdodChjKSAyMDEzLTIwMTQgSm9uYXRoYW4gT25nXG4gKiBDb3B5cmlnaHQoYykgMjAxNC0yMDIyIERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgYXN5bmNIb29rcyA9IHRyeVJlcXVpcmVBc3luY0hvb2tzKClcbnZhciBieXRlcyA9IHJlcXVpcmUoJ2J5dGVzJylcbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJ2h0dHAtZXJyb3JzJylcbnZhciBpY29udiA9IHJlcXVpcmUoJ2ljb252LWxpdGUnKVxudmFyIHVucGlwZSA9IHJlcXVpcmUoJ3VucGlwZScpXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdCb2R5XG5cbi8qKlxuICogTW9kdWxlIHZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIElDT05WX0VOQ09ESU5HX01FU1NBR0VfUkVHRVhQID0gL15FbmNvZGluZyBub3QgcmVjb2duaXplZDogL1xuXG4vKipcbiAqIEdldCB0aGUgZGVjb2RlciBmb3IgYSBnaXZlbiBlbmNvZGluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmdcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZ2V0RGVjb2RlciAoZW5jb2RpbmcpIHtcbiAgaWYgKCFlbmNvZGluZykgcmV0dXJuIG51bGxcblxuICB0cnkge1xuICAgIHJldHVybiBpY29udi5nZXREZWNvZGVyKGVuY29kaW5nKVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gZXJyb3IgZ2V0dGluZyBkZWNvZGVyXG4gICAgaWYgKCFJQ09OVl9FTkNPRElOR19NRVNTQUdFX1JFR0VYUC50ZXN0KGUubWVzc2FnZSkpIHRocm93IGVcblxuICAgIC8vIHRoZSBlbmNvZGluZyB3YXMgbm90IGZvdW5kXG4gICAgdGhyb3cgY3JlYXRlRXJyb3IoNDE1LCAnc3BlY2lmaWVkIGVuY29kaW5nIHVuc3VwcG9ydGVkJywge1xuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgdHlwZTogJ2VuY29kaW5nLnVuc3VwcG9ydGVkJ1xuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJhdyBib2R5IG9mIGEgc3RyZWFtICh0eXBpY2FsbHkgSFRUUCkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHN0cmVhbVxuICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfGZ1bmN0aW9ufSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja11cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBnZXRSYXdCb2R5IChzdHJlYW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBkb25lID0gY2FsbGJhY2tcbiAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9XG5cbiAgLy8gbGlnaHQgdmFsaWRhdGlvblxuICBpZiAoc3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzdHJlYW0gaXMgcmVxdWlyZWQnKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBzdHJlYW0gIT09ICdvYmplY3QnIHx8IHN0cmVhbSA9PT0gbnVsbCB8fCB0eXBlb2Ygc3RyZWFtLm9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc3RyZWFtIG11c3QgYmUgYSBzdHJlYW0nKVxuICB9XG5cbiAgaWYgKG9wdGlvbnMgPT09IHRydWUgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gc2hvcnQgY3V0IGZvciBlbmNvZGluZ1xuICAgIG9wdHMgPSB7XG4gICAgICBlbmNvZGluZzogb3B0aW9uc1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRvbmUgPSBvcHRpb25zXG4gICAgb3B0cyA9IHt9XG4gIH1cblxuICAvLyB2YWxpZGF0ZSBjYWxsYmFjayBpcyBhIGZ1bmN0aW9uLCBpZiBwcm92aWRlZFxuICBpZiAoZG9uZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBkb25lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgfVxuXG4gIC8vIHJlcXVpcmUgdGhlIGNhbGxiYWNrIHdpdGhvdXQgcHJvbWlzZXNcbiAgaWYgKCFkb25lICYmICFnbG9iYWwuUHJvbWlzZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IGNhbGxiYWNrIGlzIHJlcXVpcmVkJylcbiAgfVxuXG4gIC8vIGdldCBlbmNvZGluZ1xuICB2YXIgZW5jb2RpbmcgPSBvcHRzLmVuY29kaW5nICE9PSB0cnVlXG4gICAgPyBvcHRzLmVuY29kaW5nXG4gICAgOiAndXRmLTgnXG5cbiAgLy8gY29udmVydCB0aGUgbGltaXQgdG8gYW4gaW50ZWdlclxuICB2YXIgbGltaXQgPSBieXRlcy5wYXJzZShvcHRzLmxpbWl0KVxuXG4gIC8vIGNvbnZlcnQgdGhlIGV4cGVjdGVkIGxlbmd0aCB0byBhbiBpbnRlZ2VyXG4gIHZhciBsZW5ndGggPSBvcHRzLmxlbmd0aCAhPSBudWxsICYmICFpc05hTihvcHRzLmxlbmd0aClcbiAgICA/IHBhcnNlSW50KG9wdHMubGVuZ3RoLCAxMClcbiAgICA6IG51bGxcblxuICBpZiAoZG9uZSkge1xuICAgIC8vIGNsYXNzaWMgY2FsbGJhY2sgc3R5bGVcbiAgICByZXR1cm4gcmVhZFN0cmVhbShzdHJlYW0sIGVuY29kaW5nLCBsZW5ndGgsIGxpbWl0LCB3cmFwKGRvbmUpKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGV4ZWN1dG9yIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWFkU3RyZWFtKHN0cmVhbSwgZW5jb2RpbmcsIGxlbmd0aCwgbGltaXQsIGZ1bmN0aW9uIG9uUmVhZCAoZXJyLCBidWYpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgcmVzb2x2ZShidWYpXG4gICAgfSlcbiAgfSlcbn1cblxuLyoqXG4gKiBIYWx0IGEgc3RyZWFtLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW1cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaGFsdCAoc3RyZWFtKSB7XG4gIC8vIHVucGlwZSBldmVyeXRoaW5nIGZyb20gdGhlIHN0cmVhbVxuICB1bnBpcGUoc3RyZWFtKVxuXG4gIC8vIHBhdXNlIHN0cmVhbVxuICBpZiAodHlwZW9mIHN0cmVhbS5wYXVzZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHN0cmVhbS5wYXVzZSgpXG4gIH1cbn1cblxuLyoqXG4gKiBSZWFkIHRoZSBkYXRhIGZyb20gdGhlIHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gc3RyZWFtXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiByZWFkU3RyZWFtIChzdHJlYW0sIGVuY29kaW5nLCBsZW5ndGgsIGxpbWl0LCBjYWxsYmFjaykge1xuICB2YXIgY29tcGxldGUgPSBmYWxzZVxuICB2YXIgc3luYyA9IHRydWVcblxuICAvLyBjaGVjayB0aGUgbGVuZ3RoIGFuZCBsaW1pdCBvcHRpb25zLlxuICAvLyBub3RlOiB3ZSBpbnRlbnRpb25hbGx5IGxlYXZlIHRoZSBzdHJlYW0gcGF1c2VkLFxuICAvLyBzbyB1c2VycyBzaG91bGQgaGFuZGxlIHRoZSBzdHJlYW0gdGhlbXNlbHZlcy5cbiAgaWYgKGxpbWl0ICE9PSBudWxsICYmIGxlbmd0aCAhPT0gbnVsbCAmJiBsZW5ndGggPiBsaW1pdCkge1xuICAgIHJldHVybiBkb25lKGNyZWF0ZUVycm9yKDQxMywgJ3JlcXVlc3QgZW50aXR5IHRvbyBsYXJnZScsIHtcbiAgICAgIGV4cGVjdGVkOiBsZW5ndGgsXG4gICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgIGxpbWl0OiBsaW1pdCxcbiAgICAgIHR5cGU6ICdlbnRpdHkudG9vLmxhcmdlJ1xuICAgIH0pKVxuICB9XG5cbiAgLy8gc3RyZWFtczE6IGFzc2VydCByZXF1ZXN0IGVuY29kaW5nIGlzIGJ1ZmZlci5cbiAgLy8gc3RyZWFtczIrOiBhc3NlcnQgdGhlIHN0cmVhbSBlbmNvZGluZyBpcyBidWZmZXIuXG4gIC8vICAgc3RyZWFtLl9kZWNvZGVyOiBzdHJlYW1zMVxuICAvLyAgIHN0YXRlLmVuY29kaW5nOiBzdHJlYW1zMlxuICAvLyAgIHN0YXRlLmRlY29kZXI6IHN0cmVhbXMyLCBzcGVjaWZpY2FsbHkgPCAwLjEwLjZcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGlmIChzdHJlYW0uX2RlY29kZXIgfHwgKHN0YXRlICYmIChzdGF0ZS5lbmNvZGluZyB8fCBzdGF0ZS5kZWNvZGVyKSkpIHtcbiAgICAvLyBkZXZlbG9wZXIgZXJyb3JcbiAgICByZXR1cm4gZG9uZShjcmVhdGVFcnJvcig1MDAsICdzdHJlYW0gZW5jb2Rpbmcgc2hvdWxkIG5vdCBiZSBzZXQnLCB7XG4gICAgICB0eXBlOiAnc3RyZWFtLmVuY29kaW5nLnNldCdcbiAgICB9KSlcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc3RyZWFtLnJlYWRhYmxlICE9PSAndW5kZWZpbmVkJyAmJiAhc3RyZWFtLnJlYWRhYmxlKSB7XG4gICAgcmV0dXJuIGRvbmUoY3JlYXRlRXJyb3IoNTAwLCAnc3RyZWFtIGlzIG5vdCByZWFkYWJsZScsIHtcbiAgICAgIHR5cGU6ICdzdHJlYW0ubm90LnJlYWRhYmxlJ1xuICAgIH0pKVxuICB9XG5cbiAgdmFyIHJlY2VpdmVkID0gMFxuICB2YXIgZGVjb2RlclxuXG4gIHRyeSB7XG4gICAgZGVjb2RlciA9IGdldERlY29kZXIoZW5jb2RpbmcpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBkb25lKGVycilcbiAgfVxuXG4gIHZhciBidWZmZXIgPSBkZWNvZGVyXG4gICAgPyAnJ1xuICAgIDogW11cblxuICAvLyBhdHRhY2ggbGlzdGVuZXJzXG4gIHN0cmVhbS5vbignYWJvcnRlZCcsIG9uQWJvcnRlZClcbiAgc3RyZWFtLm9uKCdjbG9zZScsIGNsZWFudXApXG4gIHN0cmVhbS5vbignZGF0YScsIG9uRGF0YSlcbiAgc3RyZWFtLm9uKCdlbmQnLCBvbkVuZClcbiAgc3RyZWFtLm9uKCdlcnJvcicsIG9uRW5kKVxuXG4gIC8vIG1hcmsgc3luYyBzZWN0aW9uIGNvbXBsZXRlXG4gIHN5bmMgPSBmYWxzZVxuXG4gIGZ1bmN0aW9uIGRvbmUgKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG5cbiAgICAvLyBjb3B5IGFyZ3VtZW50c1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgIH1cblxuICAgIC8vIG1hcmsgY29tcGxldGVcbiAgICBjb21wbGV0ZSA9IHRydWVcblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGludm9rZUNhbGxiYWNrKVxuICAgIH0gZWxzZSB7XG4gICAgICBpbnZva2VDYWxsYmFjaygpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2sgKCkge1xuICAgICAgY2xlYW51cCgpXG5cbiAgICAgIGlmIChhcmdzWzBdKSB7XG4gICAgICAgIC8vIGhhbHQgdGhlIHN0cmVhbSBvbiBlcnJvclxuICAgICAgICBoYWx0KHN0cmVhbSlcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJncylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkFib3J0ZWQgKCkge1xuICAgIGlmIChjb21wbGV0ZSkgcmV0dXJuXG5cbiAgICBkb25lKGNyZWF0ZUVycm9yKDQwMCwgJ3JlcXVlc3QgYWJvcnRlZCcsIHtcbiAgICAgIGNvZGU6ICdFQ09OTkFCT1JURUQnLFxuICAgICAgZXhwZWN0ZWQ6IGxlbmd0aCxcbiAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgcmVjZWl2ZWQ6IHJlY2VpdmVkLFxuICAgICAgdHlwZTogJ3JlcXVlc3QuYWJvcnRlZCdcbiAgICB9KSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRGF0YSAoY2h1bmspIHtcbiAgICBpZiAoY29tcGxldGUpIHJldHVyblxuXG4gICAgcmVjZWl2ZWQgKz0gY2h1bmsubGVuZ3RoXG5cbiAgICBpZiAobGltaXQgIT09IG51bGwgJiYgcmVjZWl2ZWQgPiBsaW1pdCkge1xuICAgICAgZG9uZShjcmVhdGVFcnJvcig0MTMsICdyZXF1ZXN0IGVudGl0eSB0b28gbGFyZ2UnLCB7XG4gICAgICAgIGxpbWl0OiBsaW1pdCxcbiAgICAgICAgcmVjZWl2ZWQ6IHJlY2VpdmVkLFxuICAgICAgICB0eXBlOiAnZW50aXR5LnRvby5sYXJnZSdcbiAgICAgIH0pKVxuICAgIH0gZWxzZSBpZiAoZGVjb2Rlcikge1xuICAgICAgYnVmZmVyICs9IGRlY29kZXIud3JpdGUoY2h1bmspXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlci5wdXNoKGNodW5rKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRW5kIChlcnIpIHtcbiAgICBpZiAoY29tcGxldGUpIHJldHVyblxuICAgIGlmIChlcnIpIHJldHVybiBkb25lKGVycilcblxuICAgIGlmIChsZW5ndGggIT09IG51bGwgJiYgcmVjZWl2ZWQgIT09IGxlbmd0aCkge1xuICAgICAgZG9uZShjcmVhdGVFcnJvcig0MDAsICdyZXF1ZXN0IHNpemUgZGlkIG5vdCBtYXRjaCBjb250ZW50IGxlbmd0aCcsIHtcbiAgICAgICAgZXhwZWN0ZWQ6IGxlbmd0aCxcbiAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgIHJlY2VpdmVkOiByZWNlaXZlZCxcbiAgICAgICAgdHlwZTogJ3JlcXVlc3Quc2l6ZS5pbnZhbGlkJ1xuICAgICAgfSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdHJpbmcgPSBkZWNvZGVyXG4gICAgICAgID8gYnVmZmVyICsgKGRlY29kZXIuZW5kKCkgfHwgJycpXG4gICAgICAgIDogQnVmZmVyLmNvbmNhdChidWZmZXIpXG4gICAgICBkb25lKG51bGwsIHN0cmluZylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwICgpIHtcbiAgICBidWZmZXIgPSBudWxsXG5cbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0ZWQnLCBvbkFib3J0ZWQpXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25EYXRhKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25FbmQpXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRW5kKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKVxuICB9XG59XG5cbi8qKlxuICogVHJ5IHRvIHJlcXVpcmUgYXN5bmNfaG9va3NcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gdHJ5UmVxdWlyZUFzeW5jSG9va3MgKCkge1xuICB0cnkge1xuICAgIHJldHVybiByZXF1aXJlKCdhc3luY19ob29rcycpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4ge31cbiAgfVxufVxuXG4vKipcbiAqIFdyYXAgZnVuY3Rpb24gd2l0aCBhc3luYyByZXNvdXJjZSwgaWYgcG9zc2libGUuXG4gKiBBc3luY1Jlc291cmNlLmJpbmQgc3RhdGljIG1ldGhvZCBiYWNrcG9ydGVkLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB3cmFwIChmbikge1xuICB2YXIgcmVzXG5cbiAgLy8gY3JlYXRlIGFub255bW91cyByZXNvdXJjZVxuICBpZiAoYXN5bmNIb29rcy5Bc3luY1Jlc291cmNlKSB7XG4gICAgcmVzID0gbmV3IGFzeW5jSG9va3MuQXN5bmNSZXNvdXJjZShmbi5uYW1lIHx8ICdib3VuZC1hbm9ueW1vdXMtZm4nKVxuICB9XG5cbiAgLy8gaW5jb21wYXRpYmxlIG5vZGUuanNcbiAgaWYgKCFyZXMgfHwgIXJlcy5ydW5JbkFzeW5jU2NvcGUpIHtcbiAgICByZXR1cm4gZm5cbiAgfVxuXG4gIC8vIHJldHVybiBib3VuZCBmdW5jdGlvblxuICByZXR1cm4gcmVzLnJ1bkluQXN5bmNTY29wZS5iaW5kKHJlcywgZm4sIG51bGwpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/raw-body/index.js\n");

/***/ })

};
;