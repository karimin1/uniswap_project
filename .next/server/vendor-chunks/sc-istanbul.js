/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sc-istanbul";
exports.ids = ["vendor-chunks/sc-istanbul"];
exports.modules = {

/***/ "(ssr)/./node_modules/sc-istanbul/index.js":
/*!*******************************************!*\
  !*** ./node_modules/sc-istanbul/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\nCopyright (c) 2012, Yahoo! Inc.  All rights reserved.\nCopyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n*/\n\n/*jslint nomen: true */\nvar path = __webpack_require__(/*! path */ \"path\"),\n    Store = __webpack_require__(/*! ./lib/store */ \"(ssr)/./node_modules/sc-istanbul/lib/store/index.js\"),\n    Report = __webpack_require__(/*! ./lib/report */ \"(ssr)/./node_modules/sc-istanbul/lib/report/index.js\"),\n    meta = __webpack_require__(/*! ./lib/util/meta */ \"(ssr)/./node_modules/sc-istanbul/lib/util/meta.js\");\n\n//register our standard plugins\n__webpack_require__(/*! ./lib/register-plugins */ \"(ssr)/./node_modules/sc-istanbul/lib/register-plugins.js\");\n\n/**\n * the top-level API for `istanbul`. provides access to the key libraries in\n * istanbul so you can write your own tools using `istanbul` as a library.\n *\n * Usage\n * -----\n *\n *      var istanbul = require('istanbul');\n *\n *\n * @class Istanbul\n * @static\n * @module main\n * @main main\n */\n\nmodule.exports = {\n    /**\n     * the Instrumenter class.\n     * @property Instrumenter\n     * @type Instrumenter\n     * @static\n     */\n    Instrumenter: __webpack_require__(/*! ./lib/instrumenter */ \"(ssr)/./node_modules/sc-istanbul/lib/instrumenter.js\"),\n    /**\n     * the Store class.\n     * @property  Store\n     * @type Store\n     * @static\n     */\n    Store: Store,\n    /**\n     * the Collector class\n     * @property  Collector\n     * @type Collector\n     * @static\n     */\n    Collector: __webpack_require__(/*! ./lib/collector */ \"(ssr)/./node_modules/sc-istanbul/lib/collector.js\"),\n    /**\n     * the hook module\n     * @property hook\n     * @type Hook\n     * @static\n     */\n    hook: __webpack_require__(/*! ./lib/hook */ \"(ssr)/./node_modules/sc-istanbul/lib/hook.js\"),\n    /**\n     * the Report class\n     * @property Report\n     * @type Report\n     * @static\n     */\n    Report: Report,\n    /**\n     * the config module\n     * @property config\n     * @type Config\n     * @static\n     */\n    config: __webpack_require__(/*! ./lib/config */ \"(ssr)/./node_modules/sc-istanbul/lib/config.js\"),\n    /**\n     * the Reporter class\n     * @property Reporter\n     * @type Reporter\n     * @static\n     */\n    Reporter: __webpack_require__(/*! ./lib/reporter */ \"(ssr)/./node_modules/sc-istanbul/lib/reporter.js\"),\n    /**\n     * utility for processing coverage objects\n     * @property utils\n     * @type ObjectUtils\n     * @static\n     */\n    utils: __webpack_require__(/*! ./lib/object-utils */ \"(ssr)/./node_modules/sc-istanbul/lib/object-utils.js\"),\n    /**\n     * asynchronously returns a function that can match filesystem paths.\n     * The function returned in the callback may be passed directly as a `matcher`\n     * to the functions in the `hook` module.\n     *\n     * When no options are passed, the match function is one that matches all JS\n     * files under the current working directory except ones under `node_modules`\n     *\n     * Match patterns are `ant`-style patterns processed using the `glob` library.\n     * Examples not provided due to limitations in putting asterisks inside\n     * jsdoc comments. Please refer to tests under `test/other/test-matcher.js`\n     * for examples.\n     *\n     * @method matcherFor\n     * @static\n     * @param {Object} options Optional. Lookup options.\n     * @param {String} [options.root] the root of the filesystem tree under\n     *     which to match files. Defaults to `process.cwd()`\n     * @param {Array} [options.includes] an array of include patterns to match.\n     *     Defaults to all JS files under the root.\n     * @param {Array} [options.excludes] and array of exclude patterns. File paths\n     *     matching these patterns will be excluded by the returned matcher.\n     *     Defaults to files under `node_modules` found anywhere under root.\n     * @param {Function(err, matchFunction)} callback  The callback that is\n     *      called with two arguments. The first is an `Error` object in case\n     *      of errors or a falsy value if there were no errors. The second\n     *      is a function that may be use as a matcher.\n     */\n    matcherFor: (__webpack_require__(/*! ./lib/util/file-matcher */ \"(ssr)/./node_modules/sc-istanbul/lib/util/file-matcher.js\").matcherFor),\n    /**\n     * the version of the library\n     * @property VERSION\n     * @type String\n     * @static\n     */\n    VERSION: meta.VERSION,\n    /**\n     * the abstract Writer class\n     * @property Writer\n     * @type Writer\n     * @static\n     */\n    Writer: (__webpack_require__(/*! ./lib/util/writer */ \"(ssr)/./node_modules/sc-istanbul/lib/util/writer.js\").Writer),\n    /**\n     * the abstract ContentWriter class\n     * @property ContentWriter\n     * @type ContentWriter\n     * @static\n     */\n    ContentWriter: (__webpack_require__(/*! ./lib/util/writer */ \"(ssr)/./node_modules/sc-istanbul/lib/util/writer.js\").ContentWriter),\n    /**\n     * the concrete FileWriter class\n     * @property FileWriter\n     * @type FileWriter\n     * @static\n     */\n    FileWriter: __webpack_require__(/*! ./lib/util/file-writer */ \"(ssr)/./node_modules/sc-istanbul/lib/util/file-writer.js\"),\n    //undocumented\n    _yuiLoadHook: __webpack_require__(/*! ./lib/util/yui-load-hook */ \"(ssr)/./node_modules/sc-istanbul/lib/util/yui-load-hook.js\"),\n    //undocumented\n    TreeSummarizer: __webpack_require__(/*! ./lib/util/tree-summarizer */ \"(ssr)/./node_modules/sc-istanbul/lib/util/tree-summarizer.js\"),\n    //undocumented\n    assetsDir: path.resolve(__dirname, 'lib', 'assets')\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsWUFBWSxtQkFBTyxDQUFDLHdFQUFhO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQywwRUFBYztBQUNuQyxXQUFXLG1CQUFPLENBQUMsMEVBQWlCOztBQUVwQztBQUNBLG1CQUFPLENBQUMsd0ZBQXdCOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxnRkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsMEVBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxnRUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQU8sQ0FBQyxvRUFBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsd0VBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxnRkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSw4QkFBOEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEhBQTZDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0R0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1IQUEwQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyx3RkFBd0I7QUFDaEQ7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyw0RkFBMEI7QUFDcEQ7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxnR0FBNEI7QUFDeEQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9zYy1pc3RhbmJ1bC9pbmRleC5qcz9jN2Y3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTIsIFlhaG9vISBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuKi9cblxuLypqc2xpbnQgbm9tZW46IHRydWUgKi9cbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpLFxuICAgIFN0b3JlID0gcmVxdWlyZSgnLi9saWIvc3RvcmUnKSxcbiAgICBSZXBvcnQgPSByZXF1aXJlKCcuL2xpYi9yZXBvcnQnKSxcbiAgICBtZXRhID0gcmVxdWlyZSgnLi9saWIvdXRpbC9tZXRhJyk7XG5cbi8vcmVnaXN0ZXIgb3VyIHN0YW5kYXJkIHBsdWdpbnNcbnJlcXVpcmUoJy4vbGliL3JlZ2lzdGVyLXBsdWdpbnMnKTtcblxuLyoqXG4gKiB0aGUgdG9wLWxldmVsIEFQSSBmb3IgYGlzdGFuYnVsYC4gcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBrZXkgbGlicmFyaWVzIGluXG4gKiBpc3RhbmJ1bCBzbyB5b3UgY2FuIHdyaXRlIHlvdXIgb3duIHRvb2xzIHVzaW5nIGBpc3RhbmJ1bGAgYXMgYSBsaWJyYXJ5LlxuICpcbiAqIFVzYWdlXG4gKiAtLS0tLVxuICpcbiAqICAgICAgdmFyIGlzdGFuYnVsID0gcmVxdWlyZSgnaXN0YW5idWwnKTtcbiAqXG4gKlxuICogQGNsYXNzIElzdGFuYnVsXG4gKiBAc3RhdGljXG4gKiBAbW9kdWxlIG1haW5cbiAqIEBtYWluIG1haW5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvKipcbiAgICAgKiB0aGUgSW5zdHJ1bWVudGVyIGNsYXNzLlxuICAgICAqIEBwcm9wZXJ0eSBJbnN0cnVtZW50ZXJcbiAgICAgKiBAdHlwZSBJbnN0cnVtZW50ZXJcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgSW5zdHJ1bWVudGVyOiByZXF1aXJlKCcuL2xpYi9pbnN0cnVtZW50ZXInKSxcbiAgICAvKipcbiAgICAgKiB0aGUgU3RvcmUgY2xhc3MuXG4gICAgICogQHByb3BlcnR5ICBTdG9yZVxuICAgICAqIEB0eXBlIFN0b3JlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIFN0b3JlOiBTdG9yZSxcbiAgICAvKipcbiAgICAgKiB0aGUgQ29sbGVjdG9yIGNsYXNzXG4gICAgICogQHByb3BlcnR5ICBDb2xsZWN0b3JcbiAgICAgKiBAdHlwZSBDb2xsZWN0b3JcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgQ29sbGVjdG9yOiByZXF1aXJlKCcuL2xpYi9jb2xsZWN0b3InKSxcbiAgICAvKipcbiAgICAgKiB0aGUgaG9vayBtb2R1bGVcbiAgICAgKiBAcHJvcGVydHkgaG9va1xuICAgICAqIEB0eXBlIEhvb2tcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgaG9vazogcmVxdWlyZSgnLi9saWIvaG9vaycpLFxuICAgIC8qKlxuICAgICAqIHRoZSBSZXBvcnQgY2xhc3NcbiAgICAgKiBAcHJvcGVydHkgUmVwb3J0XG4gICAgICogQHR5cGUgUmVwb3J0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIFJlcG9ydDogUmVwb3J0LFxuICAgIC8qKlxuICAgICAqIHRoZSBjb25maWcgbW9kdWxlXG4gICAgICogQHByb3BlcnR5IGNvbmZpZ1xuICAgICAqIEB0eXBlIENvbmZpZ1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBjb25maWc6IHJlcXVpcmUoJy4vbGliL2NvbmZpZycpLFxuICAgIC8qKlxuICAgICAqIHRoZSBSZXBvcnRlciBjbGFzc1xuICAgICAqIEBwcm9wZXJ0eSBSZXBvcnRlclxuICAgICAqIEB0eXBlIFJlcG9ydGVyXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIFJlcG9ydGVyOiByZXF1aXJlKCcuL2xpYi9yZXBvcnRlcicpLFxuICAgIC8qKlxuICAgICAqIHV0aWxpdHkgZm9yIHByb2Nlc3NpbmcgY292ZXJhZ2Ugb2JqZWN0c1xuICAgICAqIEBwcm9wZXJ0eSB1dGlsc1xuICAgICAqIEB0eXBlIE9iamVjdFV0aWxzXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHV0aWxzOiByZXF1aXJlKCcuL2xpYi9vYmplY3QtdXRpbHMnKSxcbiAgICAvKipcbiAgICAgKiBhc3luY2hyb25vdXNseSByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gbWF0Y2ggZmlsZXN5c3RlbSBwYXRocy5cbiAgICAgKiBUaGUgZnVuY3Rpb24gcmV0dXJuZWQgaW4gdGhlIGNhbGxiYWNrIG1heSBiZSBwYXNzZWQgZGlyZWN0bHkgYXMgYSBgbWF0Y2hlcmBcbiAgICAgKiB0byB0aGUgZnVuY3Rpb25zIGluIHRoZSBgaG9va2AgbW9kdWxlLlxuICAgICAqXG4gICAgICogV2hlbiBubyBvcHRpb25zIGFyZSBwYXNzZWQsIHRoZSBtYXRjaCBmdW5jdGlvbiBpcyBvbmUgdGhhdCBtYXRjaGVzIGFsbCBKU1xuICAgICAqIGZpbGVzIHVuZGVyIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5IGV4Y2VwdCBvbmVzIHVuZGVyIGBub2RlX21vZHVsZXNgXG4gICAgICpcbiAgICAgKiBNYXRjaCBwYXR0ZXJucyBhcmUgYGFudGAtc3R5bGUgcGF0dGVybnMgcHJvY2Vzc2VkIHVzaW5nIHRoZSBgZ2xvYmAgbGlicmFyeS5cbiAgICAgKiBFeGFtcGxlcyBub3QgcHJvdmlkZWQgZHVlIHRvIGxpbWl0YXRpb25zIGluIHB1dHRpbmcgYXN0ZXJpc2tzIGluc2lkZVxuICAgICAqIGpzZG9jIGNvbW1lbnRzLiBQbGVhc2UgcmVmZXIgdG8gdGVzdHMgdW5kZXIgYHRlc3Qvb3RoZXIvdGVzdC1tYXRjaGVyLmpzYFxuICAgICAqIGZvciBleGFtcGxlcy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgbWF0Y2hlckZvclxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25hbC4gTG9va3VwIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnJvb3RdIHRoZSByb290IG9mIHRoZSBmaWxlc3lzdGVtIHRyZWUgdW5kZXJcbiAgICAgKiAgICAgd2hpY2ggdG8gbWF0Y2ggZmlsZXMuIERlZmF1bHRzIHRvIGBwcm9jZXNzLmN3ZCgpYFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmluY2x1ZGVzXSBhbiBhcnJheSBvZiBpbmNsdWRlIHBhdHRlcm5zIHRvIG1hdGNoLlxuICAgICAqICAgICBEZWZhdWx0cyB0byBhbGwgSlMgZmlsZXMgdW5kZXIgdGhlIHJvb3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuZXhjbHVkZXNdIGFuZCBhcnJheSBvZiBleGNsdWRlIHBhdHRlcm5zLiBGaWxlIHBhdGhzXG4gICAgICogICAgIG1hdGNoaW5nIHRoZXNlIHBhdHRlcm5zIHdpbGwgYmUgZXhjbHVkZWQgYnkgdGhlIHJldHVybmVkIG1hdGNoZXIuXG4gICAgICogICAgIERlZmF1bHRzIHRvIGZpbGVzIHVuZGVyIGBub2RlX21vZHVsZXNgIGZvdW5kIGFueXdoZXJlIHVuZGVyIHJvb3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbihlcnIsIG1hdGNoRnVuY3Rpb24pfSBjYWxsYmFjayAgVGhlIGNhbGxiYWNrIHRoYXQgaXNcbiAgICAgKiAgICAgIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHMuIFRoZSBmaXJzdCBpcyBhbiBgRXJyb3JgIG9iamVjdCBpbiBjYXNlXG4gICAgICogICAgICBvZiBlcnJvcnMgb3IgYSBmYWxzeSB2YWx1ZSBpZiB0aGVyZSB3ZXJlIG5vIGVycm9ycy4gVGhlIHNlY29uZFxuICAgICAqICAgICAgaXMgYSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2UgYXMgYSBtYXRjaGVyLlxuICAgICAqL1xuICAgIG1hdGNoZXJGb3I6IHJlcXVpcmUoJy4vbGliL3V0aWwvZmlsZS1tYXRjaGVyJykubWF0Y2hlckZvcixcbiAgICAvKipcbiAgICAgKiB0aGUgdmVyc2lvbiBvZiB0aGUgbGlicmFyeVxuICAgICAqIEBwcm9wZXJ0eSBWRVJTSU9OXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIFZFUlNJT046IG1ldGEuVkVSU0lPTixcbiAgICAvKipcbiAgICAgKiB0aGUgYWJzdHJhY3QgV3JpdGVyIGNsYXNzXG4gICAgICogQHByb3BlcnR5IFdyaXRlclxuICAgICAqIEB0eXBlIFdyaXRlclxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBXcml0ZXI6IHJlcXVpcmUoJy4vbGliL3V0aWwvd3JpdGVyJykuV3JpdGVyLFxuICAgIC8qKlxuICAgICAqIHRoZSBhYnN0cmFjdCBDb250ZW50V3JpdGVyIGNsYXNzXG4gICAgICogQHByb3BlcnR5IENvbnRlbnRXcml0ZXJcbiAgICAgKiBAdHlwZSBDb250ZW50V3JpdGVyXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIENvbnRlbnRXcml0ZXI6IHJlcXVpcmUoJy4vbGliL3V0aWwvd3JpdGVyJykuQ29udGVudFdyaXRlcixcbiAgICAvKipcbiAgICAgKiB0aGUgY29uY3JldGUgRmlsZVdyaXRlciBjbGFzc1xuICAgICAqIEBwcm9wZXJ0eSBGaWxlV3JpdGVyXG4gICAgICogQHR5cGUgRmlsZVdyaXRlclxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBGaWxlV3JpdGVyOiByZXF1aXJlKCcuL2xpYi91dGlsL2ZpbGUtd3JpdGVyJyksXG4gICAgLy91bmRvY3VtZW50ZWRcbiAgICBfeXVpTG9hZEhvb2s6IHJlcXVpcmUoJy4vbGliL3V0aWwveXVpLWxvYWQtaG9vaycpLFxuICAgIC8vdW5kb2N1bWVudGVkXG4gICAgVHJlZVN1bW1hcml6ZXI6IHJlcXVpcmUoJy4vbGliL3V0aWwvdHJlZS1zdW1tYXJpemVyJyksXG4gICAgLy91bmRvY3VtZW50ZWRcbiAgICBhc3NldHNEaXI6IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICdsaWInLCAnYXNzZXRzJylcbn07XG5cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/lib/collector.js":
/*!***************************************************!*\
  !*** ./node_modules/sc-istanbul/lib/collector.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar MemoryStore = __webpack_require__(/*! ./store/memory */ \"(ssr)/./node_modules/sc-istanbul/lib/store/memory.js\"),\n    utils = __webpack_require__(/*! ./object-utils */ \"(ssr)/./node_modules/sc-istanbul/lib/object-utils.js\");\n\n/**\n * a mechanism to merge multiple coverage objects into one. Handles the use case\n * of overlapping coverage information for the same files in multiple coverage\n * objects and does not double-count in this situation. For example, if\n * you pass the same coverage object multiple times, the final merged object will be\n * no different that any of the objects passed in (except for execution counts).\n *\n * The `Collector` is built for scale to handle thousands of coverage objects.\n * By default, all processing is done in memory since the common use-case is of\n * one or a few coverage objects. You can work around memory\n * issues by passing in a `Store` implementation that stores temporary computations\n * on disk (the `tmp` store, for example).\n *\n * The `getFinalCoverage` method returns an object with merged coverage information\n * and is provided as a convenience for implementors working with coverage information\n * that can fit into memory. Reporters, in the interest of generality, should *not* use this method for\n * creating reports.\n *\n * Usage\n * -----\n *\n *      var collector = new require('istanbul').Collector();\n *\n *      files.forEach(function (f) {\n *          //each coverage object can have overlapping information about multiple files\n *          collector.add(JSON.parse(fs.readFileSync(f, 'utf8')));\n *      });\n *\n *      collector.files().forEach(function(file) {\n *          var fileCoverage = collector.fileCoverageFor(file);\n *          console.log('Coverage for ' + file + ' is:' + JSON.stringify(fileCoverage));\n *      });\n *\n *      // convenience method: do not use this when dealing with a large number of files\n *      var finalCoverage = collector.getFinalCoverage();\n *\n * @class Collector\n * @module main\n * @constructor\n * @param {Object} options Optional. Configuration options.\n * @param {Store} options.store - an implementation of `Store` to use for temporary\n *      calculations.\n */\nfunction Collector(options) {\n    options = options || {};\n    this.store = options.store || new MemoryStore();\n}\n\nCollector.prototype = {\n    /**\n     * adds a coverage object to the collector.\n     *\n     * @method add\n     * @param {Object} coverage the coverage object.\n     * @param {String} testName Optional. The name of the test used to produce the object.\n     *      This is currently not used.\n     */\n    add: function (coverage /*, testName */) {\n        var store = this.store;\n        Object.keys(coverage).forEach(function (key) {\n            var fileCoverage = coverage[key];\n            if (store.hasKey(key)) {\n                store.setObject(key, utils.mergeFileCoverage(fileCoverage, store.getObject(key)));\n            } else {\n                store.setObject(key, fileCoverage);\n            }\n        });\n    },\n    /**\n     * returns a list of unique file paths for which coverage information has been added.\n     * @method files\n     * @return {Array} an array of file paths for which coverage information is present.\n     */\n    files: function () {\n        return this.store.keys();\n    },\n    /**\n     * return file coverage information for a single file\n     * @method fileCoverageFor\n     * @param {String} fileName the path for the file for which coverage information is\n     *      required. Must be one of the values returned in the `files()` method.\n     * @return {Object} the coverage information for the specified file.\n     */\n    fileCoverageFor: function (fileName) {\n        var ret = this.store.getObject(fileName);\n        utils.addDerivedInfoForFile(ret);\n        return ret;\n    },\n    /**\n     * returns file coverage information for all files. This has the same format as\n     * any of the objects passed in to the `add` method. The number of keys in this\n     * object will be a superset of all keys found in the objects passed to `add()`\n     * @method getFinalCoverage\n     * @return {Object} the merged coverage information\n     */\n    getFinalCoverage: function () {\n        var ret = {},\n            that = this;\n        this.files().forEach(function (file) {\n            ret[file] = that.fileCoverageFor(file);\n        });\n        return ret;\n    },\n    /**\n     * disposes this collector and reclaims temporary resources used in the\n     * computation. Calls `dispose()` on the underlying store.\n     * @method dispose\n     */\n    dispose: function () {\n        this.store.dispose();\n    }\n};\n\nmodule.exports = Collector;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL2NvbGxlY3Rvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2Isa0JBQWtCLG1CQUFPLENBQUMsNEVBQWdCO0FBQzFDLFlBQVksbUJBQU8sQ0FBQyw0RUFBZ0I7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL3NjLWlzdGFuYnVsL2xpYi9jb2xsZWN0b3IuanM/YzA1MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuIENvcHlyaWdodCAoYykgMjAxMiwgWWFob28hIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBNZW1vcnlTdG9yZSA9IHJlcXVpcmUoJy4vc3RvcmUvbWVtb3J5JyksXG4gICAgdXRpbHMgPSByZXF1aXJlKCcuL29iamVjdC11dGlscycpO1xuXG4vKipcbiAqIGEgbWVjaGFuaXNtIHRvIG1lcmdlIG11bHRpcGxlIGNvdmVyYWdlIG9iamVjdHMgaW50byBvbmUuIEhhbmRsZXMgdGhlIHVzZSBjYXNlXG4gKiBvZiBvdmVybGFwcGluZyBjb3ZlcmFnZSBpbmZvcm1hdGlvbiBmb3IgdGhlIHNhbWUgZmlsZXMgaW4gbXVsdGlwbGUgY292ZXJhZ2VcbiAqIG9iamVjdHMgYW5kIGRvZXMgbm90IGRvdWJsZS1jb3VudCBpbiB0aGlzIHNpdHVhdGlvbi4gRm9yIGV4YW1wbGUsIGlmXG4gKiB5b3UgcGFzcyB0aGUgc2FtZSBjb3ZlcmFnZSBvYmplY3QgbXVsdGlwbGUgdGltZXMsIHRoZSBmaW5hbCBtZXJnZWQgb2JqZWN0IHdpbGwgYmVcbiAqIG5vIGRpZmZlcmVudCB0aGF0IGFueSBvZiB0aGUgb2JqZWN0cyBwYXNzZWQgaW4gKGV4Y2VwdCBmb3IgZXhlY3V0aW9uIGNvdW50cykuXG4gKlxuICogVGhlIGBDb2xsZWN0b3JgIGlzIGJ1aWx0IGZvciBzY2FsZSB0byBoYW5kbGUgdGhvdXNhbmRzIG9mIGNvdmVyYWdlIG9iamVjdHMuXG4gKiBCeSBkZWZhdWx0LCBhbGwgcHJvY2Vzc2luZyBpcyBkb25lIGluIG1lbW9yeSBzaW5jZSB0aGUgY29tbW9uIHVzZS1jYXNlIGlzIG9mXG4gKiBvbmUgb3IgYSBmZXcgY292ZXJhZ2Ugb2JqZWN0cy4gWW91IGNhbiB3b3JrIGFyb3VuZCBtZW1vcnlcbiAqIGlzc3VlcyBieSBwYXNzaW5nIGluIGEgYFN0b3JlYCBpbXBsZW1lbnRhdGlvbiB0aGF0IHN0b3JlcyB0ZW1wb3JhcnkgY29tcHV0YXRpb25zXG4gKiBvbiBkaXNrICh0aGUgYHRtcGAgc3RvcmUsIGZvciBleGFtcGxlKS5cbiAqXG4gKiBUaGUgYGdldEZpbmFsQ292ZXJhZ2VgIG1ldGhvZCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIG1lcmdlZCBjb3ZlcmFnZSBpbmZvcm1hdGlvblxuICogYW5kIGlzIHByb3ZpZGVkIGFzIGEgY29udmVuaWVuY2UgZm9yIGltcGxlbWVudG9ycyB3b3JraW5nIHdpdGggY292ZXJhZ2UgaW5mb3JtYXRpb25cbiAqIHRoYXQgY2FuIGZpdCBpbnRvIG1lbW9yeS4gUmVwb3J0ZXJzLCBpbiB0aGUgaW50ZXJlc3Qgb2YgZ2VuZXJhbGl0eSwgc2hvdWxkICpub3QqIHVzZSB0aGlzIG1ldGhvZCBmb3JcbiAqIGNyZWF0aW5nIHJlcG9ydHMuXG4gKlxuICogVXNhZ2VcbiAqIC0tLS0tXG4gKlxuICogICAgICB2YXIgY29sbGVjdG9yID0gbmV3IHJlcXVpcmUoJ2lzdGFuYnVsJykuQ29sbGVjdG9yKCk7XG4gKlxuICogICAgICBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gKiAgICAgICAgICAvL2VhY2ggY292ZXJhZ2Ugb2JqZWN0IGNhbiBoYXZlIG92ZXJsYXBwaW5nIGluZm9ybWF0aW9uIGFib3V0IG11bHRpcGxlIGZpbGVzXG4gKiAgICAgICAgICBjb2xsZWN0b3IuYWRkKEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKGYsICd1dGY4JykpKTtcbiAqICAgICAgfSk7XG4gKlxuICogICAgICBjb2xsZWN0b3IuZmlsZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUpIHtcbiAqICAgICAgICAgIHZhciBmaWxlQ292ZXJhZ2UgPSBjb2xsZWN0b3IuZmlsZUNvdmVyYWdlRm9yKGZpbGUpO1xuICogICAgICAgICAgY29uc29sZS5sb2coJ0NvdmVyYWdlIGZvciAnICsgZmlsZSArICcgaXM6JyArIEpTT04uc3RyaW5naWZ5KGZpbGVDb3ZlcmFnZSkpO1xuICogICAgICB9KTtcbiAqXG4gKiAgICAgIC8vIGNvbnZlbmllbmNlIG1ldGhvZDogZG8gbm90IHVzZSB0aGlzIHdoZW4gZGVhbGluZyB3aXRoIGEgbGFyZ2UgbnVtYmVyIG9mIGZpbGVzXG4gKiAgICAgIHZhciBmaW5hbENvdmVyYWdlID0gY29sbGVjdG9yLmdldEZpbmFsQ292ZXJhZ2UoKTtcbiAqXG4gKiBAY2xhc3MgQ29sbGVjdG9yXG4gKiBAbW9kdWxlIG1haW5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9uYWwuIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSB7U3RvcmV9IG9wdGlvbnMuc3RvcmUgLSBhbiBpbXBsZW1lbnRhdGlvbiBvZiBgU3RvcmVgIHRvIHVzZSBmb3IgdGVtcG9yYXJ5XG4gKiAgICAgIGNhbGN1bGF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gQ29sbGVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnN0b3JlID0gb3B0aW9ucy5zdG9yZSB8fCBuZXcgTWVtb3J5U3RvcmUoKTtcbn1cblxuQ29sbGVjdG9yLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBhZGRzIGEgY292ZXJhZ2Ugb2JqZWN0IHRvIHRoZSBjb2xsZWN0b3IuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFkZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb3ZlcmFnZSB0aGUgY292ZXJhZ2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXN0TmFtZSBPcHRpb25hbC4gVGhlIG5hbWUgb2YgdGhlIHRlc3QgdXNlZCB0byBwcm9kdWNlIHRoZSBvYmplY3QuXG4gICAgICogICAgICBUaGlzIGlzIGN1cnJlbnRseSBub3QgdXNlZC5cbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uIChjb3ZlcmFnZSAvKiwgdGVzdE5hbWUgKi8pIHtcbiAgICAgICAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICAgICAgT2JqZWN0LmtleXMoY292ZXJhZ2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIGZpbGVDb3ZlcmFnZSA9IGNvdmVyYWdlW2tleV07XG4gICAgICAgICAgICBpZiAoc3RvcmUuaGFzS2V5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXRPYmplY3Qoa2V5LCB1dGlscy5tZXJnZUZpbGVDb3ZlcmFnZShmaWxlQ292ZXJhZ2UsIHN0b3JlLmdldE9iamVjdChrZXkpKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0b3JlLnNldE9iamVjdChrZXksIGZpbGVDb3ZlcmFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogcmV0dXJucyBhIGxpc3Qgb2YgdW5pcXVlIGZpbGUgcGF0aHMgZm9yIHdoaWNoIGNvdmVyYWdlIGluZm9ybWF0aW9uIGhhcyBiZWVuIGFkZGVkLlxuICAgICAqIEBtZXRob2QgZmlsZXNcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2YgZmlsZSBwYXRocyBmb3Igd2hpY2ggY292ZXJhZ2UgaW5mb3JtYXRpb24gaXMgcHJlc2VudC5cbiAgICAgKi9cbiAgICBmaWxlczogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5rZXlzKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZXR1cm4gZmlsZSBjb3ZlcmFnZSBpbmZvcm1hdGlvbiBmb3IgYSBzaW5nbGUgZmlsZVxuICAgICAqIEBtZXRob2QgZmlsZUNvdmVyYWdlRm9yXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVOYW1lIHRoZSBwYXRoIGZvciB0aGUgZmlsZSBmb3Igd2hpY2ggY292ZXJhZ2UgaW5mb3JtYXRpb24gaXNcbiAgICAgKiAgICAgIHJlcXVpcmVkLiBNdXN0IGJlIG9uZSBvZiB0aGUgdmFsdWVzIHJldHVybmVkIGluIHRoZSBgZmlsZXMoKWAgbWV0aG9kLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGNvdmVyYWdlIGluZm9ybWF0aW9uIGZvciB0aGUgc3BlY2lmaWVkIGZpbGUuXG4gICAgICovXG4gICAgZmlsZUNvdmVyYWdlRm9yOiBmdW5jdGlvbiAoZmlsZU5hbWUpIHtcbiAgICAgICAgdmFyIHJldCA9IHRoaXMuc3RvcmUuZ2V0T2JqZWN0KGZpbGVOYW1lKTtcbiAgICAgICAgdXRpbHMuYWRkRGVyaXZlZEluZm9Gb3JGaWxlKHJldCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZXR1cm5zIGZpbGUgY292ZXJhZ2UgaW5mb3JtYXRpb24gZm9yIGFsbCBmaWxlcy4gVGhpcyBoYXMgdGhlIHNhbWUgZm9ybWF0IGFzXG4gICAgICogYW55IG9mIHRoZSBvYmplY3RzIHBhc3NlZCBpbiB0byB0aGUgYGFkZGAgbWV0aG9kLiBUaGUgbnVtYmVyIG9mIGtleXMgaW4gdGhpc1xuICAgICAqIG9iamVjdCB3aWxsIGJlIGEgc3VwZXJzZXQgb2YgYWxsIGtleXMgZm91bmQgaW4gdGhlIG9iamVjdHMgcGFzc2VkIHRvIGBhZGQoKWBcbiAgICAgKiBAbWV0aG9kIGdldEZpbmFsQ292ZXJhZ2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBtZXJnZWQgY292ZXJhZ2UgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBnZXRGaW5hbENvdmVyYWdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXQgPSB7fSxcbiAgICAgICAgICAgIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLmZpbGVzKCkuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgICAgcmV0W2ZpbGVdID0gdGhhdC5maWxlQ292ZXJhZ2VGb3IoZmlsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZGlzcG9zZXMgdGhpcyBjb2xsZWN0b3IgYW5kIHJlY2xhaW1zIHRlbXBvcmFyeSByZXNvdXJjZXMgdXNlZCBpbiB0aGVcbiAgICAgKiBjb21wdXRhdGlvbi4gQ2FsbHMgYGRpc3Bvc2UoKWAgb24gdGhlIHVuZGVybHlpbmcgc3RvcmUuXG4gICAgICogQG1ldGhvZCBkaXNwb3NlXG4gICAgICovXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3Bvc2UoKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxlY3RvcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/lib/collector.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/lib/command/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/sc-istanbul/lib/command/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar Factory = __webpack_require__(/*! ../util/factory */ \"(ssr)/./node_modules/sc-istanbul/lib/util/factory.js\"),\n    factory = new Factory('command', __dirname, true);\n\nfunction Command() {}\n// add register, create, mix, loadAll, getCommandList, resolveCommandName to the Command object\nfactory.bindClassMethods(Command);\n\nCommand.prototype = {\n    toolName: function () {\n        return (__webpack_require__(/*! ../util/meta */ \"(ssr)/./node_modules/sc-istanbul/lib/util/meta.js\").NAME);\n    },\n\n    type: function () {\n        return this.constructor.TYPE;\n    },\n    synopsis: /* istanbul ignore next: base method */ function () {\n        return \"the developer has not written a one-line summary of the \" + this.type() + \" command\";\n    },\n    usage: /* istanbul ignore next: base method */ function () {\n        console.error(\"the developer has not provided a usage for the \" + this.type() + \" command\");\n    },\n    run: /* istanbul ignore next: abstract method */ function (args, callback) {\n        return callback(new Error(\"run: must be overridden for the \" + this.type() + \" command\"));\n    }\n};\n\nmodule.exports = Command;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL2NvbW1hbmQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLDZFQUFpQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsbUdBQTRCO0FBQzNDLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL3NjLWlzdGFuYnVsL2xpYi9jb21tYW5kL2luZGV4LmpzPzRlOGEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiBDb3B5cmlnaHQgKGMpIDIwMTIsIFlhaG9vISBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xuXG52YXIgRmFjdG9yeSA9IHJlcXVpcmUoJy4uL3V0aWwvZmFjdG9yeScpLFxuICAgIGZhY3RvcnkgPSBuZXcgRmFjdG9yeSgnY29tbWFuZCcsIF9fZGlybmFtZSwgdHJ1ZSk7XG5cbmZ1bmN0aW9uIENvbW1hbmQoKSB7fVxuLy8gYWRkIHJlZ2lzdGVyLCBjcmVhdGUsIG1peCwgbG9hZEFsbCwgZ2V0Q29tbWFuZExpc3QsIHJlc29sdmVDb21tYW5kTmFtZSB0byB0aGUgQ29tbWFuZCBvYmplY3RcbmZhY3RvcnkuYmluZENsYXNzTWV0aG9kcyhDb21tYW5kKTtcblxuQ29tbWFuZC5wcm90b3R5cGUgPSB7XG4gICAgdG9vbE5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoJy4uL3V0aWwvbWV0YScpLk5BTUU7XG4gICAgfSxcblxuICAgIHR5cGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuVFlQRTtcbiAgICB9LFxuICAgIHN5bm9wc2lzOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogYmFzZSBtZXRob2QgKi8gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJ0aGUgZGV2ZWxvcGVyIGhhcyBub3Qgd3JpdHRlbiBhIG9uZS1saW5lIHN1bW1hcnkgb2YgdGhlIFwiICsgdGhpcy50eXBlKCkgKyBcIiBjb21tYW5kXCI7XG4gICAgfSxcbiAgICB1c2FnZTogLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGJhc2UgbWV0aG9kICovIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcInRoZSBkZXZlbG9wZXIgaGFzIG5vdCBwcm92aWRlZCBhIHVzYWdlIGZvciB0aGUgXCIgKyB0aGlzLnR5cGUoKSArIFwiIGNvbW1hbmRcIik7XG4gICAgfSxcbiAgICBydW46IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBhYnN0cmFjdCBtZXRob2QgKi8gZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoXCJydW46IG11c3QgYmUgb3ZlcnJpZGRlbiBmb3IgdGhlIFwiICsgdGhpcy50eXBlKCkgKyBcIiBjb21tYW5kXCIpKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbW1hbmQ7XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/lib/command/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/lib/config.js":
/*!************************************************!*\
  !*** ./node_modules/sc-istanbul/lib/config.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n Copyright (c) 2013, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar path = __webpack_require__(/*! path */ \"path\"),\n    fs = __webpack_require__(/*! fs */ \"fs\"),\n    existsSync = fs.existsSync || path.existsSync,\n    CAMEL_PATTERN = /([a-z])([A-Z])/g,\n    YML_PATTERN = /\\.ya?ml$/,\n    yaml = __webpack_require__(/*! js-yaml */ \"(ssr)/./node_modules/js-yaml/index.js\"),\n    defaults = __webpack_require__(/*! ./report/common/defaults */ \"(ssr)/./node_modules/sc-istanbul/lib/report/common/defaults.js\");\n\nfunction defaultConfig(includeBackCompatAttrs) {\n    var ret = {\n        verbose: false,\n        instrumentation: {\n            root: '.',\n            extensions: ['.js'],\n            'default-excludes': true,\n            excludes: [],\n            'embed-source': false,\n            variable: '__coverage__',\n            compact: true,\n            'preserve-comments': false,\n            'complete-copy': false,\n            'save-baseline': false,\n            'baseline-file': './coverage/coverage-baseline.json',\n            'include-all-sources': false,\n            'include-pid': false,\n            'es-modules': false\n        },\n        reporting: {\n            print: 'summary',\n            reports: [ 'lcov' ],\n            dir: './coverage'\n        },\n        hooks: {\n            'hook-run-in-context': false,\n            'post-require-hook': null,\n            'handle-sigint': false\n        },\n        check: {\n            global: {\n                statements: 0,\n                lines: 0,\n                branches: 0,\n                functions: 0,\n                excludes: [] // Currently list of files (root + path). For future, extend to patterns.\n            },\n            each: {\n                statements: 0,\n                lines: 0,\n                branches: 0,\n                functions: 0,\n                excludes: []\n            }\n        }\n    };\n    ret.reporting.watermarks = defaults.watermarks();\n    ret.reporting['report-config'] = defaults.defaultReportConfig();\n\n    if (includeBackCompatAttrs) {\n        ret.instrumentation['preload-sources'] = false;\n    }\n\n    return ret;\n}\n\nfunction dasherize(word) {\n    return word.replace(CAMEL_PATTERN, function (match, lch, uch) {\n        return lch + '-' + uch.toLowerCase();\n    });\n}\nfunction isScalar(v) {\n    if (v === null) { return true; }\n    return v !== undefined && !Array.isArray(v) && typeof v !== 'object';\n}\n\nfunction isObject(v) {\n    return typeof v === 'object' && v !== null && !Array.isArray(v);\n}\n\nfunction mergeObjects(explicit, template) {\n\n    var ret = {};\n\n    Object.keys(template).forEach(function (k) {\n        var v1 = template[k],\n            v2 = explicit[k];\n\n        if (Array.isArray(v1)) {\n            ret[k] = Array.isArray(v2) && v2.length > 0 ? v2 : v1;\n        } else if (isObject(v1)) {\n            v2 = isObject(v2) ? v2 : {};\n            ret[k] = mergeObjects(v2, v1);\n        } else {\n            ret[k] = isScalar(v2) ? v2 : v1;\n        }\n    });\n    return ret;\n}\n\nfunction mergeDefaults(explicit, implicit) {\n    return mergeObjects(explicit || {}, implicit);\n}\n\nfunction addMethods() {\n    var args = Array.prototype.slice.call(arguments),\n        cons = args.shift();\n\n    args.forEach(function (arg) {\n        var method = arg,\n            property = dasherize(arg);\n        cons.prototype[method] = function () {\n            return this.config[property];\n        };\n    });\n}\n\n/**\n * Object that returns instrumentation options\n * @class InstrumentOptions\n * @module config\n * @constructor\n * @param config the instrumentation part of the config object\n */\nfunction InstrumentOptions(config) {\n    if (config['preload-sources']) {\n        console.error('The preload-sources option is deprecated, please use include-all-sources instead.');\n        config['include-all-sources'] = config['preload-sources'];\n    }\n    this.config = config;\n}\n\n/**\n * returns if default excludes should be turned on. Used by the `cover` command.\n * @method defaultExcludes\n * @return {Boolean} true if default excludes should be turned on\n */\n/**\n * returns if non-JS files should be copied during instrumentation. Used by the\n * `instrument` command.\n * @method completeCopy\n * @return {Boolean} true if non-JS files should be copied\n */\n/**\n * returns if the source should be embedded in the instrumented code. Used by the\n * `instrument` command.\n * @method embedSource\n * @return {Boolean} true if the source should be embedded in the instrumented code\n */\n/**\n * the coverage variable name to use. Used by the `instrument` command.\n * @method variable\n * @return {String} the coverage variable name to use\n */\n/**\n * returns if the output should be compact JS. Used by the `instrument` command.\n * @method compact\n * @return {Boolean} true if the output should be compact\n */\n/**\n * returns if comments should be preserved in the generated JS. Used by the\n * `cover` and `instrument` commands.\n * @method preserveComments\n * @return {Boolean} true if comments should be preserved in the generated JS\n */\n/**\n * returns if a zero-coverage baseline file should be written as part of\n * instrumentation. This allows reporting to display numbers for files that have\n * no tests. Used by the  `instrument` command.\n * @method saveBaseline\n * @return {Boolean} true if a baseline coverage file should be written.\n */\n/**\n * Sets the baseline coverage filename. Used by the  `instrument` command.\n * @method baselineFile\n * @return {String} the name of the baseline coverage file.\n */\n/**\n * returns if comments the JS to instrument contains es6 Module syntax.\n * @method esModules\n * @return {Boolean} true if code contains es6 import/export statements.\n */\n/**\n * returns if the coverage filename should include the PID. Used by the  `instrument` command.\n * @method includePid\n * @return {Boolean} true to include pid in coverage filename.\n */\n\n\naddMethods(InstrumentOptions,\n    'extensions', 'defaultExcludes', 'completeCopy',\n    'embedSource', 'variable', 'compact', 'preserveComments',\n    'saveBaseline', 'baselineFile', 'esModules',\n    'includeAllSources', 'includePid');\n\n/**\n * returns the root directory used by istanbul which is typically the root of the\n * source tree. Used by the `cover` and `report` commands.\n * @method root\n * @return {String} the root directory used by istanbul.\n */\nInstrumentOptions.prototype.root = function () { return path.resolve(this.config.root); };\n/**\n * returns an array of glob patterns that should be excluded for instrumentation.\n * Used by the `instrument` and `cover` commands.\n * @method excludes\n * @return {Array} an array of glob patterns that should be excluded for\n *  instrumentation.\n */\nInstrumentOptions.prototype.excludes = function (excludeTests) {\n    var defs;\n    if (this.defaultExcludes()) {\n        defs = [ '**/node_modules/**' ];\n        if (excludeTests) {\n            defs = defs.concat(['**/test/**', '**/tests/**']);\n        }\n        return defs.concat(this.config.excludes);\n    }\n    return this.config.excludes;\n};\n\n/**\n * Object that returns reporting options\n * @class ReportingOptions\n * @module config\n * @constructor\n * @param config the reporting part of the config object\n */\nfunction ReportingOptions(config) {\n    this.config = config;\n}\n\n/**\n * returns the kind of information to be printed on the console. May be one\n * of `summary`, `detail`, `both` or `none`. Used by the\n * `cover` command.\n * @method print\n * @return {String} the kind of information to print to the console at the end\n * of the `cover` command execution.\n */\n/**\n * returns a list of reports that should be generated at the end of a run. Used\n * by the `cover` and `report` commands.\n * @method reports\n * @return {Array} an array of reports that should be produced\n */\n/**\n * returns the directory under which reports should be generated. Used by the\n * `cover` and `report` commands.\n *\n * @method dir\n * @return {String} the directory under which reports should be generated.\n */\n/**\n * returns an object that has keys that are report format names and values that are objects\n * containing detailed configuration for each format. Running `istanbul help config`\n * will give you all the keys per report format that can be overridden.\n * Used by the `cover` and `report` commands.\n * @method reportConfig\n * @return {Object} detailed report configuration per report format.\n */\naddMethods(ReportingOptions, 'print', 'reports', 'dir', 'reportConfig');\n\nfunction isInvalidMark(v, key) {\n    var prefix = 'Watermark for [' + key + '] :';\n\n    if (v.length !== 2) {\n        return prefix + 'must be an array of length 2';\n    }\n    v[0] = Number(v[0]);\n    v[1] = Number(v[1]);\n\n    if (isNaN(v[0]) || isNaN(v[1])) {\n        return prefix + 'must have valid numbers';\n    }\n    if (v[0] < 0 || v[1] < 0) {\n        return prefix + 'must be positive numbers';\n    }\n    if (v[1] > 100) {\n        return prefix + 'cannot exceed 100';\n    }\n    if (v[1] <= v[0]) {\n        return prefix + 'low must be less than high';\n    }\n    return null;\n}\n\n/**\n * returns the low and high watermarks to be used to designate whether coverage\n * is `low`, `medium` or `high`. Statements, functions, branches and lines can\n * have independent watermarks. These are respected by all reports\n * that color for low, medium and high coverage. See the default configuration for exact syntax\n * using `istanbul help config`. Used by the `cover` and `report` commands.\n *\n * @method watermarks\n * @return {Object} an object containing low and high watermarks for statements,\n *  branches, functions and lines.\n */\nReportingOptions.prototype.watermarks = function () {\n    var v = this.config.watermarks,\n        defs = defaults.watermarks(),\n        ret = {};\n\n    Object.keys(defs).forEach(function (k) {\n        var mark = v[k], //it will already be a non-zero length array because of the way the merge works\n            message = isInvalidMark(mark, k);\n        if (message) {\n            console.error(message);\n            ret[k] = defs[k];\n        } else {\n            ret[k] = mark;\n        }\n    });\n    return ret;\n};\n\n/**\n * Object that returns hook options. Note that istanbul does not provide an\n * option to hook `require`. This is always done by the `cover` command.\n * @class HookOptions\n * @module config\n * @constructor\n * @param config the hooks part of the config object\n */\nfunction HookOptions(config) {\n    this.config = config;\n}\n\n/**\n * returns if `vm.runInThisContext` needs to be hooked, in addition to the standard\n * `require` hooks added by istanbul. This should be true for code that uses\n * RequireJS for example. Used by the `cover` command.\n * @method hookRunInContext\n * @return {Boolean} true if `vm.runInThisContext` needs to be hooked for coverage\n */\n/**\n * returns a path to JS file or a dependent module that should be used for\n * post-processing files after they have been required. See the `yui-istanbul` module for\n * an example of a post-require hook. This particular hook modifies the yui loader when\n * that file is required to add istanbul interceptors. Use by the `cover` command\n *\n * @method postRequireHook\n * @return {String} a path to a JS file or the name of a node module that needs\n * to be used as a `require` post-processor\n */\n/**\n * returns if istanbul needs to add a SIGINT (control-c, usually) handler to\n * save coverage information. Useful for getting code coverage out of processes\n * that run forever and need a SIGINT to terminate.\n * @method handleSigint\n * @return {Boolean} true if SIGINT needs to be hooked to write coverage information\n */\n\naddMethods(HookOptions, 'hookRunInContext', 'postRequireHook', 'handleSigint');\n\n/**\n * represents the istanbul configuration and provides sub-objects that can\n * return instrumentation, reporting and hook options respectively.\n * Usage\n * -----\n *\n *      var configObj = require('istanbul').config.loadFile();\n *\n *      console.log(configObj.reporting.reports());\n *\n * @class Configuration\n * @module config\n * @param {Object} obj  the base object to use as the configuration\n * @param {Object} overrides optional - override attributes that are merged into\n *  the base config\n * @constructor\n */\nfunction Configuration(obj, overrides) {\n\n    var config = mergeDefaults(obj, defaultConfig(true));\n    if (isObject(overrides)) {\n        config = mergeDefaults(overrides, config);\n    }\n    if (config.verbose) {\n        console.error('Using configuration');\n        console.error('-------------------');\n        console.error(yaml.safeDump(config, { indent: 4, flowLevel: 3 }));\n        console.error('-------------------\\n');\n    }\n    this.verbose = config.verbose;\n    this.instrumentation = new InstrumentOptions(config.instrumentation);\n    this.reporting = new ReportingOptions(config.reporting);\n    this.hooks = new HookOptions(config.hooks);\n    this.check = config.check; // Pass raw config sub-object.\n}\n\n/**\n * true if verbose logging is required\n * @property verbose\n * @type Boolean\n */\n/**\n * instrumentation options\n * @property instrumentation\n * @type InstrumentOptions\n */\n/**\n * reporting options\n * @property reporting\n * @type ReportingOptions\n */\n/**\n * hook options\n * @property hooks\n * @type HookOptions\n */\n\n\nfunction loadFile(file, overrides) {\n    var defaultConfigFile = path.resolve('.istanbul.yml'),\n        configObject;\n\n    if (file) {\n        if (!existsSync(file)) {\n            throw new Error('Invalid configuration file specified:' + file);\n        }\n    } else {\n        if (existsSync(defaultConfigFile)) {\n            file = defaultConfigFile;\n        }\n    }\n\n    if (file) {\n        if (overrides && overrides.verbose === true) {\n            console.error('Loading config: ' + file);\n        }\n        configObject = file.match(YML_PATTERN) ?\n            yaml.safeLoad(fs.readFileSync(file, 'utf8'), { filename: file }) :\n            __webpack_require__(\"(ssr)/./node_modules/sc-istanbul/lib sync recursive\")(path.resolve(file));\n    }\n\n    return new Configuration(configObject, overrides);\n}\n\nfunction loadObject(obj, overrides) {\n    return new Configuration(obj, overrides);\n}\n\n/**\n * methods to load the configuration object.\n * Usage\n * -----\n *\n *      var config = require('istanbul').config,\n *          configObj = config.loadFile();\n *\n *      console.log(configObj.reporting.reports());\n *\n * @class Config\n * @module main\n * @static\n */\nmodule.exports = {\n    /**\n     * loads the specified configuration file with optional overrides. Throws\n     * when a file is specified and it is not found.\n     * @method loadFile\n     * @static\n     * @param {String} file the file to load. If falsy, the default config file, if present, is loaded.\n     *  If not a default config is used.\n     * @param {Object} overrides - an object with override keys that are merged into the\n     *  config object loaded\n     * @return {Configuration} the config object with overrides applied\n     */\n    loadFile: loadFile,\n    /**\n     * loads the specified configuration object with optional overrides.\n     * @method loadObject\n     * @static\n     * @param {Object} obj the object to use as the base configuration.\n     * @param {Object} overrides - an object with override keys that are merged into the\n     *  config object\n     * @return {Configuration} the config object with overrides applied\n     */\n    loadObject: loadObject,\n    /**\n     * returns the default configuration object. Note that this is a plain object\n     * and not a `Configuration` instance.\n     * @method defaultConfig\n     * @static\n     * @return {Object} an object that represents the default config\n     */\n    defaultConfig: defaultConfig\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL2NvbmZpZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixTQUFTLG1CQUFPLENBQUMsY0FBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsc0RBQVM7QUFDNUIsZUFBZSxtQkFBTyxDQUFDLGdHQUEwQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHlCQUF5QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZ0JBQWdCO0FBQzNFLFlBQVksMkVBQVEsa0JBQWtCLENBQUM7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL2NvbmZpZy5qcz84NmVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gQ29weXJpZ2h0IChjKSAyMDEzLCBZYWhvbyEgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpLFxuICAgIGZzID0gcmVxdWlyZSgnZnMnKSxcbiAgICBleGlzdHNTeW5jID0gZnMuZXhpc3RzU3luYyB8fCBwYXRoLmV4aXN0c1N5bmMsXG4gICAgQ0FNRUxfUEFUVEVSTiA9IC8oW2Etel0pKFtBLVpdKS9nLFxuICAgIFlNTF9QQVRURVJOID0gL1xcLnlhP21sJC8sXG4gICAgeWFtbCA9IHJlcXVpcmUoJ2pzLXlhbWwnKSxcbiAgICBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vcmVwb3J0L2NvbW1vbi9kZWZhdWx0cycpO1xuXG5mdW5jdGlvbiBkZWZhdWx0Q29uZmlnKGluY2x1ZGVCYWNrQ29tcGF0QXR0cnMpIHtcbiAgICB2YXIgcmV0ID0ge1xuICAgICAgICB2ZXJib3NlOiBmYWxzZSxcbiAgICAgICAgaW5zdHJ1bWVudGF0aW9uOiB7XG4gICAgICAgICAgICByb290OiAnLicsXG4gICAgICAgICAgICBleHRlbnNpb25zOiBbJy5qcyddLFxuICAgICAgICAgICAgJ2RlZmF1bHQtZXhjbHVkZXMnOiB0cnVlLFxuICAgICAgICAgICAgZXhjbHVkZXM6IFtdLFxuICAgICAgICAgICAgJ2VtYmVkLXNvdXJjZSc6IGZhbHNlLFxuICAgICAgICAgICAgdmFyaWFibGU6ICdfX2NvdmVyYWdlX18nLFxuICAgICAgICAgICAgY29tcGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICdwcmVzZXJ2ZS1jb21tZW50cyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2NvbXBsZXRlLWNvcHknOiBmYWxzZSxcbiAgICAgICAgICAgICdzYXZlLWJhc2VsaW5lJzogZmFsc2UsXG4gICAgICAgICAgICAnYmFzZWxpbmUtZmlsZSc6ICcuL2NvdmVyYWdlL2NvdmVyYWdlLWJhc2VsaW5lLmpzb24nLFxuICAgICAgICAgICAgJ2luY2x1ZGUtYWxsLXNvdXJjZXMnOiBmYWxzZSxcbiAgICAgICAgICAgICdpbmNsdWRlLXBpZCc6IGZhbHNlLFxuICAgICAgICAgICAgJ2VzLW1vZHVsZXMnOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICByZXBvcnRpbmc6IHtcbiAgICAgICAgICAgIHByaW50OiAnc3VtbWFyeScsXG4gICAgICAgICAgICByZXBvcnRzOiBbICdsY292JyBdLFxuICAgICAgICAgICAgZGlyOiAnLi9jb3ZlcmFnZSdcbiAgICAgICAgfSxcbiAgICAgICAgaG9va3M6IHtcbiAgICAgICAgICAgICdob29rLXJ1bi1pbi1jb250ZXh0JzogZmFsc2UsXG4gICAgICAgICAgICAncG9zdC1yZXF1aXJlLWhvb2snOiBudWxsLFxuICAgICAgICAgICAgJ2hhbmRsZS1zaWdpbnQnOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBjaGVjazoge1xuICAgICAgICAgICAgZ2xvYmFsOiB7XG4gICAgICAgICAgICAgICAgc3RhdGVtZW50czogMCxcbiAgICAgICAgICAgICAgICBsaW5lczogMCxcbiAgICAgICAgICAgICAgICBicmFuY2hlczogMCxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbnM6IDAsXG4gICAgICAgICAgICAgICAgZXhjbHVkZXM6IFtdIC8vIEN1cnJlbnRseSBsaXN0IG9mIGZpbGVzIChyb290ICsgcGF0aCkuIEZvciBmdXR1cmUsIGV4dGVuZCB0byBwYXR0ZXJucy5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlYWNoOiB7XG4gICAgICAgICAgICAgICAgc3RhdGVtZW50czogMCxcbiAgICAgICAgICAgICAgICBsaW5lczogMCxcbiAgICAgICAgICAgICAgICBicmFuY2hlczogMCxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbnM6IDAsXG4gICAgICAgICAgICAgICAgZXhjbHVkZXM6IFtdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldC5yZXBvcnRpbmcud2F0ZXJtYXJrcyA9IGRlZmF1bHRzLndhdGVybWFya3MoKTtcbiAgICByZXQucmVwb3J0aW5nWydyZXBvcnQtY29uZmlnJ10gPSBkZWZhdWx0cy5kZWZhdWx0UmVwb3J0Q29uZmlnKCk7XG5cbiAgICBpZiAoaW5jbHVkZUJhY2tDb21wYXRBdHRycykge1xuICAgICAgICByZXQuaW5zdHJ1bWVudGF0aW9uWydwcmVsb2FkLXNvdXJjZXMnXSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRhc2hlcml6ZSh3b3JkKSB7XG4gICAgcmV0dXJuIHdvcmQucmVwbGFjZShDQU1FTF9QQVRURVJOLCBmdW5jdGlvbiAobWF0Y2gsIGxjaCwgdWNoKSB7XG4gICAgICAgIHJldHVybiBsY2ggKyAnLScgKyB1Y2gudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzU2NhbGFyKHYpIHtcbiAgICBpZiAodiA9PT0gbnVsbCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgIUFycmF5LmlzQXJyYXkodikgJiYgdHlwZW9mIHYgIT09ICdvYmplY3QnO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdCh2KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSAnb2JqZWN0JyAmJiB2ICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHYpO1xufVxuXG5mdW5jdGlvbiBtZXJnZU9iamVjdHMoZXhwbGljaXQsIHRlbXBsYXRlKSB7XG5cbiAgICB2YXIgcmV0ID0ge307XG5cbiAgICBPYmplY3Qua2V5cyh0ZW1wbGF0ZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICB2YXIgdjEgPSB0ZW1wbGF0ZVtrXSxcbiAgICAgICAgICAgIHYyID0gZXhwbGljaXRba107XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodjEpKSB7XG4gICAgICAgICAgICByZXRba10gPSBBcnJheS5pc0FycmF5KHYyKSAmJiB2Mi5sZW5ndGggPiAwID8gdjIgOiB2MTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdCh2MSkpIHtcbiAgICAgICAgICAgIHYyID0gaXNPYmplY3QodjIpID8gdjIgOiB7fTtcbiAgICAgICAgICAgIHJldFtrXSA9IG1lcmdlT2JqZWN0cyh2MiwgdjEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0W2tdID0gaXNTY2FsYXIodjIpID8gdjIgOiB2MTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdHMoZXhwbGljaXQsIGltcGxpY2l0KSB7XG4gICAgcmV0dXJuIG1lcmdlT2JqZWN0cyhleHBsaWNpdCB8fCB7fSwgaW1wbGljaXQpO1xufVxuXG5mdW5jdGlvbiBhZGRNZXRob2RzKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgY29ucyA9IGFyZ3Muc2hpZnQoKTtcblxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBhcmcsXG4gICAgICAgICAgICBwcm9wZXJ0eSA9IGRhc2hlcml6ZShhcmcpO1xuICAgICAgICBjb25zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnW3Byb3BlcnR5XTtcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBPYmplY3QgdGhhdCByZXR1cm5zIGluc3RydW1lbnRhdGlvbiBvcHRpb25zXG4gKiBAY2xhc3MgSW5zdHJ1bWVudE9wdGlvbnNcbiAqIEBtb2R1bGUgY29uZmlnXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSBjb25maWcgdGhlIGluc3RydW1lbnRhdGlvbiBwYXJ0IG9mIHRoZSBjb25maWcgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIEluc3RydW1lbnRPcHRpb25zKGNvbmZpZykge1xuICAgIGlmIChjb25maWdbJ3ByZWxvYWQtc291cmNlcyddKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZSBwcmVsb2FkLXNvdXJjZXMgb3B0aW9uIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgaW5jbHVkZS1hbGwtc291cmNlcyBpbnN0ZWFkLicpO1xuICAgICAgICBjb25maWdbJ2luY2x1ZGUtYWxsLXNvdXJjZXMnXSA9IGNvbmZpZ1sncHJlbG9hZC1zb3VyY2VzJ107XG4gICAgfVxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xufVxuXG4vKipcbiAqIHJldHVybnMgaWYgZGVmYXVsdCBleGNsdWRlcyBzaG91bGQgYmUgdHVybmVkIG9uLiBVc2VkIGJ5IHRoZSBgY292ZXJgIGNvbW1hbmQuXG4gKiBAbWV0aG9kIGRlZmF1bHRFeGNsdWRlc1xuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBkZWZhdWx0IGV4Y2x1ZGVzIHNob3VsZCBiZSB0dXJuZWQgb25cbiAqL1xuLyoqXG4gKiByZXR1cm5zIGlmIG5vbi1KUyBmaWxlcyBzaG91bGQgYmUgY29waWVkIGR1cmluZyBpbnN0cnVtZW50YXRpb24uIFVzZWQgYnkgdGhlXG4gKiBgaW5zdHJ1bWVudGAgY29tbWFuZC5cbiAqIEBtZXRob2QgY29tcGxldGVDb3B5XG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG5vbi1KUyBmaWxlcyBzaG91bGQgYmUgY29waWVkXG4gKi9cbi8qKlxuICogcmV0dXJucyBpZiB0aGUgc291cmNlIHNob3VsZCBiZSBlbWJlZGRlZCBpbiB0aGUgaW5zdHJ1bWVudGVkIGNvZGUuIFVzZWQgYnkgdGhlXG4gKiBgaW5zdHJ1bWVudGAgY29tbWFuZC5cbiAqIEBtZXRob2QgZW1iZWRTb3VyY2VcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNvdXJjZSBzaG91bGQgYmUgZW1iZWRkZWQgaW4gdGhlIGluc3RydW1lbnRlZCBjb2RlXG4gKi9cbi8qKlxuICogdGhlIGNvdmVyYWdlIHZhcmlhYmxlIG5hbWUgdG8gdXNlLiBVc2VkIGJ5IHRoZSBgaW5zdHJ1bWVudGAgY29tbWFuZC5cbiAqIEBtZXRob2QgdmFyaWFibGVcbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGNvdmVyYWdlIHZhcmlhYmxlIG5hbWUgdG8gdXNlXG4gKi9cbi8qKlxuICogcmV0dXJucyBpZiB0aGUgb3V0cHV0IHNob3VsZCBiZSBjb21wYWN0IEpTLiBVc2VkIGJ5IHRoZSBgaW5zdHJ1bWVudGAgY29tbWFuZC5cbiAqIEBtZXRob2QgY29tcGFjdFxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgb3V0cHV0IHNob3VsZCBiZSBjb21wYWN0XG4gKi9cbi8qKlxuICogcmV0dXJucyBpZiBjb21tZW50cyBzaG91bGQgYmUgcHJlc2VydmVkIGluIHRoZSBnZW5lcmF0ZWQgSlMuIFVzZWQgYnkgdGhlXG4gKiBgY292ZXJgIGFuZCBgaW5zdHJ1bWVudGAgY29tbWFuZHMuXG4gKiBAbWV0aG9kIHByZXNlcnZlQ29tbWVudHNcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgY29tbWVudHMgc2hvdWxkIGJlIHByZXNlcnZlZCBpbiB0aGUgZ2VuZXJhdGVkIEpTXG4gKi9cbi8qKlxuICogcmV0dXJucyBpZiBhIHplcm8tY292ZXJhZ2UgYmFzZWxpbmUgZmlsZSBzaG91bGQgYmUgd3JpdHRlbiBhcyBwYXJ0IG9mXG4gKiBpbnN0cnVtZW50YXRpb24uIFRoaXMgYWxsb3dzIHJlcG9ydGluZyB0byBkaXNwbGF5IG51bWJlcnMgZm9yIGZpbGVzIHRoYXQgaGF2ZVxuICogbm8gdGVzdHMuIFVzZWQgYnkgdGhlICBgaW5zdHJ1bWVudGAgY29tbWFuZC5cbiAqIEBtZXRob2Qgc2F2ZUJhc2VsaW5lXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGEgYmFzZWxpbmUgY292ZXJhZ2UgZmlsZSBzaG91bGQgYmUgd3JpdHRlbi5cbiAqL1xuLyoqXG4gKiBTZXRzIHRoZSBiYXNlbGluZSBjb3ZlcmFnZSBmaWxlbmFtZS4gVXNlZCBieSB0aGUgIGBpbnN0cnVtZW50YCBjb21tYW5kLlxuICogQG1ldGhvZCBiYXNlbGluZUZpbGVcbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIG5hbWUgb2YgdGhlIGJhc2VsaW5lIGNvdmVyYWdlIGZpbGUuXG4gKi9cbi8qKlxuICogcmV0dXJucyBpZiBjb21tZW50cyB0aGUgSlMgdG8gaW5zdHJ1bWVudCBjb250YWlucyBlczYgTW9kdWxlIHN5bnRheC5cbiAqIEBtZXRob2QgZXNNb2R1bGVzXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGNvZGUgY29udGFpbnMgZXM2IGltcG9ydC9leHBvcnQgc3RhdGVtZW50cy5cbiAqL1xuLyoqXG4gKiByZXR1cm5zIGlmIHRoZSBjb3ZlcmFnZSBmaWxlbmFtZSBzaG91bGQgaW5jbHVkZSB0aGUgUElELiBVc2VkIGJ5IHRoZSAgYGluc3RydW1lbnRgIGNvbW1hbmQuXG4gKiBAbWV0aG9kIGluY2x1ZGVQaWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgdG8gaW5jbHVkZSBwaWQgaW4gY292ZXJhZ2UgZmlsZW5hbWUuXG4gKi9cblxuXG5hZGRNZXRob2RzKEluc3RydW1lbnRPcHRpb25zLFxuICAgICdleHRlbnNpb25zJywgJ2RlZmF1bHRFeGNsdWRlcycsICdjb21wbGV0ZUNvcHknLFxuICAgICdlbWJlZFNvdXJjZScsICd2YXJpYWJsZScsICdjb21wYWN0JywgJ3ByZXNlcnZlQ29tbWVudHMnLFxuICAgICdzYXZlQmFzZWxpbmUnLCAnYmFzZWxpbmVGaWxlJywgJ2VzTW9kdWxlcycsXG4gICAgJ2luY2x1ZGVBbGxTb3VyY2VzJywgJ2luY2x1ZGVQaWQnKTtcblxuLyoqXG4gKiByZXR1cm5zIHRoZSByb290IGRpcmVjdG9yeSB1c2VkIGJ5IGlzdGFuYnVsIHdoaWNoIGlzIHR5cGljYWxseSB0aGUgcm9vdCBvZiB0aGVcbiAqIHNvdXJjZSB0cmVlLiBVc2VkIGJ5IHRoZSBgY292ZXJgIGFuZCBgcmVwb3J0YCBjb21tYW5kcy5cbiAqIEBtZXRob2Qgcm9vdFxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgcm9vdCBkaXJlY3RvcnkgdXNlZCBieSBpc3RhbmJ1bC5cbiAqL1xuSW5zdHJ1bWVudE9wdGlvbnMucHJvdG90eXBlLnJvb3QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXRoLnJlc29sdmUodGhpcy5jb25maWcucm9vdCk7IH07XG4vKipcbiAqIHJldHVybnMgYW4gYXJyYXkgb2YgZ2xvYiBwYXR0ZXJucyB0aGF0IHNob3VsZCBiZSBleGNsdWRlZCBmb3IgaW5zdHJ1bWVudGF0aW9uLlxuICogVXNlZCBieSB0aGUgYGluc3RydW1lbnRgIGFuZCBgY292ZXJgIGNvbW1hbmRzLlxuICogQG1ldGhvZCBleGNsdWRlc1xuICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIGdsb2IgcGF0dGVybnMgdGhhdCBzaG91bGQgYmUgZXhjbHVkZWQgZm9yXG4gKiAgaW5zdHJ1bWVudGF0aW9uLlxuICovXG5JbnN0cnVtZW50T3B0aW9ucy5wcm90b3R5cGUuZXhjbHVkZXMgPSBmdW5jdGlvbiAoZXhjbHVkZVRlc3RzKSB7XG4gICAgdmFyIGRlZnM7XG4gICAgaWYgKHRoaXMuZGVmYXVsdEV4Y2x1ZGVzKCkpIHtcbiAgICAgICAgZGVmcyA9IFsgJyoqL25vZGVfbW9kdWxlcy8qKicgXTtcbiAgICAgICAgaWYgKGV4Y2x1ZGVUZXN0cykge1xuICAgICAgICAgICAgZGVmcyA9IGRlZnMuY29uY2F0KFsnKiovdGVzdC8qKicsICcqKi90ZXN0cy8qKiddKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmcy5jb25jYXQodGhpcy5jb25maWcuZXhjbHVkZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb25maWcuZXhjbHVkZXM7XG59O1xuXG4vKipcbiAqIE9iamVjdCB0aGF0IHJldHVybnMgcmVwb3J0aW5nIG9wdGlvbnNcbiAqIEBjbGFzcyBSZXBvcnRpbmdPcHRpb25zXG4gKiBAbW9kdWxlIGNvbmZpZ1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gY29uZmlnIHRoZSByZXBvcnRpbmcgcGFydCBvZiB0aGUgY29uZmlnIG9iamVjdFxuICovXG5mdW5jdGlvbiBSZXBvcnRpbmdPcHRpb25zKGNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xufVxuXG4vKipcbiAqIHJldHVybnMgdGhlIGtpbmQgb2YgaW5mb3JtYXRpb24gdG8gYmUgcHJpbnRlZCBvbiB0aGUgY29uc29sZS4gTWF5IGJlIG9uZVxuICogb2YgYHN1bW1hcnlgLCBgZGV0YWlsYCwgYGJvdGhgIG9yIGBub25lYC4gVXNlZCBieSB0aGVcbiAqIGBjb3ZlcmAgY29tbWFuZC5cbiAqIEBtZXRob2QgcHJpbnRcbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGtpbmQgb2YgaW5mb3JtYXRpb24gdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgYXQgdGhlIGVuZFxuICogb2YgdGhlIGBjb3ZlcmAgY29tbWFuZCBleGVjdXRpb24uXG4gKi9cbi8qKlxuICogcmV0dXJucyBhIGxpc3Qgb2YgcmVwb3J0cyB0aGF0IHNob3VsZCBiZSBnZW5lcmF0ZWQgYXQgdGhlIGVuZCBvZiBhIHJ1bi4gVXNlZFxuICogYnkgdGhlIGBjb3ZlcmAgYW5kIGByZXBvcnRgIGNvbW1hbmRzLlxuICogQG1ldGhvZCByZXBvcnRzXG4gKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2YgcmVwb3J0cyB0aGF0IHNob3VsZCBiZSBwcm9kdWNlZFxuICovXG4vKipcbiAqIHJldHVybnMgdGhlIGRpcmVjdG9yeSB1bmRlciB3aGljaCByZXBvcnRzIHNob3VsZCBiZSBnZW5lcmF0ZWQuIFVzZWQgYnkgdGhlXG4gKiBgY292ZXJgIGFuZCBgcmVwb3J0YCBjb21tYW5kcy5cbiAqXG4gKiBAbWV0aG9kIGRpclxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgZGlyZWN0b3J5IHVuZGVyIHdoaWNoIHJlcG9ydHMgc2hvdWxkIGJlIGdlbmVyYXRlZC5cbiAqL1xuLyoqXG4gKiByZXR1cm5zIGFuIG9iamVjdCB0aGF0IGhhcyBrZXlzIHRoYXQgYXJlIHJlcG9ydCBmb3JtYXQgbmFtZXMgYW5kIHZhbHVlcyB0aGF0IGFyZSBvYmplY3RzXG4gKiBjb250YWluaW5nIGRldGFpbGVkIGNvbmZpZ3VyYXRpb24gZm9yIGVhY2ggZm9ybWF0LiBSdW5uaW5nIGBpc3RhbmJ1bCBoZWxwIGNvbmZpZ2BcbiAqIHdpbGwgZ2l2ZSB5b3UgYWxsIHRoZSBrZXlzIHBlciByZXBvcnQgZm9ybWF0IHRoYXQgY2FuIGJlIG92ZXJyaWRkZW4uXG4gKiBVc2VkIGJ5IHRoZSBgY292ZXJgIGFuZCBgcmVwb3J0YCBjb21tYW5kcy5cbiAqIEBtZXRob2QgcmVwb3J0Q29uZmlnXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRldGFpbGVkIHJlcG9ydCBjb25maWd1cmF0aW9uIHBlciByZXBvcnQgZm9ybWF0LlxuICovXG5hZGRNZXRob2RzKFJlcG9ydGluZ09wdGlvbnMsICdwcmludCcsICdyZXBvcnRzJywgJ2RpcicsICdyZXBvcnRDb25maWcnKTtcblxuZnVuY3Rpb24gaXNJbnZhbGlkTWFyayh2LCBrZXkpIHtcbiAgICB2YXIgcHJlZml4ID0gJ1dhdGVybWFyayBmb3IgWycgKyBrZXkgKyAnXSA6JztcblxuICAgIGlmICh2Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgJ211c3QgYmUgYW4gYXJyYXkgb2YgbGVuZ3RoIDInO1xuICAgIH1cbiAgICB2WzBdID0gTnVtYmVyKHZbMF0pO1xuICAgIHZbMV0gPSBOdW1iZXIodlsxXSk7XG5cbiAgICBpZiAoaXNOYU4odlswXSkgfHwgaXNOYU4odlsxXSkpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArICdtdXN0IGhhdmUgdmFsaWQgbnVtYmVycyc7XG4gICAgfVxuICAgIGlmICh2WzBdIDwgMCB8fCB2WzFdIDwgMCkge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgJ211c3QgYmUgcG9zaXRpdmUgbnVtYmVycyc7XG4gICAgfVxuICAgIGlmICh2WzFdID4gMTAwKSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyAnY2Fubm90IGV4Y2VlZCAxMDAnO1xuICAgIH1cbiAgICBpZiAodlsxXSA8PSB2WzBdKSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyAnbG93IG11c3QgYmUgbGVzcyB0aGFuIGhpZ2gnO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiByZXR1cm5zIHRoZSBsb3cgYW5kIGhpZ2ggd2F0ZXJtYXJrcyB0byBiZSB1c2VkIHRvIGRlc2lnbmF0ZSB3aGV0aGVyIGNvdmVyYWdlXG4gKiBpcyBgbG93YCwgYG1lZGl1bWAgb3IgYGhpZ2hgLiBTdGF0ZW1lbnRzLCBmdW5jdGlvbnMsIGJyYW5jaGVzIGFuZCBsaW5lcyBjYW5cbiAqIGhhdmUgaW5kZXBlbmRlbnQgd2F0ZXJtYXJrcy4gVGhlc2UgYXJlIHJlc3BlY3RlZCBieSBhbGwgcmVwb3J0c1xuICogdGhhdCBjb2xvciBmb3IgbG93LCBtZWRpdW0gYW5kIGhpZ2ggY292ZXJhZ2UuIFNlZSB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIGZvciBleGFjdCBzeW50YXhcbiAqIHVzaW5nIGBpc3RhbmJ1bCBoZWxwIGNvbmZpZ2AuIFVzZWQgYnkgdGhlIGBjb3ZlcmAgYW5kIGByZXBvcnRgIGNvbW1hbmRzLlxuICpcbiAqIEBtZXRob2Qgd2F0ZXJtYXJrc1xuICogQHJldHVybiB7T2JqZWN0fSBhbiBvYmplY3QgY29udGFpbmluZyBsb3cgYW5kIGhpZ2ggd2F0ZXJtYXJrcyBmb3Igc3RhdGVtZW50cyxcbiAqICBicmFuY2hlcywgZnVuY3Rpb25zIGFuZCBsaW5lcy5cbiAqL1xuUmVwb3J0aW5nT3B0aW9ucy5wcm90b3R5cGUud2F0ZXJtYXJrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdiA9IHRoaXMuY29uZmlnLndhdGVybWFya3MsXG4gICAgICAgIGRlZnMgPSBkZWZhdWx0cy53YXRlcm1hcmtzKCksXG4gICAgICAgIHJldCA9IHt9O1xuXG4gICAgT2JqZWN0LmtleXMoZGVmcykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICB2YXIgbWFyayA9IHZba10sIC8vaXQgd2lsbCBhbHJlYWR5IGJlIGEgbm9uLXplcm8gbGVuZ3RoIGFycmF5IGJlY2F1c2Ugb2YgdGhlIHdheSB0aGUgbWVyZ2Ugd29ya3NcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBpc0ludmFsaWRNYXJrKG1hcmssIGspO1xuICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIHJldFtrXSA9IGRlZnNba107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXRba10gPSBtYXJrO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogT2JqZWN0IHRoYXQgcmV0dXJucyBob29rIG9wdGlvbnMuIE5vdGUgdGhhdCBpc3RhbmJ1bCBkb2VzIG5vdCBwcm92aWRlIGFuXG4gKiBvcHRpb24gdG8gaG9vayBgcmVxdWlyZWAuIFRoaXMgaXMgYWx3YXlzIGRvbmUgYnkgdGhlIGBjb3ZlcmAgY29tbWFuZC5cbiAqIEBjbGFzcyBIb29rT3B0aW9uc1xuICogQG1vZHVsZSBjb25maWdcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGNvbmZpZyB0aGUgaG9va3MgcGFydCBvZiB0aGUgY29uZmlnIG9iamVjdFxuICovXG5mdW5jdGlvbiBIb29rT3B0aW9ucyhjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbn1cblxuLyoqXG4gKiByZXR1cm5zIGlmIGB2bS5ydW5JblRoaXNDb250ZXh0YCBuZWVkcyB0byBiZSBob29rZWQsIGluIGFkZGl0aW9uIHRvIHRoZSBzdGFuZGFyZFxuICogYHJlcXVpcmVgIGhvb2tzIGFkZGVkIGJ5IGlzdGFuYnVsLiBUaGlzIHNob3VsZCBiZSB0cnVlIGZvciBjb2RlIHRoYXQgdXNlc1xuICogUmVxdWlyZUpTIGZvciBleGFtcGxlLiBVc2VkIGJ5IHRoZSBgY292ZXJgIGNvbW1hbmQuXG4gKiBAbWV0aG9kIGhvb2tSdW5JbkNvbnRleHRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgYHZtLnJ1bkluVGhpc0NvbnRleHRgIG5lZWRzIHRvIGJlIGhvb2tlZCBmb3IgY292ZXJhZ2VcbiAqL1xuLyoqXG4gKiByZXR1cm5zIGEgcGF0aCB0byBKUyBmaWxlIG9yIGEgZGVwZW5kZW50IG1vZHVsZSB0aGF0IHNob3VsZCBiZSB1c2VkIGZvclxuICogcG9zdC1wcm9jZXNzaW5nIGZpbGVzIGFmdGVyIHRoZXkgaGF2ZSBiZWVuIHJlcXVpcmVkLiBTZWUgdGhlIGB5dWktaXN0YW5idWxgIG1vZHVsZSBmb3JcbiAqIGFuIGV4YW1wbGUgb2YgYSBwb3N0LXJlcXVpcmUgaG9vay4gVGhpcyBwYXJ0aWN1bGFyIGhvb2sgbW9kaWZpZXMgdGhlIHl1aSBsb2FkZXIgd2hlblxuICogdGhhdCBmaWxlIGlzIHJlcXVpcmVkIHRvIGFkZCBpc3RhbmJ1bCBpbnRlcmNlcHRvcnMuIFVzZSBieSB0aGUgYGNvdmVyYCBjb21tYW5kXG4gKlxuICogQG1ldGhvZCBwb3N0UmVxdWlyZUhvb2tcbiAqIEByZXR1cm4ge1N0cmluZ30gYSBwYXRoIHRvIGEgSlMgZmlsZSBvciB0aGUgbmFtZSBvZiBhIG5vZGUgbW9kdWxlIHRoYXQgbmVlZHNcbiAqIHRvIGJlIHVzZWQgYXMgYSBgcmVxdWlyZWAgcG9zdC1wcm9jZXNzb3JcbiAqL1xuLyoqXG4gKiByZXR1cm5zIGlmIGlzdGFuYnVsIG5lZWRzIHRvIGFkZCBhIFNJR0lOVCAoY29udHJvbC1jLCB1c3VhbGx5KSBoYW5kbGVyIHRvXG4gKiBzYXZlIGNvdmVyYWdlIGluZm9ybWF0aW9uLiBVc2VmdWwgZm9yIGdldHRpbmcgY29kZSBjb3ZlcmFnZSBvdXQgb2YgcHJvY2Vzc2VzXG4gKiB0aGF0IHJ1biBmb3JldmVyIGFuZCBuZWVkIGEgU0lHSU5UIHRvIHRlcm1pbmF0ZS5cbiAqIEBtZXRob2QgaGFuZGxlU2lnaW50XG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIFNJR0lOVCBuZWVkcyB0byBiZSBob29rZWQgdG8gd3JpdGUgY292ZXJhZ2UgaW5mb3JtYXRpb25cbiAqL1xuXG5hZGRNZXRob2RzKEhvb2tPcHRpb25zLCAnaG9va1J1bkluQ29udGV4dCcsICdwb3N0UmVxdWlyZUhvb2snLCAnaGFuZGxlU2lnaW50Jyk7XG5cbi8qKlxuICogcmVwcmVzZW50cyB0aGUgaXN0YW5idWwgY29uZmlndXJhdGlvbiBhbmQgcHJvdmlkZXMgc3ViLW9iamVjdHMgdGhhdCBjYW5cbiAqIHJldHVybiBpbnN0cnVtZW50YXRpb24sIHJlcG9ydGluZyBhbmQgaG9vayBvcHRpb25zIHJlc3BlY3RpdmVseS5cbiAqIFVzYWdlXG4gKiAtLS0tLVxuICpcbiAqICAgICAgdmFyIGNvbmZpZ09iaiA9IHJlcXVpcmUoJ2lzdGFuYnVsJykuY29uZmlnLmxvYWRGaWxlKCk7XG4gKlxuICogICAgICBjb25zb2xlLmxvZyhjb25maWdPYmoucmVwb3J0aW5nLnJlcG9ydHMoKSk7XG4gKlxuICogQGNsYXNzIENvbmZpZ3VyYXRpb25cbiAqIEBtb2R1bGUgY29uZmlnXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqICB0aGUgYmFzZSBvYmplY3QgdG8gdXNlIGFzIHRoZSBjb25maWd1cmF0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb3ZlcnJpZGVzIG9wdGlvbmFsIC0gb3ZlcnJpZGUgYXR0cmlidXRlcyB0aGF0IGFyZSBtZXJnZWQgaW50b1xuICogIHRoZSBiYXNlIGNvbmZpZ1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENvbmZpZ3VyYXRpb24ob2JqLCBvdmVycmlkZXMpIHtcblxuICAgIHZhciBjb25maWcgPSBtZXJnZURlZmF1bHRzKG9iaiwgZGVmYXVsdENvbmZpZyh0cnVlKSk7XG4gICAgaWYgKGlzT2JqZWN0KG92ZXJyaWRlcykpIHtcbiAgICAgICAgY29uZmlnID0gbWVyZ2VEZWZhdWx0cyhvdmVycmlkZXMsIGNvbmZpZyk7XG4gICAgfVxuICAgIGlmIChjb25maWcudmVyYm9zZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdVc2luZyBjb25maWd1cmF0aW9uJyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJy0tLS0tLS0tLS0tLS0tLS0tLS0nKTtcbiAgICAgICAgY29uc29sZS5lcnJvcih5YW1sLnNhZmVEdW1wKGNvbmZpZywgeyBpbmRlbnQ6IDQsIGZsb3dMZXZlbDogMyB9KSk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJy0tLS0tLS0tLS0tLS0tLS0tLS1cXG4nKTtcbiAgICB9XG4gICAgdGhpcy52ZXJib3NlID0gY29uZmlnLnZlcmJvc2U7XG4gICAgdGhpcy5pbnN0cnVtZW50YXRpb24gPSBuZXcgSW5zdHJ1bWVudE9wdGlvbnMoY29uZmlnLmluc3RydW1lbnRhdGlvbik7XG4gICAgdGhpcy5yZXBvcnRpbmcgPSBuZXcgUmVwb3J0aW5nT3B0aW9ucyhjb25maWcucmVwb3J0aW5nKTtcbiAgICB0aGlzLmhvb2tzID0gbmV3IEhvb2tPcHRpb25zKGNvbmZpZy5ob29rcyk7XG4gICAgdGhpcy5jaGVjayA9IGNvbmZpZy5jaGVjazsgLy8gUGFzcyByYXcgY29uZmlnIHN1Yi1vYmplY3QuXG59XG5cbi8qKlxuICogdHJ1ZSBpZiB2ZXJib3NlIGxvZ2dpbmcgaXMgcmVxdWlyZWRcbiAqIEBwcm9wZXJ0eSB2ZXJib3NlXG4gKiBAdHlwZSBCb29sZWFuXG4gKi9cbi8qKlxuICogaW5zdHJ1bWVudGF0aW9uIG9wdGlvbnNcbiAqIEBwcm9wZXJ0eSBpbnN0cnVtZW50YXRpb25cbiAqIEB0eXBlIEluc3RydW1lbnRPcHRpb25zXG4gKi9cbi8qKlxuICogcmVwb3J0aW5nIG9wdGlvbnNcbiAqIEBwcm9wZXJ0eSByZXBvcnRpbmdcbiAqIEB0eXBlIFJlcG9ydGluZ09wdGlvbnNcbiAqL1xuLyoqXG4gKiBob29rIG9wdGlvbnNcbiAqIEBwcm9wZXJ0eSBob29rc1xuICogQHR5cGUgSG9va09wdGlvbnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWRGaWxlKGZpbGUsIG92ZXJyaWRlcykge1xuICAgIHZhciBkZWZhdWx0Q29uZmlnRmlsZSA9IHBhdGgucmVzb2x2ZSgnLmlzdGFuYnVsLnltbCcpLFxuICAgICAgICBjb25maWdPYmplY3Q7XG5cbiAgICBpZiAoZmlsZSkge1xuICAgICAgICBpZiAoIWV4aXN0c1N5bmMoZmlsZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb25maWd1cmF0aW9uIGZpbGUgc3BlY2lmaWVkOicgKyBmaWxlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChleGlzdHNTeW5jKGRlZmF1bHRDb25maWdGaWxlKSkge1xuICAgICAgICAgICAgZmlsZSA9IGRlZmF1bHRDb25maWdGaWxlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZpbGUpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcyAmJiBvdmVycmlkZXMudmVyYm9zZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignTG9hZGluZyBjb25maWc6ICcgKyBmaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25maWdPYmplY3QgPSBmaWxlLm1hdGNoKFlNTF9QQVRURVJOKSA/XG4gICAgICAgICAgICB5YW1sLnNhZmVMb2FkKGZzLnJlYWRGaWxlU3luYyhmaWxlLCAndXRmOCcpLCB7IGZpbGVuYW1lOiBmaWxlIH0pIDpcbiAgICAgICAgICAgIHJlcXVpcmUocGF0aC5yZXNvbHZlKGZpbGUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbmZpZ3VyYXRpb24oY29uZmlnT2JqZWN0LCBvdmVycmlkZXMpO1xufVxuXG5mdW5jdGlvbiBsb2FkT2JqZWN0KG9iaiwgb3ZlcnJpZGVzKSB7XG4gICAgcmV0dXJuIG5ldyBDb25maWd1cmF0aW9uKG9iaiwgb3ZlcnJpZGVzKTtcbn1cblxuLyoqXG4gKiBtZXRob2RzIHRvIGxvYWQgdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICogVXNhZ2VcbiAqIC0tLS0tXG4gKlxuICogICAgICB2YXIgY29uZmlnID0gcmVxdWlyZSgnaXN0YW5idWwnKS5jb25maWcsXG4gKiAgICAgICAgICBjb25maWdPYmogPSBjb25maWcubG9hZEZpbGUoKTtcbiAqXG4gKiAgICAgIGNvbnNvbGUubG9nKGNvbmZpZ09iai5yZXBvcnRpbmcucmVwb3J0cygpKTtcbiAqXG4gKiBAY2xhc3MgQ29uZmlnXG4gKiBAbW9kdWxlIG1haW5cbiAqIEBzdGF0aWNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLyoqXG4gICAgICogbG9hZHMgdGhlIHNwZWNpZmllZCBjb25maWd1cmF0aW9uIGZpbGUgd2l0aCBvcHRpb25hbCBvdmVycmlkZXMuIFRocm93c1xuICAgICAqIHdoZW4gYSBmaWxlIGlzIHNwZWNpZmllZCBhbmQgaXQgaXMgbm90IGZvdW5kLlxuICAgICAqIEBtZXRob2QgbG9hZEZpbGVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGUgdGhlIGZpbGUgdG8gbG9hZC4gSWYgZmFsc3ksIHRoZSBkZWZhdWx0IGNvbmZpZyBmaWxlLCBpZiBwcmVzZW50LCBpcyBsb2FkZWQuXG4gICAgICogIElmIG5vdCBhIGRlZmF1bHQgY29uZmlnIGlzIHVzZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlcyAtIGFuIG9iamVjdCB3aXRoIG92ZXJyaWRlIGtleXMgdGhhdCBhcmUgbWVyZ2VkIGludG8gdGhlXG4gICAgICogIGNvbmZpZyBvYmplY3QgbG9hZGVkXG4gICAgICogQHJldHVybiB7Q29uZmlndXJhdGlvbn0gdGhlIGNvbmZpZyBvYmplY3Qgd2l0aCBvdmVycmlkZXMgYXBwbGllZFxuICAgICAqL1xuICAgIGxvYWRGaWxlOiBsb2FkRmlsZSxcbiAgICAvKipcbiAgICAgKiBsb2FkcyB0aGUgc3BlY2lmaWVkIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHdpdGggb3B0aW9uYWwgb3ZlcnJpZGVzLlxuICAgICAqIEBtZXRob2QgbG9hZE9iamVjdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBvYmplY3QgdG8gdXNlIGFzIHRoZSBiYXNlIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlcyAtIGFuIG9iamVjdCB3aXRoIG92ZXJyaWRlIGtleXMgdGhhdCBhcmUgbWVyZ2VkIGludG8gdGhlXG4gICAgICogIGNvbmZpZyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtDb25maWd1cmF0aW9ufSB0aGUgY29uZmlnIG9iamVjdCB3aXRoIG92ZXJyaWRlcyBhcHBsaWVkXG4gICAgICovXG4gICAgbG9hZE9iamVjdDogbG9hZE9iamVjdCxcbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gb2JqZWN0LiBOb3RlIHRoYXQgdGhpcyBpcyBhIHBsYWluIG9iamVjdFxuICAgICAqIGFuZCBub3QgYSBgQ29uZmlndXJhdGlvbmAgaW5zdGFuY2UuXG4gICAgICogQG1ldGhvZCBkZWZhdWx0Q29uZmlnXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgZGVmYXVsdCBjb25maWdcbiAgICAgKi9cbiAgICBkZWZhdWx0Q29uZmlnOiBkZWZhdWx0Q29uZmlnXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/lib/config.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/lib/hook.js":
/*!**********************************************!*\
  !*** ./node_modules/sc-istanbul/lib/hook.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n/**\n * provides a mechanism to transform code in the scope of `require` or `vm.createScript`.\n * This mechanism is general and relies on a user-supplied `matcher` function that determines when transformations should be\n * performed and a user-supplied `transformer` function that performs the actual transform.\n * Instrumenting code for coverage is one specific example of useful hooking.\n *\n * Note that both the `matcher` and `transformer` must execute synchronously.\n *\n * For the common case of matching filesystem paths based on inclusion/ exclusion patterns, use the `matcherFor`\n * function in the istanbul API to get a matcher.\n *\n * It is up to the transformer to perform processing with side-effects, such as caching, storing the original\n * source code to disk in case of dynamically generated scripts etc. The `Store` class can help you with this.\n *\n * Usage\n * -----\n *\n *      var hook = require('istanbul').hook,\n *          myMatcher = function (file) { return file.match(/foo/); },\n *          myTransformer = function (code, file) { return 'console.log(\"' + file + '\");' + code; };\n *\n *      hook.hookRequire(myMatcher, myTransformer);\n *\n *      var foo = require('foo'); //will now print foo's module path to console\n *\n * @class Hook\n * @module main\n */\nvar path = __webpack_require__(/*! path */ \"path\"),\n    fs = __webpack_require__(/*! fs */ \"fs\"),\n    Module = __webpack_require__(/*! module */ \"module\"),\n    vm = __webpack_require__(/*! vm */ \"vm\"),\n    originalLoaders = {},\n    originalCreateScript = vm.createScript,\n    originalRunInThisContext = vm.runInThisContext;\n\nfunction transformFn(matcher, transformer, verbose) {\n\n    return function (code, filename) {\n        var shouldHook = typeof filename === 'string' && matcher(path.resolve(filename)),\n            transformed,\n            changed = false;\n\n        if (shouldHook) {\n            if (verbose) {\n                console.error('Module load hook: transform [' + filename + ']');\n            }\n            try {\n                transformed = transformer(code, filename);\n                changed = true;\n            } catch (ex) {\n                console.error('Transformation error; return original code');\n                console.error(ex);\n                transformed = code;\n            }\n        } else {\n            transformed = code;\n        }\n        return { code: transformed, changed: changed };\n    };\n}\n\nfunction unloadRequireCache(matcher) {\n    if (matcher && \"function\" !== 'undefined' && __webpack_require__(\"(ssr)/./node_modules/sc-istanbul/lib sync recursive\") && __webpack_require__.c) {\n        Object.keys(__webpack_require__.c).forEach(function (filename) {\n            if (matcher(filename)) {\n                delete __webpack_require__.c[filename];\n            }\n        });\n    }\n}\n/**\n * hooks `require` to return transformed code to the node module loader.\n * Exceptions in the transform result in the original code being used instead.\n * @method hookRequire\n * @static\n * @param matcher {Function(filePath)} a function that is called with the absolute path to the file being\n *  `require`-d. Should return a truthy value when transformations need to be applied to the code, a falsy value otherwise\n * @param transformer {Function(code, filePath)} a function called with the original code and the associated path of the file\n *  from where the code was loaded. Should return the transformed code.\n * @param options {Object} options Optional.\n * @param {Boolean} [options.verbose] write a line to standard error every time the transformer is called\n * @param {Function} [options.postLoadHook] a function that is called with the name of the file being\n *  required. This is called after the require is processed irrespective of whether it was transformed.\n */\nfunction hookRequire(matcher, transformer, options) {\n    options = options || {};\n    var extensions,\n        fn = transformFn(matcher, transformer, options.verbose),\n        postLoadHook = options.postLoadHook &&\n            typeof options.postLoadHook === 'function' ? options.postLoadHook : null;\n\n    extensions = options.extensions || ['.js'];\n\n    extensions.forEach(function(ext){\n        if (!(ext in originalLoaders)) {\n            originalLoaders[ext] = Module._extensions[ext] || Module._extensions['.js'];\n        }\n        Module._extensions[ext] = function (module, filename) {\n            var ret = fn(fs.readFileSync(filename, 'utf8'), filename);\n            if (ret.changed) {\n                module._compile(ret.code, filename);\n            } else {\n                originalLoaders[ext](module, filename);\n            }\n            if (postLoadHook) {\n                postLoadHook(filename);\n            }\n        };\n    });\n}\n/**\n * unhook `require` to restore it to its original state.\n * @method unhookRequire\n * @static\n */\nfunction unhookRequire() {\n    Object.keys(originalLoaders).forEach(function(ext) {\n        Module._extensions[ext] = originalLoaders[ext];\n    });\n}\n/**\n * hooks `vm.createScript` to return transformed code out of which a `Script` object will be created.\n * Exceptions in the transform result in the original code being used instead.\n * @method hookCreateScript\n * @static\n * @param matcher {Function(filePath)} a function that is called with the filename passed to `vm.createScript`\n *  Should return a truthy value when transformations need to be applied to the code, a falsy value otherwise\n * @param transformer {Function(code, filePath)} a function called with the original code and the filename passed to\n *  `vm.createScript`. Should return the transformed code.\n * @param options {Object} options Optional.\n * @param {Boolean} [options.verbose] write a line to standard error every time the transformer is called\n */\nfunction hookCreateScript(matcher, transformer, opts) {\n    opts = opts || {};\n    var fn = transformFn(matcher, transformer, opts.verbose);\n    vm.createScript = function (code, file) {\n        var ret = fn(code, file);\n        return originalCreateScript(ret.code, file);\n    };\n}\n\n/**\n * unhooks vm.createScript, restoring it to its original state.\n * @method unhookCreateScript\n * @static\n */\nfunction unhookCreateScript() {\n    vm.createScript = originalCreateScript;\n}\n\n\n/**\n * hooks `vm.runInThisContext` to return transformed code.\n * @method hookRunInThisContext\n * @static\n * @param matcher {Function(filePath)} a function that is called with the filename passed to `vm.createScript`\n *  Should return a truthy value when transformations need to be applied to the code, a falsy value otherwise\n * @param transformer {Function(code, filePath)} a function called with the original code and the filename passed to\n *  `vm.createScript`. Should return the transformed code.\n * @param options {Object} options Optional.\n * @param {Boolean} [options.verbose] write a line to standard error every time the transformer is called\n */\nfunction hookRunInThisContext(matcher, transformer, opts) {\n    opts = opts || {};\n    var fn = transformFn(matcher, transformer, opts.verbose);\n    vm.runInThisContext = function (code, file) {\n        var ret = fn(code, file);\n        return originalRunInThisContext(ret.code, file);\n    };\n}\n\n/**\n * unhooks vm.runInThisContext, restoring it to its original state.\n * @method unhookRunInThisContext\n * @static\n */\nfunction unhookRunInThisContext() {\n    vm.runInThisContext = originalRunInThisContext;\n}\n\n\nmodule.exports = {\n    hookRequire: hookRequire,\n    unhookRequire: unhookRequire,\n    hookCreateScript: hookCreateScript,\n    unhookCreateScript: unhookCreateScript,\n    hookRunInThisContext : hookRunInThisContext,\n    unhookRunInThisContext : unhookRunInThisContext,\n    unloadRequireCache: unloadRequireCache\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL2hvb2suanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDJCQUEyQjtBQUNyRSxvREFBb0Qsb0NBQW9DO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixTQUFTLG1CQUFPLENBQUMsY0FBSTtBQUNyQixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsU0FBUyxtQkFBTyxDQUFDLGNBQUk7QUFDckIsd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsVUFBYyxvQkFBb0IsMEVBQU8sSUFBSSxxQkFBYTtBQUM3RSxvQkFBb0IscUJBQWE7QUFDakM7QUFDQSx1QkFBdUIscUJBQWE7QUFDcEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLFdBQVcsU0FBUztBQUNwQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL2hvb2suanM/ZDJhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuIENvcHlyaWdodCAoYykgMjAxMiwgWWFob28hIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG5cbi8qKlxuICogcHJvdmlkZXMgYSBtZWNoYW5pc20gdG8gdHJhbnNmb3JtIGNvZGUgaW4gdGhlIHNjb3BlIG9mIGByZXF1aXJlYCBvciBgdm0uY3JlYXRlU2NyaXB0YC5cbiAqIFRoaXMgbWVjaGFuaXNtIGlzIGdlbmVyYWwgYW5kIHJlbGllcyBvbiBhIHVzZXItc3VwcGxpZWQgYG1hdGNoZXJgIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGVuIHRyYW5zZm9ybWF0aW9ucyBzaG91bGQgYmVcbiAqIHBlcmZvcm1lZCBhbmQgYSB1c2VyLXN1cHBsaWVkIGB0cmFuc2Zvcm1lcmAgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyB0aGUgYWN0dWFsIHRyYW5zZm9ybS5cbiAqIEluc3RydW1lbnRpbmcgY29kZSBmb3IgY292ZXJhZ2UgaXMgb25lIHNwZWNpZmljIGV4YW1wbGUgb2YgdXNlZnVsIGhvb2tpbmcuXG4gKlxuICogTm90ZSB0aGF0IGJvdGggdGhlIGBtYXRjaGVyYCBhbmQgYHRyYW5zZm9ybWVyYCBtdXN0IGV4ZWN1dGUgc3luY2hyb25vdXNseS5cbiAqXG4gKiBGb3IgdGhlIGNvbW1vbiBjYXNlIG9mIG1hdGNoaW5nIGZpbGVzeXN0ZW0gcGF0aHMgYmFzZWQgb24gaW5jbHVzaW9uLyBleGNsdXNpb24gcGF0dGVybnMsIHVzZSB0aGUgYG1hdGNoZXJGb3JgXG4gKiBmdW5jdGlvbiBpbiB0aGUgaXN0YW5idWwgQVBJIHRvIGdldCBhIG1hdGNoZXIuXG4gKlxuICogSXQgaXMgdXAgdG8gdGhlIHRyYW5zZm9ybWVyIHRvIHBlcmZvcm0gcHJvY2Vzc2luZyB3aXRoIHNpZGUtZWZmZWN0cywgc3VjaCBhcyBjYWNoaW5nLCBzdG9yaW5nIHRoZSBvcmlnaW5hbFxuICogc291cmNlIGNvZGUgdG8gZGlzayBpbiBjYXNlIG9mIGR5bmFtaWNhbGx5IGdlbmVyYXRlZCBzY3JpcHRzIGV0Yy4gVGhlIGBTdG9yZWAgY2xhc3MgY2FuIGhlbHAgeW91IHdpdGggdGhpcy5cbiAqXG4gKiBVc2FnZVxuICogLS0tLS1cbiAqXG4gKiAgICAgIHZhciBob29rID0gcmVxdWlyZSgnaXN0YW5idWwnKS5ob29rLFxuICogICAgICAgICAgbXlNYXRjaGVyID0gZnVuY3Rpb24gKGZpbGUpIHsgcmV0dXJuIGZpbGUubWF0Y2goL2Zvby8pOyB9LFxuICogICAgICAgICAgbXlUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uIChjb2RlLCBmaWxlKSB7IHJldHVybiAnY29uc29sZS5sb2coXCInICsgZmlsZSArICdcIik7JyArIGNvZGU7IH07XG4gKlxuICogICAgICBob29rLmhvb2tSZXF1aXJlKG15TWF0Y2hlciwgbXlUcmFuc2Zvcm1lcik7XG4gKlxuICogICAgICB2YXIgZm9vID0gcmVxdWlyZSgnZm9vJyk7IC8vd2lsbCBub3cgcHJpbnQgZm9vJ3MgbW9kdWxlIHBhdGggdG8gY29uc29sZVxuICpcbiAqIEBjbGFzcyBIb29rXG4gKiBAbW9kdWxlIG1haW5cbiAqL1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyksXG4gICAgZnMgPSByZXF1aXJlKCdmcycpLFxuICAgIE1vZHVsZSA9IHJlcXVpcmUoJ21vZHVsZScpLFxuICAgIHZtID0gcmVxdWlyZSgndm0nKSxcbiAgICBvcmlnaW5hbExvYWRlcnMgPSB7fSxcbiAgICBvcmlnaW5hbENyZWF0ZVNjcmlwdCA9IHZtLmNyZWF0ZVNjcmlwdCxcbiAgICBvcmlnaW5hbFJ1bkluVGhpc0NvbnRleHQgPSB2bS5ydW5JblRoaXNDb250ZXh0O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1GbihtYXRjaGVyLCB0cmFuc2Zvcm1lciwgdmVyYm9zZSkge1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb2RlLCBmaWxlbmFtZSkge1xuICAgICAgICB2YXIgc2hvdWxkSG9vayA9IHR5cGVvZiBmaWxlbmFtZSA9PT0gJ3N0cmluZycgJiYgbWF0Y2hlcihwYXRoLnJlc29sdmUoZmlsZW5hbWUpKSxcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkLFxuICAgICAgICAgICAgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChzaG91bGRIb29rKSB7XG4gICAgICAgICAgICBpZiAodmVyYm9zZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ01vZHVsZSBsb2FkIGhvb2s6IHRyYW5zZm9ybSBbJyArIGZpbGVuYW1lICsgJ10nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWQgPSB0cmFuc2Zvcm1lcihjb2RlLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RyYW5zZm9ybWF0aW9uIGVycm9yOyByZXR1cm4gb3JpZ2luYWwgY29kZScpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXgpO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkID0gY29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkID0gY29kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjb2RlOiB0cmFuc2Zvcm1lZCwgY2hhbmdlZDogY2hhbmdlZCB9O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIHVubG9hZFJlcXVpcmVDYWNoZShtYXRjaGVyKSB7XG4gICAgaWYgKG1hdGNoZXIgJiYgdHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnICYmIHJlcXVpcmUgJiYgcmVxdWlyZS5jYWNoZSkge1xuICAgICAgICBPYmplY3Qua2V5cyhyZXF1aXJlLmNhY2hlKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlbmFtZSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoZXIoZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlcXVpcmUuY2FjaGVbZmlsZW5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIGhvb2tzIGByZXF1aXJlYCB0byByZXR1cm4gdHJhbnNmb3JtZWQgY29kZSB0byB0aGUgbm9kZSBtb2R1bGUgbG9hZGVyLlxuICogRXhjZXB0aW9ucyBpbiB0aGUgdHJhbnNmb3JtIHJlc3VsdCBpbiB0aGUgb3JpZ2luYWwgY29kZSBiZWluZyB1c2VkIGluc3RlYWQuXG4gKiBAbWV0aG9kIGhvb2tSZXF1aXJlXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gbWF0Y2hlciB7RnVuY3Rpb24oZmlsZVBhdGgpfSBhIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggdGhlIGFic29sdXRlIHBhdGggdG8gdGhlIGZpbGUgYmVpbmdcbiAqICBgcmVxdWlyZWAtZC4gU2hvdWxkIHJldHVybiBhIHRydXRoeSB2YWx1ZSB3aGVuIHRyYW5zZm9ybWF0aW9ucyBuZWVkIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGNvZGUsIGEgZmFsc3kgdmFsdWUgb3RoZXJ3aXNlXG4gKiBAcGFyYW0gdHJhbnNmb3JtZXIge0Z1bmN0aW9uKGNvZGUsIGZpbGVQYXRoKX0gYSBmdW5jdGlvbiBjYWxsZWQgd2l0aCB0aGUgb3JpZ2luYWwgY29kZSBhbmQgdGhlIGFzc29jaWF0ZWQgcGF0aCBvZiB0aGUgZmlsZVxuICogIGZyb20gd2hlcmUgdGhlIGNvZGUgd2FzIGxvYWRlZC4gU2hvdWxkIHJldHVybiB0aGUgdHJhbnNmb3JtZWQgY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9uYWwuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnZlcmJvc2VdIHdyaXRlIGEgbGluZSB0byBzdGFuZGFyZCBlcnJvciBldmVyeSB0aW1lIHRoZSB0cmFuc2Zvcm1lciBpcyBjYWxsZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnBvc3RMb2FkSG9va10gYSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGJlaW5nXG4gKiAgcmVxdWlyZWQuIFRoaXMgaXMgY2FsbGVkIGFmdGVyIHRoZSByZXF1aXJlIGlzIHByb2Nlc3NlZCBpcnJlc3BlY3RpdmUgb2Ygd2hldGhlciBpdCB3YXMgdHJhbnNmb3JtZWQuXG4gKi9cbmZ1bmN0aW9uIGhvb2tSZXF1aXJlKG1hdGNoZXIsIHRyYW5zZm9ybWVyLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGV4dGVuc2lvbnMsXG4gICAgICAgIGZuID0gdHJhbnNmb3JtRm4obWF0Y2hlciwgdHJhbnNmb3JtZXIsIG9wdGlvbnMudmVyYm9zZSksXG4gICAgICAgIHBvc3RMb2FkSG9vayA9IG9wdGlvbnMucG9zdExvYWRIb29rICYmXG4gICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5wb3N0TG9hZEhvb2sgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnBvc3RMb2FkSG9vayA6IG51bGw7XG5cbiAgICBleHRlbnNpb25zID0gb3B0aW9ucy5leHRlbnNpb25zIHx8IFsnLmpzJ107XG5cbiAgICBleHRlbnNpb25zLmZvckVhY2goZnVuY3Rpb24oZXh0KXtcbiAgICAgICAgaWYgKCEoZXh0IGluIG9yaWdpbmFsTG9hZGVycykpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTG9hZGVyc1tleHRdID0gTW9kdWxlLl9leHRlbnNpb25zW2V4dF0gfHwgTW9kdWxlLl9leHRlbnNpb25zWycuanMnXTtcbiAgICAgICAgfVxuICAgICAgICBNb2R1bGUuX2V4dGVuc2lvbnNbZXh0XSA9IGZ1bmN0aW9uIChtb2R1bGUsIGZpbGVuYW1lKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gZm4oZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lLCAndXRmOCcpLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICBpZiAocmV0LmNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuX2NvbXBpbGUocmV0LmNvZGUsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxMb2FkZXJzW2V4dF0obW9kdWxlLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zdExvYWRIb29rKSB7XG4gICAgICAgICAgICAgICAgcG9zdExvYWRIb29rKGZpbGVuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbi8qKlxuICogdW5ob29rIGByZXF1aXJlYCB0byByZXN0b3JlIGl0IHRvIGl0cyBvcmlnaW5hbCBzdGF0ZS5cbiAqIEBtZXRob2QgdW5ob29rUmVxdWlyZVxuICogQHN0YXRpY1xuICovXG5mdW5jdGlvbiB1bmhvb2tSZXF1aXJlKCkge1xuICAgIE9iamVjdC5rZXlzKG9yaWdpbmFsTG9hZGVycykuZm9yRWFjaChmdW5jdGlvbihleHQpIHtcbiAgICAgICAgTW9kdWxlLl9leHRlbnNpb25zW2V4dF0gPSBvcmlnaW5hbExvYWRlcnNbZXh0XTtcbiAgICB9KTtcbn1cbi8qKlxuICogaG9va3MgYHZtLmNyZWF0ZVNjcmlwdGAgdG8gcmV0dXJuIHRyYW5zZm9ybWVkIGNvZGUgb3V0IG9mIHdoaWNoIGEgYFNjcmlwdGAgb2JqZWN0IHdpbGwgYmUgY3JlYXRlZC5cbiAqIEV4Y2VwdGlvbnMgaW4gdGhlIHRyYW5zZm9ybSByZXN1bHQgaW4gdGhlIG9yaWdpbmFsIGNvZGUgYmVpbmcgdXNlZCBpbnN0ZWFkLlxuICogQG1ldGhvZCBob29rQ3JlYXRlU2NyaXB0XG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gbWF0Y2hlciB7RnVuY3Rpb24oZmlsZVBhdGgpfSBhIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggdGhlIGZpbGVuYW1lIHBhc3NlZCB0byBgdm0uY3JlYXRlU2NyaXB0YFxuICogIFNob3VsZCByZXR1cm4gYSB0cnV0aHkgdmFsdWUgd2hlbiB0cmFuc2Zvcm1hdGlvbnMgbmVlZCB0byBiZSBhcHBsaWVkIHRvIHRoZSBjb2RlLCBhIGZhbHN5IHZhbHVlIG90aGVyd2lzZVxuICogQHBhcmFtIHRyYW5zZm9ybWVyIHtGdW5jdGlvbihjb2RlLCBmaWxlUGF0aCl9IGEgZnVuY3Rpb24gY2FsbGVkIHdpdGggdGhlIG9yaWdpbmFsIGNvZGUgYW5kIHRoZSBmaWxlbmFtZSBwYXNzZWQgdG9cbiAqICBgdm0uY3JlYXRlU2NyaXB0YC4gU2hvdWxkIHJldHVybiB0aGUgdHJhbnNmb3JtZWQgY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9uYWwuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnZlcmJvc2VdIHdyaXRlIGEgbGluZSB0byBzdGFuZGFyZCBlcnJvciBldmVyeSB0aW1lIHRoZSB0cmFuc2Zvcm1lciBpcyBjYWxsZWRcbiAqL1xuZnVuY3Rpb24gaG9va0NyZWF0ZVNjcmlwdChtYXRjaGVyLCB0cmFuc2Zvcm1lciwgb3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBmbiA9IHRyYW5zZm9ybUZuKG1hdGNoZXIsIHRyYW5zZm9ybWVyLCBvcHRzLnZlcmJvc2UpO1xuICAgIHZtLmNyZWF0ZVNjcmlwdCA9IGZ1bmN0aW9uIChjb2RlLCBmaWxlKSB7XG4gICAgICAgIHZhciByZXQgPSBmbihjb2RlLCBmaWxlKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsQ3JlYXRlU2NyaXB0KHJldC5jb2RlLCBmaWxlKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIHVuaG9va3Mgdm0uY3JlYXRlU2NyaXB0LCByZXN0b3JpbmcgaXQgdG8gaXRzIG9yaWdpbmFsIHN0YXRlLlxuICogQG1ldGhvZCB1bmhvb2tDcmVhdGVTY3JpcHRcbiAqIEBzdGF0aWNcbiAqL1xuZnVuY3Rpb24gdW5ob29rQ3JlYXRlU2NyaXB0KCkge1xuICAgIHZtLmNyZWF0ZVNjcmlwdCA9IG9yaWdpbmFsQ3JlYXRlU2NyaXB0O1xufVxuXG5cbi8qKlxuICogaG9va3MgYHZtLnJ1bkluVGhpc0NvbnRleHRgIHRvIHJldHVybiB0cmFuc2Zvcm1lZCBjb2RlLlxuICogQG1ldGhvZCBob29rUnVuSW5UaGlzQ29udGV4dFxuICogQHN0YXRpY1xuICogQHBhcmFtIG1hdGNoZXIge0Z1bmN0aW9uKGZpbGVQYXRoKX0gYSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIHRoZSBmaWxlbmFtZSBwYXNzZWQgdG8gYHZtLmNyZWF0ZVNjcmlwdGBcbiAqICBTaG91bGQgcmV0dXJuIGEgdHJ1dGh5IHZhbHVlIHdoZW4gdHJhbnNmb3JtYXRpb25zIG5lZWQgdG8gYmUgYXBwbGllZCB0byB0aGUgY29kZSwgYSBmYWxzeSB2YWx1ZSBvdGhlcndpc2VcbiAqIEBwYXJhbSB0cmFuc2Zvcm1lciB7RnVuY3Rpb24oY29kZSwgZmlsZVBhdGgpfSBhIGZ1bmN0aW9uIGNhbGxlZCB3aXRoIHRoZSBvcmlnaW5hbCBjb2RlIGFuZCB0aGUgZmlsZW5hbWUgcGFzc2VkIHRvXG4gKiAgYHZtLmNyZWF0ZVNjcmlwdGAuIFNob3VsZCByZXR1cm4gdGhlIHRyYW5zZm9ybWVkIGNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbmFsLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy52ZXJib3NlXSB3cml0ZSBhIGxpbmUgdG8gc3RhbmRhcmQgZXJyb3IgZXZlcnkgdGltZSB0aGUgdHJhbnNmb3JtZXIgaXMgY2FsbGVkXG4gKi9cbmZ1bmN0aW9uIGhvb2tSdW5JblRoaXNDb250ZXh0KG1hdGNoZXIsIHRyYW5zZm9ybWVyLCBvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdmFyIGZuID0gdHJhbnNmb3JtRm4obWF0Y2hlciwgdHJhbnNmb3JtZXIsIG9wdHMudmVyYm9zZSk7XG4gICAgdm0ucnVuSW5UaGlzQ29udGV4dCA9IGZ1bmN0aW9uIChjb2RlLCBmaWxlKSB7XG4gICAgICAgIHZhciByZXQgPSBmbihjb2RlLCBmaWxlKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUnVuSW5UaGlzQ29udGV4dChyZXQuY29kZSwgZmlsZSk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiB1bmhvb2tzIHZtLnJ1bkluVGhpc0NvbnRleHQsIHJlc3RvcmluZyBpdCB0byBpdHMgb3JpZ2luYWwgc3RhdGUuXG4gKiBAbWV0aG9kIHVuaG9va1J1bkluVGhpc0NvbnRleHRcbiAqIEBzdGF0aWNcbiAqL1xuZnVuY3Rpb24gdW5ob29rUnVuSW5UaGlzQ29udGV4dCgpIHtcbiAgICB2bS5ydW5JblRoaXNDb250ZXh0ID0gb3JpZ2luYWxSdW5JblRoaXNDb250ZXh0O1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGhvb2tSZXF1aXJlOiBob29rUmVxdWlyZSxcbiAgICB1bmhvb2tSZXF1aXJlOiB1bmhvb2tSZXF1aXJlLFxuICAgIGhvb2tDcmVhdGVTY3JpcHQ6IGhvb2tDcmVhdGVTY3JpcHQsXG4gICAgdW5ob29rQ3JlYXRlU2NyaXB0OiB1bmhvb2tDcmVhdGVTY3JpcHQsXG4gICAgaG9va1J1bkluVGhpc0NvbnRleHQgOiBob29rUnVuSW5UaGlzQ29udGV4dCxcbiAgICB1bmhvb2tSdW5JblRoaXNDb250ZXh0IDogdW5ob29rUnVuSW5UaGlzQ29udGV4dCxcbiAgICB1bmxvYWRSZXF1aXJlQ2FjaGU6IHVubG9hZFJlcXVpcmVDYWNoZVxufTtcblxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/lib/hook.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/lib/instrumenter.js":
/*!******************************************************!*\
  !*** ./node_modules/sc-istanbul/lib/instrumenter.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n/*global esprima, escodegen, window */\n(function (isNode) {\n    \"use strict\";\n    var SYNTAX,\n        nodeType,\n        ESP = isNode ? __webpack_require__(/*! esprima */ \"(ssr)/./node_modules/esprima/esprima.js\") : esprima,\n        ESPGEN = isNode ? __webpack_require__(/*! escodegen */ \"(ssr)/./node_modules/escodegen/escodegen.js\") : escodegen,  //TODO - package as dependency\n        crypto = isNode ? __webpack_require__(/*! crypto */ \"crypto\") : null,\n        LEADER_WRAP = '(function () { ',\n        TRAILER_WRAP = '\\n}());',\n        COMMENT_RE = /^\\s*istanbul\\s+ignore\\s+(if|else|next)(?=\\W|$)/,\n        astgen,\n        preconditions,\n        cond,\n        isArray = Array.isArray;\n\n    /* istanbul ignore if: untestable */\n    if (!isArray) {\n        isArray = function (thing) { return thing &&  Object.prototype.toString.call(thing) === '[object Array]'; };\n    }\n\n    if (!isNode) {\n        preconditions = {\n            'Could not find esprima': ESP,\n            'Could not find escodegen': ESPGEN,\n            'JSON object not in scope': JSON,\n            'Array does not implement push': [].push,\n            'Array does not implement unshift': [].unshift\n        };\n        /* istanbul ignore next: untestable */\n        for (cond in preconditions) {\n            if (preconditions.hasOwnProperty(cond)) {\n                if (!preconditions[cond]) { throw new Error(cond); }\n            }\n        }\n    }\n\n    function generateTrackerVar(filename, omitSuffix) {\n        var hash, suffix;\n        if (crypto !== null) {\n            hash = crypto.createHash('md5');\n            hash.update(filename);\n            suffix = hash.digest('base64');\n            //trim trailing equal signs, turn identifier unsafe chars to safe ones + => _ and / => $\n            suffix = suffix.replace(new RegExp('=', 'g'), '')\n                .replace(new RegExp('\\\\+', 'g'), '_')\n                .replace(new RegExp('/', 'g'), '$');\n        } else {\n            window.__cov_seq = window.__cov_seq || 0;\n            window.__cov_seq += 1;\n            suffix = window.__cov_seq;\n        }\n        return '__cov_' + (omitSuffix ? '' : suffix);\n    }\n\n    function pushAll(ary, thing) {\n        if (!isArray(thing)) {\n            thing = [ thing ];\n        }\n        Array.prototype.push.apply(ary, thing);\n    }\n\n    SYNTAX = {\n        // keep in sync with estraverse's VisitorKeys\n        AssignmentExpression: ['left', 'right'],\n        AssignmentPattern: ['left', 'right'],\n        ArrayExpression: ['elements'],\n        ArrayPattern: ['elements'],\n        ArrowFunctionExpression: ['params', 'body'],\n        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.\n        BlockStatement: ['body'],\n        BinaryExpression: ['left', 'right'],\n        BreakStatement: ['label'],\n        CallExpression: ['callee', 'arguments'],\n        CatchClause: ['param', 'body'],\n        ClassBody: ['body'],\n        ClassDeclaration: ['id', 'superClass', 'body'],\n        ClassExpression: ['id', 'superClass', 'body'],\n        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: ['test', 'consequent', 'alternate'],\n        ContinueStatement: ['label'],\n        DebuggerStatement: [],\n        DirectiveStatement: [],\n        DoWhileStatement: ['body', 'test'],\n        EmptyStatement: [],\n        ExportAllDeclaration: ['source'],\n        ExportDefaultDeclaration: ['declaration'],\n        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],\n        ExportSpecifier: ['exported', 'local'],\n        ExpressionStatement: ['expression'],\n        ForStatement: ['init', 'test', 'update', 'body'],\n        ForInStatement: ['left', 'right', 'body'],\n        ForOfStatement: ['left', 'right', 'body'],\n        FunctionDeclaration: ['id', 'params', 'body'],\n        FunctionExpression: ['id', 'params', 'body'],\n        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        Identifier: [],\n        IfStatement: ['test', 'consequent', 'alternate'],\n        ImportDeclaration: ['specifiers', 'source'],\n        ImportDefaultSpecifier: ['local'],\n        ImportNamespaceSpecifier: ['local'],\n        ImportSpecifier: ['imported', 'local'],\n        Literal: [],\n        LabeledStatement: ['label', 'body'],\n        LogicalExpression: ['left', 'right'],\n        MetaProperty: ['meta', 'property'],\n        MemberExpression: ['object', 'property'],\n        MethodDefinition: ['key', 'value'],\n        ModuleSpecifier: [],\n        NewExpression: ['callee', 'arguments'],\n        ObjectExpression: ['properties'],\n        ObjectPattern: ['properties'],\n        Program: ['body'],\n        Property: ['key', 'value'],\n        RestElement: [ 'argument' ],\n        ReturnStatement: ['argument'],\n        SequenceExpression: ['expressions'],\n        SpreadElement: ['argument'],\n        Super: [],\n        SwitchStatement: ['discriminant', 'cases'],\n        SwitchCase: ['test', 'consequent'],\n        TaggedTemplateExpression: ['tag', 'quasi'],\n        TemplateElement: [],\n        TemplateLiteral: ['quasis', 'expressions'],\n        ThisExpression: [],\n        ThrowStatement: ['argument'],\n        TryStatement: ['block', 'handler', 'finalizer'],\n        UnaryExpression: ['argument'],\n        UpdateExpression: ['argument'],\n        VariableDeclaration: ['declarations'],\n        VariableDeclarator: ['id', 'init'],\n        WhileStatement: ['test', 'body'],\n        WithStatement: ['object', 'body'],\n        YieldExpression: ['argument']\n    };\n\n    for (nodeType in SYNTAX) {\n        /* istanbul ignore else: has own property */\n        if (SYNTAX.hasOwnProperty(nodeType)) {\n            SYNTAX[nodeType] = { name: nodeType, children: SYNTAX[nodeType] };\n        }\n    }\n\n    astgen = {\n        variable: function (name) { return { type: SYNTAX.Identifier.name, name: name }; },\n        stringLiteral: function (str) { return { type: SYNTAX.Literal.name, value: String(str) }; },\n        numericLiteral: function (num) { return { type: SYNTAX.Literal.name, value: Number(num) }; },\n        statement: function (contents) { return { type: SYNTAX.ExpressionStatement.name, expression: contents }; },\n        dot: function (obj, field) { return { type: SYNTAX.MemberExpression.name, computed: false, object: obj, property: field }; },\n        subscript: function (obj, sub) { return { type: SYNTAX.MemberExpression.name, computed: true, object: obj, property: sub }; },\n        postIncrement: function (obj) { return { type: SYNTAX.UpdateExpression.name, operator: '++', prefix: false, argument: obj }; },\n        sequence: function (one, two) { return { type: SYNTAX.SequenceExpression.name, expressions: [one, two] }; },\n        returnStatement: function (expr) { return { type: SYNTAX.ReturnStatement.name, argument: expr }; }\n    };\n\n    function Walker(walkMap, preprocessor, scope, debug) {\n        this.walkMap = walkMap;\n        this.preprocessor = preprocessor;\n        this.scope = scope;\n        this.debug = debug;\n        if (this.debug) {\n            this.level = 0;\n            this.seq = true;\n        }\n    }\n\n    function defaultWalker(node, walker) {\n\n        var type = node.type,\n            preprocessor,\n            postprocessor,\n            children = SYNTAX[type],\n            // don't run generated nodes thru custom walks otherwise we will attempt to instrument the instrumentation code :)\n            applyCustomWalker = !!node.loc || node.type === SYNTAX.Program.name,\n            walkerFn = applyCustomWalker ? walker.walkMap[type] : null,\n            i,\n            j,\n            walkFnIndex,\n            childType,\n            childNode,\n            ret,\n            childArray,\n            childElement,\n            pathElement,\n            assignNode,\n            isLast;\n\n        if (!SYNTAX[type]) {\n            console.error(node);\n            console.error('Unsupported node type:' + type);\n            return;\n        }\n        children = SYNTAX[type].children;\n        /* istanbul ignore if: guard */\n        if (node.walking) { throw new Error('Infinite regress: Custom walkers may NOT call walker.apply(node)'); }\n        node.walking = true;\n\n        ret = walker.apply(node, walker.preprocessor);\n\n        preprocessor = ret.preprocessor;\n        if (preprocessor) {\n            delete ret.preprocessor;\n            ret = walker.apply(node, preprocessor);\n        }\n\n        if (isArray(walkerFn)) {\n            for (walkFnIndex = 0; walkFnIndex < walkerFn.length; walkFnIndex += 1) {\n                isLast = walkFnIndex === walkerFn.length - 1;\n                ret = walker.apply(ret, walkerFn[walkFnIndex]);\n                /*istanbul ignore next: paranoid check */\n                if (ret.type !== type && !isLast) {\n                    throw new Error('Only the last walker is allowed to change the node type: [type was: ' + type + ' ]');\n                }\n            }\n        } else {\n            if (walkerFn) {\n                ret = walker.apply(node, walkerFn);\n            }\n        }\n\n        if (node.skipSelf) {\n            return;\n        }\n\n        for (i = 0; i < children.length; i += 1) {\n            childType = children[i];\n            childNode = node[childType];\n            if (childNode && !childNode.skipWalk) {\n                pathElement = { node: node, property: childType };\n                if (isArray(childNode)) {\n                    childArray = [];\n                    for (j = 0; j < childNode.length; j += 1) {\n                        childElement = childNode[j];\n                        pathElement.index = j;\n                        if (childElement) {\n                          assignNode = walker.apply(childElement, null, pathElement);\n                          if (isArray(assignNode.prepend)) {\n                              pushAll(childArray, assignNode.prepend);\n                              delete assignNode.prepend;\n                          }\n                        } else {\n                            assignNode = undefined;\n                        }\n                        pushAll(childArray, assignNode);\n                    }\n                    node[childType] = childArray;\n                } else {\n                    assignNode = walker.apply(childNode, null, pathElement);\n                    /*istanbul ignore if: paranoid check */\n                    if (isArray(assignNode.prepend)) {\n                        throw new Error('Internal error: attempt to prepend statements in disallowed (non-array) context');\n                        /* if this should be allowed, this is how to solve it\n                        tmpNode = { type: 'BlockStatement', body: [] };\n                        pushAll(tmpNode.body, assignNode.prepend);\n                        pushAll(tmpNode.body, assignNode);\n                        node[childType] = tmpNode;\n                        delete assignNode.prepend;\n                        */\n                    } else {\n                        node[childType] = assignNode;\n                    }\n                }\n            }\n        }\n\n        postprocessor = ret.postprocessor;\n        if (postprocessor) {\n            delete ret.postprocessor;\n            ret = walker.apply(ret, postprocessor);\n        }\n\n        delete node.walking;\n\n        return ret;\n    }\n\n    Walker.prototype = {\n        startWalk: function (node) {\n            this.path = [];\n            this.apply(node);\n        },\n\n        apply: function (node, walkFn, pathElement) {\n            var ret, i, seq, prefix;\n\n            walkFn = walkFn || defaultWalker;\n            if (this.debug) {\n                this.seq += 1;\n                this.level += 1;\n                seq = this.seq;\n                prefix = '';\n                for (i = 0; i < this.level; i += 1) { prefix += '    '; }\n                console.log(prefix + 'Enter (' + seq + '):' + node.type);\n            }\n            if (pathElement) { this.path.push(pathElement); }\n            ret = walkFn.call(this.scope, node, this);\n            if (pathElement) { this.path.pop(); }\n            if (this.debug) {\n                this.level -= 1;\n                console.log(prefix + 'Return (' + seq + '):' + node.type);\n            }\n            return ret || node;\n        },\n\n        startLineForNode: function (node) {\n            return node && node.loc && node.loc.start ? node.loc.start.line : /* istanbul ignore next: guard */ null;\n        },\n\n        ancestor: function (n) {\n            return this.path.length > n - 1 ? this.path[this.path.length - n] : /* istanbul ignore next: guard */ null;\n        },\n\n        parent: function () {\n            return this.ancestor(1);\n        },\n\n        isLabeled: function () {\n            var el = this.parent();\n            return el && el.node.type === SYNTAX.LabeledStatement.name;\n        }\n    };\n\n    /**\n     * mechanism to instrument code for coverage. It uses the `esprima` and\n     * `escodegen` libraries for JS parsing and code generation respectively.\n     *\n     * Works on `node` as well as the browser.\n     *\n     * Usage on nodejs\n     * ---------------\n     *\n     *      var instrumenter = new require('istanbul').Instrumenter(),\n     *          changed = instrumenter.instrumentSync('function meaningOfLife() { return 42; }', 'filename.js');\n     *\n     * Usage in a browser\n     * ------------------\n     *\n     * Load `esprima.js`, `escodegen.js` and `instrumenter.js` (this file) using `script` tags or other means.\n     *\n     * Create an instrumenter object as:\n     *\n     *      var instrumenter = new Instrumenter(),\n     *          changed = instrumenter.instrumentSync('function meaningOfLife() { return 42; }', 'filename.js');\n     *\n     * Aside from demonstration purposes, it is unclear why you would want to instrument code in a browser.\n     *\n     * @class Instrumenter\n     * @constructor\n     * @param {Object} options Optional. Configuration options.\n     * @param {String} [options.coverageVariable] the global variable name to use for\n     *      tracking coverage. Defaults to `__coverage__`\n     * @param {Boolean} [options.embedSource] whether to embed the source code of every\n     *      file as an array in the file coverage object for that file. Defaults to `false`\n     * @param {Boolean} [options.preserveComments] whether comments should be preserved in the output. Defaults to `false`\n     * @param {Boolean} [options.noCompact] emit readable code when set. Defaults to `false`\n     * @param {Boolean} [options.esModules] whether the code to instrument contains uses es\n     *      imports or exports.\n     * @param {Boolean} [options.noAutoWrap] do not automatically wrap the source in\n     *      an anonymous function before covering it. By default, code is wrapped in\n     *      an anonymous function before it is parsed. This is done because\n     *      some nodejs libraries have `return` statements outside of\n     *      a function which is technically invalid Javascript and causes the parser to fail.\n     *      This construct, however, works correctly in node since module loading\n     *      is done in the context of an anonymous function.\n     *\n     * Note that the semantics of the code *returned* by the instrumenter does not change in any way.\n     * The function wrapper is \"unwrapped\" before the instrumented code is generated.\n     * @param {Object} [options.codeGenerationOptions] an object that is directly passed to the `escodegen`\n     *      library as configuration for code generation. The `noCompact` setting is not honored when this\n     *      option is specified\n     * @param {Boolean} [options.debug] assist in debugging. Currently, the only effect of\n     *      setting this option is a pretty-print of the coverage variable. Defaults to `false`\n     * @param {Boolean} [options.walkDebug] assist in debugging of the AST walker used by this class.\n     *\n     */\n    function Instrumenter(options) {\n        this.opts = options || {\n            debug: false,\n            walkDebug: false,\n            coverageVariable: '__coverage__',\n            codeGenerationOptions: undefined,\n            noAutoWrap: false,\n            noCompact: false,\n            embedSource: false,\n            preserveComments: false,\n            esModules: false\n        };\n\n        if (this.opts.esModules && !this.opts.noAutoWrap) {\n            this.opts.noAutoWrap = true;\n            if (this.opts.debug) {\n                console.log('Setting noAutoWrap to true as required by esModules');\n            }\n        }\n\n        this.walker = new Walker({\n            ArrowFunctionExpression: [ this.arrowBlockConverter ],\n            ExpressionStatement: this.coverStatement,\n            ExportNamedDeclaration: this.coverExport,\n            BreakStatement: this.coverStatement,\n            ContinueStatement: this.coverStatement,\n            DebuggerStatement: this.coverStatement,\n            ReturnStatement: this.coverStatement,\n            ThrowStatement: this.coverStatement,\n            TryStatement: [ this.paranoidHandlerCheck, this.coverStatement],\n            VariableDeclaration: this.coverStatement,\n            IfStatement: [ this.ifBlockConverter, this.coverStatement, this.ifBranchInjector ],\n            ForStatement: [ this.skipInit, this.loopBlockConverter, this.coverStatement ],\n            ForInStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],\n            ForOfStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],\n            WhileStatement: [ this.loopBlockConverter, this.coverStatement ],\n            DoWhileStatement: [ this.loopBlockConverter, this.coverStatement ],\n            SwitchStatement: [ this.coverStatement, this.switchBranchInjector ],\n            SwitchCase: [ this.switchCaseInjector ],\n            WithStatement: [ this.withBlockConverter, this.coverStatement ],\n            FunctionDeclaration: [ this.coverFunction, this.coverStatement ],\n            FunctionExpression: this.coverFunction,\n            LabeledStatement: this.coverStatement,\n            ConditionalExpression: this.conditionalBranchInjector,\n            LogicalExpression: this.logicalExpressionBranchInjector,\n            ObjectExpression: this.maybeAddType,\n            MetaProperty: this.coverMetaProperty,\n        }, this.extractCurrentHint, this, this.opts.walkDebug);\n\n        //unit testing purposes only\n        if (this.opts.backdoor && this.opts.backdoor.omitTrackerSuffix) {\n            this.omitTrackerSuffix = true;\n        }\n    }\n\n    Instrumenter.prototype = {\n        /**\n         * synchronous instrumentation method. Throws when illegal code is passed to it\n         * @method instrumentSync\n         * @param {String} code the code to be instrumented as a String\n         * @param {String} filename Optional. The name of the file from which\n         *  the code was read. A temporary filename is generated when not specified.\n         *  Not specifying a filename is only useful for unit tests and demonstrations\n         *  of this library.\n         */\n        instrumentSync: function (code, filename) {\n            var program;\n\n            //protect from users accidentally passing in a Buffer object instead\n            if (typeof code !== 'string') { throw new Error('Code must be string'); }\n            if (code.charAt(0) === '#') { //shebang, 'comment' it out, won't affect syntax tree locations for things we care about\n                code = '//' + code;\n            }\n            if (!this.opts.noAutoWrap) {\n                code = LEADER_WRAP + code + TRAILER_WRAP;\n            }\n            try {\n                program = ESP.parse(code, {\n                    loc: true,\n                    range: true,\n                    tokens: this.opts.preserveComments,\n                    comment: true,\n                    sourceType: this.opts.esModules ? 'module' : 'script'\n                });\n            } catch (e) {\n                console.log('Failed to parse file: ' + filename);\n                throw e;\n            }\n            if (this.opts.preserveComments) {\n                program = ESPGEN.attachComments(program, program.comments, program.tokens);\n            }\n            if (!this.opts.noAutoWrap) {\n                program = {\n                    type: SYNTAX.Program.name,\n                    body: program.body[0].expression.callee.body.body,\n                    comments: program.comments\n                };\n            }\n            return this.instrumentASTSync(program, filename, code);\n        },\n        filterHints: function (comments) {\n            var ret = [],\n                i,\n                comment,\n                groups;\n            if (!(comments && isArray(comments))) {\n                return ret;\n            }\n            for (i = 0; i < comments.length; i += 1) {\n                comment = comments[i];\n                /* istanbul ignore else: paranoid check */\n                if (comment && comment.value && comment.range && isArray(comment.range)) {\n                    groups = String(comment.value).match(COMMENT_RE);\n                    if (groups) {\n                        ret.push({ type: groups[1], start: comment.range[0], end: comment.range[1] });\n                    }\n                }\n            }\n            return ret;\n        },\n        extractCurrentHint: function (node) {\n            if (!node.range) { return; }\n            var i = this.currentState.lastHintPosition + 1,\n                hints = this.currentState.hints,\n                nodeStart = node.range[0],\n                hint;\n            this.currentState.currentHint = null;\n            while (i < hints.length) {\n                hint = hints[i];\n                if (hint.end < nodeStart) {\n                    this.currentState.currentHint = hint;\n                    this.currentState.lastHintPosition = i;\n                    i += 1;\n                } else {\n                    break;\n                }\n            }\n        },\n        /**\n         * synchronous instrumentation method that instruments an AST instead.\n         * @method instrumentASTSync\n         * @param {String} program the AST to be instrumented\n         * @param {String} filename Optional. The name of the file from which\n         *  the code was read. A temporary filename is generated when not specified.\n         *  Not specifying a filename is only useful for unit tests and demonstrations\n         *  of this library.\n         *  @param {String} originalCode the original code corresponding to the AST,\n         *  used for embedding the source into the coverage object\n         */\n        instrumentASTSync: function (program, filename, originalCode) {\n            var usingStrict = false,\n                codegenOptions,\n                generated,\n                preamble,\n                lineCount,\n                i;\n            filename = filename || String(new Date().getTime()) + '.js';\n            this.sourceMap = null;\n            this.coverState = {\n                path: filename,\n                s: {},\n                b: {},\n                f: {},\n                fnMap: {},\n                statementMap: {},\n                branchMap: {}\n            };\n            this.currentState = {\n                trackerVar: generateTrackerVar(filename, this.omitTrackerSuffix),\n                func: 0,\n                branch: 0,\n                variable: 0,\n                statement: 0,\n                hints: this.filterHints(program.comments),\n                currentHint: null,\n                lastHintPosition: -1,\n                ignoring: 0\n            };\n            if (program.body && program.body.length > 0 && this.isUseStrictExpression(program.body[0])) {\n                //nuke it\n                program.body.shift();\n                //and add it back at code generation time\n                usingStrict = true;\n            }\n            this.walker.startWalk(program);\n            codegenOptions = this.opts.codeGenerationOptions || { format: { compact: !this.opts.noCompact }};\n            codegenOptions.comment = this.opts.preserveComments;\n            //console.log(JSON.stringify(program, undefined, 2));\n\n            generated = ESPGEN.generate(program, codegenOptions);\n            preamble = this.getPreamble(originalCode || '', usingStrict);\n\n            if (generated.map && generated.code) {\n                lineCount = preamble.split(/\\r\\n|\\r|\\n/).length;\n                // offset all the generated line numbers by the number of lines in the preamble\n                for (i = 0; i < generated.map._mappings._array.length; i += 1) {\n                    generated.map._mappings._array[i].generatedLine += lineCount;\n                }\n                this.sourceMap = generated.map;\n                generated = generated.code;\n            }\n\n            return preamble + '\\n' + generated + '\\n';\n        },\n        /**\n         * Callback based instrumentation. Note that this still executes synchronously in the same process tick\n         * and calls back immediately. It only provides the options for callback style error handling as\n         * opposed to a `try-catch` style and nothing more. Implemented as a wrapper over `instrumentSync`\n         *\n         * @method instrument\n         * @param {String} code the code to be instrumented as a String\n         * @param {String} filename Optional. The name of the file from which\n         *  the code was read. A temporary filename is generated when not specified.\n         *  Not specifying a filename is only useful for unit tests and demonstrations\n         *  of this library.\n         * @param {Function(err, instrumentedCode)} callback - the callback function\n         */\n        instrument: function (code, filename, callback) {\n\n            if (!callback && typeof filename === 'function') {\n                callback = filename;\n                filename = null;\n            }\n            try {\n                callback(null, this.instrumentSync(code, filename));\n            } catch (ex) {\n                callback(ex);\n            }\n        },\n        /**\n         * returns the file coverage object for the code that was instrumented\n         * just before calling this method. Note that this represents a\n         * \"zero-coverage\" object which is not even representative of the code\n         * being loaded in node or a browser (which would increase the statement\n         * counts for mainline code).\n         * @method lastFileCoverage\n         * @return {Object} a \"zero-coverage\" file coverage object for the code last instrumented\n         * by this instrumenter\n         */\n        lastFileCoverage: function () {\n            return this.coverState;\n        },\n        /**\n         * returns the source map object for the code that was instrumented\n         * just before calling this method.\n         * @method lastSourceMap\n         * @return {Object} a source map object for the code last instrumented\n         * by this instrumenter\n         */\n        lastSourceMap: function () {\n            return this.sourceMap;\n        },\n        fixColumnPositions: function (coverState) {\n            var offset = LEADER_WRAP.length,\n                fixer = function (loc) {\n                    if (loc.start.line === 1) {\n                        loc.start.column -= offset;\n                    }\n                    if (loc.end.line === 1) {\n                        loc.end.column -= offset;\n                    }\n                },\n                k,\n                obj,\n                i,\n                locations;\n\n            obj = coverState.statementMap;\n            for (k in obj) {\n                /* istanbul ignore else: has own property */\n                if (obj.hasOwnProperty(k)) { fixer(obj[k]); }\n            }\n            obj = coverState.fnMap;\n            for (k in obj) {\n                /* istanbul ignore else: has own property */\n                if (obj.hasOwnProperty(k)) { fixer(obj[k].loc); }\n            }\n            obj = coverState.branchMap;\n            for (k in obj) {\n                /* istanbul ignore else: has own property */\n                if (obj.hasOwnProperty(k)) {\n                    locations = obj[k].locations;\n                    for (i = 0; i < locations.length; i += 1) {\n                        fixer(locations[i]);\n                    }\n                }\n            }\n        },\n\n        getPreamble: function (sourceCode, emitUseStrict) {\n            var varName = this.opts.coverageVariable || '__coverage__',\n                file = this.coverState.path.replace(/\\\\/g, '\\\\\\\\'),\n                tracker = this.currentState.trackerVar,\n                coverState,\n                strictLine = emitUseStrict ? '\"use strict\";' : '',\n                // return replacements using the function to ensure that the replacement is\n                // treated like a dumb string and not as a string with RE replacement patterns\n                replacer = function (s) {\n                    return function () { return s; };\n                },\n                code;\n            if (!this.opts.noAutoWrap) {\n                this.fixColumnPositions(this.coverState);\n            }\n            if (this.opts.embedSource) {\n                this.coverState.code = sourceCode.split(/(?:\\r?\\n)|\\r/);\n            }\n            coverState = this.opts.debug ? JSON.stringify(this.coverState, undefined, 4) : JSON.stringify(this.coverState);\n            code = [\n                \"%STRICT%\",\n                \"var %VAR% = (Function('return this'))();\",\n                \"if (!%VAR%.%GLOBAL%) { %VAR%.%GLOBAL% = {}; }\",\n                \"%VAR% = %VAR%.%GLOBAL%;\",\n                \"if (!(%VAR%['%FILE%'])) {\",\n                \"   %VAR%['%FILE%'] = %OBJECT%;\",\n                \"}\",\n                \"%VAR% = %VAR%['%FILE%'];\"\n            ].join(\"\\n\")\n                .replace(/%STRICT%/g, replacer(strictLine))\n                .replace(/%VAR%/g, replacer(tracker))\n                .replace(/%GLOBAL%/g, replacer(varName))\n                .replace(/%FILE%/g, replacer(file))\n                .replace(/%OBJECT%/g, replacer(coverState));\n            return code;\n        },\n\n        startIgnore: function () {\n            this.currentState.ignoring += 1;\n        },\n\n        endIgnore: function () {\n            this.currentState.ignoring -= 1;\n        },\n\n        convertToBlock: function (node) {\n            if (!node) {\n                return { type: 'BlockStatement', body: [] };\n            } else if (node.type === 'BlockStatement') {\n                return node;\n            } else {\n                return { type: 'BlockStatement', body: [ node ] };\n            }\n        },\n\n        arrowBlockConverter: function (node) {\n            var retStatement;\n            if (node.expression) { // turn expression nodes into a block with a return statement\n                retStatement = astgen.returnStatement(node.body);\n                // ensure the generated return statement is covered\n                retStatement.loc = node.body.loc;\n                node.body = this.convertToBlock(retStatement);\n                node.expression = false;\n            }\n        },\n\n        paranoidHandlerCheck: function (node) {\n            // if someone is using an older esprima on the browser\n            // convert handlers array to single handler attribute\n            // containing its first element\n            /* istanbul ignore next */\n            if (!node.handler && node.handlers) {\n                node.handler = node.handlers[0];\n            }\n        },\n\n        ifBlockConverter: function (node) {\n            node.consequent = this.convertToBlock(node.consequent);\n            node.alternate = this.convertToBlock(node.alternate);\n        },\n\n        loopBlockConverter: function (node) {\n            node.body = this.convertToBlock(node.body);\n        },\n\n        withBlockConverter: function (node) {\n            node.body = this.convertToBlock(node.body);\n        },\n\n        statementName: function (location, initValue) {\n            var sName,\n                ignoring = !!this.currentState.ignoring;\n\n            location.skip = ignoring || undefined;\n            initValue = initValue || 0;\n            this.currentState.statement += 1;\n            sName = this.currentState.statement;\n            this.coverState.statementMap[sName] = location;\n            this.coverState.s[sName] = initValue;\n            return sName;\n        },\n\n        skipInit: function (node /*, walker */) {\n            if (node.init) {\n                node.init.skipWalk = true;\n            }\n        },\n\n        skipLeft: function (node /*, walker */) {\n            node.left.skipWalk = true;\n        },\n\n        isUseStrictExpression: function (node) {\n            return node && node.type === SYNTAX.ExpressionStatement.name &&\n                node.expression  && node.expression.type === SYNTAX.Literal.name &&\n                node.expression.value === 'use strict';\n        },\n\n        maybeSkipNode: function (node, type) {\n            var alreadyIgnoring = !!this.currentState.ignoring,\n                hint = this.currentState.currentHint,\n                ignoreThis = !alreadyIgnoring && hint && hint.type === type;\n\n            if (ignoreThis) {\n                this.startIgnore();\n                node.postprocessor = this.endIgnore;\n                return true;\n            }\n            return false;\n        },\n\n        coverMetaProperty: function(node /* , walker */) {\n           node.skipSelf = true;\n        },\n\n        coverStatement: function (node, walker) {\n            var sName,\n                incrStatementCount,\n                parent,\n                grandParent;\n\n            this.maybeSkipNode(node, 'next');\n\n            if (this.isUseStrictExpression(node)) {\n                grandParent = walker.ancestor(2);\n                /* istanbul ignore else: difficult to test */\n                if (grandParent) {\n                    if ((grandParent.node.type === SYNTAX.FunctionExpression.name ||\n                        grandParent.node.type === SYNTAX.FunctionDeclaration.name)  &&\n                        walker.parent().node.body[0] === node) {\n                        return;\n                    }\n                }\n            }\n\n            if (node.type === SYNTAX.FunctionDeclaration.name) {\n                // Called for the side-effect of setting the function's statement count to 1.\n                this.statementName(node.loc, 1);\n            } else {\n                // We let `coverExport` handle ExportNamedDeclarations.\n                parent = walker.parent();\n                if (parent && parent.node.type === SYNTAX.ExportNamedDeclaration.name) {\n                    return;\n                }\n\n                sName = this.statementName(node.loc);\n\n                incrStatementCount = astgen.statement(\n                    astgen.postIncrement(\n                        astgen.subscript(\n                            astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable('s')),\n                            astgen.stringLiteral(sName)\n                        )\n                    )\n                );\n\n                this.splice(incrStatementCount, node, walker);\n            }\n        },\n\n        coverExport: function (node, walker) {\n            var sName, incrStatementCount;\n\n            if ( !node.declaration || !node.declaration.declarations ) { return; }\n\n            this.maybeSkipNode(node, 'next');\n\n            sName = this.statementName(node.declaration.loc);\n            incrStatementCount = astgen.statement(\n                astgen.postIncrement(\n                    astgen.subscript(\n                        astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable('s')),\n                        astgen.stringLiteral(sName)\n                    )\n                )\n            );\n\n            this.splice(incrStatementCount, node, walker);\n        },\n\n        splice: function (statements, node, walker) {\n            var targetNode = walker.isLabeled() ? walker.parent().node : node;\n            targetNode.prepend = targetNode.prepend || [];\n            pushAll(targetNode.prepend, statements);\n        },\n\n        functionName: function (node, line, location) {\n            this.currentState.func += 1;\n            var id = this.currentState.func,\n                ignoring = !!this.currentState.ignoring,\n                name = node.id ? node.id.name : '(anonymous_' + id + ')',\n                clone = function (attr) {\n                    var obj = location[attr] || /* istanbul ignore next */ {};\n                    return { line: obj.line, column: obj.column };\n                };\n            this.coverState.fnMap[id] = {\n                name: name, line: line,\n                loc: {\n                    start: clone('start'),\n                    end: clone('end')\n                },\n                skip: ignoring || undefined\n            };\n            this.coverState.f[id] = 0;\n            return id;\n        },\n\n        coverFunction: function (node, walker) {\n            var id,\n                body = node.body,\n                blockBody = body.body,\n                popped;\n\n            this.maybeSkipNode(node, 'next');\n\n            id = this.functionName(node, walker.startLineForNode(node), {\n                start: node.loc.start,\n                end: { line: node.body.loc.start.line, column: node.body.loc.start.column }\n            });\n\n            if (blockBody.length > 0 && this.isUseStrictExpression(blockBody[0])) {\n                popped = blockBody.shift();\n            }\n            blockBody.unshift(\n                astgen.statement(\n                    astgen.postIncrement(\n                        astgen.subscript(\n                            astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable('f')),\n                            astgen.stringLiteral(id)\n                        )\n                    )\n                )\n            );\n            if (popped) {\n                blockBody.unshift(popped);\n            }\n        },\n\n        branchName: function (type, startLine, pathLocations) {\n            var bName,\n                paths = [],\n                locations = [],\n                i,\n                ignoring = !!this.currentState.ignoring;\n            this.currentState.branch += 1;\n            bName = this.currentState.branch;\n            for (i = 0; i < pathLocations.length; i += 1) {\n                pathLocations[i].skip = pathLocations[i].skip || ignoring || undefined;\n                locations.push(pathLocations[i]);\n                paths.push(0);\n            }\n            this.coverState.b[bName] = paths;\n            this.coverState.branchMap[bName] = { line: startLine, type: type, locations: locations };\n            return bName;\n        },\n\n        branchIncrementExprAst: function (varName, branchIndex, down) {\n            var ret = astgen.postIncrement(\n                astgen.subscript(\n                    astgen.subscript(\n                        astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable('b')),\n                        astgen.stringLiteral(varName)\n                    ),\n                    astgen.numericLiteral(branchIndex)\n                ),\n                down\n            );\n            return ret;\n        },\n\n        locationsForNodes: function (nodes) {\n            var ret = [],\n                i;\n            for (i = 0; i < nodes.length; i += 1) {\n                ret.push(nodes[i].loc);\n            }\n            return ret;\n        },\n\n        ifBranchInjector: function (node, walker) {\n            var alreadyIgnoring = !!this.currentState.ignoring,\n                hint = this.currentState.currentHint,\n                ignoreThen = !alreadyIgnoring && hint && hint.type === 'if',\n                ignoreElse = !alreadyIgnoring && hint && hint.type === 'else',\n                line = node.loc.start.line,\n                col = node.loc.start.column,\n                makeLoc = function () { return  { line: line, column: col }; },\n                bName = this.branchName('if', walker.startLineForNode(node), [\n                    { start: makeLoc(), end: makeLoc(), skip: ignoreThen || undefined },\n                    { start: makeLoc(), end: makeLoc(), skip: ignoreElse || undefined }\n                ]),\n                thenBody = node.consequent.body,\n                elseBody = node.alternate.body,\n                child;\n            thenBody.unshift(astgen.statement(this.branchIncrementExprAst(bName, 0)));\n            elseBody.unshift(astgen.statement(this.branchIncrementExprAst(bName, 1)));\n            if (ignoreThen) { child = node.consequent; child.preprocessor = this.startIgnore; child.postprocessor = this.endIgnore; }\n            if (ignoreElse) { child = node.alternate; child.preprocessor = this.startIgnore; child.postprocessor = this.endIgnore; }\n        },\n\n        branchLocationFor: function (name, index) {\n            return this.coverState.branchMap[name].locations[index];\n        },\n\n        switchBranchInjector: function (node, walker) {\n            var cases = node.cases,\n                bName,\n                i;\n\n            if (!(cases && cases.length > 0)) {\n                return;\n            }\n            bName = this.branchName('switch', walker.startLineForNode(node), this.locationsForNodes(cases));\n            for (i = 0; i < cases.length; i += 1) {\n                cases[i].branchLocation = this.branchLocationFor(bName, i);\n                cases[i].consequent.unshift(astgen.statement(this.branchIncrementExprAst(bName, i)));\n            }\n        },\n\n        switchCaseInjector: function (node) {\n            var location = node.branchLocation;\n            delete node.branchLocation;\n            if (this.maybeSkipNode(node, 'next')) {\n                location.skip = true;\n            }\n        },\n\n        conditionalBranchInjector: function (node, walker) {\n            var bName = this.branchName('cond-expr', walker.startLineForNode(node), this.locationsForNodes([ node.consequent, node.alternate ])),\n                ast1 = this.branchIncrementExprAst(bName, 0),\n                ast2 = this.branchIncrementExprAst(bName, 1);\n\n            node.consequent.preprocessor = this.maybeAddSkip(this.branchLocationFor(bName, 0));\n            node.alternate.preprocessor = this.maybeAddSkip(this.branchLocationFor(bName, 1));\n            node.consequent = astgen.sequence(ast1, node.consequent);\n            node.alternate = astgen.sequence(ast2, node.alternate);\n        },\n\n        maybeAddSkip: function (branchLocation) {\n            return function (node) {\n                var alreadyIgnoring = !!this.currentState.ignoring,\n                    hint = this.currentState.currentHint,\n                    ignoreThis = !alreadyIgnoring && hint && hint.type === 'next';\n                if (ignoreThis) {\n                    this.startIgnore();\n                    node.postprocessor = this.endIgnore;\n                }\n                if (ignoreThis || alreadyIgnoring) {\n                    branchLocation.skip = true;\n                }\n            };\n        },\n\n        logicalExpressionBranchInjector: function (node, walker) {\n            var parent = walker.parent(),\n                leaves = [],\n                bName,\n                tuple,\n                i;\n\n            this.maybeSkipNode(node, 'next');\n\n            if (parent && parent.node.type === SYNTAX.LogicalExpression.name) {\n                //already covered\n                return;\n            }\n\n            this.findLeaves(node, leaves);\n            bName = this.branchName('binary-expr',\n                walker.startLineForNode(node),\n                this.locationsForNodes(leaves.map(function (item) { return item.node; }))\n            );\n            for (i = 0; i < leaves.length; i += 1) {\n                tuple = leaves[i];\n                tuple.parent[tuple.property] = astgen.sequence(this.branchIncrementExprAst(bName, i), tuple.node);\n                tuple.node.preprocessor = this.maybeAddSkip(this.branchLocationFor(bName, i));\n            }\n        },\n\n        findLeaves: function (node, accumulator, parent, property) {\n            if (node.type === SYNTAX.LogicalExpression.name) {\n                this.findLeaves(node.left, accumulator, node, 'left');\n                this.findLeaves(node.right, accumulator, node, 'right');\n            } else {\n                accumulator.push({ node: node, parent: parent, property: property });\n            }\n        },\n        maybeAddType: function (node /*, walker */) {\n            var props = node.properties,\n                i,\n                child;\n            for (i = 0; i < props.length; i += 1) {\n                child = props[i];\n                if (!child.type) {\n                    child.type = SYNTAX.Property.name;\n                }\n            }\n        },\n    };\n\n    if (isNode) {\n        module.exports = Instrumenter;\n    } else {\n        window.Instrumenter = Instrumenter;\n    }\n\n}( true && typeof module.exports !== 'undefined' && typeof exports !== 'undefined'));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL2luc3RydW1lbnRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsd0RBQVM7QUFDeEMsMEJBQTBCLG1CQUFPLENBQUMsOERBQVc7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMsc0JBQVE7QUFDMUMsc0NBQXNDO0FBQ3RDLDJCQUEyQixJQUFJO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsU0FBUyw2Q0FBNkM7QUFDMUYsd0NBQXdDLFNBQVMsa0RBQWtEO0FBQ25HLHlDQUF5QyxTQUFTLGtEQUFrRDtBQUNwRyx5Q0FBeUMsU0FBUyxnRUFBZ0U7QUFDbEgscUNBQXFDLFNBQVMsc0ZBQXNGO0FBQ3BJLHlDQUF5QyxTQUFTLG1GQUFtRjtBQUNySSx3Q0FBd0MsU0FBUyxxRkFBcUY7QUFDdEksd0NBQXdDLFNBQVMsa0VBQWtFO0FBQ25ILDJDQUEyQyxTQUFTO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLCtCQUErQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCLFVBQVU7QUFDdEQ7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLFlBQVk7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLFlBQVk7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUMsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlFQUFpRTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHlCQUF5QjtBQUN6QixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxVQUFVO0FBQzVFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkNBQTJDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlDQUFpQztBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCx3Q0FBd0Msc0JBQXNCO0FBQzlELHdDQUF3QztBQUN4QywwQ0FBMEM7QUFDMUMsK0NBQStDO0FBQy9DLGtCQUFrQjtBQUNsQix5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkLHlCQUF5QjtBQUN6QjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQSx5RUFBeUU7O0FBRXpFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFVBQVUsNEJBQTRCO0FBQzlFO0FBQ0Esc0JBQXNCLGlFQUFpRTtBQUN2RixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlCQUF5Qix1Q0FBdUM7QUFDOUYsOEJBQThCLHdCQUF3Qix1Q0FBdUM7QUFDN0YsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxtQkFBbUI7QUFDdkY7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxtQ0FBbUMsZ0RBQWdEO0FBQ25GO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxDQUFDLENBQUMsS0FBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL3NjLWlzdGFuYnVsL2xpYi9pbnN0cnVtZW50ZXIuanM/MGFjMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuIENvcHlyaWdodCAoYykgMjAxMiwgWWFob28hIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG5cbi8qZ2xvYmFsIGVzcHJpbWEsIGVzY29kZWdlbiwgd2luZG93ICovXG4oZnVuY3Rpb24gKGlzTm9kZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBTWU5UQVgsXG4gICAgICAgIG5vZGVUeXBlLFxuICAgICAgICBFU1AgPSBpc05vZGUgPyByZXF1aXJlKCdlc3ByaW1hJykgOiBlc3ByaW1hLFxuICAgICAgICBFU1BHRU4gPSBpc05vZGUgPyByZXF1aXJlKCdlc2NvZGVnZW4nKSA6IGVzY29kZWdlbiwgIC8vVE9ETyAtIHBhY2thZ2UgYXMgZGVwZW5kZW5jeVxuICAgICAgICBjcnlwdG8gPSBpc05vZGUgPyByZXF1aXJlKCdjcnlwdG8nKSA6IG51bGwsXG4gICAgICAgIExFQURFUl9XUkFQID0gJyhmdW5jdGlvbiAoKSB7ICcsXG4gICAgICAgIFRSQUlMRVJfV1JBUCA9ICdcXG59KCkpOycsXG4gICAgICAgIENPTU1FTlRfUkUgPSAvXlxccyppc3RhbmJ1bFxccytpZ25vcmVcXHMrKGlmfGVsc2V8bmV4dCkoPz1cXFd8JCkvLFxuICAgICAgICBhc3RnZW4sXG4gICAgICAgIHByZWNvbmRpdGlvbnMsXG4gICAgICAgIGNvbmQsXG4gICAgICAgIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiB1bnRlc3RhYmxlICovXG4gICAgaWYgKCFpc0FycmF5KSB7XG4gICAgICAgIGlzQXJyYXkgPSBmdW5jdGlvbiAodGhpbmcpIHsgcmV0dXJuIHRoaW5nICYmICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpbmcpID09PSAnW29iamVjdCBBcnJheV0nOyB9O1xuICAgIH1cblxuICAgIGlmICghaXNOb2RlKSB7XG4gICAgICAgIHByZWNvbmRpdGlvbnMgPSB7XG4gICAgICAgICAgICAnQ291bGQgbm90IGZpbmQgZXNwcmltYSc6IEVTUCxcbiAgICAgICAgICAgICdDb3VsZCBub3QgZmluZCBlc2NvZGVnZW4nOiBFU1BHRU4sXG4gICAgICAgICAgICAnSlNPTiBvYmplY3Qgbm90IGluIHNjb3BlJzogSlNPTixcbiAgICAgICAgICAgICdBcnJheSBkb2VzIG5vdCBpbXBsZW1lbnQgcHVzaCc6IFtdLnB1c2gsXG4gICAgICAgICAgICAnQXJyYXkgZG9lcyBub3QgaW1wbGVtZW50IHVuc2hpZnQnOiBbXS51bnNoaWZ0XG4gICAgICAgIH07XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiB1bnRlc3RhYmxlICovXG4gICAgICAgIGZvciAoY29uZCBpbiBwcmVjb25kaXRpb25zKSB7XG4gICAgICAgICAgICBpZiAocHJlY29uZGl0aW9ucy5oYXNPd25Qcm9wZXJ0eShjb25kKSkge1xuICAgICAgICAgICAgICAgIGlmICghcHJlY29uZGl0aW9uc1tjb25kXSkgeyB0aHJvdyBuZXcgRXJyb3IoY29uZCk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlVHJhY2tlclZhcihmaWxlbmFtZSwgb21pdFN1ZmZpeCkge1xuICAgICAgICB2YXIgaGFzaCwgc3VmZml4O1xuICAgICAgICBpZiAoY3J5cHRvICE9PSBudWxsKSB7XG4gICAgICAgICAgICBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goJ21kNScpO1xuICAgICAgICAgICAgaGFzaC51cGRhdGUoZmlsZW5hbWUpO1xuICAgICAgICAgICAgc3VmZml4ID0gaGFzaC5kaWdlc3QoJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgLy90cmltIHRyYWlsaW5nIGVxdWFsIHNpZ25zLCB0dXJuIGlkZW50aWZpZXIgdW5zYWZlIGNoYXJzIHRvIHNhZmUgb25lcyArID0+IF8gYW5kIC8gPT4gJFxuICAgICAgICAgICAgc3VmZml4ID0gc3VmZml4LnJlcGxhY2UobmV3IFJlZ0V4cCgnPScsICdnJyksICcnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFwrJywgJ2cnKSwgJ18nKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoJy8nLCAnZycpLCAnJCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2luZG93Ll9fY292X3NlcSA9IHdpbmRvdy5fX2Nvdl9zZXEgfHwgMDtcbiAgICAgICAgICAgIHdpbmRvdy5fX2Nvdl9zZXEgKz0gMTtcbiAgICAgICAgICAgIHN1ZmZpeCA9IHdpbmRvdy5fX2Nvdl9zZXE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdfX2Nvdl8nICsgKG9taXRTdWZmaXggPyAnJyA6IHN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaEFsbChhcnksIHRoaW5nKSB7XG4gICAgICAgIGlmICghaXNBcnJheSh0aGluZykpIHtcbiAgICAgICAgICAgIHRoaW5nID0gWyB0aGluZyBdO1xuICAgICAgICB9XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGFyeSwgdGhpbmcpO1xuICAgIH1cblxuICAgIFNZTlRBWCA9IHtcbiAgICAgICAgLy8ga2VlcCBpbiBzeW5jIHdpdGggZXN0cmF2ZXJzZSdzIFZpc2l0b3JLZXlzXG4gICAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiBbJ2xlZnQnLCAncmlnaHQnXSxcbiAgICAgICAgQXNzaWdubWVudFBhdHRlcm46IFsnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBBcnJheUV4cHJlc3Npb246IFsnZWxlbWVudHMnXSxcbiAgICAgICAgQXJyYXlQYXR0ZXJuOiBbJ2VsZW1lbnRzJ10sXG4gICAgICAgIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiBbJ3BhcmFtcycsICdib2R5J10sXG4gICAgICAgIEF3YWl0RXhwcmVzc2lvbjogWydhcmd1bWVudCddLCAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgQmxvY2tTdGF0ZW1lbnQ6IFsnYm9keSddLFxuICAgICAgICBCaW5hcnlFeHByZXNzaW9uOiBbJ2xlZnQnLCAncmlnaHQnXSxcbiAgICAgICAgQnJlYWtTdGF0ZW1lbnQ6IFsnbGFiZWwnXSxcbiAgICAgICAgQ2FsbEV4cHJlc3Npb246IFsnY2FsbGVlJywgJ2FyZ3VtZW50cyddLFxuICAgICAgICBDYXRjaENsYXVzZTogWydwYXJhbScsICdib2R5J10sXG4gICAgICAgIENsYXNzQm9keTogWydib2R5J10sXG4gICAgICAgIENsYXNzRGVjbGFyYXRpb246IFsnaWQnLCAnc3VwZXJDbGFzcycsICdib2R5J10sXG4gICAgICAgIENsYXNzRXhwcmVzc2lvbjogWydpZCcsICdzdXBlckNsYXNzJywgJ2JvZHknXSxcbiAgICAgICAgQ29tcHJlaGVuc2lvbkJsb2NrOiBbJ2xlZnQnLCAncmlnaHQnXSwgIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbjogWydibG9ja3MnLCAnZmlsdGVyJywgJ2JvZHknXSwgIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBDb25kaXRpb25hbEV4cHJlc3Npb246IFsndGVzdCcsICdjb25zZXF1ZW50JywgJ2FsdGVybmF0ZSddLFxuICAgICAgICBDb250aW51ZVN0YXRlbWVudDogWydsYWJlbCddLFxuICAgICAgICBEZWJ1Z2dlclN0YXRlbWVudDogW10sXG4gICAgICAgIERpcmVjdGl2ZVN0YXRlbWVudDogW10sXG4gICAgICAgIERvV2hpbGVTdGF0ZW1lbnQ6IFsnYm9keScsICd0ZXN0J10sXG4gICAgICAgIEVtcHR5U3RhdGVtZW50OiBbXSxcbiAgICAgICAgRXhwb3J0QWxsRGVjbGFyYXRpb246IFsnc291cmNlJ10sXG4gICAgICAgIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjogWydkZWNsYXJhdGlvbiddLFxuICAgICAgICBFeHBvcnROYW1lZERlY2xhcmF0aW9uOiBbJ2RlY2xhcmF0aW9uJywgJ3NwZWNpZmllcnMnLCAnc291cmNlJ10sXG4gICAgICAgIEV4cG9ydFNwZWNpZmllcjogWydleHBvcnRlZCcsICdsb2NhbCddLFxuICAgICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiBbJ2V4cHJlc3Npb24nXSxcbiAgICAgICAgRm9yU3RhdGVtZW50OiBbJ2luaXQnLCAndGVzdCcsICd1cGRhdGUnLCAnYm9keSddLFxuICAgICAgICBGb3JJblN0YXRlbWVudDogWydsZWZ0JywgJ3JpZ2h0JywgJ2JvZHknXSxcbiAgICAgICAgRm9yT2ZTdGF0ZW1lbnQ6IFsnbGVmdCcsICdyaWdodCcsICdib2R5J10sXG4gICAgICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246IFsnaWQnLCAncGFyYW1zJywgJ2JvZHknXSxcbiAgICAgICAgRnVuY3Rpb25FeHByZXNzaW9uOiBbJ2lkJywgJ3BhcmFtcycsICdib2R5J10sXG4gICAgICAgIEdlbmVyYXRvckV4cHJlc3Npb246IFsnYmxvY2tzJywgJ2ZpbHRlcicsICdib2R5J10sICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgSWRlbnRpZmllcjogW10sXG4gICAgICAgIElmU3RhdGVtZW50OiBbJ3Rlc3QnLCAnY29uc2VxdWVudCcsICdhbHRlcm5hdGUnXSxcbiAgICAgICAgSW1wb3J0RGVjbGFyYXRpb246IFsnc3BlY2lmaWVycycsICdzb3VyY2UnXSxcbiAgICAgICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogWydsb2NhbCddLFxuICAgICAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6IFsnbG9jYWwnXSxcbiAgICAgICAgSW1wb3J0U3BlY2lmaWVyOiBbJ2ltcG9ydGVkJywgJ2xvY2FsJ10sXG4gICAgICAgIExpdGVyYWw6IFtdLFxuICAgICAgICBMYWJlbGVkU3RhdGVtZW50OiBbJ2xhYmVsJywgJ2JvZHknXSxcbiAgICAgICAgTG9naWNhbEV4cHJlc3Npb246IFsnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBNZXRhUHJvcGVydHk6IFsnbWV0YScsICdwcm9wZXJ0eSddLFxuICAgICAgICBNZW1iZXJFeHByZXNzaW9uOiBbJ29iamVjdCcsICdwcm9wZXJ0eSddLFxuICAgICAgICBNZXRob2REZWZpbml0aW9uOiBbJ2tleScsICd2YWx1ZSddLFxuICAgICAgICBNb2R1bGVTcGVjaWZpZXI6IFtdLFxuICAgICAgICBOZXdFeHByZXNzaW9uOiBbJ2NhbGxlZScsICdhcmd1bWVudHMnXSxcbiAgICAgICAgT2JqZWN0RXhwcmVzc2lvbjogWydwcm9wZXJ0aWVzJ10sXG4gICAgICAgIE9iamVjdFBhdHRlcm46IFsncHJvcGVydGllcyddLFxuICAgICAgICBQcm9ncmFtOiBbJ2JvZHknXSxcbiAgICAgICAgUHJvcGVydHk6IFsna2V5JywgJ3ZhbHVlJ10sXG4gICAgICAgIFJlc3RFbGVtZW50OiBbICdhcmd1bWVudCcgXSxcbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFNlcXVlbmNlRXhwcmVzc2lvbjogWydleHByZXNzaW9ucyddLFxuICAgICAgICBTcHJlYWRFbGVtZW50OiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFN1cGVyOiBbXSxcbiAgICAgICAgU3dpdGNoU3RhdGVtZW50OiBbJ2Rpc2NyaW1pbmFudCcsICdjYXNlcyddLFxuICAgICAgICBTd2l0Y2hDYXNlOiBbJ3Rlc3QnLCAnY29uc2VxdWVudCddLFxuICAgICAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246IFsndGFnJywgJ3F1YXNpJ10sXG4gICAgICAgIFRlbXBsYXRlRWxlbWVudDogW10sXG4gICAgICAgIFRlbXBsYXRlTGl0ZXJhbDogWydxdWFzaXMnLCAnZXhwcmVzc2lvbnMnXSxcbiAgICAgICAgVGhpc0V4cHJlc3Npb246IFtdLFxuICAgICAgICBUaHJvd1N0YXRlbWVudDogWydhcmd1bWVudCddLFxuICAgICAgICBUcnlTdGF0ZW1lbnQ6IFsnYmxvY2snLCAnaGFuZGxlcicsICdmaW5hbGl6ZXInXSxcbiAgICAgICAgVW5hcnlFeHByZXNzaW9uOiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFVwZGF0ZUV4cHJlc3Npb246IFsnYXJndW1lbnQnXSxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogWydkZWNsYXJhdGlvbnMnXSxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdG9yOiBbJ2lkJywgJ2luaXQnXSxcbiAgICAgICAgV2hpbGVTdGF0ZW1lbnQ6IFsndGVzdCcsICdib2R5J10sXG4gICAgICAgIFdpdGhTdGF0ZW1lbnQ6IFsnb2JqZWN0JywgJ2JvZHknXSxcbiAgICAgICAgWWllbGRFeHByZXNzaW9uOiBbJ2FyZ3VtZW50J11cbiAgICB9O1xuXG4gICAgZm9yIChub2RlVHlwZSBpbiBTWU5UQVgpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IGhhcyBvd24gcHJvcGVydHkgKi9cbiAgICAgICAgaWYgKFNZTlRBWC5oYXNPd25Qcm9wZXJ0eShub2RlVHlwZSkpIHtcbiAgICAgICAgICAgIFNZTlRBWFtub2RlVHlwZV0gPSB7IG5hbWU6IG5vZGVUeXBlLCBjaGlsZHJlbjogU1lOVEFYW25vZGVUeXBlXSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN0Z2VuID0ge1xuICAgICAgICB2YXJpYWJsZTogZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHsgdHlwZTogU1lOVEFYLklkZW50aWZpZXIubmFtZSwgbmFtZTogbmFtZSB9OyB9LFxuICAgICAgICBzdHJpbmdMaXRlcmFsOiBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiB7IHR5cGU6IFNZTlRBWC5MaXRlcmFsLm5hbWUsIHZhbHVlOiBTdHJpbmcoc3RyKSB9OyB9LFxuICAgICAgICBudW1lcmljTGl0ZXJhbDogZnVuY3Rpb24gKG51bSkgeyByZXR1cm4geyB0eXBlOiBTWU5UQVguTGl0ZXJhbC5uYW1lLCB2YWx1ZTogTnVtYmVyKG51bSkgfTsgfSxcbiAgICAgICAgc3RhdGVtZW50OiBmdW5jdGlvbiAoY29udGVudHMpIHsgcmV0dXJuIHsgdHlwZTogU1lOVEFYLkV4cHJlc3Npb25TdGF0ZW1lbnQubmFtZSwgZXhwcmVzc2lvbjogY29udGVudHMgfTsgfSxcbiAgICAgICAgZG90OiBmdW5jdGlvbiAob2JqLCBmaWVsZCkgeyByZXR1cm4geyB0eXBlOiBTWU5UQVguTWVtYmVyRXhwcmVzc2lvbi5uYW1lLCBjb21wdXRlZDogZmFsc2UsIG9iamVjdDogb2JqLCBwcm9wZXJ0eTogZmllbGQgfTsgfSxcbiAgICAgICAgc3Vic2NyaXB0OiBmdW5jdGlvbiAob2JqLCBzdWIpIHsgcmV0dXJuIHsgdHlwZTogU1lOVEFYLk1lbWJlckV4cHJlc3Npb24ubmFtZSwgY29tcHV0ZWQ6IHRydWUsIG9iamVjdDogb2JqLCBwcm9wZXJ0eTogc3ViIH07IH0sXG4gICAgICAgIHBvc3RJbmNyZW1lbnQ6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHsgdHlwZTogU1lOVEFYLlVwZGF0ZUV4cHJlc3Npb24ubmFtZSwgb3BlcmF0b3I6ICcrKycsIHByZWZpeDogZmFsc2UsIGFyZ3VtZW50OiBvYmogfTsgfSxcbiAgICAgICAgc2VxdWVuY2U6IGZ1bmN0aW9uIChvbmUsIHR3bykgeyByZXR1cm4geyB0eXBlOiBTWU5UQVguU2VxdWVuY2VFeHByZXNzaW9uLm5hbWUsIGV4cHJlc3Npb25zOiBbb25lLCB0d29dIH07IH0sXG4gICAgICAgIHJldHVyblN0YXRlbWVudDogZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIHsgdHlwZTogU1lOVEFYLlJldHVyblN0YXRlbWVudC5uYW1lLCBhcmd1bWVudDogZXhwciB9OyB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFdhbGtlcih3YWxrTWFwLCBwcmVwcm9jZXNzb3IsIHNjb3BlLCBkZWJ1Zykge1xuICAgICAgICB0aGlzLndhbGtNYXAgPSB3YWxrTWFwO1xuICAgICAgICB0aGlzLnByZXByb2Nlc3NvciA9IHByZXByb2Nlc3NvcjtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgICAgICB0aGlzLmRlYnVnID0gZGVidWc7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICB0aGlzLmxldmVsID0gMDtcbiAgICAgICAgICAgIHRoaXMuc2VxID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXYWxrZXIobm9kZSwgd2Fsa2VyKSB7XG5cbiAgICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGUsXG4gICAgICAgICAgICBwcmVwcm9jZXNzb3IsXG4gICAgICAgICAgICBwb3N0cHJvY2Vzc29yLFxuICAgICAgICAgICAgY2hpbGRyZW4gPSBTWU5UQVhbdHlwZV0sXG4gICAgICAgICAgICAvLyBkb24ndCBydW4gZ2VuZXJhdGVkIG5vZGVzIHRocnUgY3VzdG9tIHdhbGtzIG90aGVyd2lzZSB3ZSB3aWxsIGF0dGVtcHQgdG8gaW5zdHJ1bWVudCB0aGUgaW5zdHJ1bWVudGF0aW9uIGNvZGUgOilcbiAgICAgICAgICAgIGFwcGx5Q3VzdG9tV2Fsa2VyID0gISFub2RlLmxvYyB8fCBub2RlLnR5cGUgPT09IFNZTlRBWC5Qcm9ncmFtLm5hbWUsXG4gICAgICAgICAgICB3YWxrZXJGbiA9IGFwcGx5Q3VzdG9tV2Fsa2VyID8gd2Fsa2VyLndhbGtNYXBbdHlwZV0gOiBudWxsLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICB3YWxrRm5JbmRleCxcbiAgICAgICAgICAgIGNoaWxkVHlwZSxcbiAgICAgICAgICAgIGNoaWxkTm9kZSxcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGNoaWxkQXJyYXksXG4gICAgICAgICAgICBjaGlsZEVsZW1lbnQsXG4gICAgICAgICAgICBwYXRoRWxlbWVudCxcbiAgICAgICAgICAgIGFzc2lnbk5vZGUsXG4gICAgICAgICAgICBpc0xhc3Q7XG5cbiAgICAgICAgaWYgKCFTWU5UQVhbdHlwZV0pIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3Iobm9kZSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbnN1cHBvcnRlZCBub2RlIHR5cGU6JyArIHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuID0gU1lOVEFYW3R5cGVdLmNoaWxkcmVuO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IGd1YXJkICovXG4gICAgICAgIGlmIChub2RlLndhbGtpbmcpIHsgdGhyb3cgbmV3IEVycm9yKCdJbmZpbml0ZSByZWdyZXNzOiBDdXN0b20gd2Fsa2VycyBtYXkgTk9UIGNhbGwgd2Fsa2VyLmFwcGx5KG5vZGUpJyk7IH1cbiAgICAgICAgbm9kZS53YWxraW5nID0gdHJ1ZTtcblxuICAgICAgICByZXQgPSB3YWxrZXIuYXBwbHkobm9kZSwgd2Fsa2VyLnByZXByb2Nlc3Nvcik7XG5cbiAgICAgICAgcHJlcHJvY2Vzc29yID0gcmV0LnByZXByb2Nlc3NvcjtcbiAgICAgICAgaWYgKHByZXByb2Nlc3Nvcikge1xuICAgICAgICAgICAgZGVsZXRlIHJldC5wcmVwcm9jZXNzb3I7XG4gICAgICAgICAgICByZXQgPSB3YWxrZXIuYXBwbHkobm9kZSwgcHJlcHJvY2Vzc29yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0FycmF5KHdhbGtlckZuKSkge1xuICAgICAgICAgICAgZm9yICh3YWxrRm5JbmRleCA9IDA7IHdhbGtGbkluZGV4IDwgd2Fsa2VyRm4ubGVuZ3RoOyB3YWxrRm5JbmRleCArPSAxKSB7XG4gICAgICAgICAgICAgICAgaXNMYXN0ID0gd2Fsa0ZuSW5kZXggPT09IHdhbGtlckZuLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgcmV0ID0gd2Fsa2VyLmFwcGx5KHJldCwgd2Fsa2VyRm5bd2Fsa0ZuSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBuZXh0OiBwYXJhbm9pZCBjaGVjayAqL1xuICAgICAgICAgICAgICAgIGlmIChyZXQudHlwZSAhPT0gdHlwZSAmJiAhaXNMYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSB0aGUgbGFzdCB3YWxrZXIgaXMgYWxsb3dlZCB0byBjaGFuZ2UgdGhlIG5vZGUgdHlwZTogW3R5cGUgd2FzOiAnICsgdHlwZSArICcgXScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh3YWxrZXJGbikge1xuICAgICAgICAgICAgICAgIHJldCA9IHdhbGtlci5hcHBseShub2RlLCB3YWxrZXJGbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5za2lwU2VsZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjaGlsZFR5cGUgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IG5vZGVbY2hpbGRUeXBlXTtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUgJiYgIWNoaWxkTm9kZS5za2lwV2Fsaykge1xuICAgICAgICAgICAgICAgIHBhdGhFbGVtZW50ID0geyBub2RlOiBub2RlLCBwcm9wZXJ0eTogY2hpbGRUeXBlIH07XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZEFycmF5ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjaGlsZE5vZGUubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkRWxlbWVudCA9IGNoaWxkTm9kZVtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhFbGVtZW50LmluZGV4ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWduTm9kZSA9IHdhbGtlci5hcHBseShjaGlsZEVsZW1lbnQsIG51bGwsIHBhdGhFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoYXNzaWduTm9kZS5wcmVwZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaEFsbChjaGlsZEFycmF5LCBhc3NpZ25Ob2RlLnByZXBlbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFzc2lnbk5vZGUucHJlcGVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ25Ob2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaEFsbChjaGlsZEFycmF5LCBhc3NpZ25Ob2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlW2NoaWxkVHlwZV0gPSBjaGlsZEFycmF5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbk5vZGUgPSB3YWxrZXIuYXBwbHkoY2hpbGROb2RlLCBudWxsLCBwYXRoRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIGlmOiBwYXJhbm9pZCBjaGVjayAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShhc3NpZ25Ob2RlLnByZXBlbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVybmFsIGVycm9yOiBhdHRlbXB0IHRvIHByZXBlbmQgc3RhdGVtZW50cyBpbiBkaXNhbGxvd2VkIChub24tYXJyYXkpIGNvbnRleHQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlmIHRoaXMgc2hvdWxkIGJlIGFsbG93ZWQsIHRoaXMgaXMgaG93IHRvIHNvbHZlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXBOb2RlID0geyB0eXBlOiAnQmxvY2tTdGF0ZW1lbnQnLCBib2R5OiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaEFsbCh0bXBOb2RlLmJvZHksIGFzc2lnbk5vZGUucHJlcGVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoQWxsKHRtcE5vZGUuYm9keSwgYXNzaWduTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlW2NoaWxkVHlwZV0gPSB0bXBOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFzc2lnbk5vZGUucHJlcGVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlW2NoaWxkVHlwZV0gPSBhc3NpZ25Ob2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcG9zdHByb2Nlc3NvciA9IHJldC5wb3N0cHJvY2Vzc29yO1xuICAgICAgICBpZiAocG9zdHByb2Nlc3Nvcikge1xuICAgICAgICAgICAgZGVsZXRlIHJldC5wb3N0cHJvY2Vzc29yO1xuICAgICAgICAgICAgcmV0ID0gd2Fsa2VyLmFwcGx5KHJldCwgcG9zdHByb2Nlc3Nvcik7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgbm9kZS53YWxraW5nO1xuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgV2Fsa2VyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgc3RhcnRXYWxrOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gW107XG4gICAgICAgICAgICB0aGlzLmFwcGx5KG5vZGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbiAobm9kZSwgd2Fsa0ZuLCBwYXRoRWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHJldCwgaSwgc2VxLCBwcmVmaXg7XG5cbiAgICAgICAgICAgIHdhbGtGbiA9IHdhbGtGbiB8fCBkZWZhdWx0V2Fsa2VyO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcSArPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMubGV2ZWwgKz0gMTtcbiAgICAgICAgICAgICAgICBzZXEgPSB0aGlzLnNlcTtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZXZlbDsgaSArPSAxKSB7IHByZWZpeCArPSAnICAgICc7IH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhwcmVmaXggKyAnRW50ZXIgKCcgKyBzZXEgKyAnKTonICsgbm9kZS50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRoRWxlbWVudCkgeyB0aGlzLnBhdGgucHVzaChwYXRoRWxlbWVudCk7IH1cbiAgICAgICAgICAgIHJldCA9IHdhbGtGbi5jYWxsKHRoaXMuc2NvcGUsIG5vZGUsIHRoaXMpO1xuICAgICAgICAgICAgaWYgKHBhdGhFbGVtZW50KSB7IHRoaXMucGF0aC5wb3AoKTsgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxldmVsIC09IDE7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocHJlZml4ICsgJ1JldHVybiAoJyArIHNlcSArICcpOicgKyBub2RlLnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldCB8fCBub2RlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXJ0TGluZUZvck5vZGU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZSAmJiBub2RlLmxvYyAmJiBub2RlLmxvYy5zdGFydCA/IG5vZGUubG9jLnN0YXJ0LmxpbmUgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZ3VhcmQgKi8gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBhbmNlc3RvcjogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGgubGVuZ3RoID4gbiAtIDEgPyB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIG5dIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGd1YXJkICovIG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmNlc3RvcigxKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0xhYmVsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMucGFyZW50KCk7XG4gICAgICAgICAgICByZXR1cm4gZWwgJiYgZWwubm9kZS50eXBlID09PSBTWU5UQVguTGFiZWxlZFN0YXRlbWVudC5uYW1lO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIG1lY2hhbmlzbSB0byBpbnN0cnVtZW50IGNvZGUgZm9yIGNvdmVyYWdlLiBJdCB1c2VzIHRoZSBgZXNwcmltYWAgYW5kXG4gICAgICogYGVzY29kZWdlbmAgbGlicmFyaWVzIGZvciBKUyBwYXJzaW5nIGFuZCBjb2RlIGdlbmVyYXRpb24gcmVzcGVjdGl2ZWx5LlxuICAgICAqXG4gICAgICogV29ya3Mgb24gYG5vZGVgIGFzIHdlbGwgYXMgdGhlIGJyb3dzZXIuXG4gICAgICpcbiAgICAgKiBVc2FnZSBvbiBub2RlanNcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS1cbiAgICAgKlxuICAgICAqICAgICAgdmFyIGluc3RydW1lbnRlciA9IG5ldyByZXF1aXJlKCdpc3RhbmJ1bCcpLkluc3RydW1lbnRlcigpLFxuICAgICAqICAgICAgICAgIGNoYW5nZWQgPSBpbnN0cnVtZW50ZXIuaW5zdHJ1bWVudFN5bmMoJ2Z1bmN0aW9uIG1lYW5pbmdPZkxpZmUoKSB7IHJldHVybiA0MjsgfScsICdmaWxlbmFtZS5qcycpO1xuICAgICAqXG4gICAgICogVXNhZ2UgaW4gYSBicm93c2VyXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICpcbiAgICAgKiBMb2FkIGBlc3ByaW1hLmpzYCwgYGVzY29kZWdlbi5qc2AgYW5kIGBpbnN0cnVtZW50ZXIuanNgICh0aGlzIGZpbGUpIHVzaW5nIGBzY3JpcHRgIHRhZ3Mgb3Igb3RoZXIgbWVhbnMuXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYW4gaW5zdHJ1bWVudGVyIG9iamVjdCBhczpcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGluc3RydW1lbnRlciA9IG5ldyBJbnN0cnVtZW50ZXIoKSxcbiAgICAgKiAgICAgICAgICBjaGFuZ2VkID0gaW5zdHJ1bWVudGVyLmluc3RydW1lbnRTeW5jKCdmdW5jdGlvbiBtZWFuaW5nT2ZMaWZlKCkgeyByZXR1cm4gNDI7IH0nLCAnZmlsZW5hbWUuanMnKTtcbiAgICAgKlxuICAgICAqIEFzaWRlIGZyb20gZGVtb25zdHJhdGlvbiBwdXJwb3NlcywgaXQgaXMgdW5jbGVhciB3aHkgeW91IHdvdWxkIHdhbnQgdG8gaW5zdHJ1bWVudCBjb2RlIGluIGEgYnJvd3Nlci5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBJbnN0cnVtZW50ZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25hbC4gQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jb3ZlcmFnZVZhcmlhYmxlXSB0aGUgZ2xvYmFsIHZhcmlhYmxlIG5hbWUgdG8gdXNlIGZvclxuICAgICAqICAgICAgdHJhY2tpbmcgY292ZXJhZ2UuIERlZmF1bHRzIHRvIGBfX2NvdmVyYWdlX19gXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5lbWJlZFNvdXJjZV0gd2hldGhlciB0byBlbWJlZCB0aGUgc291cmNlIGNvZGUgb2YgZXZlcnlcbiAgICAgKiAgICAgIGZpbGUgYXMgYW4gYXJyYXkgaW4gdGhlIGZpbGUgY292ZXJhZ2Ugb2JqZWN0IGZvciB0aGF0IGZpbGUuIERlZmF1bHRzIHRvIGBmYWxzZWBcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnByZXNlcnZlQ29tbWVudHNdIHdoZXRoZXIgY29tbWVudHMgc2hvdWxkIGJlIHByZXNlcnZlZCBpbiB0aGUgb3V0cHV0LiBEZWZhdWx0cyB0byBgZmFsc2VgXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub0NvbXBhY3RdIGVtaXQgcmVhZGFibGUgY29kZSB3aGVuIHNldC4gRGVmYXVsdHMgdG8gYGZhbHNlYFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZXNNb2R1bGVzXSB3aGV0aGVyIHRoZSBjb2RlIHRvIGluc3RydW1lbnQgY29udGFpbnMgdXNlcyBlc1xuICAgICAqICAgICAgaW1wb3J0cyBvciBleHBvcnRzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubm9BdXRvV3JhcF0gZG8gbm90IGF1dG9tYXRpY2FsbHkgd3JhcCB0aGUgc291cmNlIGluXG4gICAgICogICAgICBhbiBhbm9ueW1vdXMgZnVuY3Rpb24gYmVmb3JlIGNvdmVyaW5nIGl0LiBCeSBkZWZhdWx0LCBjb2RlIGlzIHdyYXBwZWQgaW5cbiAgICAgKiAgICAgIGFuIGFub255bW91cyBmdW5jdGlvbiBiZWZvcmUgaXQgaXMgcGFyc2VkLiBUaGlzIGlzIGRvbmUgYmVjYXVzZVxuICAgICAqICAgICAgc29tZSBub2RlanMgbGlicmFyaWVzIGhhdmUgYHJldHVybmAgc3RhdGVtZW50cyBvdXRzaWRlIG9mXG4gICAgICogICAgICBhIGZ1bmN0aW9uIHdoaWNoIGlzIHRlY2huaWNhbGx5IGludmFsaWQgSmF2YXNjcmlwdCBhbmQgY2F1c2VzIHRoZSBwYXJzZXIgdG8gZmFpbC5cbiAgICAgKiAgICAgIFRoaXMgY29uc3RydWN0LCBob3dldmVyLCB3b3JrcyBjb3JyZWN0bHkgaW4gbm9kZSBzaW5jZSBtb2R1bGUgbG9hZGluZ1xuICAgICAqICAgICAgaXMgZG9uZSBpbiB0aGUgY29udGV4dCBvZiBhbiBhbm9ueW1vdXMgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlIHNlbWFudGljcyBvZiB0aGUgY29kZSAqcmV0dXJuZWQqIGJ5IHRoZSBpbnN0cnVtZW50ZXIgZG9lcyBub3QgY2hhbmdlIGluIGFueSB3YXkuXG4gICAgICogVGhlIGZ1bmN0aW9uIHdyYXBwZXIgaXMgXCJ1bndyYXBwZWRcIiBiZWZvcmUgdGhlIGluc3RydW1lbnRlZCBjb2RlIGlzIGdlbmVyYXRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY29kZUdlbmVyYXRpb25PcHRpb25zXSBhbiBvYmplY3QgdGhhdCBpcyBkaXJlY3RseSBwYXNzZWQgdG8gdGhlIGBlc2NvZGVnZW5gXG4gICAgICogICAgICBsaWJyYXJ5IGFzIGNvbmZpZ3VyYXRpb24gZm9yIGNvZGUgZ2VuZXJhdGlvbi4gVGhlIGBub0NvbXBhY3RgIHNldHRpbmcgaXMgbm90IGhvbm9yZWQgd2hlbiB0aGlzXG4gICAgICogICAgICBvcHRpb24gaXMgc3BlY2lmaWVkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kZWJ1Z10gYXNzaXN0IGluIGRlYnVnZ2luZy4gQ3VycmVudGx5LCB0aGUgb25seSBlZmZlY3Qgb2ZcbiAgICAgKiAgICAgIHNldHRpbmcgdGhpcyBvcHRpb24gaXMgYSBwcmV0dHktcHJpbnQgb2YgdGhlIGNvdmVyYWdlIHZhcmlhYmxlLiBEZWZhdWx0cyB0byBgZmFsc2VgXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53YWxrRGVidWddIGFzc2lzdCBpbiBkZWJ1Z2dpbmcgb2YgdGhlIEFTVCB3YWxrZXIgdXNlZCBieSB0aGlzIGNsYXNzLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW5zdHJ1bWVudGVyKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0aW9ucyB8fCB7XG4gICAgICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICAgICAgICB3YWxrRGVidWc6IGZhbHNlLFxuICAgICAgICAgICAgY292ZXJhZ2VWYXJpYWJsZTogJ19fY292ZXJhZ2VfXycsXG4gICAgICAgICAgICBjb2RlR2VuZXJhdGlvbk9wdGlvbnM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG5vQXV0b1dyYXA6IGZhbHNlLFxuICAgICAgICAgICAgbm9Db21wYWN0OiBmYWxzZSxcbiAgICAgICAgICAgIGVtYmVkU291cmNlOiBmYWxzZSxcbiAgICAgICAgICAgIHByZXNlcnZlQ29tbWVudHM6IGZhbHNlLFxuICAgICAgICAgICAgZXNNb2R1bGVzOiBmYWxzZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLm9wdHMuZXNNb2R1bGVzICYmICF0aGlzLm9wdHMubm9BdXRvV3JhcCkge1xuICAgICAgICAgICAgdGhpcy5vcHRzLm5vQXV0b1dyYXAgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTZXR0aW5nIG5vQXV0b1dyYXAgdG8gdHJ1ZSBhcyByZXF1aXJlZCBieSBlc01vZHVsZXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMud2Fsa2VyID0gbmV3IFdhbGtlcih7XG4gICAgICAgICAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogWyB0aGlzLmFycm93QmxvY2tDb252ZXJ0ZXIgXSxcbiAgICAgICAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6IHRoaXMuY292ZXJTdGF0ZW1lbnQsXG4gICAgICAgICAgICBFeHBvcnROYW1lZERlY2xhcmF0aW9uOiB0aGlzLmNvdmVyRXhwb3J0LFxuICAgICAgICAgICAgQnJlYWtTdGF0ZW1lbnQ6IHRoaXMuY292ZXJTdGF0ZW1lbnQsXG4gICAgICAgICAgICBDb250aW51ZVN0YXRlbWVudDogdGhpcy5jb3ZlclN0YXRlbWVudCxcbiAgICAgICAgICAgIERlYnVnZ2VyU3RhdGVtZW50OiB0aGlzLmNvdmVyU3RhdGVtZW50LFxuICAgICAgICAgICAgUmV0dXJuU3RhdGVtZW50OiB0aGlzLmNvdmVyU3RhdGVtZW50LFxuICAgICAgICAgICAgVGhyb3dTdGF0ZW1lbnQ6IHRoaXMuY292ZXJTdGF0ZW1lbnQsXG4gICAgICAgICAgICBUcnlTdGF0ZW1lbnQ6IFsgdGhpcy5wYXJhbm9pZEhhbmRsZXJDaGVjaywgdGhpcy5jb3ZlclN0YXRlbWVudF0sXG4gICAgICAgICAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiB0aGlzLmNvdmVyU3RhdGVtZW50LFxuICAgICAgICAgICAgSWZTdGF0ZW1lbnQ6IFsgdGhpcy5pZkJsb2NrQ29udmVydGVyLCB0aGlzLmNvdmVyU3RhdGVtZW50LCB0aGlzLmlmQnJhbmNoSW5qZWN0b3IgXSxcbiAgICAgICAgICAgIEZvclN0YXRlbWVudDogWyB0aGlzLnNraXBJbml0LCB0aGlzLmxvb3BCbG9ja0NvbnZlcnRlciwgdGhpcy5jb3ZlclN0YXRlbWVudCBdLFxuICAgICAgICAgICAgRm9ySW5TdGF0ZW1lbnQ6IFsgdGhpcy5za2lwTGVmdCwgdGhpcy5sb29wQmxvY2tDb252ZXJ0ZXIsIHRoaXMuY292ZXJTdGF0ZW1lbnQgXSxcbiAgICAgICAgICAgIEZvck9mU3RhdGVtZW50OiBbIHRoaXMuc2tpcExlZnQsIHRoaXMubG9vcEJsb2NrQ29udmVydGVyLCB0aGlzLmNvdmVyU3RhdGVtZW50IF0sXG4gICAgICAgICAgICBXaGlsZVN0YXRlbWVudDogWyB0aGlzLmxvb3BCbG9ja0NvbnZlcnRlciwgdGhpcy5jb3ZlclN0YXRlbWVudCBdLFxuICAgICAgICAgICAgRG9XaGlsZVN0YXRlbWVudDogWyB0aGlzLmxvb3BCbG9ja0NvbnZlcnRlciwgdGhpcy5jb3ZlclN0YXRlbWVudCBdLFxuICAgICAgICAgICAgU3dpdGNoU3RhdGVtZW50OiBbIHRoaXMuY292ZXJTdGF0ZW1lbnQsIHRoaXMuc3dpdGNoQnJhbmNoSW5qZWN0b3IgXSxcbiAgICAgICAgICAgIFN3aXRjaENhc2U6IFsgdGhpcy5zd2l0Y2hDYXNlSW5qZWN0b3IgXSxcbiAgICAgICAgICAgIFdpdGhTdGF0ZW1lbnQ6IFsgdGhpcy53aXRoQmxvY2tDb252ZXJ0ZXIsIHRoaXMuY292ZXJTdGF0ZW1lbnQgXSxcbiAgICAgICAgICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246IFsgdGhpcy5jb3ZlckZ1bmN0aW9uLCB0aGlzLmNvdmVyU3RhdGVtZW50IF0sXG4gICAgICAgICAgICBGdW5jdGlvbkV4cHJlc3Npb246IHRoaXMuY292ZXJGdW5jdGlvbixcbiAgICAgICAgICAgIExhYmVsZWRTdGF0ZW1lbnQ6IHRoaXMuY292ZXJTdGF0ZW1lbnQsXG4gICAgICAgICAgICBDb25kaXRpb25hbEV4cHJlc3Npb246IHRoaXMuY29uZGl0aW9uYWxCcmFuY2hJbmplY3RvcixcbiAgICAgICAgICAgIExvZ2ljYWxFeHByZXNzaW9uOiB0aGlzLmxvZ2ljYWxFeHByZXNzaW9uQnJhbmNoSW5qZWN0b3IsXG4gICAgICAgICAgICBPYmplY3RFeHByZXNzaW9uOiB0aGlzLm1heWJlQWRkVHlwZSxcbiAgICAgICAgICAgIE1ldGFQcm9wZXJ0eTogdGhpcy5jb3Zlck1ldGFQcm9wZXJ0eSxcbiAgICAgICAgfSwgdGhpcy5leHRyYWN0Q3VycmVudEhpbnQsIHRoaXMsIHRoaXMub3B0cy53YWxrRGVidWcpO1xuXG4gICAgICAgIC8vdW5pdCB0ZXN0aW5nIHB1cnBvc2VzIG9ubHlcbiAgICAgICAgaWYgKHRoaXMub3B0cy5iYWNrZG9vciAmJiB0aGlzLm9wdHMuYmFja2Rvb3Iub21pdFRyYWNrZXJTdWZmaXgpIHtcbiAgICAgICAgICAgIHRoaXMub21pdFRyYWNrZXJTdWZmaXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgSW5zdHJ1bWVudGVyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHN5bmNocm9ub3VzIGluc3RydW1lbnRhdGlvbiBtZXRob2QuIFRocm93cyB3aGVuIGlsbGVnYWwgY29kZSBpcyBwYXNzZWQgdG8gaXRcbiAgICAgICAgICogQG1ldGhvZCBpbnN0cnVtZW50U3luY1xuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29kZSB0aGUgY29kZSB0byBiZSBpbnN0cnVtZW50ZWQgYXMgYSBTdHJpbmdcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lIE9wdGlvbmFsLiBUaGUgbmFtZSBvZiB0aGUgZmlsZSBmcm9tIHdoaWNoXG4gICAgICAgICAqICB0aGUgY29kZSB3YXMgcmVhZC4gQSB0ZW1wb3JhcnkgZmlsZW5hbWUgaXMgZ2VuZXJhdGVkIHdoZW4gbm90IHNwZWNpZmllZC5cbiAgICAgICAgICogIE5vdCBzcGVjaWZ5aW5nIGEgZmlsZW5hbWUgaXMgb25seSB1c2VmdWwgZm9yIHVuaXQgdGVzdHMgYW5kIGRlbW9uc3RyYXRpb25zXG4gICAgICAgICAqICBvZiB0aGlzIGxpYnJhcnkuXG4gICAgICAgICAqL1xuICAgICAgICBpbnN0cnVtZW50U3luYzogZnVuY3Rpb24gKGNvZGUsIGZpbGVuYW1lKSB7XG4gICAgICAgICAgICB2YXIgcHJvZ3JhbTtcblxuICAgICAgICAgICAgLy9wcm90ZWN0IGZyb20gdXNlcnMgYWNjaWRlbnRhbGx5IHBhc3NpbmcgaW4gYSBCdWZmZXIgb2JqZWN0IGluc3RlYWRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29kZSAhPT0gJ3N0cmluZycpIHsgdGhyb3cgbmV3IEVycm9yKCdDb2RlIG11c3QgYmUgc3RyaW5nJyk7IH1cbiAgICAgICAgICAgIGlmIChjb2RlLmNoYXJBdCgwKSA9PT0gJyMnKSB7IC8vc2hlYmFuZywgJ2NvbW1lbnQnIGl0IG91dCwgd29uJ3QgYWZmZWN0IHN5bnRheCB0cmVlIGxvY2F0aW9ucyBmb3IgdGhpbmdzIHdlIGNhcmUgYWJvdXRcbiAgICAgICAgICAgICAgICBjb2RlID0gJy8vJyArIGNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0cy5ub0F1dG9XcmFwKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IExFQURFUl9XUkFQICsgY29kZSArIFRSQUlMRVJfV1JBUDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbSA9IEVTUC5wYXJzZShjb2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIGxvYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5vcHRzLnByZXNlcnZlQ29tbWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVR5cGU6IHRoaXMub3B0cy5lc01vZHVsZXMgPyAnbW9kdWxlJyA6ICdzY3JpcHQnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCB0byBwYXJzZSBmaWxlOiAnICsgZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnByZXNlcnZlQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmFtID0gRVNQR0VOLmF0dGFjaENvbW1lbnRzKHByb2dyYW0sIHByb2dyYW0uY29tbWVudHMsIHByb2dyYW0udG9rZW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRzLm5vQXV0b1dyYXApIHtcbiAgICAgICAgICAgICAgICBwcm9ncmFtID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTWU5UQVguUHJvZ3JhbS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBwcm9ncmFtLmJvZHlbMF0uZXhwcmVzc2lvbi5jYWxsZWUuYm9keS5ib2R5LFxuICAgICAgICAgICAgICAgICAgICBjb21tZW50czogcHJvZ3JhbS5jb21tZW50c1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnN0cnVtZW50QVNUU3luYyhwcm9ncmFtLCBmaWxlbmFtZSwgY29kZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbHRlckhpbnRzOiBmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBbXSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQsXG4gICAgICAgICAgICAgICAgZ3JvdXBzO1xuICAgICAgICAgICAgaWYgKCEoY29tbWVudHMgJiYgaXNBcnJheShjb21tZW50cykpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21tZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBjb21tZW50c1tpXTtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogcGFyYW5vaWQgY2hlY2sgKi9cbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudCAmJiBjb21tZW50LnZhbHVlICYmIGNvbW1lbnQucmFuZ2UgJiYgaXNBcnJheShjb21tZW50LnJhbmdlKSkge1xuICAgICAgICAgICAgICAgICAgICBncm91cHMgPSBTdHJpbmcoY29tbWVudC52YWx1ZSkubWF0Y2goQ09NTUVOVF9SRSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChncm91cHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKHsgdHlwZTogZ3JvdXBzWzFdLCBzdGFydDogY29tbWVudC5yYW5nZVswXSwgZW5kOiBjb21tZW50LnJhbmdlWzFdIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcbiAgICAgICAgZXh0cmFjdEN1cnJlbnRIaW50OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKCFub2RlLnJhbmdlKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmN1cnJlbnRTdGF0ZS5sYXN0SGludFBvc2l0aW9uICsgMSxcbiAgICAgICAgICAgICAgICBoaW50cyA9IHRoaXMuY3VycmVudFN0YXRlLmhpbnRzLFxuICAgICAgICAgICAgICAgIG5vZGVTdGFydCA9IG5vZGUucmFuZ2VbMF0sXG4gICAgICAgICAgICAgICAgaGludDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRlLmN1cnJlbnRIaW50ID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgaGludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaGludCA9IGhpbnRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChoaW50LmVuZCA8IG5vZGVTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZS5jdXJyZW50SGludCA9IGhpbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRlLmxhc3RIaW50UG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogc3luY2hyb25vdXMgaW5zdHJ1bWVudGF0aW9uIG1ldGhvZCB0aGF0IGluc3RydW1lbnRzIGFuIEFTVCBpbnN0ZWFkLlxuICAgICAgICAgKiBAbWV0aG9kIGluc3RydW1lbnRBU1RTeW5jXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9ncmFtIHRoZSBBU1QgdG8gYmUgaW5zdHJ1bWVudGVkXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZSBPcHRpb25hbC4gVGhlIG5hbWUgb2YgdGhlIGZpbGUgZnJvbSB3aGljaFxuICAgICAgICAgKiAgdGhlIGNvZGUgd2FzIHJlYWQuIEEgdGVtcG9yYXJ5IGZpbGVuYW1lIGlzIGdlbmVyYXRlZCB3aGVuIG5vdCBzcGVjaWZpZWQuXG4gICAgICAgICAqICBOb3Qgc3BlY2lmeWluZyBhIGZpbGVuYW1lIGlzIG9ubHkgdXNlZnVsIGZvciB1bml0IHRlc3RzIGFuZCBkZW1vbnN0cmF0aW9uc1xuICAgICAgICAgKiAgb2YgdGhpcyBsaWJyYXJ5LlxuICAgICAgICAgKiAgQHBhcmFtIHtTdHJpbmd9IG9yaWdpbmFsQ29kZSB0aGUgb3JpZ2luYWwgY29kZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBBU1QsXG4gICAgICAgICAqICB1c2VkIGZvciBlbWJlZGRpbmcgdGhlIHNvdXJjZSBpbnRvIHRoZSBjb3ZlcmFnZSBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIGluc3RydW1lbnRBU1RTeW5jOiBmdW5jdGlvbiAocHJvZ3JhbSwgZmlsZW5hbWUsIG9yaWdpbmFsQ29kZSkge1xuICAgICAgICAgICAgdmFyIHVzaW5nU3RyaWN0ID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgY29kZWdlbk9wdGlvbnMsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVkLFxuICAgICAgICAgICAgICAgIHByZWFtYmxlLFxuICAgICAgICAgICAgICAgIGxpbmVDb3VudCxcbiAgICAgICAgICAgICAgICBpO1xuICAgICAgICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZSB8fCBTdHJpbmcobmV3IERhdGUoKS5nZXRUaW1lKCkpICsgJy5qcyc7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZU1hcCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNvdmVyU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgcGF0aDogZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgczoge30sXG4gICAgICAgICAgICAgICAgYjoge30sXG4gICAgICAgICAgICAgICAgZjoge30sXG4gICAgICAgICAgICAgICAgZm5NYXA6IHt9LFxuICAgICAgICAgICAgICAgIHN0YXRlbWVudE1hcDoge30sXG4gICAgICAgICAgICAgICAgYnJhbmNoTWFwOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0ge1xuICAgICAgICAgICAgICAgIHRyYWNrZXJWYXI6IGdlbmVyYXRlVHJhY2tlclZhcihmaWxlbmFtZSwgdGhpcy5vbWl0VHJhY2tlclN1ZmZpeCksXG4gICAgICAgICAgICAgICAgZnVuYzogMCxcbiAgICAgICAgICAgICAgICBicmFuY2g6IDAsXG4gICAgICAgICAgICAgICAgdmFyaWFibGU6IDAsXG4gICAgICAgICAgICAgICAgc3RhdGVtZW50OiAwLFxuICAgICAgICAgICAgICAgIGhpbnRzOiB0aGlzLmZpbHRlckhpbnRzKHByb2dyYW0uY29tbWVudHMpLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRIaW50OiBudWxsLFxuICAgICAgICAgICAgICAgIGxhc3RIaW50UG9zaXRpb246IC0xLFxuICAgICAgICAgICAgICAgIGlnbm9yaW5nOiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHByb2dyYW0uYm9keSAmJiBwcm9ncmFtLmJvZHkubGVuZ3RoID4gMCAmJiB0aGlzLmlzVXNlU3RyaWN0RXhwcmVzc2lvbihwcm9ncmFtLmJvZHlbMF0pKSB7XG4gICAgICAgICAgICAgICAgLy9udWtlIGl0XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS5ib2R5LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgLy9hbmQgYWRkIGl0IGJhY2sgYXQgY29kZSBnZW5lcmF0aW9uIHRpbWVcbiAgICAgICAgICAgICAgICB1c2luZ1N0cmljdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndhbGtlci5zdGFydFdhbGsocHJvZ3JhbSk7XG4gICAgICAgICAgICBjb2RlZ2VuT3B0aW9ucyA9IHRoaXMub3B0cy5jb2RlR2VuZXJhdGlvbk9wdGlvbnMgfHwgeyBmb3JtYXQ6IHsgY29tcGFjdDogIXRoaXMub3B0cy5ub0NvbXBhY3QgfX07XG4gICAgICAgICAgICBjb2RlZ2VuT3B0aW9ucy5jb21tZW50ID0gdGhpcy5vcHRzLnByZXNlcnZlQ29tbWVudHM7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHByb2dyYW0sIHVuZGVmaW5lZCwgMikpO1xuXG4gICAgICAgICAgICBnZW5lcmF0ZWQgPSBFU1BHRU4uZ2VuZXJhdGUocHJvZ3JhbSwgY29kZWdlbk9wdGlvbnMpO1xuICAgICAgICAgICAgcHJlYW1ibGUgPSB0aGlzLmdldFByZWFtYmxlKG9yaWdpbmFsQ29kZSB8fCAnJywgdXNpbmdTdHJpY3QpO1xuXG4gICAgICAgICAgICBpZiAoZ2VuZXJhdGVkLm1hcCAmJiBnZW5lcmF0ZWQuY29kZSkge1xuICAgICAgICAgICAgICAgIGxpbmVDb3VudCA9IHByZWFtYmxlLnNwbGl0KC9cXHJcXG58XFxyfFxcbi8pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBvZmZzZXQgYWxsIHRoZSBnZW5lcmF0ZWQgbGluZSBudW1iZXJzIGJ5IHRoZSBudW1iZXIgb2YgbGluZXMgaW4gdGhlIHByZWFtYmxlXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGdlbmVyYXRlZC5tYXAuX21hcHBpbmdzLl9hcnJheS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWQubWFwLl9tYXBwaW5ncy5fYXJyYXlbaV0uZ2VuZXJhdGVkTGluZSArPSBsaW5lQ291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlTWFwID0gZ2VuZXJhdGVkLm1hcDtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZWQgPSBnZW5lcmF0ZWQuY29kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHByZWFtYmxlICsgJ1xcbicgKyBnZW5lcmF0ZWQgKyAnXFxuJztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIGJhc2VkIGluc3RydW1lbnRhdGlvbi4gTm90ZSB0aGF0IHRoaXMgc3RpbGwgZXhlY3V0ZXMgc3luY2hyb25vdXNseSBpbiB0aGUgc2FtZSBwcm9jZXNzIHRpY2tcbiAgICAgICAgICogYW5kIGNhbGxzIGJhY2sgaW1tZWRpYXRlbHkuIEl0IG9ubHkgcHJvdmlkZXMgdGhlIG9wdGlvbnMgZm9yIGNhbGxiYWNrIHN0eWxlIGVycm9yIGhhbmRsaW5nIGFzXG4gICAgICAgICAqIG9wcG9zZWQgdG8gYSBgdHJ5LWNhdGNoYCBzdHlsZSBhbmQgbm90aGluZyBtb3JlLiBJbXBsZW1lbnRlZCBhcyBhIHdyYXBwZXIgb3ZlciBgaW5zdHJ1bWVudFN5bmNgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgaW5zdHJ1bWVudFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29kZSB0aGUgY29kZSB0byBiZSBpbnN0cnVtZW50ZWQgYXMgYSBTdHJpbmdcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lIE9wdGlvbmFsLiBUaGUgbmFtZSBvZiB0aGUgZmlsZSBmcm9tIHdoaWNoXG4gICAgICAgICAqICB0aGUgY29kZSB3YXMgcmVhZC4gQSB0ZW1wb3JhcnkgZmlsZW5hbWUgaXMgZ2VuZXJhdGVkIHdoZW4gbm90IHNwZWNpZmllZC5cbiAgICAgICAgICogIE5vdCBzcGVjaWZ5aW5nIGEgZmlsZW5hbWUgaXMgb25seSB1c2VmdWwgZm9yIHVuaXQgdGVzdHMgYW5kIGRlbW9uc3RyYXRpb25zXG4gICAgICAgICAqICBvZiB0aGlzIGxpYnJhcnkuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb24oZXJyLCBpbnN0cnVtZW50ZWRDb2RlKX0gY2FsbGJhY2sgLSB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIGluc3RydW1lbnQ6IGZ1bmN0aW9uIChjb2RlLCBmaWxlbmFtZSwgY2FsbGJhY2spIHtcblxuICAgICAgICAgICAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2YgZmlsZW5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZpbGVuYW1lO1xuICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdGhpcy5pbnN0cnVtZW50U3luYyhjb2RlLCBmaWxlbmFtZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXR1cm5zIHRoZSBmaWxlIGNvdmVyYWdlIG9iamVjdCBmb3IgdGhlIGNvZGUgdGhhdCB3YXMgaW5zdHJ1bWVudGVkXG4gICAgICAgICAqIGp1c3QgYmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QuIE5vdGUgdGhhdCB0aGlzIHJlcHJlc2VudHMgYVxuICAgICAgICAgKiBcInplcm8tY292ZXJhZ2VcIiBvYmplY3Qgd2hpY2ggaXMgbm90IGV2ZW4gcmVwcmVzZW50YXRpdmUgb2YgdGhlIGNvZGVcbiAgICAgICAgICogYmVpbmcgbG9hZGVkIGluIG5vZGUgb3IgYSBicm93c2VyICh3aGljaCB3b3VsZCBpbmNyZWFzZSB0aGUgc3RhdGVtZW50XG4gICAgICAgICAqIGNvdW50cyBmb3IgbWFpbmxpbmUgY29kZSkuXG4gICAgICAgICAqIEBtZXRob2QgbGFzdEZpbGVDb3ZlcmFnZVxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGEgXCJ6ZXJvLWNvdmVyYWdlXCIgZmlsZSBjb3ZlcmFnZSBvYmplY3QgZm9yIHRoZSBjb2RlIGxhc3QgaW5zdHJ1bWVudGVkXG4gICAgICAgICAqIGJ5IHRoaXMgaW5zdHJ1bWVudGVyXG4gICAgICAgICAqL1xuICAgICAgICBsYXN0RmlsZUNvdmVyYWdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3ZlclN0YXRlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJucyB0aGUgc291cmNlIG1hcCBvYmplY3QgZm9yIHRoZSBjb2RlIHRoYXQgd2FzIGluc3RydW1lbnRlZFxuICAgICAgICAgKiBqdXN0IGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLlxuICAgICAgICAgKiBAbWV0aG9kIGxhc3RTb3VyY2VNYXBcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBhIHNvdXJjZSBtYXAgb2JqZWN0IGZvciB0aGUgY29kZSBsYXN0IGluc3RydW1lbnRlZFxuICAgICAgICAgKiBieSB0aGlzIGluc3RydW1lbnRlclxuICAgICAgICAgKi9cbiAgICAgICAgbGFzdFNvdXJjZU1hcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlTWFwO1xuICAgICAgICB9LFxuICAgICAgICBmaXhDb2x1bW5Qb3NpdGlvbnM6IGZ1bmN0aW9uIChjb3ZlclN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gTEVBREVSX1dSQVAubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGZpeGVyID0gZnVuY3Rpb24gKGxvYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jLnN0YXJ0LmxpbmUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5zdGFydC5jb2x1bW4gLT0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2MuZW5kLmxpbmUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5lbmQuY29sdW1uIC09IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgayxcbiAgICAgICAgICAgICAgICBvYmosXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbnM7XG5cbiAgICAgICAgICAgIG9iaiA9IGNvdmVyU3RhdGUuc3RhdGVtZW50TWFwO1xuICAgICAgICAgICAgZm9yIChrIGluIG9iaikge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBoYXMgb3duIHByb3BlcnR5ICovXG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkgeyBmaXhlcihvYmpba10pOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmogPSBjb3ZlclN0YXRlLmZuTWFwO1xuICAgICAgICAgICAgZm9yIChrIGluIG9iaikge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBoYXMgb3duIHByb3BlcnR5ICovXG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkgeyBmaXhlcihvYmpba10ubG9jKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqID0gY292ZXJTdGF0ZS5icmFuY2hNYXA7XG4gICAgICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IGhhcyBvd24gcHJvcGVydHkgKi9cbiAgICAgICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9ucyA9IG9ialtrXS5sb2NhdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsb2NhdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpeGVyKGxvY2F0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0UHJlYW1ibGU6IGZ1bmN0aW9uIChzb3VyY2VDb2RlLCBlbWl0VXNlU3RyaWN0KSB7XG4gICAgICAgICAgICB2YXIgdmFyTmFtZSA9IHRoaXMub3B0cy5jb3ZlcmFnZVZhcmlhYmxlIHx8ICdfX2NvdmVyYWdlX18nLFxuICAgICAgICAgICAgICAgIGZpbGUgPSB0aGlzLmNvdmVyU3RhdGUucGF0aC5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpLFxuICAgICAgICAgICAgICAgIHRyYWNrZXIgPSB0aGlzLmN1cnJlbnRTdGF0ZS50cmFja2VyVmFyLFxuICAgICAgICAgICAgICAgIGNvdmVyU3RhdGUsXG4gICAgICAgICAgICAgICAgc3RyaWN0TGluZSA9IGVtaXRVc2VTdHJpY3QgPyAnXCJ1c2Ugc3RyaWN0XCI7JyA6ICcnLFxuICAgICAgICAgICAgICAgIC8vIHJldHVybiByZXBsYWNlbWVudHMgdXNpbmcgdGhlIGZ1bmN0aW9uIHRvIGVuc3VyZSB0aGF0IHRoZSByZXBsYWNlbWVudCBpc1xuICAgICAgICAgICAgICAgIC8vIHRyZWF0ZWQgbGlrZSBhIGR1bWIgc3RyaW5nIGFuZCBub3QgYXMgYSBzdHJpbmcgd2l0aCBSRSByZXBsYWNlbWVudCBwYXR0ZXJuc1xuICAgICAgICAgICAgICAgIHJlcGxhY2VyID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHM7IH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb2RlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdHMubm9BdXRvV3JhcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZml4Q29sdW1uUG9zaXRpb25zKHRoaXMuY292ZXJTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLmVtYmVkU291cmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3ZlclN0YXRlLmNvZGUgPSBzb3VyY2VDb2RlLnNwbGl0KC8oPzpcXHI/XFxuKXxcXHIvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdmVyU3RhdGUgPSB0aGlzLm9wdHMuZGVidWcgPyBKU09OLnN0cmluZ2lmeSh0aGlzLmNvdmVyU3RhdGUsIHVuZGVmaW5lZCwgNCkgOiBKU09OLnN0cmluZ2lmeSh0aGlzLmNvdmVyU3RhdGUpO1xuICAgICAgICAgICAgY29kZSA9IFtcbiAgICAgICAgICAgICAgICBcIiVTVFJJQ1QlXCIsXG4gICAgICAgICAgICAgICAgXCJ2YXIgJVZBUiUgPSAoRnVuY3Rpb24oJ3JldHVybiB0aGlzJykpKCk7XCIsXG4gICAgICAgICAgICAgICAgXCJpZiAoISVWQVIlLiVHTE9CQUwlKSB7ICVWQVIlLiVHTE9CQUwlID0ge307IH1cIixcbiAgICAgICAgICAgICAgICBcIiVWQVIlID0gJVZBUiUuJUdMT0JBTCU7XCIsXG4gICAgICAgICAgICAgICAgXCJpZiAoISglVkFSJVsnJUZJTEUlJ10pKSB7XCIsXG4gICAgICAgICAgICAgICAgXCIgICAlVkFSJVsnJUZJTEUlJ10gPSAlT0JKRUNUJTtcIixcbiAgICAgICAgICAgICAgICBcIn1cIixcbiAgICAgICAgICAgICAgICBcIiVWQVIlID0gJVZBUiVbJyVGSUxFJSddO1wiXG4gICAgICAgICAgICBdLmpvaW4oXCJcXG5cIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvJVNUUklDVCUvZywgcmVwbGFjZXIoc3RyaWN0TGluZSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLyVWQVIlL2csIHJlcGxhY2VyKHRyYWNrZXIpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8lR0xPQkFMJS9nLCByZXBsYWNlcih2YXJOYW1lKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvJUZJTEUlL2csIHJlcGxhY2VyKGZpbGUpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8lT0JKRUNUJS9nLCByZXBsYWNlcihjb3ZlclN0YXRlKSk7XG4gICAgICAgICAgICByZXR1cm4gY29kZTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdGFydElnbm9yZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUuaWdub3JpbmcgKz0gMTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbmRJZ25vcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRlLmlnbm9yaW5nIC09IDE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udmVydFRvQmxvY2s6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnQmxvY2tTdGF0ZW1lbnQnLCBib2R5OiBbXSB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdCbG9ja1N0YXRlbWVudCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ0Jsb2NrU3RhdGVtZW50JywgYm9keTogWyBub2RlIF0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhcnJvd0Jsb2NrQ29udmVydGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIHJldFN0YXRlbWVudDtcbiAgICAgICAgICAgIGlmIChub2RlLmV4cHJlc3Npb24pIHsgLy8gdHVybiBleHByZXNzaW9uIG5vZGVzIGludG8gYSBibG9jayB3aXRoIGEgcmV0dXJuIHN0YXRlbWVudFxuICAgICAgICAgICAgICAgIHJldFN0YXRlbWVudCA9IGFzdGdlbi5yZXR1cm5TdGF0ZW1lbnQobm9kZS5ib2R5KTtcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgdGhlIGdlbmVyYXRlZCByZXR1cm4gc3RhdGVtZW50IGlzIGNvdmVyZWRcbiAgICAgICAgICAgICAgICByZXRTdGF0ZW1lbnQubG9jID0gbm9kZS5ib2R5LmxvYztcbiAgICAgICAgICAgICAgICBub2RlLmJvZHkgPSB0aGlzLmNvbnZlcnRUb0Jsb2NrKHJldFN0YXRlbWVudCk7XG4gICAgICAgICAgICAgICAgbm9kZS5leHByZXNzaW9uID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyYW5vaWRIYW5kbGVyQ2hlY2s6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAvLyBpZiBzb21lb25lIGlzIHVzaW5nIGFuIG9sZGVyIGVzcHJpbWEgb24gdGhlIGJyb3dzZXJcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgaGFuZGxlcnMgYXJyYXkgdG8gc2luZ2xlIGhhbmRsZXIgYXR0cmlidXRlXG4gICAgICAgICAgICAvLyBjb250YWluaW5nIGl0cyBmaXJzdCBlbGVtZW50XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKCFub2RlLmhhbmRsZXIgJiYgbm9kZS5oYW5kbGVycykge1xuICAgICAgICAgICAgICAgIG5vZGUuaGFuZGxlciA9IG5vZGUuaGFuZGxlcnNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaWZCbG9ja0NvbnZlcnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMuY29udmVydFRvQmxvY2sobm9kZS5jb25zZXF1ZW50KTtcbiAgICAgICAgICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5jb252ZXJ0VG9CbG9jayhub2RlLmFsdGVybmF0ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbG9vcEJsb2NrQ29udmVydGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS5ib2R5ID0gdGhpcy5jb252ZXJ0VG9CbG9jayhub2RlLmJvZHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdpdGhCbG9ja0NvbnZlcnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUuYm9keSA9IHRoaXMuY29udmVydFRvQmxvY2sobm9kZS5ib2R5KTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdGF0ZW1lbnROYW1lOiBmdW5jdGlvbiAobG9jYXRpb24sIGluaXRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIHNOYW1lLFxuICAgICAgICAgICAgICAgIGlnbm9yaW5nID0gISF0aGlzLmN1cnJlbnRTdGF0ZS5pZ25vcmluZztcblxuICAgICAgICAgICAgbG9jYXRpb24uc2tpcCA9IGlnbm9yaW5nIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGluaXRWYWx1ZSA9IGluaXRWYWx1ZSB8fCAwO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUuc3RhdGVtZW50ICs9IDE7XG4gICAgICAgICAgICBzTmFtZSA9IHRoaXMuY3VycmVudFN0YXRlLnN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuY292ZXJTdGF0ZS5zdGF0ZW1lbnRNYXBbc05hbWVdID0gbG9jYXRpb247XG4gICAgICAgICAgICB0aGlzLmNvdmVyU3RhdGUuc1tzTmFtZV0gPSBpbml0VmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gc05hbWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2tpcEluaXQ6IGZ1bmN0aW9uIChub2RlIC8qLCB3YWxrZXIgKi8pIHtcbiAgICAgICAgICAgIGlmIChub2RlLmluaXQpIHtcbiAgICAgICAgICAgICAgICBub2RlLmluaXQuc2tpcFdhbGsgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNraXBMZWZ0OiBmdW5jdGlvbiAobm9kZSAvKiwgd2Fsa2VyICovKSB7XG4gICAgICAgICAgICBub2RlLmxlZnQuc2tpcFdhbGsgPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzVXNlU3RyaWN0RXhwcmVzc2lvbjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlICYmIG5vZGUudHlwZSA9PT0gU1lOVEFYLkV4cHJlc3Npb25TdGF0ZW1lbnQubmFtZSAmJlxuICAgICAgICAgICAgICAgIG5vZGUuZXhwcmVzc2lvbiAgJiYgbm9kZS5leHByZXNzaW9uLnR5cGUgPT09IFNZTlRBWC5MaXRlcmFsLm5hbWUgJiZcbiAgICAgICAgICAgICAgICBub2RlLmV4cHJlc3Npb24udmFsdWUgPT09ICd1c2Ugc3RyaWN0JztcbiAgICAgICAgfSxcblxuICAgICAgICBtYXliZVNraXBOb2RlOiBmdW5jdGlvbiAobm9kZSwgdHlwZSkge1xuICAgICAgICAgICAgdmFyIGFscmVhZHlJZ25vcmluZyA9ICEhdGhpcy5jdXJyZW50U3RhdGUuaWdub3JpbmcsXG4gICAgICAgICAgICAgICAgaGludCA9IHRoaXMuY3VycmVudFN0YXRlLmN1cnJlbnRIaW50LFxuICAgICAgICAgICAgICAgIGlnbm9yZVRoaXMgPSAhYWxyZWFkeUlnbm9yaW5nICYmIGhpbnQgJiYgaGludC50eXBlID09PSB0eXBlO1xuXG4gICAgICAgICAgICBpZiAoaWdub3JlVGhpcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRJZ25vcmUoKTtcbiAgICAgICAgICAgICAgICBub2RlLnBvc3Rwcm9jZXNzb3IgPSB0aGlzLmVuZElnbm9yZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb3Zlck1ldGFQcm9wZXJ0eTogZnVuY3Rpb24obm9kZSAvKiAsIHdhbGtlciAqLykge1xuICAgICAgICAgICBub2RlLnNraXBTZWxmID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb3ZlclN0YXRlbWVudDogZnVuY3Rpb24gKG5vZGUsIHdhbGtlcikge1xuICAgICAgICAgICAgdmFyIHNOYW1lLFxuICAgICAgICAgICAgICAgIGluY3JTdGF0ZW1lbnRDb3VudCxcbiAgICAgICAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgICAgICAgZ3JhbmRQYXJlbnQ7XG5cbiAgICAgICAgICAgIHRoaXMubWF5YmVTa2lwTm9kZShub2RlLCAnbmV4dCcpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc1VzZVN0cmljdEV4cHJlc3Npb24obm9kZSkpIHtcbiAgICAgICAgICAgICAgICBncmFuZFBhcmVudCA9IHdhbGtlci5hbmNlc3RvcigyKTtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogZGlmZmljdWx0IHRvIHRlc3QgKi9cbiAgICAgICAgICAgICAgICBpZiAoZ3JhbmRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChncmFuZFBhcmVudC5ub2RlLnR5cGUgPT09IFNZTlRBWC5GdW5jdGlvbkV4cHJlc3Npb24ubmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhbmRQYXJlbnQubm9kZS50eXBlID09PSBTWU5UQVguRnVuY3Rpb25EZWNsYXJhdGlvbi5uYW1lKSAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhbGtlci5wYXJlbnQoKS5ub2RlLmJvZHlbMF0gPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU1lOVEFYLkZ1bmN0aW9uRGVjbGFyYXRpb24ubmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIENhbGxlZCBmb3IgdGhlIHNpZGUtZWZmZWN0IG9mIHNldHRpbmcgdGhlIGZ1bmN0aW9uJ3Mgc3RhdGVtZW50IGNvdW50IHRvIDEuXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZW1lbnROYW1lKG5vZGUubG9jLCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbGV0IGBjb3ZlckV4cG9ydGAgaGFuZGxlIEV4cG9ydE5hbWVkRGVjbGFyYXRpb25zLlxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHdhbGtlci5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5ub2RlLnR5cGUgPT09IFNZTlRBWC5FeHBvcnROYW1lZERlY2xhcmF0aW9uLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNOYW1lID0gdGhpcy5zdGF0ZW1lbnROYW1lKG5vZGUubG9jKTtcblxuICAgICAgICAgICAgICAgIGluY3JTdGF0ZW1lbnRDb3VudCA9IGFzdGdlbi5zdGF0ZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgIGFzdGdlbi5wb3N0SW5jcmVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgYXN0Z2VuLnN1YnNjcmlwdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3RnZW4uZG90KGFzdGdlbi52YXJpYWJsZSh0aGlzLmN1cnJlbnRTdGF0ZS50cmFja2VyVmFyKSwgYXN0Z2VuLnZhcmlhYmxlKCdzJykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzdGdlbi5zdHJpbmdMaXRlcmFsKHNOYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuc3BsaWNlKGluY3JTdGF0ZW1lbnRDb3VudCwgbm9kZSwgd2Fsa2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjb3ZlckV4cG9ydDogZnVuY3Rpb24gKG5vZGUsIHdhbGtlcikge1xuICAgICAgICAgICAgdmFyIHNOYW1lLCBpbmNyU3RhdGVtZW50Q291bnQ7XG5cbiAgICAgICAgICAgIGlmICggIW5vZGUuZGVjbGFyYXRpb24gfHwgIW5vZGUuZGVjbGFyYXRpb24uZGVjbGFyYXRpb25zICkgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgdGhpcy5tYXliZVNraXBOb2RlKG5vZGUsICduZXh0Jyk7XG5cbiAgICAgICAgICAgIHNOYW1lID0gdGhpcy5zdGF0ZW1lbnROYW1lKG5vZGUuZGVjbGFyYXRpb24ubG9jKTtcbiAgICAgICAgICAgIGluY3JTdGF0ZW1lbnRDb3VudCA9IGFzdGdlbi5zdGF0ZW1lbnQoXG4gICAgICAgICAgICAgICAgYXN0Z2VuLnBvc3RJbmNyZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgIGFzdGdlbi5zdWJzY3JpcHQoXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3RnZW4uZG90KGFzdGdlbi52YXJpYWJsZSh0aGlzLmN1cnJlbnRTdGF0ZS50cmFja2VyVmFyKSwgYXN0Z2VuLnZhcmlhYmxlKCdzJykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXN0Z2VuLnN0cmluZ0xpdGVyYWwoc05hbWUpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLnNwbGljZShpbmNyU3RhdGVtZW50Q291bnQsIG5vZGUsIHdhbGtlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3BsaWNlOiBmdW5jdGlvbiAoc3RhdGVtZW50cywgbm9kZSwgd2Fsa2VyKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IHdhbGtlci5pc0xhYmVsZWQoKSA/IHdhbGtlci5wYXJlbnQoKS5ub2RlIDogbm9kZTtcbiAgICAgICAgICAgIHRhcmdldE5vZGUucHJlcGVuZCA9IHRhcmdldE5vZGUucHJlcGVuZCB8fCBbXTtcbiAgICAgICAgICAgIHB1c2hBbGwodGFyZ2V0Tm9kZS5wcmVwZW5kLCBzdGF0ZW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmdW5jdGlvbk5hbWU6IGZ1bmN0aW9uIChub2RlLCBsaW5lLCBsb2NhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUuZnVuYyArPSAxO1xuICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5jdXJyZW50U3RhdGUuZnVuYyxcbiAgICAgICAgICAgICAgICBpZ25vcmluZyA9ICEhdGhpcy5jdXJyZW50U3RhdGUuaWdub3JpbmcsXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5vZGUuaWQgPyBub2RlLmlkLm5hbWUgOiAnKGFub255bW91c18nICsgaWQgKyAnKScsXG4gICAgICAgICAgICAgICAgY2xvbmUgPSBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gbG9jYXRpb25bYXR0cl0gfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge307XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmU6IG9iai5saW5lLCBjb2x1bW46IG9iai5jb2x1bW4gfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5jb3ZlclN0YXRlLmZuTWFwW2lkXSA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLCBsaW5lOiBsaW5lLFxuICAgICAgICAgICAgICAgIGxvYzoge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogY2xvbmUoJ3N0YXJ0JyksXG4gICAgICAgICAgICAgICAgICAgIGVuZDogY2xvbmUoJ2VuZCcpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBza2lwOiBpZ25vcmluZyB8fCB1bmRlZmluZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmNvdmVyU3RhdGUuZltpZF0gPSAwO1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvdmVyRnVuY3Rpb246IGZ1bmN0aW9uIChub2RlLCB3YWxrZXIpIHtcbiAgICAgICAgICAgIHZhciBpZCxcbiAgICAgICAgICAgICAgICBib2R5ID0gbm9kZS5ib2R5LFxuICAgICAgICAgICAgICAgIGJsb2NrQm9keSA9IGJvZHkuYm9keSxcbiAgICAgICAgICAgICAgICBwb3BwZWQ7XG5cbiAgICAgICAgICAgIHRoaXMubWF5YmVTa2lwTm9kZShub2RlLCAnbmV4dCcpO1xuXG4gICAgICAgICAgICBpZCA9IHRoaXMuZnVuY3Rpb25OYW1lKG5vZGUsIHdhbGtlci5zdGFydExpbmVGb3JOb2RlKG5vZGUpLCB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG5vZGUubG9jLnN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogeyBsaW5lOiBub2RlLmJvZHkubG9jLnN0YXJ0LmxpbmUsIGNvbHVtbjogbm9kZS5ib2R5LmxvYy5zdGFydC5jb2x1bW4gfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChibG9ja0JvZHkubGVuZ3RoID4gMCAmJiB0aGlzLmlzVXNlU3RyaWN0RXhwcmVzc2lvbihibG9ja0JvZHlbMF0pKSB7XG4gICAgICAgICAgICAgICAgcG9wcGVkID0gYmxvY2tCb2R5LnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9ja0JvZHkudW5zaGlmdChcbiAgICAgICAgICAgICAgICBhc3RnZW4uc3RhdGVtZW50KFxuICAgICAgICAgICAgICAgICAgICBhc3RnZW4ucG9zdEluY3JlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzdGdlbi5zdWJzY3JpcHQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN0Z2VuLmRvdChhc3RnZW4udmFyaWFibGUodGhpcy5jdXJyZW50U3RhdGUudHJhY2tlclZhciksIGFzdGdlbi52YXJpYWJsZSgnZicpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3RnZW4uc3RyaW5nTGl0ZXJhbChpZClcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAocG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tCb2R5LnVuc2hpZnQocG9wcGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBicmFuY2hOYW1lOiBmdW5jdGlvbiAodHlwZSwgc3RhcnRMaW5lLCBwYXRoTG9jYXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgYk5hbWUsXG4gICAgICAgICAgICAgICAgcGF0aHMgPSBbXSxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbnMgPSBbXSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGlnbm9yaW5nID0gISF0aGlzLmN1cnJlbnRTdGF0ZS5pZ25vcmluZztcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRlLmJyYW5jaCArPSAxO1xuICAgICAgICAgICAgYk5hbWUgPSB0aGlzLmN1cnJlbnRTdGF0ZS5icmFuY2g7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGF0aExvY2F0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHBhdGhMb2NhdGlvbnNbaV0uc2tpcCA9IHBhdGhMb2NhdGlvbnNbaV0uc2tpcCB8fCBpZ25vcmluZyB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbG9jYXRpb25zLnB1c2gocGF0aExvY2F0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgcGF0aHMucHVzaCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY292ZXJTdGF0ZS5iW2JOYW1lXSA9IHBhdGhzO1xuICAgICAgICAgICAgdGhpcy5jb3ZlclN0YXRlLmJyYW5jaE1hcFtiTmFtZV0gPSB7IGxpbmU6IHN0YXJ0TGluZSwgdHlwZTogdHlwZSwgbG9jYXRpb25zOiBsb2NhdGlvbnMgfTtcbiAgICAgICAgICAgIHJldHVybiBiTmFtZTtcbiAgICAgICAgfSxcblxuICAgICAgICBicmFuY2hJbmNyZW1lbnRFeHByQXN0OiBmdW5jdGlvbiAodmFyTmFtZSwgYnJhbmNoSW5kZXgsIGRvd24pIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBhc3RnZW4ucG9zdEluY3JlbWVudChcbiAgICAgICAgICAgICAgICBhc3RnZW4uc3Vic2NyaXB0KFxuICAgICAgICAgICAgICAgICAgICBhc3RnZW4uc3Vic2NyaXB0KFxuICAgICAgICAgICAgICAgICAgICAgICAgYXN0Z2VuLmRvdChhc3RnZW4udmFyaWFibGUodGhpcy5jdXJyZW50U3RhdGUudHJhY2tlclZhciksIGFzdGdlbi52YXJpYWJsZSgnYicpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzdGdlbi5zdHJpbmdMaXRlcmFsKHZhck5hbWUpXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIGFzdGdlbi5udW1lcmljTGl0ZXJhbChicmFuY2hJbmRleClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGRvd25cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGxvY2F0aW9uc0Zvck5vZGVzOiBmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBbXSxcbiAgICAgICAgICAgICAgICBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2gobm9kZXNbaV0ubG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaWZCcmFuY2hJbmplY3RvcjogZnVuY3Rpb24gKG5vZGUsIHdhbGtlcikge1xuICAgICAgICAgICAgdmFyIGFscmVhZHlJZ25vcmluZyA9ICEhdGhpcy5jdXJyZW50U3RhdGUuaWdub3JpbmcsXG4gICAgICAgICAgICAgICAgaGludCA9IHRoaXMuY3VycmVudFN0YXRlLmN1cnJlbnRIaW50LFxuICAgICAgICAgICAgICAgIGlnbm9yZVRoZW4gPSAhYWxyZWFkeUlnbm9yaW5nICYmIGhpbnQgJiYgaGludC50eXBlID09PSAnaWYnLFxuICAgICAgICAgICAgICAgIGlnbm9yZUVsc2UgPSAhYWxyZWFkeUlnbm9yaW5nICYmIGhpbnQgJiYgaGludC50eXBlID09PSAnZWxzZScsXG4gICAgICAgICAgICAgICAgbGluZSA9IG5vZGUubG9jLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgY29sID0gbm9kZS5sb2Muc3RhcnQuY29sdW1uLFxuICAgICAgICAgICAgICAgIG1ha2VMb2MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAgeyBsaW5lOiBsaW5lLCBjb2x1bW46IGNvbCB9OyB9LFxuICAgICAgICAgICAgICAgIGJOYW1lID0gdGhpcy5icmFuY2hOYW1lKCdpZicsIHdhbGtlci5zdGFydExpbmVGb3JOb2RlKG5vZGUpLCBbXG4gICAgICAgICAgICAgICAgICAgIHsgc3RhcnQ6IG1ha2VMb2MoKSwgZW5kOiBtYWtlTG9jKCksIHNraXA6IGlnbm9yZVRoZW4gfHwgdW5kZWZpbmVkIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgc3RhcnQ6IG1ha2VMb2MoKSwgZW5kOiBtYWtlTG9jKCksIHNraXA6IGlnbm9yZUVsc2UgfHwgdW5kZWZpbmVkIH1cbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICB0aGVuQm9keSA9IG5vZGUuY29uc2VxdWVudC5ib2R5LFxuICAgICAgICAgICAgICAgIGVsc2VCb2R5ID0gbm9kZS5hbHRlcm5hdGUuYm9keSxcbiAgICAgICAgICAgICAgICBjaGlsZDtcbiAgICAgICAgICAgIHRoZW5Cb2R5LnVuc2hpZnQoYXN0Z2VuLnN0YXRlbWVudCh0aGlzLmJyYW5jaEluY3JlbWVudEV4cHJBc3QoYk5hbWUsIDApKSk7XG4gICAgICAgICAgICBlbHNlQm9keS51bnNoaWZ0KGFzdGdlbi5zdGF0ZW1lbnQodGhpcy5icmFuY2hJbmNyZW1lbnRFeHByQXN0KGJOYW1lLCAxKSkpO1xuICAgICAgICAgICAgaWYgKGlnbm9yZVRoZW4pIHsgY2hpbGQgPSBub2RlLmNvbnNlcXVlbnQ7IGNoaWxkLnByZXByb2Nlc3NvciA9IHRoaXMuc3RhcnRJZ25vcmU7IGNoaWxkLnBvc3Rwcm9jZXNzb3IgPSB0aGlzLmVuZElnbm9yZTsgfVxuICAgICAgICAgICAgaWYgKGlnbm9yZUVsc2UpIHsgY2hpbGQgPSBub2RlLmFsdGVybmF0ZTsgY2hpbGQucHJlcHJvY2Vzc29yID0gdGhpcy5zdGFydElnbm9yZTsgY2hpbGQucG9zdHByb2Nlc3NvciA9IHRoaXMuZW5kSWdub3JlOyB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYnJhbmNoTG9jYXRpb25Gb3I6IGZ1bmN0aW9uIChuYW1lLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY292ZXJTdGF0ZS5icmFuY2hNYXBbbmFtZV0ubG9jYXRpb25zW2luZGV4XTtcbiAgICAgICAgfSxcblxuICAgICAgICBzd2l0Y2hCcmFuY2hJbmplY3RvcjogZnVuY3Rpb24gKG5vZGUsIHdhbGtlcikge1xuICAgICAgICAgICAgdmFyIGNhc2VzID0gbm9kZS5jYXNlcyxcbiAgICAgICAgICAgICAgICBiTmFtZSxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICBpZiAoIShjYXNlcyAmJiBjYXNlcy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJOYW1lID0gdGhpcy5icmFuY2hOYW1lKCdzd2l0Y2gnLCB3YWxrZXIuc3RhcnRMaW5lRm9yTm9kZShub2RlKSwgdGhpcy5sb2NhdGlvbnNGb3JOb2RlcyhjYXNlcykpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNhc2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY2FzZXNbaV0uYnJhbmNoTG9jYXRpb24gPSB0aGlzLmJyYW5jaExvY2F0aW9uRm9yKGJOYW1lLCBpKTtcbiAgICAgICAgICAgICAgICBjYXNlc1tpXS5jb25zZXF1ZW50LnVuc2hpZnQoYXN0Z2VuLnN0YXRlbWVudCh0aGlzLmJyYW5jaEluY3JlbWVudEV4cHJBc3QoYk5hbWUsIGkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3dpdGNoQ2FzZUluamVjdG9yOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gbm9kZS5icmFuY2hMb2NhdGlvbjtcbiAgICAgICAgICAgIGRlbGV0ZSBub2RlLmJyYW5jaExvY2F0aW9uO1xuICAgICAgICAgICAgaWYgKHRoaXMubWF5YmVTa2lwTm9kZShub2RlLCAnbmV4dCcpKSB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb24uc2tpcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29uZGl0aW9uYWxCcmFuY2hJbmplY3RvcjogZnVuY3Rpb24gKG5vZGUsIHdhbGtlcikge1xuICAgICAgICAgICAgdmFyIGJOYW1lID0gdGhpcy5icmFuY2hOYW1lKCdjb25kLWV4cHInLCB3YWxrZXIuc3RhcnRMaW5lRm9yTm9kZShub2RlKSwgdGhpcy5sb2NhdGlvbnNGb3JOb2RlcyhbIG5vZGUuY29uc2VxdWVudCwgbm9kZS5hbHRlcm5hdGUgXSkpLFxuICAgICAgICAgICAgICAgIGFzdDEgPSB0aGlzLmJyYW5jaEluY3JlbWVudEV4cHJBc3QoYk5hbWUsIDApLFxuICAgICAgICAgICAgICAgIGFzdDIgPSB0aGlzLmJyYW5jaEluY3JlbWVudEV4cHJBc3QoYk5hbWUsIDEpO1xuXG4gICAgICAgICAgICBub2RlLmNvbnNlcXVlbnQucHJlcHJvY2Vzc29yID0gdGhpcy5tYXliZUFkZFNraXAodGhpcy5icmFuY2hMb2NhdGlvbkZvcihiTmFtZSwgMCkpO1xuICAgICAgICAgICAgbm9kZS5hbHRlcm5hdGUucHJlcHJvY2Vzc29yID0gdGhpcy5tYXliZUFkZFNraXAodGhpcy5icmFuY2hMb2NhdGlvbkZvcihiTmFtZSwgMSkpO1xuICAgICAgICAgICAgbm9kZS5jb25zZXF1ZW50ID0gYXN0Z2VuLnNlcXVlbmNlKGFzdDEsIG5vZGUuY29uc2VxdWVudCk7XG4gICAgICAgICAgICBub2RlLmFsdGVybmF0ZSA9IGFzdGdlbi5zZXF1ZW5jZShhc3QyLCBub2RlLmFsdGVybmF0ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF5YmVBZGRTa2lwOiBmdW5jdGlvbiAoYnJhbmNoTG9jYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBhbHJlYWR5SWdub3JpbmcgPSAhIXRoaXMuY3VycmVudFN0YXRlLmlnbm9yaW5nLFxuICAgICAgICAgICAgICAgICAgICBoaW50ID0gdGhpcy5jdXJyZW50U3RhdGUuY3VycmVudEhpbnQsXG4gICAgICAgICAgICAgICAgICAgIGlnbm9yZVRoaXMgPSAhYWxyZWFkeUlnbm9yaW5nICYmIGhpbnQgJiYgaGludC50eXBlID09PSAnbmV4dCc7XG4gICAgICAgICAgICAgICAgaWYgKGlnbm9yZVRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydElnbm9yZSgpO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnBvc3Rwcm9jZXNzb3IgPSB0aGlzLmVuZElnbm9yZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlnbm9yZVRoaXMgfHwgYWxyZWFkeUlnbm9yaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyYW5jaExvY2F0aW9uLnNraXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgbG9naWNhbEV4cHJlc3Npb25CcmFuY2hJbmplY3RvcjogZnVuY3Rpb24gKG5vZGUsIHdhbGtlcikge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHdhbGtlci5wYXJlbnQoKSxcbiAgICAgICAgICAgICAgICBsZWF2ZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBiTmFtZSxcbiAgICAgICAgICAgICAgICB0dXBsZSxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICB0aGlzLm1heWJlU2tpcE5vZGUobm9kZSwgJ25leHQnKTtcblxuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQubm9kZS50eXBlID09PSBTWU5UQVguTG9naWNhbEV4cHJlc3Npb24ubmFtZSkge1xuICAgICAgICAgICAgICAgIC8vYWxyZWFkeSBjb3ZlcmVkXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmZpbmRMZWF2ZXMobm9kZSwgbGVhdmVzKTtcbiAgICAgICAgICAgIGJOYW1lID0gdGhpcy5icmFuY2hOYW1lKCdiaW5hcnktZXhwcicsXG4gICAgICAgICAgICAgICAgd2Fsa2VyLnN0YXJ0TGluZUZvck5vZGUobm9kZSksXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbnNGb3JOb2RlcyhsZWF2ZXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLm5vZGU7IH0pKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZWF2ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB0dXBsZSA9IGxlYXZlc1tpXTtcbiAgICAgICAgICAgICAgICB0dXBsZS5wYXJlbnRbdHVwbGUucHJvcGVydHldID0gYXN0Z2VuLnNlcXVlbmNlKHRoaXMuYnJhbmNoSW5jcmVtZW50RXhwckFzdChiTmFtZSwgaSksIHR1cGxlLm5vZGUpO1xuICAgICAgICAgICAgICAgIHR1cGxlLm5vZGUucHJlcHJvY2Vzc29yID0gdGhpcy5tYXliZUFkZFNraXAodGhpcy5icmFuY2hMb2NhdGlvbkZvcihiTmFtZSwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmRMZWF2ZXM6IGZ1bmN0aW9uIChub2RlLCBhY2N1bXVsYXRvciwgcGFyZW50LCBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU1lOVEFYLkxvZ2ljYWxFeHByZXNzaW9uLm5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmRMZWF2ZXMobm9kZS5sZWZ0LCBhY2N1bXVsYXRvciwgbm9kZSwgJ2xlZnQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmRMZWF2ZXMobm9kZS5yaWdodCwgYWNjdW11bGF0b3IsIG5vZGUsICdyaWdodCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRvci5wdXNoKHsgbm9kZTogbm9kZSwgcGFyZW50OiBwYXJlbnQsIHByb3BlcnR5OiBwcm9wZXJ0eSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWF5YmVBZGRUeXBlOiBmdW5jdGlvbiAobm9kZSAvKiwgd2Fsa2VyICovKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBub2RlLnByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBjaGlsZDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gcHJvcHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnR5cGUgPSBTWU5UQVguUHJvcGVydHkubmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBJbnN0cnVtZW50ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93Lkluc3RydW1lbnRlciA9IEluc3RydW1lbnRlcjtcbiAgICB9XG5cbn0odHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/lib/instrumenter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/lib/object-utils.js":
/*!******************************************************!*\
  !*** ./node_modules/sc-istanbul/lib/object-utils.js ***!
  \******************************************************/
/***/ ((module, exports) => {

eval("/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n/**\n * utility methods to process coverage objects. A coverage object has the following\n * format.\n *\n *      {\n *          \"/path/to/file1.js\": { file1 coverage },\n *          \"/path/to/file2.js\": { file2 coverage }\n *      }\n *\n *  The internals of the file coverage object are intentionally not documented since\n *  it is not a public interface.\n *\n *  *Note:* When a method of this module has the word `File` in it, it will accept\n *  one of the sub-objects of the main coverage object as an argument. Other\n *  methods accept the higher level coverage object with multiple keys.\n *\n * Works on `node` as well as the browser.\n *\n * Usage on nodejs\n * ---------------\n *\n *      var objectUtils = require('istanbul').utils;\n *\n * Usage in a browser\n * ------------------\n *\n * Load this file using a `script` tag or other means. This will set `window.coverageUtils`\n * to this module's exports.\n *\n * @class ObjectUtils\n * @module main\n * @static\n */\n(function (isNode) {\n    /**\n     * adds line coverage information to a file coverage object, reverse-engineering\n     * it from statement coverage. The object passed in is updated in place.\n     *\n     * Note that if line coverage information is already present in the object,\n     * it is not recomputed.\n     *\n     * @method addDerivedInfoForFile\n     * @static\n     * @param {Object} fileCoverage the coverage object for a single file\n     */\n    function addDerivedInfoForFile(fileCoverage) {\n        var statementMap = fileCoverage.statementMap,\n            statements = fileCoverage.s,\n            lineMap;\n\n        if (!fileCoverage.l) {\n            fileCoverage.l = lineMap = {};\n            Object.keys(statements).forEach(function (st) {\n                var line = statementMap[st].start.line,\n                    count = statements[st],\n                    prevVal = lineMap[line];\n                if (count === 0 && statementMap[st].skip) { count = 1; }\n                if (typeof prevVal === 'undefined' || prevVal < count) {\n                    lineMap[line] = count;\n                }\n            });\n        }\n    }\n    /**\n     * adds line coverage information to all file coverage objects.\n     *\n     * @method addDerivedInfo\n     * @static\n     * @param {Object} coverage the coverage object\n     */\n    function addDerivedInfo(coverage) {\n        Object.keys(coverage).forEach(function (k) {\n            addDerivedInfoForFile(coverage[k]);\n        });\n    }\n    /**\n     * removes line coverage information from all file coverage objects\n     * @method removeDerivedInfo\n     * @static\n     * @param {Object} coverage the coverage object\n     */\n    function removeDerivedInfo(coverage) {\n        Object.keys(coverage).forEach(function (k) {\n            delete coverage[k].l;\n        });\n    }\n\n    function percent(covered, total) {\n        var tmp;\n        if (total > 0) {\n            tmp = 1000 * 100 * covered / total + 5;\n            return Math.floor(tmp / 10) / 100;\n        } else {\n            return 100.00;\n        }\n    }\n\n    function computeSimpleTotals(fileCoverage, property, mapProperty) {\n        var stats = fileCoverage[property],\n            map = mapProperty ? fileCoverage[mapProperty] : null,\n            ret = { total: 0, covered: 0, skipped: 0 };\n\n        Object.keys(stats).forEach(function (key) {\n            var covered = !!stats[key],\n                skipped = map && map[key].skip;\n            ret.total += 1;\n            if (covered || skipped) {\n                ret.covered += 1;\n            }\n            if (!covered && skipped) {\n                ret.skipped += 1;\n            }\n        });\n        ret.pct = percent(ret.covered, ret.total);\n        return ret;\n    }\n\n    function computeBranchTotals(fileCoverage) {\n        var stats = fileCoverage.b,\n            branchMap = fileCoverage.branchMap,\n            ret = { total: 0, covered: 0, skipped: 0 };\n\n        Object.keys(stats).forEach(function (key) {\n            var branches = stats[key],\n                map = branchMap[key],\n                covered,\n                skipped,\n                i;\n            for (i = 0; i < branches.length; i += 1) {\n                covered = branches[i] > 0;\n                skipped = map.locations && map.locations[i] && map.locations[i].skip;\n                if (covered || skipped) {\n                    ret.covered += 1;\n                }\n                if (!covered && skipped) {\n                    ret.skipped += 1;\n                }\n            }\n            ret.total += branches.length;\n        });\n        ret.pct = percent(ret.covered, ret.total);\n        return ret;\n    }\n    /**\n     * returns a blank summary metrics object. A metrics object has the following\n     * format.\n     *\n     *      {\n     *          lines: lineMetrics,\n     *          statements: statementMetrics,\n     *          functions: functionMetrics,\n     *          branches: branchMetrics\n     *          linesCovered: lineCoveredCount\n     *      }\n     *\n     *  Each individual metric object looks as follows:\n     *\n     *      {\n     *          total: n,\n     *          covered: m,\n     *          pct: percent\n     *      }\n     *\n     * @method blankSummary\n     * @static\n     * @return {Object} a blank metrics object\n     */\n    function blankSummary() {\n        return {\n            lines: {\n                total: 0,\n                covered: 0,\n                skipped: 0,\n                pct: 'Unknown'\n            },\n            statements: {\n                total: 0,\n                covered: 0,\n                skipped: 0,\n                pct: 'Unknown'\n            },\n            functions: {\n                total: 0,\n                covered: 0,\n                skipped: 0,\n                pct: 'Unknown'\n            },\n            branches: {\n                total: 0,\n                covered: 0,\n                skipped: 0,\n                pct: 'Unknown'\n            },\n            linesCovered: {}\n        };\n    }\n    /**\n     * returns the summary metrics given the coverage object for a single file. See `blankSummary()`\n     * to understand the format of the returned object.\n     *\n     * @method summarizeFileCoverage\n     * @static\n     * @param {Object} fileCoverage the coverage object for a single file.\n     * @return {Object} the summary metrics for the file\n     */\n    function summarizeFileCoverage(fileCoverage) {\n        var ret = blankSummary();\n        addDerivedInfoForFile(fileCoverage);\n        ret.lines = computeSimpleTotals(fileCoverage, 'l');\n        ret.functions = computeSimpleTotals(fileCoverage, 'f', 'fnMap');\n        ret.statements = computeSimpleTotals(fileCoverage, 's', 'statementMap');\n        ret.branches = computeBranchTotals(fileCoverage);\n        ret.linesCovered = fileCoverage.l;\n        return ret;\n    }\n    /**\n     * merges two instances of file coverage objects *for the same file*\n     * such that the execution counts are correct.\n     *\n     * @method mergeFileCoverage\n     * @static\n     * @param {Object} first the first file coverage object for a given file\n     * @param {Object} second the second file coverage object for the same file\n     * @return {Object} an object that is a result of merging the two. Note that\n     *      the input objects are not changed in any way.\n     */\n    function mergeFileCoverage(first, second) {\n        var ret = JSON.parse(JSON.stringify(first)),\n            i;\n\n        delete ret.l; //remove derived info\n\n        Object.keys(second.s).forEach(function (k) {\n            ret.s[k] += second.s[k];\n        });\n        Object.keys(second.f).forEach(function (k) {\n            ret.f[k] += second.f[k];\n        });\n        Object.keys(second.b).forEach(function (k) {\n            var retArray = ret.b[k],\n                secondArray = second.b[k];\n            for (i = 0; i < retArray.length; i += 1) {\n                retArray[i] += secondArray[i];\n            }\n        });\n\n        return ret;\n    }\n    /**\n     * merges multiple summary metrics objects by summing up the `totals` and\n     * `covered` fields and recomputing the percentages. This function is generic\n     * and can accept any number of arguments.\n     *\n     * @method mergeSummaryObjects\n     * @static\n     * @param {Object} summary... multiple summary metrics objects\n     * @return {Object} the merged summary metrics\n     */\n    function mergeSummaryObjects() {\n        var ret = blankSummary(),\n            args = Array.prototype.slice.call(arguments),\n            keys = ['lines', 'statements', 'branches', 'functions'],\n            increment = function (obj) {\n                if (obj) {\n                    keys.forEach(function (key) {\n                        ret[key].total += obj[key].total;\n                        ret[key].covered += obj[key].covered;\n                        ret[key].skipped += obj[key].skipped;\n                    });\n\n                    // keep track of all lines we have coverage for.\n                    Object.keys(obj.linesCovered).forEach(function (key) {\n                        if (!ret.linesCovered[key]) {\n                            ret.linesCovered[key] = obj.linesCovered[key];\n                        } else {\n                            ret.linesCovered[key] += obj.linesCovered[key];\n                        }\n                    });\n                }\n            };\n        args.forEach(function (arg) {\n            increment(arg);\n        });\n        keys.forEach(function (key) {\n            ret[key].pct = percent(ret[key].covered, ret[key].total);\n        });\n\n        return ret;\n    }\n    /**\n     * returns the coverage summary for a single coverage object. This is\n     * wrapper over `summarizeFileCoverage` and `mergeSummaryObjects` for\n     * the common case of a single coverage object\n     * @method summarizeCoverage\n     * @static\n     * @param {Object} coverage  the coverage object\n     * @return {Object} summary coverage metrics across all files in the coverage object\n     */\n    function summarizeCoverage(coverage) {\n        var fileSummary = [];\n        Object.keys(coverage).forEach(function (key) {\n            fileSummary.push(summarizeFileCoverage(coverage[key]));\n        });\n        return mergeSummaryObjects.apply(null, fileSummary);\n    }\n\n    /**\n     * makes the coverage object generated by this library yuitest_coverage compatible.\n     * Note that this transformation is lossy since the returned object will not have\n     * statement and branch coverage.\n     *\n     * @method toYUICoverage\n     * @static\n     * @param {Object} coverage The `istanbul` coverage object\n     * @return {Object} a coverage object in `yuitest_coverage` format.\n     */\n    function toYUICoverage(coverage) {\n        var ret = {};\n\n        addDerivedInfo(coverage);\n\n        Object.keys(coverage).forEach(function (k) {\n            var fileCoverage = coverage[k],\n                lines = fileCoverage.l,\n                functions = fileCoverage.f,\n                fnMap = fileCoverage.fnMap,\n                o;\n\n            o = ret[k] = {\n                lines: {},\n                calledLines: 0,\n                coveredLines: 0,\n                functions: {},\n                calledFunctions: 0,\n                coveredFunctions: 0\n            };\n            Object.keys(lines).forEach(function (k) {\n                o.lines[k] = lines[k];\n                o.coveredLines += 1;\n                if (lines[k] > 0) {\n                    o.calledLines += 1;\n                }\n            });\n            Object.keys(functions).forEach(function (k) {\n                var name = fnMap[k].name + ':' + fnMap[k].line;\n                o.functions[name] = functions[k];\n                o.coveredFunctions += 1;\n                if (functions[k] > 0) {\n                    o.calledFunctions += 1;\n                }\n            });\n        });\n        return ret;\n    }\n\n    /**\n     * Creates new file coverage object with incremented hits count\n     * on skipped statements, branches and functions\n     *\n     * @method incrementIgnoredTotals\n     * @static\n     * @param {Object} cov File coverage object\n     * @return {Object} New file coverage object\n     */\n    function incrementIgnoredTotals(cov) {\n        //TODO: This may be slow in the browser and may break in older browsers\n        //      Look into using a library that works in Node and the browser\n        var fileCoverage = JSON.parse(JSON.stringify(cov));\n\n        [\n            {mapKey: 'statementMap', hitsKey: 's'},\n            {mapKey: 'branchMap', hitsKey: 'b'},\n            {mapKey: 'fnMap', hitsKey: 'f'}\n        ].forEach(function (keys) {\n            Object.keys(fileCoverage[keys.mapKey])\n                .forEach(function (key) {\n                    var map = fileCoverage[keys.mapKey][key];\n                    var hits = fileCoverage[keys.hitsKey];\n\n                    if (keys.mapKey === 'branchMap') {\n                        var locations = map.locations;\n\n                        locations.forEach(function (location, index) {\n                            if (hits[key][index] === 0 && location.skip) {\n                                hits[key][index] = 1;\n                            }\n                        });\n\n                        return;\n                    }\n\n                    if (hits[key] === 0 && map.skip) {\n                        hits[key] = 1;\n                    }\n                });\n            });\n\n        return fileCoverage;\n    }\n\n    var exportables = {\n        addDerivedInfo: addDerivedInfo,\n        addDerivedInfoForFile: addDerivedInfoForFile,\n        removeDerivedInfo: removeDerivedInfo,\n        blankSummary: blankSummary,\n        summarizeFileCoverage: summarizeFileCoverage,\n        summarizeCoverage: summarizeCoverage,\n        mergeFileCoverage: mergeFileCoverage,\n        mergeSummaryObjects: mergeSummaryObjects,\n        toYUICoverage: toYUICoverage,\n        incrementIgnoredTotals: incrementIgnoredTotals\n    };\n\n    /* istanbul ignore else: windows */\n    if (isNode) {\n        module.exports = exportables;\n    } else {\n        window.coverageUtils = exportables;\n    }\n}( true && typeof module.exports !== 'undefined' && typeof exports !== 'undefined'));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL29iamVjdC11dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxxQ0FBcUM7QUFDbEQsYUFBYSxrQ0FBa0M7QUFDL0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLENBQUMsQ0FBQyxLQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL29iamVjdC11dGlscy5qcz80ZWU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gQ29weXJpZ2h0IChjKSAyMDEyLCBZYWhvbyEgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cblxuLyoqXG4gKiB1dGlsaXR5IG1ldGhvZHMgdG8gcHJvY2VzcyBjb3ZlcmFnZSBvYmplY3RzLiBBIGNvdmVyYWdlIG9iamVjdCBoYXMgdGhlIGZvbGxvd2luZ1xuICogZm9ybWF0LlxuICpcbiAqICAgICAge1xuICogICAgICAgICAgXCIvcGF0aC90by9maWxlMS5qc1wiOiB7IGZpbGUxIGNvdmVyYWdlIH0sXG4gKiAgICAgICAgICBcIi9wYXRoL3RvL2ZpbGUyLmpzXCI6IHsgZmlsZTIgY292ZXJhZ2UgfVxuICogICAgICB9XG4gKlxuICogIFRoZSBpbnRlcm5hbHMgb2YgdGhlIGZpbGUgY292ZXJhZ2Ugb2JqZWN0IGFyZSBpbnRlbnRpb25hbGx5IG5vdCBkb2N1bWVudGVkIHNpbmNlXG4gKiAgaXQgaXMgbm90IGEgcHVibGljIGludGVyZmFjZS5cbiAqXG4gKiAgKk5vdGU6KiBXaGVuIGEgbWV0aG9kIG9mIHRoaXMgbW9kdWxlIGhhcyB0aGUgd29yZCBgRmlsZWAgaW4gaXQsIGl0IHdpbGwgYWNjZXB0XG4gKiAgb25lIG9mIHRoZSBzdWItb2JqZWN0cyBvZiB0aGUgbWFpbiBjb3ZlcmFnZSBvYmplY3QgYXMgYW4gYXJndW1lbnQuIE90aGVyXG4gKiAgbWV0aG9kcyBhY2NlcHQgdGhlIGhpZ2hlciBsZXZlbCBjb3ZlcmFnZSBvYmplY3Qgd2l0aCBtdWx0aXBsZSBrZXlzLlxuICpcbiAqIFdvcmtzIG9uIGBub2RlYCBhcyB3ZWxsIGFzIHRoZSBicm93c2VyLlxuICpcbiAqIFVzYWdlIG9uIG5vZGVqc1xuICogLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogICAgICB2YXIgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCdpc3RhbmJ1bCcpLnV0aWxzO1xuICpcbiAqIFVzYWdlIGluIGEgYnJvd3NlclxuICogLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogTG9hZCB0aGlzIGZpbGUgdXNpbmcgYSBgc2NyaXB0YCB0YWcgb3Igb3RoZXIgbWVhbnMuIFRoaXMgd2lsbCBzZXQgYHdpbmRvdy5jb3ZlcmFnZVV0aWxzYFxuICogdG8gdGhpcyBtb2R1bGUncyBleHBvcnRzLlxuICpcbiAqIEBjbGFzcyBPYmplY3RVdGlsc1xuICogQG1vZHVsZSBtYWluXG4gKiBAc3RhdGljXG4gKi9cbihmdW5jdGlvbiAoaXNOb2RlKSB7XG4gICAgLyoqXG4gICAgICogYWRkcyBsaW5lIGNvdmVyYWdlIGluZm9ybWF0aW9uIHRvIGEgZmlsZSBjb3ZlcmFnZSBvYmplY3QsIHJldmVyc2UtZW5naW5lZXJpbmdcbiAgICAgKiBpdCBmcm9tIHN0YXRlbWVudCBjb3ZlcmFnZS4gVGhlIG9iamVjdCBwYXNzZWQgaW4gaXMgdXBkYXRlZCBpbiBwbGFjZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBpZiBsaW5lIGNvdmVyYWdlIGluZm9ybWF0aW9uIGlzIGFscmVhZHkgcHJlc2VudCBpbiB0aGUgb2JqZWN0LFxuICAgICAqIGl0IGlzIG5vdCByZWNvbXB1dGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBhZGREZXJpdmVkSW5mb0ZvckZpbGVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZpbGVDb3ZlcmFnZSB0aGUgY292ZXJhZ2Ugb2JqZWN0IGZvciBhIHNpbmdsZSBmaWxlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkRGVyaXZlZEluZm9Gb3JGaWxlKGZpbGVDb3ZlcmFnZSkge1xuICAgICAgICB2YXIgc3RhdGVtZW50TWFwID0gZmlsZUNvdmVyYWdlLnN0YXRlbWVudE1hcCxcbiAgICAgICAgICAgIHN0YXRlbWVudHMgPSBmaWxlQ292ZXJhZ2UucyxcbiAgICAgICAgICAgIGxpbmVNYXA7XG5cbiAgICAgICAgaWYgKCFmaWxlQ292ZXJhZ2UubCkge1xuICAgICAgICAgICAgZmlsZUNvdmVyYWdlLmwgPSBsaW5lTWFwID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzdGF0ZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChzdCkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gc3RhdGVtZW50TWFwW3N0XS5zdGFydC5saW5lLFxuICAgICAgICAgICAgICAgICAgICBjb3VudCA9IHN0YXRlbWVudHNbc3RdLFxuICAgICAgICAgICAgICAgICAgICBwcmV2VmFsID0gbGluZU1hcFtsaW5lXTtcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IDAgJiYgc3RhdGVtZW50TWFwW3N0XS5za2lwKSB7IGNvdW50ID0gMTsgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJldlZhbCA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJldlZhbCA8IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVNYXBbbGluZV0gPSBjb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBhZGRzIGxpbmUgY292ZXJhZ2UgaW5mb3JtYXRpb24gdG8gYWxsIGZpbGUgY292ZXJhZ2Ugb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgYWRkRGVyaXZlZEluZm9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvdmVyYWdlIHRoZSBjb3ZlcmFnZSBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGREZXJpdmVkSW5mbyhjb3ZlcmFnZSkge1xuICAgICAgICBPYmplY3Qua2V5cyhjb3ZlcmFnZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgYWRkRGVyaXZlZEluZm9Gb3JGaWxlKGNvdmVyYWdlW2tdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJlbW92ZXMgbGluZSBjb3ZlcmFnZSBpbmZvcm1hdGlvbiBmcm9tIGFsbCBmaWxlIGNvdmVyYWdlIG9iamVjdHNcbiAgICAgKiBAbWV0aG9kIHJlbW92ZURlcml2ZWRJbmZvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb3ZlcmFnZSB0aGUgY292ZXJhZ2Ugb2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlRGVyaXZlZEluZm8oY292ZXJhZ2UpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoY292ZXJhZ2UpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb3ZlcmFnZVtrXS5sO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZXJjZW50KGNvdmVyZWQsIHRvdGFsKSB7XG4gICAgICAgIHZhciB0bXA7XG4gICAgICAgIGlmICh0b3RhbCA+IDApIHtcbiAgICAgICAgICAgIHRtcCA9IDEwMDAgKiAxMDAgKiBjb3ZlcmVkIC8gdG90YWwgKyA1O1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodG1wIC8gMTApIC8gMTAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDEwMC4wMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVTaW1wbGVUb3RhbHMoZmlsZUNvdmVyYWdlLCBwcm9wZXJ0eSwgbWFwUHJvcGVydHkpIHtcbiAgICAgICAgdmFyIHN0YXRzID0gZmlsZUNvdmVyYWdlW3Byb3BlcnR5XSxcbiAgICAgICAgICAgIG1hcCA9IG1hcFByb3BlcnR5ID8gZmlsZUNvdmVyYWdlW21hcFByb3BlcnR5XSA6IG51bGwsXG4gICAgICAgICAgICByZXQgPSB7IHRvdGFsOiAwLCBjb3ZlcmVkOiAwLCBza2lwcGVkOiAwIH07XG5cbiAgICAgICAgT2JqZWN0LmtleXMoc3RhdHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIGNvdmVyZWQgPSAhIXN0YXRzW2tleV0sXG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IG1hcCAmJiBtYXBba2V5XS5za2lwO1xuICAgICAgICAgICAgcmV0LnRvdGFsICs9IDE7XG4gICAgICAgICAgICBpZiAoY292ZXJlZCB8fCBza2lwcGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0LmNvdmVyZWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY292ZXJlZCAmJiBza2lwcGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0LnNraXBwZWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldC5wY3QgPSBwZXJjZW50KHJldC5jb3ZlcmVkLCByZXQudG90YWwpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVCcmFuY2hUb3RhbHMoZmlsZUNvdmVyYWdlKSB7XG4gICAgICAgIHZhciBzdGF0cyA9IGZpbGVDb3ZlcmFnZS5iLFxuICAgICAgICAgICAgYnJhbmNoTWFwID0gZmlsZUNvdmVyYWdlLmJyYW5jaE1hcCxcbiAgICAgICAgICAgIHJldCA9IHsgdG90YWw6IDAsIGNvdmVyZWQ6IDAsIHNraXBwZWQ6IDAgfTtcblxuICAgICAgICBPYmplY3Qua2V5cyhzdGF0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgYnJhbmNoZXMgPSBzdGF0c1trZXldLFxuICAgICAgICAgICAgICAgIG1hcCA9IGJyYW5jaE1hcFtrZXldLFxuICAgICAgICAgICAgICAgIGNvdmVyZWQsXG4gICAgICAgICAgICAgICAgc2tpcHBlZCxcbiAgICAgICAgICAgICAgICBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGJyYW5jaGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY292ZXJlZCA9IGJyYW5jaGVzW2ldID4gMDtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gbWFwLmxvY2F0aW9ucyAmJiBtYXAubG9jYXRpb25zW2ldICYmIG1hcC5sb2NhdGlvbnNbaV0uc2tpcDtcbiAgICAgICAgICAgICAgICBpZiAoY292ZXJlZCB8fCBza2lwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldC5jb3ZlcmVkICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY292ZXJlZCAmJiBza2lwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldC5za2lwcGVkICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0LnRvdGFsICs9IGJyYW5jaGVzLmxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldC5wY3QgPSBwZXJjZW50KHJldC5jb3ZlcmVkLCByZXQudG90YWwpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIGEgYmxhbmsgc3VtbWFyeSBtZXRyaWNzIG9iamVjdC4gQSBtZXRyaWNzIG9iamVjdCBoYXMgdGhlIGZvbGxvd2luZ1xuICAgICAqIGZvcm1hdC5cbiAgICAgKlxuICAgICAqICAgICAge1xuICAgICAqICAgICAgICAgIGxpbmVzOiBsaW5lTWV0cmljcyxcbiAgICAgKiAgICAgICAgICBzdGF0ZW1lbnRzOiBzdGF0ZW1lbnRNZXRyaWNzLFxuICAgICAqICAgICAgICAgIGZ1bmN0aW9uczogZnVuY3Rpb25NZXRyaWNzLFxuICAgICAqICAgICAgICAgIGJyYW5jaGVzOiBicmFuY2hNZXRyaWNzXG4gICAgICogICAgICAgICAgbGluZXNDb3ZlcmVkOiBsaW5lQ292ZXJlZENvdW50XG4gICAgICogICAgICB9XG4gICAgICpcbiAgICAgKiAgRWFjaCBpbmRpdmlkdWFsIG1ldHJpYyBvYmplY3QgbG9va3MgYXMgZm9sbG93czpcbiAgICAgKlxuICAgICAqICAgICAge1xuICAgICAqICAgICAgICAgIHRvdGFsOiBuLFxuICAgICAqICAgICAgICAgIGNvdmVyZWQ6IG0sXG4gICAgICogICAgICAgICAgcGN0OiBwZXJjZW50XG4gICAgICogICAgICB9XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGJsYW5rU3VtbWFyeVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGEgYmxhbmsgbWV0cmljcyBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBibGFua1N1bW1hcnkoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5lczoge1xuICAgICAgICAgICAgICAgIHRvdGFsOiAwLFxuICAgICAgICAgICAgICAgIGNvdmVyZWQ6IDAsXG4gICAgICAgICAgICAgICAgc2tpcHBlZDogMCxcbiAgICAgICAgICAgICAgICBwY3Q6ICdVbmtub3duJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXRlbWVudHM6IHtcbiAgICAgICAgICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgICAgICAgICBjb3ZlcmVkOiAwLFxuICAgICAgICAgICAgICAgIHNraXBwZWQ6IDAsXG4gICAgICAgICAgICAgICAgcGN0OiAnVW5rbm93bidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgICAgICAgICBjb3ZlcmVkOiAwLFxuICAgICAgICAgICAgICAgIHNraXBwZWQ6IDAsXG4gICAgICAgICAgICAgICAgcGN0OiAnVW5rbm93bidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBicmFuY2hlczoge1xuICAgICAgICAgICAgICAgIHRvdGFsOiAwLFxuICAgICAgICAgICAgICAgIGNvdmVyZWQ6IDAsXG4gICAgICAgICAgICAgICAgc2tpcHBlZDogMCxcbiAgICAgICAgICAgICAgICBwY3Q6ICdVbmtub3duJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVzQ292ZXJlZDoge31cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgc3VtbWFyeSBtZXRyaWNzIGdpdmVuIHRoZSBjb3ZlcmFnZSBvYmplY3QgZm9yIGEgc2luZ2xlIGZpbGUuIFNlZSBgYmxhbmtTdW1tYXJ5KClgXG4gICAgICogdG8gdW5kZXJzdGFuZCB0aGUgZm9ybWF0IG9mIHRoZSByZXR1cm5lZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHN1bW1hcml6ZUZpbGVDb3ZlcmFnZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZmlsZUNvdmVyYWdlIHRoZSBjb3ZlcmFnZSBvYmplY3QgZm9yIGEgc2luZ2xlIGZpbGUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgc3VtbWFyeSBtZXRyaWNzIGZvciB0aGUgZmlsZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1bW1hcml6ZUZpbGVDb3ZlcmFnZShmaWxlQ292ZXJhZ2UpIHtcbiAgICAgICAgdmFyIHJldCA9IGJsYW5rU3VtbWFyeSgpO1xuICAgICAgICBhZGREZXJpdmVkSW5mb0ZvckZpbGUoZmlsZUNvdmVyYWdlKTtcbiAgICAgICAgcmV0LmxpbmVzID0gY29tcHV0ZVNpbXBsZVRvdGFscyhmaWxlQ292ZXJhZ2UsICdsJyk7XG4gICAgICAgIHJldC5mdW5jdGlvbnMgPSBjb21wdXRlU2ltcGxlVG90YWxzKGZpbGVDb3ZlcmFnZSwgJ2YnLCAnZm5NYXAnKTtcbiAgICAgICAgcmV0LnN0YXRlbWVudHMgPSBjb21wdXRlU2ltcGxlVG90YWxzKGZpbGVDb3ZlcmFnZSwgJ3MnLCAnc3RhdGVtZW50TWFwJyk7XG4gICAgICAgIHJldC5icmFuY2hlcyA9IGNvbXB1dGVCcmFuY2hUb3RhbHMoZmlsZUNvdmVyYWdlKTtcbiAgICAgICAgcmV0LmxpbmVzQ292ZXJlZCA9IGZpbGVDb3ZlcmFnZS5sO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBtZXJnZXMgdHdvIGluc3RhbmNlcyBvZiBmaWxlIGNvdmVyYWdlIG9iamVjdHMgKmZvciB0aGUgc2FtZSBmaWxlKlxuICAgICAqIHN1Y2ggdGhhdCB0aGUgZXhlY3V0aW9uIGNvdW50cyBhcmUgY29ycmVjdC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgbWVyZ2VGaWxlQ292ZXJhZ2VcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZpcnN0IHRoZSBmaXJzdCBmaWxlIGNvdmVyYWdlIG9iamVjdCBmb3IgYSBnaXZlbiBmaWxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlY29uZCB0aGUgc2Vjb25kIGZpbGUgY292ZXJhZ2Ugb2JqZWN0IGZvciB0aGUgc2FtZSBmaWxlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBhbiBvYmplY3QgdGhhdCBpcyBhIHJlc3VsdCBvZiBtZXJnaW5nIHRoZSB0d28uIE5vdGUgdGhhdFxuICAgICAqICAgICAgdGhlIGlucHV0IG9iamVjdHMgYXJlIG5vdCBjaGFuZ2VkIGluIGFueSB3YXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VGaWxlQ292ZXJhZ2UoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICB2YXIgcmV0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShmaXJzdCkpLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBkZWxldGUgcmV0Lmw7IC8vcmVtb3ZlIGRlcml2ZWQgaW5mb1xuXG4gICAgICAgIE9iamVjdC5rZXlzKHNlY29uZC5zKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXQuc1trXSArPSBzZWNvbmQuc1trXTtcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5rZXlzKHNlY29uZC5mKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXQuZltrXSArPSBzZWNvbmQuZltrXTtcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5rZXlzKHNlY29uZC5iKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcmV0QXJyYXkgPSByZXQuYltrXSxcbiAgICAgICAgICAgICAgICBzZWNvbmRBcnJheSA9IHNlY29uZC5iW2tdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJldEFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyYXlbaV0gKz0gc2Vjb25kQXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG1lcmdlcyBtdWx0aXBsZSBzdW1tYXJ5IG1ldHJpY3Mgb2JqZWN0cyBieSBzdW1taW5nIHVwIHRoZSBgdG90YWxzYCBhbmRcbiAgICAgKiBgY292ZXJlZGAgZmllbGRzIGFuZCByZWNvbXB1dGluZyB0aGUgcGVyY2VudGFnZXMuIFRoaXMgZnVuY3Rpb24gaXMgZ2VuZXJpY1xuICAgICAqIGFuZCBjYW4gYWNjZXB0IGFueSBudW1iZXIgb2YgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBtZXJnZVN1bW1hcnlPYmplY3RzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdW1tYXJ5Li4uIG11bHRpcGxlIHN1bW1hcnkgbWV0cmljcyBvYmplY3RzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgbWVyZ2VkIHN1bW1hcnkgbWV0cmljc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlU3VtbWFyeU9iamVjdHMoKSB7XG4gICAgICAgIHZhciByZXQgPSBibGFua1N1bW1hcnkoKSxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAga2V5cyA9IFsnbGluZXMnLCAnc3RhdGVtZW50cycsICdicmFuY2hlcycsICdmdW5jdGlvbnMnXSxcbiAgICAgICAgICAgIGluY3JlbWVudCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRba2V5XS50b3RhbCArPSBvYmpba2V5XS50b3RhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldFtrZXldLmNvdmVyZWQgKz0gb2JqW2tleV0uY292ZXJlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldFtrZXldLnNraXBwZWQgKz0gb2JqW2tleV0uc2tpcHBlZDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBhbGwgbGluZXMgd2UgaGF2ZSBjb3ZlcmFnZSBmb3IuXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG9iai5saW5lc0NvdmVyZWQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXQubGluZXNDb3ZlcmVkW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQubGluZXNDb3ZlcmVkW2tleV0gPSBvYmoubGluZXNDb3ZlcmVkW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5saW5lc0NvdmVyZWRba2V5XSArPSBvYmoubGluZXNDb3ZlcmVkW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICBpbmNyZW1lbnQoYXJnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXRba2V5XS5wY3QgPSBwZXJjZW50KHJldFtrZXldLmNvdmVyZWQsIHJldFtrZXldLnRvdGFsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgY292ZXJhZ2Ugc3VtbWFyeSBmb3IgYSBzaW5nbGUgY292ZXJhZ2Ugb2JqZWN0LiBUaGlzIGlzXG4gICAgICogd3JhcHBlciBvdmVyIGBzdW1tYXJpemVGaWxlQ292ZXJhZ2VgIGFuZCBgbWVyZ2VTdW1tYXJ5T2JqZWN0c2AgZm9yXG4gICAgICogdGhlIGNvbW1vbiBjYXNlIG9mIGEgc2luZ2xlIGNvdmVyYWdlIG9iamVjdFxuICAgICAqIEBtZXRob2Qgc3VtbWFyaXplQ292ZXJhZ2VcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvdmVyYWdlICB0aGUgY292ZXJhZ2Ugb2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzdW1tYXJ5IGNvdmVyYWdlIG1ldHJpY3MgYWNyb3NzIGFsbCBmaWxlcyBpbiB0aGUgY292ZXJhZ2Ugb2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtbWFyaXplQ292ZXJhZ2UoY292ZXJhZ2UpIHtcbiAgICAgICAgdmFyIGZpbGVTdW1tYXJ5ID0gW107XG4gICAgICAgIE9iamVjdC5rZXlzKGNvdmVyYWdlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGZpbGVTdW1tYXJ5LnB1c2goc3VtbWFyaXplRmlsZUNvdmVyYWdlKGNvdmVyYWdlW2tleV0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZXJnZVN1bW1hcnlPYmplY3RzLmFwcGx5KG51bGwsIGZpbGVTdW1tYXJ5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtYWtlcyB0aGUgY292ZXJhZ2Ugb2JqZWN0IGdlbmVyYXRlZCBieSB0aGlzIGxpYnJhcnkgeXVpdGVzdF9jb3ZlcmFnZSBjb21wYXRpYmxlLlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIHRyYW5zZm9ybWF0aW9uIGlzIGxvc3N5IHNpbmNlIHRoZSByZXR1cm5lZCBvYmplY3Qgd2lsbCBub3QgaGF2ZVxuICAgICAqIHN0YXRlbWVudCBhbmQgYnJhbmNoIGNvdmVyYWdlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCB0b1lVSUNvdmVyYWdlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb3ZlcmFnZSBUaGUgYGlzdGFuYnVsYCBjb3ZlcmFnZSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGEgY292ZXJhZ2Ugb2JqZWN0IGluIGB5dWl0ZXN0X2NvdmVyYWdlYCBmb3JtYXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9ZVUlDb3ZlcmFnZShjb3ZlcmFnZSkge1xuICAgICAgICB2YXIgcmV0ID0ge307XG5cbiAgICAgICAgYWRkRGVyaXZlZEluZm8oY292ZXJhZ2UpO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKGNvdmVyYWdlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgZmlsZUNvdmVyYWdlID0gY292ZXJhZ2Vba10sXG4gICAgICAgICAgICAgICAgbGluZXMgPSBmaWxlQ292ZXJhZ2UubCxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbnMgPSBmaWxlQ292ZXJhZ2UuZixcbiAgICAgICAgICAgICAgICBmbk1hcCA9IGZpbGVDb3ZlcmFnZS5mbk1hcCxcbiAgICAgICAgICAgICAgICBvO1xuXG4gICAgICAgICAgICBvID0gcmV0W2tdID0ge1xuICAgICAgICAgICAgICAgIGxpbmVzOiB7fSxcbiAgICAgICAgICAgICAgICBjYWxsZWRMaW5lczogMCxcbiAgICAgICAgICAgICAgICBjb3ZlcmVkTGluZXM6IDAsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25zOiB7fSxcbiAgICAgICAgICAgICAgICBjYWxsZWRGdW5jdGlvbnM6IDAsXG4gICAgICAgICAgICAgICAgY292ZXJlZEZ1bmN0aW9uczogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGxpbmVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgby5saW5lc1trXSA9IGxpbmVzW2tdO1xuICAgICAgICAgICAgICAgIG8uY292ZXJlZExpbmVzICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzW2tdID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBvLmNhbGxlZExpbmVzICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhmdW5jdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGZuTWFwW2tdLm5hbWUgKyAnOicgKyBmbk1hcFtrXS5saW5lO1xuICAgICAgICAgICAgICAgIG8uZnVuY3Rpb25zW25hbWVdID0gZnVuY3Rpb25zW2tdO1xuICAgICAgICAgICAgICAgIG8uY292ZXJlZEZ1bmN0aW9ucyArPSAxO1xuICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbnNba10gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG8uY2FsbGVkRnVuY3Rpb25zICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IGZpbGUgY292ZXJhZ2Ugb2JqZWN0IHdpdGggaW5jcmVtZW50ZWQgaGl0cyBjb3VudFxuICAgICAqIG9uIHNraXBwZWQgc3RhdGVtZW50cywgYnJhbmNoZXMgYW5kIGZ1bmN0aW9uc1xuICAgICAqXG4gICAgICogQG1ldGhvZCBpbmNyZW1lbnRJZ25vcmVkVG90YWxzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb3YgRmlsZSBjb3ZlcmFnZSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE5ldyBmaWxlIGNvdmVyYWdlIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluY3JlbWVudElnbm9yZWRUb3RhbHMoY292KSB7XG4gICAgICAgIC8vVE9ETzogVGhpcyBtYXkgYmUgc2xvdyBpbiB0aGUgYnJvd3NlciBhbmQgbWF5IGJyZWFrIGluIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIC8vICAgICAgTG9vayBpbnRvIHVzaW5nIGEgbGlicmFyeSB0aGF0IHdvcmtzIGluIE5vZGUgYW5kIHRoZSBicm93c2VyXG4gICAgICAgIHZhciBmaWxlQ292ZXJhZ2UgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvdikpO1xuXG4gICAgICAgIFtcbiAgICAgICAgICAgIHttYXBLZXk6ICdzdGF0ZW1lbnRNYXAnLCBoaXRzS2V5OiAncyd9LFxuICAgICAgICAgICAge21hcEtleTogJ2JyYW5jaE1hcCcsIGhpdHNLZXk6ICdiJ30sXG4gICAgICAgICAgICB7bWFwS2V5OiAnZm5NYXAnLCBoaXRzS2V5OiAnZid9XG4gICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZmlsZUNvdmVyYWdlW2tleXMubWFwS2V5XSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXAgPSBmaWxlQ292ZXJhZ2Vba2V5cy5tYXBLZXldW2tleV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBoaXRzID0gZmlsZUNvdmVyYWdlW2tleXMuaGl0c0tleV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleXMubWFwS2V5ID09PSAnYnJhbmNoTWFwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9ucyA9IG1hcC5sb2NhdGlvbnM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChsb2NhdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGl0c1trZXldW2luZGV4XSA9PT0gMCAmJiBsb2NhdGlvbi5za2lwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdHNba2V5XVtpbmRleF0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaGl0c1trZXldID09PSAwICYmIG1hcC5za2lwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXRzW2tleV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZmlsZUNvdmVyYWdlO1xuICAgIH1cblxuICAgIHZhciBleHBvcnRhYmxlcyA9IHtcbiAgICAgICAgYWRkRGVyaXZlZEluZm86IGFkZERlcml2ZWRJbmZvLFxuICAgICAgICBhZGREZXJpdmVkSW5mb0ZvckZpbGU6IGFkZERlcml2ZWRJbmZvRm9yRmlsZSxcbiAgICAgICAgcmVtb3ZlRGVyaXZlZEluZm86IHJlbW92ZURlcml2ZWRJbmZvLFxuICAgICAgICBibGFua1N1bW1hcnk6IGJsYW5rU3VtbWFyeSxcbiAgICAgICAgc3VtbWFyaXplRmlsZUNvdmVyYWdlOiBzdW1tYXJpemVGaWxlQ292ZXJhZ2UsXG4gICAgICAgIHN1bW1hcml6ZUNvdmVyYWdlOiBzdW1tYXJpemVDb3ZlcmFnZSxcbiAgICAgICAgbWVyZ2VGaWxlQ292ZXJhZ2U6IG1lcmdlRmlsZUNvdmVyYWdlLFxuICAgICAgICBtZXJnZVN1bW1hcnlPYmplY3RzOiBtZXJnZVN1bW1hcnlPYmplY3RzLFxuICAgICAgICB0b1lVSUNvdmVyYWdlOiB0b1lVSUNvdmVyYWdlLFxuICAgICAgICBpbmNyZW1lbnRJZ25vcmVkVG90YWxzOiBpbmNyZW1lbnRJZ25vcmVkVG90YWxzXG4gICAgfTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiB3aW5kb3dzICovXG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGFibGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5jb3ZlcmFnZVV0aWxzID0gZXhwb3J0YWJsZXM7XG4gICAgfVxufSh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/lib/object-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/lib/register-plugins.js":
/*!**********************************************************!*\
  !*** ./node_modules/sc-istanbul/lib/register-plugins.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar Store = __webpack_require__(/*! ./store */ \"(ssr)/./node_modules/sc-istanbul/lib/store/index.js\"),\n    Report = __webpack_require__(/*! ./report */ \"(ssr)/./node_modules/sc-istanbul/lib/report/index.js\"),\n    Command = __webpack_require__(/*! ./command */ \"(ssr)/./node_modules/sc-istanbul/lib/command/index.js\");\n\nStore.loadAll();\nReport.loadAll();\nCommand.loadAll();\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL3JlZ2lzdGVyLXBsdWdpbnMuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLG9FQUFTO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyxzRUFBVTtBQUMvQixjQUFjLG1CQUFPLENBQUMsd0VBQVc7O0FBRWpDO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL3JlZ2lzdGVyLXBsdWdpbnMuanM/MGJlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4gQ29weXJpZ2h0IChjKSAyMDEyLCBZYWhvbyEgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbnZhciBTdG9yZSA9IHJlcXVpcmUoJy4vc3RvcmUnKSxcbiAgICBSZXBvcnQgPSByZXF1aXJlKCcuL3JlcG9ydCcpLFxuICAgIENvbW1hbmQgPSByZXF1aXJlKCcuL2NvbW1hbmQnKTtcblxuU3RvcmUubG9hZEFsbCgpO1xuUmVwb3J0LmxvYWRBbGwoKTtcbkNvbW1hbmQubG9hZEFsbCgpO1xuXG5cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/lib/register-plugins.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/lib/report/common/defaults.js":
/*!****************************************************************!*\
  !*** ./node_modules/sc-istanbul/lib/report/common/defaults.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n Copyright (c) 2013, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar Report  = __webpack_require__(/*! ../index */ \"(ssr)/./node_modules/sc-istanbul/lib/report/index.js\");\nvar supportsColor = __webpack_require__(/*! supports-color */ \"(ssr)/./node_modules/sc-istanbul/node_modules/supports-color/index.js\");\n\nmodule.exports = {\n    watermarks: function () {\n        return {\n            statements: [ 50, 80 ],\n            lines: [ 50, 80 ],\n            functions: [ 50, 80],\n            branches: [ 50, 80 ]\n        };\n    },\n\n    classFor: function (type, metrics, watermarks) {\n        var mark = watermarks[type],\n            value = metrics[type].pct;\n        return value >= mark[1] ? 'high' : value >= mark[0] ? 'medium' : 'low';\n    },\n\n    colorize: function (str, clazz) {\n        /* istanbul ignore if: untestable in batch mode */\n        var colors = {\n            low: '31;1',\n            medium: '33;1',\n            high: '32;1'\n        };\n        \n        if (supportsColor && colors[clazz]) {\n            return '\\u001b[' + colors[clazz] + 'm' + str + '\\u001b[0m';\n        }\n        return str;\n    },\n\n    defaultReportConfig: function () {\n        var cfg = {};\n        Report.getReportList().forEach(function (type) {\n            var rpt = Report.create(type),\n                c = rpt.getDefaultConfig();\n            if (c) {\n                cfg[type] = c;\n            }\n        });\n        return cfg;\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL3JlcG9ydC9jb21tb24vZGVmYXVsdHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLHNFQUFVO0FBQ2hDLG9CQUFvQixtQkFBTyxDQUFDLDZGQUFnQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQix3QkFBd0I7QUFDeEIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL3NjLWlzdGFuYnVsL2xpYi9yZXBvcnQvY29tbW9uL2RlZmF1bHRzLmpzP2NiYmMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiBDb3B5cmlnaHQgKGMpIDIwMTMsIFlhaG9vISBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xuXG52YXIgUmVwb3J0ICA9IHJlcXVpcmUoJy4uL2luZGV4Jyk7XG52YXIgc3VwcG9ydHNDb2xvciA9IHJlcXVpcmUoJ3N1cHBvcnRzLWNvbG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHdhdGVybWFya3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXRlbWVudHM6IFsgNTAsIDgwIF0sXG4gICAgICAgICAgICBsaW5lczogWyA1MCwgODAgXSxcbiAgICAgICAgICAgIGZ1bmN0aW9uczogWyA1MCwgODBdLFxuICAgICAgICAgICAgYnJhbmNoZXM6IFsgNTAsIDgwIF1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgY2xhc3NGb3I6IGZ1bmN0aW9uICh0eXBlLCBtZXRyaWNzLCB3YXRlcm1hcmtzKSB7XG4gICAgICAgIHZhciBtYXJrID0gd2F0ZXJtYXJrc1t0eXBlXSxcbiAgICAgICAgICAgIHZhbHVlID0gbWV0cmljc1t0eXBlXS5wY3Q7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSBtYXJrWzFdID8gJ2hpZ2gnIDogdmFsdWUgPj0gbWFya1swXSA/ICdtZWRpdW0nIDogJ2xvdyc7XG4gICAgfSxcblxuICAgIGNvbG9yaXplOiBmdW5jdGlvbiAoc3RyLCBjbGF6eikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IHVudGVzdGFibGUgaW4gYmF0Y2ggbW9kZSAqL1xuICAgICAgICB2YXIgY29sb3JzID0ge1xuICAgICAgICAgICAgbG93OiAnMzE7MScsXG4gICAgICAgICAgICBtZWRpdW06ICczMzsxJyxcbiAgICAgICAgICAgIGhpZ2g6ICczMjsxJ1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgaWYgKHN1cHBvcnRzQ29sb3IgJiYgY29sb3JzW2NsYXp6XSkge1xuICAgICAgICAgICAgcmV0dXJuICdcXHUwMDFiWycgKyBjb2xvcnNbY2xhenpdICsgJ20nICsgc3RyICsgJ1xcdTAwMWJbMG0nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuICAgIGRlZmF1bHRSZXBvcnRDb25maWc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNmZyA9IHt9O1xuICAgICAgICBSZXBvcnQuZ2V0UmVwb3J0TGlzdCgpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIHZhciBycHQgPSBSZXBvcnQuY3JlYXRlKHR5cGUpLFxuICAgICAgICAgICAgICAgIGMgPSBycHQuZ2V0RGVmYXVsdENvbmZpZygpO1xuICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICBjZmdbdHlwZV0gPSBjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNmZztcbiAgICB9XG59O1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/lib/report/common/defaults.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/lib/report/index.js":
/*!******************************************************!*\
  !*** ./node_modules/sc-istanbul/lib/report/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar util = __webpack_require__(/*! util */ \"util\"),\n    EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter),\n    Factory = __webpack_require__(/*! ../util/factory */ \"(ssr)/./node_modules/sc-istanbul/lib/util/factory.js\"),\n    factory = new Factory('report', __dirname, false);\n/**\n * An abstraction for producing coverage reports.\n * This class is both the base class as well as a factory for `Report` implementations.\n * All reports are event emitters and are expected to emit a `done` event when\n * the report writing is complete.\n *\n * See also the `Reporter` class for easily producing multiple coverage reports\n * with a single call.\n *\n * Usage\n * -----\n *\n *      var Report = require('istanbul').Report,\n *          report = Report.create('html'),\n *          collector = new require('istanbul').Collector;\n *\n *      collector.add(coverageObject);\n *      report.on('done', function () { console.log('done'); });\n *      report.writeReport(collector);\n *\n * @class Report\n * @module report\n * @main report\n * @constructor\n * @protected\n * @param {Object} options Optional. The options supported by a specific store implementation.\n */\nfunction Report(/* options */) {\n    EventEmitter.call(this);\n}\n\nutil.inherits(Report, EventEmitter);\n\n//add register, create, mix, loadAll, getReportList as class methods\nfactory.bindClassMethods(Report);\n\n/**\n * registers a new report implementation.\n * @method register\n * @static\n * @param {Function} constructor the constructor function for the report. This function must have a\n *  `TYPE` property of type String, that will be used in `Report.create()`\n */\n/**\n * returns a report implementation of the specified type.\n * @method create\n * @static\n * @param {String} type the type of report to create\n * @param {Object} opts Optional. Options specific to the report implementation\n * @return {Report} a new store of the specified type\n */\n/**\n * returns the list of available reports as an array of strings\n * @method getReportList\n * @static\n * @return an array of supported report formats\n */\n\nvar proto = {\n    /**\n     * returns a one-line summary of the report\n     * @method synopsis\n     * @return {String} a description of what the report is about\n     */\n    synopsis: function () {\n        throw new Error('synopsis must be overridden');\n    },\n    /**\n     * returns a config object that has override-able keys settable via config\n     * @method getDefaultConfig\n     * @return {Object|null} an object representing keys that can be overridden via\n     *  the istanbul configuration where the values are the defaults used when\n     *  not specified. A null return implies no config attributes\n     */\n    getDefaultConfig: function () {\n        return null;\n    },\n    /**\n     * writes the report for a set of coverage objects added to a collector.\n     * @method writeReport\n     * @param {Collector} collector the collector for getting the set of files and coverage\n     * @param {Boolean} sync true if reports must be written synchronously, false if they can be written using asynchronous means (e.g. stream.write)\n     */\n    writeReport: function (/* collector, sync */) {\n        throw new Error('writeReport: must be overridden');\n    }\n};\n\nObject.keys(proto).forEach(function (k) {\n    Report.prototype[k] = proto[k];\n});\n\nmodule.exports = Report;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL3JlcG9ydC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsbUJBQW1CLDBEQUE4QjtBQUNqRCxjQUFjLG1CQUFPLENBQUMsNkVBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL3JlcG9ydC9pbmRleC5qcz9hYTNmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gQ29weXJpZ2h0IChjKSAyMDEyLCBZYWhvbyEgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyksXG4gICAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyLFxuICAgIEZhY3RvcnkgPSByZXF1aXJlKCcuLi91dGlsL2ZhY3RvcnknKSxcbiAgICBmYWN0b3J5ID0gbmV3IEZhY3RvcnkoJ3JlcG9ydCcsIF9fZGlybmFtZSwgZmFsc2UpO1xuLyoqXG4gKiBBbiBhYnN0cmFjdGlvbiBmb3IgcHJvZHVjaW5nIGNvdmVyYWdlIHJlcG9ydHMuXG4gKiBUaGlzIGNsYXNzIGlzIGJvdGggdGhlIGJhc2UgY2xhc3MgYXMgd2VsbCBhcyBhIGZhY3RvcnkgZm9yIGBSZXBvcnRgIGltcGxlbWVudGF0aW9ucy5cbiAqIEFsbCByZXBvcnRzIGFyZSBldmVudCBlbWl0dGVycyBhbmQgYXJlIGV4cGVjdGVkIHRvIGVtaXQgYSBgZG9uZWAgZXZlbnQgd2hlblxuICogdGhlIHJlcG9ydCB3cml0aW5nIGlzIGNvbXBsZXRlLlxuICpcbiAqIFNlZSBhbHNvIHRoZSBgUmVwb3J0ZXJgIGNsYXNzIGZvciBlYXNpbHkgcHJvZHVjaW5nIG11bHRpcGxlIGNvdmVyYWdlIHJlcG9ydHNcbiAqIHdpdGggYSBzaW5nbGUgY2FsbC5cbiAqXG4gKiBVc2FnZVxuICogLS0tLS1cbiAqXG4gKiAgICAgIHZhciBSZXBvcnQgPSByZXF1aXJlKCdpc3RhbmJ1bCcpLlJlcG9ydCxcbiAqICAgICAgICAgIHJlcG9ydCA9IFJlcG9ydC5jcmVhdGUoJ2h0bWwnKSxcbiAqICAgICAgICAgIGNvbGxlY3RvciA9IG5ldyByZXF1aXJlKCdpc3RhbmJ1bCcpLkNvbGxlY3RvcjtcbiAqXG4gKiAgICAgIGNvbGxlY3Rvci5hZGQoY292ZXJhZ2VPYmplY3QpO1xuICogICAgICByZXBvcnQub24oJ2RvbmUnLCBmdW5jdGlvbiAoKSB7IGNvbnNvbGUubG9nKCdkb25lJyk7IH0pO1xuICogICAgICByZXBvcnQud3JpdGVSZXBvcnQoY29sbGVjdG9yKTtcbiAqXG4gKiBAY2xhc3MgUmVwb3J0XG4gKiBAbW9kdWxlIHJlcG9ydFxuICogQG1haW4gcmVwb3J0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbmFsLiBUaGUgb3B0aW9ucyBzdXBwb3J0ZWQgYnkgYSBzcGVjaWZpYyBzdG9yZSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gUmVwb3J0KC8qIG9wdGlvbnMgKi8pIHtcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbn1cblxudXRpbC5pbmhlcml0cyhSZXBvcnQsIEV2ZW50RW1pdHRlcik7XG5cbi8vYWRkIHJlZ2lzdGVyLCBjcmVhdGUsIG1peCwgbG9hZEFsbCwgZ2V0UmVwb3J0TGlzdCBhcyBjbGFzcyBtZXRob2RzXG5mYWN0b3J5LmJpbmRDbGFzc01ldGhvZHMoUmVwb3J0KTtcblxuLyoqXG4gKiByZWdpc3RlcnMgYSBuZXcgcmVwb3J0IGltcGxlbWVudGF0aW9uLlxuICogQG1ldGhvZCByZWdpc3RlclxuICogQHN0YXRpY1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3IgdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgcmVwb3J0LiBUaGlzIGZ1bmN0aW9uIG11c3QgaGF2ZSBhXG4gKiAgYFRZUEVgIHByb3BlcnR5IG9mIHR5cGUgU3RyaW5nLCB0aGF0IHdpbGwgYmUgdXNlZCBpbiBgUmVwb3J0LmNyZWF0ZSgpYFxuICovXG4vKipcbiAqIHJldHVybnMgYSByZXBvcnQgaW1wbGVtZW50YXRpb24gb2YgdGhlIHNwZWNpZmllZCB0eXBlLlxuICogQG1ldGhvZCBjcmVhdGVcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIHJlcG9ydCB0byBjcmVhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsLiBPcHRpb25zIHNwZWNpZmljIHRvIHRoZSByZXBvcnQgaW1wbGVtZW50YXRpb25cbiAqIEByZXR1cm4ge1JlcG9ydH0gYSBuZXcgc3RvcmUgb2YgdGhlIHNwZWNpZmllZCB0eXBlXG4gKi9cbi8qKlxuICogcmV0dXJucyB0aGUgbGlzdCBvZiBhdmFpbGFibGUgcmVwb3J0cyBhcyBhbiBhcnJheSBvZiBzdHJpbmdzXG4gKiBAbWV0aG9kIGdldFJlcG9ydExpc3RcbiAqIEBzdGF0aWNcbiAqIEByZXR1cm4gYW4gYXJyYXkgb2Ygc3VwcG9ydGVkIHJlcG9ydCBmb3JtYXRzXG4gKi9cblxudmFyIHByb3RvID0ge1xuICAgIC8qKlxuICAgICAqIHJldHVybnMgYSBvbmUtbGluZSBzdW1tYXJ5IG9mIHRoZSByZXBvcnRcbiAgICAgKiBAbWV0aG9kIHN5bm9wc2lzXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBhIGRlc2NyaXB0aW9uIG9mIHdoYXQgdGhlIHJlcG9ydCBpcyBhYm91dFxuICAgICAqL1xuICAgIHN5bm9wc2lzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3lub3BzaXMgbXVzdCBiZSBvdmVycmlkZGVuJyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZXR1cm5zIGEgY29uZmlnIG9iamVjdCB0aGF0IGhhcyBvdmVycmlkZS1hYmxlIGtleXMgc2V0dGFibGUgdmlhIGNvbmZpZ1xuICAgICAqIEBtZXRob2QgZ2V0RGVmYXVsdENvbmZpZ1xuICAgICAqIEByZXR1cm4ge09iamVjdHxudWxsfSBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGtleXMgdGhhdCBjYW4gYmUgb3ZlcnJpZGRlbiB2aWFcbiAgICAgKiAgdGhlIGlzdGFuYnVsIGNvbmZpZ3VyYXRpb24gd2hlcmUgdGhlIHZhbHVlcyBhcmUgdGhlIGRlZmF1bHRzIHVzZWQgd2hlblxuICAgICAqICBub3Qgc3BlY2lmaWVkLiBBIG51bGwgcmV0dXJuIGltcGxpZXMgbm8gY29uZmlnIGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICBnZXREZWZhdWx0Q29uZmlnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogd3JpdGVzIHRoZSByZXBvcnQgZm9yIGEgc2V0IG9mIGNvdmVyYWdlIG9iamVjdHMgYWRkZWQgdG8gYSBjb2xsZWN0b3IuXG4gICAgICogQG1ldGhvZCB3cml0ZVJlcG9ydFxuICAgICAqIEBwYXJhbSB7Q29sbGVjdG9yfSBjb2xsZWN0b3IgdGhlIGNvbGxlY3RvciBmb3IgZ2V0dGluZyB0aGUgc2V0IG9mIGZpbGVzIGFuZCBjb3ZlcmFnZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3luYyB0cnVlIGlmIHJlcG9ydHMgbXVzdCBiZSB3cml0dGVuIHN5bmNocm9ub3VzbHksIGZhbHNlIGlmIHRoZXkgY2FuIGJlIHdyaXR0ZW4gdXNpbmcgYXN5bmNocm9ub3VzIG1lYW5zIChlLmcuIHN0cmVhbS53cml0ZSlcbiAgICAgKi9cbiAgICB3cml0ZVJlcG9ydDogZnVuY3Rpb24gKC8qIGNvbGxlY3Rvciwgc3luYyAqLykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyaXRlUmVwb3J0OiBtdXN0IGJlIG92ZXJyaWRkZW4nKTtcbiAgICB9XG59O1xuXG5PYmplY3Qua2V5cyhwcm90bykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIFJlcG9ydC5wcm90b3R5cGVba10gPSBwcm90b1trXTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcG9ydDtcblxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/lib/report/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/lib/reporter.js":
/*!**************************************************!*\
  !*** ./node_modules/sc-istanbul/lib/reporter.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n Copyright (c) 2014, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar Report = __webpack_require__(/*! ./report */ \"(ssr)/./node_modules/sc-istanbul/lib/report/index.js\"),\n    configuration = __webpack_require__(/*! ./config */ \"(ssr)/./node_modules/sc-istanbul/lib/config.js\"),\n    inputError = __webpack_require__(/*! ./util/input-error */ \"(ssr)/./node_modules/sc-istanbul/lib/util/input-error.js\");\n\n/**\n * convenience mechanism to write one or more reports ensuring that config\n * options are respected.\n * Usage\n * -----\n *\n *      var fs = require('fs'),\n *          reporter = new require('istanbul').Reporter(),\n *          collector = new require('istanbul').Collector(),\n *          sync = true;\n *\n *      collector.add(JSON.parse(fs.readFileSync('coverage.json', 'utf8')));\n *      reporter.add('lcovonly');\n *      reporter.addAll(['clover', 'cobertura']);\n *      reporter.write(collector, sync, function () { console.log('done'); });\n *\n * @class Reporter\n * @param {Configuration} cfg  the config object, a falsy value will load the\n *  default configuration instead\n * @param {String} dir  the directory in which to write the reports, may be falsy\n *  to use config or global defaults\n * @constructor\n * @module main\n */\nfunction Reporter(cfg, dir) {\n    this.config = cfg || configuration.loadFile();\n    this.dir = dir || this.config.reporting.dir();\n    this.reports = {};\n}\n\nReporter.prototype = {\n    /**\n     * adds a report to be generated. Must be one of the entries returned\n     * by `Report.getReportList()`\n     * @method add\n     * @param {String} fmt the format of the report to generate\n     */\n    add: function (fmt) {\n        if (this.reports[fmt]) { // already added\n            return;\n        }\n        var config = this.config,\n            rptConfig = config.reporting.reportConfig()[fmt] || {};\n        rptConfig.verbose = config.verbose;\n        rptConfig.dir = this.dir;\n        rptConfig.watermarks = config.reporting.watermarks();\n        try {\n            this.reports[fmt] = Report.create(fmt, rptConfig);\n        } catch (ex) {\n            throw inputError.create('Invalid report format [' + fmt + ']');\n        }\n    },\n    /**\n     * adds an array of report formats to be generated\n     * @method addAll\n     * @param {Array} fmts an array of report formats\n     */\n    addAll: function (fmts) {\n        var that = this;\n        fmts.forEach(function (f) {\n            that.add(f);\n        });\n    },\n    /**\n     * writes all reports added and calls the callback when done\n     * @method write\n     * @param {Collector} collector the collector having the coverage data\n     * @param {Boolean} sync true to write reports synchronously\n     * @param {Function} callback the callback to call when done. When `sync`\n     * is true, the callback will be called in the same process tick.\n     */\n    write: function (collector, sync, callback) {\n        var reports = this.reports,\n            verbose = this.config.verbose,\n            handler = this.handleDone.bind(this, callback);\n\n        this.inProgress = Object.keys(reports).length;\n\n        Object.keys(reports).forEach(function (name) {\n            var report = reports[name];\n            if (verbose) {\n                console.error('Write report: ' + name);\n            }\n            report.on('done', handler);\n            report.writeReport(collector, sync);\n        });\n    },\n    /*\n     * handles listening on all reports to be completed before calling the callback\n     * @method handleDone\n     * @private\n     * @param {Function} callback the callback to call when all reports are\n     * written\n     */\n    handleDone: function (callback) {\n        this.inProgress -= 1;\n        if (this.inProgress === 0) {\n            return callback();\n        }\n    }\n};\n\nmodule.exports = Reporter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL3JlcG9ydGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHNFQUFVO0FBQy9CLG9CQUFvQixtQkFBTyxDQUFDLGdFQUFVO0FBQ3RDLGlCQUFpQixtQkFBTyxDQUFDLG9GQUFvQjs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxzQkFBc0I7QUFDNUU7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL3JlcG9ydGVyLmpzPzMxNDIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiBDb3B5cmlnaHQgKGMpIDIwMTQsIFlhaG9vISBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xudmFyIFJlcG9ydCA9IHJlcXVpcmUoJy4vcmVwb3J0JyksXG4gICAgY29uZmlndXJhdGlvbiA9IHJlcXVpcmUoJy4vY29uZmlnJyksXG4gICAgaW5wdXRFcnJvciA9IHJlcXVpcmUoJy4vdXRpbC9pbnB1dC1lcnJvcicpO1xuXG4vKipcbiAqIGNvbnZlbmllbmNlIG1lY2hhbmlzbSB0byB3cml0ZSBvbmUgb3IgbW9yZSByZXBvcnRzIGVuc3VyaW5nIHRoYXQgY29uZmlnXG4gKiBvcHRpb25zIGFyZSByZXNwZWN0ZWQuXG4gKiBVc2FnZVxuICogLS0tLS1cbiAqXG4gKiAgICAgIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyksXG4gKiAgICAgICAgICByZXBvcnRlciA9IG5ldyByZXF1aXJlKCdpc3RhbmJ1bCcpLlJlcG9ydGVyKCksXG4gKiAgICAgICAgICBjb2xsZWN0b3IgPSBuZXcgcmVxdWlyZSgnaXN0YW5idWwnKS5Db2xsZWN0b3IoKSxcbiAqICAgICAgICAgIHN5bmMgPSB0cnVlO1xuICpcbiAqICAgICAgY29sbGVjdG9yLmFkZChKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYygnY292ZXJhZ2UuanNvbicsICd1dGY4JykpKTtcbiAqICAgICAgcmVwb3J0ZXIuYWRkKCdsY292b25seScpO1xuICogICAgICByZXBvcnRlci5hZGRBbGwoWydjbG92ZXInLCAnY29iZXJ0dXJhJ10pO1xuICogICAgICByZXBvcnRlci53cml0ZShjb2xsZWN0b3IsIHN5bmMsIGZ1bmN0aW9uICgpIHsgY29uc29sZS5sb2coJ2RvbmUnKTsgfSk7XG4gKlxuICogQGNsYXNzIFJlcG9ydGVyXG4gKiBAcGFyYW0ge0NvbmZpZ3VyYXRpb259IGNmZyAgdGhlIGNvbmZpZyBvYmplY3QsIGEgZmFsc3kgdmFsdWUgd2lsbCBsb2FkIHRoZVxuICogIGRlZmF1bHQgY29uZmlndXJhdGlvbiBpbnN0ZWFkXG4gKiBAcGFyYW0ge1N0cmluZ30gZGlyICB0aGUgZGlyZWN0b3J5IGluIHdoaWNoIHRvIHdyaXRlIHRoZSByZXBvcnRzLCBtYXkgYmUgZmFsc3lcbiAqICB0byB1c2UgY29uZmlnIG9yIGdsb2JhbCBkZWZhdWx0c1xuICogQGNvbnN0cnVjdG9yXG4gKiBAbW9kdWxlIG1haW5cbiAqL1xuZnVuY3Rpb24gUmVwb3J0ZXIoY2ZnLCBkaXIpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNmZyB8fCBjb25maWd1cmF0aW9uLmxvYWRGaWxlKCk7XG4gICAgdGhpcy5kaXIgPSBkaXIgfHwgdGhpcy5jb25maWcucmVwb3J0aW5nLmRpcigpO1xuICAgIHRoaXMucmVwb3J0cyA9IHt9O1xufVxuXG5SZXBvcnRlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogYWRkcyBhIHJlcG9ydCB0byBiZSBnZW5lcmF0ZWQuIE11c3QgYmUgb25lIG9mIHRoZSBlbnRyaWVzIHJldHVybmVkXG4gICAgICogYnkgYFJlcG9ydC5nZXRSZXBvcnRMaXN0KClgXG4gICAgICogQG1ldGhvZCBhZGRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZm10IHRoZSBmb3JtYXQgb2YgdGhlIHJlcG9ydCB0byBnZW5lcmF0ZVxuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24gKGZtdCkge1xuICAgICAgICBpZiAodGhpcy5yZXBvcnRzW2ZtdF0pIHsgLy8gYWxyZWFkeSBhZGRlZFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgICAgIHJwdENvbmZpZyA9IGNvbmZpZy5yZXBvcnRpbmcucmVwb3J0Q29uZmlnKClbZm10XSB8fCB7fTtcbiAgICAgICAgcnB0Q29uZmlnLnZlcmJvc2UgPSBjb25maWcudmVyYm9zZTtcbiAgICAgICAgcnB0Q29uZmlnLmRpciA9IHRoaXMuZGlyO1xuICAgICAgICBycHRDb25maWcud2F0ZXJtYXJrcyA9IGNvbmZpZy5yZXBvcnRpbmcud2F0ZXJtYXJrcygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRzW2ZtdF0gPSBSZXBvcnQuY3JlYXRlKGZtdCwgcnB0Q29uZmlnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHRocm93IGlucHV0RXJyb3IuY3JlYXRlKCdJbnZhbGlkIHJlcG9ydCBmb3JtYXQgWycgKyBmbXQgKyAnXScpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBhZGRzIGFuIGFycmF5IG9mIHJlcG9ydCBmb3JtYXRzIHRvIGJlIGdlbmVyYXRlZFxuICAgICAqIEBtZXRob2QgYWRkQWxsXG4gICAgICogQHBhcmFtIHtBcnJheX0gZm10cyBhbiBhcnJheSBvZiByZXBvcnQgZm9ybWF0c1xuICAgICAqL1xuICAgIGFkZEFsbDogZnVuY3Rpb24gKGZtdHMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBmbXRzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIHRoYXQuYWRkKGYpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHdyaXRlcyBhbGwgcmVwb3J0cyBhZGRlZCBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrIHdoZW4gZG9uZVxuICAgICAqIEBtZXRob2Qgd3JpdGVcbiAgICAgKiBAcGFyYW0ge0NvbGxlY3Rvcn0gY29sbGVjdG9yIHRoZSBjb2xsZWN0b3IgaGF2aW5nIHRoZSBjb3ZlcmFnZSBkYXRhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzeW5jIHRydWUgdG8gd3JpdGUgcmVwb3J0cyBzeW5jaHJvbm91c2x5XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbiBkb25lLiBXaGVuIGBzeW5jYFxuICAgICAqIGlzIHRydWUsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgc2FtZSBwcm9jZXNzIHRpY2suXG4gICAgICovXG4gICAgd3JpdGU6IGZ1bmN0aW9uIChjb2xsZWN0b3IsIHN5bmMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXBvcnRzID0gdGhpcy5yZXBvcnRzLFxuICAgICAgICAgICAgdmVyYm9zZSA9IHRoaXMuY29uZmlnLnZlcmJvc2UsXG4gICAgICAgICAgICBoYW5kbGVyID0gdGhpcy5oYW5kbGVEb25lLmJpbmQodGhpcywgY2FsbGJhY2spO1xuXG4gICAgICAgIHRoaXMuaW5Qcm9ncmVzcyA9IE9iamVjdC5rZXlzKHJlcG9ydHMpLmxlbmd0aDtcblxuICAgICAgICBPYmplY3Qua2V5cyhyZXBvcnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgcmVwb3J0ID0gcmVwb3J0c1tuYW1lXTtcbiAgICAgICAgICAgIGlmICh2ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignV3JpdGUgcmVwb3J0OiAnICsgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXBvcnQub24oJ2RvbmUnLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIHJlcG9ydC53cml0ZVJlcG9ydChjb2xsZWN0b3IsIHN5bmMpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIC8qXG4gICAgICogaGFuZGxlcyBsaXN0ZW5pbmcgb24gYWxsIHJlcG9ydHMgdG8gYmUgY29tcGxldGVkIGJlZm9yZSBjYWxsaW5nIHRoZSBjYWxsYmFja1xuICAgICAqIEBtZXRob2QgaGFuZGxlRG9uZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbiBhbGwgcmVwb3J0cyBhcmVcbiAgICAgKiB3cml0dGVuXG4gICAgICovXG4gICAgaGFuZGxlRG9uZTogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuaW5Qcm9ncmVzcyAtPSAxO1xuICAgICAgICBpZiAodGhpcy5pblByb2dyZXNzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVwb3J0ZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/lib/reporter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/lib/store/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/sc-istanbul/lib/store/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar Factory = __webpack_require__(/*! ../util/factory */ \"(ssr)/./node_modules/sc-istanbul/lib/util/factory.js\"),\n    factory = new Factory('store', __dirname, false);\n/**\n * An abstraction for keeping track of content against some keys (e.g.\n * original source, instrumented source, coverage objects against file names).\n * This class is both the base class as well as a factory for `Store` implementations.\n *\n * Usage\n * -----\n *\n *      var Store = require('istanbul').Store,\n *          store = Store.create('memory');\n *\n *      //basic use\n *      store.set('foo', 'foo-content');\n *      var content = store.get('foo');\n *\n *      //keys and values\n *      store.keys().forEach(function (key) {\n *          console.log(key + ':\\n' + store.get(key);\n *      });\n *      if (store.hasKey('bar') { console.log(store.get('bar'); }\n *\n *\n *      //syntactic sugar\n *      store.setObject('foo', { foo: true });\n *      console.log(store.getObject('foo').foo);\n *\n *      store.dispose();\n *\n * @class Store\n * @constructor\n * @module store\n * @param {Object} options Optional. The options supported by a specific store implementation.\n * @main store\n */\nfunction Store(/* options */) {}\n\n//add register, create, mix, loadAll, getStoreList as class methods\nfactory.bindClassMethods(Store);\n\n/**\n * registers a new store implementation.\n * @method register\n * @static\n * @param {Function} constructor the constructor function for the store. This function must have a\n *  `TYPE` property of type String, that will be used in `Store.create()`\n */\n/**\n * returns a store implementation of the specified type.\n * @method create\n * @static\n * @param {String} type the type of store to create\n * @param {Object} opts Optional. Options specific to the store implementation\n * @return {Store} a new store of the specified type\n */\n\nStore.prototype = {\n    /**\n     * sets some content associated with a specific key. The manner in which\n     * duplicate keys are handled for multiple `set()` calls with the same\n     * key is implementation-specific.\n     *\n     * @method set\n     * @param {String} key the key for the content\n     * @param {String} contents the contents for the key\n     */\n    set: function (/* key, contents */) { throw new Error(\"set: must be overridden\"); },\n    /**\n     * returns the content associated to a specific key or throws if the key\n     * was not `set`\n     * @method get\n     * @param {String} key the key for which to get the content\n     * @return {String} the content for the specified key\n     */\n    get: function (/* key */) { throw new Error(\"get: must be overridden\"); },\n    /**\n     * returns a list of all known keys\n     * @method keys\n     * @return {Array} an array of seen keys\n     */\n    keys: function () { throw new Error(\"keys: must be overridden\"); },\n    /**\n     * returns true if the key is one for which a `get()` call would work.\n     * @method hasKey\n     * @param {String} key\n     * @return true if the key is valid for this store, false otherwise\n     */\n    hasKey: function (/* key */) { throw new Error(\"hasKey: must be overridden\"); },\n    /**\n     * lifecycle method to dispose temporary resources associated with the store\n     * @method dispose\n     */\n    dispose: function () {},\n    /**\n     * sugar method to return an object associated with a specific key. Throws\n     * if the content set against the key was not a valid JSON string.\n     * @method getObject\n     * @param {String} key the key for which to return the associated object\n     * @return {Object} the object corresponding to the key\n     */\n    getObject: function (key) {\n        return JSON.parse(this.get(key));\n    },\n    /**\n     * sugar method to set an object against a specific key.\n     * @method setObject\n     * @param {String} key the key for the object\n     * @param {Object} object the object to be stored\n     */\n    setObject: function (key, object) {\n        return this.set(key, JSON.stringify(object));\n    }\n};\n\nmodule.exports = Store;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL3N0b3JlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyw2RUFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxXQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLDBDQUEwQyw2Q0FBNkM7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSxnQ0FBZ0MsNkNBQTZDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0Esd0JBQXdCLDhDQUE4QztBQUN0RTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLG1DQUFtQyxnREFBZ0Q7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL3N0b3JlL2luZGV4LmpzPzg5NGQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiBDb3B5cmlnaHQgKGMpIDIwMTIsIFlhaG9vISBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xuXG52YXIgRmFjdG9yeSA9IHJlcXVpcmUoJy4uL3V0aWwvZmFjdG9yeScpLFxuICAgIGZhY3RvcnkgPSBuZXcgRmFjdG9yeSgnc3RvcmUnLCBfX2Rpcm5hbWUsIGZhbHNlKTtcbi8qKlxuICogQW4gYWJzdHJhY3Rpb24gZm9yIGtlZXBpbmcgdHJhY2sgb2YgY29udGVudCBhZ2FpbnN0IHNvbWUga2V5cyAoZS5nLlxuICogb3JpZ2luYWwgc291cmNlLCBpbnN0cnVtZW50ZWQgc291cmNlLCBjb3ZlcmFnZSBvYmplY3RzIGFnYWluc3QgZmlsZSBuYW1lcykuXG4gKiBUaGlzIGNsYXNzIGlzIGJvdGggdGhlIGJhc2UgY2xhc3MgYXMgd2VsbCBhcyBhIGZhY3RvcnkgZm9yIGBTdG9yZWAgaW1wbGVtZW50YXRpb25zLlxuICpcbiAqIFVzYWdlXG4gKiAtLS0tLVxuICpcbiAqICAgICAgdmFyIFN0b3JlID0gcmVxdWlyZSgnaXN0YW5idWwnKS5TdG9yZSxcbiAqICAgICAgICAgIHN0b3JlID0gU3RvcmUuY3JlYXRlKCdtZW1vcnknKTtcbiAqXG4gKiAgICAgIC8vYmFzaWMgdXNlXG4gKiAgICAgIHN0b3JlLnNldCgnZm9vJywgJ2Zvby1jb250ZW50Jyk7XG4gKiAgICAgIHZhciBjb250ZW50ID0gc3RvcmUuZ2V0KCdmb28nKTtcbiAqXG4gKiAgICAgIC8va2V5cyBhbmQgdmFsdWVzXG4gKiAgICAgIHN0b3JlLmtleXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAqICAgICAgICAgIGNvbnNvbGUubG9nKGtleSArICc6XFxuJyArIHN0b3JlLmdldChrZXkpO1xuICogICAgICB9KTtcbiAqICAgICAgaWYgKHN0b3JlLmhhc0tleSgnYmFyJykgeyBjb25zb2xlLmxvZyhzdG9yZS5nZXQoJ2JhcicpOyB9XG4gKlxuICpcbiAqICAgICAgLy9zeW50YWN0aWMgc3VnYXJcbiAqICAgICAgc3RvcmUuc2V0T2JqZWN0KCdmb28nLCB7IGZvbzogdHJ1ZSB9KTtcbiAqICAgICAgY29uc29sZS5sb2coc3RvcmUuZ2V0T2JqZWN0KCdmb28nKS5mb28pO1xuICpcbiAqICAgICAgc3RvcmUuZGlzcG9zZSgpO1xuICpcbiAqIEBjbGFzcyBTdG9yZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAbW9kdWxlIHN0b3JlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25hbC4gVGhlIG9wdGlvbnMgc3VwcG9ydGVkIGJ5IGEgc3BlY2lmaWMgc3RvcmUgaW1wbGVtZW50YXRpb24uXG4gKiBAbWFpbiBzdG9yZVxuICovXG5mdW5jdGlvbiBTdG9yZSgvKiBvcHRpb25zICovKSB7fVxuXG4vL2FkZCByZWdpc3RlciwgY3JlYXRlLCBtaXgsIGxvYWRBbGwsIGdldFN0b3JlTGlzdCBhcyBjbGFzcyBtZXRob2RzXG5mYWN0b3J5LmJpbmRDbGFzc01ldGhvZHMoU3RvcmUpO1xuXG4vKipcbiAqIHJlZ2lzdGVycyBhIG5ldyBzdG9yZSBpbXBsZW1lbnRhdGlvbi5cbiAqIEBtZXRob2QgcmVnaXN0ZXJcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbnN0cnVjdG9yIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIHN0b3JlLiBUaGlzIGZ1bmN0aW9uIG11c3QgaGF2ZSBhXG4gKiAgYFRZUEVgIHByb3BlcnR5IG9mIHR5cGUgU3RyaW5nLCB0aGF0IHdpbGwgYmUgdXNlZCBpbiBgU3RvcmUuY3JlYXRlKClgXG4gKi9cbi8qKlxuICogcmV0dXJucyBhIHN0b3JlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBzcGVjaWZpZWQgdHlwZS5cbiAqIEBtZXRob2QgY3JlYXRlXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSBvZiBzdG9yZSB0byBjcmVhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsLiBPcHRpb25zIHNwZWNpZmljIHRvIHRoZSBzdG9yZSBpbXBsZW1lbnRhdGlvblxuICogQHJldHVybiB7U3RvcmV9IGEgbmV3IHN0b3JlIG9mIHRoZSBzcGVjaWZpZWQgdHlwZVxuICovXG5cblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzZXRzIHNvbWUgY29udGVudCBhc3NvY2lhdGVkIHdpdGggYSBzcGVjaWZpYyBrZXkuIFRoZSBtYW5uZXIgaW4gd2hpY2hcbiAgICAgKiBkdXBsaWNhdGUga2V5cyBhcmUgaGFuZGxlZCBmb3IgbXVsdGlwbGUgYHNldCgpYCBjYWxscyB3aXRoIHRoZSBzYW1lXG4gICAgICoga2V5IGlzIGltcGxlbWVudGF0aW9uLXNwZWNpZmljLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IHRoZSBrZXkgZm9yIHRoZSBjb250ZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnRzIHRoZSBjb250ZW50cyBmb3IgdGhlIGtleVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24gKC8qIGtleSwgY29udGVudHMgKi8pIHsgdGhyb3cgbmV3IEVycm9yKFwic2V0OiBtdXN0IGJlIG92ZXJyaWRkZW5cIik7IH0sXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgY29udGVudCBhc3NvY2lhdGVkIHRvIGEgc3BlY2lmaWMga2V5IG9yIHRocm93cyBpZiB0aGUga2V5XG4gICAgICogd2FzIG5vdCBgc2V0YFxuICAgICAqIEBtZXRob2QgZ2V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSB0aGUga2V5IGZvciB3aGljaCB0byBnZXQgdGhlIGNvbnRlbnRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBjb250ZW50IGZvciB0aGUgc3BlY2lmaWVkIGtleVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKC8qIGtleSAqLykgeyB0aHJvdyBuZXcgRXJyb3IoXCJnZXQ6IG11c3QgYmUgb3ZlcnJpZGRlblwiKTsgfSxcbiAgICAvKipcbiAgICAgKiByZXR1cm5zIGEgbGlzdCBvZiBhbGwga25vd24ga2V5c1xuICAgICAqIEBtZXRob2Qga2V5c1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzZWVuIGtleXNcbiAgICAgKi9cbiAgICBrZXlzOiBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcihcImtleXM6IG11c3QgYmUgb3ZlcnJpZGRlblwiKTsgfSxcbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRydWUgaWYgdGhlIGtleSBpcyBvbmUgZm9yIHdoaWNoIGEgYGdldCgpYCBjYWxsIHdvdWxkIHdvcmsuXG4gICAgICogQG1ldGhvZCBoYXNLZXlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHJldHVybiB0cnVlIGlmIHRoZSBrZXkgaXMgdmFsaWQgZm9yIHRoaXMgc3RvcmUsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGhhc0tleTogZnVuY3Rpb24gKC8qIGtleSAqLykgeyB0aHJvdyBuZXcgRXJyb3IoXCJoYXNLZXk6IG11c3QgYmUgb3ZlcnJpZGRlblwiKTsgfSxcbiAgICAvKipcbiAgICAgKiBsaWZlY3ljbGUgbWV0aG9kIHRvIGRpc3Bvc2UgdGVtcG9yYXJ5IHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggdGhlIHN0b3JlXG4gICAgICogQG1ldGhvZCBkaXNwb3NlXG4gICAgICovXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge30sXG4gICAgLyoqXG4gICAgICogc3VnYXIgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIGEgc3BlY2lmaWMga2V5LiBUaHJvd3NcbiAgICAgKiBpZiB0aGUgY29udGVudCBzZXQgYWdhaW5zdCB0aGUga2V5IHdhcyBub3QgYSB2YWxpZCBKU09OIHN0cmluZy5cbiAgICAgKiBAbWV0aG9kIGdldE9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgdGhlIGtleSBmb3Igd2hpY2ggdG8gcmV0dXJuIHRoZSBhc3NvY2lhdGVkIG9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBrZXlcbiAgICAgKi9cbiAgICBnZXRPYmplY3Q6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy5nZXQoa2V5KSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBzdWdhciBtZXRob2QgdG8gc2V0IGFuIG9iamVjdCBhZ2FpbnN0IGEgc3BlY2lmaWMga2V5LlxuICAgICAqIEBtZXRob2Qgc2V0T2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSB0aGUga2V5IGZvciB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0aGUgb2JqZWN0IHRvIGJlIHN0b3JlZFxuICAgICAqL1xuICAgIHNldE9iamVjdDogZnVuY3Rpb24gKGtleSwgb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldChrZXksIEpTT04uc3RyaW5naWZ5KG9iamVjdCkpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3RvcmU7XG5cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/lib/store/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/lib/store/memory.js":
/*!******************************************************!*\
  !*** ./node_modules/sc-istanbul/lib/store/memory.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar util = __webpack_require__(/*! util */ \"util\"),\n    Store = __webpack_require__(/*! ./index */ \"(ssr)/./node_modules/sc-istanbul/lib/store/index.js\");\n\n/**\n * a `Store` implementation using an in-memory object.\n *\n * Usage\n * -----\n *\n *      var store = require('istanbul').Store.create('memory');\n *\n *\n * @class MemoryStore\n * @extends Store\n * @module store\n * @constructor\n */\nfunction MemoryStore() {\n    Store.call(this);\n    this.map = {};\n}\n\nMemoryStore.TYPE = 'memory';\nutil.inherits(MemoryStore, Store);\n\nStore.mix(MemoryStore, {\n    set: function (key, contents) {\n        this.map[key] = contents;\n    },\n\n    get: function (key) {\n        if (!this.hasKey(key)) {\n            throw new Error('Unable to find entry for [' + key + ']');\n        }\n        return this.map[key];\n    },\n\n    hasKey: function (key) {\n        return this.map.hasOwnProperty(key);\n    },\n\n    keys: function () {\n        return Object.keys(this.map);\n    },\n\n    dispose: function () {\n        this.map = {};\n    }\n});\n\nmodule.exports = MemoryStore;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL3N0b3JlL21lbW9yeS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsWUFBWSxtQkFBTyxDQUFDLG9FQUFTOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL3NjLWlzdGFuYnVsL2xpYi9zdG9yZS9tZW1vcnkuanM/YWNmNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuIENvcHlyaWdodCAoYykgMjAxMiwgWWFob28hIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpLFxuICAgIFN0b3JlID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuXG4vKipcbiAqIGEgYFN0b3JlYCBpbXBsZW1lbnRhdGlvbiB1c2luZyBhbiBpbi1tZW1vcnkgb2JqZWN0LlxuICpcbiAqIFVzYWdlXG4gKiAtLS0tLVxuICpcbiAqICAgICAgdmFyIHN0b3JlID0gcmVxdWlyZSgnaXN0YW5idWwnKS5TdG9yZS5jcmVhdGUoJ21lbW9yeScpO1xuICpcbiAqXG4gKiBAY2xhc3MgTWVtb3J5U3RvcmVcbiAqIEBleHRlbmRzIFN0b3JlXG4gKiBAbW9kdWxlIHN0b3JlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTWVtb3J5U3RvcmUoKSB7XG4gICAgU3RvcmUuY2FsbCh0aGlzKTtcbiAgICB0aGlzLm1hcCA9IHt9O1xufVxuXG5NZW1vcnlTdG9yZS5UWVBFID0gJ21lbW9yeSc7XG51dGlsLmluaGVyaXRzKE1lbW9yeVN0b3JlLCBTdG9yZSk7XG5cblN0b3JlLm1peChNZW1vcnlTdG9yZSwge1xuICAgIHNldDogZnVuY3Rpb24gKGtleSwgY29udGVudHMpIHtcbiAgICAgICAgdGhpcy5tYXBba2V5XSA9IGNvbnRlbnRzO1xuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0tleShrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIGVudHJ5IGZvciBbJyArIGtleSArICddJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWFwW2tleV07XG4gICAgfSxcblxuICAgIGhhc0tleTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICB9LFxuXG4gICAga2V5czogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5tYXApO1xuICAgIH0sXG5cbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWFwID0ge307XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWVtb3J5U3RvcmU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/lib/store/memory.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/lib/util/factory.js":
/*!******************************************************!*\
  !*** ./node_modules/sc-istanbul/lib/util/factory.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar util = __webpack_require__(/*! util */ \"util\"),\n    path = __webpack_require__(/*! path */ \"path\"),\n    fs = __webpack_require__(/*! fs */ \"fs\"),\n    abbrev = __webpack_require__(/*! abbrev */ \"(ssr)/./node_modules/abbrev/abbrev.js\");\n\nfunction Factory(kind, dir, allowAbbreviations) {\n    this.kind = kind;\n    this.dir = dir;\n    this.allowAbbreviations = allowAbbreviations;\n    this.classMap = {};\n    this.abbreviations = null;\n}\n\nFactory.prototype = {\n\n    knownTypes: function () {\n        var keys = Object.keys(this.classMap);\n        keys.sort();\n        return keys;\n    },\n\n    resolve: function (abbreviatedType) {\n        if (!this.abbreviations) {\n            this.abbreviations = abbrev(this.knownTypes());\n        }\n        return this.abbreviations[abbreviatedType];\n    },\n\n    register: function (constructor) {\n        var type = constructor.TYPE;\n        if (!type) { throw new Error('Could not register ' + this.kind + ' constructor [no TYPE property]: ' + util.inspect(constructor)); }\n        this.classMap[type] = constructor;\n        this.abbreviations = null;\n    },\n\n    create: function (type, opts) {\n        var allowAbbrev = this.allowAbbreviations,\n            realType = allowAbbrev ? this.resolve(type) : type,\n            Cons;\n\n        Cons = realType ? this.classMap[realType] : null;\n        if (!Cons) { throw new Error('Invalid ' + this.kind + ' [' + type + '], allowed values are ' + this.knownTypes().join(', ')); }\n        return new Cons(opts);\n    },\n\n    loadStandard: function (dir) {\n        var that = this;\n        fs.readdirSync(dir).forEach(function (file) {\n            if (file !== 'index.js' && file.indexOf('.js') === file.length - 3) {\n                try {\n                    that.register(__webpack_require__(\"(ssr)/./node_modules/sc-istanbul/lib/util sync recursive\")(path.resolve(dir, file)));\n                } catch (ex) {\n                    console.error(ex.message);\n                    console.error(ex.stack);\n                    throw new Error('Could not register ' + that.kind + ' from file ' + file);\n                }\n            }\n        });\n    },\n\n    bindClassMethods: function (Cons) {\n        var tmpKind = this.kind.charAt(0).toUpperCase() + this.kind.substring(1), //ucfirst\n            allowAbbrev = this.allowAbbreviations;\n\n        Cons.mix = Factory.mix;\n        Cons.register = this.register.bind(this);\n        Cons.create = this.create.bind(this);\n        Cons.loadAll = this.loadStandard.bind(this, this.dir);\n        Cons['get' + tmpKind + 'List'] = this.knownTypes.bind(this);\n        if (allowAbbrev) {\n            Cons['resolve' + tmpKind + 'Name'] = this.resolve.bind(this);\n        }\n    }\n};\n\nFactory.mix = function (cons, proto) {\n    Object.keys(proto).forEach(function (key) {\n        cons.prototype[key] = proto[key];\n    });\n};\n\nmodule.exports = Factory;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL3V0aWwvZmFjdG9yeS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLFNBQVMsbUJBQU8sQ0FBQyxjQUFJO0FBQ3JCLGFBQWEsbUJBQU8sQ0FBQyxxREFBUTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0ZBQVEsdUJBQXVCLENBQUM7QUFDbEUsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9zYy1pc3RhbmJ1bC9saWIvdXRpbC9mYWN0b3J5LmpzP2MyMmMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiBDb3B5cmlnaHQgKGMpIDIwMTIsIFlhaG9vISBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKSxcbiAgICBwYXRoID0gcmVxdWlyZSgncGF0aCcpLFxuICAgIGZzID0gcmVxdWlyZSgnZnMnKSxcbiAgICBhYmJyZXYgPSByZXF1aXJlKCdhYmJyZXYnKTtcblxuZnVuY3Rpb24gRmFjdG9yeShraW5kLCBkaXIsIGFsbG93QWJicmV2aWF0aW9ucykge1xuICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgdGhpcy5kaXIgPSBkaXI7XG4gICAgdGhpcy5hbGxvd0FiYnJldmlhdGlvbnMgPSBhbGxvd0FiYnJldmlhdGlvbnM7XG4gICAgdGhpcy5jbGFzc01hcCA9IHt9O1xuICAgIHRoaXMuYWJicmV2aWF0aW9ucyA9IG51bGw7XG59XG5cbkZhY3RvcnkucHJvdG90eXBlID0ge1xuXG4gICAga25vd25UeXBlczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuY2xhc3NNYXApO1xuICAgICAgICBrZXlzLnNvcnQoKTtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfSxcblxuICAgIHJlc29sdmU6IGZ1bmN0aW9uIChhYmJyZXZpYXRlZFR5cGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFiYnJldmlhdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuYWJicmV2aWF0aW9ucyA9IGFiYnJldih0aGlzLmtub3duVHlwZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWJicmV2aWF0aW9uc1thYmJyZXZpYXRlZFR5cGVdO1xuICAgIH0sXG5cbiAgICByZWdpc3RlcjogZnVuY3Rpb24gKGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHZhciB0eXBlID0gY29uc3RydWN0b3IuVFlQRTtcbiAgICAgICAgaWYgKCF0eXBlKSB7IHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJlZ2lzdGVyICcgKyB0aGlzLmtpbmQgKyAnIGNvbnN0cnVjdG9yIFtubyBUWVBFIHByb3BlcnR5XTogJyArIHV0aWwuaW5zcGVjdChjb25zdHJ1Y3RvcikpOyB9XG4gICAgICAgIHRoaXMuY2xhc3NNYXBbdHlwZV0gPSBjb25zdHJ1Y3RvcjtcbiAgICAgICAgdGhpcy5hYmJyZXZpYXRpb25zID0gbnVsbDtcbiAgICB9LFxuXG4gICAgY3JlYXRlOiBmdW5jdGlvbiAodHlwZSwgb3B0cykge1xuICAgICAgICB2YXIgYWxsb3dBYmJyZXYgPSB0aGlzLmFsbG93QWJicmV2aWF0aW9ucyxcbiAgICAgICAgICAgIHJlYWxUeXBlID0gYWxsb3dBYmJyZXYgPyB0aGlzLnJlc29sdmUodHlwZSkgOiB0eXBlLFxuICAgICAgICAgICAgQ29ucztcblxuICAgICAgICBDb25zID0gcmVhbFR5cGUgPyB0aGlzLmNsYXNzTWFwW3JlYWxUeXBlXSA6IG51bGw7XG4gICAgICAgIGlmICghQ29ucykgeyB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIHRoaXMua2luZCArICcgWycgKyB0eXBlICsgJ10sIGFsbG93ZWQgdmFsdWVzIGFyZSAnICsgdGhpcy5rbm93blR5cGVzKCkuam9pbignLCAnKSk7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb25zKG9wdHMpO1xuICAgIH0sXG5cbiAgICBsb2FkU3RhbmRhcmQ6IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBmcy5yZWFkZGlyU3luYyhkaXIpLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgICAgIGlmIChmaWxlICE9PSAnaW5kZXguanMnICYmIGZpbGUuaW5kZXhPZignLmpzJykgPT09IGZpbGUubGVuZ3RoIC0gMykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQucmVnaXN0ZXIocmVxdWlyZShwYXRoLnJlc29sdmUoZGlyLCBmaWxlKSkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXgubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXguc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCByZWdpc3RlciAnICsgdGhhdC5raW5kICsgJyBmcm9tIGZpbGUgJyArIGZpbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGJpbmRDbGFzc01ldGhvZHM6IGZ1bmN0aW9uIChDb25zKSB7XG4gICAgICAgIHZhciB0bXBLaW5kID0gdGhpcy5raW5kLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGhpcy5raW5kLnN1YnN0cmluZygxKSwgLy91Y2ZpcnN0XG4gICAgICAgICAgICBhbGxvd0FiYnJldiA9IHRoaXMuYWxsb3dBYmJyZXZpYXRpb25zO1xuXG4gICAgICAgIENvbnMubWl4ID0gRmFjdG9yeS5taXg7XG4gICAgICAgIENvbnMucmVnaXN0ZXIgPSB0aGlzLnJlZ2lzdGVyLmJpbmQodGhpcyk7XG4gICAgICAgIENvbnMuY3JlYXRlID0gdGhpcy5jcmVhdGUuYmluZCh0aGlzKTtcbiAgICAgICAgQ29ucy5sb2FkQWxsID0gdGhpcy5sb2FkU3RhbmRhcmQuYmluZCh0aGlzLCB0aGlzLmRpcik7XG4gICAgICAgIENvbnNbJ2dldCcgKyB0bXBLaW5kICsgJ0xpc3QnXSA9IHRoaXMua25vd25UeXBlcy5iaW5kKHRoaXMpO1xuICAgICAgICBpZiAoYWxsb3dBYmJyZXYpIHtcbiAgICAgICAgICAgIENvbnNbJ3Jlc29sdmUnICsgdG1wS2luZCArICdOYW1lJ10gPSB0aGlzLnJlc29sdmUuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkZhY3RvcnkubWl4ID0gZnVuY3Rpb24gKGNvbnMsIHByb3RvKSB7XG4gICAgT2JqZWN0LmtleXMocHJvdG8pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBjb25zLnByb3RvdHlwZVtrZXldID0gcHJvdG9ba2V5XTtcbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmFjdG9yeTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/lib/util/factory.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/lib/util/file-matcher.js":
/*!***********************************************************!*\
  !*** ./node_modules/sc-istanbul/lib/util/file-matcher.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar async = __webpack_require__(/*! async */ \"(ssr)/./node_modules/sc-istanbul/node_modules/async/lib/async.js\"),\n    glob = __webpack_require__(/*! glob */ \"(ssr)/./node_modules/sc-istanbul/node_modules/glob/glob.js\"),\n    fs = __webpack_require__(/*! fs */ \"fs\"),\n    path = __webpack_require__(/*! path */ \"path\"),\n    seq = 0;\n\nfunction filesFor(options, callback) {\n    if (!callback && typeof options === 'function') {\n        callback = options;\n        options = null;\n    }\n    options = options || {};\n\n    var root = options.root,\n        includes = options.includes,\n        excludes = options.excludes,\n        realpath = options.realpath,\n        relative = options.relative,\n        opts;\n\n    root = root || process.cwd();\n    includes = includes && Array.isArray(includes) ? includes : [ '**/*.js' ];\n    excludes = excludes && Array.isArray(excludes) ? excludes : [ '**/node_modules/**' ];\n\n    opts = { cwd: root, nodir: true, ignore: excludes };\n    seq += 1;\n    opts['x' + seq + new Date().getTime()] = true; //cache buster for minimatch cache bug\n    glob(includes.join(' '), opts, function (err, files) {\n        if (err) { return callback(err); }\n        if (relative) { return callback(err, files); }\n\n        if (!realpath) {\n            files = files.map(function (file) { return path.resolve(root, file); });\n            return callback(err, files);\n        }\n\n        var realPathCache = module.constructor._realpathCache || {};\n\n        async.map(files, function (file, done) {\n            fs.realpath(path.resolve(root, file), realPathCache, done);\n        }, callback);\n    });\n}\n\nfunction matcherFor(options, callback) {\n\n    if (!callback && typeof options === 'function') {\n        callback = options;\n        options = null;\n    }\n    options = options || {};\n    options.relative = false; //force absolute paths\n    options.realpath = true; //force real paths (to match Node.js module paths)\n\n    filesFor(options, function (err, files) {\n        var fileMap = {},\n            matchFn;\n        if (err) { return callback(err); }\n        files.forEach(function (file) { fileMap[file] = true; });\n\n        matchFn = function (file) { return fileMap[file]; };\n        matchFn.files = Object.keys(fileMap);\n        return callback(null, matchFn);\n    });\n}\n\nmodule.exports = {\n    filesFor: filesFor,\n    matcherFor: matcherFor\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL3V0aWwvZmlsZS1tYXRjaGVyLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsK0VBQU87QUFDM0IsV0FBVyxtQkFBTyxDQUFDLHdFQUFNO0FBQ3pCLFNBQVMsbUJBQU8sQ0FBQyxjQUFJO0FBQ3JCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxtQkFBbUI7QUFDbkIsd0JBQXdCOztBQUV4QjtBQUNBLGdEQUFnRCxrQ0FBa0M7QUFDbEY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDZCQUE2Qjs7QUFFN0I7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxtQkFBbUI7QUFDbkIsd0NBQXdDLHVCQUF1Qjs7QUFFL0Qsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL3NjLWlzdGFuYnVsL2xpYi91dGlsL2ZpbGUtbWF0Y2hlci5qcz8wOWM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gQ29weXJpZ2h0IChjKSAyMDEyLCBZYWhvbyEgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cblxudmFyIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKSxcbiAgICBnbG9iID0gcmVxdWlyZSgnZ2xvYicpLFxuICAgIGZzID0gcmVxdWlyZSgnZnMnKSxcbiAgICBwYXRoID0gcmVxdWlyZSgncGF0aCcpLFxuICAgIHNlcSA9IDA7XG5cbmZ1bmN0aW9uIGZpbGVzRm9yKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciByb290ID0gb3B0aW9ucy5yb290LFxuICAgICAgICBpbmNsdWRlcyA9IG9wdGlvbnMuaW5jbHVkZXMsXG4gICAgICAgIGV4Y2x1ZGVzID0gb3B0aW9ucy5leGNsdWRlcyxcbiAgICAgICAgcmVhbHBhdGggPSBvcHRpb25zLnJlYWxwYXRoLFxuICAgICAgICByZWxhdGl2ZSA9IG9wdGlvbnMucmVsYXRpdmUsXG4gICAgICAgIG9wdHM7XG5cbiAgICByb290ID0gcm9vdCB8fCBwcm9jZXNzLmN3ZCgpO1xuICAgIGluY2x1ZGVzID0gaW5jbHVkZXMgJiYgQXJyYXkuaXNBcnJheShpbmNsdWRlcykgPyBpbmNsdWRlcyA6IFsgJyoqLyouanMnIF07XG4gICAgZXhjbHVkZXMgPSBleGNsdWRlcyAmJiBBcnJheS5pc0FycmF5KGV4Y2x1ZGVzKSA/IGV4Y2x1ZGVzIDogWyAnKiovbm9kZV9tb2R1bGVzLyoqJyBdO1xuXG4gICAgb3B0cyA9IHsgY3dkOiByb290LCBub2RpcjogdHJ1ZSwgaWdub3JlOiBleGNsdWRlcyB9O1xuICAgIHNlcSArPSAxO1xuICAgIG9wdHNbJ3gnICsgc2VxICsgbmV3IERhdGUoKS5nZXRUaW1lKCldID0gdHJ1ZTsgLy9jYWNoZSBidXN0ZXIgZm9yIG1pbmltYXRjaCBjYWNoZSBidWdcbiAgICBnbG9iKGluY2x1ZGVzLmpvaW4oJyAnKSwgb3B0cywgZnVuY3Rpb24gKGVyciwgZmlsZXMpIHtcbiAgICAgICAgaWYgKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKTsgfVxuICAgICAgICBpZiAocmVsYXRpdmUpIHsgcmV0dXJuIGNhbGxiYWNrKGVyciwgZmlsZXMpOyB9XG5cbiAgICAgICAgaWYgKCFyZWFscGF0aCkge1xuICAgICAgICAgICAgZmlsZXMgPSBmaWxlcy5tYXAoZnVuY3Rpb24gKGZpbGUpIHsgcmV0dXJuIHBhdGgucmVzb2x2ZShyb290LCBmaWxlKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBmaWxlcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVhbFBhdGhDYWNoZSA9IG1vZHVsZS5jb25zdHJ1Y3Rvci5fcmVhbHBhdGhDYWNoZSB8fCB7fTtcblxuICAgICAgICBhc3luYy5tYXAoZmlsZXMsIGZ1bmN0aW9uIChmaWxlLCBkb25lKSB7XG4gICAgICAgICAgICBmcy5yZWFscGF0aChwYXRoLnJlc29sdmUocm9vdCwgZmlsZSksIHJlYWxQYXRoQ2FjaGUsIGRvbmUpO1xuICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGb3Iob3B0aW9ucywgY2FsbGJhY2spIHtcblxuICAgIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5yZWxhdGl2ZSA9IGZhbHNlOyAvL2ZvcmNlIGFic29sdXRlIHBhdGhzXG4gICAgb3B0aW9ucy5yZWFscGF0aCA9IHRydWU7IC8vZm9yY2UgcmVhbCBwYXRocyAodG8gbWF0Y2ggTm9kZS5qcyBtb2R1bGUgcGF0aHMpXG5cbiAgICBmaWxlc0ZvcihvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBmaWxlcykge1xuICAgICAgICB2YXIgZmlsZU1hcCA9IHt9LFxuICAgICAgICAgICAgbWF0Y2hGbjtcbiAgICAgICAgaWYgKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKTsgfVxuICAgICAgICBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7IGZpbGVNYXBbZmlsZV0gPSB0cnVlOyB9KTtcblxuICAgICAgICBtYXRjaEZuID0gZnVuY3Rpb24gKGZpbGUpIHsgcmV0dXJuIGZpbGVNYXBbZmlsZV07IH07XG4gICAgICAgIG1hdGNoRm4uZmlsZXMgPSBPYmplY3Qua2V5cyhmaWxlTWFwKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG1hdGNoRm4pO1xuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBmaWxlc0ZvcjogZmlsZXNGb3IsXG4gICAgbWF0Y2hlckZvcjogbWF0Y2hlckZvclxufTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/lib/util/file-matcher.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/lib/util/file-writer.js":
/*!**********************************************************!*\
  !*** ./node_modules/sc-istanbul/lib/util/file-writer.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar path = __webpack_require__(/*! path */ \"path\"),\n    util = __webpack_require__(/*! util */ \"util\"),\n    fs = __webpack_require__(/*! fs */ \"fs\"),\n    async = __webpack_require__(/*! async */ \"(ssr)/./node_modules/sc-istanbul/node_modules/async/lib/async.js\"),\n    mkdirp = __webpack_require__(/*! mkdirp */ \"(ssr)/./node_modules/mkdirp/index.js\"),\n    writer = __webpack_require__(/*! ./writer */ \"(ssr)/./node_modules/sc-istanbul/lib/util/writer.js\"),\n    Writer = writer.Writer,\n    ContentWriter = writer.ContentWriter;\n\nfunction extend(cons, proto) {\n    Object.keys(proto).forEach(function (k) {\n        cons.prototype[k] = proto[k];\n    });\n}\n\nfunction BufferedContentWriter() {\n    ContentWriter.call(this);\n    this.content = '';\n}\nutil.inherits(BufferedContentWriter, ContentWriter);\n\nextend(BufferedContentWriter, {\n    write: function (str) {\n        this.content += str;\n    },\n    getContent: function () {\n        return this.content;\n    }\n});\n\nfunction StreamContentWriter(stream) {\n    ContentWriter.call(this);\n    this.stream = stream;\n}\nutil.inherits(StreamContentWriter, ContentWriter);\n\nextend(StreamContentWriter, {\n    write: function (str) {\n        this.stream.write(str);\n    }\n});\n\nfunction SyncFileWriter() {\n    Writer.call(this);\n}\nutil.inherits(SyncFileWriter, Writer);\n\nextend(SyncFileWriter, {\n    writeFile: function (file, callback) {\n        mkdirp.sync(path.dirname(file));\n        var cw = new BufferedContentWriter();\n        callback(cw);\n        fs.writeFileSync(file, cw.getContent(), 'utf8');\n    },\n    done: function () {\n        this.emit('done'); //everything already done\n    }\n});\n\nfunction AsyncFileWriter() {\n    this.queue = async.queue(this.processFile.bind(this), 20);\n    this.openFileMap = {};\n}\n\nutil.inherits(AsyncFileWriter, Writer);\n\nextend(AsyncFileWriter, {\n    writeFile: function (file, callback) {\n        this.openFileMap[file] = true;\n        this.queue.push({ file: file, callback: callback });\n    },\n    processFile: function (task, cb) {\n        var file = task.file,\n            userCallback = task.callback,\n            that = this,\n            stream,\n            contentWriter;\n\n        mkdirp.sync(path.dirname(file));\n        stream = fs.createWriteStream(file);\n        stream.on('close', function () {\n            delete that.openFileMap[file];\n            cb();\n            that.checkDone();\n        });\n        stream.on('error', function (err) { that.emit('error', err); });\n        contentWriter = new StreamContentWriter(stream);\n        userCallback(contentWriter);\n        stream.end();\n    },\n    done: function () {\n        this.doneCalled = true;\n        this.checkDone();\n    },\n    checkDone: function () {\n        if (!this.doneCalled) { return; }\n        if (Object.keys(this.openFileMap).length === 0) {\n            this.emit('done');\n        }\n    }\n});\n/**\n * a concrete writer implementation that can write files synchronously or\n * asynchronously based on the constructor argument passed to it.\n *\n * Usage\n * -----\n *\n *      var sync = true,\n *          fileWriter = new require('istanbul').FileWriter(sync);\n *\n *      fileWriter.on('done', function () { console.log('done'); });\n *      fileWriter.copyFile('/foo/bar.jpg', '/baz/bar.jpg');\n *      fileWriter.writeFile('/foo/index.html', function (contentWriter) {\n *          contentWriter.println('<html>');\n *          contentWriter.println('</html>');\n *      });\n *      fileWriter.done(); // will emit the `done` event when all files are written\n *\n * @class FileWriter\n * @extends Writer\n * @module io\n * @param sync\n * @constructor\n */\nfunction FileWriter(sync) {\n    Writer.call(this);\n    var that = this;\n    this.delegate = sync ? new SyncFileWriter() : new AsyncFileWriter();\n    this.delegate.on('error', function (err) { that.emit('error', err); });\n    this.delegate.on('done', function () { that.emit('done'); });\n}\n\nutil.inherits(FileWriter, Writer);\n\nextend(FileWriter, {\n    copyFile: function (source, dest) {\n        mkdirp.sync(path.dirname(dest));\n        fs.writeFileSync(dest, fs.readFileSync(source));\n    },\n    writeFile: function (file, callback) {\n        this.delegate.writeFile(file, callback);\n    },\n    done: function () {\n        this.delegate.done();\n    }\n});\n\nmodule.exports = FileWriter;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL3V0aWwvZmlsZS13cml0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixTQUFTLG1CQUFPLENBQUMsY0FBSTtBQUNyQixZQUFZLG1CQUFPLENBQUMsK0VBQU87QUFDM0IsYUFBYSxtQkFBTyxDQUFDLG9EQUFRO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyxxRUFBVTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdDQUFnQztBQUMxRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0Q0FBNEMsMEJBQTBCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDBCQUEwQjtBQUN6RSwyQ0FBMkMsb0JBQW9CO0FBQy9EOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL3V0aWwvZmlsZS13cml0ZXIuanM/NWU2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuIENvcHlyaWdodCAoYykgMjAxMiwgWWFob28hIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG5cbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpLFxuICAgIHV0aWwgPSByZXF1aXJlKCd1dGlsJyksXG4gICAgZnMgPSByZXF1aXJlKCdmcycpLFxuICAgIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKSxcbiAgICBta2RpcnAgPSByZXF1aXJlKCdta2RpcnAnKSxcbiAgICB3cml0ZXIgPSByZXF1aXJlKCcuL3dyaXRlcicpLFxuICAgIFdyaXRlciA9IHdyaXRlci5Xcml0ZXIsXG4gICAgQ29udGVudFdyaXRlciA9IHdyaXRlci5Db250ZW50V3JpdGVyO1xuXG5mdW5jdGlvbiBleHRlbmQoY29ucywgcHJvdG8pIHtcbiAgICBPYmplY3Qua2V5cyhwcm90bykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICBjb25zLnByb3RvdHlwZVtrXSA9IHByb3RvW2tdO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBCdWZmZXJlZENvbnRlbnRXcml0ZXIoKSB7XG4gICAgQ29udGVudFdyaXRlci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuY29udGVudCA9ICcnO1xufVxudXRpbC5pbmhlcml0cyhCdWZmZXJlZENvbnRlbnRXcml0ZXIsIENvbnRlbnRXcml0ZXIpO1xuXG5leHRlbmQoQnVmZmVyZWRDb250ZW50V3JpdGVyLCB7XG4gICAgd3JpdGU6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ICs9IHN0cjtcbiAgICB9LFxuICAgIGdldENvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gU3RyZWFtQ29udGVudFdyaXRlcihzdHJlYW0pIHtcbiAgICBDb250ZW50V3JpdGVyLmNhbGwodGhpcyk7XG4gICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG59XG51dGlsLmluaGVyaXRzKFN0cmVhbUNvbnRlbnRXcml0ZXIsIENvbnRlbnRXcml0ZXIpO1xuXG5leHRlbmQoU3RyZWFtQ29udGVudFdyaXRlciwge1xuICAgIHdyaXRlOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKHN0cik7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIFN5bmNGaWxlV3JpdGVyKCkge1xuICAgIFdyaXRlci5jYWxsKHRoaXMpO1xufVxudXRpbC5pbmhlcml0cyhTeW5jRmlsZVdyaXRlciwgV3JpdGVyKTtcblxuZXh0ZW5kKFN5bmNGaWxlV3JpdGVyLCB7XG4gICAgd3JpdGVGaWxlOiBmdW5jdGlvbiAoZmlsZSwgY2FsbGJhY2spIHtcbiAgICAgICAgbWtkaXJwLnN5bmMocGF0aC5kaXJuYW1lKGZpbGUpKTtcbiAgICAgICAgdmFyIGN3ID0gbmV3IEJ1ZmZlcmVkQ29udGVudFdyaXRlcigpO1xuICAgICAgICBjYWxsYmFjayhjdyk7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgY3cuZ2V0Q29udGVudCgpLCAndXRmOCcpO1xuICAgIH0sXG4gICAgZG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2RvbmUnKTsgLy9ldmVyeXRoaW5nIGFscmVhZHkgZG9uZVxuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBBc3luY0ZpbGVXcml0ZXIoKSB7XG4gICAgdGhpcy5xdWV1ZSA9IGFzeW5jLnF1ZXVlKHRoaXMucHJvY2Vzc0ZpbGUuYmluZCh0aGlzKSwgMjApO1xuICAgIHRoaXMub3BlbkZpbGVNYXAgPSB7fTtcbn1cblxudXRpbC5pbmhlcml0cyhBc3luY0ZpbGVXcml0ZXIsIFdyaXRlcik7XG5cbmV4dGVuZChBc3luY0ZpbGVXcml0ZXIsIHtcbiAgICB3cml0ZUZpbGU6IGZ1bmN0aW9uIChmaWxlLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm9wZW5GaWxlTWFwW2ZpbGVdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHsgZmlsZTogZmlsZSwgY2FsbGJhY2s6IGNhbGxiYWNrIH0pO1xuICAgIH0sXG4gICAgcHJvY2Vzc0ZpbGU6IGZ1bmN0aW9uICh0YXNrLCBjYikge1xuICAgICAgICB2YXIgZmlsZSA9IHRhc2suZmlsZSxcbiAgICAgICAgICAgIHVzZXJDYWxsYmFjayA9IHRhc2suY2FsbGJhY2ssXG4gICAgICAgICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgIHN0cmVhbSxcbiAgICAgICAgICAgIGNvbnRlbnRXcml0ZXI7XG5cbiAgICAgICAgbWtkaXJwLnN5bmMocGF0aC5kaXJuYW1lKGZpbGUpKTtcbiAgICAgICAgc3RyZWFtID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oZmlsZSk7XG4gICAgICAgIHN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhhdC5vcGVuRmlsZU1hcFtmaWxlXTtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB0aGF0LmNoZWNrRG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHsgdGhhdC5lbWl0KCdlcnJvcicsIGVycik7IH0pO1xuICAgICAgICBjb250ZW50V3JpdGVyID0gbmV3IFN0cmVhbUNvbnRlbnRXcml0ZXIoc3RyZWFtKTtcbiAgICAgICAgdXNlckNhbGxiYWNrKGNvbnRlbnRXcml0ZXIpO1xuICAgICAgICBzdHJlYW0uZW5kKCk7XG4gICAgfSxcbiAgICBkb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZG9uZUNhbGxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2hlY2tEb25lKCk7XG4gICAgfSxcbiAgICBjaGVja0RvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbmVDYWxsZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLm9wZW5GaWxlTWFwKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZG9uZScpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4vKipcbiAqIGEgY29uY3JldGUgd3JpdGVyIGltcGxlbWVudGF0aW9uIHRoYXQgY2FuIHdyaXRlIGZpbGVzIHN5bmNocm9ub3VzbHkgb3JcbiAqIGFzeW5jaHJvbm91c2x5IGJhc2VkIG9uIHRoZSBjb25zdHJ1Y3RvciBhcmd1bWVudCBwYXNzZWQgdG8gaXQuXG4gKlxuICogVXNhZ2VcbiAqIC0tLS0tXG4gKlxuICogICAgICB2YXIgc3luYyA9IHRydWUsXG4gKiAgICAgICAgICBmaWxlV3JpdGVyID0gbmV3IHJlcXVpcmUoJ2lzdGFuYnVsJykuRmlsZVdyaXRlcihzeW5jKTtcbiAqXG4gKiAgICAgIGZpbGVXcml0ZXIub24oJ2RvbmUnLCBmdW5jdGlvbiAoKSB7IGNvbnNvbGUubG9nKCdkb25lJyk7IH0pO1xuICogICAgICBmaWxlV3JpdGVyLmNvcHlGaWxlKCcvZm9vL2Jhci5qcGcnLCAnL2Jhei9iYXIuanBnJyk7XG4gKiAgICAgIGZpbGVXcml0ZXIud3JpdGVGaWxlKCcvZm9vL2luZGV4Lmh0bWwnLCBmdW5jdGlvbiAoY29udGVudFdyaXRlcikge1xuICogICAgICAgICAgY29udGVudFdyaXRlci5wcmludGxuKCc8aHRtbD4nKTtcbiAqICAgICAgICAgIGNvbnRlbnRXcml0ZXIucHJpbnRsbignPC9odG1sPicpO1xuICogICAgICB9KTtcbiAqICAgICAgZmlsZVdyaXRlci5kb25lKCk7IC8vIHdpbGwgZW1pdCB0aGUgYGRvbmVgIGV2ZW50IHdoZW4gYWxsIGZpbGVzIGFyZSB3cml0dGVuXG4gKlxuICogQGNsYXNzIEZpbGVXcml0ZXJcbiAqIEBleHRlbmRzIFdyaXRlclxuICogQG1vZHVsZSBpb1xuICogQHBhcmFtIHN5bmNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBGaWxlV3JpdGVyKHN5bmMpIHtcbiAgICBXcml0ZXIuY2FsbCh0aGlzKTtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhpcy5kZWxlZ2F0ZSA9IHN5bmMgPyBuZXcgU3luY0ZpbGVXcml0ZXIoKSA6IG5ldyBBc3luY0ZpbGVXcml0ZXIoKTtcbiAgICB0aGlzLmRlbGVnYXRlLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHsgdGhhdC5lbWl0KCdlcnJvcicsIGVycik7IH0pO1xuICAgIHRoaXMuZGVsZWdhdGUub24oJ2RvbmUnLCBmdW5jdGlvbiAoKSB7IHRoYXQuZW1pdCgnZG9uZScpOyB9KTtcbn1cblxudXRpbC5pbmhlcml0cyhGaWxlV3JpdGVyLCBXcml0ZXIpO1xuXG5leHRlbmQoRmlsZVdyaXRlciwge1xuICAgIGNvcHlGaWxlOiBmdW5jdGlvbiAoc291cmNlLCBkZXN0KSB7XG4gICAgICAgIG1rZGlycC5zeW5jKHBhdGguZGlybmFtZShkZXN0KSk7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMoZGVzdCwgZnMucmVhZEZpbGVTeW5jKHNvdXJjZSkpO1xuICAgIH0sXG4gICAgd3JpdGVGaWxlOiBmdW5jdGlvbiAoZmlsZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS53cml0ZUZpbGUoZmlsZSwgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgZG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLmRvbmUoKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWxlV3JpdGVyOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/lib/util/file-writer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/lib/util/input-error.js":
/*!**********************************************************!*\
  !*** ./node_modules/sc-istanbul/lib/util/input-error.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nmodule.exports.create = function (message) {\n    var err = new Error(message);\n    err.inputError = true;\n    return err;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL3V0aWwvaW5wdXQtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9zYy1pc3RhbmJ1bC9saWIvdXRpbC9pbnB1dC1lcnJvci5qcz9lNTYxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gQ29weXJpZ2h0IChjKSAyMDEyLCBZYWhvbyEgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIGVyci5pbnB1dEVycm9yID0gdHJ1ZTtcbiAgICByZXR1cm4gZXJyO1xufTtcblxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/lib/util/input-error.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/lib/util/meta.js":
/*!***************************************************!*\
  !*** ./node_modules/sc-istanbul/lib/util/meta.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar path = __webpack_require__(/*! path */ \"path\"),\n    fs = __webpack_require__(/*! fs */ \"fs\"),\n    pkg = JSON.parse(fs.readFileSync(path.resolve(__dirname, '..', '..', 'package.json'), 'utf8'));\n\nmodule.exports = {\n    NAME: pkg.name,\n    VERSION: pkg.version\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL3V0aWwvbWV0YS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixTQUFTLG1CQUFPLENBQUMsY0FBSTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL3V0aWwvbWV0YS5qcz83YmIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gQ29weXJpZ2h0IChjKSAyMDEyLCBZYWhvbyEgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpLFxuICAgIGZzID0gcmVxdWlyZSgnZnMnKSxcbiAgICBwa2cgPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4nLCAnLi4nLCAncGFja2FnZS5qc29uJyksICd1dGY4JykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBOQU1FOiBwa2cubmFtZSxcbiAgICBWRVJTSU9OOiBwa2cudmVyc2lvblxufTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/lib/util/meta.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/lib/util/tree-summarizer.js":
/*!**************************************************************!*\
  !*** ./node_modules/sc-istanbul/lib/util/tree-summarizer.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar path = __webpack_require__(/*! path */ \"path\"),\n    SEP = path.sep || '/',\n    utils = __webpack_require__(/*! ../object-utils */ \"(ssr)/./node_modules/sc-istanbul/lib/object-utils.js\");\n\nfunction commonArrayPrefix(first, second) {\n    var len = first.length < second.length ? first.length : second.length,\n        i,\n        ret = [];\n    for (i = 0; i < len; i += 1) {\n        if (first[i] === second[i]) {\n            ret.push(first[i]);\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\n\nfunction findCommonArrayPrefix(args) {\n    if (args.length === 0) {\n        return [];\n    }\n\n    var separated = args.map(function (arg) { return arg.split(SEP); }),\n        ret = separated.pop();\n\n    if (separated.length === 0) {\n        return ret.slice(0, ret.length - 1);\n    } else {\n        return separated.reduce(commonArrayPrefix, ret);\n    }\n}\n\nfunction Node(fullName, kind, metrics) {\n    this.name = fullName;\n    this.fullName = fullName;\n    this.kind = kind;\n    this.metrics = metrics || null;\n    this.parent = null;\n    this.children = [];\n}\n\nNode.prototype = {\n    displayShortName: function () {\n        return this.relativeName;\n    },\n    fullPath: function () {\n        return this.fullName;\n    },\n    addChild: function (child) {\n        this.children.push(child);\n        child.parent = this;\n    },\n    toJSON: function () {\n        return {\n            name: this.name,\n            relativeName: this.relativeName,\n            fullName: this.fullName,\n            kind: this.kind,\n            metrics: this.metrics,\n            parent: this.parent === null ? null : this.parent.name,\n            children: this.children.map(function (node) { return node.toJSON(); })\n        };\n    }\n};\n\nfunction TreeSummary(summaryMap, commonPrefix) {\n    this.prefix = commonPrefix;\n    this.convertToTree(summaryMap, commonPrefix);\n}\n\nTreeSummary.prototype = {\n    getNode: function (shortName) {\n        return this.map[shortName];\n    },\n    convertToTree: function (summaryMap, arrayPrefix) {\n        var nodes = [],\n            rootPath = arrayPrefix.join(SEP) + SEP,\n            root = new Node(rootPath, 'dir'),\n            tmp,\n            tmpChildren,\n            seen = {},\n            filesUnderRoot = false;\n\n        seen[rootPath] = root;\n        Object.keys(summaryMap).forEach(function (key) {\n            var metrics = summaryMap[key],\n                node,\n                parentPath,\n                parent;\n            node = new Node(key, 'file', metrics);\n            seen[key] = node;\n            nodes.push(node);\n            parentPath = path.dirname(key) + SEP;\n            if (parentPath === SEP + SEP || parentPath === '.' + SEP) {\n                parentPath = SEP + '__root__' + SEP;\n            }\n            parent = seen[parentPath];\n            if (!parent) {\n                parent = new Node(parentPath, 'dir');\n                root.addChild(parent);\n                seen[parentPath] = parent;\n            }\n            parent.addChild(node);\n            if (parent === root) { filesUnderRoot = true; }\n        });\n\n        if (filesUnderRoot && arrayPrefix.length > 0) {\n            arrayPrefix.pop(); //start at one level above\n            tmp = root;\n            tmpChildren = tmp.children;\n            tmp.children = [];\n            root = new Node(arrayPrefix.join(SEP) + SEP, 'dir');\n            root.addChild(tmp);\n            tmpChildren.forEach(function (child) {\n                if (child.kind === 'dir') {\n                    root.addChild(child);\n                } else {\n                    tmp.addChild(child);\n                }\n            });\n        }\n        this.fixupNodes(root, arrayPrefix.join(SEP) + SEP);\n        this.calculateMetrics(root);\n        this.root = root;\n        this.map = {};\n        this.indexAndSortTree(root, this.map);\n    },\n\n    fixupNodes: function (node, prefix, parent) {\n        var that = this;\n        if (node.name.indexOf(prefix) === 0) {\n            node.name = node.name.substring(prefix.length);\n        }\n        if (node.name.charAt(0) === SEP) {\n            node.name = node.name.substring(1);\n        }\n        if (parent) {\n            if (parent.name !== '__root__' + SEP) {\n                node.relativeName = node.name.substring(parent.name.length);\n            } else {\n                node.relativeName = node.name;\n            }\n        } else {\n            node.relativeName = node.name.substring(prefix.length);\n        }\n        node.children.forEach(function (child) {\n            that.fixupNodes(child, prefix, node);\n        });\n    },\n    calculateMetrics: function (entry) {\n        var that = this,\n            fileChildren;\n        if (entry.kind !== 'dir') {return; }\n        entry.children.forEach(function (child) {\n            that.calculateMetrics(child);\n        });\n        entry.metrics = utils.mergeSummaryObjects.apply(\n            null,\n            entry.children.map(function (child) { return child.metrics; })\n        );\n        // calclulate \"java-style\" package metrics where there is no hierarchy\n        // across packages\n        fileChildren = entry.children.filter(function (n) { return n.kind !== 'dir'; });\n        if (fileChildren.length > 0) {\n            entry.packageMetrics = utils.mergeSummaryObjects.apply(\n                null,\n                fileChildren.map(function (child) { return child.metrics; })\n            );\n        } else {\n            entry.packageMetrics = null;\n        }\n    },\n    indexAndSortTree: function (node, map) {\n        var that = this;\n        map[node.name] = node;\n        node.children.sort(function (a, b) {\n            a = a.relativeName;\n            b = b.relativeName;\n            return a < b ? -1 : a > b ? 1 : 0;\n        });\n        node.children.forEach(function (child) {\n            that.indexAndSortTree(child, map);\n        });\n    },\n    toJSON: function () {\n        return {\n            prefix: this.prefix,\n            root: this.root.toJSON()\n        };\n    }\n};\n\nfunction TreeSummarizer() {\n    this.summaryMap = {};\n}\n\nTreeSummarizer.prototype = {\n    addFileCoverageSummary: function (filePath, metrics) {\n        this.summaryMap[filePath] = metrics;\n    },\n    getTreeSummary: function () {\n        var commonArrayPrefix = findCommonArrayPrefix(Object.keys(this.summaryMap));\n        return new TreeSummary(this.summaryMap, commonArrayPrefix);\n    }\n};\n\nmodule.exports = TreeSummarizer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL3V0aWwvdHJlZS1zdW1tYXJpemVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QjtBQUNBLFlBQVksbUJBQU8sQ0FBQyw2RUFBaUI7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4Qyx3QkFBd0I7QUFDdEU7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx1QkFBdUI7QUFDakY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxTQUFTOztBQUVUO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtEQUFrRCx1QkFBdUI7QUFDekU7QUFDQTtBQUNBO0FBQ0EsNERBQTRELDBCQUEwQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsdUJBQXVCO0FBQzNFO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9zYy1pc3RhbmJ1bC9saWIvdXRpbC90cmVlLXN1bW1hcml6ZXIuanM/NGRkZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuIENvcHlyaWdodCAoYykgMjAxMiwgWWFob28hIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG5cbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpLFxuICAgIFNFUCA9IHBhdGguc2VwIHx8ICcvJyxcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4uL29iamVjdC11dGlscycpO1xuXG5mdW5jdGlvbiBjb21tb25BcnJheVByZWZpeChmaXJzdCwgc2Vjb25kKSB7XG4gICAgdmFyIGxlbiA9IGZpcnN0Lmxlbmd0aCA8IHNlY29uZC5sZW5ndGggPyBmaXJzdC5sZW5ndGggOiBzZWNvbmQubGVuZ3RoLFxuICAgICAgICBpLFxuICAgICAgICByZXQgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGZpcnN0W2ldID09PSBzZWNvbmRbaV0pIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGZpcnN0W2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRDb21tb25BcnJheVByZWZpeChhcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgc2VwYXJhdGVkID0gYXJncy5tYXAoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gYXJnLnNwbGl0KFNFUCk7IH0pLFxuICAgICAgICByZXQgPSBzZXBhcmF0ZWQucG9wKCk7XG5cbiAgICBpZiAoc2VwYXJhdGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcmV0LnNsaWNlKDAsIHJldC5sZW5ndGggLSAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VwYXJhdGVkLnJlZHVjZShjb21tb25BcnJheVByZWZpeCwgcmV0KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIE5vZGUoZnVsbE5hbWUsIGtpbmQsIG1ldHJpY3MpIHtcbiAgICB0aGlzLm5hbWUgPSBmdWxsTmFtZTtcbiAgICB0aGlzLmZ1bGxOYW1lID0gZnVsbE5hbWU7XG4gICAgdGhpcy5raW5kID0ga2luZDtcbiAgICB0aGlzLm1ldHJpY3MgPSBtZXRyaWNzIHx8IG51bGw7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbn1cblxuTm9kZS5wcm90b3R5cGUgPSB7XG4gICAgZGlzcGxheVNob3J0TmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWxhdGl2ZU5hbWU7XG4gICAgfSxcbiAgICBmdWxsUGF0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mdWxsTmFtZTtcbiAgICB9LFxuICAgIGFkZENoaWxkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICB9LFxuICAgIHRvSlNPTjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgcmVsYXRpdmVOYW1lOiB0aGlzLnJlbGF0aXZlTmFtZSxcbiAgICAgICAgICAgIGZ1bGxOYW1lOiB0aGlzLmZ1bGxOYW1lLFxuICAgICAgICAgICAga2luZDogdGhpcy5raW5kLFxuICAgICAgICAgICAgbWV0cmljczogdGhpcy5tZXRyaWNzLFxuICAgICAgICAgICAgcGFyZW50OiB0aGlzLnBhcmVudCA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLnBhcmVudC5uYW1lLFxuICAgICAgICAgICAgY2hpbGRyZW46IHRoaXMuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnRvSlNPTigpOyB9KVxuICAgICAgICB9O1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIFRyZWVTdW1tYXJ5KHN1bW1hcnlNYXAsIGNvbW1vblByZWZpeCkge1xuICAgIHRoaXMucHJlZml4ID0gY29tbW9uUHJlZml4O1xuICAgIHRoaXMuY29udmVydFRvVHJlZShzdW1tYXJ5TWFwLCBjb21tb25QcmVmaXgpO1xufVxuXG5UcmVlU3VtbWFyeS5wcm90b3R5cGUgPSB7XG4gICAgZ2V0Tm9kZTogZnVuY3Rpb24gKHNob3J0TmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXBbc2hvcnROYW1lXTtcbiAgICB9LFxuICAgIGNvbnZlcnRUb1RyZWU6IGZ1bmN0aW9uIChzdW1tYXJ5TWFwLCBhcnJheVByZWZpeCkge1xuICAgICAgICB2YXIgbm9kZXMgPSBbXSxcbiAgICAgICAgICAgIHJvb3RQYXRoID0gYXJyYXlQcmVmaXguam9pbihTRVApICsgU0VQLFxuICAgICAgICAgICAgcm9vdCA9IG5ldyBOb2RlKHJvb3RQYXRoLCAnZGlyJyksXG4gICAgICAgICAgICB0bXAsXG4gICAgICAgICAgICB0bXBDaGlsZHJlbixcbiAgICAgICAgICAgIHNlZW4gPSB7fSxcbiAgICAgICAgICAgIGZpbGVzVW5kZXJSb290ID0gZmFsc2U7XG5cbiAgICAgICAgc2Vlbltyb290UGF0aF0gPSByb290O1xuICAgICAgICBPYmplY3Qua2V5cyhzdW1tYXJ5TWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBtZXRyaWNzID0gc3VtbWFyeU1hcFtrZXldLFxuICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgcGFyZW50UGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ7XG4gICAgICAgICAgICBub2RlID0gbmV3IE5vZGUoa2V5LCAnZmlsZScsIG1ldHJpY3MpO1xuICAgICAgICAgICAgc2VlbltrZXldID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICBwYXJlbnRQYXRoID0gcGF0aC5kaXJuYW1lKGtleSkgKyBTRVA7XG4gICAgICAgICAgICBpZiAocGFyZW50UGF0aCA9PT0gU0VQICsgU0VQIHx8IHBhcmVudFBhdGggPT09ICcuJyArIFNFUCkge1xuICAgICAgICAgICAgICAgIHBhcmVudFBhdGggPSBTRVAgKyAnX19yb290X18nICsgU0VQO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gc2VlbltwYXJlbnRQYXRoXTtcbiAgICAgICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbmV3IE5vZGUocGFyZW50UGF0aCwgJ2RpcicpO1xuICAgICAgICAgICAgICAgIHJvb3QuYWRkQ2hpbGQocGFyZW50KTtcbiAgICAgICAgICAgICAgICBzZWVuW3BhcmVudFBhdGhdID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50LmFkZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gcm9vdCkgeyBmaWxlc1VuZGVyUm9vdCA9IHRydWU7IH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGZpbGVzVW5kZXJSb290ICYmIGFycmF5UHJlZml4Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGFycmF5UHJlZml4LnBvcCgpOyAvL3N0YXJ0IGF0IG9uZSBsZXZlbCBhYm92ZVxuICAgICAgICAgICAgdG1wID0gcm9vdDtcbiAgICAgICAgICAgIHRtcENoaWxkcmVuID0gdG1wLmNoaWxkcmVuO1xuICAgICAgICAgICAgdG1wLmNoaWxkcmVuID0gW107XG4gICAgICAgICAgICByb290ID0gbmV3IE5vZGUoYXJyYXlQcmVmaXguam9pbihTRVApICsgU0VQLCAnZGlyJyk7XG4gICAgICAgICAgICByb290LmFkZENoaWxkKHRtcCk7XG4gICAgICAgICAgICB0bXBDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5raW5kID09PSAnZGlyJykge1xuICAgICAgICAgICAgICAgICAgICByb290LmFkZENoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0bXAuYWRkQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZml4dXBOb2Rlcyhyb290LCBhcnJheVByZWZpeC5qb2luKFNFUCkgKyBTRVApO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZU1ldHJpY3Mocm9vdCk7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMubWFwID0ge307XG4gICAgICAgIHRoaXMuaW5kZXhBbmRTb3J0VHJlZShyb290LCB0aGlzLm1hcCk7XG4gICAgfSxcblxuICAgIGZpeHVwTm9kZXM6IGZ1bmN0aW9uIChub2RlLCBwcmVmaXgsIHBhcmVudCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIGlmIChub2RlLm5hbWUuaW5kZXhPZihwcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICBub2RlLm5hbWUgPSBub2RlLm5hbWUuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLm5hbWUuY2hhckF0KDApID09PSBTRVApIHtcbiAgICAgICAgICAgIG5vZGUubmFtZSA9IG5vZGUubmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC5uYW1lICE9PSAnX19yb290X18nICsgU0VQKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZWxhdGl2ZU5hbWUgPSBub2RlLm5hbWUuc3Vic3RyaW5nKHBhcmVudC5uYW1lLmxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUucmVsYXRpdmVOYW1lID0gbm9kZS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5yZWxhdGl2ZU5hbWUgPSBub2RlLm5hbWUuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHRoYXQuZml4dXBOb2RlcyhjaGlsZCwgcHJlZml4LCBub2RlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBjYWxjdWxhdGVNZXRyaWNzOiBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgZmlsZUNoaWxkcmVuO1xuICAgICAgICBpZiAoZW50cnkua2luZCAhPT0gJ2RpcicpIHtyZXR1cm47IH1cbiAgICAgICAgZW50cnkuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHRoYXQuY2FsY3VsYXRlTWV0cmljcyhjaGlsZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbnRyeS5tZXRyaWNzID0gdXRpbHMubWVyZ2VTdW1tYXJ5T2JqZWN0cy5hcHBseShcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBlbnRyeS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5tZXRyaWNzOyB9KVxuICAgICAgICApO1xuICAgICAgICAvLyBjYWxjbHVsYXRlIFwiamF2YS1zdHlsZVwiIHBhY2thZ2UgbWV0cmljcyB3aGVyZSB0aGVyZSBpcyBubyBoaWVyYXJjaHlcbiAgICAgICAgLy8gYWNyb3NzIHBhY2thZ2VzXG4gICAgICAgIGZpbGVDaGlsZHJlbiA9IGVudHJ5LmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAobikgeyByZXR1cm4gbi5raW5kICE9PSAnZGlyJzsgfSk7XG4gICAgICAgIGlmIChmaWxlQ2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZW50cnkucGFja2FnZU1ldHJpY3MgPSB1dGlscy5tZXJnZVN1bW1hcnlPYmplY3RzLmFwcGx5KFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgZmlsZUNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLm1ldHJpY3M7IH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW50cnkucGFja2FnZU1ldHJpY3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBpbmRleEFuZFNvcnRUcmVlOiBmdW5jdGlvbiAobm9kZSwgbWFwKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgbWFwW25vZGUubmFtZV0gPSBub2RlO1xuICAgICAgICBub2RlLmNoaWxkcmVuLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGEgPSBhLnJlbGF0aXZlTmFtZTtcbiAgICAgICAgICAgIGIgPSBiLnJlbGF0aXZlTmFtZTtcbiAgICAgICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbiAgICAgICAgfSk7XG4gICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHRoYXQuaW5kZXhBbmRTb3J0VHJlZShjaGlsZCwgbWFwKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICB0b0pTT046IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByZWZpeDogdGhpcy5wcmVmaXgsXG4gICAgICAgICAgICByb290OiB0aGlzLnJvb3QudG9KU09OKClcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBUcmVlU3VtbWFyaXplcigpIHtcbiAgICB0aGlzLnN1bW1hcnlNYXAgPSB7fTtcbn1cblxuVHJlZVN1bW1hcml6ZXIucHJvdG90eXBlID0ge1xuICAgIGFkZEZpbGVDb3ZlcmFnZVN1bW1hcnk6IGZ1bmN0aW9uIChmaWxlUGF0aCwgbWV0cmljcykge1xuICAgICAgICB0aGlzLnN1bW1hcnlNYXBbZmlsZVBhdGhdID0gbWV0cmljcztcbiAgICB9LFxuICAgIGdldFRyZWVTdW1tYXJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb21tb25BcnJheVByZWZpeCA9IGZpbmRDb21tb25BcnJheVByZWZpeChPYmplY3Qua2V5cyh0aGlzLnN1bW1hcnlNYXApKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlU3VtbWFyeSh0aGlzLnN1bW1hcnlNYXAsIGNvbW1vbkFycmF5UHJlZml4KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyZWVTdW1tYXJpemVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/lib/util/tree-summarizer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/lib/util/writer.js":
/*!*****************************************************!*\
  !*** ./node_modules/sc-istanbul/lib/util/writer.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar util = __webpack_require__(/*! util */ \"util\"),\n    EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\n\nfunction extend(cons, proto) {\n    Object.keys(proto).forEach(function (k) {\n        cons.prototype[k] = proto[k];\n    });\n}\n\n/**\n * abstract interfaces for writing content\n * @class ContentWriter\n * @module io\n * @main io\n * @constructor\n */\n//abstract interface for writing content\nfunction ContentWriter() {\n}\n\nContentWriter.prototype = {\n    /**\n     * writes the specified string as-is\n     * @method write\n     * @param {String} str the string to write\n     */\n    write: /* istanbul ignore next: abstract method */ function (/* str */) {\n        throw new Error('write: must be overridden');\n    },\n    /**\n     * writes the specified string with a newline at the end\n     * @method println\n     * @param {String} str the string to write\n     */\n    println: function (str) { this.write(str + '\\n'); }\n};\n\n/**\n * abstract interface for writing files and assets. The caller is expected to\n * call `done` on the writer after it has finished writing all the required\n * files. The writer is an event-emitter that emits a `done` event when `done`\n * is called on it *and* all files have successfully been written.\n *\n * @class Writer\n * @constructor\n */\nfunction Writer() {\n    EventEmitter.call(this);\n}\n\nutil.inherits(Writer, EventEmitter);\n\nextend(Writer, {\n    /**\n     * allows writing content to a file using a callback that is passed a content writer\n     * @method writeFile\n     * @param {String} file the name of the file to write\n     * @param {Function} callback the callback that is called as `callback(contentWriter)`\n     */\n    writeFile: /* istanbul ignore next: abstract method */ function (/* file, callback */) {\n        throw new Error('writeFile: must be overridden');\n    },\n    /**\n     * copies a file from source to destination\n     * @method copyFile\n     * @param {String} source the file to copy, found on the file system\n     * @param {String} dest the destination path\n     */\n    copyFile: /* istanbul ignore next: abstract method */ function (/* source, dest */) {\n        throw new Error('copyFile: must be overridden');\n    },\n    /**\n     * marker method to indicate that the caller is done with this writer object\n     * The writer is expected to emit a `done` event only after this method is called\n     * and it is truly done.\n     * @method done\n     */\n    done: /* istanbul ignore next: abstract method */ function () {\n        throw new Error('done: must be overridden');\n    }\n});\n\nmodule.exports = {\n    Writer: Writer,\n    ContentWriter: ContentWriter\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL3V0aWwvd3JpdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixtQkFBbUIsMERBQThCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9zYy1pc3RhbmJ1bC9saWIvdXRpbC93cml0ZXIuanM/YTE3YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuIENvcHlyaWdodCAoYykgMjAxMiwgWWFob28hIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpLFxuICAgIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuZnVuY3Rpb24gZXh0ZW5kKGNvbnMsIHByb3RvKSB7XG4gICAgT2JqZWN0LmtleXMocHJvdG8pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgY29ucy5wcm90b3R5cGVba10gPSBwcm90b1trXTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBhYnN0cmFjdCBpbnRlcmZhY2VzIGZvciB3cml0aW5nIGNvbnRlbnRcbiAqIEBjbGFzcyBDb250ZW50V3JpdGVyXG4gKiBAbW9kdWxlIGlvXG4gKiBAbWFpbiBpb1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbi8vYWJzdHJhY3QgaW50ZXJmYWNlIGZvciB3cml0aW5nIGNvbnRlbnRcbmZ1bmN0aW9uIENvbnRlbnRXcml0ZXIoKSB7XG59XG5cbkNvbnRlbnRXcml0ZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHdyaXRlcyB0aGUgc3BlY2lmaWVkIHN0cmluZyBhcy1pc1xuICAgICAqIEBtZXRob2Qgd3JpdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gd3JpdGVcbiAgICAgKi9cbiAgICB3cml0ZTogLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGFic3RyYWN0IG1ldGhvZCAqLyBmdW5jdGlvbiAoLyogc3RyICovKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd3JpdGU6IG11c3QgYmUgb3ZlcnJpZGRlbicpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogd3JpdGVzIHRoZSBzcGVjaWZpZWQgc3RyaW5nIHdpdGggYSBuZXdsaW5lIGF0IHRoZSBlbmRcbiAgICAgKiBAbWV0aG9kIHByaW50bG5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gd3JpdGVcbiAgICAgKi9cbiAgICBwcmludGxuOiBmdW5jdGlvbiAoc3RyKSB7IHRoaXMud3JpdGUoc3RyICsgJ1xcbicpOyB9XG59O1xuXG4vKipcbiAqIGFic3RyYWN0IGludGVyZmFjZSBmb3Igd3JpdGluZyBmaWxlcyBhbmQgYXNzZXRzLiBUaGUgY2FsbGVyIGlzIGV4cGVjdGVkIHRvXG4gKiBjYWxsIGBkb25lYCBvbiB0aGUgd3JpdGVyIGFmdGVyIGl0IGhhcyBmaW5pc2hlZCB3cml0aW5nIGFsbCB0aGUgcmVxdWlyZWRcbiAqIGZpbGVzLiBUaGUgd3JpdGVyIGlzIGFuIGV2ZW50LWVtaXR0ZXIgdGhhdCBlbWl0cyBhIGBkb25lYCBldmVudCB3aGVuIGBkb25lYFxuICogaXMgY2FsbGVkIG9uIGl0ICphbmQqIGFsbCBmaWxlcyBoYXZlIHN1Y2Nlc3NmdWxseSBiZWVuIHdyaXR0ZW4uXG4gKlxuICogQGNsYXNzIFdyaXRlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFdyaXRlcigpIHtcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbn1cblxudXRpbC5pbmhlcml0cyhXcml0ZXIsIEV2ZW50RW1pdHRlcik7XG5cbmV4dGVuZChXcml0ZXIsIHtcbiAgICAvKipcbiAgICAgKiBhbGxvd3Mgd3JpdGluZyBjb250ZW50IHRvIGEgZmlsZSB1c2luZyBhIGNhbGxiYWNrIHRoYXQgaXMgcGFzc2VkIGEgY29udGVudCB3cml0ZXJcbiAgICAgKiBAbWV0aG9kIHdyaXRlRmlsZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlIHRoZSBuYW1lIG9mIHRoZSBmaWxlIHRvIHdyaXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIGFzIGBjYWxsYmFjayhjb250ZW50V3JpdGVyKWBcbiAgICAgKi9cbiAgICB3cml0ZUZpbGU6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBhYnN0cmFjdCBtZXRob2QgKi8gZnVuY3Rpb24gKC8qIGZpbGUsIGNhbGxiYWNrICovKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd3JpdGVGaWxlOiBtdXN0IGJlIG92ZXJyaWRkZW4nKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGNvcGllcyBhIGZpbGUgZnJvbSBzb3VyY2UgdG8gZGVzdGluYXRpb25cbiAgICAgKiBAbWV0aG9kIGNvcHlGaWxlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZSB0aGUgZmlsZSB0byBjb3B5LCBmb3VuZCBvbiB0aGUgZmlsZSBzeXN0ZW1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVzdCB0aGUgZGVzdGluYXRpb24gcGF0aFxuICAgICAqL1xuICAgIGNvcHlGaWxlOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogYWJzdHJhY3QgbWV0aG9kICovIGZ1bmN0aW9uICgvKiBzb3VyY2UsIGRlc3QgKi8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3B5RmlsZTogbXVzdCBiZSBvdmVycmlkZGVuJyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBtYXJrZXIgbWV0aG9kIHRvIGluZGljYXRlIHRoYXQgdGhlIGNhbGxlciBpcyBkb25lIHdpdGggdGhpcyB3cml0ZXIgb2JqZWN0XG4gICAgICogVGhlIHdyaXRlciBpcyBleHBlY3RlZCB0byBlbWl0IGEgYGRvbmVgIGV2ZW50IG9ubHkgYWZ0ZXIgdGhpcyBtZXRob2QgaXMgY2FsbGVkXG4gICAgICogYW5kIGl0IGlzIHRydWx5IGRvbmUuXG4gICAgICogQG1ldGhvZCBkb25lXG4gICAgICovXG4gICAgZG9uZTogLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGFic3RyYWN0IG1ldGhvZCAqLyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZG9uZTogbXVzdCBiZSBvdmVycmlkZGVuJyk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFdyaXRlcjogV3JpdGVyLFxuICAgIENvbnRlbnRXcml0ZXI6IENvbnRlbnRXcml0ZXJcbn07XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/lib/util/writer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/lib/util/yui-load-hook.js":
/*!************************************************************!*\
  !*** ./node_modules/sc-istanbul/lib/util/yui-load-hook.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n//EXPERIMENTAL code: do not rely on this in anyway until the docs say it is allowed\n\nvar path = __webpack_require__(/*! path */ \"path\"),\n    yuiRegexp = /yui-nodejs\\.js$/;\n\nmodule.exports = function (matchFn, transformFn, verbose) {\n    return function (file) {\n        if (!file.match(yuiRegexp)) {\n            return;\n        }\n        var YMain = __webpack_require__(\"(ssr)/./node_modules/sc-istanbul/lib/util sync recursive\")(file),\n            YUI,\n            loaderFn,\n            origGet;\n\n        if (YMain.YUI) {\n            YUI = YMain.YUI;\n            loaderFn = YUI.Env && YUI.Env.mods && YUI.Env.mods['loader-base'] ? YUI.Env.mods['loader-base'].fn : null;\n            if (!loaderFn) { return; }\n            if (verbose) { console.log('Applying YUI load post-hook'); }\n            YUI.Env.mods['loader-base'].fn = function (Y) {\n                loaderFn.call(null, Y);\n                origGet = Y.Get._exec;\n                Y.Get._exec = function (data, url, cb) {\n                    if (matchFn(url) || matchFn(path.resolve(url))) { //allow for relative paths as well\n                        if (verbose) {\n                            console.log('Transforming [' + url + ']');\n                        }\n                        try {\n                            data = transformFn(data, url);\n                        } catch (ex) {\n                            console.error('Error transforming: ' + url + ' return original code');\n                            console.error(ex.message || ex);\n                            if (ex.stack) { console.error(ex.stack); }\n                        }\n                    }\n                    return origGet.call(Y, data, url, cb);\n                };\n                return Y;\n            };\n        }\n    };\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL3V0aWwveXVpLWxvYWQtaG9vay5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnRkFBUSxJQUFJLENBQUM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbGliL3V0aWwveXVpLWxvYWQtaG9vay5qcz83ZmI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gQ29weXJpZ2h0IChjKSAyMDEyLCBZYWhvbyEgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cblxuLy9FWFBFUklNRU5UQUwgY29kZTogZG8gbm90IHJlbHkgb24gdGhpcyBpbiBhbnl3YXkgdW50aWwgdGhlIGRvY3Mgc2F5IGl0IGlzIGFsbG93ZWRcblxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyksXG4gICAgeXVpUmVnZXhwID0gL3l1aS1ub2RlanNcXC5qcyQvO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRjaEZuLCB0cmFuc2Zvcm1GbiwgdmVyYm9zZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICBpZiAoIWZpbGUubWF0Y2goeXVpUmVnZXhwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBZTWFpbiA9IHJlcXVpcmUoZmlsZSksXG4gICAgICAgICAgICBZVUksXG4gICAgICAgICAgICBsb2FkZXJGbixcbiAgICAgICAgICAgIG9yaWdHZXQ7XG5cbiAgICAgICAgaWYgKFlNYWluLllVSSkge1xuICAgICAgICAgICAgWVVJID0gWU1haW4uWVVJO1xuICAgICAgICAgICAgbG9hZGVyRm4gPSBZVUkuRW52ICYmIFlVSS5FbnYubW9kcyAmJiBZVUkuRW52Lm1vZHNbJ2xvYWRlci1iYXNlJ10gPyBZVUkuRW52Lm1vZHNbJ2xvYWRlci1iYXNlJ10uZm4gOiBudWxsO1xuICAgICAgICAgICAgaWYgKCFsb2FkZXJGbikgeyByZXR1cm47IH1cbiAgICAgICAgICAgIGlmICh2ZXJib3NlKSB7IGNvbnNvbGUubG9nKCdBcHBseWluZyBZVUkgbG9hZCBwb3N0LWhvb2snKTsgfVxuICAgICAgICAgICAgWVVJLkVudi5tb2RzWydsb2FkZXItYmFzZSddLmZuID0gZnVuY3Rpb24gKFkpIHtcbiAgICAgICAgICAgICAgICBsb2FkZXJGbi5jYWxsKG51bGwsIFkpO1xuICAgICAgICAgICAgICAgIG9yaWdHZXQgPSBZLkdldC5fZXhlYztcbiAgICAgICAgICAgICAgICBZLkdldC5fZXhlYyA9IGZ1bmN0aW9uIChkYXRhLCB1cmwsIGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaEZuKHVybCkgfHwgbWF0Y2hGbihwYXRoLnJlc29sdmUodXJsKSkpIHsgLy9hbGxvdyBmb3IgcmVsYXRpdmUgcGF0aHMgYXMgd2VsbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVHJhbnNmb3JtaW5nIFsnICsgdXJsICsgJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRyYW5zZm9ybUZuKGRhdGEsIHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHRyYW5zZm9ybWluZzogJyArIHVybCArICcgcmV0dXJuIG9yaWdpbmFsIGNvZGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGV4Lm1lc3NhZ2UgfHwgZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleC5zdGFjaykgeyBjb25zb2xlLmVycm9yKGV4LnN0YWNrKTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnR2V0LmNhbGwoWSwgZGF0YSwgdXJsLCBjYik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/lib/util/yui-load-hook.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/node_modules/async/lib/async.js":
/*!******************************************************************!*\
  !*** ./node_modules/sc-istanbul/node_modules/async/lib/async.js ***!
  \******************************************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * async\n * https://github.com/caolan/async\n *\n * Copyright 2010-2014 Caolan McMahon\n * Released under the MIT license\n */\n(function () {\n\n    var async = {};\n    function noop() {}\n    function identity(v) {\n        return v;\n    }\n    function toBool(v) {\n        return !!v;\n    }\n    function notId(v) {\n        return !v;\n    }\n\n    // global on the server, window in the browser\n    var previous_async;\n\n    // Establish the root object, `window` (`self`) in the browser, `global`\n    // on the server, or `this` in some virtual machines. We use `self`\n    // instead of `window` for `WebWorker` support.\n    var root = typeof self === 'object' && self.self === self && self ||\n            typeof global === 'object' && global.global === global && global ||\n            this;\n\n    if (root != null) {\n        previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        return function() {\n            if (fn === null) throw new Error(\"Callback was already called.\");\n            fn.apply(this, arguments);\n            fn = null;\n        };\n    }\n\n    function _once(fn) {\n        return function() {\n            if (fn === null) return;\n            fn.apply(this, arguments);\n            fn = null;\n        };\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _toString = Object.prototype.toString;\n\n    var _isArray = Array.isArray || function (obj) {\n        return _toString.call(obj) === '[object Array]';\n    };\n\n    // Ported from underscore.js isObject\n    var _isObject = function(obj) {\n        var type = typeof obj;\n        return type === 'function' || type === 'object' && !!obj;\n    };\n\n    function _isArrayLike(arr) {\n        return _isArray(arr) || (\n            // has a positive integer length property\n            typeof arr.length === \"number\" &&\n            arr.length >= 0 &&\n            arr.length % 1 === 0\n        );\n    }\n\n    function _arrayEach(arr, iterator) {\n        var index = -1,\n            length = arr.length;\n\n        while (++index < length) {\n            iterator(arr[index], index, arr);\n        }\n    }\n\n    function _map(arr, iterator) {\n        var index = -1,\n            length = arr.length,\n            result = Array(length);\n\n        while (++index < length) {\n            result[index] = iterator(arr[index], index, arr);\n        }\n        return result;\n    }\n\n    function _range(count) {\n        return _map(Array(count), function (v, i) { return i; });\n    }\n\n    function _reduce(arr, iterator, memo) {\n        _arrayEach(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    }\n\n    function _forEachOf(object, iterator) {\n        _arrayEach(_keys(object), function (key) {\n            iterator(object[key], key);\n        });\n    }\n\n    function _indexOf(arr, item) {\n        for (var i = 0; i < arr.length; i++) {\n            if (arr[i] === item) return i;\n        }\n        return -1;\n    }\n\n    var _keys = Object.keys || function (obj) {\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    function _keyIterator(coll) {\n        var i = -1;\n        var len;\n        var keys;\n        if (_isArrayLike(coll)) {\n            len = coll.length;\n            return function next() {\n                i++;\n                return i < len ? i : null;\n            };\n        } else {\n            keys = _keys(coll);\n            len = keys.length;\n            return function next() {\n                i++;\n                return i < len ? keys[i] : null;\n            };\n        }\n    }\n\n    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)\n    // This accumulates the arguments passed into an array, after a given index.\n    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).\n    function _restParam(func, startIndex) {\n        startIndex = startIndex == null ? func.length - 1 : +startIndex;\n        return function() {\n            var length = Math.max(arguments.length - startIndex, 0);\n            var rest = Array(length);\n            for (var index = 0; index < length; index++) {\n                rest[index] = arguments[index + startIndex];\n            }\n            switch (startIndex) {\n                case 0: return func.call(this, rest);\n                case 1: return func.call(this, arguments[0], rest);\n            }\n            // Currently unused but handle cases outside of the switch statement:\n            // var args = Array(startIndex + 1);\n            // for (index = 0; index < startIndex; index++) {\n            //     args[index] = arguments[index];\n            // }\n            // args[startIndex] = rest;\n            // return func.apply(this, args);\n        };\n    }\n\n    function _withoutIndex(iterator) {\n        return function (value, index, callback) {\n            return iterator(value, callback);\n        };\n    }\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n\n    // capture the global reference to guard against fakeTimer mocks\n    var _setImmediate = typeof setImmediate === 'function' && setImmediate;\n\n    var _delay = _setImmediate ? function(fn) {\n        // not a direct alias for IE10 compatibility\n        _setImmediate(fn);\n    } : function(fn) {\n        setTimeout(fn, 0);\n    };\n\n    if (typeof process === 'object' && typeof process.nextTick === 'function') {\n        async.nextTick = process.nextTick;\n    } else {\n        async.nextTick = _delay;\n    }\n    async.setImmediate = _setImmediate ? _delay : async.nextTick;\n\n\n    async.forEach =\n    async.each = function (arr, iterator, callback) {\n        return async.eachOf(arr, _withoutIndex(iterator), callback);\n    };\n\n    async.forEachSeries =\n    async.eachSeries = function (arr, iterator, callback) {\n        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);\n    };\n\n\n    async.forEachLimit =\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);\n    };\n\n    async.forEachOf =\n    async.eachOf = function (object, iterator, callback) {\n        callback = _once(callback || noop);\n        object = object || [];\n\n        var iter = _keyIterator(object);\n        var key, completed = 0;\n\n        while ((key = iter()) != null) {\n            completed += 1;\n            iterator(object[key], key, only_once(done));\n        }\n\n        if (completed === 0) callback(null);\n\n        function done(err) {\n            completed--;\n            if (err) {\n                callback(err);\n            }\n            // Check key is null in case iterator isn't exhausted\n            // and done resolved synchronously.\n            else if (key === null && completed <= 0) {\n                callback(null);\n            }\n        }\n    };\n\n    async.forEachOfSeries =\n    async.eachOfSeries = function (obj, iterator, callback) {\n        callback = _once(callback || noop);\n        obj = obj || [];\n        var nextKey = _keyIterator(obj);\n        var key = nextKey();\n        function iterate() {\n            var sync = true;\n            if (key === null) {\n                return callback(null);\n            }\n            iterator(obj[key], key, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    key = nextKey();\n                    if (key === null) {\n                        return callback(null);\n                    } else {\n                        if (sync) {\n                            async.setImmediate(iterate);\n                        } else {\n                            iterate();\n                        }\n                    }\n                }\n            }));\n            sync = false;\n        }\n        iterate();\n    };\n\n\n\n    async.forEachOfLimit =\n    async.eachOfLimit = function (obj, limit, iterator, callback) {\n        _eachOfLimit(limit)(obj, iterator, callback);\n    };\n\n    function _eachOfLimit(limit) {\n\n        return function (obj, iterator, callback) {\n            callback = _once(callback || noop);\n            obj = obj || [];\n            var nextKey = _keyIterator(obj);\n            if (limit <= 0) {\n                return callback(null);\n            }\n            var done = false;\n            var running = 0;\n            var errored = false;\n\n            (function replenish () {\n                if (done && running <= 0) {\n                    return callback(null);\n                }\n\n                while (running < limit && !errored) {\n                    var key = nextKey();\n                    if (key === null) {\n                        done = true;\n                        if (running <= 0) {\n                            callback(null);\n                        }\n                        return;\n                    }\n                    running += 1;\n                    iterator(obj[key], key, only_once(function (err) {\n                        running -= 1;\n                        if (err) {\n                            callback(err);\n                            errored = true;\n                        }\n                        else {\n                            replenish();\n                        }\n                    }));\n                }\n            })();\n        };\n    }\n\n\n    function doParallel(fn) {\n        return function (obj, iterator, callback) {\n            return fn(async.eachOf, obj, iterator, callback);\n        };\n    }\n    function doParallelLimit(fn) {\n        return function (obj, limit, iterator, callback) {\n            return fn(_eachOfLimit(limit), obj, iterator, callback);\n        };\n    }\n    function doSeries(fn) {\n        return function (obj, iterator, callback) {\n            return fn(async.eachOfSeries, obj, iterator, callback);\n        };\n    }\n\n    function _asyncMap(eachfn, arr, iterator, callback) {\n        callback = _once(callback || noop);\n        arr = arr || [];\n        var results = _isArrayLike(arr) ? [] : {};\n        eachfn(arr, function (value, index, callback) {\n            iterator(value, function (err, v) {\n                results[index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    }\n\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = doParallelLimit(_asyncMap);\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.inject =\n    async.foldl =\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachOfSeries(arr, function (x, i, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n\n    async.foldr =\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, identity).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n\n    async.transform = function (arr, memo, iterator, callback) {\n        if (arguments.length === 3) {\n            callback = iterator;\n            iterator = memo;\n            memo = _isArray(arr) ? [] : {};\n        }\n\n        async.eachOf(arr, function(v, k, cb) {\n            iterator(memo, v, k, cb);\n        }, function(err) {\n            callback(err, memo);\n        });\n    };\n\n    function _filter(eachfn, arr, iterator, callback) {\n        var results = [];\n        eachfn(arr, function (x, index, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    results.push({index: index, value: x});\n                }\n                callback();\n            });\n        }, function () {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    }\n\n    async.select =\n    async.filter = doParallel(_filter);\n\n    async.selectLimit =\n    async.filterLimit = doParallelLimit(_filter);\n\n    async.selectSeries =\n    async.filterSeries = doSeries(_filter);\n\n    function _reject(eachfn, arr, iterator, callback) {\n        _filter(eachfn, arr, function(value, cb) {\n            iterator(value, function(v) {\n                cb(!v);\n            });\n        }, callback);\n    }\n    async.reject = doParallel(_reject);\n    async.rejectLimit = doParallelLimit(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    function _createTester(eachfn, check, getResult) {\n        return function(arr, limit, iterator, cb) {\n            function done() {\n                if (cb) cb(getResult(false, void 0));\n            }\n            function iteratee(x, _, callback) {\n                if (!cb) return callback();\n                iterator(x, function (v) {\n                    if (cb && check(v)) {\n                        cb(getResult(true, x));\n                        cb = iterator = false;\n                    }\n                    callback();\n                });\n            }\n            if (arguments.length > 3) {\n                eachfn(arr, limit, iteratee, done);\n            } else {\n                cb = iterator;\n                iterator = limit;\n                eachfn(arr, iteratee, done);\n            }\n        };\n    }\n\n    async.any =\n    async.some = _createTester(async.eachOf, toBool, identity);\n\n    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);\n\n    async.all =\n    async.every = _createTester(async.eachOf, notId, notId);\n\n    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);\n\n    function _findGetResult(v, x) {\n        return x;\n    }\n    async.detect = _createTester(async.eachOf, identity, _findGetResult);\n    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);\n    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                callback(null, _map(results.sort(comparator), function (x) {\n                    return x.value;\n                }));\n            }\n\n        });\n\n        function comparator(left, right) {\n            var a = left.criteria, b = right.criteria;\n            return a < b ? -1 : a > b ? 1 : 0;\n        }\n    };\n\n    async.auto = function (tasks, concurrency, callback) {\n        if (typeof arguments[1] === 'function') {\n            // concurrency is optional, shift the args.\n            callback = concurrency;\n            concurrency = null;\n        }\n        callback = _once(callback || noop);\n        var keys = _keys(tasks);\n        var remainingTasks = keys.length;\n        if (!remainingTasks) {\n            return callback(null);\n        }\n        if (!concurrency) {\n            concurrency = remainingTasks;\n        }\n\n        var results = {};\n        var runningTasks = 0;\n\n        var hasError = false;\n\n        var listeners = [];\n        function addListener(fn) {\n            listeners.unshift(fn);\n        }\n        function removeListener(fn) {\n            var idx = _indexOf(listeners, fn);\n            if (idx >= 0) listeners.splice(idx, 1);\n        }\n        function taskComplete() {\n            remainingTasks--;\n            _arrayEach(listeners.slice(0), function (fn) {\n                fn();\n            });\n        }\n\n        addListener(function () {\n            if (!remainingTasks) {\n                callback(null, results);\n            }\n        });\n\n        _arrayEach(keys, function (k) {\n            if (hasError) return;\n            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\n            var taskCallback = _restParam(function(err, args) {\n                runningTasks--;\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _forEachOf(results, function(val, rkey) {\n                        safeResults[rkey] = val;\n                    });\n                    safeResults[k] = args;\n                    hasError = true;\n\n                    callback(err, safeResults);\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            });\n            var requires = task.slice(0, task.length - 1);\n            // prevent dead-locks\n            var len = requires.length;\n            var dep;\n            while (len--) {\n                if (!(dep = tasks[requires[len]])) {\n                    throw new Error('Has nonexistent dependency in ' + requires.join(', '));\n                }\n                if (_isArray(dep) && _indexOf(dep, k) >= 0) {\n                    throw new Error('Has cyclic dependencies');\n                }\n            }\n            function ready() {\n                return runningTasks < concurrency && _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            }\n            if (ready()) {\n                runningTasks++;\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                addListener(listener);\n            }\n            function listener() {\n                if (ready()) {\n                    runningTasks++;\n                    removeListener(listener);\n                    task[task.length - 1](taskCallback, results);\n                }\n            }\n        });\n    };\n\n\n\n    async.retry = function(times, task, callback) {\n        var DEFAULT_TIMES = 5;\n        var DEFAULT_INTERVAL = 0;\n\n        var attempts = [];\n\n        var opts = {\n            times: DEFAULT_TIMES,\n            interval: DEFAULT_INTERVAL\n        };\n\n        function parseTimes(acc, t){\n            if(typeof t === 'number'){\n                acc.times = parseInt(t, 10) || DEFAULT_TIMES;\n            } else if(typeof t === 'object'){\n                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;\n                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;\n            } else {\n                throw new Error('Unsupported argument type for \\'times\\': ' + typeof t);\n            }\n        }\n\n        var length = arguments.length;\n        if (length < 1 || length > 3) {\n            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');\n        } else if (length <= 2 && typeof times === 'function') {\n            callback = task;\n            task = times;\n        }\n        if (typeof times !== 'function') {\n            parseTimes(opts, times);\n        }\n        opts.callback = callback;\n        opts.task = task;\n\n        function wrappedTask(wrappedCallback, wrappedResults) {\n            function retryAttempt(task, finalAttempt) {\n                return function(seriesCallback) {\n                    task(function(err, result){\n                        seriesCallback(!err || finalAttempt, {err: err, result: result});\n                    }, wrappedResults);\n                };\n            }\n\n            function retryInterval(interval){\n                return function(seriesCallback){\n                    setTimeout(function(){\n                        seriesCallback(null);\n                    }, interval);\n                };\n            }\n\n            while (opts.times) {\n\n                var finalAttempt = !(opts.times-=1);\n                attempts.push(retryAttempt(opts.task, finalAttempt));\n                if(!finalAttempt && opts.interval > 0){\n                    attempts.push(retryInterval(opts.interval));\n                }\n            }\n\n            async.series(attempts, function(done, data){\n                data = data[data.length - 1];\n                (wrappedCallback || opts.callback)(data.err, data.result);\n            });\n        }\n\n        // If a callback is passed, run this as a controll flow\n        return opts.callback ? wrappedTask() : wrappedTask;\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = _once(callback || noop);\n        if (!_isArray(tasks)) {\n            var err = new Error('First argument to waterfall must be an array of functions');\n            return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        function wrapIterator(iterator) {\n            return _restParam(function (err, args) {\n                if (err) {\n                    callback.apply(null, [err].concat(args));\n                }\n                else {\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    ensureAsync(iterator).apply(null, args);\n                }\n            });\n        }\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    function _parallel(eachfn, tasks, callback) {\n        callback = callback || noop;\n        var results = _isArrayLike(tasks) ? [] : {};\n\n        eachfn(tasks, function (task, key, callback) {\n            task(_restParam(function (err, args) {\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                results[key] = args;\n                callback(err);\n            }));\n        }, function (err) {\n            callback(err, results);\n        });\n    }\n\n    async.parallel = function (tasks, callback) {\n        _parallel(async.eachOf, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel(_eachOfLimit(limit), tasks, callback);\n    };\n\n    async.series = function(tasks, callback) {\n        _parallel(async.eachOfSeries, tasks, callback);\n    };\n\n    async.iterator = function (tasks) {\n        function makeCallback(index) {\n            function fn() {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            }\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        }\n        return makeCallback(0);\n    };\n\n    async.apply = _restParam(function (fn, args) {\n        return _restParam(function (callArgs) {\n            return fn.apply(\n                null, args.concat(callArgs)\n            );\n        });\n    });\n\n    function _concat(eachfn, arr, fn, callback) {\n        var result = [];\n        eachfn(arr, function (x, index, cb) {\n            fn(x, function (err, y) {\n                result = result.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, result);\n        });\n    }\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        callback = callback || noop;\n        if (test()) {\n            var next = _restParam(function(err, args) {\n                if (err) {\n                    callback(err);\n                } else if (test.apply(this, args)) {\n                    iterator(next);\n                } else {\n                    callback.apply(null, [null].concat(args));\n                }\n            });\n            iterator(next);\n        } else {\n            callback(null);\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        var calls = 0;\n        return async.whilst(function() {\n            return ++calls <= 1 || test.apply(this, arguments);\n        }, iterator, callback);\n    };\n\n    async.until = function (test, iterator, callback) {\n        return async.whilst(function() {\n            return !test.apply(this, arguments);\n        }, iterator, callback);\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        return async.doWhilst(iterator, function() {\n            return !test.apply(this, arguments);\n        }, callback);\n    };\n\n    async.during = function (test, iterator, callback) {\n        callback = callback || noop;\n\n        var next = _restParam(function(err, args) {\n            if (err) {\n                callback(err);\n            } else {\n                args.push(check);\n                test.apply(this, args);\n            }\n        });\n\n        var check = function(err, truth) {\n            if (err) {\n                callback(err);\n            } else if (truth) {\n                iterator(next);\n            } else {\n                callback(null);\n            }\n        };\n\n        test(check);\n    };\n\n    async.doDuring = function (iterator, test, callback) {\n        var calls = 0;\n        async.during(function(next) {\n            if (calls++ < 1) {\n                next(null, true);\n            } else {\n                test.apply(this, arguments);\n            }\n        }, iterator, callback);\n    };\n\n    function _queue(worker, concurrency, payload) {\n        if (concurrency == null) {\n            concurrency = 1;\n        }\n        else if(concurrency === 0) {\n            throw new Error('Concurrency must not be zero');\n        }\n        function _insert(q, data, pos, callback) {\n            if (callback != null && typeof callback !== \"function\") {\n                throw new Error(\"task callback must be a function\");\n            }\n            q.started = true;\n            if (!_isArray(data)) {\n                data = [data];\n            }\n            if(data.length === 0 && q.idle()) {\n                // call drain immediately if there are no tasks\n                return async.setImmediate(function() {\n                    q.drain();\n                });\n            }\n            _arrayEach(data, function(task) {\n                var item = {\n                    data: task,\n                    callback: callback || noop\n                };\n\n                if (pos) {\n                    q.tasks.unshift(item);\n                } else {\n                    q.tasks.push(item);\n                }\n\n                if (q.tasks.length === q.concurrency) {\n                    q.saturated();\n                }\n            });\n            async.setImmediate(q.process);\n        }\n        function _next(q, tasks) {\n            return function(){\n                workers -= 1;\n\n                var removed = false;\n                var args = arguments;\n                _arrayEach(tasks, function (task) {\n                    _arrayEach(workersList, function (worker, index) {\n                        if (worker === task && !removed) {\n                            workersList.splice(index, 1);\n                            removed = true;\n                        }\n                    });\n\n                    task.callback.apply(task, args);\n                });\n                if (q.tasks.length + workers === 0) {\n                    q.drain();\n                }\n                q.process();\n            };\n        }\n\n        var workers = 0;\n        var workersList = [];\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            payload: payload,\n            saturated: noop,\n            empty: noop,\n            drain: noop,\n            started: false,\n            paused: false,\n            push: function (data, callback) {\n                _insert(q, data, false, callback);\n            },\n            kill: function () {\n                q.drain = noop;\n                q.tasks = [];\n            },\n            unshift: function (data, callback) {\n                _insert(q, data, true, callback);\n            },\n            process: function () {\n                while(!q.paused && workers < q.concurrency && q.tasks.length){\n\n                    var tasks = q.payload ?\n                        q.tasks.splice(0, q.payload) :\n                        q.tasks.splice(0, q.tasks.length);\n\n                    var data = _map(tasks, function (task) {\n                        return task.data;\n                    });\n\n                    if (q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    workersList.push(tasks[0]);\n                    var cb = only_once(_next(q, tasks));\n                    worker(data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            },\n            workersList: function () {\n                return workersList;\n            },\n            idle: function() {\n                return q.tasks.length + workers === 0;\n            },\n            pause: function () {\n                q.paused = true;\n            },\n            resume: function () {\n                if (q.paused === false) { return; }\n                q.paused = false;\n                var resumeCount = Math.min(q.concurrency, q.tasks.length);\n                // Need to call q.process once per concurrent\n                // worker to preserve full concurrency after pause\n                for (var w = 1; w <= resumeCount; w++) {\n                    async.setImmediate(q.process);\n                }\n            }\n        };\n        return q;\n    }\n\n    async.queue = function (worker, concurrency) {\n        var q = _queue(function (items, cb) {\n            worker(items[0], cb);\n        }, concurrency, 1);\n\n        return q;\n    };\n\n    async.priorityQueue = function (worker, concurrency) {\n\n        function _compareTasks(a, b){\n            return a.priority - b.priority;\n        }\n\n        function _binarySearch(sequence, item, compare) {\n            var beg = -1,\n                end = sequence.length - 1;\n            while (beg < end) {\n                var mid = beg + ((end - beg + 1) >>> 1);\n                if (compare(item, sequence[mid]) >= 0) {\n                    beg = mid;\n                } else {\n                    end = mid - 1;\n                }\n            }\n            return beg;\n        }\n\n        function _insert(q, data, priority, callback) {\n            if (callback != null && typeof callback !== \"function\") {\n                throw new Error(\"task callback must be a function\");\n            }\n            q.started = true;\n            if (!_isArray(data)) {\n                data = [data];\n            }\n            if(data.length === 0) {\n                // call drain immediately if there are no tasks\n                return async.setImmediate(function() {\n                    q.drain();\n                });\n            }\n            _arrayEach(data, function(task) {\n                var item = {\n                    data: task,\n                    priority: priority,\n                    callback: typeof callback === 'function' ? callback : noop\n                };\n\n                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\n\n                if (q.tasks.length === q.concurrency) {\n                    q.saturated();\n                }\n                async.setImmediate(q.process);\n            });\n        }\n\n        // Start with a normal queue\n        var q = async.queue(worker, concurrency);\n\n        // Override push to accept second parameter representing priority\n        q.push = function (data, priority, callback) {\n            _insert(q, data, priority, callback);\n        };\n\n        // Remove unshift function\n        delete q.unshift;\n\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        return _queue(worker, 1, payload);\n    };\n\n    function _console_fn(name) {\n        return _restParam(function (fn, args) {\n            fn.apply(null, args.concat([_restParam(function (err, args) {\n                if (typeof console === 'object') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _arrayEach(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            })]));\n        });\n    }\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        var has = Object.prototype.hasOwnProperty;\n        hasher = hasher || identity;\n        var memoized = _restParam(function memoized(args) {\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (has.call(memo, key)) {   \n                async.setImmediate(function () {\n                    callback.apply(null, memo[key]);\n                });\n            }\n            else if (has.call(queues, key)) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([_restParam(function (args) {\n                    memo[key] = args;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                        q[i].apply(null, args);\n                    }\n                })]));\n            }\n        });\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n        return function () {\n            return (fn.unmemoized || fn).apply(null, arguments);\n        };\n    };\n\n    function _times(mapper) {\n        return function (count, iterator, callback) {\n            mapper(_range(count), iterator, callback);\n        };\n    }\n\n    async.times = _times(async.map);\n    async.timesSeries = _times(async.mapSeries);\n    async.timesLimit = function (count, limit, iterator, callback) {\n        return async.mapLimit(_range(count), limit, iterator, callback);\n    };\n\n    async.seq = function (/* functions... */) {\n        var fns = arguments;\n        return _restParam(function (args) {\n            var that = this;\n\n            var callback = args[args.length - 1];\n            if (typeof callback == 'function') {\n                args.pop();\n            } else {\n                callback = noop;\n            }\n\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {\n                    cb(err, nextargs);\n                })]));\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        });\n    };\n\n    async.compose = function (/* functions... */) {\n        return async.seq.apply(null, Array.prototype.reverse.call(arguments));\n    };\n\n\n    function _applyEach(eachfn) {\n        return _restParam(function(fns, args) {\n            var go = _restParam(function(args) {\n                var that = this;\n                var callback = args.pop();\n                return eachfn(fns, function (fn, _, cb) {\n                    fn.apply(that, args.concat([cb]));\n                },\n                callback);\n            });\n            if (args.length) {\n                return go.apply(this, args);\n            }\n            else {\n                return go;\n            }\n        });\n    }\n\n    async.applyEach = _applyEach(async.eachOf);\n    async.applyEachSeries = _applyEach(async.eachOfSeries);\n\n\n    async.forever = function (fn, callback) {\n        var done = only_once(callback || noop);\n        var task = ensureAsync(fn);\n        function next(err) {\n            if (err) {\n                return done(err);\n            }\n            task(next);\n        }\n        next();\n    };\n\n    function ensureAsync(fn) {\n        return _restParam(function (args) {\n            var callback = args.pop();\n            args.push(function () {\n                var innerArgs = arguments;\n                if (sync) {\n                    async.setImmediate(function () {\n                        callback.apply(null, innerArgs);\n                    });\n                } else {\n                    callback.apply(null, innerArgs);\n                }\n            });\n            var sync = true;\n            fn.apply(this, args);\n            sync = false;\n        });\n    }\n\n    async.ensureAsync = ensureAsync;\n\n    async.constant = _restParam(function(values) {\n        var args = [null].concat(values);\n        return function (callback) {\n            return callback.apply(this, args);\n        };\n    });\n\n    async.wrapSync =\n    async.asyncify = function asyncify(func) {\n        return _restParam(function (args) {\n            var callback = args.pop();\n            var result;\n            try {\n                result = func.apply(this, args);\n            } catch (e) {\n                return callback(e);\n            }\n            // if result is Promise object\n            if (_isObject(result) && typeof result.then === \"function\") {\n                result.then(function(value) {\n                    callback(null, value);\n                })[\"catch\"](function(err) {\n                    callback(err.message ? err : new Error(err));\n                });\n            } else {\n                callback(null, result);\n            }\n        });\n    };\n\n    // Node.js\n    if ( true && module.exports) {\n        module.exports = async;\n    }\n    // AMD / RequireJS\n    else if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n            return async;\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n    // included directly via <script> tag\n    else {}\n\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbm9kZV9tb2R1bGVzL2FzeW5jL2xpYi9hc3luYy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0QsV0FBVztBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw2QkFBNkI7QUFDakU7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQseUJBQXlCO0FBQ3ZGLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxRQUFRLEtBQTBCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBMEM7QUFDdkQsUUFBUSxpQ0FBTyxFQUFFLG1DQUFFO0FBQ25CO0FBQ0EsU0FBUztBQUFBLGtHQUFDO0FBQ1Y7QUFDQTtBQUNBLFNBQVMsRUFFSjs7QUFFTCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9zYy1pc3RhbmJ1bC9ub2RlX21vZHVsZXMvYXN5bmMvbGliL2FzeW5jLmpzP2M2MDgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBhc3luY1xuICogaHR0cHM6Ly9naXRodWIuY29tL2Nhb2xhbi9hc3luY1xuICpcbiAqIENvcHlyaWdodCAyMDEwLTIwMTQgQ2FvbGFuIE1jTWFob25cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGFzeW5jID0ge307XG4gICAgZnVuY3Rpb24gbm9vcCgpIHt9XG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodikge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9Cb29sKHYpIHtcbiAgICAgICAgcmV0dXJuICEhdjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm90SWQodikge1xuICAgICAgICByZXR1cm4gIXY7XG4gICAgfVxuXG4gICAgLy8gZ2xvYmFsIG9uIHRoZSBzZXJ2ZXIsIHdpbmRvdyBpbiB0aGUgYnJvd3NlclxuICAgIHZhciBwcmV2aW91c19hc3luYztcblxuICAgIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIChgc2VsZmApIGluIHRoZSBicm93c2VyLCBgZ2xvYmFsYFxuICAgIC8vIG9uIHRoZSBzZXJ2ZXIsIG9yIGB0aGlzYCBpbiBzb21lIHZpcnR1YWwgbWFjaGluZXMuIFdlIHVzZSBgc2VsZmBcbiAgICAvLyBpbnN0ZWFkIG9mIGB3aW5kb3dgIGZvciBgV2ViV29ya2VyYCBzdXBwb3J0LlxuICAgIHZhciByb290ID0gdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZiAmJiBzZWxmIHx8XG4gICAgICAgICAgICB0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiBnbG9iYWwuZ2xvYmFsID09PSBnbG9iYWwgJiYgZ2xvYmFsIHx8XG4gICAgICAgICAgICB0aGlzO1xuXG4gICAgaWYgKHJvb3QgIT0gbnVsbCkge1xuICAgICAgICBwcmV2aW91c19hc3luYyA9IHJvb3QuYXN5bmM7XG4gICAgfVxuXG4gICAgYXN5bmMubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcm9vdC5hc3luYyA9IHByZXZpb3VzX2FzeW5jO1xuICAgICAgICByZXR1cm4gYXN5bmM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG9ubHlfb25jZShmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoZm4gPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIHdhcyBhbHJlYWR5IGNhbGxlZC5cIik7XG4gICAgICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgZm4gPSBudWxsO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vbmNlKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChmbiA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGZuID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLy8vIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJsaXR5IGZ1bmN0aW9ucyAvLy8vXG5cbiAgICB2YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuICAgIHZhciBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuXG4gICAgLy8gUG9ydGVkIGZyb20gdW5kZXJzY29yZS5qcyBpc09iamVjdFxuICAgIHZhciBfaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2lzQXJyYXlMaWtlKGFycikge1xuICAgICAgICByZXR1cm4gX2lzQXJyYXkoYXJyKSB8fCAoXG4gICAgICAgICAgICAvLyBoYXMgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxlbmd0aCBwcm9wZXJ0eVxuICAgICAgICAgICAgdHlwZW9mIGFyci5sZW5ndGggPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgICAgIGFyci5sZW5ndGggPj0gMCAmJlxuICAgICAgICAgICAgYXJyLmxlbmd0aCAlIDEgPT09IDBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYXJyYXlFYWNoKGFyciwgaXRlcmF0b3IpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBhcnIubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihhcnJbaW5kZXhdLCBpbmRleCwgYXJyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9tYXAoYXJyLCBpdGVyYXRvcikge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFyci5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0b3IoYXJyW2luZGV4XSwgaW5kZXgsIGFycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcmFuZ2UoY291bnQpIHtcbiAgICAgICAgcmV0dXJuIF9tYXAoQXJyYXkoY291bnQpLCBmdW5jdGlvbiAodiwgaSkgeyByZXR1cm4gaTsgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3JlZHVjZShhcnIsIGl0ZXJhdG9yLCBtZW1vKSB7XG4gICAgICAgIF9hcnJheUVhY2goYXJyLCBmdW5jdGlvbiAoeCwgaSwgYSkge1xuICAgICAgICAgICAgbWVtbyA9IGl0ZXJhdG9yKG1lbW8sIHgsIGksIGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2ZvckVhY2hPZihvYmplY3QsIGl0ZXJhdG9yKSB7XG4gICAgICAgIF9hcnJheUVhY2goX2tleXMob2JqZWN0KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaXRlcmF0b3Iob2JqZWN0W2tleV0sIGtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pbmRleE9mKGFyciwgaXRlbSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFycltpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHZhciBfa2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9rZXlJdGVyYXRvcihjb2xsKSB7XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIHZhciBsZW47XG4gICAgICAgIHZhciBrZXlzO1xuICAgICAgICBpZiAoX2lzQXJyYXlMaWtlKGNvbGwpKSB7XG4gICAgICAgICAgICBsZW4gPSBjb2xsLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA8IGxlbiA/IGkgOiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleXMgPSBfa2V5cyhjb2xsKTtcbiAgICAgICAgICAgIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIHJldHVybiBpIDwgbGVuID8ga2V5c1tpXSA6IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2ltaWxhciB0byBFUzYncyByZXN0IHBhcmFtIChodHRwOi8vYXJpeWEub2ZpbGFicy5jb20vMjAxMy8wMy9lczYtYW5kLXJlc3QtcGFyYW1ldGVyLmh0bWwpXG4gICAgLy8gVGhpcyBhY2N1bXVsYXRlcyB0aGUgYXJndW1lbnRzIHBhc3NlZCBpbnRvIGFuIGFycmF5LCBhZnRlciBhIGdpdmVuIGluZGV4LlxuICAgIC8vIEZyb20gdW5kZXJzY29yZS5qcyAoaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMjE0MCkuXG4gICAgZnVuY3Rpb24gX3Jlc3RQYXJhbShmdW5jLCBzdGFydEluZGV4KSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSBzdGFydEluZGV4ID09IG51bGwgPyBmdW5jLmxlbmd0aCAtIDEgOiArc3RhcnRJbmRleDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KGFyZ3VtZW50cy5sZW5ndGggLSBzdGFydEluZGV4LCAwKTtcbiAgICAgICAgICAgIHZhciByZXN0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICByZXN0W2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleCArIHN0YXJ0SW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIHJlc3QpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmd1bWVudHNbMF0sIHJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ3VycmVudGx5IHVudXNlZCBidXQgaGFuZGxlIGNhc2VzIG91dHNpZGUgb2YgdGhlIHN3aXRjaCBzdGF0ZW1lbnQ6XG4gICAgICAgICAgICAvLyB2YXIgYXJncyA9IEFycmF5KHN0YXJ0SW5kZXggKyAxKTtcbiAgICAgICAgICAgIC8vIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHN0YXJ0SW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIC8vICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyBhcmdzW3N0YXJ0SW5kZXhdID0gcmVzdDtcbiAgICAgICAgICAgIC8vIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF93aXRob3V0SW5kZXgoaXRlcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3IodmFsdWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLy8vIGV4cG9ydGVkIGFzeW5jIG1vZHVsZSBmdW5jdGlvbnMgLy8vL1xuXG4gICAgLy8vLyBuZXh0VGljayBpbXBsZW1lbnRhdGlvbiB3aXRoIGJyb3dzZXItY29tcGF0aWJsZSBmYWxsYmFjayAvLy8vXG5cbiAgICAvLyBjYXB0dXJlIHRoZSBnbG9iYWwgcmVmZXJlbmNlIHRvIGd1YXJkIGFnYWluc3QgZmFrZVRpbWVyIG1vY2tzXG4gICAgdmFyIF9zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nICYmIHNldEltbWVkaWF0ZTtcblxuICAgIHZhciBfZGVsYXkgPSBfc2V0SW1tZWRpYXRlID8gZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgLy8gbm90IGEgZGlyZWN0IGFsaWFzIGZvciBJRTEwIGNvbXBhdGliaWxpdHlcbiAgICAgICAgX3NldEltbWVkaWF0ZShmbik7XG4gICAgfSA6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGFzeW5jLm5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICB9IGVsc2Uge1xuICAgICAgICBhc3luYy5uZXh0VGljayA9IF9kZWxheTtcbiAgICB9XG4gICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gX3NldEltbWVkaWF0ZSA/IF9kZWxheSA6IGFzeW5jLm5leHRUaWNrO1xuXG5cbiAgICBhc3luYy5mb3JFYWNoID1cbiAgICBhc3luYy5lYWNoID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBhc3luYy5lYWNoT2YoYXJyLCBfd2l0aG91dEluZGV4KGl0ZXJhdG9yKSwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5mb3JFYWNoU2VyaWVzID1cbiAgICBhc3luYy5lYWNoU2VyaWVzID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBhc3luYy5lYWNoT2ZTZXJpZXMoYXJyLCBfd2l0aG91dEluZGV4KGl0ZXJhdG9yKSwgY2FsbGJhY2spO1xuICAgIH07XG5cblxuICAgIGFzeW5jLmZvckVhY2hMaW1pdCA9XG4gICAgYXN5bmMuZWFjaExpbWl0ID0gZnVuY3Rpb24gKGFyciwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX2VhY2hPZkxpbWl0KGxpbWl0KShhcnIsIF93aXRob3V0SW5kZXgoaXRlcmF0b3IpLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLmZvckVhY2hPZiA9XG4gICAgYXN5bmMuZWFjaE9mID0gZnVuY3Rpb24gKG9iamVjdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gX29uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdCB8fCBbXTtcblxuICAgICAgICB2YXIgaXRlciA9IF9rZXlJdGVyYXRvcihvYmplY3QpO1xuICAgICAgICB2YXIga2V5LCBjb21wbGV0ZWQgPSAwO1xuXG4gICAgICAgIHdoaWxlICgoa2V5ID0gaXRlcigpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcbiAgICAgICAgICAgIGl0ZXJhdG9yKG9iamVjdFtrZXldLCBrZXksIG9ubHlfb25jZShkb25lKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tcGxldGVkID09PSAwKSBjYWxsYmFjayhudWxsKTtcblxuICAgICAgICBmdW5jdGlvbiBkb25lKGVycikge1xuICAgICAgICAgICAgY29tcGxldGVkLS07XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGtleSBpcyBudWxsIGluIGNhc2UgaXRlcmF0b3IgaXNuJ3QgZXhoYXVzdGVkXG4gICAgICAgICAgICAvLyBhbmQgZG9uZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5LlxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBudWxsICYmIGNvbXBsZXRlZCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMuZm9yRWFjaE9mU2VyaWVzID1cbiAgICBhc3luYy5lYWNoT2ZTZXJpZXMgPSBmdW5jdGlvbiAob2JqLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBfb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgICAgICAgb2JqID0gb2JqIHx8IFtdO1xuICAgICAgICB2YXIgbmV4dEtleSA9IF9rZXlJdGVyYXRvcihvYmopO1xuICAgICAgICB2YXIga2V5ID0gbmV4dEtleSgpO1xuICAgICAgICBmdW5jdGlvbiBpdGVyYXRlKCkge1xuICAgICAgICAgICAgdmFyIHN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZXJhdG9yKG9ialtrZXldLCBrZXksIG9ubHlfb25jZShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gbmV4dEtleSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShpdGVyYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgc3luYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGl0ZXJhdGUoKTtcbiAgICB9O1xuXG5cblxuICAgIGFzeW5jLmZvckVhY2hPZkxpbWl0ID1cbiAgICBhc3luYy5lYWNoT2ZMaW1pdCA9IGZ1bmN0aW9uIChvYmosIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgX2VhY2hPZkxpbWl0KGxpbWl0KShvYmosIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9lYWNoT2ZMaW1pdChsaW1pdCkge1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gX29uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgICAgICAgICBvYmogPSBvYmogfHwgW107XG4gICAgICAgICAgICB2YXIgbmV4dEtleSA9IF9rZXlJdGVyYXRvcihvYmopO1xuICAgICAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHJ1bm5pbmcgPSAwO1xuICAgICAgICAgICAgdmFyIGVycm9yZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgKGZ1bmN0aW9uIHJlcGxlbmlzaCAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUgJiYgcnVubmluZyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAocnVubmluZyA8IGxpbWl0ICYmICFlcnJvcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBuZXh0S2V5KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmcgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3Iob2JqW2tleV0sIGtleSwgb25seV9vbmNlKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gZG9QYXJhbGxlbChmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4oYXN5bmMuZWFjaE9mLCBvYmosIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRvUGFyYWxsZWxMaW1pdChmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGZuKF9lYWNoT2ZMaW1pdChsaW1pdCksIG9iaiwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZG9TZXJpZXMoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGZuKGFzeW5jLmVhY2hPZlNlcmllcywgb2JqLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9hc3luY01hcChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gX29uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgICAgIGFyciA9IGFyciB8fCBbXTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBfaXNBcnJheUxpa2UoYXJyKSA/IFtdIDoge307XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih2YWx1ZSwgZnVuY3Rpb24gKGVyciwgdikge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gdjtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jLm1hcCA9IGRvUGFyYWxsZWwoX2FzeW5jTWFwKTtcbiAgICBhc3luYy5tYXBTZXJpZXMgPSBkb1NlcmllcyhfYXN5bmNNYXApO1xuICAgIGFzeW5jLm1hcExpbWl0ID0gZG9QYXJhbGxlbExpbWl0KF9hc3luY01hcCk7XG5cbiAgICAvLyByZWR1Y2Ugb25seSBoYXMgYSBzZXJpZXMgdmVyc2lvbiwgYXMgZG9pbmcgcmVkdWNlIGluIHBhcmFsbGVsIHdvbid0XG4gICAgLy8gd29yayBpbiBtYW55IHNpdHVhdGlvbnMuXG4gICAgYXN5bmMuaW5qZWN0ID1cbiAgICBhc3luYy5mb2xkbCA9XG4gICAgYXN5bmMucmVkdWNlID0gZnVuY3Rpb24gKGFyciwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2hPZlNlcmllcyhhcnIsIGZ1bmN0aW9uICh4LCBpLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IobWVtbywgeCwgZnVuY3Rpb24gKGVyciwgdikge1xuICAgICAgICAgICAgICAgIG1lbW8gPSB2O1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBtZW1vKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLmZvbGRyID1cbiAgICBhc3luYy5yZWR1Y2VSaWdodCA9IGZ1bmN0aW9uIChhcnIsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmV2ZXJzZWQgPSBfbWFwKGFyciwgaWRlbnRpdHkpLnJldmVyc2UoKTtcbiAgICAgICAgYXN5bmMucmVkdWNlKHJldmVyc2VkLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoYXJyLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gaXRlcmF0b3I7XG4gICAgICAgICAgICBpdGVyYXRvciA9IG1lbW87XG4gICAgICAgICAgICBtZW1vID0gX2lzQXJyYXkoYXJyKSA/IFtdIDoge307XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYy5lYWNoT2YoYXJyLCBmdW5jdGlvbih2LCBrLCBjYikge1xuICAgICAgICAgICAgaXRlcmF0b3IobWVtbywgdiwgaywgY2IpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbWVtbyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfZmlsdGVyKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGluZGV4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goe2luZGV4OiBpbmRleCwgdmFsdWU6IHh9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhfbWFwKHJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgICAgIH0pLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYy5zZWxlY3QgPVxuICAgIGFzeW5jLmZpbHRlciA9IGRvUGFyYWxsZWwoX2ZpbHRlcik7XG5cbiAgICBhc3luYy5zZWxlY3RMaW1pdCA9XG4gICAgYXN5bmMuZmlsdGVyTGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2ZpbHRlcik7XG5cbiAgICBhc3luYy5zZWxlY3RTZXJpZXMgPVxuICAgIGFzeW5jLmZpbHRlclNlcmllcyA9IGRvU2VyaWVzKF9maWx0ZXIpO1xuXG4gICAgZnVuY3Rpb24gX3JlamVjdChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9maWx0ZXIoZWFjaGZuLCBhcnIsIGZ1bmN0aW9uKHZhbHVlLCBjYikge1xuICAgICAgICAgICAgaXRlcmF0b3IodmFsdWUsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICBjYighdik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBhc3luYy5yZWplY3QgPSBkb1BhcmFsbGVsKF9yZWplY3QpO1xuICAgIGFzeW5jLnJlamVjdExpbWl0ID0gZG9QYXJhbGxlbExpbWl0KF9yZWplY3QpO1xuICAgIGFzeW5jLnJlamVjdFNlcmllcyA9IGRvU2VyaWVzKF9yZWplY3QpO1xuXG4gICAgZnVuY3Rpb24gX2NyZWF0ZVRlc3RlcihlYWNoZm4sIGNoZWNrLCBnZXRSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFyciwgbGltaXQsIGl0ZXJhdG9yLCBjYikge1xuICAgICAgICAgICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2IpIGNiKGdldFJlc3VsdChmYWxzZSwgdm9pZCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBpdGVyYXRlZSh4LCBfLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmICghY2IpIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYiAmJiBjaGVjayh2KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IoZ2V0UmVzdWx0KHRydWUsIHgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiID0gaXRlcmF0b3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICAgICAgZWFjaGZuKGFyciwgbGltaXQsIGl0ZXJhdGVlLCBkb25lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2IgPSBpdGVyYXRvcjtcbiAgICAgICAgICAgICAgICBpdGVyYXRvciA9IGxpbWl0O1xuICAgICAgICAgICAgICAgIGVhY2hmbihhcnIsIGl0ZXJhdGVlLCBkb25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYy5hbnkgPVxuICAgIGFzeW5jLnNvbWUgPSBfY3JlYXRlVGVzdGVyKGFzeW5jLmVhY2hPZiwgdG9Cb29sLCBpZGVudGl0eSk7XG5cbiAgICBhc3luYy5zb21lTGltaXQgPSBfY3JlYXRlVGVzdGVyKGFzeW5jLmVhY2hPZkxpbWl0LCB0b0Jvb2wsIGlkZW50aXR5KTtcblxuICAgIGFzeW5jLmFsbCA9XG4gICAgYXN5bmMuZXZlcnkgPSBfY3JlYXRlVGVzdGVyKGFzeW5jLmVhY2hPZiwgbm90SWQsIG5vdElkKTtcblxuICAgIGFzeW5jLmV2ZXJ5TGltaXQgPSBfY3JlYXRlVGVzdGVyKGFzeW5jLmVhY2hPZkxpbWl0LCBub3RJZCwgbm90SWQpO1xuXG4gICAgZnVuY3Rpb24gX2ZpbmRHZXRSZXN1bHQodiwgeCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgYXN5bmMuZGV0ZWN0ID0gX2NyZWF0ZVRlc3Rlcihhc3luYy5lYWNoT2YsIGlkZW50aXR5LCBfZmluZEdldFJlc3VsdCk7XG4gICAgYXN5bmMuZGV0ZWN0U2VyaWVzID0gX2NyZWF0ZVRlc3Rlcihhc3luYy5lYWNoT2ZTZXJpZXMsIGlkZW50aXR5LCBfZmluZEdldFJlc3VsdCk7XG4gICAgYXN5bmMuZGV0ZWN0TGltaXQgPSBfY3JlYXRlVGVzdGVyKGFzeW5jLmVhY2hPZkxpbWl0LCBpZGVudGl0eSwgX2ZpbmRHZXRSZXN1bHQpO1xuXG4gICAgYXN5bmMuc29ydEJ5ID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLm1hcChhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKGVyciwgY3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7dmFsdWU6IHgsIGNyaXRlcmlhOiBjcml0ZXJpYX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBfbWFwKHJlc3VsdHMuc29ydChjb21wYXJhdG9yKSwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXBhcmF0b3IobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYSwgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLmF1dG8gPSBmdW5jdGlvbiAodGFza3MsIGNvbmN1cnJlbmN5LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gY29uY3VycmVuY3kgaXMgb3B0aW9uYWwsIHNoaWZ0IHRoZSBhcmdzLlxuICAgICAgICAgICAgY2FsbGJhY2sgPSBjb25jdXJyZW5jeTtcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayA9IF9vbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgICAgICB2YXIga2V5cyA9IF9rZXlzKHRhc2tzKTtcbiAgICAgICAgdmFyIHJlbWFpbmluZ1Rhc2tzID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGlmICghcmVtYWluaW5nVGFza3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICBjb25jdXJyZW5jeSA9IHJlbWFpbmluZ1Rhc2tzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgdmFyIHJ1bm5pbmdUYXNrcyA9IDA7XG5cbiAgICAgICAgdmFyIGhhc0Vycm9yID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBhZGRMaXN0ZW5lcihmbikge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnVuc2hpZnQoZm4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGZuKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gX2luZGV4T2YobGlzdGVuZXJzLCBmbik7XG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIGxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0YXNrQ29tcGxldGUoKSB7XG4gICAgICAgICAgICByZW1haW5pbmdUYXNrcy0tO1xuICAgICAgICAgICAgX2FycmF5RWFjaChsaXN0ZW5lcnMuc2xpY2UoMCksIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZExpc3RlbmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghcmVtYWluaW5nVGFza3MpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2FycmF5RWFjaChrZXlzLCBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGhhc0Vycm9yKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgdGFzayA9IF9pc0FycmF5KHRhc2tzW2tdKSA/IHRhc2tzW2tdOiBbdGFza3Nba11dO1xuICAgICAgICAgICAgdmFyIHRhc2tDYWxsYmFjayA9IF9yZXN0UGFyYW0oZnVuY3Rpb24oZXJyLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgcnVubmluZ1Rhc2tzLS07XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhZmVSZXN1bHRzID0ge307XG4gICAgICAgICAgICAgICAgICAgIF9mb3JFYWNoT2YocmVzdWx0cywgZnVuY3Rpb24odmFsLCBya2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1tya2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNhZmVSZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgc2FmZVJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSh0YXNrQ29tcGxldGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHJlcXVpcmVzID0gdGFzay5zbGljZSgwLCB0YXNrLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgLy8gcHJldmVudCBkZWFkLWxvY2tzXG4gICAgICAgICAgICB2YXIgbGVuID0gcmVxdWlyZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGRlcDtcbiAgICAgICAgICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgICAgICAgICAgIGlmICghKGRlcCA9IHRhc2tzW3JlcXVpcmVzW2xlbl1dKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhcyBub25leGlzdGVudCBkZXBlbmRlbmN5IGluICcgKyByZXF1aXJlcy5qb2luKCcsICcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5KGRlcCkgJiYgX2luZGV4T2YoZGVwLCBrKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzIGN5Y2xpYyBkZXBlbmRlbmNpZXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiByZWFkeSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcnVubmluZ1Rhc2tzIDwgY29uY3VycmVuY3kgJiYgX3JlZHVjZShyZXF1aXJlcywgZnVuY3Rpb24gKGEsIHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChhICYmIHJlc3VsdHMuaGFzT3duUHJvcGVydHkoeCkpO1xuICAgICAgICAgICAgICAgIH0sIHRydWUpICYmICFyZXN1bHRzLmhhc093blByb3BlcnR5KGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlYWR5KCkpIHtcbiAgICAgICAgICAgICAgICBydW5uaW5nVGFza3MrKztcbiAgICAgICAgICAgICAgICB0YXNrW3Rhc2subGVuZ3RoIC0gMV0odGFza0NhbGxiYWNrLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xuICAgICAgICAgICAgICAgIGlmIChyZWFkeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdUYXNrcysrO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tbdGFzay5sZW5ndGggLSAxXSh0YXNrQ2FsbGJhY2ssIHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuXG5cbiAgICBhc3luYy5yZXRyeSA9IGZ1bmN0aW9uKHRpbWVzLCB0YXNrLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgREVGQVVMVF9USU1FUyA9IDU7XG4gICAgICAgIHZhciBERUZBVUxUX0lOVEVSVkFMID0gMDtcblxuICAgICAgICB2YXIgYXR0ZW1wdHMgPSBbXTtcblxuICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgIHRpbWVzOiBERUZBVUxUX1RJTUVTLFxuICAgICAgICAgICAgaW50ZXJ2YWw6IERFRkFVTFRfSU5URVJWQUxcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBwYXJzZVRpbWVzKGFjYywgdCl7XG4gICAgICAgICAgICBpZih0eXBlb2YgdCA9PT0gJ251bWJlcicpe1xuICAgICAgICAgICAgICAgIGFjYy50aW1lcyA9IHBhcnNlSW50KHQsIDEwKSB8fCBERUZBVUxUX1RJTUVTO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHR5cGVvZiB0ID09PSAnb2JqZWN0Jyl7XG4gICAgICAgICAgICAgICAgYWNjLnRpbWVzID0gcGFyc2VJbnQodC50aW1lcywgMTApIHx8IERFRkFVTFRfVElNRVM7XG4gICAgICAgICAgICAgICAgYWNjLmludGVydmFsID0gcGFyc2VJbnQodC5pbnRlcnZhbCwgMTApIHx8IERFRkFVTFRfSU5URVJWQUw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgYXJndW1lbnQgdHlwZSBmb3IgXFwndGltZXNcXCc6ICcgKyB0eXBlb2YgdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDEgfHwgbGVuZ3RoID4gMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyAtIG11c3QgYmUgZWl0aGVyICh0YXNrKSwgKHRhc2ssIGNhbGxiYWNrKSwgKHRpbWVzLCB0YXNrKSBvciAodGltZXMsIHRhc2ssIGNhbGxiYWNrKScpO1xuICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA8PSAyICYmIHR5cGVvZiB0aW1lcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSB0YXNrO1xuICAgICAgICAgICAgdGFzayA9IHRpbWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGltZXMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHBhcnNlVGltZXMob3B0cywgdGltZXMpO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgb3B0cy50YXNrID0gdGFzaztcblxuICAgICAgICBmdW5jdGlvbiB3cmFwcGVkVGFzayh3cmFwcGVkQ2FsbGJhY2ssIHdyYXBwZWRSZXN1bHRzKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiByZXRyeUF0dGVtcHQodGFzaywgZmluYWxBdHRlbXB0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNlcmllc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2soZnVuY3Rpb24oZXJyLCByZXN1bHQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzQ2FsbGJhY2soIWVyciB8fCBmaW5hbEF0dGVtcHQsIHtlcnI6IGVyciwgcmVzdWx0OiByZXN1bHR9KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgd3JhcHBlZFJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJldHJ5SW50ZXJ2YWwoaW50ZXJ2YWwpe1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzZXJpZXNDYWxsYmFjayl7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0NhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9LCBpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKG9wdHMudGltZXMpIHtcblxuICAgICAgICAgICAgICAgIHZhciBmaW5hbEF0dGVtcHQgPSAhKG9wdHMudGltZXMtPTEpO1xuICAgICAgICAgICAgICAgIGF0dGVtcHRzLnB1c2gocmV0cnlBdHRlbXB0KG9wdHMudGFzaywgZmluYWxBdHRlbXB0KSk7XG4gICAgICAgICAgICAgICAgaWYoIWZpbmFsQXR0ZW1wdCAmJiBvcHRzLmludGVydmFsID4gMCl7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRzLnB1c2gocmV0cnlJbnRlcnZhbChvcHRzLmludGVydmFsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhc3luYy5zZXJpZXMoYXR0ZW1wdHMsIGZ1bmN0aW9uKGRvbmUsIGRhdGEpe1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgKHdyYXBwZWRDYWxsYmFjayB8fCBvcHRzLmNhbGxiYWNrKShkYXRhLmVyciwgZGF0YS5yZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhIGNhbGxiYWNrIGlzIHBhc3NlZCwgcnVuIHRoaXMgYXMgYSBjb250cm9sbCBmbG93XG4gICAgICAgIHJldHVybiBvcHRzLmNhbGxiYWNrID8gd3JhcHBlZFRhc2soKSA6IHdyYXBwZWRUYXNrO1xuICAgIH07XG5cbiAgICBhc3luYy53YXRlcmZhbGwgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gX29uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgICAgIGlmICghX2lzQXJyYXkodGFza3MpKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byB3YXRlcmZhbGwgbXVzdCBiZSBhbiBhcnJheSBvZiBmdW5jdGlvbnMnKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cmFwSXRlcmF0b3IoaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVzdFBhcmFtKGZ1bmN0aW9uIChlcnIsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIFtlcnJdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh3cmFwSXRlcmF0b3IobmV4dCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbnN1cmVBc3luYyhpdGVyYXRvcikuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcEl0ZXJhdG9yKGFzeW5jLml0ZXJhdG9yKHRhc2tzKSkoKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX3BhcmFsbGVsKGVhY2hmbiwgdGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBfaXNBcnJheUxpa2UodGFza3MpID8gW10gOiB7fTtcblxuICAgICAgICBlYWNoZm4odGFza3MsIGZ1bmN0aW9uICh0YXNrLCBrZXksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0YXNrKF9yZXN0UGFyYW0oZnVuY3Rpb24gKGVyciwgYXJncykge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzW2tleV0gPSBhcmdzO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jLnBhcmFsbGVsID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBfcGFyYWxsZWwoYXN5bmMuZWFjaE9mLCB0YXNrcywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5wYXJhbGxlbExpbWl0ID0gZnVuY3Rpb24odGFza3MsIGxpbWl0LCBjYWxsYmFjaykge1xuICAgICAgICBfcGFyYWxsZWwoX2VhY2hPZkxpbWl0KGxpbWl0KSwgdGFza3MsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuc2VyaWVzID0gZnVuY3Rpb24odGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9wYXJhbGxlbChhc3luYy5lYWNoT2ZTZXJpZXMsIHRhc2tzLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLml0ZXJhdG9yID0gZnVuY3Rpb24gKHRhc2tzKSB7XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VDYWxsYmFjayhpbmRleCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZm4oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrc1tpbmRleF0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZuLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpbmRleCA8IHRhc2tzLmxlbmd0aCAtIDEpID8gbWFrZUNhbGxiYWNrKGluZGV4ICsgMSk6IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWtlQ2FsbGJhY2soMCk7XG4gICAgfTtcblxuICAgIGFzeW5jLmFwcGx5ID0gX3Jlc3RQYXJhbShmdW5jdGlvbiAoZm4sIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9yZXN0UGFyYW0oZnVuY3Rpb24gKGNhbGxBcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoXG4gICAgICAgICAgICAgICAgbnVsbCwgYXJncy5jb25jYXQoY2FsbEFyZ3MpXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIF9jb25jYXQoZWFjaGZuLCBhcnIsIGZuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBpbmRleCwgY2IpIHtcbiAgICAgICAgICAgIGZuKHgsIGZ1bmN0aW9uIChlcnIsIHkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHkgfHwgW10pO1xuICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMuY29uY2F0ID0gZG9QYXJhbGxlbChfY29uY2F0KTtcbiAgICBhc3luYy5jb25jYXRTZXJpZXMgPSBkb1NlcmllcyhfY29uY2F0KTtcblxuICAgIGFzeW5jLndoaWxzdCA9IGZ1bmN0aW9uICh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICAgICAgICBpZiAodGVzdCgpKSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IF9yZXN0UGFyYW0oZnVuY3Rpb24oZXJyLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGVzdC5hcHBseSh0aGlzLCBhcmdzKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvcihuZXh0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBbbnVsbF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGl0ZXJhdG9yKG5leHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMuZG9XaGlsc3QgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjYWxscyA9IDA7XG4gICAgICAgIHJldHVybiBhc3luYy53aGlsc3QoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gKytjYWxscyA8PSAxIHx8IHRlc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMudW50aWwgPSBmdW5jdGlvbiAodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBhc3luYy53aGlsc3QoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRlc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuZG9VbnRpbCA9IGZ1bmN0aW9uIChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGFzeW5jLmRvV2hpbHN0KGl0ZXJhdG9yLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLmR1cmluZyA9IGZ1bmN0aW9uICh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuXG4gICAgICAgIHZhciBuZXh0ID0gX3Jlc3RQYXJhbShmdW5jdGlvbihlcnIsIGFyZ3MpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goY2hlY2spO1xuICAgICAgICAgICAgICAgIHRlc3QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBjaGVjayA9IGZ1bmN0aW9uKGVyciwgdHJ1dGgpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0cnV0aCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKG5leHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0ZXN0KGNoZWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuZG9EdXJpbmcgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjYWxscyA9IDA7XG4gICAgICAgIGFzeW5jLmR1cmluZyhmdW5jdGlvbihuZXh0KSB7XG4gICAgICAgICAgICBpZiAoY2FsbHMrKyA8IDEpIHtcbiAgICAgICAgICAgICAgICBuZXh0KG51bGwsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9xdWV1ZSh3b3JrZXIsIGNvbmN1cnJlbmN5LCBwYXlsb2FkKSB7XG4gICAgICAgIGlmIChjb25jdXJyZW5jeSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25jdXJyZW5jeSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihjb25jdXJyZW5jeSA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25jdXJyZW5jeSBtdXN0IG5vdCBiZSB6ZXJvJyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX2luc2VydChxLCBkYXRhLCBwb3MsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRhc2sgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcS5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghX2lzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGF0YS5sZW5ndGggPT09IDAgJiYgcS5pZGxlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xuICAgICAgICAgICAgICAgIHJldHVybiBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9hcnJheUVhY2goZGF0YSwgZnVuY3Rpb24odGFzaykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB0YXNrLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2sgfHwgbm9vcFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHEudGFza3MudW5zaGlmdChpdGVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBxLnRhc2tzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHEudGFza3MubGVuZ3RoID09PSBxLmNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICAgICAgICAgIHEuc2F0dXJhdGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUocS5wcm9jZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBfbmV4dChxLCB0YXNrcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgd29ya2VycyAtPSAxO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICBfYXJyYXlFYWNoKHRhc2tzLCBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICAgICAgICAgICAgICBfYXJyYXlFYWNoKHdvcmtlcnNMaXN0LCBmdW5jdGlvbiAod29ya2VyLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtlciA9PT0gdGFzayAmJiAhcmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlcnNMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHRhc2suY2FsbGJhY2suYXBwbHkodGFzaywgYXJncyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHEudGFza3MubGVuZ3RoICsgd29ya2VycyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBxLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHEucHJvY2VzcygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3b3JrZXJzID0gMDtcbiAgICAgICAgdmFyIHdvcmtlcnNMaXN0ID0gW107XG4gICAgICAgIHZhciBxID0ge1xuICAgICAgICAgICAgdGFza3M6IFtdLFxuICAgICAgICAgICAgY29uY3VycmVuY3k6IGNvbmN1cnJlbmN5LFxuICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgIHNhdHVyYXRlZDogbm9vcCxcbiAgICAgICAgICAgIGVtcHR5OiBub29wLFxuICAgICAgICAgICAgZHJhaW46IG5vb3AsXG4gICAgICAgICAgICBzdGFydGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHBhdXNlZDogZmFsc2UsXG4gICAgICAgICAgICBwdXNoOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIGZhbHNlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2lsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHEuZHJhaW4gPSBub29wO1xuICAgICAgICAgICAgICAgIHEudGFza3MgPSBbXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNoaWZ0OiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIHRydWUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUoIXEucGF1c2VkICYmIHdvcmtlcnMgPCBxLmNvbmN1cnJlbmN5ICYmIHEudGFza3MubGVuZ3RoKXtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFza3MgPSBxLnBheWxvYWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgcS50YXNrcy5zcGxpY2UoMCwgcS5wYXlsb2FkKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBxLnRhc2tzLnNwbGljZSgwLCBxLnRhc2tzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfbWFwKHRhc2tzLCBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhc2suZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHEudGFza3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd29ya2VycyArPSAxO1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXJzTGlzdC5wdXNoKHRhc2tzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNiID0gb25seV9vbmNlKF9uZXh0KHEsIHRhc2tzKSk7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcihkYXRhLCBjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxLnRhc2tzLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydW5uaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlcnM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd29ya2Vyc0xpc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd29ya2Vyc0xpc3Q7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWRsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHEudGFza3MubGVuZ3RoICsgd29ya2VycyA9PT0gMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHEucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAocS5wYXVzZWQgPT09IGZhbHNlKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgIHEucGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VtZUNvdW50ID0gTWF0aC5taW4ocS5jb25jdXJyZW5jeSwgcS50YXNrcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gY2FsbCBxLnByb2Nlc3Mgb25jZSBwZXIgY29uY3VycmVudFxuICAgICAgICAgICAgICAgIC8vIHdvcmtlciB0byBwcmVzZXJ2ZSBmdWxsIGNvbmN1cnJlbmN5IGFmdGVyIHBhdXNlXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdyA9IDE7IHcgPD0gcmVzdW1lQ291bnQ7IHcrKykge1xuICAgICAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUocS5wcm9jZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBxO1xuICAgIH1cblxuICAgIGFzeW5jLnF1ZXVlID0gZnVuY3Rpb24gKHdvcmtlciwgY29uY3VycmVuY3kpIHtcbiAgICAgICAgdmFyIHEgPSBfcXVldWUoZnVuY3Rpb24gKGl0ZW1zLCBjYikge1xuICAgICAgICAgICAgd29ya2VyKGl0ZW1zWzBdLCBjYik7XG4gICAgICAgIH0sIGNvbmN1cnJlbmN5LCAxKTtcblxuICAgICAgICByZXR1cm4gcTtcbiAgICB9O1xuXG4gICAgYXN5bmMucHJpb3JpdHlRdWV1ZSA9IGZ1bmN0aW9uICh3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XG5cbiAgICAgICAgZnVuY3Rpb24gX2NvbXBhcmVUYXNrcyhhLCBiKXtcbiAgICAgICAgICAgIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF9iaW5hcnlTZWFyY2goc2VxdWVuY2UsIGl0ZW0sIGNvbXBhcmUpIHtcbiAgICAgICAgICAgIHZhciBiZWcgPSAtMSxcbiAgICAgICAgICAgICAgICBlbmQgPSBzZXF1ZW5jZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKGJlZyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciBtaWQgPSBiZWcgKyAoKGVuZCAtIGJlZyArIDEpID4+PiAxKTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShpdGVtLCBzZXF1ZW5jZVttaWRdKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZyA9IG1pZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBtaWQgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiZWc7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfaW5zZXJ0KHEsIGRhdGEsIHByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0YXNrIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHEuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIV9pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FsbCBkcmFpbiBpbW1lZGlhdGVseSBpZiB0aGVyZSBhcmUgbm8gdGFza3NcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBxLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfYXJyYXlFYWNoKGRhdGEsIGZ1bmN0aW9uKHRhc2spIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdGFzayxcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5LFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gY2FsbGJhY2sgOiBub29wXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHEudGFza3Muc3BsaWNlKF9iaW5hcnlTZWFyY2gocS50YXNrcywgaXRlbSwgX2NvbXBhcmVUYXNrcykgKyAxLCAwLCBpdGVtKTtcblxuICAgICAgICAgICAgICAgIGlmIChxLnRhc2tzLmxlbmd0aCA9PT0gcS5jb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgICAgICBxLnNhdHVyYXRlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUocS5wcm9jZXNzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgd2l0aCBhIG5vcm1hbCBxdWV1ZVxuICAgICAgICB2YXIgcSA9IGFzeW5jLnF1ZXVlKHdvcmtlciwgY29uY3VycmVuY3kpO1xuXG4gICAgICAgIC8vIE92ZXJyaWRlIHB1c2ggdG8gYWNjZXB0IHNlY29uZCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIHByaW9yaXR5XG4gICAgICAgIHEucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBwcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgcHJpb3JpdHksIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZW1vdmUgdW5zaGlmdCBmdW5jdGlvblxuICAgICAgICBkZWxldGUgcS51bnNoaWZ0O1xuXG4gICAgICAgIHJldHVybiBxO1xuICAgIH07XG5cbiAgICBhc3luYy5jYXJnbyA9IGZ1bmN0aW9uICh3b3JrZXIsIHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIF9xdWV1ZSh3b3JrZXIsIDEsIHBheWxvYWQpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfY29uc29sZV9mbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBfcmVzdFBhcmFtKGZ1bmN0aW9uIChmbiwgYXJncykge1xuICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoW19yZXN0UGFyYW0oZnVuY3Rpb24gKGVyciwgYXJncykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uc29sZVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2FycmF5RWFjaChhcmdzLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGVbbmFtZV0oeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMubG9nID0gX2NvbnNvbGVfZm4oJ2xvZycpO1xuICAgIGFzeW5jLmRpciA9IF9jb25zb2xlX2ZuKCdkaXInKTtcbiAgICAvKmFzeW5jLmluZm8gPSBfY29uc29sZV9mbignaW5mbycpO1xuICAgIGFzeW5jLndhcm4gPSBfY29uc29sZV9mbignd2FybicpO1xuICAgIGFzeW5jLmVycm9yID0gX2NvbnNvbGVfZm4oJ2Vycm9yJyk7Ki9cblxuICAgIGFzeW5jLm1lbW9pemUgPSBmdW5jdGlvbiAoZm4sIGhhc2hlcikge1xuICAgICAgICB2YXIgbWVtbyA9IHt9O1xuICAgICAgICB2YXIgcXVldWVzID0ge307XG4gICAgICAgIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICAgICAgICBoYXNoZXIgPSBoYXNoZXIgfHwgaWRlbnRpdHk7XG4gICAgICAgIHZhciBtZW1vaXplZCA9IF9yZXN0UGFyYW0oZnVuY3Rpb24gbWVtb2l6ZWQoYXJncykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIHZhciBrZXkgPSBoYXNoZXIuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICBpZiAoaGFzLmNhbGwobWVtbywga2V5KSkgeyAgIFxuICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIG1lbW9ba2V5XSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXMuY2FsbChxdWV1ZXMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZXNba2V5XS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXVlc1trZXldID0gW2NhbGxiYWNrXTtcbiAgICAgICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChbX3Jlc3RQYXJhbShmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICBtZW1vW2tleV0gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IHF1ZXVlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcXVldWVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFbaV0uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1lbW9pemVkLm1lbW8gPSBtZW1vO1xuICAgICAgICBtZW1vaXplZC51bm1lbW9pemVkID0gZm47XG4gICAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9O1xuXG4gICAgYXN5bmMudW5tZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKGZuLnVubWVtb2l6ZWQgfHwgZm4pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF90aW1lcyhtYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb3VudCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBtYXBwZXIoX3JhbmdlKGNvdW50KSwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYy50aW1lcyA9IF90aW1lcyhhc3luYy5tYXApO1xuICAgIGFzeW5jLnRpbWVzU2VyaWVzID0gX3RpbWVzKGFzeW5jLm1hcFNlcmllcyk7XG4gICAgYXN5bmMudGltZXNMaW1pdCA9IGZ1bmN0aW9uIChjb3VudCwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gYXN5bmMubWFwTGltaXQoX3JhbmdlKGNvdW50KSwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnNlcSA9IGZ1bmN0aW9uICgvKiBmdW5jdGlvbnMuLi4gKi8pIHtcbiAgICAgICAgdmFyIGZucyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIF9yZXN0UGFyYW0oZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wb3AoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhc3luYy5yZWR1Y2UoZm5zLCBhcmdzLCBmdW5jdGlvbiAobmV3YXJncywgZm4sIGNiKSB7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgbmV3YXJncy5jb25jYXQoW19yZXN0UGFyYW0oZnVuY3Rpb24gKGVyciwgbmV4dGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IoZXJyLCBuZXh0YXJncyk7XG4gICAgICAgICAgICAgICAgfSldKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoYXQsIFtlcnJdLmNvbmNhdChyZXN1bHRzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLmNvbXBvc2UgPSBmdW5jdGlvbiAoLyogZnVuY3Rpb25zLi4uICovKSB7XG4gICAgICAgIHJldHVybiBhc3luYy5zZXEuYXBwbHkobnVsbCwgQXJyYXkucHJvdG90eXBlLnJldmVyc2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG5cbiAgICBmdW5jdGlvbiBfYXBwbHlFYWNoKGVhY2hmbikge1xuICAgICAgICByZXR1cm4gX3Jlc3RQYXJhbShmdW5jdGlvbihmbnMsIGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBnbyA9IF9yZXN0UGFyYW0oZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlYWNoZm4oZm5zLCBmdW5jdGlvbiAoZm4sIF8sIGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MuY29uY2F0KFtjYl0pKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdvLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYy5hcHBseUVhY2ggPSBfYXBwbHlFYWNoKGFzeW5jLmVhY2hPZik7XG4gICAgYXN5bmMuYXBwbHlFYWNoU2VyaWVzID0gX2FwcGx5RWFjaChhc3luYy5lYWNoT2ZTZXJpZXMpO1xuXG5cbiAgICBhc3luYy5mb3JldmVyID0gZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZG9uZSA9IG9ubHlfb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgICAgICAgdmFyIHRhc2sgPSBlbnN1cmVBc3luYyhmbik7XG4gICAgICAgIGZ1bmN0aW9uIG5leHQoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhc2sobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBlbnN1cmVBc3luYyhmbikge1xuICAgICAgICByZXR1cm4gX3Jlc3RQYXJhbShmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyQXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICBpZiAoc3luYykge1xuICAgICAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgaW5uZXJBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgaW5uZXJBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgc3luYyA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYy5lbnN1cmVBc3luYyA9IGVuc3VyZUFzeW5jO1xuXG4gICAgYXN5bmMuY29uc3RhbnQgPSBfcmVzdFBhcmFtKGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgICB2YXIgYXJncyA9IFtudWxsXS5jb25jYXQodmFsdWVzKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgYXN5bmMud3JhcFN5bmMgPVxuICAgIGFzeW5jLmFzeW5jaWZ5ID0gZnVuY3Rpb24gYXN5bmNpZnkoZnVuYykge1xuICAgICAgICByZXR1cm4gX3Jlc3RQYXJhbShmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgcmVzdWx0IGlzIFByb21pc2Ugb2JqZWN0XG4gICAgICAgICAgICBpZiAoX2lzT2JqZWN0KHJlc3VsdCkgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLm1lc3NhZ2UgPyBlcnIgOiBuZXcgRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBOb2RlLmpzXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gYXN5bmM7XG4gICAgfVxuICAgIC8vIEFNRCAvIFJlcXVpcmVKU1xuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3luYztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGluY2x1ZGVkIGRpcmVjdGx5IHZpYSA8c2NyaXB0PiB0YWdcbiAgICBlbHNlIHtcbiAgICAgICAgcm9vdC5hc3luYyA9IGFzeW5jO1xuICAgIH1cblxufSgpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/node_modules/async/lib/async.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/node_modules/glob/common.js":
/*!**************************************************************!*\
  !*** ./node_modules/sc-istanbul/node_modules/glob/common.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("exports.alphasort = alphasort\nexports.alphasorti = alphasorti\nexports.setopts = setopts\nexports.ownProp = ownProp\nexports.makeAbs = makeAbs\nexports.finish = finish\nexports.mark = mark\nexports.isIgnored = isIgnored\nexports.childrenIgnored = childrenIgnored\n\nfunction ownProp (obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field)\n}\n\nvar path = __webpack_require__(/*! path */ \"path\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"(ssr)/./node_modules/minimatch/minimatch.js\")\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"(ssr)/./node_modules/path-is-absolute/index.js\")\nvar Minimatch = minimatch.Minimatch\n\nfunction alphasorti (a, b) {\n  return a.toLowerCase().localeCompare(b.toLowerCase())\n}\n\nfunction alphasort (a, b) {\n  return a.localeCompare(b)\n}\n\nfunction setupIgnores (self, options) {\n  self.ignore = options.ignore || []\n\n  if (!Array.isArray(self.ignore))\n    self.ignore = [self.ignore]\n\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap)\n  }\n}\n\nfunction ignoreMap (pattern) {\n  var gmatcher = null\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '')\n    gmatcher = new Minimatch(gpattern)\n  }\n\n  return {\n    matcher: new Minimatch(pattern),\n    gmatcher: gmatcher\n  }\n}\n\nfunction setopts (self, pattern, options) {\n  if (!options)\n    options = {}\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\")\n    }\n    pattern = \"**/\" + pattern\n  }\n\n  self.silent = !!options.silent\n  self.pattern = pattern\n  self.strict = options.strict !== false\n  self.realpath = !!options.realpath\n  self.realpathCache = options.realpathCache || Object.create(null)\n  self.follow = !!options.follow\n  self.dot = !!options.dot\n  self.mark = !!options.mark\n  self.nodir = !!options.nodir\n  if (self.nodir)\n    self.mark = true\n  self.sync = !!options.sync\n  self.nounique = !!options.nounique\n  self.nonull = !!options.nonull\n  self.nosort = !!options.nosort\n  self.nocase = !!options.nocase\n  self.stat = !!options.stat\n  self.noprocess = !!options.noprocess\n\n  self.maxLength = options.maxLength || Infinity\n  self.cache = options.cache || Object.create(null)\n  self.statCache = options.statCache || Object.create(null)\n  self.symlinks = options.symlinks || Object.create(null)\n\n  setupIgnores(self, options)\n\n  self.changedCwd = false\n  var cwd = process.cwd()\n  if (!ownProp(options, \"cwd\"))\n    self.cwd = cwd\n  else {\n    self.cwd = options.cwd\n    self.changedCwd = path.resolve(options.cwd) !== cwd\n  }\n\n  self.root = options.root || path.resolve(self.cwd, \"/\")\n  self.root = path.resolve(self.root)\n  if (process.platform === \"win32\")\n    self.root = self.root.replace(/\\\\/g, \"/\")\n\n  self.nomount = !!options.nomount\n\n  // disable comments and negation unless the user explicitly\n  // passes in false as the option.\n  options.nonegate = options.nonegate === false ? false : true\n  options.nocomment = options.nocomment === false ? false : true\n  deprecationWarning(options)\n\n  self.minimatch = new Minimatch(pattern, options)\n  self.options = self.minimatch.options\n}\n\n// TODO(isaacs): remove entirely in v6\n// exported to reset in tests\nexports.deprecationWarned\nfunction deprecationWarning(options) {\n  if (!options.nonegate || !options.nocomment) {\n    if (process.noDeprecation !== true && !exports.deprecationWarned) {\n      var msg = 'glob WARNING: comments and negation will be disabled in v6'\n      if (process.throwDeprecation)\n        throw new Error(msg)\n      else if (process.traceDeprecation)\n        console.trace(msg)\n      else\n        console.error(msg)\n\n      exports.deprecationWarned = true\n    }\n  }\n}\n\nfunction finish (self) {\n  var nou = self.nounique\n  var all = nou ? [] : Object.create(null)\n\n  for (var i = 0, l = self.matches.length; i < l; i ++) {\n    var matches = self.matches[i]\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i]\n        if (nou)\n          all.push(literal)\n        else\n          all[literal] = true\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches)\n      if (nou)\n        all.push.apply(all, m)\n      else\n        m.forEach(function (m) {\n          all[m] = true\n        })\n    }\n  }\n\n  if (!nou)\n    all = Object.keys(all)\n\n  if (!self.nosort)\n    all = all.sort(self.nocase ? alphasorti : alphasort)\n\n  // at *some* point we statted all of these\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i])\n    }\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        return !(/\\/$/.test(e))\n      })\n    }\n  }\n\n  if (self.ignore.length)\n    all = all.filter(function(m) {\n      return !isIgnored(self, m)\n    })\n\n  self.found = all\n}\n\nfunction mark (self, p) {\n  var abs = makeAbs(self, p)\n  var c = self.cache[abs]\n  var m = p\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c)\n    var slash = p.slice(-1) === '/'\n\n    if (isDir && !slash)\n      m += '/'\n    else if (!isDir && slash)\n      m = m.slice(0, -1)\n\n    if (m !== p) {\n      var mabs = makeAbs(self, m)\n      self.statCache[mabs] = self.statCache[abs]\n      self.cache[mabs] = self.cache[abs]\n    }\n  }\n\n  return m\n}\n\n// lotta situps...\nfunction makeAbs (self, f) {\n  var abs = f\n  if (f.charAt(0) === '/') {\n    abs = path.join(self.root, f)\n  } else if (isAbsolute(f) || f === '') {\n    abs = f\n  } else if (self.changedCwd) {\n    abs = path.resolve(self.cwd, f)\n  } else {\n    abs = path.resolve(f)\n  }\n  return abs\n}\n\n\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\nfunction childrenIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbm9kZV9tb2R1bGVzL2dsb2IvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsY0FBYztBQUNkLFlBQVk7QUFDWixpQkFBaUI7QUFDakIsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLGdCQUFnQixtQkFBTyxDQUFDLDhEQUFXO0FBQ25DLGlCQUFpQixtQkFBTyxDQUFDLHdFQUFrQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSx5QkFBeUI7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbm9kZV9tb2R1bGVzL2dsb2IvY29tbW9uLmpzPzFjZGYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5hbHBoYXNvcnQgPSBhbHBoYXNvcnRcbmV4cG9ydHMuYWxwaGFzb3J0aSA9IGFscGhhc29ydGlcbmV4cG9ydHMuc2V0b3B0cyA9IHNldG9wdHNcbmV4cG9ydHMub3duUHJvcCA9IG93blByb3BcbmV4cG9ydHMubWFrZUFicyA9IG1ha2VBYnNcbmV4cG9ydHMuZmluaXNoID0gZmluaXNoXG5leHBvcnRzLm1hcmsgPSBtYXJrXG5leHBvcnRzLmlzSWdub3JlZCA9IGlzSWdub3JlZFxuZXhwb3J0cy5jaGlsZHJlbklnbm9yZWQgPSBjaGlsZHJlbklnbm9yZWRcblxuZnVuY3Rpb24gb3duUHJvcCAob2JqLCBmaWVsZCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgZmllbGQpXG59XG5cbnZhciBwYXRoID0gcmVxdWlyZShcInBhdGhcIilcbnZhciBtaW5pbWF0Y2ggPSByZXF1aXJlKFwibWluaW1hdGNoXCIpXG52YXIgaXNBYnNvbHV0ZSA9IHJlcXVpcmUoXCJwYXRoLWlzLWFic29sdXRlXCIpXG52YXIgTWluaW1hdGNoID0gbWluaW1hdGNoLk1pbmltYXRjaFxuXG5mdW5jdGlvbiBhbHBoYXNvcnRpIChhLCBiKSB7XG4gIHJldHVybiBhLnRvTG93ZXJDYXNlKCkubG9jYWxlQ29tcGFyZShiLnRvTG93ZXJDYXNlKCkpXG59XG5cbmZ1bmN0aW9uIGFscGhhc29ydCAoYSwgYikge1xuICByZXR1cm4gYS5sb2NhbGVDb21wYXJlKGIpXG59XG5cbmZ1bmN0aW9uIHNldHVwSWdub3JlcyAoc2VsZiwgb3B0aW9ucykge1xuICBzZWxmLmlnbm9yZSA9IG9wdGlvbnMuaWdub3JlIHx8IFtdXG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHNlbGYuaWdub3JlKSlcbiAgICBzZWxmLmlnbm9yZSA9IFtzZWxmLmlnbm9yZV1cblxuICBpZiAoc2VsZi5pZ25vcmUubGVuZ3RoKSB7XG4gICAgc2VsZi5pZ25vcmUgPSBzZWxmLmlnbm9yZS5tYXAoaWdub3JlTWFwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGlnbm9yZU1hcCAocGF0dGVybikge1xuICB2YXIgZ21hdGNoZXIgPSBudWxsXG4gIGlmIChwYXR0ZXJuLnNsaWNlKC0zKSA9PT0gJy8qKicpIHtcbiAgICB2YXIgZ3BhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UoLyhcXC9cXCpcXCopKyQvLCAnJylcbiAgICBnbWF0Y2hlciA9IG5ldyBNaW5pbWF0Y2goZ3BhdHRlcm4pXG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1hdGNoZXI6IG5ldyBNaW5pbWF0Y2gocGF0dGVybiksXG4gICAgZ21hdGNoZXI6IGdtYXRjaGVyXG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0b3B0cyAoc2VsZiwgcGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IHt9XG5cbiAgLy8gYmFzZS1tYXRjaGluZzoganVzdCB1c2UgZ2xvYnN0YXIgZm9yIHRoYXQuXG4gIGlmIChvcHRpb25zLm1hdGNoQmFzZSAmJiAtMSA9PT0gcGF0dGVybi5pbmRleE9mKFwiL1wiKSkge1xuICAgIGlmIChvcHRpb25zLm5vZ2xvYnN0YXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJhc2UgbWF0Y2hpbmcgcmVxdWlyZXMgZ2xvYnN0YXJcIilcbiAgICB9XG4gICAgcGF0dGVybiA9IFwiKiovXCIgKyBwYXR0ZXJuXG4gIH1cblxuICBzZWxmLnNpbGVudCA9ICEhb3B0aW9ucy5zaWxlbnRcbiAgc2VsZi5wYXR0ZXJuID0gcGF0dGVyblxuICBzZWxmLnN0cmljdCA9IG9wdGlvbnMuc3RyaWN0ICE9PSBmYWxzZVxuICBzZWxmLnJlYWxwYXRoID0gISFvcHRpb25zLnJlYWxwYXRoXG4gIHNlbGYucmVhbHBhdGhDYWNoZSA9IG9wdGlvbnMucmVhbHBhdGhDYWNoZSB8fCBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHNlbGYuZm9sbG93ID0gISFvcHRpb25zLmZvbGxvd1xuICBzZWxmLmRvdCA9ICEhb3B0aW9ucy5kb3RcbiAgc2VsZi5tYXJrID0gISFvcHRpb25zLm1hcmtcbiAgc2VsZi5ub2RpciA9ICEhb3B0aW9ucy5ub2RpclxuICBpZiAoc2VsZi5ub2RpcilcbiAgICBzZWxmLm1hcmsgPSB0cnVlXG4gIHNlbGYuc3luYyA9ICEhb3B0aW9ucy5zeW5jXG4gIHNlbGYubm91bmlxdWUgPSAhIW9wdGlvbnMubm91bmlxdWVcbiAgc2VsZi5ub251bGwgPSAhIW9wdGlvbnMubm9udWxsXG4gIHNlbGYubm9zb3J0ID0gISFvcHRpb25zLm5vc29ydFxuICBzZWxmLm5vY2FzZSA9ICEhb3B0aW9ucy5ub2Nhc2VcbiAgc2VsZi5zdGF0ID0gISFvcHRpb25zLnN0YXRcbiAgc2VsZi5ub3Byb2Nlc3MgPSAhIW9wdGlvbnMubm9wcm9jZXNzXG5cbiAgc2VsZi5tYXhMZW5ndGggPSBvcHRpb25zLm1heExlbmd0aCB8fCBJbmZpbml0eVxuICBzZWxmLmNhY2hlID0gb3B0aW9ucy5jYWNoZSB8fCBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHNlbGYuc3RhdENhY2hlID0gb3B0aW9ucy5zdGF0Q2FjaGUgfHwgT2JqZWN0LmNyZWF0ZShudWxsKVxuICBzZWxmLnN5bWxpbmtzID0gb3B0aW9ucy5zeW1saW5rcyB8fCBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgc2V0dXBJZ25vcmVzKHNlbGYsIG9wdGlvbnMpXG5cbiAgc2VsZi5jaGFuZ2VkQ3dkID0gZmFsc2VcbiAgdmFyIGN3ZCA9IHByb2Nlc3MuY3dkKClcbiAgaWYgKCFvd25Qcm9wKG9wdGlvbnMsIFwiY3dkXCIpKVxuICAgIHNlbGYuY3dkID0gY3dkXG4gIGVsc2Uge1xuICAgIHNlbGYuY3dkID0gb3B0aW9ucy5jd2RcbiAgICBzZWxmLmNoYW5nZWRDd2QgPSBwYXRoLnJlc29sdmUob3B0aW9ucy5jd2QpICE9PSBjd2RcbiAgfVxuXG4gIHNlbGYucm9vdCA9IG9wdGlvbnMucm9vdCB8fCBwYXRoLnJlc29sdmUoc2VsZi5jd2QsIFwiL1wiKVxuICBzZWxmLnJvb3QgPSBwYXRoLnJlc29sdmUoc2VsZi5yb290KVxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKVxuICAgIHNlbGYucm9vdCA9IHNlbGYucm9vdC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKVxuXG4gIHNlbGYubm9tb3VudCA9ICEhb3B0aW9ucy5ub21vdW50XG5cbiAgLy8gZGlzYWJsZSBjb21tZW50cyBhbmQgbmVnYXRpb24gdW5sZXNzIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgLy8gcGFzc2VzIGluIGZhbHNlIGFzIHRoZSBvcHRpb24uXG4gIG9wdGlvbnMubm9uZWdhdGUgPSBvcHRpb25zLm5vbmVnYXRlID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZVxuICBvcHRpb25zLm5vY29tbWVudCA9IG9wdGlvbnMubm9jb21tZW50ID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZVxuICBkZXByZWNhdGlvbldhcm5pbmcob3B0aW9ucylcblxuICBzZWxmLm1pbmltYXRjaCA9IG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucylcbiAgc2VsZi5vcHRpb25zID0gc2VsZi5taW5pbWF0Y2gub3B0aW9uc1xufVxuXG4vLyBUT0RPKGlzYWFjcyk6IHJlbW92ZSBlbnRpcmVseSBpbiB2NlxuLy8gZXhwb3J0ZWQgdG8gcmVzZXQgaW4gdGVzdHNcbmV4cG9ydHMuZGVwcmVjYXRpb25XYXJuZWRcbmZ1bmN0aW9uIGRlcHJlY2F0aW9uV2FybmluZyhvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucy5ub25lZ2F0ZSB8fCAhb3B0aW9ucy5ub2NvbW1lbnQpIHtcbiAgICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uICE9PSB0cnVlICYmICFleHBvcnRzLmRlcHJlY2F0aW9uV2FybmVkKSB7XG4gICAgICB2YXIgbXNnID0gJ2dsb2IgV0FSTklORzogY29tbWVudHMgYW5kIG5lZ2F0aW9uIHdpbGwgYmUgZGlzYWJsZWQgaW4gdjYnXG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKVxuICAgICAgZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKVxuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZylcbiAgICAgIGVsc2VcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpXG5cbiAgICAgIGV4cG9ydHMuZGVwcmVjYXRpb25XYXJuZWQgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaCAoc2VsZikge1xuICB2YXIgbm91ID0gc2VsZi5ub3VuaXF1ZVxuICB2YXIgYWxsID0gbm91ID8gW10gOiBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzZWxmLm1hdGNoZXMubGVuZ3RoOyBpIDwgbDsgaSArKykge1xuICAgIHZhciBtYXRjaGVzID0gc2VsZi5tYXRjaGVzW2ldXG4gICAgaWYgKCFtYXRjaGVzIHx8IE9iamVjdC5rZXlzKG1hdGNoZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHNlbGYubm9udWxsKSB7XG4gICAgICAgIC8vIGRvIGxpa2UgdGhlIHNoZWxsLCBhbmQgc3BpdCBvdXQgdGhlIGxpdGVyYWwgZ2xvYlxuICAgICAgICB2YXIgbGl0ZXJhbCA9IHNlbGYubWluaW1hdGNoLmdsb2JTZXRbaV1cbiAgICAgICAgaWYgKG5vdSlcbiAgICAgICAgICBhbGwucHVzaChsaXRlcmFsKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYWxsW2xpdGVyYWxdID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYWQgbWF0Y2hlc1xuICAgICAgdmFyIG0gPSBPYmplY3Qua2V5cyhtYXRjaGVzKVxuICAgICAgaWYgKG5vdSlcbiAgICAgICAgYWxsLnB1c2guYXBwbHkoYWxsLCBtKVxuICAgICAgZWxzZVxuICAgICAgICBtLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICBhbGxbbV0gPSB0cnVlXG4gICAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaWYgKCFub3UpXG4gICAgYWxsID0gT2JqZWN0LmtleXMoYWxsKVxuXG4gIGlmICghc2VsZi5ub3NvcnQpXG4gICAgYWxsID0gYWxsLnNvcnQoc2VsZi5ub2Nhc2UgPyBhbHBoYXNvcnRpIDogYWxwaGFzb3J0KVxuXG4gIC8vIGF0ICpzb21lKiBwb2ludCB3ZSBzdGF0dGVkIGFsbCBvZiB0aGVzZVxuICBpZiAoc2VsZi5tYXJrKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFsbFtpXSA9IHNlbGYuX21hcmsoYWxsW2ldKVxuICAgIH1cbiAgICBpZiAoc2VsZi5ub2Rpcikge1xuICAgICAgYWxsID0gYWxsLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gISgvXFwvJC8udGVzdChlKSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaWYgKHNlbGYuaWdub3JlLmxlbmd0aClcbiAgICBhbGwgPSBhbGwuZmlsdGVyKGZ1bmN0aW9uKG0pIHtcbiAgICAgIHJldHVybiAhaXNJZ25vcmVkKHNlbGYsIG0pXG4gICAgfSlcblxuICBzZWxmLmZvdW5kID0gYWxsXG59XG5cbmZ1bmN0aW9uIG1hcmsgKHNlbGYsIHApIHtcbiAgdmFyIGFicyA9IG1ha2VBYnMoc2VsZiwgcClcbiAgdmFyIGMgPSBzZWxmLmNhY2hlW2Fic11cbiAgdmFyIG0gPSBwXG4gIGlmIChjKSB7XG4gICAgdmFyIGlzRGlyID0gYyA9PT0gJ0RJUicgfHwgQXJyYXkuaXNBcnJheShjKVxuICAgIHZhciBzbGFzaCA9IHAuc2xpY2UoLTEpID09PSAnLydcblxuICAgIGlmIChpc0RpciAmJiAhc2xhc2gpXG4gICAgICBtICs9ICcvJ1xuICAgIGVsc2UgaWYgKCFpc0RpciAmJiBzbGFzaClcbiAgICAgIG0gPSBtLnNsaWNlKDAsIC0xKVxuXG4gICAgaWYgKG0gIT09IHApIHtcbiAgICAgIHZhciBtYWJzID0gbWFrZUFicyhzZWxmLCBtKVxuICAgICAgc2VsZi5zdGF0Q2FjaGVbbWFic10gPSBzZWxmLnN0YXRDYWNoZVthYnNdXG4gICAgICBzZWxmLmNhY2hlW21hYnNdID0gc2VsZi5jYWNoZVthYnNdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1cbn1cblxuLy8gbG90dGEgc2l0dXBzLi4uXG5mdW5jdGlvbiBtYWtlQWJzIChzZWxmLCBmKSB7XG4gIHZhciBhYnMgPSBmXG4gIGlmIChmLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgYWJzID0gcGF0aC5qb2luKHNlbGYucm9vdCwgZilcbiAgfSBlbHNlIGlmIChpc0Fic29sdXRlKGYpIHx8IGYgPT09ICcnKSB7XG4gICAgYWJzID0gZlxuICB9IGVsc2UgaWYgKHNlbGYuY2hhbmdlZEN3ZCkge1xuICAgIGFicyA9IHBhdGgucmVzb2x2ZShzZWxmLmN3ZCwgZilcbiAgfSBlbHNlIHtcbiAgICBhYnMgPSBwYXRoLnJlc29sdmUoZilcbiAgfVxuICByZXR1cm4gYWJzXG59XG5cblxuLy8gUmV0dXJuIHRydWUsIGlmIHBhdHRlcm4gZW5kcyB3aXRoIGdsb2JzdGFyICcqKicsIGZvciB0aGUgYWNjb21wYW55aW5nIHBhcmVudCBkaXJlY3RvcnkuXG4vLyBFeDotIElmIG5vZGVfbW9kdWxlcy8qKiBpcyB0aGUgcGF0dGVybiwgYWRkICdub2RlX21vZHVsZXMnIHRvIGlnbm9yZSBsaXN0IGFsb25nIHdpdGggaXQncyBjb250ZW50c1xuZnVuY3Rpb24gaXNJZ25vcmVkIChzZWxmLCBwYXRoKSB7XG4gIGlmICghc2VsZi5pZ25vcmUubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIHJldHVybiBzZWxmLmlnbm9yZS5zb21lKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS5tYXRjaGVyLm1hdGNoKHBhdGgpIHx8ICEhKGl0ZW0uZ21hdGNoZXIgJiYgaXRlbS5nbWF0Y2hlci5tYXRjaChwYXRoKSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY2hpbGRyZW5JZ25vcmVkIChzZWxmLCBwYXRoKSB7XG4gIGlmICghc2VsZi5pZ25vcmUubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIHJldHVybiBzZWxmLmlnbm9yZS5zb21lKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gISEoaXRlbS5nbWF0Y2hlciAmJiBpdGVtLmdtYXRjaGVyLm1hdGNoKHBhdGgpKVxuICB9KVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/node_modules/glob/common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/node_modules/glob/glob.js":
/*!************************************************************!*\
  !*** ./node_modules/sc-istanbul/node_modules/glob/glob.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\nmodule.exports = glob\n\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"(ssr)/./node_modules/minimatch/minimatch.js\")\nvar Minimatch = minimatch.Minimatch\nvar inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/inherits/inherits.js\")\nvar EE = (__webpack_require__(/*! events */ \"events\").EventEmitter)\nvar path = __webpack_require__(/*! path */ \"path\")\nvar assert = __webpack_require__(/*! assert */ \"assert\")\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"(ssr)/./node_modules/path-is-absolute/index.js\")\nvar globSync = __webpack_require__(/*! ./sync.js */ \"(ssr)/./node_modules/sc-istanbul/node_modules/glob/sync.js\")\nvar common = __webpack_require__(/*! ./common.js */ \"(ssr)/./node_modules/sc-istanbul/node_modules/glob/common.js\")\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar inflight = __webpack_require__(/*! inflight */ \"(ssr)/./node_modules/inflight/inflight.js\")\nvar util = __webpack_require__(/*! util */ \"util\")\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nvar once = __webpack_require__(/*! once */ \"(ssr)/./node_modules/once/once.js\")\n\nfunction glob (pattern, options, cb) {\n  if (typeof options === 'function') cb = options, options = {}\n  if (!options) options = {}\n\n  if (options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return globSync(pattern, options)\n  }\n\n  return new Glob(pattern, options, cb)\n}\n\nglob.sync = globSync\nvar GlobSync = glob.GlobSync = globSync.GlobSync\n\n// old api surface\nglob.glob = glob\n\nglob.hasMagic = function (pattern, options_) {\n  var options = util._extend({}, options_)\n  options.noprocess = true\n\n  var g = new Glob(pattern, options)\n  var set = g.minimatch.set\n  if (set.length > 1)\n    return true\n\n  for (var j = 0; j < set[0].length; j++) {\n    if (typeof set[0][j] !== 'string')\n      return true\n  }\n\n  return false\n}\n\nglob.Glob = Glob\ninherits(Glob, EE)\nfunction Glob (pattern, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = null\n  }\n\n  if (options && options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return new GlobSync(pattern, options)\n  }\n\n  if (!(this instanceof Glob))\n    return new Glob(pattern, options, cb)\n\n  setopts(this, pattern, options)\n  this._didRealPath = false\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n)\n\n  if (typeof cb === 'function') {\n    cb = once(cb)\n    this.on('error', cb)\n    this.on('end', function (matches) {\n      cb(null, matches)\n    })\n  }\n\n  var self = this\n  var n = this.minimatch.set.length\n  this._processing = 0\n  this.matches = new Array(n)\n\n  this._emitQueue = []\n  this._processQueue = []\n  this.paused = false\n\n  if (this.noprocess)\n    return this\n\n  if (n === 0)\n    return done()\n\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false, done)\n  }\n\n  function done () {\n    --self._processing\n    if (self._processing <= 0)\n      self._finish()\n  }\n}\n\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob)\n  if (this.aborted)\n    return\n\n  if (this.realpath && !this._didRealpath)\n    return this._realpath()\n\n  common.finish(this)\n  this.emit('end', this.found)\n}\n\nGlob.prototype._realpath = function () {\n  if (this._didRealpath)\n    return\n\n  this._didRealpath = true\n\n  var n = this.matches.length\n  if (n === 0)\n    return this._finish()\n\n  var self = this\n  for (var i = 0; i < this.matches.length; i++)\n    this._realpathSet(i, next)\n\n  function next () {\n    if (--n === 0)\n      self._finish()\n  }\n}\n\nGlob.prototype._realpathSet = function (index, cb) {\n  var matchset = this.matches[index]\n  if (!matchset)\n    return cb()\n\n  var found = Object.keys(matchset)\n  var self = this\n  var n = found.length\n\n  if (n === 0)\n    return cb()\n\n  var set = this.matches[index] = Object.create(null)\n  found.forEach(function (p, i) {\n    // If there's a problem with the stat, then it means that\n    // one or more of the links in the realpath couldn't be\n    // resolved.  just return the abs value in that case.\n    p = self._makeAbs(p)\n    fs.realpath(p, self.realpathCache, function (er, real) {\n      if (!er)\n        set[real] = true\n      else if (er.syscall === 'stat')\n        set[p] = true\n      else\n        self.emit('error', er) // srsly wtf right here\n\n      if (--n === 0) {\n        self.matches[index] = set\n        cb()\n      }\n    })\n  })\n}\n\nGlob.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlob.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\nGlob.prototype.abort = function () {\n  this.aborted = true\n  this.emit('abort')\n}\n\nGlob.prototype.pause = function () {\n  if (!this.paused) {\n    this.paused = true\n    this.emit('pause')\n  }\n}\n\nGlob.prototype.resume = function () {\n  if (this.paused) {\n    this.emit('resume')\n    this.paused = false\n    if (this._emitQueue.length) {\n      var eq = this._emitQueue.slice(0)\n      this._emitQueue.length = 0\n      for (var i = 0; i < eq.length; i ++) {\n        var e = eq[i]\n        this._emitMatch(e[0], e[1])\n      }\n    }\n    if (this._processQueue.length) {\n      var pq = this._processQueue.slice(0)\n      this._processQueue.length = 0\n      for (var i = 0; i < pq.length; i ++) {\n        var p = pq[i]\n        this._processing--\n        this._process(p[0], p[1], p[2], p[3])\n      }\n    }\n  }\n}\n\nGlob.prototype._process = function (pattern, index, inGlobStar, cb) {\n  assert(this instanceof Glob)\n  assert(typeof cb === 'function')\n\n  if (this.aborted)\n    return\n\n  this._processing++\n  if (this.paused) {\n    this._processQueue.push([pattern, index, inGlobStar, cb])\n    return\n  }\n\n  //console.error('PROCESS %d', this._processing, pattern)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index, cb)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip _processing\n  if (childrenIgnored(this, read))\n    return cb()\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)\n}\n\nGlob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\nGlob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return cb()\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return cb()\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return cb()\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix) {\n      if (prefix !== '/')\n        e = prefix + '/' + e\n      else\n        e = prefix + e\n    }\n    this._process([e].concat(remain), index, inGlobStar, cb)\n  }\n  cb()\n}\n\nGlob.prototype._emitMatch = function (index, e) {\n  if (this.aborted)\n    return\n\n  if (this.matches[index][e])\n    return\n\n  if (isIgnored(this, e))\n    return\n\n  if (this.paused) {\n    this._emitQueue.push([index, e])\n    return\n  }\n\n  var abs = this._makeAbs(e)\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  if (this.mark)\n    e = this._mark(e)\n\n  this.matches[index][e] = true\n\n  var st = this.statCache[abs]\n  if (st)\n    this.emit('stat', e, st)\n\n  this.emit('match', e)\n}\n\nGlob.prototype._readdirInGlobStar = function (abs, cb) {\n  if (this.aborted)\n    return\n\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false, cb)\n\n  var lstatkey = 'lstat\\0' + abs\n  var self = this\n  var lstatcb = inflight(lstatkey, lstatcb_)\n\n  if (lstatcb)\n    fs.lstat(abs, lstatcb)\n\n  function lstatcb_ (er, lstat) {\n    if (er)\n      return cb()\n\n    var isSym = lstat.isSymbolicLink()\n    self.symlinks[abs] = isSym\n\n    // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n    if (!isSym && !lstat.isDirectory()) {\n      self.cache[abs] = 'FILE'\n      cb()\n    } else\n      self._readdir(abs, false, cb)\n  }\n}\n\nGlob.prototype._readdir = function (abs, inGlobStar, cb) {\n  if (this.aborted)\n    return\n\n  cb = inflight('readdir\\0'+abs+'\\0'+inGlobStar, cb)\n  if (!cb)\n    return\n\n  //console.error('RD %j %j', +inGlobStar, abs)\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs, cb)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return cb()\n\n    if (Array.isArray(c))\n      return cb(null, c)\n  }\n\n  var self = this\n  fs.readdir(abs, readdirCb(this, abs, cb))\n}\n\nfunction readdirCb (self, abs, cb) {\n  return function (er, entries) {\n    if (er)\n      self._readdirError(abs, er, cb)\n    else\n      self._readdirEntries(abs, entries, cb)\n  }\n}\n\nGlob.prototype._readdirEntries = function (abs, entries, cb) {\n  if (this.aborted)\n    return\n\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n  return cb(null, entries)\n}\n\nGlob.prototype._readdirError = function (f, er, cb) {\n  if (this.aborted)\n    return\n\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      this.cache[this._makeAbs(f)] = 'FILE'\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict) {\n        this.emit('error', er)\n        // If the error is handled, then we abort\n        // if not, we threw out of here\n        this.abort()\n      }\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n\n  return cb()\n}\n\nGlob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\n\nGlob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  //console.error('pgs2', prefix, remain[0], entries)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return cb()\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false, cb)\n\n  var isSym = this.symlinks[abs]\n  var len = entries.length\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return cb()\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true, cb)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true, cb)\n  }\n\n  cb()\n}\n\nGlob.prototype._processSimple = function (prefix, index, cb) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var self = this\n  this._stat(prefix, function (er, exists) {\n    self._processSimple2(prefix, index, er, exists, cb)\n  })\n}\nGlob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\n\n  //console.error('ps2', prefix, exists)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return cb()\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n  cb()\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlob.prototype._stat = function (f, cb) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return cb()\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return cb(null, c)\n\n    if (needDir && c === 'FILE')\n      return cb()\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (stat !== undefined) {\n    if (stat === false)\n      return cb(null, stat)\n    else {\n      var type = stat.isDirectory() ? 'DIR' : 'FILE'\n      if (needDir && type === 'FILE')\n        return cb()\n      else\n        return cb(null, type, stat)\n    }\n  }\n\n  var self = this\n  var statcb = inflight('stat\\0' + abs, lstatcb_)\n  if (statcb)\n    fs.lstat(abs, statcb)\n\n  function lstatcb_ (er, lstat) {\n    if (lstat && lstat.isSymbolicLink()) {\n      // If it's a symlink, then treat it as the target, unless\n      // the target does not exist, then treat it as a file.\n      return fs.stat(abs, function (er, stat) {\n        if (er)\n          self._stat2(f, abs, null, lstat, cb)\n        else\n          self._stat2(f, abs, er, stat, cb)\n      })\n    } else {\n      self._stat2(f, abs, er, lstat, cb)\n    }\n  }\n}\n\nGlob.prototype._stat2 = function (f, abs, er, stat, cb) {\n  if (er) {\n    this.statCache[abs] = false\n    return cb()\n  }\n\n  var needDir = f.slice(-1) === '/'\n  this.statCache[abs] = stat\n\n  if (abs.slice(-1) === '/' && !stat.isDirectory())\n    return cb(null, false, stat)\n\n  var c = stat.isDirectory() ? 'DIR' : 'FILE'\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c !== 'DIR')\n    return cb()\n\n  return cb(null, c, stat)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbm9kZV9tb2R1bGVzL2dsb2IvZ2xvYi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUyxtQkFBTyxDQUFDLGNBQUk7QUFDckIsZ0JBQWdCLG1CQUFPLENBQUMsOERBQVc7QUFDbkM7QUFDQSxlQUFlLG1CQUFPLENBQUMsMkRBQVU7QUFDakMsU0FBUywwREFBOEI7QUFDdkMsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBa0I7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLDZFQUFXO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxpRkFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQywyREFBVTtBQUNqQyxXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekI7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsK0NBQU07O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQ0FBZ0Msc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL3NjLWlzdGFuYnVsL25vZGVfbW9kdWxlcy9nbG9iL2dsb2IuanM/M2I3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBcHByb2FjaDpcbi8vXG4vLyAxLiBHZXQgdGhlIG1pbmltYXRjaCBzZXRcbi8vIDIuIEZvciBlYWNoIHBhdHRlcm4gaW4gdGhlIHNldCwgUFJPQ0VTUyhwYXR0ZXJuLCBmYWxzZSlcbi8vIDMuIFN0b3JlIG1hdGNoZXMgcGVyLXNldCwgdGhlbiB1bmlxIHRoZW1cbi8vXG4vLyBQUk9DRVNTKHBhdHRlcm4sIGluR2xvYlN0YXIpXG4vLyBHZXQgdGhlIGZpcnN0IFtuXSBpdGVtcyBmcm9tIHBhdHRlcm4gdGhhdCBhcmUgYWxsIHN0cmluZ3Ncbi8vIEpvaW4gdGhlc2UgdG9nZXRoZXIuICBUaGlzIGlzIFBSRUZJWC5cbi8vICAgSWYgdGhlcmUgaXMgbm8gbW9yZSByZW1haW5pbmcsIHRoZW4gc3RhdChQUkVGSVgpIGFuZFxuLy8gICBhZGQgdG8gbWF0Y2hlcyBpZiBpdCBzdWNjZWVkcy4gIEVORC5cbi8vXG4vLyBJZiBpbkdsb2JTdGFyIGFuZCBQUkVGSVggaXMgc3ltbGluayBhbmQgcG9pbnRzIHRvIGRpclxuLy8gICBzZXQgRU5UUklFUyA9IFtdXG4vLyBlbHNlIHJlYWRkaXIoUFJFRklYKSBhcyBFTlRSSUVTXG4vLyAgIElmIGZhaWwsIEVORFxuLy9cbi8vIHdpdGggRU5UUklFU1xuLy8gICBJZiBwYXR0ZXJuW25dIGlzIEdMT0JTVEFSXG4vLyAgICAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBnbG9ic3RhciBtYXRjaCBpcyBlbXB0eVxuLy8gICAgIC8vIGJ5IHBydW5pbmcgaXQgb3V0LCBhbmQgdGVzdGluZyB0aGUgcmVzdWx0aW5nIHBhdHRlcm5cbi8vICAgICBQUk9DRVNTKHBhdHRlcm5bMC4ubl0gKyBwYXR0ZXJuW24rMSAuLiAkXSwgZmFsc2UpXG4vLyAgICAgLy8gaGFuZGxlIG90aGVyIGNhc2VzLlxuLy8gICAgIGZvciBFTlRSWSBpbiBFTlRSSUVTIChub3QgZG90ZmlsZXMpXG4vLyAgICAgICAvLyBhdHRhY2ggZ2xvYnN0YXIgKyB0YWlsIG9udG8gdGhlIGVudHJ5XG4vLyAgICAgICAvLyBNYXJrIHRoYXQgdGhpcyBlbnRyeSBpcyBhIGdsb2JzdGFyIG1hdGNoXG4vLyAgICAgICBQUk9DRVNTKHBhdHRlcm5bMC4ubl0gKyBFTlRSWSArIHBhdHRlcm5bbiAuLiAkXSwgdHJ1ZSlcbi8vXG4vLyAgIGVsc2UgLy8gbm90IGdsb2JzdGFyXG4vLyAgICAgZm9yIEVOVFJZIGluIEVOVFJJRVMgKG5vdCBkb3RmaWxlcywgdW5sZXNzIHBhdHRlcm5bbl0gaXMgZG90KVxuLy8gICAgICAgVGVzdCBFTlRSWSBhZ2FpbnN0IHBhdHRlcm5bbl1cbi8vICAgICAgIElmIGZhaWxzLCBjb250aW51ZVxuLy8gICAgICAgSWYgcGFzc2VzLCBQUk9DRVNTKHBhdHRlcm5bMC4ubl0gKyBpdGVtICsgcGF0dGVybltuKzEgLi4gJF0pXG4vL1xuLy8gQ2F2ZWF0OlxuLy8gICBDYWNoZSBhbGwgc3RhdHMgYW5kIHJlYWRkaXJzIHJlc3VsdHMgdG8gbWluaW1pemUgc3lzY2FsbC4gIFNpbmNlIGFsbFxuLy8gICB3ZSBldmVyIGNhcmUgYWJvdXQgaXMgZXhpc3RlbmNlIGFuZCBkaXJlY3RvcnktbmVzcywgd2UgY2FuIGp1c3Qga2VlcFxuLy8gICBgdHJ1ZWAgZm9yIGZpbGVzLCBhbmQgW2NoaWxkcmVuLC4uLl0gZm9yIGRpcmVjdG9yaWVzLCBvciBgZmFsc2VgIGZvclxuLy8gICB0aGluZ3MgdGhhdCBkb24ndCBleGlzdC5cblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iXG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbnZhciBtaW5pbWF0Y2ggPSByZXF1aXJlKCdtaW5pbWF0Y2gnKVxudmFyIE1pbmltYXRjaCA9IG1pbmltYXRjaC5NaW5pbWF0Y2hcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxudmFyIGlzQWJzb2x1dGUgPSByZXF1aXJlKCdwYXRoLWlzLWFic29sdXRlJylcbnZhciBnbG9iU3luYyA9IHJlcXVpcmUoJy4vc3luYy5qcycpXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24uanMnKVxudmFyIGFscGhhc29ydCA9IGNvbW1vbi5hbHBoYXNvcnRcbnZhciBhbHBoYXNvcnRpID0gY29tbW9uLmFscGhhc29ydGlcbnZhciBzZXRvcHRzID0gY29tbW9uLnNldG9wdHNcbnZhciBvd25Qcm9wID0gY29tbW9uLm93blByb3BcbnZhciBpbmZsaWdodCA9IHJlcXVpcmUoJ2luZmxpZ2h0JylcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG52YXIgY2hpbGRyZW5JZ25vcmVkID0gY29tbW9uLmNoaWxkcmVuSWdub3JlZFxudmFyIGlzSWdub3JlZCA9IGNvbW1vbi5pc0lnbm9yZWRcblxudmFyIG9uY2UgPSByZXF1aXJlKCdvbmNlJylcblxuZnVuY3Rpb24gZ2xvYiAocGF0dGVybiwgb3B0aW9ucywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSB7fVxuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fVxuXG4gIGlmIChvcHRpb25zLnN5bmMpIHtcbiAgICBpZiAoY2IpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBwcm92aWRlZCB0byBzeW5jIGdsb2InKVxuICAgIHJldHVybiBnbG9iU3luYyhwYXR0ZXJuLCBvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBHbG9iKHBhdHRlcm4sIG9wdGlvbnMsIGNiKVxufVxuXG5nbG9iLnN5bmMgPSBnbG9iU3luY1xudmFyIEdsb2JTeW5jID0gZ2xvYi5HbG9iU3luYyA9IGdsb2JTeW5jLkdsb2JTeW5jXG5cbi8vIG9sZCBhcGkgc3VyZmFjZVxuZ2xvYi5nbG9iID0gZ2xvYlxuXG5nbG9iLmhhc01hZ2ljID0gZnVuY3Rpb24gKHBhdHRlcm4sIG9wdGlvbnNfKSB7XG4gIHZhciBvcHRpb25zID0gdXRpbC5fZXh0ZW5kKHt9LCBvcHRpb25zXylcbiAgb3B0aW9ucy5ub3Byb2Nlc3MgPSB0cnVlXG5cbiAgdmFyIGcgPSBuZXcgR2xvYihwYXR0ZXJuLCBvcHRpb25zKVxuICB2YXIgc2V0ID0gZy5taW5pbWF0Y2guc2V0XG4gIGlmIChzZXQubGVuZ3RoID4gMSlcbiAgICByZXR1cm4gdHJ1ZVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgc2V0WzBdLmxlbmd0aDsgaisrKSB7XG4gICAgaWYgKHR5cGVvZiBzZXRbMF1bal0gIT09ICdzdHJpbmcnKVxuICAgICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5nbG9iLkdsb2IgPSBHbG9iXG5pbmhlcml0cyhHbG9iLCBFRSlcbmZ1bmN0aW9uIEdsb2IgKHBhdHRlcm4sIG9wdGlvbnMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBudWxsXG4gIH1cblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnN5bmMpIHtcbiAgICBpZiAoY2IpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBwcm92aWRlZCB0byBzeW5jIGdsb2InKVxuICAgIHJldHVybiBuZXcgR2xvYlN5bmMocGF0dGVybiwgb3B0aW9ucylcbiAgfVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHbG9iKSlcbiAgICByZXR1cm4gbmV3IEdsb2IocGF0dGVybiwgb3B0aW9ucywgY2IpXG5cbiAgc2V0b3B0cyh0aGlzLCBwYXR0ZXJuLCBvcHRpb25zKVxuICB0aGlzLl9kaWRSZWFsUGF0aCA9IGZhbHNlXG5cbiAgLy8gcHJvY2VzcyBlYWNoIHBhdHRlcm4gaW4gdGhlIG1pbmltYXRjaCBzZXRcbiAgdmFyIG4gPSB0aGlzLm1pbmltYXRjaC5zZXQubGVuZ3RoXG5cbiAgLy8gVGhlIG1hdGNoZXMgYXJlIHN0b3JlZCBhcyB7PGZpbGVuYW1lPjogdHJ1ZSwuLi59IHNvIHRoYXRcbiAgLy8gZHVwbGljYXRlcyBhcmUgYXV0b21hZ2ljYWxseSBwcnVuZWQuXG4gIC8vIExhdGVyLCB3ZSBkbyBhbiBPYmplY3Qua2V5cygpIG9uIHRoZXNlLlxuICAvLyBLZWVwIHRoZW0gYXMgYSBsaXN0IHNvIHdlIGNhbiBmaWxsIGluIHdoZW4gbm9udWxsIGlzIHNldC5cbiAgdGhpcy5tYXRjaGVzID0gbmV3IEFycmF5KG4pXG5cbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb25jZShjYilcbiAgICB0aGlzLm9uKCdlcnJvcicsIGNiKVxuICAgIHRoaXMub24oJ2VuZCcsIGZ1bmN0aW9uIChtYXRjaGVzKSB7XG4gICAgICBjYihudWxsLCBtYXRjaGVzKVxuICAgIH0pXG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIG4gPSB0aGlzLm1pbmltYXRjaC5zZXQubGVuZ3RoXG4gIHRoaXMuX3Byb2Nlc3NpbmcgPSAwXG4gIHRoaXMubWF0Y2hlcyA9IG5ldyBBcnJheShuKVxuXG4gIHRoaXMuX2VtaXRRdWV1ZSA9IFtdXG4gIHRoaXMuX3Byb2Nlc3NRdWV1ZSA9IFtdXG4gIHRoaXMucGF1c2VkID0gZmFsc2VcblxuICBpZiAodGhpcy5ub3Byb2Nlc3MpXG4gICAgcmV0dXJuIHRoaXNcblxuICBpZiAobiA9PT0gMClcbiAgICByZXR1cm4gZG9uZSgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpICsrKSB7XG4gICAgdGhpcy5fcHJvY2Vzcyh0aGlzLm1pbmltYXRjaC5zZXRbaV0sIGksIGZhbHNlLCBkb25lKVxuICB9XG5cbiAgZnVuY3Rpb24gZG9uZSAoKSB7XG4gICAgLS1zZWxmLl9wcm9jZXNzaW5nXG4gICAgaWYgKHNlbGYuX3Byb2Nlc3NpbmcgPD0gMClcbiAgICAgIHNlbGYuX2ZpbmlzaCgpXG4gIH1cbn1cblxuR2xvYi5wcm90b3R5cGUuX2ZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBHbG9iKVxuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIGlmICh0aGlzLnJlYWxwYXRoICYmICF0aGlzLl9kaWRSZWFscGF0aClcbiAgICByZXR1cm4gdGhpcy5fcmVhbHBhdGgoKVxuXG4gIGNvbW1vbi5maW5pc2godGhpcylcbiAgdGhpcy5lbWl0KCdlbmQnLCB0aGlzLmZvdW5kKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcmVhbHBhdGggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kaWRSZWFscGF0aClcbiAgICByZXR1cm5cblxuICB0aGlzLl9kaWRSZWFscGF0aCA9IHRydWVcblxuICB2YXIgbiA9IHRoaXMubWF0Y2hlcy5sZW5ndGhcbiAgaWYgKG4gPT09IDApXG4gICAgcmV0dXJuIHRoaXMuX2ZpbmlzaCgpXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXRjaGVzLmxlbmd0aDsgaSsrKVxuICAgIHRoaXMuX3JlYWxwYXRoU2V0KGksIG5leHQpXG5cbiAgZnVuY3Rpb24gbmV4dCAoKSB7XG4gICAgaWYgKC0tbiA9PT0gMClcbiAgICAgIHNlbGYuX2ZpbmlzaCgpXG4gIH1cbn1cblxuR2xvYi5wcm90b3R5cGUuX3JlYWxwYXRoU2V0ID0gZnVuY3Rpb24gKGluZGV4LCBjYikge1xuICB2YXIgbWF0Y2hzZXQgPSB0aGlzLm1hdGNoZXNbaW5kZXhdXG4gIGlmICghbWF0Y2hzZXQpXG4gICAgcmV0dXJuIGNiKClcblxuICB2YXIgZm91bmQgPSBPYmplY3Qua2V5cyhtYXRjaHNldClcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBuID0gZm91bmQubGVuZ3RoXG5cbiAgaWYgKG4gPT09IDApXG4gICAgcmV0dXJuIGNiKClcblxuICB2YXIgc2V0ID0gdGhpcy5tYXRjaGVzW2luZGV4XSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgZm91bmQuZm9yRWFjaChmdW5jdGlvbiAocCwgaSkge1xuICAgIC8vIElmIHRoZXJlJ3MgYSBwcm9ibGVtIHdpdGggdGhlIHN0YXQsIHRoZW4gaXQgbWVhbnMgdGhhdFxuICAgIC8vIG9uZSBvciBtb3JlIG9mIHRoZSBsaW5rcyBpbiB0aGUgcmVhbHBhdGggY291bGRuJ3QgYmVcbiAgICAvLyByZXNvbHZlZC4gIGp1c3QgcmV0dXJuIHRoZSBhYnMgdmFsdWUgaW4gdGhhdCBjYXNlLlxuICAgIHAgPSBzZWxmLl9tYWtlQWJzKHApXG4gICAgZnMucmVhbHBhdGgocCwgc2VsZi5yZWFscGF0aENhY2hlLCBmdW5jdGlvbiAoZXIsIHJlYWwpIHtcbiAgICAgIGlmICghZXIpXG4gICAgICAgIHNldFtyZWFsXSA9IHRydWVcbiAgICAgIGVsc2UgaWYgKGVyLnN5c2NhbGwgPT09ICdzdGF0JylcbiAgICAgICAgc2V0W3BdID0gdHJ1ZVxuICAgICAgZWxzZVxuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXIpIC8vIHNyc2x5IHd0ZiByaWdodCBoZXJlXG5cbiAgICAgIGlmICgtLW4gPT09IDApIHtcbiAgICAgICAgc2VsZi5tYXRjaGVzW2luZGV4XSA9IHNldFxuICAgICAgICBjYigpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn1cblxuR2xvYi5wcm90b3R5cGUuX21hcmsgPSBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gY29tbW9uLm1hcmsodGhpcywgcClcbn1cblxuR2xvYi5wcm90b3R5cGUuX21ha2VBYnMgPSBmdW5jdGlvbiAoZikge1xuICByZXR1cm4gY29tbW9uLm1ha2VBYnModGhpcywgZilcbn1cblxuR2xvYi5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYWJvcnRlZCA9IHRydWVcbiAgdGhpcy5lbWl0KCdhYm9ydCcpXG59XG5cbkdsb2IucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMucGF1c2VkKSB7XG4gICAgdGhpcy5wYXVzZWQgPSB0cnVlXG4gICAgdGhpcy5lbWl0KCdwYXVzZScpXG4gIH1cbn1cblxuR2xvYi5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICB0aGlzLmVtaXQoJ3Jlc3VtZScpXG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuICAgIGlmICh0aGlzLl9lbWl0UXVldWUubGVuZ3RoKSB7XG4gICAgICB2YXIgZXEgPSB0aGlzLl9lbWl0UXVldWUuc2xpY2UoMClcbiAgICAgIHRoaXMuX2VtaXRRdWV1ZS5sZW5ndGggPSAwXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVxLmxlbmd0aDsgaSArKykge1xuICAgICAgICB2YXIgZSA9IGVxW2ldXG4gICAgICAgIHRoaXMuX2VtaXRNYXRjaChlWzBdLCBlWzFdKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5fcHJvY2Vzc1F1ZXVlLmxlbmd0aCkge1xuICAgICAgdmFyIHBxID0gdGhpcy5fcHJvY2Vzc1F1ZXVlLnNsaWNlKDApXG4gICAgICB0aGlzLl9wcm9jZXNzUXVldWUubGVuZ3RoID0gMFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcS5sZW5ndGg7IGkgKyspIHtcbiAgICAgICAgdmFyIHAgPSBwcVtpXVxuICAgICAgICB0aGlzLl9wcm9jZXNzaW5nLS1cbiAgICAgICAgdGhpcy5fcHJvY2VzcyhwWzBdLCBwWzFdLCBwWzJdLCBwWzNdKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcHJvY2VzcyA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpIHtcbiAgYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBHbG9iKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIGlmICh0aGlzLmFib3J0ZWQpXG4gICAgcmV0dXJuXG5cbiAgdGhpcy5fcHJvY2Vzc2luZysrXG4gIGlmICh0aGlzLnBhdXNlZCkge1xuICAgIHRoaXMuX3Byb2Nlc3NRdWV1ZS5wdXNoKFtwYXR0ZXJuLCBpbmRleCwgaW5HbG9iU3RhciwgY2JdKVxuICAgIHJldHVyblxuICB9XG5cbiAgLy9jb25zb2xlLmVycm9yKCdQUk9DRVNTICVkJywgdGhpcy5fcHJvY2Vzc2luZywgcGF0dGVybilcblxuICAvLyBHZXQgdGhlIGZpcnN0IFtuXSBwYXJ0cyBvZiBwYXR0ZXJuIHRoYXQgYXJlIGFsbCBzdHJpbmdzLlxuICB2YXIgbiA9IDBcbiAgd2hpbGUgKHR5cGVvZiBwYXR0ZXJuW25dID09PSAnc3RyaW5nJykge1xuICAgIG4gKytcbiAgfVxuICAvLyBub3cgbiBpcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG9uZSB0aGF0IGlzICpub3QqIGEgc3RyaW5nLlxuXG4gIC8vIHNlZSBpZiB0aGVyZSdzIGFueXRoaW5nIGVsc2VcbiAgdmFyIHByZWZpeFxuICBzd2l0Y2ggKG4pIHtcbiAgICAvLyBpZiBub3QsIHRoZW4gdGhpcyBpcyByYXRoZXIgc2ltcGxlXG4gICAgY2FzZSBwYXR0ZXJuLmxlbmd0aDpcbiAgICAgIHRoaXMuX3Byb2Nlc3NTaW1wbGUocGF0dGVybi5qb2luKCcvJyksIGluZGV4LCBjYilcbiAgICAgIHJldHVyblxuXG4gICAgY2FzZSAwOlxuICAgICAgLy8gcGF0dGVybiAqc3RhcnRzKiB3aXRoIHNvbWUgbm9uLXRyaXZpYWwgaXRlbS5cbiAgICAgIC8vIGdvaW5nIHRvIHJlYWRkaXIoY3dkKSwgYnV0IG5vdCBpbmNsdWRlIHRoZSBwcmVmaXggaW4gbWF0Y2hlcy5cbiAgICAgIHByZWZpeCA9IG51bGxcbiAgICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gcGF0dGVybiBoYXMgc29tZSBzdHJpbmcgYml0cyBpbiB0aGUgZnJvbnQuXG4gICAgICAvLyB3aGF0ZXZlciBpdCBzdGFydHMgd2l0aCwgd2hldGhlciB0aGF0J3MgJ2Fic29sdXRlJyBsaWtlIC9mb28vYmFyLFxuICAgICAgLy8gb3IgJ3JlbGF0aXZlJyBsaWtlICcuLi9iYXonXG4gICAgICBwcmVmaXggPSBwYXR0ZXJuLnNsaWNlKDAsIG4pLmpvaW4oJy8nKVxuICAgICAgYnJlYWtcbiAgfVxuXG4gIHZhciByZW1haW4gPSBwYXR0ZXJuLnNsaWNlKG4pXG5cbiAgLy8gZ2V0IHRoZSBsaXN0IG9mIGVudHJpZXMuXG4gIHZhciByZWFkXG4gIGlmIChwcmVmaXggPT09IG51bGwpXG4gICAgcmVhZCA9ICcuJ1xuICBlbHNlIGlmIChpc0Fic29sdXRlKHByZWZpeCkgfHwgaXNBYnNvbHV0ZShwYXR0ZXJuLmpvaW4oJy8nKSkpIHtcbiAgICBpZiAoIXByZWZpeCB8fCAhaXNBYnNvbHV0ZShwcmVmaXgpKVxuICAgICAgcHJlZml4ID0gJy8nICsgcHJlZml4XG4gICAgcmVhZCA9IHByZWZpeFxuICB9IGVsc2VcbiAgICByZWFkID0gcHJlZml4XG5cbiAgdmFyIGFicyA9IHRoaXMuX21ha2VBYnMocmVhZClcblxuICAvL2lmIGlnbm9yZWQsIHNraXAgX3Byb2Nlc3NpbmdcbiAgaWYgKGNoaWxkcmVuSWdub3JlZCh0aGlzLCByZWFkKSlcbiAgICByZXR1cm4gY2IoKVxuXG4gIHZhciBpc0dsb2JTdGFyID0gcmVtYWluWzBdID09PSBtaW5pbWF0Y2guR0xPQlNUQVJcbiAgaWYgKGlzR2xvYlN0YXIpXG4gICAgdGhpcy5fcHJvY2Vzc0dsb2JTdGFyKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyLCBjYilcbiAgZWxzZVxuICAgIHRoaXMuX3Byb2Nlc3NSZWFkZGlyKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyLCBjYilcbn1cblxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3NSZWFkZGlyID0gZnVuY3Rpb24gKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5fcmVhZGRpcihhYnMsIGluR2xvYlN0YXIsIGZ1bmN0aW9uIChlciwgZW50cmllcykge1xuICAgIHJldHVybiBzZWxmLl9wcm9jZXNzUmVhZGRpcjIocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGVudHJpZXMsIGNiKVxuICB9KVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcHJvY2Vzc1JlYWRkaXIyID0gZnVuY3Rpb24gKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyLCBlbnRyaWVzLCBjYikge1xuXG4gIC8vIGlmIHRoZSBhYnMgaXNuJ3QgYSBkaXIsIHRoZW4gbm90aGluZyBjYW4gbWF0Y2ghXG4gIGlmICghZW50cmllcylcbiAgICByZXR1cm4gY2IoKVxuXG4gIC8vIEl0IHdpbGwgb25seSBtYXRjaCBkb3QgZW50cmllcyBpZiBpdCBzdGFydHMgd2l0aCBhIGRvdCwgb3IgaWZcbiAgLy8gZG90IGlzIHNldC4gIFN0dWZmIGxpa2UgQCguZm9vfC5iYXIpIGlzbid0IGFsbG93ZWQuXG4gIHZhciBwbiA9IHJlbWFpblswXVxuICB2YXIgbmVnYXRlID0gISF0aGlzLm1pbmltYXRjaC5uZWdhdGVcbiAgdmFyIHJhd0dsb2IgPSBwbi5fZ2xvYlxuICB2YXIgZG90T2sgPSB0aGlzLmRvdCB8fCByYXdHbG9iLmNoYXJBdCgwKSA9PT0gJy4nXG5cbiAgdmFyIG1hdGNoZWRFbnRyaWVzID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGUgPSBlbnRyaWVzW2ldXG4gICAgaWYgKGUuY2hhckF0KDApICE9PSAnLicgfHwgZG90T2spIHtcbiAgICAgIHZhciBtXG4gICAgICBpZiAobmVnYXRlICYmICFwcmVmaXgpIHtcbiAgICAgICAgbSA9ICFlLm1hdGNoKHBuKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbSA9IGUubWF0Y2gocG4pXG4gICAgICB9XG4gICAgICBpZiAobSlcbiAgICAgICAgbWF0Y2hlZEVudHJpZXMucHVzaChlKVxuICAgIH1cbiAgfVxuXG4gIC8vY29uc29sZS5lcnJvcigncHJkMicsIHByZWZpeCwgZW50cmllcywgcmVtYWluWzBdLl9nbG9iLCBtYXRjaGVkRW50cmllcylcblxuICB2YXIgbGVuID0gbWF0Y2hlZEVudHJpZXMubGVuZ3RoXG4gIC8vIElmIHRoZXJlIGFyZSBubyBtYXRjaGVkIGVudHJpZXMsIHRoZW4gbm90aGluZyBtYXRjaGVzLlxuICBpZiAobGVuID09PSAwKVxuICAgIHJldHVybiBjYigpXG5cbiAgLy8gaWYgdGhpcyBpcyB0aGUgbGFzdCByZW1haW5pbmcgcGF0dGVybiBiaXQsIHRoZW4gbm8gbmVlZCBmb3JcbiAgLy8gYW4gYWRkaXRpb25hbCBzdGF0ICp1bmxlc3MqIHRoZSB1c2VyIGhhcyBzcGVjaWZpZWQgbWFyayBvclxuICAvLyBzdGF0IGV4cGxpY2l0bHkuICBXZSBrbm93IHRoZXkgZXhpc3QsIHNpbmNlIHJlYWRkaXIgcmV0dXJuZWRcbiAgLy8gdGhlbS5cblxuICBpZiAocmVtYWluLmxlbmd0aCA9PT0gMSAmJiAhdGhpcy5tYXJrICYmICF0aGlzLnN0YXQpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2hlc1tpbmRleF0pXG4gICAgICB0aGlzLm1hdGNoZXNbaW5kZXhdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKyspIHtcbiAgICAgIHZhciBlID0gbWF0Y2hlZEVudHJpZXNbaV1cbiAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgaWYgKHByZWZpeCAhPT0gJy8nKVxuICAgICAgICAgIGUgPSBwcmVmaXggKyAnLycgKyBlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlID0gcHJlZml4ICsgZVxuICAgICAgfVxuXG4gICAgICBpZiAoZS5jaGFyQXQoMCkgPT09ICcvJyAmJiAhdGhpcy5ub21vdW50KSB7XG4gICAgICAgIGUgPSBwYXRoLmpvaW4odGhpcy5yb290LCBlKVxuICAgICAgfVxuICAgICAgdGhpcy5fZW1pdE1hdGNoKGluZGV4LCBlKVxuICAgIH1cbiAgICAvLyBUaGlzIHdhcyB0aGUgbGFzdCBvbmUsIGFuZCBubyBzdGF0cyB3ZXJlIG5lZWRlZFxuICAgIHJldHVybiBjYigpXG4gIH1cblxuICAvLyBub3cgdGVzdCBhbGwgbWF0Y2hlZCBlbnRyaWVzIGFzIHN0YW5kLWlucyBmb3IgdGhhdCBwYXJ0XG4gIC8vIG9mIHRoZSBwYXR0ZXJuLlxuICByZW1haW4uc2hpZnQoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArKykge1xuICAgIHZhciBlID0gbWF0Y2hlZEVudHJpZXNbaV1cbiAgICB2YXIgbmV3UGF0dGVyblxuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgIGlmIChwcmVmaXggIT09ICcvJylcbiAgICAgICAgZSA9IHByZWZpeCArICcvJyArIGVcbiAgICAgIGVsc2VcbiAgICAgICAgZSA9IHByZWZpeCArIGVcbiAgICB9XG4gICAgdGhpcy5fcHJvY2VzcyhbZV0uY29uY2F0KHJlbWFpbiksIGluZGV4LCBpbkdsb2JTdGFyLCBjYilcbiAgfVxuICBjYigpXG59XG5cbkdsb2IucHJvdG90eXBlLl9lbWl0TWF0Y2ggPSBmdW5jdGlvbiAoaW5kZXgsIGUpIHtcbiAgaWYgKHRoaXMuYWJvcnRlZClcbiAgICByZXR1cm5cblxuICBpZiAodGhpcy5tYXRjaGVzW2luZGV4XVtlXSlcbiAgICByZXR1cm5cblxuICBpZiAoaXNJZ25vcmVkKHRoaXMsIGUpKVxuICAgIHJldHVyblxuXG4gIGlmICh0aGlzLnBhdXNlZCkge1xuICAgIHRoaXMuX2VtaXRRdWV1ZS5wdXNoKFtpbmRleCwgZV0pXG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhlKVxuXG4gIGlmICh0aGlzLm5vZGlyKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNhY2hlW2Fic11cbiAgICBpZiAoYyA9PT0gJ0RJUicgfHwgQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHRoaXMubWFyaylcbiAgICBlID0gdGhpcy5fbWFyayhlKVxuXG4gIHRoaXMubWF0Y2hlc1tpbmRleF1bZV0gPSB0cnVlXG5cbiAgdmFyIHN0ID0gdGhpcy5zdGF0Q2FjaGVbYWJzXVxuICBpZiAoc3QpXG4gICAgdGhpcy5lbWl0KCdzdGF0JywgZSwgc3QpXG5cbiAgdGhpcy5lbWl0KCdtYXRjaCcsIGUpXG59XG5cbkdsb2IucHJvdG90eXBlLl9yZWFkZGlySW5HbG9iU3RhciA9IGZ1bmN0aW9uIChhYnMsIGNiKSB7XG4gIGlmICh0aGlzLmFib3J0ZWQpXG4gICAgcmV0dXJuXG5cbiAgLy8gZm9sbG93IGFsbCBzeW1saW5rZWQgZGlyZWN0b3JpZXMgZm9yZXZlclxuICAvLyBqdXN0IHByb2NlZWQgYXMgaWYgdGhpcyBpcyBhIG5vbi1nbG9ic3RhciBzaXR1YXRpb25cbiAgaWYgKHRoaXMuZm9sbG93KVxuICAgIHJldHVybiB0aGlzLl9yZWFkZGlyKGFicywgZmFsc2UsIGNiKVxuXG4gIHZhciBsc3RhdGtleSA9ICdsc3RhdFxcMCcgKyBhYnNcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBsc3RhdGNiID0gaW5mbGlnaHQobHN0YXRrZXksIGxzdGF0Y2JfKVxuXG4gIGlmIChsc3RhdGNiKVxuICAgIGZzLmxzdGF0KGFicywgbHN0YXRjYilcblxuICBmdW5jdGlvbiBsc3RhdGNiXyAoZXIsIGxzdGF0KSB7XG4gICAgaWYgKGVyKVxuICAgICAgcmV0dXJuIGNiKClcblxuICAgIHZhciBpc1N5bSA9IGxzdGF0LmlzU3ltYm9saWNMaW5rKClcbiAgICBzZWxmLnN5bWxpbmtzW2Fic10gPSBpc1N5bVxuXG4gICAgLy8gSWYgaXQncyBub3QgYSBzeW1saW5rIG9yIGEgZGlyLCB0aGVuIGl0J3MgZGVmaW5pdGVseSBhIHJlZ3VsYXIgZmlsZS5cbiAgICAvLyBkb24ndCBib3RoZXIgZG9pbmcgYSByZWFkZGlyIGluIHRoYXQgY2FzZS5cbiAgICBpZiAoIWlzU3ltICYmICFsc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICBzZWxmLmNhY2hlW2Fic10gPSAnRklMRSdcbiAgICAgIGNiKClcbiAgICB9IGVsc2VcbiAgICAgIHNlbGYuX3JlYWRkaXIoYWJzLCBmYWxzZSwgY2IpXG4gIH1cbn1cblxuR2xvYi5wcm90b3R5cGUuX3JlYWRkaXIgPSBmdW5jdGlvbiAoYWJzLCBpbkdsb2JTdGFyLCBjYikge1xuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIGNiID0gaW5mbGlnaHQoJ3JlYWRkaXJcXDAnK2FicysnXFwwJytpbkdsb2JTdGFyLCBjYilcbiAgaWYgKCFjYilcbiAgICByZXR1cm5cblxuICAvL2NvbnNvbGUuZXJyb3IoJ1JEICVqICVqJywgK2luR2xvYlN0YXIsIGFicylcbiAgaWYgKGluR2xvYlN0YXIgJiYgIW93blByb3AodGhpcy5zeW1saW5rcywgYWJzKSlcbiAgICByZXR1cm4gdGhpcy5fcmVhZGRpckluR2xvYlN0YXIoYWJzLCBjYilcblxuICBpZiAob3duUHJvcCh0aGlzLmNhY2hlLCBhYnMpKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNhY2hlW2Fic11cbiAgICBpZiAoIWMgfHwgYyA9PT0gJ0ZJTEUnKVxuICAgICAgcmV0dXJuIGNiKClcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKVxuICAgICAgcmV0dXJuIGNiKG51bGwsIGMpXG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgZnMucmVhZGRpcihhYnMsIHJlYWRkaXJDYih0aGlzLCBhYnMsIGNiKSlcbn1cblxuZnVuY3Rpb24gcmVhZGRpckNiIChzZWxmLCBhYnMsIGNiKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZXIsIGVudHJpZXMpIHtcbiAgICBpZiAoZXIpXG4gICAgICBzZWxmLl9yZWFkZGlyRXJyb3IoYWJzLCBlciwgY2IpXG4gICAgZWxzZVxuICAgICAgc2VsZi5fcmVhZGRpckVudHJpZXMoYWJzLCBlbnRyaWVzLCBjYilcbiAgfVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcmVhZGRpckVudHJpZXMgPSBmdW5jdGlvbiAoYWJzLCBlbnRyaWVzLCBjYikge1xuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIC8vIGlmIHdlIGhhdmVuJ3QgYXNrZWQgdG8gc3RhdCBldmVyeXRoaW5nLCB0aGVuIGp1c3RcbiAgLy8gYXNzdW1lIHRoYXQgZXZlcnl0aGluZyBpbiB0aGVyZSBleGlzdHMsIHNvIHdlIGNhbiBhdm9pZFxuICAvLyBoYXZpbmcgdG8gc3RhdCBpdCBhIHNlY29uZCB0aW1lLlxuICBpZiAoIXRoaXMubWFyayAmJiAhdGhpcy5zdGF0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSArKykge1xuICAgICAgdmFyIGUgPSBlbnRyaWVzW2ldXG4gICAgICBpZiAoYWJzID09PSAnLycpXG4gICAgICAgIGUgPSBhYnMgKyBlXG4gICAgICBlbHNlXG4gICAgICAgIGUgPSBhYnMgKyAnLycgKyBlXG4gICAgICB0aGlzLmNhY2hlW2VdID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuY2FjaGVbYWJzXSA9IGVudHJpZXNcbiAgcmV0dXJuIGNiKG51bGwsIGVudHJpZXMpXG59XG5cbkdsb2IucHJvdG90eXBlLl9yZWFkZGlyRXJyb3IgPSBmdW5jdGlvbiAoZiwgZXIsIGNiKSB7XG4gIGlmICh0aGlzLmFib3J0ZWQpXG4gICAgcmV0dXJuXG5cbiAgLy8gaGFuZGxlIGVycm9ycywgYW5kIGNhY2hlIHRoZSBpbmZvcm1hdGlvblxuICBzd2l0Y2ggKGVyLmNvZGUpIHtcbiAgICBjYXNlICdFTk9UU1VQJzogLy8gaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdsb2IvaXNzdWVzLzIwNVxuICAgIGNhc2UgJ0VOT1RESVInOiAvLyB0b3RhbGx5IG5vcm1hbC4gbWVhbnMgaXQgKmRvZXMqIGV4aXN0LlxuICAgICAgdGhpcy5jYWNoZVt0aGlzLl9tYWtlQWJzKGYpXSA9ICdGSUxFJ1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgJ0VOT0VOVCc6IC8vIG5vdCB0ZXJyaWJseSB1bnVzdWFsXG4gICAgY2FzZSAnRUxPT1AnOlxuICAgIGNhc2UgJ0VOQU1FVE9PTE9ORyc6XG4gICAgY2FzZSAnVU5LTk9XTic6XG4gICAgICB0aGlzLmNhY2hlW3RoaXMuX21ha2VBYnMoZildID0gZmFsc2VcbiAgICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OiAvLyBzb21lIHVudXN1YWwgZXJyb3IuICBUcmVhdCBhcyBmYWlsdXJlLlxuICAgICAgdGhpcy5jYWNoZVt0aGlzLl9tYWtlQWJzKGYpXSA9IGZhbHNlXG4gICAgICBpZiAodGhpcy5zdHJpY3QpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgICAgICAvLyBJZiB0aGUgZXJyb3IgaXMgaGFuZGxlZCwgdGhlbiB3ZSBhYm9ydFxuICAgICAgICAvLyBpZiBub3QsIHdlIHRocmV3IG91dCBvZiBoZXJlXG4gICAgICAgIHRoaXMuYWJvcnQoKVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnNpbGVudClcbiAgICAgICAgY29uc29sZS5lcnJvcignZ2xvYiBlcnJvcicsIGVyKVxuICAgICAgYnJlYWtcbiAgfVxuXG4gIHJldHVybiBjYigpXG59XG5cbkdsb2IucHJvdG90eXBlLl9wcm9jZXNzR2xvYlN0YXIgPSBmdW5jdGlvbiAocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLl9yZWFkZGlyKGFicywgaW5HbG9iU3RhciwgZnVuY3Rpb24gKGVyLCBlbnRyaWVzKSB7XG4gICAgc2VsZi5fcHJvY2Vzc0dsb2JTdGFyMihwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgZW50cmllcywgY2IpXG4gIH0pXG59XG5cblxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3NHbG9iU3RhcjIgPSBmdW5jdGlvbiAocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGVudHJpZXMsIGNiKSB7XG4gIC8vY29uc29sZS5lcnJvcigncGdzMicsIHByZWZpeCwgcmVtYWluWzBdLCBlbnRyaWVzKVxuXG4gIC8vIG5vIGVudHJpZXMgbWVhbnMgbm90IGEgZGlyLCBzbyBpdCBjYW4gbmV2ZXIgaGF2ZSBtYXRjaGVzXG4gIC8vIGZvby50eHQvKiogZG9lc24ndCBtYXRjaCBmb28udHh0XG4gIGlmICghZW50cmllcylcbiAgICByZXR1cm4gY2IoKVxuXG4gIC8vIHRlc3Qgd2l0aG91dCB0aGUgZ2xvYnN0YXIsIGFuZCB3aXRoIGV2ZXJ5IGNoaWxkIGJvdGggYmVsb3dcbiAgLy8gYW5kIHJlcGxhY2luZyB0aGUgZ2xvYnN0YXIuXG4gIHZhciByZW1haW5XaXRob3V0R2xvYlN0YXIgPSByZW1haW4uc2xpY2UoMSlcbiAgdmFyIGdzcHJlZiA9IHByZWZpeCA/IFsgcHJlZml4IF0gOiBbXVxuICB2YXIgbm9HbG9iU3RhciA9IGdzcHJlZi5jb25jYXQocmVtYWluV2l0aG91dEdsb2JTdGFyKVxuXG4gIC8vIHRoZSBub0dsb2JTdGFyIHBhdHRlcm4gZXhpdHMgdGhlIGluR2xvYlN0YXIgc3RhdGVcbiAgdGhpcy5fcHJvY2Vzcyhub0dsb2JTdGFyLCBpbmRleCwgZmFsc2UsIGNiKVxuXG4gIHZhciBpc1N5bSA9IHRoaXMuc3ltbGlua3NbYWJzXVxuICB2YXIgbGVuID0gZW50cmllcy5sZW5ndGhcblxuICAvLyBJZiBpdCdzIGEgc3ltbGluaywgYW5kIHdlJ3JlIGluIGEgZ2xvYnN0YXIsIHRoZW4gc3RvcFxuICBpZiAoaXNTeW0gJiYgaW5HbG9iU3RhcilcbiAgICByZXR1cm4gY2IoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZSA9IGVudHJpZXNbaV1cbiAgICBpZiAoZS5jaGFyQXQoMCkgPT09ICcuJyAmJiAhdGhpcy5kb3QpXG4gICAgICBjb250aW51ZVxuXG4gICAgLy8gdGhlc2UgdHdvIGNhc2VzIGVudGVyIHRoZSBpbkdsb2JTdGFyIHN0YXRlXG4gICAgdmFyIGluc3RlYWQgPSBnc3ByZWYuY29uY2F0KGVudHJpZXNbaV0sIHJlbWFpbldpdGhvdXRHbG9iU3RhcilcbiAgICB0aGlzLl9wcm9jZXNzKGluc3RlYWQsIGluZGV4LCB0cnVlLCBjYilcblxuICAgIHZhciBiZWxvdyA9IGdzcHJlZi5jb25jYXQoZW50cmllc1tpXSwgcmVtYWluKVxuICAgIHRoaXMuX3Byb2Nlc3MoYmVsb3csIGluZGV4LCB0cnVlLCBjYilcbiAgfVxuXG4gIGNiKClcbn1cblxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3NTaW1wbGUgPSBmdW5jdGlvbiAocHJlZml4LCBpbmRleCwgY2IpIHtcbiAgLy8gWFhYIHJldmlldyB0aGlzLiAgU2hvdWxkbid0IGl0IGJlIGRvaW5nIHRoZSBtb3VudGluZyBldGNcbiAgLy8gYmVmb3JlIGRvaW5nIHN0YXQ/ICBraW5kYSB3ZWlyZD9cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX3N0YXQocHJlZml4LCBmdW5jdGlvbiAoZXIsIGV4aXN0cykge1xuICAgIHNlbGYuX3Byb2Nlc3NTaW1wbGUyKHByZWZpeCwgaW5kZXgsIGVyLCBleGlzdHMsIGNiKVxuICB9KVxufVxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3NTaW1wbGUyID0gZnVuY3Rpb24gKHByZWZpeCwgaW5kZXgsIGVyLCBleGlzdHMsIGNiKSB7XG5cbiAgLy9jb25zb2xlLmVycm9yKCdwczInLCBwcmVmaXgsIGV4aXN0cylcblxuICBpZiAoIXRoaXMubWF0Y2hlc1tpbmRleF0pXG4gICAgdGhpcy5tYXRjaGVzW2luZGV4XSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICAvLyBJZiBpdCBkb2Vzbid0IGV4aXN0LCB0aGVuIGp1c3QgbWFyayB0aGUgbGFjayBvZiByZXN1bHRzXG4gIGlmICghZXhpc3RzKVxuICAgIHJldHVybiBjYigpXG5cbiAgaWYgKHByZWZpeCAmJiBpc0Fic29sdXRlKHByZWZpeCkgJiYgIXRoaXMubm9tb3VudCkge1xuICAgIHZhciB0cmFpbCA9IC9bXFwvXFxcXF0kLy50ZXN0KHByZWZpeClcbiAgICBpZiAocHJlZml4LmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICBwcmVmaXggPSBwYXRoLmpvaW4odGhpcy5yb290LCBwcmVmaXgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeCA9IHBhdGgucmVzb2x2ZSh0aGlzLnJvb3QsIHByZWZpeClcbiAgICAgIGlmICh0cmFpbClcbiAgICAgICAgcHJlZml4ICs9ICcvJ1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKVxuICAgIHByZWZpeCA9IHByZWZpeC5yZXBsYWNlKC9cXFxcL2csICcvJylcblxuICAvLyBNYXJrIHRoaXMgYXMgYSBtYXRjaFxuICB0aGlzLl9lbWl0TWF0Y2goaW5kZXgsIHByZWZpeClcbiAgY2IoKVxufVxuXG4vLyBSZXR1cm5zIGVpdGhlciAnRElSJywgJ0ZJTEUnLCBvciBmYWxzZVxuR2xvYi5wcm90b3R5cGUuX3N0YXQgPSBmdW5jdGlvbiAoZiwgY2IpIHtcbiAgdmFyIGFicyA9IHRoaXMuX21ha2VBYnMoZilcbiAgdmFyIG5lZWREaXIgPSBmLnNsaWNlKC0xKSA9PT0gJy8nXG5cbiAgaWYgKGYubGVuZ3RoID4gdGhpcy5tYXhMZW5ndGgpXG4gICAgcmV0dXJuIGNiKClcblxuICBpZiAoIXRoaXMuc3RhdCAmJiBvd25Qcm9wKHRoaXMuY2FjaGUsIGFicykpIHtcbiAgICB2YXIgYyA9IHRoaXMuY2FjaGVbYWJzXVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpXG4gICAgICBjID0gJ0RJUidcblxuICAgIC8vIEl0IGV4aXN0cywgYnV0IG1heWJlIG5vdCBob3cgd2UgbmVlZCBpdFxuICAgIGlmICghbmVlZERpciB8fCBjID09PSAnRElSJylcbiAgICAgIHJldHVybiBjYihudWxsLCBjKVxuXG4gICAgaWYgKG5lZWREaXIgJiYgYyA9PT0gJ0ZJTEUnKVxuICAgICAgcmV0dXJuIGNiKClcblxuICAgIC8vIG90aGVyd2lzZSB3ZSBoYXZlIHRvIHN0YXQsIGJlY2F1c2UgbWF5YmUgYz10cnVlXG4gICAgLy8gaWYgd2Uga25vdyBpdCBleGlzdHMsIGJ1dCBub3Qgd2hhdCBpdCBpcy5cbiAgfVxuXG4gIHZhciBleGlzdHNcbiAgdmFyIHN0YXQgPSB0aGlzLnN0YXRDYWNoZVthYnNdXG4gIGlmIChzdGF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoc3RhdCA9PT0gZmFsc2UpXG4gICAgICByZXR1cm4gY2IobnVsbCwgc3RhdClcbiAgICBlbHNlIHtcbiAgICAgIHZhciB0eXBlID0gc3RhdC5pc0RpcmVjdG9yeSgpID8gJ0RJUicgOiAnRklMRSdcbiAgICAgIGlmIChuZWVkRGlyICYmIHR5cGUgPT09ICdGSUxFJylcbiAgICAgICAgcmV0dXJuIGNiKClcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHR5cGUsIHN0YXQpXG4gICAgfVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBzdGF0Y2IgPSBpbmZsaWdodCgnc3RhdFxcMCcgKyBhYnMsIGxzdGF0Y2JfKVxuICBpZiAoc3RhdGNiKVxuICAgIGZzLmxzdGF0KGFicywgc3RhdGNiKVxuXG4gIGZ1bmN0aW9uIGxzdGF0Y2JfIChlciwgbHN0YXQpIHtcbiAgICBpZiAobHN0YXQgJiYgbHN0YXQuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgLy8gSWYgaXQncyBhIHN5bWxpbmssIHRoZW4gdHJlYXQgaXQgYXMgdGhlIHRhcmdldCwgdW5sZXNzXG4gICAgICAvLyB0aGUgdGFyZ2V0IGRvZXMgbm90IGV4aXN0LCB0aGVuIHRyZWF0IGl0IGFzIGEgZmlsZS5cbiAgICAgIHJldHVybiBmcy5zdGF0KGFicywgZnVuY3Rpb24gKGVyLCBzdGF0KSB7XG4gICAgICAgIGlmIChlcilcbiAgICAgICAgICBzZWxmLl9zdGF0MihmLCBhYnMsIG51bGwsIGxzdGF0LCBjYilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNlbGYuX3N0YXQyKGYsIGFicywgZXIsIHN0YXQsIGNiKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5fc3RhdDIoZiwgYWJzLCBlciwgbHN0YXQsIGNiKVxuICAgIH1cbiAgfVxufVxuXG5HbG9iLnByb3RvdHlwZS5fc3RhdDIgPSBmdW5jdGlvbiAoZiwgYWJzLCBlciwgc3RhdCwgY2IpIHtcbiAgaWYgKGVyKSB7XG4gICAgdGhpcy5zdGF0Q2FjaGVbYWJzXSA9IGZhbHNlXG4gICAgcmV0dXJuIGNiKClcbiAgfVxuXG4gIHZhciBuZWVkRGlyID0gZi5zbGljZSgtMSkgPT09ICcvJ1xuICB0aGlzLnN0YXRDYWNoZVthYnNdID0gc3RhdFxuXG4gIGlmIChhYnMuc2xpY2UoLTEpID09PSAnLycgJiYgIXN0YXQuaXNEaXJlY3RvcnkoKSlcbiAgICByZXR1cm4gY2IobnVsbCwgZmFsc2UsIHN0YXQpXG5cbiAgdmFyIGMgPSBzdGF0LmlzRGlyZWN0b3J5KCkgPyAnRElSJyA6ICdGSUxFJ1xuICB0aGlzLmNhY2hlW2Fic10gPSB0aGlzLmNhY2hlW2Fic10gfHwgY1xuXG4gIGlmIChuZWVkRGlyICYmIGMgIT09ICdESVInKVxuICAgIHJldHVybiBjYigpXG5cbiAgcmV0dXJuIGNiKG51bGwsIGMsIHN0YXQpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/node_modules/glob/glob.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/node_modules/glob/sync.js":
/*!************************************************************!*\
  !*** ./node_modules/sc-istanbul/node_modules/glob/sync.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = globSync\nglobSync.GlobSync = GlobSync\n\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"(ssr)/./node_modules/minimatch/minimatch.js\")\nvar Minimatch = minimatch.Minimatch\nvar Glob = (__webpack_require__(/*! ./glob.js */ \"(ssr)/./node_modules/sc-istanbul/node_modules/glob/glob.js\").Glob)\nvar util = __webpack_require__(/*! util */ \"util\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar assert = __webpack_require__(/*! assert */ \"assert\")\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"(ssr)/./node_modules/path-is-absolute/index.js\")\nvar common = __webpack_require__(/*! ./common.js */ \"(ssr)/./node_modules/sc-istanbul/node_modules/glob/common.js\")\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar childrenIgnored = common.childrenIgnored\n\nfunction globSync (pattern, options) {\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  return new GlobSync(pattern, options).found\n}\n\nfunction GlobSync (pattern, options) {\n  if (!pattern)\n    throw new Error('must provide pattern')\n\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  if (!(this instanceof GlobSync))\n    return new GlobSync(pattern, options)\n\n  setopts(this, pattern, options)\n\n  if (this.noprocess)\n    return this\n\n  var n = this.minimatch.set.length\n  this.matches = new Array(n)\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false)\n  }\n  this._finish()\n}\n\nGlobSync.prototype._finish = function () {\n  assert(this instanceof GlobSync)\n  if (this.realpath) {\n    var self = this\n    this.matches.forEach(function (matchset, index) {\n      var set = self.matches[index] = Object.create(null)\n      for (var p in matchset) {\n        try {\n          p = self._makeAbs(p)\n          var real = fs.realpathSync(p, self.realpathCache)\n          set[real] = true\n        } catch (er) {\n          if (er.syscall === 'stat')\n            set[self._makeAbs(p)] = true\n          else\n            throw er\n        }\n      }\n    })\n  }\n  common.finish(this)\n}\n\n\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\n  assert(this instanceof GlobSync)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // See if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip processing\n  if (childrenIgnored(this, read))\n    return\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)\n}\n\n\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar)\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix.slice(-1) !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this.matches[index][e] = true\n    }\n    // This was the last one, and no stats were needed\n    return\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix)\n      newPattern = [prefix, e]\n    else\n      newPattern = [e]\n    this._process(newPattern.concat(remain), index, inGlobStar)\n  }\n}\n\n\nGlobSync.prototype._emitMatch = function (index, e) {\n  var abs = this._makeAbs(e)\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[this._makeAbs(e)]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n  if (this.stat)\n    this._stat(e)\n}\n\n\nGlobSync.prototype._readdirInGlobStar = function (abs) {\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false)\n\n  var entries\n  var lstat\n  var stat\n  try {\n    lstat = fs.lstatSync(abs)\n  } catch (er) {\n    // lstat failed, doesn't exist\n    return null\n  }\n\n  var isSym = lstat.isSymbolicLink()\n  this.symlinks[abs] = isSym\n\n  // If it's not a symlink or a dir, then it's definitely a regular file.\n  // don't bother doing a readdir in that case.\n  if (!isSym && !lstat.isDirectory())\n    this.cache[abs] = 'FILE'\n  else\n    entries = this._readdir(abs, false)\n\n  return entries\n}\n\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\n  var entries\n\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return null\n\n    if (Array.isArray(c))\n      return c\n  }\n\n  try {\n    return this._readdirEntries(abs, fs.readdirSync(abs))\n  } catch (er) {\n    this._readdirError(abs, er)\n    return null\n  }\n}\n\nGlobSync.prototype._readdirEntries = function (abs, entries) {\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n\n  // mark and cache dir-ness\n  return entries\n}\n\nGlobSync.prototype._readdirError = function (f, er) {\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      this.cache[this._makeAbs(f)] = 'FILE'\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict)\n        throw er\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n}\n\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n\n  var entries = this._readdir(abs, inGlobStar)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false)\n\n  var len = entries.length\n  var isSym = this.symlinks[abs]\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true)\n  }\n}\n\nGlobSync.prototype._processSimple = function (prefix, index) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var exists = this._stat(prefix)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this.matches[index][prefix] = true\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function (f) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return false\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return c\n\n    if (needDir && c === 'FILE')\n      return false\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (!stat) {\n    var lstat\n    try {\n      lstat = fs.lstatSync(abs)\n    } catch (er) {\n      return false\n    }\n\n    if (lstat.isSymbolicLink()) {\n      try {\n        stat = fs.statSync(abs)\n      } catch (er) {\n        stat = lstat\n      }\n    } else {\n      stat = lstat\n    }\n  }\n\n  this.statCache[abs] = stat\n\n  var c = stat.isDirectory() ? 'DIR' : 'FILE'\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c !== 'DIR')\n    return false\n\n  return c\n}\n\nGlobSync.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlobSync.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbm9kZV9tb2R1bGVzL2dsb2Ivc3luYy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBLFNBQVMsbUJBQU8sQ0FBQyxjQUFJO0FBQ3JCLGdCQUFnQixtQkFBTyxDQUFDLDhEQUFXO0FBQ25DO0FBQ0EsV0FBVyx5R0FBeUI7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsd0VBQWtCO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyxpRkFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbm9kZV9tb2R1bGVzL2dsb2Ivc3luYy5qcz84MmMyIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZ2xvYlN5bmNcbmdsb2JTeW5jLkdsb2JTeW5jID0gR2xvYlN5bmNcblxudmFyIGZzID0gcmVxdWlyZSgnZnMnKVxudmFyIG1pbmltYXRjaCA9IHJlcXVpcmUoJ21pbmltYXRjaCcpXG52YXIgTWluaW1hdGNoID0gbWluaW1hdGNoLk1pbmltYXRjaFxudmFyIEdsb2IgPSByZXF1aXJlKCcuL2dsb2IuanMnKS5HbG9iXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxudmFyIGlzQWJzb2x1dGUgPSByZXF1aXJlKCdwYXRoLWlzLWFic29sdXRlJylcbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbi5qcycpXG52YXIgYWxwaGFzb3J0ID0gY29tbW9uLmFscGhhc29ydFxudmFyIGFscGhhc29ydGkgPSBjb21tb24uYWxwaGFzb3J0aVxudmFyIHNldG9wdHMgPSBjb21tb24uc2V0b3B0c1xudmFyIG93blByb3AgPSBjb21tb24ub3duUHJvcFxudmFyIGNoaWxkcmVuSWdub3JlZCA9IGNvbW1vbi5jaGlsZHJlbklnbm9yZWRcblxuZnVuY3Rpb24gZ2xvYlN5bmMgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDMpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgcHJvdmlkZWQgdG8gc3luYyBnbG9iXFxuJytcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1nbG9iL2lzc3Vlcy8xNjcnKVxuXG4gIHJldHVybiBuZXcgR2xvYlN5bmMocGF0dGVybiwgb3B0aW9ucykuZm91bmRcbn1cblxuZnVuY3Rpb24gR2xvYlN5bmMgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKCFwYXR0ZXJuKVxuICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBwcm92aWRlIHBhdHRlcm4nKVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAzKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIHByb3ZpZGVkIHRvIHN5bmMgZ2xvYlxcbicrXG4gICAgICAgICAgICAgICAgICAgICAgICAnU2VlOiBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtZ2xvYi9pc3N1ZXMvMTY3JylcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgR2xvYlN5bmMpKVxuICAgIHJldHVybiBuZXcgR2xvYlN5bmMocGF0dGVybiwgb3B0aW9ucylcblxuICBzZXRvcHRzKHRoaXMsIHBhdHRlcm4sIG9wdGlvbnMpXG5cbiAgaWYgKHRoaXMubm9wcm9jZXNzKVxuICAgIHJldHVybiB0aGlzXG5cbiAgdmFyIG4gPSB0aGlzLm1pbmltYXRjaC5zZXQubGVuZ3RoXG4gIHRoaXMubWF0Y2hlcyA9IG5ldyBBcnJheShuKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkgKyspIHtcbiAgICB0aGlzLl9wcm9jZXNzKHRoaXMubWluaW1hdGNoLnNldFtpXSwgaSwgZmFsc2UpXG4gIH1cbiAgdGhpcy5fZmluaXNoKClcbn1cblxuR2xvYlN5bmMucHJvdG90eXBlLl9maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gIGFzc2VydCh0aGlzIGluc3RhbmNlb2YgR2xvYlN5bmMpXG4gIGlmICh0aGlzLnJlYWxwYXRoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgdGhpcy5tYXRjaGVzLmZvckVhY2goZnVuY3Rpb24gKG1hdGNoc2V0LCBpbmRleCkge1xuICAgICAgdmFyIHNldCA9IHNlbGYubWF0Y2hlc1tpbmRleF0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICBmb3IgKHZhciBwIGluIG1hdGNoc2V0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcCA9IHNlbGYuX21ha2VBYnMocClcbiAgICAgICAgICB2YXIgcmVhbCA9IGZzLnJlYWxwYXRoU3luYyhwLCBzZWxmLnJlYWxwYXRoQ2FjaGUpXG4gICAgICAgICAgc2V0W3JlYWxdID0gdHJ1ZVxuICAgICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICAgIGlmIChlci5zeXNjYWxsID09PSAnc3RhdCcpXG4gICAgICAgICAgICBzZXRbc2VsZi5fbWFrZUFicyhwKV0gPSB0cnVlXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgZXJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgY29tbW9uLmZpbmlzaCh0aGlzKVxufVxuXG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fcHJvY2VzcyA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBpbmRleCwgaW5HbG9iU3Rhcikge1xuICBhc3NlcnQodGhpcyBpbnN0YW5jZW9mIEdsb2JTeW5jKVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgW25dIHBhcnRzIG9mIHBhdHRlcm4gdGhhdCBhcmUgYWxsIHN0cmluZ3MuXG4gIHZhciBuID0gMFxuICB3aGlsZSAodHlwZW9mIHBhdHRlcm5bbl0gPT09ICdzdHJpbmcnKSB7XG4gICAgbiArK1xuICB9XG4gIC8vIG5vdyBuIGlzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgb25lIHRoYXQgaXMgKm5vdCogYSBzdHJpbmcuXG5cbiAgLy8gU2VlIGlmIHRoZXJlJ3MgYW55dGhpbmcgZWxzZVxuICB2YXIgcHJlZml4XG4gIHN3aXRjaCAobikge1xuICAgIC8vIGlmIG5vdCwgdGhlbiB0aGlzIGlzIHJhdGhlciBzaW1wbGVcbiAgICBjYXNlIHBhdHRlcm4ubGVuZ3RoOlxuICAgICAgdGhpcy5fcHJvY2Vzc1NpbXBsZShwYXR0ZXJuLmpvaW4oJy8nKSwgaW5kZXgpXG4gICAgICByZXR1cm5cblxuICAgIGNhc2UgMDpcbiAgICAgIC8vIHBhdHRlcm4gKnN0YXJ0cyogd2l0aCBzb21lIG5vbi10cml2aWFsIGl0ZW0uXG4gICAgICAvLyBnb2luZyB0byByZWFkZGlyKGN3ZCksIGJ1dCBub3QgaW5jbHVkZSB0aGUgcHJlZml4IGluIG1hdGNoZXMuXG4gICAgICBwcmVmaXggPSBudWxsXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIHBhdHRlcm4gaGFzIHNvbWUgc3RyaW5nIGJpdHMgaW4gdGhlIGZyb250LlxuICAgICAgLy8gd2hhdGV2ZXIgaXQgc3RhcnRzIHdpdGgsIHdoZXRoZXIgdGhhdCdzICdhYnNvbHV0ZScgbGlrZSAvZm9vL2JhcixcbiAgICAgIC8vIG9yICdyZWxhdGl2ZScgbGlrZSAnLi4vYmF6J1xuICAgICAgcHJlZml4ID0gcGF0dGVybi5zbGljZSgwLCBuKS5qb2luKCcvJylcbiAgICAgIGJyZWFrXG4gIH1cblxuICB2YXIgcmVtYWluID0gcGF0dGVybi5zbGljZShuKVxuXG4gIC8vIGdldCB0aGUgbGlzdCBvZiBlbnRyaWVzLlxuICB2YXIgcmVhZFxuICBpZiAocHJlZml4ID09PSBudWxsKVxuICAgIHJlYWQgPSAnLidcbiAgZWxzZSBpZiAoaXNBYnNvbHV0ZShwcmVmaXgpIHx8IGlzQWJzb2x1dGUocGF0dGVybi5qb2luKCcvJykpKSB7XG4gICAgaWYgKCFwcmVmaXggfHwgIWlzQWJzb2x1dGUocHJlZml4KSlcbiAgICAgIHByZWZpeCA9ICcvJyArIHByZWZpeFxuICAgIHJlYWQgPSBwcmVmaXhcbiAgfSBlbHNlXG4gICAgcmVhZCA9IHByZWZpeFxuXG4gIHZhciBhYnMgPSB0aGlzLl9tYWtlQWJzKHJlYWQpXG5cbiAgLy9pZiBpZ25vcmVkLCBza2lwIHByb2Nlc3NpbmdcbiAgaWYgKGNoaWxkcmVuSWdub3JlZCh0aGlzLCByZWFkKSlcbiAgICByZXR1cm5cblxuICB2YXIgaXNHbG9iU3RhciA9IHJlbWFpblswXSA9PT0gbWluaW1hdGNoLkdMT0JTVEFSXG4gIGlmIChpc0dsb2JTdGFyKVxuICAgIHRoaXMuX3Byb2Nlc3NHbG9iU3RhcihwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhcilcbiAgZWxzZVxuICAgIHRoaXMuX3Byb2Nlc3NSZWFkZGlyKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyKVxufVxuXG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fcHJvY2Vzc1JlYWRkaXIgPSBmdW5jdGlvbiAocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIpIHtcbiAgdmFyIGVudHJpZXMgPSB0aGlzLl9yZWFkZGlyKGFicywgaW5HbG9iU3RhcilcblxuICAvLyBpZiB0aGUgYWJzIGlzbid0IGEgZGlyLCB0aGVuIG5vdGhpbmcgY2FuIG1hdGNoIVxuICBpZiAoIWVudHJpZXMpXG4gICAgcmV0dXJuXG5cbiAgLy8gSXQgd2lsbCBvbmx5IG1hdGNoIGRvdCBlbnRyaWVzIGlmIGl0IHN0YXJ0cyB3aXRoIGEgZG90LCBvciBpZlxuICAvLyBkb3QgaXMgc2V0LiAgU3R1ZmYgbGlrZSBAKC5mb298LmJhcikgaXNuJ3QgYWxsb3dlZC5cbiAgdmFyIHBuID0gcmVtYWluWzBdXG4gIHZhciBuZWdhdGUgPSAhIXRoaXMubWluaW1hdGNoLm5lZ2F0ZVxuICB2YXIgcmF3R2xvYiA9IHBuLl9nbG9iXG4gIHZhciBkb3RPayA9IHRoaXMuZG90IHx8IHJhd0dsb2IuY2hhckF0KDApID09PSAnLidcblxuICB2YXIgbWF0Y2hlZEVudHJpZXMgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZSA9IGVudHJpZXNbaV1cbiAgICBpZiAoZS5jaGFyQXQoMCkgIT09ICcuJyB8fCBkb3RPaykge1xuICAgICAgdmFyIG1cbiAgICAgIGlmIChuZWdhdGUgJiYgIXByZWZpeCkge1xuICAgICAgICBtID0gIWUubWF0Y2gocG4pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtID0gZS5tYXRjaChwbilcbiAgICAgIH1cbiAgICAgIGlmIChtKVxuICAgICAgICBtYXRjaGVkRW50cmllcy5wdXNoKGUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGxlbiA9IG1hdGNoZWRFbnRyaWVzLmxlbmd0aFxuICAvLyBJZiB0aGVyZSBhcmUgbm8gbWF0Y2hlZCBlbnRyaWVzLCB0aGVuIG5vdGhpbmcgbWF0Y2hlcy5cbiAgaWYgKGxlbiA9PT0gMClcbiAgICByZXR1cm5cblxuICAvLyBpZiB0aGlzIGlzIHRoZSBsYXN0IHJlbWFpbmluZyBwYXR0ZXJuIGJpdCwgdGhlbiBubyBuZWVkIGZvclxuICAvLyBhbiBhZGRpdGlvbmFsIHN0YXQgKnVubGVzcyogdGhlIHVzZXIgaGFzIHNwZWNpZmllZCBtYXJrIG9yXG4gIC8vIHN0YXQgZXhwbGljaXRseS4gIFdlIGtub3cgdGhleSBleGlzdCwgc2luY2UgcmVhZGRpciByZXR1cm5lZFxuICAvLyB0aGVtLlxuXG4gIGlmIChyZW1haW4ubGVuZ3RoID09PSAxICYmICF0aGlzLm1hcmsgJiYgIXRoaXMuc3RhdCkge1xuICAgIGlmICghdGhpcy5tYXRjaGVzW2luZGV4XSlcbiAgICAgIHRoaXMubWF0Y2hlc1tpbmRleF0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArKykge1xuICAgICAgdmFyIGUgPSBtYXRjaGVkRW50cmllc1tpXVxuICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICBpZiAocHJlZml4LnNsaWNlKC0xKSAhPT0gJy8nKVxuICAgICAgICAgIGUgPSBwcmVmaXggKyAnLycgKyBlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlID0gcHJlZml4ICsgZVxuICAgICAgfVxuXG4gICAgICBpZiAoZS5jaGFyQXQoMCkgPT09ICcvJyAmJiAhdGhpcy5ub21vdW50KSB7XG4gICAgICAgIGUgPSBwYXRoLmpvaW4odGhpcy5yb290LCBlKVxuICAgICAgfVxuICAgICAgdGhpcy5tYXRjaGVzW2luZGV4XVtlXSA9IHRydWVcbiAgICB9XG4gICAgLy8gVGhpcyB3YXMgdGhlIGxhc3Qgb25lLCBhbmQgbm8gc3RhdHMgd2VyZSBuZWVkZWRcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIG5vdyB0ZXN0IGFsbCBtYXRjaGVkIGVudHJpZXMgYXMgc3RhbmQtaW5zIGZvciB0aGF0IHBhcnRcbiAgLy8gb2YgdGhlIHBhdHRlcm4uXG4gIHJlbWFpbi5zaGlmdCgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICsrKSB7XG4gICAgdmFyIGUgPSBtYXRjaGVkRW50cmllc1tpXVxuICAgIHZhciBuZXdQYXR0ZXJuXG4gICAgaWYgKHByZWZpeClcbiAgICAgIG5ld1BhdHRlcm4gPSBbcHJlZml4LCBlXVxuICAgIGVsc2VcbiAgICAgIG5ld1BhdHRlcm4gPSBbZV1cbiAgICB0aGlzLl9wcm9jZXNzKG5ld1BhdHRlcm4uY29uY2F0KHJlbWFpbiksIGluZGV4LCBpbkdsb2JTdGFyKVxuICB9XG59XG5cblxuR2xvYlN5bmMucHJvdG90eXBlLl9lbWl0TWF0Y2ggPSBmdW5jdGlvbiAoaW5kZXgsIGUpIHtcbiAgdmFyIGFicyA9IHRoaXMuX21ha2VBYnMoZSlcbiAgaWYgKHRoaXMubWFyaylcbiAgICBlID0gdGhpcy5fbWFyayhlKVxuXG4gIGlmICh0aGlzLm1hdGNoZXNbaW5kZXhdW2VdKVxuICAgIHJldHVyblxuXG4gIGlmICh0aGlzLm5vZGlyKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNhY2hlW3RoaXMuX21ha2VBYnMoZSldXG4gICAgaWYgKGMgPT09ICdESVInIHx8IEFycmF5LmlzQXJyYXkoYykpXG4gICAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXMubWF0Y2hlc1tpbmRleF1bZV0gPSB0cnVlXG4gIGlmICh0aGlzLnN0YXQpXG4gICAgdGhpcy5fc3RhdChlKVxufVxuXG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fcmVhZGRpckluR2xvYlN0YXIgPSBmdW5jdGlvbiAoYWJzKSB7XG4gIC8vIGZvbGxvdyBhbGwgc3ltbGlua2VkIGRpcmVjdG9yaWVzIGZvcmV2ZXJcbiAgLy8ganVzdCBwcm9jZWVkIGFzIGlmIHRoaXMgaXMgYSBub24tZ2xvYnN0YXIgc2l0dWF0aW9uXG4gIGlmICh0aGlzLmZvbGxvdylcbiAgICByZXR1cm4gdGhpcy5fcmVhZGRpcihhYnMsIGZhbHNlKVxuXG4gIHZhciBlbnRyaWVzXG4gIHZhciBsc3RhdFxuICB2YXIgc3RhdFxuICB0cnkge1xuICAgIGxzdGF0ID0gZnMubHN0YXRTeW5jKGFicylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICAvLyBsc3RhdCBmYWlsZWQsIGRvZXNuJ3QgZXhpc3RcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgdmFyIGlzU3ltID0gbHN0YXQuaXNTeW1ib2xpY0xpbmsoKVxuICB0aGlzLnN5bWxpbmtzW2Fic10gPSBpc1N5bVxuXG4gIC8vIElmIGl0J3Mgbm90IGEgc3ltbGluayBvciBhIGRpciwgdGhlbiBpdCdzIGRlZmluaXRlbHkgYSByZWd1bGFyIGZpbGUuXG4gIC8vIGRvbid0IGJvdGhlciBkb2luZyBhIHJlYWRkaXIgaW4gdGhhdCBjYXNlLlxuICBpZiAoIWlzU3ltICYmICFsc3RhdC5pc0RpcmVjdG9yeSgpKVxuICAgIHRoaXMuY2FjaGVbYWJzXSA9ICdGSUxFJ1xuICBlbHNlXG4gICAgZW50cmllcyA9IHRoaXMuX3JlYWRkaXIoYWJzLCBmYWxzZSlcblxuICByZXR1cm4gZW50cmllc1xufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3JlYWRkaXIgPSBmdW5jdGlvbiAoYWJzLCBpbkdsb2JTdGFyKSB7XG4gIHZhciBlbnRyaWVzXG5cbiAgaWYgKGluR2xvYlN0YXIgJiYgIW93blByb3AodGhpcy5zeW1saW5rcywgYWJzKSlcbiAgICByZXR1cm4gdGhpcy5fcmVhZGRpckluR2xvYlN0YXIoYWJzKVxuXG4gIGlmIChvd25Qcm9wKHRoaXMuY2FjaGUsIGFicykpIHtcbiAgICB2YXIgYyA9IHRoaXMuY2FjaGVbYWJzXVxuICAgIGlmICghYyB8fCBjID09PSAnRklMRScpXG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpXG4gICAgICByZXR1cm4gY1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGRpckVudHJpZXMoYWJzLCBmcy5yZWFkZGlyU3luYyhhYnMpKVxuICB9IGNhdGNoIChlcikge1xuICAgIHRoaXMuX3JlYWRkaXJFcnJvcihhYnMsIGVyKVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuR2xvYlN5bmMucHJvdG90eXBlLl9yZWFkZGlyRW50cmllcyA9IGZ1bmN0aW9uIChhYnMsIGVudHJpZXMpIHtcbiAgLy8gaWYgd2UgaGF2ZW4ndCBhc2tlZCB0byBzdGF0IGV2ZXJ5dGhpbmcsIHRoZW4ganVzdFxuICAvLyBhc3N1bWUgdGhhdCBldmVyeXRoaW5nIGluIHRoZXJlIGV4aXN0cywgc28gd2UgY2FuIGF2b2lkXG4gIC8vIGhhdmluZyB0byBzdGF0IGl0IGEgc2Vjb25kIHRpbWUuXG4gIGlmICghdGhpcy5tYXJrICYmICF0aGlzLnN0YXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpICsrKSB7XG4gICAgICB2YXIgZSA9IGVudHJpZXNbaV1cbiAgICAgIGlmIChhYnMgPT09ICcvJylcbiAgICAgICAgZSA9IGFicyArIGVcbiAgICAgIGVsc2VcbiAgICAgICAgZSA9IGFicyArICcvJyArIGVcbiAgICAgIHRoaXMuY2FjaGVbZV0gPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgdGhpcy5jYWNoZVthYnNdID0gZW50cmllc1xuXG4gIC8vIG1hcmsgYW5kIGNhY2hlIGRpci1uZXNzXG4gIHJldHVybiBlbnRyaWVzXG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fcmVhZGRpckVycm9yID0gZnVuY3Rpb24gKGYsIGVyKSB7XG4gIC8vIGhhbmRsZSBlcnJvcnMsIGFuZCBjYWNoZSB0aGUgaW5mb3JtYXRpb25cbiAgc3dpdGNoIChlci5jb2RlKSB7XG4gICAgY2FzZSAnRU5PVFNVUCc6IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1nbG9iL2lzc3Vlcy8yMDVcbiAgICBjYXNlICdFTk9URElSJzogLy8gdG90YWxseSBub3JtYWwuIG1lYW5zIGl0ICpkb2VzKiBleGlzdC5cbiAgICAgIHRoaXMuY2FjaGVbdGhpcy5fbWFrZUFicyhmKV0gPSAnRklMRSdcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdFTk9FTlQnOiAvLyBub3QgdGVycmlibHkgdW51c3VhbFxuICAgIGNhc2UgJ0VMT09QJzpcbiAgICBjYXNlICdFTkFNRVRPT0xPTkcnOlxuICAgIGNhc2UgJ1VOS05PV04nOlxuICAgICAgdGhpcy5jYWNoZVt0aGlzLl9tYWtlQWJzKGYpXSA9IGZhbHNlXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDogLy8gc29tZSB1bnVzdWFsIGVycm9yLiAgVHJlYXQgYXMgZmFpbHVyZS5cbiAgICAgIHRoaXMuY2FjaGVbdGhpcy5fbWFrZUFicyhmKV0gPSBmYWxzZVxuICAgICAgaWYgKHRoaXMuc3RyaWN0KVxuICAgICAgICB0aHJvdyBlclxuICAgICAgaWYgKCF0aGlzLnNpbGVudClcbiAgICAgICAgY29uc29sZS5lcnJvcignZ2xvYiBlcnJvcicsIGVyKVxuICAgICAgYnJlYWtcbiAgfVxufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3Byb2Nlc3NHbG9iU3RhciA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3Rhcikge1xuXG4gIHZhciBlbnRyaWVzID0gdGhpcy5fcmVhZGRpcihhYnMsIGluR2xvYlN0YXIpXG5cbiAgLy8gbm8gZW50cmllcyBtZWFucyBub3QgYSBkaXIsIHNvIGl0IGNhbiBuZXZlciBoYXZlIG1hdGNoZXNcbiAgLy8gZm9vLnR4dC8qKiBkb2Vzbid0IG1hdGNoIGZvby50eHRcbiAgaWYgKCFlbnRyaWVzKVxuICAgIHJldHVyblxuXG4gIC8vIHRlc3Qgd2l0aG91dCB0aGUgZ2xvYnN0YXIsIGFuZCB3aXRoIGV2ZXJ5IGNoaWxkIGJvdGggYmVsb3dcbiAgLy8gYW5kIHJlcGxhY2luZyB0aGUgZ2xvYnN0YXIuXG4gIHZhciByZW1haW5XaXRob3V0R2xvYlN0YXIgPSByZW1haW4uc2xpY2UoMSlcbiAgdmFyIGdzcHJlZiA9IHByZWZpeCA/IFsgcHJlZml4IF0gOiBbXVxuICB2YXIgbm9HbG9iU3RhciA9IGdzcHJlZi5jb25jYXQocmVtYWluV2l0aG91dEdsb2JTdGFyKVxuXG4gIC8vIHRoZSBub0dsb2JTdGFyIHBhdHRlcm4gZXhpdHMgdGhlIGluR2xvYlN0YXIgc3RhdGVcbiAgdGhpcy5fcHJvY2Vzcyhub0dsb2JTdGFyLCBpbmRleCwgZmFsc2UpXG5cbiAgdmFyIGxlbiA9IGVudHJpZXMubGVuZ3RoXG4gIHZhciBpc1N5bSA9IHRoaXMuc3ltbGlua3NbYWJzXVxuXG4gIC8vIElmIGl0J3MgYSBzeW1saW5rLCBhbmQgd2UncmUgaW4gYSBnbG9ic3RhciwgdGhlbiBzdG9wXG4gIGlmIChpc1N5bSAmJiBpbkdsb2JTdGFyKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZSA9IGVudHJpZXNbaV1cbiAgICBpZiAoZS5jaGFyQXQoMCkgPT09ICcuJyAmJiAhdGhpcy5kb3QpXG4gICAgICBjb250aW51ZVxuXG4gICAgLy8gdGhlc2UgdHdvIGNhc2VzIGVudGVyIHRoZSBpbkdsb2JTdGFyIHN0YXRlXG4gICAgdmFyIGluc3RlYWQgPSBnc3ByZWYuY29uY2F0KGVudHJpZXNbaV0sIHJlbWFpbldpdGhvdXRHbG9iU3RhcilcbiAgICB0aGlzLl9wcm9jZXNzKGluc3RlYWQsIGluZGV4LCB0cnVlKVxuXG4gICAgdmFyIGJlbG93ID0gZ3NwcmVmLmNvbmNhdChlbnRyaWVzW2ldLCByZW1haW4pXG4gICAgdGhpcy5fcHJvY2VzcyhiZWxvdywgaW5kZXgsIHRydWUpXG4gIH1cbn1cblxuR2xvYlN5bmMucHJvdG90eXBlLl9wcm9jZXNzU2ltcGxlID0gZnVuY3Rpb24gKHByZWZpeCwgaW5kZXgpIHtcbiAgLy8gWFhYIHJldmlldyB0aGlzLiAgU2hvdWxkbid0IGl0IGJlIGRvaW5nIHRoZSBtb3VudGluZyBldGNcbiAgLy8gYmVmb3JlIGRvaW5nIHN0YXQ/ICBraW5kYSB3ZWlyZD9cbiAgdmFyIGV4aXN0cyA9IHRoaXMuX3N0YXQocHJlZml4KVxuXG4gIGlmICghdGhpcy5tYXRjaGVzW2luZGV4XSlcbiAgICB0aGlzLm1hdGNoZXNbaW5kZXhdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIC8vIElmIGl0IGRvZXNuJ3QgZXhpc3QsIHRoZW4ganVzdCBtYXJrIHRoZSBsYWNrIG9mIHJlc3VsdHNcbiAgaWYgKCFleGlzdHMpXG4gICAgcmV0dXJuXG5cbiAgaWYgKHByZWZpeCAmJiBpc0Fic29sdXRlKHByZWZpeCkgJiYgIXRoaXMubm9tb3VudCkge1xuICAgIHZhciB0cmFpbCA9IC9bXFwvXFxcXF0kLy50ZXN0KHByZWZpeClcbiAgICBpZiAocHJlZml4LmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICBwcmVmaXggPSBwYXRoLmpvaW4odGhpcy5yb290LCBwcmVmaXgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeCA9IHBhdGgucmVzb2x2ZSh0aGlzLnJvb3QsIHByZWZpeClcbiAgICAgIGlmICh0cmFpbClcbiAgICAgICAgcHJlZml4ICs9ICcvJ1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKVxuICAgIHByZWZpeCA9IHByZWZpeC5yZXBsYWNlKC9cXFxcL2csICcvJylcblxuICAvLyBNYXJrIHRoaXMgYXMgYSBtYXRjaFxuICB0aGlzLm1hdGNoZXNbaW5kZXhdW3ByZWZpeF0gPSB0cnVlXG59XG5cbi8vIFJldHVybnMgZWl0aGVyICdESVInLCAnRklMRScsIG9yIGZhbHNlXG5HbG9iU3luYy5wcm90b3R5cGUuX3N0YXQgPSBmdW5jdGlvbiAoZikge1xuICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhmKVxuICB2YXIgbmVlZERpciA9IGYuc2xpY2UoLTEpID09PSAnLydcblxuICBpZiAoZi5sZW5ndGggPiB0aGlzLm1heExlbmd0aClcbiAgICByZXR1cm4gZmFsc2VcblxuICBpZiAoIXRoaXMuc3RhdCAmJiBvd25Qcm9wKHRoaXMuY2FjaGUsIGFicykpIHtcbiAgICB2YXIgYyA9IHRoaXMuY2FjaGVbYWJzXVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpXG4gICAgICBjID0gJ0RJUidcblxuICAgIC8vIEl0IGV4aXN0cywgYnV0IG1heWJlIG5vdCBob3cgd2UgbmVlZCBpdFxuICAgIGlmICghbmVlZERpciB8fCBjID09PSAnRElSJylcbiAgICAgIHJldHVybiBjXG5cbiAgICBpZiAobmVlZERpciAmJiBjID09PSAnRklMRScpXG4gICAgICByZXR1cm4gZmFsc2VcblxuICAgIC8vIG90aGVyd2lzZSB3ZSBoYXZlIHRvIHN0YXQsIGJlY2F1c2UgbWF5YmUgYz10cnVlXG4gICAgLy8gaWYgd2Uga25vdyBpdCBleGlzdHMsIGJ1dCBub3Qgd2hhdCBpdCBpcy5cbiAgfVxuXG4gIHZhciBleGlzdHNcbiAgdmFyIHN0YXQgPSB0aGlzLnN0YXRDYWNoZVthYnNdXG4gIGlmICghc3RhdCkge1xuICAgIHZhciBsc3RhdFxuICAgIHRyeSB7XG4gICAgICBsc3RhdCA9IGZzLmxzdGF0U3luYyhhYnMpXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChsc3RhdC5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGF0ID0gZnMuc3RhdFN5bmMoYWJzKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgc3RhdCA9IGxzdGF0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXQgPSBsc3RhdFxuICAgIH1cbiAgfVxuXG4gIHRoaXMuc3RhdENhY2hlW2Fic10gPSBzdGF0XG5cbiAgdmFyIGMgPSBzdGF0LmlzRGlyZWN0b3J5KCkgPyAnRElSJyA6ICdGSUxFJ1xuICB0aGlzLmNhY2hlW2Fic10gPSB0aGlzLmNhY2hlW2Fic10gfHwgY1xuXG4gIGlmIChuZWVkRGlyICYmIGMgIT09ICdESVInKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIHJldHVybiBjXG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fbWFyayA9IGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBjb21tb24ubWFyayh0aGlzLCBwKVxufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX21ha2VBYnMgPSBmdW5jdGlvbiAoZikge1xuICByZXR1cm4gY29tbW9uLm1ha2VBYnModGhpcywgZilcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/node_modules/glob/sync.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/node_modules/has-flag/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sc-istanbul/node_modules/has-flag/index.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function (flag, argv) {\n\targv = argv || process.argv;\n\n\tvar terminatorPos = argv.indexOf('--');\n\tvar prefix = /^--/.test(flag) ? '' : '--';\n\tvar pos = argv.indexOf(prefix + flag);\n\n\treturn pos !== -1 && (terminatorPos !== -1 ? pos < terminatorPos : true);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbm9kZV9tb2R1bGVzL2hhcy1mbGFnL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbm9kZV9tb2R1bGVzL2hhcy1mbGFnL2luZGV4LmpzPzE1YzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZmxhZywgYXJndikge1xuXHRhcmd2ID0gYXJndiB8fCBwcm9jZXNzLmFyZ3Y7XG5cblx0dmFyIHRlcm1pbmF0b3JQb3MgPSBhcmd2LmluZGV4T2YoJy0tJyk7XG5cdHZhciBwcmVmaXggPSAvXi0tLy50ZXN0KGZsYWcpID8gJycgOiAnLS0nO1xuXHR2YXIgcG9zID0gYXJndi5pbmRleE9mKHByZWZpeCArIGZsYWcpO1xuXG5cdHJldHVybiBwb3MgIT09IC0xICYmICh0ZXJtaW5hdG9yUG9zICE9PSAtMSA/IHBvcyA8IHRlcm1pbmF0b3JQb3MgOiB0cnVlKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/node_modules/has-flag/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sc-istanbul/node_modules/supports-color/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sc-istanbul/node_modules/supports-color/index.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar hasFlag = __webpack_require__(/*! has-flag */ \"(ssr)/./node_modules/sc-istanbul/node_modules/has-flag/index.js\");\n\nvar support = function (level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel: level,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n};\n\nvar supportLevel = (function () {\n\tif (hasFlag('no-color') ||\n\t\thasFlag('no-colors') ||\n\t\thasFlag('color=false')) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (hasFlag('color') ||\n\t\thasFlag('colors') ||\n\t\thasFlag('color=true') ||\n\t\thasFlag('color=always')) {\n\t\treturn 1;\n\t}\n\n\tif (process.stdout && !process.stdout.isTTY) {\n\t\treturn 0;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\treturn 1;\n\t}\n\n\tif ('CI' in process.env) {\n\t\tif ('TRAVIS' in process.env || process.env.CI === 'Travis') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif ('TEAMCITY_VERSION' in process.env) {\n\t\treturn process.env.TEAMCITY_VERSION.match(/^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/) === null ? 0 : 1;\n\t}\n\n\tif (/^(screen|xterm)-256(?:color)?/.test(process.env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in process.env) {\n\t\treturn 1;\n\t}\n\n\tif (process.env.TERM === 'dumb') {\n\t\treturn 0;\n\t}\n\n\treturn 0;\n})();\n\nif (supportLevel === 0 && 'FORCE_COLOR' in process.env) {\n\tsupportLevel = 1;\n}\n\nmodule.exports = process && support(supportLevel);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2MtaXN0YW5idWwvbm9kZV9tb2R1bGVzL3N1cHBvcnRzLWNvbG9yL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsY0FBYyxtQkFBTyxDQUFDLGlGQUFVOztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9FQUFvRSxHQUFHO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9zYy1pc3RhbmJ1bC9ub2RlX21vZHVsZXMvc3VwcG9ydHMtY29sb3IvaW5kZXguanM/ZjI3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgaGFzRmxhZyA9IHJlcXVpcmUoJ2hhcy1mbGFnJyk7XG5cbnZhciBzdXBwb3J0ID0gZnVuY3Rpb24gKGxldmVsKSB7XG5cdGlmIChsZXZlbCA9PT0gMCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0bGV2ZWw6IGxldmVsLFxuXHRcdGhhc0Jhc2ljOiB0cnVlLFxuXHRcdGhhczI1NjogbGV2ZWwgPj0gMixcblx0XHRoYXMxNm06IGxldmVsID49IDNcblx0fTtcbn07XG5cbnZhciBzdXBwb3J0TGV2ZWwgPSAoZnVuY3Rpb24gKCkge1xuXHRpZiAoaGFzRmxhZygnbm8tY29sb3InKSB8fFxuXHRcdGhhc0ZsYWcoJ25vLWNvbG9ycycpIHx8XG5cdFx0aGFzRmxhZygnY29sb3I9ZmFsc2UnKSkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0aWYgKGhhc0ZsYWcoJ2NvbG9yPTE2bScpIHx8XG5cdFx0aGFzRmxhZygnY29sb3I9ZnVsbCcpIHx8XG5cdFx0aGFzRmxhZygnY29sb3I9dHJ1ZWNvbG9yJykpIHtcblx0XHRyZXR1cm4gMztcblx0fVxuXG5cdGlmIChoYXNGbGFnKCdjb2xvcj0yNTYnKSkge1xuXHRcdHJldHVybiAyO1xuXHR9XG5cblx0aWYgKGhhc0ZsYWcoJ2NvbG9yJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcnMnKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPXRydWUnKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPWFsd2F5cycpKSB7XG5cdFx0cmV0dXJuIDE7XG5cdH1cblxuXHRpZiAocHJvY2Vzcy5zdGRvdXQgJiYgIXByb2Nlc3Muc3Rkb3V0LmlzVFRZKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuXHRcdHJldHVybiAxO1xuXHR9XG5cblx0aWYgKCdDSScgaW4gcHJvY2Vzcy5lbnYpIHtcblx0XHRpZiAoJ1RSQVZJUycgaW4gcHJvY2Vzcy5lbnYgfHwgcHJvY2Vzcy5lbnYuQ0kgPT09ICdUcmF2aXMnKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGlmICgnVEVBTUNJVFlfVkVSU0lPTicgaW4gcHJvY2Vzcy5lbnYpIHtcblx0XHRyZXR1cm4gcHJvY2Vzcy5lbnYuVEVBTUNJVFlfVkVSU0lPTi5tYXRjaCgvXig5XFwuKDAqWzEtOV1cXGQqKVxcLnxcXGR7Mix9XFwuKS8pID09PSBudWxsID8gMCA6IDE7XG5cdH1cblxuXHRpZiAoL14oc2NyZWVufHh0ZXJtKS0yNTYoPzpjb2xvcik/Ly50ZXN0KHByb2Nlc3MuZW52LlRFUk0pKSB7XG5cdFx0cmV0dXJuIDI7XG5cdH1cblxuXHRpZiAoL15zY3JlZW58Xnh0ZXJtfF52dDEwMHxjb2xvcnxhbnNpfGN5Z3dpbnxsaW51eC9pLnRlc3QocHJvY2Vzcy5lbnYuVEVSTSkpIHtcblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGlmICgnQ09MT1JURVJNJyBpbiBwcm9jZXNzLmVudikge1xuXHRcdHJldHVybiAxO1xuXHR9XG5cblx0aWYgKHByb2Nlc3MuZW52LlRFUk0gPT09ICdkdW1iJykge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0cmV0dXJuIDA7XG59KSgpO1xuXG5pZiAoc3VwcG9ydExldmVsID09PSAwICYmICdGT1JDRV9DT0xPUicgaW4gcHJvY2Vzcy5lbnYpIHtcblx0c3VwcG9ydExldmVsID0gMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzICYmIHN1cHBvcnQoc3VwcG9ydExldmVsKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sc-istanbul/node_modules/supports-color/index.js\n");

/***/ })

};
;