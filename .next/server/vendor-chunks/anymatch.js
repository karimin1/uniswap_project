"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/anymatch";
exports.ids = ["vendor-chunks/anymatch"];
exports.modules = {

/***/ "(ssr)/./node_modules/anymatch/index.js":
/*!****************************************!*\
  !*** ./node_modules/anymatch/index.js ***!
  \****************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nconst picomatch = __webpack_require__(/*! picomatch */ \"(ssr)/./node_modules/picomatch/index.js\");\nconst normalizePath = __webpack_require__(/*! normalize-path */ \"(ssr)/./node_modules/normalize-path/index.js\");\n\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\nconst BANG = '!';\nconst DEFAULT_OPTIONS = {returnIndex: false};\nconst arrify = (item) => Array.isArray(item) ? item : [item];\n\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return (string) => matcher === string || glob(string);\n  }\n  if (matcher instanceof RegExp) {\n    return (string) => matcher.test(string);\n  }\n  return (string) => false;\n};\n\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n  const _path = isList ? args[0] : args;\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' +\n      Object.prototype.toString.call(_path))\n  }\n  const path = normalizePath(_path, false);\n\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  const applied = isList && [path].concat(args.slice(1));\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\nconst anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;\n  const returnIndex = opts.returnIndex || false;\n\n  // Early cache for matchers.\n  const mtchers = arrify(matchers);\n  const negatedGlobs = mtchers\n    .filter(item => typeof item === 'string' && item.charAt(0) === BANG)\n    .map(item => item.slice(1))\n    .map(item => picomatch(item, opts));\n  const patterns = mtchers\n    .filter(item => typeof item !== 'string' || (typeof item === 'string' && item.charAt(0) !== BANG))\n    .map(matcher => createPattern(matcher, opts));\n\n  if (testString == null) {\n    return (testString, ri = false) => {\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    }\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch.default = anymatch;\nmodule.exports = anymatch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYW55bWF0Y2gvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxrQkFBa0IsbUJBQU8sQ0FBQywwREFBVztBQUNyQyxzQkFBc0IsbUJBQU8sQ0FBQyxvRUFBZ0I7O0FBRTlDO0FBQ0EsYUFBYSxpQ0FBaUM7QUFDOUMsYUFBYSwwQkFBMEI7QUFDdkMsYUFBYSxtQ0FBbUM7QUFDaEQ7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsY0FBYztBQUN6QixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msc0JBQXNCO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9hbnltYXRjaC9pbmRleC5qcz9kYjZiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5jb25zdCBwaWNvbWF0Y2ggPSByZXF1aXJlKCdwaWNvbWF0Y2gnKTtcbmNvbnN0IG5vcm1hbGl6ZVBhdGggPSByZXF1aXJlKCdub3JtYWxpemUtcGF0aCcpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsodGVzdFN0cmluZzogc3RyaW5nKSA9PiBib29sZWFufSBBbnltYXRjaEZuXG4gKiBAdHlwZWRlZiB7c3RyaW5nfFJlZ0V4cHxBbnltYXRjaEZufSBBbnltYXRjaFBhdHRlcm5cbiAqIEB0eXBlZGVmIHtBbnltYXRjaFBhdHRlcm58QW55bWF0Y2hQYXR0ZXJuW119IEFueW1hdGNoTWF0Y2hlclxuICovXG5jb25zdCBCQU5HID0gJyEnO1xuY29uc3QgREVGQVVMVF9PUFRJT05TID0ge3JldHVybkluZGV4OiBmYWxzZX07XG5jb25zdCBhcnJpZnkgPSAoaXRlbSkgPT4gQXJyYXkuaXNBcnJheShpdGVtKSA/IGl0ZW0gOiBbaXRlbV07XG5cbi8qKlxuICogQHBhcmFtIHtBbnltYXRjaFBhdHRlcm59IG1hdGNoZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7QW55bWF0Y2hGbn1cbiAqL1xuY29uc3QgY3JlYXRlUGF0dGVybiA9IChtYXRjaGVyLCBvcHRpb25zKSA9PiB7XG4gIGlmICh0eXBlb2YgbWF0Y2hlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXRjaGVyO1xuICB9XG4gIGlmICh0eXBlb2YgbWF0Y2hlciA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBnbG9iID0gcGljb21hdGNoKG1hdGNoZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiAoc3RyaW5nKSA9PiBtYXRjaGVyID09PSBzdHJpbmcgfHwgZ2xvYihzdHJpbmcpO1xuICB9XG4gIGlmIChtYXRjaGVyIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIChzdHJpbmcpID0+IG1hdGNoZXIudGVzdChzdHJpbmcpO1xuICB9XG4gIHJldHVybiAoc3RyaW5nKSA9PiBmYWxzZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxGdW5jdGlvbj59IHBhdHRlcm5zXG4gKiBAcGFyYW0ge0FycmF5PEZ1bmN0aW9uPn0gbmVnUGF0dGVybnNcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBhcmdzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJldHVybkluZGV4XG4gKiBAcmV0dXJucyB7Ym9vbGVhbnxudW1iZXJ9XG4gKi9cbmNvbnN0IG1hdGNoUGF0dGVybnMgPSAocGF0dGVybnMsIG5lZ1BhdHRlcm5zLCBhcmdzLCByZXR1cm5JbmRleCkgPT4ge1xuICBjb25zdCBpc0xpc3QgPSBBcnJheS5pc0FycmF5KGFyZ3MpO1xuICBjb25zdCBfcGF0aCA9IGlzTGlzdCA/IGFyZ3NbMF0gOiBhcmdzO1xuICBpZiAoIWlzTGlzdCAmJiB0eXBlb2YgX3BhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYW55bWF0Y2g6IHNlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nOiBnb3QgJyArXG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoX3BhdGgpKVxuICB9XG4gIGNvbnN0IHBhdGggPSBub3JtYWxpemVQYXRoKF9wYXRoLCBmYWxzZSk7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG5lZ1BhdHRlcm5zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IG5nbG9iID0gbmVnUGF0dGVybnNbaW5kZXhdO1xuICAgIGlmIChuZ2xvYihwYXRoKSkge1xuICAgICAgcmV0dXJuIHJldHVybkluZGV4ID8gLTEgOiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBhcHBsaWVkID0gaXNMaXN0ICYmIFtwYXRoXS5jb25jYXQoYXJncy5zbGljZSgxKSk7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwYXR0ZXJucy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBwYXR0ZXJuID0gcGF0dGVybnNbaW5kZXhdO1xuICAgIGlmIChpc0xpc3QgPyBwYXR0ZXJuKC4uLmFwcGxpZWQpIDogcGF0dGVybihwYXRoKSkge1xuICAgICAgcmV0dXJuIHJldHVybkluZGV4ID8gaW5kZXggOiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXR1cm5JbmRleCA/IC0xIDogZmFsc2U7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QW55bWF0Y2hNYXRjaGVyfSBtYXRjaGVyc1xuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHRlc3RTdHJpbmdcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7Ym9vbGVhbnxudW1iZXJ8RnVuY3Rpb259XG4gKi9cbmNvbnN0IGFueW1hdGNoID0gKG1hdGNoZXJzLCB0ZXN0U3RyaW5nLCBvcHRpb25zID0gREVGQVVMVF9PUFRJT05TKSA9PiB7XG4gIGlmIChtYXRjaGVycyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYW55bWF0Y2g6IHNwZWNpZnkgZmlyc3QgYXJndW1lbnQnKTtcbiAgfVxuICBjb25zdCBvcHRzID0gdHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJyA/IHtyZXR1cm5JbmRleDogb3B0aW9uc30gOiBvcHRpb25zO1xuICBjb25zdCByZXR1cm5JbmRleCA9IG9wdHMucmV0dXJuSW5kZXggfHwgZmFsc2U7XG5cbiAgLy8gRWFybHkgY2FjaGUgZm9yIG1hdGNoZXJzLlxuICBjb25zdCBtdGNoZXJzID0gYXJyaWZ5KG1hdGNoZXJzKTtcbiAgY29uc3QgbmVnYXRlZEdsb2JzID0gbXRjaGVyc1xuICAgIC5maWx0ZXIoaXRlbSA9PiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgJiYgaXRlbS5jaGFyQXQoMCkgPT09IEJBTkcpXG4gICAgLm1hcChpdGVtID0+IGl0ZW0uc2xpY2UoMSkpXG4gICAgLm1hcChpdGVtID0+IHBpY29tYXRjaChpdGVtLCBvcHRzKSk7XG4gIGNvbnN0IHBhdHRlcm5zID0gbXRjaGVyc1xuICAgIC5maWx0ZXIoaXRlbSA9PiB0eXBlb2YgaXRlbSAhPT0gJ3N0cmluZycgfHwgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJyAmJiBpdGVtLmNoYXJBdCgwKSAhPT0gQkFORykpXG4gICAgLm1hcChtYXRjaGVyID0+IGNyZWF0ZVBhdHRlcm4obWF0Y2hlciwgb3B0cykpO1xuXG4gIGlmICh0ZXN0U3RyaW5nID09IG51bGwpIHtcbiAgICByZXR1cm4gKHRlc3RTdHJpbmcsIHJpID0gZmFsc2UpID0+IHtcbiAgICAgIGNvbnN0IHJldHVybkluZGV4ID0gdHlwZW9mIHJpID09PSAnYm9vbGVhbicgPyByaSA6IGZhbHNlO1xuICAgICAgcmV0dXJuIG1hdGNoUGF0dGVybnMocGF0dGVybnMsIG5lZ2F0ZWRHbG9icywgdGVzdFN0cmluZywgcmV0dXJuSW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaFBhdHRlcm5zKHBhdHRlcm5zLCBuZWdhdGVkR2xvYnMsIHRlc3RTdHJpbmcsIHJldHVybkluZGV4KTtcbn07XG5cbmFueW1hdGNoLmRlZmF1bHQgPSBhbnltYXRjaDtcbm1vZHVsZS5leHBvcnRzID0gYW55bWF0Y2g7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/anymatch/index.js\n");

/***/ })

};
;