"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/io-ts";
exports.ids = ["vendor-chunks/io-ts"];
exports.modules = {

/***/ "(ssr)/./node_modules/io-ts/es6/index.js":
/*!*****************************************!*\
  !*** ./node_modules/io-ts/es6/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnyArrayType: () => (/* binding */ AnyArrayType),\n/* harmony export */   AnyDictionaryType: () => (/* binding */ AnyDictionaryType),\n/* harmony export */   AnyType: () => (/* binding */ AnyType),\n/* harmony export */   Array: () => (/* binding */ UnknownArray),\n/* harmony export */   ArrayType: () => (/* binding */ ArrayType),\n/* harmony export */   BooleanType: () => (/* binding */ BooleanType),\n/* harmony export */   Dictionary: () => (/* binding */ Dictionary),\n/* harmony export */   DictionaryType: () => (/* binding */ DictionaryType),\n/* harmony export */   ExactType: () => (/* binding */ ExactType),\n/* harmony export */   Function: () => (/* binding */ Function),\n/* harmony export */   FunctionType: () => (/* binding */ FunctionType),\n/* harmony export */   Int: () => (/* binding */ Int),\n/* harmony export */   Integer: () => (/* binding */ Integer),\n/* harmony export */   InterfaceType: () => (/* binding */ InterfaceType),\n/* harmony export */   IntersectionType: () => (/* binding */ IntersectionType),\n/* harmony export */   KeyofType: () => (/* binding */ KeyofType),\n/* harmony export */   LiteralType: () => (/* binding */ LiteralType),\n/* harmony export */   NeverType: () => (/* binding */ NeverType),\n/* harmony export */   NullType: () => (/* binding */ NullType),\n/* harmony export */   NumberType: () => (/* binding */ NumberType),\n/* harmony export */   ObjectType: () => (/* binding */ ObjectType),\n/* harmony export */   PartialType: () => (/* binding */ PartialType),\n/* harmony export */   ReadonlyArrayType: () => (/* binding */ ReadonlyArrayType),\n/* harmony export */   ReadonlyType: () => (/* binding */ ReadonlyType),\n/* harmony export */   RecursiveType: () => (/* binding */ RecursiveType),\n/* harmony export */   RefinementType: () => (/* binding */ RefinementType),\n/* harmony export */   StrictType: () => (/* binding */ StrictType),\n/* harmony export */   StringType: () => (/* binding */ StringType),\n/* harmony export */   TaggedUnionType: () => (/* binding */ TaggedUnionType),\n/* harmony export */   TupleType: () => (/* binding */ TupleType),\n/* harmony export */   Type: () => (/* binding */ Type),\n/* harmony export */   UndefinedType: () => (/* binding */ UndefinedType),\n/* harmony export */   UnionType: () => (/* binding */ UnionType),\n/* harmony export */   UnknownArray: () => (/* binding */ UnknownArray),\n/* harmony export */   UnknownRecord: () => (/* binding */ UnknownRecord),\n/* harmony export */   UnknownType: () => (/* binding */ UnknownType),\n/* harmony export */   VoidType: () => (/* binding */ VoidType),\n/* harmony export */   alias: () => (/* binding */ alias),\n/* harmony export */   any: () => (/* binding */ any),\n/* harmony export */   appendContext: () => (/* binding */ appendContext),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   brand: () => (/* binding */ brand),\n/* harmony export */   clean: () => (/* binding */ clean),\n/* harmony export */   dictionary: () => (/* binding */ dictionary),\n/* harmony export */   emptyTags: () => (/* binding */ emptyTags),\n/* harmony export */   exact: () => (/* binding */ exact),\n/* harmony export */   failure: () => (/* binding */ failure),\n/* harmony export */   failures: () => (/* binding */ failures),\n/* harmony export */   getContextEntry: () => (/* binding */ getContextEntry),\n/* harmony export */   getDefaultContext: () => (/* binding */ getDefaultContext),\n/* harmony export */   getFunctionName: () => (/* binding */ getFunctionName),\n/* harmony export */   getIndex: () => (/* binding */ getIndex),\n/* harmony export */   getTags: () => (/* binding */ getTags),\n/* harmony export */   getValidationError: () => (/* binding */ getValidationError),\n/* harmony export */   identity: () => (/* binding */ identity),\n/* harmony export */   \"interface\": () => (/* binding */ type),\n/* harmony export */   intersection: () => (/* binding */ intersection),\n/* harmony export */   keyof: () => (/* binding */ keyof),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   never: () => (/* binding */ never),\n/* harmony export */   \"null\": () => (/* binding */ nullType),\n/* harmony export */   nullType: () => (/* binding */ nullType),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   object: () => (/* binding */ object),\n/* harmony export */   partial: () => (/* binding */ partial),\n/* harmony export */   readonly: () => (/* binding */ readonly),\n/* harmony export */   readonlyArray: () => (/* binding */ readonlyArray),\n/* harmony export */   record: () => (/* binding */ record),\n/* harmony export */   recursion: () => (/* binding */ recursion),\n/* harmony export */   refinement: () => (/* binding */ refinement),\n/* harmony export */   strict: () => (/* binding */ strict),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   success: () => (/* binding */ success),\n/* harmony export */   taggedUnion: () => (/* binding */ taggedUnion),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   undefined: () => (/* binding */ undefinedType),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   unknown: () => (/* binding */ unknown),\n/* harmony export */   \"void\": () => (/* binding */ voidType),\n/* harmony export */   voidType: () => (/* binding */ voidType)\n/* harmony export */ });\n/* harmony import */ var fp_ts_lib_Either__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fp-ts/lib/Either */ \"(ssr)/./node_modules/io-ts/node_modules/fp-ts/lib/Either.js\");\n/* harmony import */ var fp_ts_lib_Either__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fp_ts_lib_Either__WEBPACK_IMPORTED_MODULE_0__);\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n/**\n * @since 1.0.0\n */\nvar Type = /** @class */ (function () {\n    function Type(\n    /** a unique name for this codec */\n    name, \n    /** a custom type guard */\n    is, \n    /** succeeds if a value of type I can be decoded to a value of type A */\n    validate, \n    /** converts a value of type A to a value of type O */\n    encode) {\n        this.name = name;\n        this.is = is;\n        this.validate = validate;\n        this.encode = encode;\n        this.decode = this.decode.bind(this);\n    }\n    Type.prototype.pipe = function (ab, name) {\n        var _this = this;\n        if (name === void 0) { name = \"pipe(\" + this.name + \", \" + ab.name + \")\"; }\n        return new Type(name, ab.is, function (i, c) { return _this.validate(i, c).chain(function (a) { return ab.validate(a, c); }); }, this.encode === identity && ab.encode === identity ? identity : function (b) { return _this.encode(ab.encode(b)); });\n    };\n    Type.prototype.asDecoder = function () {\n        return this;\n    };\n    Type.prototype.asEncoder = function () {\n        return this;\n    };\n    /** a version of `validate` with a default context */\n    Type.prototype.decode = function (i) {\n        return this.validate(i, [{ key: '', type: this, actual: i }]);\n    };\n    return Type;\n}());\n\n/**\n * @since 1.0.0\n */\nvar identity = function (a) { return a; };\n/**\n * @since 1.0.0\n */\nvar getFunctionName = function (f) {\n    return f.displayName || f.name || \"<function\" + f.length + \">\";\n};\n/**\n * @since 1.0.0\n */\nvar getContextEntry = function (key, decoder) { return ({ key: key, type: decoder }); };\n/**\n * @since 1.0.0\n */\nvar appendContext = function (c, key, decoder, actual) {\n    var len = c.length;\n    var r = Array(len + 1);\n    for (var i = 0; i < len; i++) {\n        r[i] = c[i];\n    }\n    r[len] = { key: key, type: decoder, actual: actual };\n    return r;\n};\n/**\n * @since 1.0.0\n */\nvar failures = fp_ts_lib_Either__WEBPACK_IMPORTED_MODULE_0__.left;\n/**\n * @since 1.0.0\n */\nvar failure = function (value, context, message) {\n    return failures([{ value: value, context: context, message: message }]);\n};\n/**\n * @since 1.0.0\n */\nvar success = fp_ts_lib_Either__WEBPACK_IMPORTED_MODULE_0__.right;\nvar pushAll = function (xs, ys) {\n    var l = ys.length;\n    for (var i = 0; i < l; i++) {\n        xs.push(ys[i]);\n    }\n};\nvar getIsCodec = function (tag) { return function (codec) { return codec._tag === tag; }; };\nvar isUnknownCodec = getIsCodec('UnknownType');\n// tslint:disable-next-line: deprecation\nvar isAnyCodec = getIsCodec('AnyType');\nvar isInterfaceCodec = getIsCodec('InterfaceType');\nvar isPartialCodec = getIsCodec('PartialType');\n//\n// basic types\n//\n/**\n * @since 1.0.0\n */\nvar NullType = /** @class */ (function (_super) {\n    __extends(NullType, _super);\n    function NullType() {\n        var _this = _super.call(this, 'null', function (u) { return u === null; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        _this._tag = 'NullType';\n        return _this;\n    }\n    return NullType;\n}(Type));\n\n/**\n * @alias `null`\n * @since 1.0.0\n */\nvar nullType = new NullType();\n/**\n * @since 1.0.0\n */\nvar UndefinedType = /** @class */ (function (_super) {\n    __extends(UndefinedType, _super);\n    function UndefinedType() {\n        var _this = _super.call(this, 'undefined', function (u) { return u === void 0; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        _this._tag = 'UndefinedType';\n        return _this;\n    }\n    return UndefinedType;\n}(Type));\n\nvar undefinedType = new UndefinedType();\n/**\n * @since 1.2.0\n */\nvar VoidType = /** @class */ (function (_super) {\n    __extends(VoidType, _super);\n    function VoidType() {\n        var _this = _super.call(this, 'void', undefinedType.is, undefinedType.validate, identity) || this;\n        _this._tag = 'VoidType';\n        return _this;\n    }\n    return VoidType;\n}(Type));\n\n/**\n * @alias `void`\n * @since 1.2.0\n */\nvar voidType = new VoidType();\n/**\n * @since 1.5.0\n */\nvar UnknownType = /** @class */ (function (_super) {\n    __extends(UnknownType, _super);\n    function UnknownType() {\n        var _this = _super.call(this, 'unknown', function (_) { return true; }, success, identity) || this;\n        _this._tag = 'UnknownType';\n        return _this;\n    }\n    return UnknownType;\n}(Type));\n\n/**\n * @since 1.5.0\n */\nvar unknown = new UnknownType();\n/**\n * @since 1.0.0\n */\nvar StringType = /** @class */ (function (_super) {\n    __extends(StringType, _super);\n    function StringType() {\n        var _this = _super.call(this, 'string', function (u) { return typeof u === 'string'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        _this._tag = 'StringType';\n        return _this;\n    }\n    return StringType;\n}(Type));\n\n/**\n * @since 1.0.0\n */\nvar string = new StringType();\n/**\n * @since 1.0.0\n */\nvar NumberType = /** @class */ (function (_super) {\n    __extends(NumberType, _super);\n    function NumberType() {\n        var _this = _super.call(this, 'number', function (u) { return typeof u === 'number'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        _this._tag = 'NumberType';\n        return _this;\n    }\n    return NumberType;\n}(Type));\n\n/**\n * @since 1.0.0\n */\nvar number = new NumberType();\n/**\n * @since 1.0.0\n */\nvar BooleanType = /** @class */ (function (_super) {\n    __extends(BooleanType, _super);\n    function BooleanType() {\n        var _this = _super.call(this, 'boolean', function (u) { return typeof u === 'boolean'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        _this._tag = 'BooleanType';\n        return _this;\n    }\n    return BooleanType;\n}(Type));\n\n/**\n * @since 1.0.0\n */\nvar boolean = new BooleanType();\n/**\n * @since 1.0.0\n */\nvar AnyArrayType = /** @class */ (function (_super) {\n    __extends(AnyArrayType, _super);\n    function AnyArrayType() {\n        var _this = _super.call(this, 'UnknownArray', Array.isArray, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        _this._tag = 'AnyArrayType';\n        return _this;\n    }\n    return AnyArrayType;\n}(Type));\n\n/**\n * @since 1.7.1\n */\nvar UnknownArray = new AnyArrayType();\n/**\n * @since 1.0.0\n */\nvar AnyDictionaryType = /** @class */ (function (_super) {\n    __extends(AnyDictionaryType, _super);\n    function AnyDictionaryType() {\n        var _this = _super.call(this, 'UnknownRecord', function (u) { return u !== null && typeof u === 'object'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        _this._tag = 'AnyDictionaryType';\n        return _this;\n    }\n    return AnyDictionaryType;\n}(Type));\n\n/**\n * @since 1.7.1\n */\nvar UnknownRecord = new AnyDictionaryType();\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar FunctionType = /** @class */ (function (_super) {\n    __extends(FunctionType, _super);\n    function FunctionType() {\n        var _this = _super.call(this, 'Function', \n        // tslint:disable-next-line:strict-type-predicates\n        function (u) { return typeof u === 'function'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        _this._tag = 'FunctionType';\n        return _this;\n    }\n    return FunctionType;\n}(Type));\n\n/**\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nvar Function = new FunctionType();\n/**\n * @since 1.0.0\n */\nvar RefinementType = /** @class */ (function (_super) {\n    __extends(RefinementType, _super);\n    function RefinementType(name, is, validate, encode, type, predicate) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        _this.predicate = predicate;\n        _this._tag = 'RefinementType';\n        return _this;\n    }\n    return RefinementType;\n}(Type));\n\n/**\n * @since 1.8.1\n */\nvar brand = function (codec, predicate, name) {\n    // tslint:disable-next-line: deprecation\n    return refinement(codec, predicate, name);\n};\n/**\n * A branded codec representing an integer\n * @since 1.8.1\n */\nvar Int = brand(number, function (n) { return Number.isInteger(n); }, 'Int');\n/**\n * @since 1.0.0\n */\nvar LiteralType = /** @class */ (function (_super) {\n    __extends(LiteralType, _super);\n    function LiteralType(name, is, validate, encode, value) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.value = value;\n        _this._tag = 'LiteralType';\n        return _this;\n    }\n    return LiteralType;\n}(Type));\n\n/**\n * @since 1.0.0\n */\nvar literal = function (value, name) {\n    if (name === void 0) { name = JSON.stringify(value); }\n    var is = function (u) { return u === value; };\n    return new LiteralType(name, is, function (u, c) { return (is(u) ? success(value) : failure(u, c)); }, identity, value);\n};\n/**\n * @since 1.0.0\n */\nvar KeyofType = /** @class */ (function (_super) {\n    __extends(KeyofType, _super);\n    function KeyofType(name, is, validate, encode, keys) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.keys = keys;\n        _this._tag = 'KeyofType';\n        return _this;\n    }\n    return KeyofType;\n}(Type));\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * @since 1.0.0\n */\nvar keyof = function (keys, name) {\n    if (name === void 0) { name = Object.keys(keys)\n        .map(function (k) { return JSON.stringify(k); })\n        .join(' | '); }\n    var is = function (u) { return string.is(u) && hasOwnProperty.call(keys, u); };\n    return new KeyofType(name, is, function (u, c) { return (is(u) ? success(u) : failure(u, c)); }, identity, keys);\n};\n/**\n * @since 1.0.0\n */\nvar RecursiveType = /** @class */ (function (_super) {\n    __extends(RecursiveType, _super);\n    function RecursiveType(name, is, validate, encode, runDefinition) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.runDefinition = runDefinition;\n        _this._tag = 'RecursiveType';\n        return _this;\n    }\n    Object.defineProperty(RecursiveType.prototype, \"type\", {\n        get: function () {\n            return this.runDefinition();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return RecursiveType;\n}(Type));\n\n/**\n * @since 1.0.0\n */\nvar recursion = function (name, definition) {\n    var cache;\n    var runDefinition = function () {\n        if (!cache) {\n            cache = definition(Self);\n            cache.name = name;\n        }\n        return cache;\n    };\n    var Self = new RecursiveType(name, function (u) { return runDefinition().is(u); }, function (u, c) { return runDefinition().validate(u, c); }, function (a) { return runDefinition().encode(a); }, runDefinition);\n    return Self;\n};\n/**\n * @since 1.0.0\n */\nvar ArrayType = /** @class */ (function (_super) {\n    __extends(ArrayType, _super);\n    function ArrayType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        _this._tag = 'ArrayType';\n        return _this;\n    }\n    return ArrayType;\n}(Type));\n\n/**\n * @since 1.0.0\n */\nvar array = function (codec, name) {\n    if (name === void 0) { name = \"Array<\" + codec.name + \">\"; }\n    return new ArrayType(name, function (u) { return UnknownArray.is(u) && u.every(codec.is); }, function (u, c) {\n        return UnknownArray.validate(u, c).chain(function (us) {\n            var len = us.length;\n            var as = us;\n            var errors = [];\n            var _loop_1 = function (i) {\n                var ui = us[i];\n                codec.validate(ui, appendContext(c, String(i), codec, ui)).fold(function (e) { return pushAll(errors, e); }, function (ai) {\n                    if (ai !== ui) {\n                        if (as === us) {\n                            as = us.slice();\n                        }\n                        as[i] = ai;\n                    }\n                });\n            };\n            for (var i = 0; i < len; i++) {\n                _loop_1(i);\n            }\n            return errors.length > 0 ? failures(errors) : success(as);\n        });\n    }, codec.encode === identity ? identity : function (a) { return a.map(codec.encode); }, codec);\n};\n/**\n * @since 1.0.0\n */\nvar InterfaceType = /** @class */ (function (_super) {\n    __extends(InterfaceType, _super);\n    function InterfaceType(name, is, validate, encode, props) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.props = props;\n        _this._tag = 'InterfaceType';\n        return _this;\n    }\n    return InterfaceType;\n}(Type));\n\nvar getNameFromProps = function (props) {\n    return Object.keys(props)\n        .map(function (k) { return k + \": \" + props[k].name; })\n        .join(', ');\n};\nvar useIdentity = function (codecs) {\n    for (var i = 0; i < codecs.length; i++) {\n        if (codecs[i].encode !== identity) {\n            return false;\n        }\n    }\n    return true;\n};\nvar getInterfaceTypeName = function (props) {\n    return \"{ \" + getNameFromProps(props) + \" }\";\n};\n/**\n * @alias `interface`\n * @since 1.0.0\n */\nvar type = function (props, name) {\n    if (name === void 0) { name = getInterfaceTypeName(props); }\n    var keys = Object.keys(props);\n    var types = keys.map(function (key) { return props[key]; });\n    var len = keys.length;\n    return new InterfaceType(name, function (u) {\n        if (!UnknownRecord.is(u)) {\n            return false;\n        }\n        for (var i = 0; i < len; i++) {\n            var k = keys[i];\n            if (!hasOwnProperty.call(u, k) || !types[i].is(u[k])) {\n                return false;\n            }\n        }\n        return true;\n    }, function (u, c) {\n        return UnknownRecord.validate(u, c).chain(function (o) {\n            var a = o;\n            var errors = [];\n            var _loop_2 = function (i) {\n                var k = keys[i];\n                if (!hasOwnProperty.call(a, k)) {\n                    if (a === o) {\n                        a = __assign({}, o);\n                    }\n                    a[k] = a[k];\n                }\n                var ak = a[k];\n                var type_1 = types[i];\n                type_1.validate(ak, appendContext(c, k, type_1, ak)).fold(function (e) { return pushAll(errors, e); }, function (vak) {\n                    if (vak !== ak) {\n                        /* istanbul ignore next */\n                        if (a === o) {\n                            a = __assign({}, o);\n                        }\n                        a[k] = vak;\n                    }\n                });\n            };\n            for (var i = 0; i < len; i++) {\n                _loop_2(i);\n            }\n            return errors.length > 0 ? failures(errors) : success(a);\n        });\n    }, useIdentity(types)\n        ? identity\n        : function (a) {\n            var s = __assign({}, a);\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                var encode = types[i].encode;\n                if (encode !== identity) {\n                    s[k] = encode(a[k]);\n                }\n            }\n            return s;\n        }, props);\n};\n/**\n * @since 1.0.0\n */\nvar PartialType = /** @class */ (function (_super) {\n    __extends(PartialType, _super);\n    function PartialType(name, is, validate, encode, props) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.props = props;\n        _this._tag = 'PartialType';\n        return _this;\n    }\n    return PartialType;\n}(Type));\n\nvar getPartialTypeName = function (inner) {\n    return \"Partial<\" + inner + \">\";\n};\n/**\n * @since 1.0.0\n */\nvar partial = function (props, name) {\n    if (name === void 0) { name = getPartialTypeName(getInterfaceTypeName(props)); }\n    var keys = Object.keys(props);\n    var types = keys.map(function (key) { return props[key]; });\n    var len = keys.length;\n    return new PartialType(name, function (u) {\n        if (!UnknownRecord.is(u)) {\n            return false;\n        }\n        for (var i = 0; i < len; i++) {\n            var k = keys[i];\n            var uk = u[k];\n            if (uk !== undefined && !props[k].is(uk)) {\n                return false;\n            }\n        }\n        return true;\n    }, function (u, c) {\n        return UnknownRecord.validate(u, c).chain(function (o) {\n            var a = o;\n            var errors = [];\n            var _loop_3 = function (i) {\n                var k = keys[i];\n                var ak = a[k];\n                var type_2 = props[k];\n                type_2.validate(ak, appendContext(c, k, type_2, ak)).fold(function (e) {\n                    if (ak !== undefined) {\n                        pushAll(errors, e);\n                    }\n                }, function (vak) {\n                    if (vak !== ak) {\n                        /* istanbul ignore next */\n                        if (a === o) {\n                            a = __assign({}, o);\n                        }\n                        a[k] = vak;\n                    }\n                });\n            };\n            for (var i = 0; i < len; i++) {\n                _loop_3(i);\n            }\n            return errors.length > 0 ? failures(errors) : success(a);\n        });\n    }, useIdentity(types)\n        ? identity\n        : function (a) {\n            var s = __assign({}, a);\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                var ak = a[k];\n                if (ak !== undefined) {\n                    s[k] = types[i].encode(ak);\n                }\n            }\n            return s;\n        }, props);\n};\n/**\n * @since 1.0.0\n */\nvar DictionaryType = /** @class */ (function (_super) {\n    __extends(DictionaryType, _super);\n    function DictionaryType(name, is, validate, encode, domain, codomain) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.domain = domain;\n        _this.codomain = codomain;\n        _this._tag = 'DictionaryType';\n        return _this;\n    }\n    return DictionaryType;\n}(Type));\n\nvar isObject = function (r) { return Object.prototype.toString.call(r) === '[object Object]'; };\n/**\n * @since 1.7.1\n */\nvar record = function (domain, codomain, name) {\n    if (name === void 0) { name = \"{ [K in \" + domain.name + \"]: \" + codomain.name + \" }\"; }\n    return new DictionaryType(name, function (u) {\n        if (!UnknownRecord.is(u)) {\n            return false;\n        }\n        if (!isUnknownCodec(codomain) && !isAnyCodec(codomain) && !isObject(u)) {\n            return false;\n        }\n        return Object.keys(u).every(function (k) { return domain.is(k) && codomain.is(u[k]); });\n    }, function (u, c) {\n        return UnknownRecord.validate(u, c).chain(function (o) {\n            if (!isUnknownCodec(codomain) && !isAnyCodec(codomain) && !isObject(o)) {\n                return failure(u, c);\n            }\n            var a = {};\n            var errors = [];\n            var keys = Object.keys(o);\n            var len = keys.length;\n            var changed = false;\n            var _loop_4 = function (i) {\n                var k = keys[i];\n                var ok = o[k];\n                domain.validate(k, appendContext(c, k, domain, k)).fold(function (e) { return pushAll(errors, e); }, function (vk) {\n                    changed = changed || vk !== k;\n                    k = vk;\n                    codomain.validate(ok, appendContext(c, k, codomain, ok)).fold(function (e) { return pushAll(errors, e); }, function (vok) {\n                        changed = changed || vok !== ok;\n                        a[k] = vok;\n                    });\n                });\n            };\n            for (var i = 0; i < len; i++) {\n                _loop_4(i);\n            }\n            return errors.length > 0 ? failures(errors) : success((changed ? a : o));\n        });\n    }, domain.encode === identity && codomain.encode === identity\n        ? identity\n        : function (a) {\n            var s = {};\n            var keys = Object.keys(a);\n            var len = keys.length;\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                s[String(domain.encode(k))] = codomain.encode(a[k]);\n            }\n            return s;\n        }, domain, codomain);\n};\n/**\n * @since 1.0.0\n */\nvar UnionType = /** @class */ (function (_super) {\n    __extends(UnionType, _super);\n    function UnionType(name, is, validate, encode, types) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.types = types;\n        _this._tag = 'UnionType';\n        return _this;\n    }\n    return UnionType;\n}(Type));\n\nvar getUnionName = function (codecs) {\n    return '(' + codecs.map(function (type) { return type.name; }).join(' | ') + ')';\n};\n/**\n * @since 1.0.0\n */\nvar union = function (codecs, name) {\n    if (name === void 0) { name = getUnionName(codecs); }\n    var index = getIndex(codecs);\n    if (index !== undefined && codecs.length > 0) {\n        var tag_1 = index[0], groups_1 = index[1];\n        var len_1 = groups_1.length;\n        var find_1 = function (value) {\n            for (var i = 0; i < len_1; i++) {\n                if (groups_1[i].indexOf(value) !== -1) {\n                    return i;\n                }\n            }\n            return undefined;\n        };\n        // tslint:disable-next-line: deprecation\n        return new TaggedUnionType(name, function (u) {\n            if (!UnknownRecord.is(u)) {\n                return false;\n            }\n            var i = find_1(u[tag_1]);\n            return i !== undefined ? codecs[i].is(u) : false;\n        }, function (u, c) {\n            return UnknownRecord.validate(u, c).chain(function (r) {\n                var i = find_1(r[tag_1]);\n                if (i === undefined) {\n                    return failure(u, c);\n                }\n                var codec = codecs[i];\n                return codec.validate(r, appendContext(c, String(i), codec, r));\n            });\n        }, useIdentity(codecs)\n            ? identity\n            : function (a) {\n                var i = find_1(a[tag_1]);\n                if (i === undefined) {\n                    // https://github.com/gcanti/io-ts/pull/305\n                    throw new Error(\"no codec found to encode value in union codec \" + name);\n                }\n                else {\n                    return codecs[i].encode(a);\n                }\n            }, codecs, tag_1);\n    }\n    else {\n        return new UnionType(name, function (u) { return codecs.some(function (type) { return type.is(u); }); }, function (u, c) {\n            var errors = [];\n            for (var i = 0; i < codecs.length; i++) {\n                var codec = codecs[i];\n                var r = codec\n                    .validate(u, appendContext(c, String(i), codec, u))\n                    .fold(function (e) { return pushAll(errors, e); }, success);\n                if (r !== undefined) {\n                    return r;\n                }\n            }\n            return failures(errors);\n        }, useIdentity(codecs)\n            ? identity\n            : function (a) {\n                for (var _i = 0, codecs_1 = codecs; _i < codecs_1.length; _i++) {\n                    var codec = codecs_1[_i];\n                    if (codec.is(a)) {\n                        return codec.encode(a);\n                    }\n                }\n                // https://github.com/gcanti/io-ts/pull/305\n                throw new Error(\"no codec found to encode value in union type \" + name);\n            }, codecs);\n    }\n};\n/**\n * @since 1.0.0\n */\nvar IntersectionType = /** @class */ (function (_super) {\n    __extends(IntersectionType, _super);\n    function IntersectionType(name, is, validate, encode, types) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.types = types;\n        _this._tag = 'IntersectionType';\n        return _this;\n    }\n    return IntersectionType;\n}(Type));\n\nvar mergeAll = function (base, us) {\n    var r = base;\n    for (var i = 0; i < us.length; i++) {\n        var u = us[i];\n        if (u !== base) {\n            // `u` contains a prismatic value or is the result of a stripping combinator\n            if (r === base) {\n                r = Object.assign({}, u);\n                continue;\n            }\n            for (var k in u) {\n                if (u[k] !== base[k] || !r.hasOwnProperty(k)) {\n                    r[k] = u[k];\n                }\n            }\n        }\n    }\n    return r;\n};\nfunction intersection(codecs, name) {\n    if (name === void 0) { name = \"(\" + codecs.map(function (type) { return type.name; }).join(' & ') + \")\"; }\n    var len = codecs.length;\n    return new IntersectionType(name, function (u) { return codecs.every(function (type) { return type.is(u); }); }, codecs.length === 0\n        ? success\n        : function (u, c) {\n            var us = [];\n            var errors = [];\n            for (var i = 0; i < len; i++) {\n                var codec = codecs[i];\n                codec.validate(u, appendContext(c, String(i), codec, u)).fold(function (e) { return pushAll(errors, e); }, function (a) { return us.push(a); });\n            }\n            return errors.length > 0 ? failures(errors) : success(mergeAll(u, us));\n        }, codecs.length === 0 ? identity : function (a) { return mergeAll(a, codecs.map(function (codec) { return codec.encode(a); })); }, codecs);\n}\n/**\n * @since 1.0.0\n */\nvar TupleType = /** @class */ (function (_super) {\n    __extends(TupleType, _super);\n    function TupleType(name, is, validate, encode, types) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.types = types;\n        _this._tag = 'TupleType';\n        return _this;\n    }\n    return TupleType;\n}(Type));\n\nfunction tuple(codecs, name) {\n    if (name === void 0) { name = \"[\" + codecs.map(function (type) { return type.name; }).join(', ') + \"]\"; }\n    var len = codecs.length;\n    return new TupleType(name, function (u) { return UnknownArray.is(u) && u.length === len && codecs.every(function (type, i) { return type.is(u[i]); }); }, function (u, c) {\n        return UnknownArray.validate(u, c).chain(function (us) {\n            var as = us.length > len ? us.slice(0, len) : us; // strip additional components\n            var errors = [];\n            var _loop_5 = function (i) {\n                var a = us[i];\n                var type_3 = codecs[i];\n                type_3.validate(a, appendContext(c, String(i), type_3, a)).fold(function (e) { return pushAll(errors, e); }, function (va) {\n                    if (va !== a) {\n                        /* istanbul ignore next */\n                        if (as === us) {\n                            as = us.slice();\n                        }\n                        as[i] = va;\n                    }\n                });\n            };\n            for (var i = 0; i < len; i++) {\n                _loop_5(i);\n            }\n            return errors.length > 0 ? failures(errors) : success(as);\n        });\n    }, useIdentity(codecs) ? identity : function (a) { return codecs.map(function (type, i) { return type.encode(a[i]); }); }, codecs);\n}\n/**\n * @since 1.0.0\n */\nvar ReadonlyType = /** @class */ (function (_super) {\n    __extends(ReadonlyType, _super);\n    function ReadonlyType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        _this._tag = 'ReadonlyType';\n        return _this;\n    }\n    return ReadonlyType;\n}(Type));\n\n/**\n * @since 1.0.0\n */\nvar readonly = function (codec, name) {\n    if (name === void 0) { name = \"Readonly<\" + codec.name + \">\"; }\n    return new ReadonlyType(name, codec.is, function (u, c) {\n        return codec.validate(u, c).map(function (x) {\n            if (true) {\n                return Object.freeze(x);\n            }\n            return x;\n        });\n    }, codec.encode === identity ? identity : codec.encode, codec);\n};\n/**\n * @since 1.0.0\n */\nvar ReadonlyArrayType = /** @class */ (function (_super) {\n    __extends(ReadonlyArrayType, _super);\n    function ReadonlyArrayType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        _this._tag = 'ReadonlyArrayType';\n        return _this;\n    }\n    return ReadonlyArrayType;\n}(Type));\n\n/**\n * @since 1.0.0\n */\nvar readonlyArray = function (codec, name) {\n    if (name === void 0) { name = \"ReadonlyArray<\" + codec.name + \">\"; }\n    var arrayType = array(codec);\n    return new ReadonlyArrayType(name, arrayType.is, function (u, c) {\n        return arrayType.validate(u, c).map(function (x) {\n            if (true) {\n                return Object.freeze(x);\n            }\n            return x;\n        });\n    }, arrayType.encode, codec);\n};\n/**\n * Strips additional properties\n * @since 1.0.0\n */\nvar strict = function (props, name) {\n    return exact(type(props), name);\n};\n/**\n * @since 1.3.0\n * @deprecated\n */\nvar TaggedUnionType = /** @class */ (function (_super) {\n    __extends(TaggedUnionType, _super);\n    function TaggedUnionType(name, \n    // tslint:disable-next-line: deprecation\n    is, \n    // tslint:disable-next-line: deprecation\n    validate, \n    // tslint:disable-next-line: deprecation\n    encode, codecs, tag) {\n        var _this = _super.call(this, name, is, validate, encode, codecs) /* istanbul ignore next */ // <= workaround for https://github.com/Microsoft/TypeScript/issues/13455\n         || this;\n        _this.tag = tag;\n        return _this;\n    }\n    return TaggedUnionType;\n}(UnionType));\n\n/**\n * Use `union` instead\n *\n * @since 1.3.0\n * @deprecated\n */\nvar taggedUnion = function (tag, codecs, name\n// tslint:disable-next-line: deprecation\n) {\n    if (name === void 0) { name = getUnionName(codecs); }\n    var U = union(codecs, name);\n    // tslint:disable-next-line: deprecation\n    if (U instanceof TaggedUnionType) {\n        return U;\n    }\n    else {\n        console.warn(\"[io-ts] Cannot build a tagged union for \" + name + \", returning a de-optimized union\");\n        // tslint:disable-next-line: deprecation\n        return new TaggedUnionType(name, U.is, U.validate, U.encode, codecs, tag);\n    }\n};\n/**\n * @since 1.1.0\n */\nvar ExactType = /** @class */ (function (_super) {\n    __extends(ExactType, _super);\n    function ExactType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        _this._tag = 'ExactType';\n        return _this;\n    }\n    return ExactType;\n}(Type));\n\nvar getProps = function (codec) {\n    switch (codec._tag) {\n        case 'RefinementType':\n        case 'ReadonlyType':\n            return getProps(codec.type);\n        case 'InterfaceType':\n        case 'StrictType':\n        case 'PartialType':\n            return codec.props;\n        case 'IntersectionType':\n            return codec.types.reduce(function (props, type) { return Object.assign(props, getProps(type)); }, {});\n    }\n};\nvar stripKeys = function (o, props) {\n    var keys = Object.getOwnPropertyNames(o);\n    var shouldStrip = false;\n    var r = {};\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        if (!hasOwnProperty.call(props, key)) {\n            shouldStrip = true;\n        }\n        else {\n            r[key] = o[key];\n        }\n    }\n    return shouldStrip ? r : o;\n};\nvar getExactTypeName = function (codec) {\n    if (isInterfaceCodec(codec)) {\n        return \"{| \" + getNameFromProps(codec.props) + \" |}\";\n    }\n    else if (isPartialCodec(codec)) {\n        return getPartialTypeName(\"{| \" + getNameFromProps(codec.props) + \" |}\");\n    }\n    return \"Exact<\" + codec.name + \">\";\n};\n/**\n * Strips additional properties\n * @since 1.1.0\n */\nvar exact = function (codec, name) {\n    if (name === void 0) { name = getExactTypeName(codec); }\n    var props = getProps(codec);\n    return new ExactType(name, codec.is, function (u, c) {\n        return UnknownRecord.validate(u, c).chain(function () { return codec.validate(u, c).fold(fp_ts_lib_Either__WEBPACK_IMPORTED_MODULE_0__.left, function (a) { return success(stripKeys(a, props)); }); });\n    }, function (a) { return codec.encode(stripKeys(a, props)); }, codec);\n};\n\n\n/**\n * Use `UnknownArray` instead\n * @deprecated\n */\n\n/**\n * Use `type` instead\n * @deprecated\n */\n\n\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar getValidationError /* istanbul ignore next */ = function (value, context) { return ({\n    value: value,\n    context: context\n}); };\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar getDefaultContext /* istanbul ignore next */ = function (decoder) { return [\n    { key: '', type: decoder }\n]; };\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar NeverType = /** @class */ (function (_super) {\n    __extends(NeverType, _super);\n    function NeverType() {\n        var _this = _super.call(this, 'never', function (_) { return false; }, function (u, c) { return failure(u, c); }, \n        /* istanbul ignore next */\n        function () {\n            throw new Error('cannot encode never');\n        }) || this;\n        _this._tag = 'NeverType';\n        return _this;\n    }\n    return NeverType;\n}(Type));\n\n/**\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nvar never = new NeverType();\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar AnyType = /** @class */ (function (_super) {\n    __extends(AnyType, _super);\n    function AnyType() {\n        var _this = _super.call(this, 'any', function (_) { return true; }, success, identity) || this;\n        _this._tag = 'AnyType';\n        return _this;\n    }\n    return AnyType;\n}(Type));\n\n/**\n * Use `unknown` instead\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nvar any = new AnyType();\n/**\n * Use `UnknownRecord` instead\n * @since 1.0.0\n * @deprecated\n */\nvar Dictionary = UnknownRecord;\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar ObjectType = /** @class */ (function (_super) {\n    __extends(ObjectType, _super);\n    function ObjectType() {\n        var _this = _super.call(this, 'object', UnknownRecord.is, UnknownRecord.validate, identity) || this;\n        _this._tag = 'ObjectType';\n        return _this;\n    }\n    return ObjectType;\n}(Type));\n\n/**\n * Use `UnknownRecord` instead\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nvar object = new ObjectType();\n/**\n * Use `brand` instead\n * @since 1.0.0\n * @deprecated\n */\nfunction refinement(codec, predicate, name) {\n    if (name === void 0) { name = \"(\" + codec.name + \" | \" + getFunctionName(predicate) + \")\"; }\n    return new RefinementType(name, function (u) { return codec.is(u) && predicate(u); }, function (i, c) { return codec.validate(i, c).chain(function (a) { return (predicate(a) ? success(a) : failure(a, c)); }); }, codec.encode, codec, predicate);\n}\n/**\n * Use `Int` instead\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nvar Integer = refinement(number, Number.isInteger, 'Integer');\n/**\n * Use `record` instead\n * @since 1.0.0\n * @deprecated\n */\nvar dictionary = record;\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar StrictType = /** @class */ (function (_super) {\n    __extends(StrictType, _super);\n    function StrictType(name, \n    // tslint:disable-next-line: deprecation\n    is, \n    // tslint:disable-next-line: deprecation\n    validate, \n    // tslint:disable-next-line: deprecation\n    encode, props) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.props = props;\n        _this._tag = 'StrictType';\n        return _this;\n    }\n    return StrictType;\n}(Type));\n\n/**\n * Drops the codec \"kind\"\n * @since 1.1.0\n * @deprecated\n */\nfunction clean(codec) {\n    return codec;\n}\nfunction alias(codec) {\n    return function () { return codec; };\n}\nvar isNonEmpty = function (as) { return as.length > 0; };\n/**\n * @internal\n */\nvar emptyTags = {};\nfunction intersect(a, b) {\n    var r = [];\n    for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {\n        var v = a_1[_i];\n        if (b.indexOf(v) !== -1) {\n            r.push(v);\n        }\n    }\n    return r;\n}\nfunction mergeTags(a, b) {\n    if (a === emptyTags) {\n        return b;\n    }\n    if (b === emptyTags) {\n        return a;\n    }\n    var r = Object.assign({}, a);\n    for (var k in b) {\n        if (a.hasOwnProperty(k)) {\n            var intersection_1 = intersect(a[k], b[k]);\n            if (isNonEmpty(intersection_1)) {\n                r[k] = intersection_1;\n            }\n            else {\n                r = emptyTags;\n                break;\n            }\n        }\n        else {\n            r[k] = b[k];\n        }\n    }\n    return r;\n}\nfunction intersectTags(a, b) {\n    if (a === emptyTags || b === emptyTags) {\n        return emptyTags;\n    }\n    var r = emptyTags;\n    for (var k in a) {\n        if (b.hasOwnProperty(k)) {\n            var intersection_2 = intersect(a[k], b[k]);\n            if (intersection_2.length === 0) {\n                if (r === emptyTags) {\n                    r = {};\n                }\n                r[k] = a[k].concat(b[k]);\n            }\n        }\n    }\n    return r;\n}\nfunction isLiteralC(codec) {\n    return codec._tag === 'LiteralType';\n}\nfunction isTypeC(codec) {\n    return codec._tag === 'InterfaceType';\n}\n// tslint:disable-next-line: deprecation\nfunction isStrictC(codec) {\n    return codec._tag === 'StrictType';\n}\nfunction isExactC(codec) {\n    return codec._tag === 'ExactType';\n}\n// tslint:disable-next-line: deprecation\nfunction isRefinementC(codec) {\n    return codec._tag === 'RefinementType';\n}\nfunction isIntersectionC(codec) {\n    return codec._tag === 'IntersectionType';\n}\nfunction isUnionC(codec) {\n    return codec._tag === 'UnionType';\n}\nfunction isRecursiveC(codec) {\n    return codec._tag === 'RecursiveType';\n}\nvar lazyCodec = null;\n/**\n * @internal\n */\nfunction getTags(codec) {\n    if (codec === lazyCodec) {\n        return emptyTags;\n    }\n    if (isTypeC(codec) || isStrictC(codec)) {\n        var index = emptyTags;\n        // tslint:disable-next-line: forin\n        for (var k in codec.props) {\n            var prop = codec.props[k];\n            if (isLiteralC(prop)) {\n                if (index === emptyTags) {\n                    index = {};\n                }\n                index[k] = [prop.value];\n            }\n        }\n        return index;\n    }\n    else if (isExactC(codec) || isRefinementC(codec)) {\n        return getTags(codec.type);\n    }\n    else if (isIntersectionC(codec)) {\n        return codec.types.reduce(function (tags, codec) { return mergeTags(tags, getTags(codec)); }, emptyTags);\n    }\n    else if (isUnionC(codec)) {\n        return codec.types.slice(1).reduce(function (tags, codec) { return intersectTags(tags, getTags(codec)); }, getTags(codec.types[0]));\n    }\n    else if (isRecursiveC(codec)) {\n        lazyCodec = codec;\n        var tags = getTags(codec.type);\n        lazyCodec = null;\n        return tags;\n    }\n    return emptyTags;\n}\n/**\n * @internal\n */\nfunction getIndex(codecs) {\n    var tags = getTags(codecs[0]);\n    var keys = Object.keys(tags);\n    var len = codecs.length;\n    var _loop_6 = function (k) {\n        var all = tags[k].slice();\n        var index = [tags[k]];\n        for (var i = 1; i < len; i++) {\n            var codec = codecs[i];\n            var ctags = getTags(codec);\n            var values = ctags[k];\n            // tslint:disable-next-line: strict-type-predicates\n            if (values === undefined) {\n                return \"continue-keys\";\n            }\n            else {\n                if (values.some(function (v) { return all.indexOf(v) !== -1; })) {\n                    return \"continue-keys\";\n                }\n                else {\n                    all.push.apply(all, values);\n                    index.push(values);\n                }\n            }\n        }\n        return { value: [k, index] };\n    };\n    keys: for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var k = keys_1[_i];\n        var state_1 = _loop_6(k);\n        if (typeof state_1 === \"object\")\n            return state_1.value;\n        switch (state_1) {\n            case \"continue-keys\": continue keys;\n        }\n    }\n    return undefined;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW8tdHMvZXM2L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3QjtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCxnQkFBZ0IsU0FBSSxJQUFJLFNBQUk7QUFDNUI7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQytDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQix1REFBdUQsaURBQWlELDJCQUEyQixJQUFJLGlGQUFpRixvQ0FBb0M7QUFDNVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdDQUFnQztBQUNuRTtBQUNBO0FBQ0EsQ0FBQztBQUNlO0FBQ2hCO0FBQ0E7QUFDQTtBQUNPLDhCQUE4QjtBQUNyQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnREFBZ0QsVUFBVSx5QkFBeUI7QUFDMUY7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZUFBZSxrREFBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDTztBQUNQLHVCQUF1QixrREFBa0Q7QUFD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K0MsK0JBQStCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSwwQ0FBMEMsb0JBQW9CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9pby10cy9lczYvaW5kZXguanM/ZjFiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5pbXBvcnQgeyBsZWZ0LCByaWdodCB9IGZyb20gJ2ZwLXRzL2xpYi9FaXRoZXInO1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xudmFyIFR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHlwZShcbiAgICAvKiogYSB1bmlxdWUgbmFtZSBmb3IgdGhpcyBjb2RlYyAqL1xuICAgIG5hbWUsIFxuICAgIC8qKiBhIGN1c3RvbSB0eXBlIGd1YXJkICovXG4gICAgaXMsIFxuICAgIC8qKiBzdWNjZWVkcyBpZiBhIHZhbHVlIG9mIHR5cGUgSSBjYW4gYmUgZGVjb2RlZCB0byBhIHZhbHVlIG9mIHR5cGUgQSAqL1xuICAgIHZhbGlkYXRlLCBcbiAgICAvKiogY29udmVydHMgYSB2YWx1ZSBvZiB0eXBlIEEgdG8gYSB2YWx1ZSBvZiB0eXBlIE8gKi9cbiAgICBlbmNvZGUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pcyA9IGlzO1xuICAgICAgICB0aGlzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG4gICAgICAgIHRoaXMuZW5jb2RlID0gZW5jb2RlO1xuICAgICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVjb2RlLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIFR5cGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoYWIsIG5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gXCJwaXBlKFwiICsgdGhpcy5uYW1lICsgXCIsIFwiICsgYWIubmFtZSArIFwiKVwiOyB9XG4gICAgICAgIHJldHVybiBuZXcgVHlwZShuYW1lLCBhYi5pcywgZnVuY3Rpb24gKGksIGMpIHsgcmV0dXJuIF90aGlzLnZhbGlkYXRlKGksIGMpLmNoYWluKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhYi52YWxpZGF0ZShhLCBjKTsgfSk7IH0sIHRoaXMuZW5jb2RlID09PSBpZGVudGl0eSAmJiBhYi5lbmNvZGUgPT09IGlkZW50aXR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbiAoYikgeyByZXR1cm4gX3RoaXMuZW5jb2RlKGFiLmVuY29kZShiKSk7IH0pO1xuICAgIH07XG4gICAgVHlwZS5wcm90b3R5cGUuYXNEZWNvZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR5cGUucHJvdG90eXBlLmFzRW5jb2RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogYSB2ZXJzaW9uIG9mIGB2YWxpZGF0ZWAgd2l0aCBhIGRlZmF1bHQgY29udGV4dCAqL1xuICAgIFR5cGUucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlKGksIFt7IGtleTogJycsIHR5cGU6IHRoaXMsIGFjdHVhbDogaSB9XSk7XG4gICAgfTtcbiAgICByZXR1cm4gVHlwZTtcbn0oKSk7XG5leHBvcnQgeyBUeXBlIH07XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG5leHBvcnQgdmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGE7IH07XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG5leHBvcnQgdmFyIGdldEZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGYuZGlzcGxheU5hbWUgfHwgZi5uYW1lIHx8IFwiPGZ1bmN0aW9uXCIgKyBmLmxlbmd0aCArIFwiPlwiO1xufTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydCB2YXIgZ2V0Q29udGV4dEVudHJ5ID0gZnVuY3Rpb24gKGtleSwgZGVjb2RlcikgeyByZXR1cm4gKHsga2V5OiBrZXksIHR5cGU6IGRlY29kZXIgfSk7IH07XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG5leHBvcnQgdmFyIGFwcGVuZENvbnRleHQgPSBmdW5jdGlvbiAoYywga2V5LCBkZWNvZGVyLCBhY3R1YWwpIHtcbiAgICB2YXIgbGVuID0gYy5sZW5ndGg7XG4gICAgdmFyIHIgPSBBcnJheShsZW4gKyAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJbaV0gPSBjW2ldO1xuICAgIH1cbiAgICByW2xlbl0gPSB7IGtleToga2V5LCB0eXBlOiBkZWNvZGVyLCBhY3R1YWw6IGFjdHVhbCB9O1xuICAgIHJldHVybiByO1xufTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydCB2YXIgZmFpbHVyZXMgPSBsZWZ0O1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xuZXhwb3J0IHZhciBmYWlsdXJlID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGZhaWx1cmVzKFt7IHZhbHVlOiB2YWx1ZSwgY29udGV4dDogY29udGV4dCwgbWVzc2FnZTogbWVzc2FnZSB9XSk7XG59O1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xuZXhwb3J0IHZhciBzdWNjZXNzID0gcmlnaHQ7XG52YXIgcHVzaEFsbCA9IGZ1bmN0aW9uICh4cywgeXMpIHtcbiAgICB2YXIgbCA9IHlzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICB4cy5wdXNoKHlzW2ldKTtcbiAgICB9XG59O1xudmFyIGdldElzQ29kZWMgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBmdW5jdGlvbiAoY29kZWMpIHsgcmV0dXJuIGNvZGVjLl90YWcgPT09IHRhZzsgfTsgfTtcbnZhciBpc1Vua25vd25Db2RlYyA9IGdldElzQ29kZWMoJ1Vua25vd25UeXBlJyk7XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGRlcHJlY2F0aW9uXG52YXIgaXNBbnlDb2RlYyA9IGdldElzQ29kZWMoJ0FueVR5cGUnKTtcbnZhciBpc0ludGVyZmFjZUNvZGVjID0gZ2V0SXNDb2RlYygnSW50ZXJmYWNlVHlwZScpO1xudmFyIGlzUGFydGlhbENvZGVjID0gZ2V0SXNDb2RlYygnUGFydGlhbFR5cGUnKTtcbi8vXG4vLyBiYXNpYyB0eXBlc1xuLy9cbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbnZhciBOdWxsVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTnVsbFR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTnVsbFR5cGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICdudWxsJywgZnVuY3Rpb24gKHUpIHsgcmV0dXJuIHUgPT09IG51bGw7IH0sIGZ1bmN0aW9uICh1LCBjKSB7IHJldHVybiAoX3RoaXMuaXModSkgPyBzdWNjZXNzKHUpIDogZmFpbHVyZSh1LCBjKSk7IH0sIGlkZW50aXR5KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fdGFnID0gJ051bGxUeXBlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTnVsbFR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydCB7IE51bGxUeXBlIH07XG4vKipcbiAqIEBhbGlhcyBgbnVsbGBcbiAqIEBzaW5jZSAxLjAuMFxuICovXG5leHBvcnQgdmFyIG51bGxUeXBlID0gbmV3IE51bGxUeXBlKCk7XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG52YXIgVW5kZWZpbmVkVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVW5kZWZpbmVkVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVbmRlZmluZWRUeXBlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAndW5kZWZpbmVkJywgZnVuY3Rpb24gKHUpIHsgcmV0dXJuIHUgPT09IHZvaWQgMDsgfSwgZnVuY3Rpb24gKHUsIGMpIHsgcmV0dXJuIChfdGhpcy5pcyh1KSA/IHN1Y2Nlc3ModSkgOiBmYWlsdXJlKHUsIGMpKTsgfSwgaWRlbnRpdHkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl90YWcgPSAnVW5kZWZpbmVkVHlwZSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFVuZGVmaW5lZFR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydCB7IFVuZGVmaW5lZFR5cGUgfTtcbnZhciB1bmRlZmluZWRUeXBlID0gbmV3IFVuZGVmaW5lZFR5cGUoKTtcbi8qKlxuICogQHNpbmNlIDEuMi4wXG4gKi9cbnZhciBWb2lkVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVm9pZFR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVm9pZFR5cGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICd2b2lkJywgdW5kZWZpbmVkVHlwZS5pcywgdW5kZWZpbmVkVHlwZS52YWxpZGF0ZSwgaWRlbnRpdHkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl90YWcgPSAnVm9pZFR5cGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBWb2lkVHlwZTtcbn0oVHlwZSkpO1xuZXhwb3J0IHsgVm9pZFR5cGUgfTtcbi8qKlxuICogQGFsaWFzIGB2b2lkYFxuICogQHNpbmNlIDEuMi4wXG4gKi9cbmV4cG9ydCB2YXIgdm9pZFR5cGUgPSBuZXcgVm9pZFR5cGUoKTtcbi8qKlxuICogQHNpbmNlIDEuNS4wXG4gKi9cbnZhciBVbmtub3duVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVW5rbm93blR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVW5rbm93blR5cGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICd1bmtub3duJywgZnVuY3Rpb24gKF8pIHsgcmV0dXJuIHRydWU7IH0sIHN1Y2Nlc3MsIGlkZW50aXR5KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fdGFnID0gJ1Vua25vd25UeXBlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVW5rbm93blR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydCB7IFVua25vd25UeXBlIH07XG4vKipcbiAqIEBzaW5jZSAxLjUuMFxuICovXG5leHBvcnQgdmFyIHVua25vd24gPSBuZXcgVW5rbm93blR5cGUoKTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbnZhciBTdHJpbmdUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdHJpbmdUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0cmluZ1R5cGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICdzdHJpbmcnLCBmdW5jdGlvbiAodSkgeyByZXR1cm4gdHlwZW9mIHUgPT09ICdzdHJpbmcnOyB9LCBmdW5jdGlvbiAodSwgYykgeyByZXR1cm4gKF90aGlzLmlzKHUpID8gc3VjY2Vzcyh1KSA6IGZhaWx1cmUodSwgYykpOyB9LCBpZGVudGl0eSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3RhZyA9ICdTdHJpbmdUeXBlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nVHlwZTtcbn0oVHlwZSkpO1xuZXhwb3J0IHsgU3RyaW5nVHlwZSB9O1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xuZXhwb3J0IHZhciBzdHJpbmcgPSBuZXcgU3RyaW5nVHlwZSgpO1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xudmFyIE51bWJlclR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE51bWJlclR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTnVtYmVyVHlwZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ251bWJlcicsIGZ1bmN0aW9uICh1KSB7IHJldHVybiB0eXBlb2YgdSA9PT0gJ251bWJlcic7IH0sIGZ1bmN0aW9uICh1LCBjKSB7IHJldHVybiAoX3RoaXMuaXModSkgPyBzdWNjZXNzKHUpIDogZmFpbHVyZSh1LCBjKSk7IH0sIGlkZW50aXR5KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fdGFnID0gJ051bWJlclR5cGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXJUeXBlO1xufShUeXBlKSk7XG5leHBvcnQgeyBOdW1iZXJUeXBlIH07XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG5leHBvcnQgdmFyIG51bWJlciA9IG5ldyBOdW1iZXJUeXBlKCk7XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG52YXIgQm9vbGVhblR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJvb2xlYW5UeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJvb2xlYW5UeXBlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAnYm9vbGVhbicsIGZ1bmN0aW9uICh1KSB7IHJldHVybiB0eXBlb2YgdSA9PT0gJ2Jvb2xlYW4nOyB9LCBmdW5jdGlvbiAodSwgYykgeyByZXR1cm4gKF90aGlzLmlzKHUpID8gc3VjY2Vzcyh1KSA6IGZhaWx1cmUodSwgYykpOyB9LCBpZGVudGl0eSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3RhZyA9ICdCb29sZWFuVHlwZSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJvb2xlYW5UeXBlO1xufShUeXBlKSk7XG5leHBvcnQgeyBCb29sZWFuVHlwZSB9O1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xuZXhwb3J0IHZhciBib29sZWFuID0gbmV3IEJvb2xlYW5UeXBlKCk7XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG52YXIgQW55QXJyYXlUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBbnlBcnJheVR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQW55QXJyYXlUeXBlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAnVW5rbm93bkFycmF5JywgQXJyYXkuaXNBcnJheSwgZnVuY3Rpb24gKHUsIGMpIHsgcmV0dXJuIChfdGhpcy5pcyh1KSA/IHN1Y2Nlc3ModSkgOiBmYWlsdXJlKHUsIGMpKTsgfSwgaWRlbnRpdHkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl90YWcgPSAnQW55QXJyYXlUeXBlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQW55QXJyYXlUeXBlO1xufShUeXBlKSk7XG5leHBvcnQgeyBBbnlBcnJheVR5cGUgfTtcbi8qKlxuICogQHNpbmNlIDEuNy4xXG4gKi9cbmV4cG9ydCB2YXIgVW5rbm93bkFycmF5ID0gbmV3IEFueUFycmF5VHlwZSgpO1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xudmFyIEFueURpY3Rpb25hcnlUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBbnlEaWN0aW9uYXJ5VHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBbnlEaWN0aW9uYXJ5VHlwZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ1Vua25vd25SZWNvcmQnLCBmdW5jdGlvbiAodSkgeyByZXR1cm4gdSAhPT0gbnVsbCAmJiB0eXBlb2YgdSA9PT0gJ29iamVjdCc7IH0sIGZ1bmN0aW9uICh1LCBjKSB7IHJldHVybiAoX3RoaXMuaXModSkgPyBzdWNjZXNzKHUpIDogZmFpbHVyZSh1LCBjKSk7IH0sIGlkZW50aXR5KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fdGFnID0gJ0FueURpY3Rpb25hcnlUeXBlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQW55RGljdGlvbmFyeVR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydCB7IEFueURpY3Rpb25hcnlUeXBlIH07XG4vKipcbiAqIEBzaW5jZSAxLjcuMVxuICovXG5leHBvcnQgdmFyIFVua25vd25SZWNvcmQgPSBuZXcgQW55RGljdGlvbmFyeVR5cGUoKTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG52YXIgRnVuY3Rpb25UeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGdW5jdGlvblR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnVuY3Rpb25UeXBlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAnRnVuY3Rpb24nLCBcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnN0cmljdC10eXBlLXByZWRpY2F0ZXNcbiAgICAgICAgZnVuY3Rpb24gKHUpIHsgcmV0dXJuIHR5cGVvZiB1ID09PSAnZnVuY3Rpb24nOyB9LCBmdW5jdGlvbiAodSwgYykgeyByZXR1cm4gKF90aGlzLmlzKHUpID8gc3VjY2Vzcyh1KSA6IGZhaWx1cmUodSwgYykpOyB9LCBpZGVudGl0eSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3RhZyA9ICdGdW5jdGlvblR5cGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBGdW5jdGlvblR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydCB7IEZ1bmN0aW9uVHlwZSB9O1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGVwcmVjYXRpb25cbmV4cG9ydCB2YXIgRnVuY3Rpb24gPSBuZXcgRnVuY3Rpb25UeXBlKCk7XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG52YXIgUmVmaW5lbWVudFR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlZmluZW1lbnRUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlZmluZW1lbnRUeXBlKG5hbWUsIGlzLCB2YWxpZGF0ZSwgZW5jb2RlLCB0eXBlLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgaXMsIHZhbGlkYXRlLCBlbmNvZGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICBfdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIF90aGlzLl90YWcgPSAnUmVmaW5lbWVudFR5cGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZWZpbmVtZW50VHlwZTtcbn0oVHlwZSkpO1xuZXhwb3J0IHsgUmVmaW5lbWVudFR5cGUgfTtcbi8qKlxuICogQHNpbmNlIDEuOC4xXG4gKi9cbmV4cG9ydCB2YXIgYnJhbmQgPSBmdW5jdGlvbiAoY29kZWMsIHByZWRpY2F0ZSwgbmFtZSkge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGVwcmVjYXRpb25cbiAgICByZXR1cm4gcmVmaW5lbWVudChjb2RlYywgcHJlZGljYXRlLCBuYW1lKTtcbn07XG4vKipcbiAqIEEgYnJhbmRlZCBjb2RlYyByZXByZXNlbnRpbmcgYW4gaW50ZWdlclxuICogQHNpbmNlIDEuOC4xXG4gKi9cbmV4cG9ydCB2YXIgSW50ID0gYnJhbmQobnVtYmVyLCBmdW5jdGlvbiAobikgeyByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihuKTsgfSwgJ0ludCcpO1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xudmFyIExpdGVyYWxUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaXRlcmFsVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaXRlcmFsVHlwZShuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgaXMsIHZhbGlkYXRlLCBlbmNvZGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIF90aGlzLl90YWcgPSAnTGl0ZXJhbFR5cGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBMaXRlcmFsVHlwZTtcbn0oVHlwZSkpO1xuZXhwb3J0IHsgTGl0ZXJhbFR5cGUgfTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydCB2YXIgbGl0ZXJhbCA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lID09PSB2b2lkIDApIHsgbmFtZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTsgfVxuICAgIHZhciBpcyA9IGZ1bmN0aW9uICh1KSB7IHJldHVybiB1ID09PSB2YWx1ZTsgfTtcbiAgICByZXR1cm4gbmV3IExpdGVyYWxUeXBlKG5hbWUsIGlzLCBmdW5jdGlvbiAodSwgYykgeyByZXR1cm4gKGlzKHUpID8gc3VjY2Vzcyh2YWx1ZSkgOiBmYWlsdXJlKHUsIGMpKTsgfSwgaWRlbnRpdHksIHZhbHVlKTtcbn07XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG52YXIgS2V5b2ZUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhLZXlvZlR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gS2V5b2ZUeXBlKG5hbWUsIGlzLCB2YWxpZGF0ZSwgZW5jb2RlLCBrZXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIGlzLCB2YWxpZGF0ZSwgZW5jb2RlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5rZXlzID0ga2V5cztcbiAgICAgICAgX3RoaXMuX3RhZyA9ICdLZXlvZlR5cGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBLZXlvZlR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydCB7IEtleW9mVHlwZSB9O1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydCB2YXIga2V5b2YgPSBmdW5jdGlvbiAoa2V5cywgbmFtZSkge1xuICAgIGlmIChuYW1lID09PSB2b2lkIDApIHsgbmFtZSA9IE9iamVjdC5rZXlzKGtleXMpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGspOyB9KVxuICAgICAgICAuam9pbignIHwgJyk7IH1cbiAgICB2YXIgaXMgPSBmdW5jdGlvbiAodSkgeyByZXR1cm4gc3RyaW5nLmlzKHUpICYmIGhhc093blByb3BlcnR5LmNhbGwoa2V5cywgdSk7IH07XG4gICAgcmV0dXJuIG5ldyBLZXlvZlR5cGUobmFtZSwgaXMsIGZ1bmN0aW9uICh1LCBjKSB7IHJldHVybiAoaXModSkgPyBzdWNjZXNzKHUpIDogZmFpbHVyZSh1LCBjKSk7IH0sIGlkZW50aXR5LCBrZXlzKTtcbn07XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG52YXIgUmVjdXJzaXZlVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVjdXJzaXZlVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWN1cnNpdmVUeXBlKG5hbWUsIGlzLCB2YWxpZGF0ZSwgZW5jb2RlLCBydW5EZWZpbml0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIGlzLCB2YWxpZGF0ZSwgZW5jb2RlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5ydW5EZWZpbml0aW9uID0gcnVuRGVmaW5pdGlvbjtcbiAgICAgICAgX3RoaXMuX3RhZyA9ICdSZWN1cnNpdmVUeXBlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVjdXJzaXZlVHlwZS5wcm90b3R5cGUsIFwidHlwZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVuRGVmaW5pdGlvbigpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gUmVjdXJzaXZlVHlwZTtcbn0oVHlwZSkpO1xuZXhwb3J0IHsgUmVjdXJzaXZlVHlwZSB9O1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xuZXhwb3J0IHZhciByZWN1cnNpb24gPSBmdW5jdGlvbiAobmFtZSwgZGVmaW5pdGlvbikge1xuICAgIHZhciBjYWNoZTtcbiAgICB2YXIgcnVuRGVmaW5pdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFjYWNoZSkge1xuICAgICAgICAgICAgY2FjaGUgPSBkZWZpbml0aW9uKFNlbGYpO1xuICAgICAgICAgICAgY2FjaGUubmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH07XG4gICAgdmFyIFNlbGYgPSBuZXcgUmVjdXJzaXZlVHlwZShuYW1lLCBmdW5jdGlvbiAodSkgeyByZXR1cm4gcnVuRGVmaW5pdGlvbigpLmlzKHUpOyB9LCBmdW5jdGlvbiAodSwgYykgeyByZXR1cm4gcnVuRGVmaW5pdGlvbigpLnZhbGlkYXRlKHUsIGMpOyB9LCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gcnVuRGVmaW5pdGlvbigpLmVuY29kZShhKTsgfSwgcnVuRGVmaW5pdGlvbik7XG4gICAgcmV0dXJuIFNlbGY7XG59O1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xudmFyIEFycmF5VHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJyYXlUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFycmF5VHlwZShuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSwgdHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIF90aGlzLl90YWcgPSAnQXJyYXlUeXBlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXlUeXBlO1xufShUeXBlKSk7XG5leHBvcnQgeyBBcnJheVR5cGUgfTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydCB2YXIgYXJyYXkgPSBmdW5jdGlvbiAoY29kZWMsIG5hbWUpIHtcbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSBcIkFycmF5PFwiICsgY29kZWMubmFtZSArIFwiPlwiOyB9XG4gICAgcmV0dXJuIG5ldyBBcnJheVR5cGUobmFtZSwgZnVuY3Rpb24gKHUpIHsgcmV0dXJuIFVua25vd25BcnJheS5pcyh1KSAmJiB1LmV2ZXJ5KGNvZGVjLmlzKTsgfSwgZnVuY3Rpb24gKHUsIGMpIHtcbiAgICAgICAgcmV0dXJuIFVua25vd25BcnJheS52YWxpZGF0ZSh1LCBjKS5jaGFpbihmdW5jdGlvbiAodXMpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSB1cy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYXMgPSB1cztcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdWkgPSB1c1tpXTtcbiAgICAgICAgICAgICAgICBjb2RlYy52YWxpZGF0ZSh1aSwgYXBwZW5kQ29udGV4dChjLCBTdHJpbmcoaSksIGNvZGVjLCB1aSkpLmZvbGQoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHB1c2hBbGwoZXJyb3JzLCBlKTsgfSwgZnVuY3Rpb24gKGFpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhaSAhPT0gdWkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcyA9PT0gdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcyA9IHVzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhc1tpXSA9IGFpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JzLmxlbmd0aCA+IDAgPyBmYWlsdXJlcyhlcnJvcnMpIDogc3VjY2Vzcyhhcyk7XG4gICAgICAgIH0pO1xuICAgIH0sIGNvZGVjLmVuY29kZSA9PT0gaWRlbnRpdHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLm1hcChjb2RlYy5lbmNvZGUpOyB9LCBjb2RlYyk7XG59O1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xudmFyIEludGVyZmFjZVR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEludGVyZmFjZVR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW50ZXJmYWNlVHlwZShuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSwgcHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgaXMsIHZhbGlkYXRlLCBlbmNvZGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIF90aGlzLl90YWcgPSAnSW50ZXJmYWNlVHlwZSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEludGVyZmFjZVR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydCB7IEludGVyZmFjZVR5cGUgfTtcbnZhciBnZXROYW1lRnJvbVByb3BzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHByb3BzKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBrICsgXCI6IFwiICsgcHJvcHNba10ubmFtZTsgfSlcbiAgICAgICAgLmpvaW4oJywgJyk7XG59O1xudmFyIHVzZUlkZW50aXR5ID0gZnVuY3Rpb24gKGNvZGVjcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZWNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjb2RlY3NbaV0uZW5jb2RlICE9PSBpZGVudGl0eSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbnZhciBnZXRJbnRlcmZhY2VUeXBlTmFtZSA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHJldHVybiBcInsgXCIgKyBnZXROYW1lRnJvbVByb3BzKHByb3BzKSArIFwiIH1cIjtcbn07XG4vKipcbiAqIEBhbGlhcyBgaW50ZXJmYWNlYFxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydCB2YXIgdHlwZSA9IGZ1bmN0aW9uIChwcm9wcywgbmFtZSkge1xuICAgIGlmIChuYW1lID09PSB2b2lkIDApIHsgbmFtZSA9IGdldEludGVyZmFjZVR5cGVOYW1lKHByb3BzKTsgfVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpO1xuICAgIHZhciB0eXBlcyA9IGtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHByb3BzW2tleV07IH0pO1xuICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICByZXR1cm4gbmV3IEludGVyZmFjZVR5cGUobmFtZSwgZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgaWYgKCFVbmtub3duUmVjb3JkLmlzKHUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGsgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHUsIGspIHx8ICF0eXBlc1tpXS5pcyh1W2tdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCBmdW5jdGlvbiAodSwgYykge1xuICAgICAgICByZXR1cm4gVW5rbm93blJlY29yZC52YWxpZGF0ZSh1LCBjKS5jaGFpbihmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGEgPSBvO1xuICAgICAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHZhciBrID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoYSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgPT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBfX2Fzc2lnbih7fSwgbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYVtrXSA9IGFba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBhayA9IGFba107XG4gICAgICAgICAgICAgICAgdmFyIHR5cGVfMSA9IHR5cGVzW2ldO1xuICAgICAgICAgICAgICAgIHR5cGVfMS52YWxpZGF0ZShhaywgYXBwZW5kQ29udGV4dChjLCBrLCB0eXBlXzEsIGFrKSkuZm9sZChmdW5jdGlvbiAoZSkgeyByZXR1cm4gcHVzaEFsbChlcnJvcnMsIGUpOyB9LCBmdW5jdGlvbiAodmFrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWsgIT09IGFrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgPT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gX19hc3NpZ24oe30sIG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYVtrXSA9IHZhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcF8yKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPiAwID8gZmFpbHVyZXMoZXJyb3JzKSA6IHN1Y2Nlc3MoYSk7XG4gICAgICAgIH0pO1xuICAgIH0sIHVzZUlkZW50aXR5KHR5cGVzKVxuICAgICAgICA/IGlkZW50aXR5XG4gICAgICAgIDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHZhciBzID0gX19hc3NpZ24oe30sIGEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgZW5jb2RlID0gdHlwZXNbaV0uZW5jb2RlO1xuICAgICAgICAgICAgICAgIGlmIChlbmNvZGUgIT09IGlkZW50aXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNba10gPSBlbmNvZGUoYVtrXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH0sIHByb3BzKTtcbn07XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG52YXIgUGFydGlhbFR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBhcnRpYWxUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhcnRpYWxUeXBlKG5hbWUsIGlzLCB2YWxpZGF0ZSwgZW5jb2RlLCBwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgX3RoaXMuX3RhZyA9ICdQYXJ0aWFsVHlwZSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBhcnRpYWxUeXBlO1xufShUeXBlKSk7XG5leHBvcnQgeyBQYXJ0aWFsVHlwZSB9O1xudmFyIGdldFBhcnRpYWxUeXBlTmFtZSA9IGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBcIlBhcnRpYWw8XCIgKyBpbm5lciArIFwiPlwiO1xufTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydCB2YXIgcGFydGlhbCA9IGZ1bmN0aW9uIChwcm9wcywgbmFtZSkge1xuICAgIGlmIChuYW1lID09PSB2b2lkIDApIHsgbmFtZSA9IGdldFBhcnRpYWxUeXBlTmFtZShnZXRJbnRlcmZhY2VUeXBlTmFtZShwcm9wcykpOyB9XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcyk7XG4gICAgdmFyIHR5cGVzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gcHJvcHNba2V5XTsgfSk7XG4gICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIHJldHVybiBuZXcgUGFydGlhbFR5cGUobmFtZSwgZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgaWYgKCFVbmtub3duUmVjb3JkLmlzKHUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGsgPSBrZXlzW2ldO1xuICAgICAgICAgICAgdmFyIHVrID0gdVtrXTtcbiAgICAgICAgICAgIGlmICh1ayAhPT0gdW5kZWZpbmVkICYmICFwcm9wc1trXS5pcyh1aykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgZnVuY3Rpb24gKHUsIGMpIHtcbiAgICAgICAgcmV0dXJuIFVua25vd25SZWNvcmQudmFsaWRhdGUodSwgYykuY2hhaW4oZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhID0gbztcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBfbG9vcF8zID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgayA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGFrID0gYVtrXTtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZV8yID0gcHJvcHNba107XG4gICAgICAgICAgICAgICAgdHlwZV8yLnZhbGlkYXRlKGFrLCBhcHBlbmRDb250ZXh0KGMsIGssIHR5cGVfMiwgYWspKS5mb2xkKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoQWxsKGVycm9ycywgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAodmFrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWsgIT09IGFrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgPT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gX19hc3NpZ24oe30sIG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYVtrXSA9IHZhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcF8zKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPiAwID8gZmFpbHVyZXMoZXJyb3JzKSA6IHN1Y2Nlc3MoYSk7XG4gICAgICAgIH0pO1xuICAgIH0sIHVzZUlkZW50aXR5KHR5cGVzKVxuICAgICAgICA/IGlkZW50aXR5XG4gICAgICAgIDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHZhciBzID0gX19hc3NpZ24oe30sIGEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgYWsgPSBhW2tdO1xuICAgICAgICAgICAgICAgIGlmIChhayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNba10gPSB0eXBlc1tpXS5lbmNvZGUoYWspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9LCBwcm9wcyk7XG59O1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xudmFyIERpY3Rpb25hcnlUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWN0aW9uYXJ5VHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaWN0aW9uYXJ5VHlwZShuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSwgZG9tYWluLCBjb2RvbWFpbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZG9tYWluID0gZG9tYWluO1xuICAgICAgICBfdGhpcy5jb2RvbWFpbiA9IGNvZG9tYWluO1xuICAgICAgICBfdGhpcy5fdGFnID0gJ0RpY3Rpb25hcnlUeXBlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRGljdGlvbmFyeVR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydCB7IERpY3Rpb25hcnlUeXBlIH07XG52YXIgaXNPYmplY3QgPSBmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHIpID09PSAnW29iamVjdCBPYmplY3RdJzsgfTtcbi8qKlxuICogQHNpbmNlIDEuNy4xXG4gKi9cbmV4cG9ydCB2YXIgcmVjb3JkID0gZnVuY3Rpb24gKGRvbWFpbiwgY29kb21haW4sIG5hbWUpIHtcbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSBcInsgW0sgaW4gXCIgKyBkb21haW4ubmFtZSArIFwiXTogXCIgKyBjb2RvbWFpbi5uYW1lICsgXCIgfVwiOyB9XG4gICAgcmV0dXJuIG5ldyBEaWN0aW9uYXJ5VHlwZShuYW1lLCBmdW5jdGlvbiAodSkge1xuICAgICAgICBpZiAoIVVua25vd25SZWNvcmQuaXModSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5rbm93bkNvZGVjKGNvZG9tYWluKSAmJiAhaXNBbnlDb2RlYyhjb2RvbWFpbikgJiYgIWlzT2JqZWN0KHUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHUpLmV2ZXJ5KGZ1bmN0aW9uIChrKSB7IHJldHVybiBkb21haW4uaXMoaykgJiYgY29kb21haW4uaXModVtrXSk7IH0pO1xuICAgIH0sIGZ1bmN0aW9uICh1LCBjKSB7XG4gICAgICAgIHJldHVybiBVbmtub3duUmVjb3JkLnZhbGlkYXRlKHUsIGMpLmNoYWluKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICBpZiAoIWlzVW5rbm93bkNvZGVjKGNvZG9tYWluKSAmJiAhaXNBbnlDb2RlYyhjb2RvbWFpbikgJiYgIWlzT2JqZWN0KG8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhaWx1cmUodSwgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYSA9IHt9O1xuICAgICAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvKTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgX2xvb3BfNCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBvayA9IG9ba107XG4gICAgICAgICAgICAgICAgZG9tYWluLnZhbGlkYXRlKGssIGFwcGVuZENvbnRleHQoYywgaywgZG9tYWluLCBrKSkuZm9sZChmdW5jdGlvbiAoZSkgeyByZXR1cm4gcHVzaEFsbChlcnJvcnMsIGUpOyB9LCBmdW5jdGlvbiAodmspIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IGNoYW5nZWQgfHwgdmsgIT09IGs7XG4gICAgICAgICAgICAgICAgICAgIGsgPSB2aztcbiAgICAgICAgICAgICAgICAgICAgY29kb21haW4udmFsaWRhdGUob2ssIGFwcGVuZENvbnRleHQoYywgaywgY29kb21haW4sIG9rKSkuZm9sZChmdW5jdGlvbiAoZSkgeyByZXR1cm4gcHVzaEFsbChlcnJvcnMsIGUpOyB9LCBmdW5jdGlvbiAodm9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCB2b2sgIT09IG9rO1xuICAgICAgICAgICAgICAgICAgICAgICAgYVtrXSA9IHZvaztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIF9sb29wXzQoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JzLmxlbmd0aCA+IDAgPyBmYWlsdXJlcyhlcnJvcnMpIDogc3VjY2VzcygoY2hhbmdlZCA/IGEgOiBvKSk7XG4gICAgICAgIH0pO1xuICAgIH0sIGRvbWFpbi5lbmNvZGUgPT09IGlkZW50aXR5ICYmIGNvZG9tYWluLmVuY29kZSA9PT0gaWRlbnRpdHlcbiAgICAgICAgPyBpZGVudGl0eVxuICAgICAgICA6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHt9O1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgayA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgc1tTdHJpbmcoZG9tYWluLmVuY29kZShrKSldID0gY29kb21haW4uZW5jb2RlKGFba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH0sIGRvbWFpbiwgY29kb21haW4pO1xufTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbnZhciBVbmlvblR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFVuaW9uVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVbmlvblR5cGUobmFtZSwgaXMsIHZhbGlkYXRlLCBlbmNvZGUsIHR5cGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIGlzLCB2YWxpZGF0ZSwgZW5jb2RlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlcyA9IHR5cGVzO1xuICAgICAgICBfdGhpcy5fdGFnID0gJ1VuaW9uVHlwZSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFVuaW9uVHlwZTtcbn0oVHlwZSkpO1xuZXhwb3J0IHsgVW5pb25UeXBlIH07XG52YXIgZ2V0VW5pb25OYW1lID0gZnVuY3Rpb24gKGNvZGVjcykge1xuICAgIHJldHVybiAnKCcgKyBjb2RlY3MubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLm5hbWU7IH0pLmpvaW4oJyB8ICcpICsgJyknO1xufTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydCB2YXIgdW5pb24gPSBmdW5jdGlvbiAoY29kZWNzLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gZ2V0VW5pb25OYW1lKGNvZGVjcyk7IH1cbiAgICB2YXIgaW5kZXggPSBnZXRJbmRleChjb2RlY3MpO1xuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGNvZGVjcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB0YWdfMSA9IGluZGV4WzBdLCBncm91cHNfMSA9IGluZGV4WzFdO1xuICAgICAgICB2YXIgbGVuXzEgPSBncm91cHNfMS5sZW5ndGg7XG4gICAgICAgIHZhciBmaW5kXzEgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuXzE7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChncm91cHNfMVtpXS5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBkZXByZWNhdGlvblxuICAgICAgICByZXR1cm4gbmV3IFRhZ2dlZFVuaW9uVHlwZShuYW1lLCBmdW5jdGlvbiAodSkge1xuICAgICAgICAgICAgaWYgKCFVbmtub3duUmVjb3JkLmlzKHUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGkgPSBmaW5kXzEodVt0YWdfMV0pO1xuICAgICAgICAgICAgcmV0dXJuIGkgIT09IHVuZGVmaW5lZCA/IGNvZGVjc1tpXS5pcyh1KSA6IGZhbHNlO1xuICAgICAgICB9LCBmdW5jdGlvbiAodSwgYykge1xuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SZWNvcmQudmFsaWRhdGUodSwgYykuY2hhaW4oZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGZpbmRfMShyW3RhZ18xXSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFpbHVyZSh1LCBjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNvZGVjID0gY29kZWNzW2ldO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlYy52YWxpZGF0ZShyLCBhcHBlbmRDb250ZXh0KGMsIFN0cmluZyhpKSwgY29kZWMsIHIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB1c2VJZGVudGl0eShjb2RlY3MpXG4gICAgICAgICAgICA/IGlkZW50aXR5XG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBmaW5kXzEoYVt0YWdfMV0pO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2djYW50aS9pby10cy9wdWxsLzMwNVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBjb2RlYyBmb3VuZCB0byBlbmNvZGUgdmFsdWUgaW4gdW5pb24gY29kZWMgXCIgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlY3NbaV0uZW5jb2RlKGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGNvZGVjcywgdGFnXzEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVbmlvblR5cGUobmFtZSwgZnVuY3Rpb24gKHUpIHsgcmV0dXJuIGNvZGVjcy5zb21lKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLmlzKHUpOyB9KTsgfSwgZnVuY3Rpb24gKHUsIGMpIHtcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZWNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGVjID0gY29kZWNzW2ldO1xuICAgICAgICAgICAgICAgIHZhciByID0gY29kZWNcbiAgICAgICAgICAgICAgICAgICAgLnZhbGlkYXRlKHUsIGFwcGVuZENvbnRleHQoYywgU3RyaW5nKGkpLCBjb2RlYywgdSkpXG4gICAgICAgICAgICAgICAgICAgIC5mb2xkKGZ1bmN0aW9uIChlKSB7IHJldHVybiBwdXNoQWxsKGVycm9ycywgZSk7IH0sIHN1Y2Nlc3MpO1xuICAgICAgICAgICAgICAgIGlmIChyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhaWx1cmVzKGVycm9ycyk7XG4gICAgICAgIH0sIHVzZUlkZW50aXR5KGNvZGVjcylcbiAgICAgICAgICAgID8gaWRlbnRpdHlcbiAgICAgICAgICAgIDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNvZGVjc18xID0gY29kZWNzOyBfaSA8IGNvZGVjc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29kZWMgPSBjb2RlY3NfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlYy5pcyhhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVjLmVuY29kZShhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2NhbnRpL2lvLXRzL3B1bGwvMzA1XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gY29kZWMgZm91bmQgdG8gZW5jb2RlIHZhbHVlIGluIHVuaW9uIHR5cGUgXCIgKyBuYW1lKTtcbiAgICAgICAgICAgIH0sIGNvZGVjcyk7XG4gICAgfVxufTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbnZhciBJbnRlcnNlY3Rpb25UeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnRlcnNlY3Rpb25UeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEludGVyc2VjdGlvblR5cGUobmFtZSwgaXMsIHZhbGlkYXRlLCBlbmNvZGUsIHR5cGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIGlzLCB2YWxpZGF0ZSwgZW5jb2RlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlcyA9IHR5cGVzO1xuICAgICAgICBfdGhpcy5fdGFnID0gJ0ludGVyc2VjdGlvblR5cGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBJbnRlcnNlY3Rpb25UeXBlO1xufShUeXBlKSk7XG5leHBvcnQgeyBJbnRlcnNlY3Rpb25UeXBlIH07XG52YXIgbWVyZ2VBbGwgPSBmdW5jdGlvbiAoYmFzZSwgdXMpIHtcbiAgICB2YXIgciA9IGJhc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdSA9IHVzW2ldO1xuICAgICAgICBpZiAodSAhPT0gYmFzZSkge1xuICAgICAgICAgICAgLy8gYHVgIGNvbnRhaW5zIGEgcHJpc21hdGljIHZhbHVlIG9yIGlzIHRoZSByZXN1bHQgb2YgYSBzdHJpcHBpbmcgY29tYmluYXRvclxuICAgICAgICAgICAgaWYgKHIgPT09IGJhc2UpIHtcbiAgICAgICAgICAgICAgICByID0gT2JqZWN0LmFzc2lnbih7fSwgdSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIHUpIHtcbiAgICAgICAgICAgICAgICBpZiAodVtrXSAhPT0gYmFzZVtrXSB8fCAhci5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICByW2tdID0gdVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdGlvbihjb2RlY3MsIG5hbWUpIHtcbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSBcIihcIiArIGNvZGVjcy5tYXAoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHR5cGUubmFtZTsgfSkuam9pbignICYgJykgKyBcIilcIjsgfVxuICAgIHZhciBsZW4gPSBjb2RlY3MubGVuZ3RoO1xuICAgIHJldHVybiBuZXcgSW50ZXJzZWN0aW9uVHlwZShuYW1lLCBmdW5jdGlvbiAodSkgeyByZXR1cm4gY29kZWNzLmV2ZXJ5KGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLmlzKHUpOyB9KTsgfSwgY29kZWNzLmxlbmd0aCA9PT0gMFxuICAgICAgICA/IHN1Y2Nlc3NcbiAgICAgICAgOiBmdW5jdGlvbiAodSwgYykge1xuICAgICAgICAgICAgdmFyIHVzID0gW107XG4gICAgICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGVjID0gY29kZWNzW2ldO1xuICAgICAgICAgICAgICAgIGNvZGVjLnZhbGlkYXRlKHUsIGFwcGVuZENvbnRleHQoYywgU3RyaW5nKGkpLCBjb2RlYywgdSkpLmZvbGQoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHB1c2hBbGwoZXJyb3JzLCBlKTsgfSwgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHVzLnB1c2goYSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPiAwID8gZmFpbHVyZXMoZXJyb3JzKSA6IHN1Y2Nlc3MobWVyZ2VBbGwodSwgdXMpKTtcbiAgICAgICAgfSwgY29kZWNzLmxlbmd0aCA9PT0gMCA/IGlkZW50aXR5IDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIG1lcmdlQWxsKGEsIGNvZGVjcy5tYXAoZnVuY3Rpb24gKGNvZGVjKSB7IHJldHVybiBjb2RlYy5lbmNvZGUoYSk7IH0pKTsgfSwgY29kZWNzKTtcbn1cbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbnZhciBUdXBsZVR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFR1cGxlVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUdXBsZVR5cGUobmFtZSwgaXMsIHZhbGlkYXRlLCBlbmNvZGUsIHR5cGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIGlzLCB2YWxpZGF0ZSwgZW5jb2RlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlcyA9IHR5cGVzO1xuICAgICAgICBfdGhpcy5fdGFnID0gJ1R1cGxlVHlwZSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFR1cGxlVHlwZTtcbn0oVHlwZSkpO1xuZXhwb3J0IHsgVHVwbGVUeXBlIH07XG5leHBvcnQgZnVuY3Rpb24gdHVwbGUoY29kZWNzLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gXCJbXCIgKyBjb2RlY3MubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLm5hbWU7IH0pLmpvaW4oJywgJykgKyBcIl1cIjsgfVxuICAgIHZhciBsZW4gPSBjb2RlY3MubGVuZ3RoO1xuICAgIHJldHVybiBuZXcgVHVwbGVUeXBlKG5hbWUsIGZ1bmN0aW9uICh1KSB7IHJldHVybiBVbmtub3duQXJyYXkuaXModSkgJiYgdS5sZW5ndGggPT09IGxlbiAmJiBjb2RlY3MuZXZlcnkoZnVuY3Rpb24gKHR5cGUsIGkpIHsgcmV0dXJuIHR5cGUuaXModVtpXSk7IH0pOyB9LCBmdW5jdGlvbiAodSwgYykge1xuICAgICAgICByZXR1cm4gVW5rbm93bkFycmF5LnZhbGlkYXRlKHUsIGMpLmNoYWluKGZ1bmN0aW9uICh1cykge1xuICAgICAgICAgICAgdmFyIGFzID0gdXMubGVuZ3RoID4gbGVuID8gdXMuc2xpY2UoMCwgbGVuKSA6IHVzOyAvLyBzdHJpcCBhZGRpdGlvbmFsIGNvbXBvbmVudHNcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBfbG9vcF81ID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHVzW2ldO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlXzMgPSBjb2RlY3NbaV07XG4gICAgICAgICAgICAgICAgdHlwZV8zLnZhbGlkYXRlKGEsIGFwcGVuZENvbnRleHQoYywgU3RyaW5nKGkpLCB0eXBlXzMsIGEpKS5mb2xkKGZ1bmN0aW9uIChlKSB7IHJldHVybiBwdXNoQWxsKGVycm9ycywgZSk7IH0sIGZ1bmN0aW9uICh2YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmEgIT09IGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXMgPT09IHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXMgPSB1cy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXNbaV0gPSB2YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcF81KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPiAwID8gZmFpbHVyZXMoZXJyb3JzKSA6IHN1Y2Nlc3MoYXMpO1xuICAgICAgICB9KTtcbiAgICB9LCB1c2VJZGVudGl0eShjb2RlY3MpID8gaWRlbnRpdHkgOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gY29kZWNzLm1hcChmdW5jdGlvbiAodHlwZSwgaSkgeyByZXR1cm4gdHlwZS5lbmNvZGUoYVtpXSk7IH0pOyB9LCBjb2RlY3MpO1xufVxuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xudmFyIFJlYWRvbmx5VHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVhZG9ubHlUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlYWRvbmx5VHlwZShuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSwgdHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIF90aGlzLl90YWcgPSAnUmVhZG9ubHlUeXBlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmVhZG9ubHlUeXBlO1xufShUeXBlKSk7XG5leHBvcnQgeyBSZWFkb25seVR5cGUgfTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydCB2YXIgcmVhZG9ubHkgPSBmdW5jdGlvbiAoY29kZWMsIG5hbWUpIHtcbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSBcIlJlYWRvbmx5PFwiICsgY29kZWMubmFtZSArIFwiPlwiOyB9XG4gICAgcmV0dXJuIG5ldyBSZWFkb25seVR5cGUobmFtZSwgY29kZWMuaXMsIGZ1bmN0aW9uICh1LCBjKSB7XG4gICAgICAgIHJldHVybiBjb2RlYy52YWxpZGF0ZSh1LCBjKS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSk7XG4gICAgfSwgY29kZWMuZW5jb2RlID09PSBpZGVudGl0eSA/IGlkZW50aXR5IDogY29kZWMuZW5jb2RlLCBjb2RlYyk7XG59O1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xudmFyIFJlYWRvbmx5QXJyYXlUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWFkb25seUFycmF5VHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWFkb25seUFycmF5VHlwZShuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSwgdHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIF90aGlzLl90YWcgPSAnUmVhZG9ubHlBcnJheVR5cGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZWFkb25seUFycmF5VHlwZTtcbn0oVHlwZSkpO1xuZXhwb3J0IHsgUmVhZG9ubHlBcnJheVR5cGUgfTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydCB2YXIgcmVhZG9ubHlBcnJheSA9IGZ1bmN0aW9uIChjb2RlYywgbmFtZSkge1xuICAgIGlmIChuYW1lID09PSB2b2lkIDApIHsgbmFtZSA9IFwiUmVhZG9ubHlBcnJheTxcIiArIGNvZGVjLm5hbWUgKyBcIj5cIjsgfVxuICAgIHZhciBhcnJheVR5cGUgPSBhcnJheShjb2RlYyk7XG4gICAgcmV0dXJuIG5ldyBSZWFkb25seUFycmF5VHlwZShuYW1lLCBhcnJheVR5cGUuaXMsIGZ1bmN0aW9uICh1LCBjKSB7XG4gICAgICAgIHJldHVybiBhcnJheVR5cGUudmFsaWRhdGUodSwgYykubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH0pO1xuICAgIH0sIGFycmF5VHlwZS5lbmNvZGUsIGNvZGVjKTtcbn07XG4vKipcbiAqIFN0cmlwcyBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAqIEBzaW5jZSAxLjAuMFxuICovXG5leHBvcnQgdmFyIHN0cmljdCA9IGZ1bmN0aW9uIChwcm9wcywgbmFtZSkge1xuICAgIHJldHVybiBleGFjdCh0eXBlKHByb3BzKSwgbmFtZSk7XG59O1xuLyoqXG4gKiBAc2luY2UgMS4zLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbnZhciBUYWdnZWRVbmlvblR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhZ2dlZFVuaW9uVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWdnZWRVbmlvblR5cGUobmFtZSwgXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBkZXByZWNhdGlvblxuICAgIGlzLCBcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGRlcHJlY2F0aW9uXG4gICAgdmFsaWRhdGUsIFxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGVwcmVjYXRpb25cbiAgICBlbmNvZGUsIGNvZGVjcywgdGFnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIGlzLCB2YWxpZGF0ZSwgZW5jb2RlLCBjb2RlY3MpIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIC8vIDw9IHdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMTM0NTVcbiAgICAgICAgIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRhZyA9IHRhZztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGFnZ2VkVW5pb25UeXBlO1xufShVbmlvblR5cGUpKTtcbmV4cG9ydCB7IFRhZ2dlZFVuaW9uVHlwZSB9O1xuLyoqXG4gKiBVc2UgYHVuaW9uYCBpbnN0ZWFkXG4gKlxuICogQHNpbmNlIDEuMy4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgdmFyIHRhZ2dlZFVuaW9uID0gZnVuY3Rpb24gKHRhZywgY29kZWNzLCBuYW1lXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGRlcHJlY2F0aW9uXG4pIHtcbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSBnZXRVbmlvbk5hbWUoY29kZWNzKTsgfVxuICAgIHZhciBVID0gdW5pb24oY29kZWNzLCBuYW1lKTtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGRlcHJlY2F0aW9uXG4gICAgaWYgKFUgaW5zdGFuY2VvZiBUYWdnZWRVbmlvblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIFU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbaW8tdHNdIENhbm5vdCBidWlsZCBhIHRhZ2dlZCB1bmlvbiBmb3IgXCIgKyBuYW1lICsgXCIsIHJldHVybmluZyBhIGRlLW9wdGltaXplZCB1bmlvblwiKTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBkZXByZWNhdGlvblxuICAgICAgICByZXR1cm4gbmV3IFRhZ2dlZFVuaW9uVHlwZShuYW1lLCBVLmlzLCBVLnZhbGlkYXRlLCBVLmVuY29kZSwgY29kZWNzLCB0YWcpO1xuICAgIH1cbn07XG4vKipcbiAqIEBzaW5jZSAxLjEuMFxuICovXG52YXIgRXhhY3RUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeGFjdFR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXhhY3RUeXBlKG5hbWUsIGlzLCB2YWxpZGF0ZSwgZW5jb2RlLCB0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIGlzLCB2YWxpZGF0ZSwgZW5jb2RlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgX3RoaXMuX3RhZyA9ICdFeGFjdFR5cGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBFeGFjdFR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydCB7IEV4YWN0VHlwZSB9O1xudmFyIGdldFByb3BzID0gZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgc3dpdGNoIChjb2RlYy5fdGFnKSB7XG4gICAgICAgIGNhc2UgJ1JlZmluZW1lbnRUeXBlJzpcbiAgICAgICAgY2FzZSAnUmVhZG9ubHlUeXBlJzpcbiAgICAgICAgICAgIHJldHVybiBnZXRQcm9wcyhjb2RlYy50eXBlKTtcbiAgICAgICAgY2FzZSAnSW50ZXJmYWNlVHlwZSc6XG4gICAgICAgIGNhc2UgJ1N0cmljdFR5cGUnOlxuICAgICAgICBjYXNlICdQYXJ0aWFsVHlwZSc6XG4gICAgICAgICAgICByZXR1cm4gY29kZWMucHJvcHM7XG4gICAgICAgIGNhc2UgJ0ludGVyc2VjdGlvblR5cGUnOlxuICAgICAgICAgICAgcmV0dXJuIGNvZGVjLnR5cGVzLnJlZHVjZShmdW5jdGlvbiAocHJvcHMsIHR5cGUpIHsgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvcHMsIGdldFByb3BzKHR5cGUpKTsgfSwge30pO1xuICAgIH1cbn07XG52YXIgc3RyaXBLZXlzID0gZnVuY3Rpb24gKG8sIHByb3BzKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvKTtcbiAgICB2YXIgc2hvdWxkU3RyaXAgPSBmYWxzZTtcbiAgICB2YXIgciA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBrZXkpKSB7XG4gICAgICAgICAgICBzaG91bGRTdHJpcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByW2tleV0gPSBvW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNob3VsZFN0cmlwID8gciA6IG87XG59O1xudmFyIGdldEV4YWN0VHlwZU5hbWUgPSBmdW5jdGlvbiAoY29kZWMpIHtcbiAgICBpZiAoaXNJbnRlcmZhY2VDb2RlYyhjb2RlYykpIHtcbiAgICAgICAgcmV0dXJuIFwie3wgXCIgKyBnZXROYW1lRnJvbVByb3BzKGNvZGVjLnByb3BzKSArIFwiIHx9XCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGFydGlhbENvZGVjKGNvZGVjKSkge1xuICAgICAgICByZXR1cm4gZ2V0UGFydGlhbFR5cGVOYW1lKFwie3wgXCIgKyBnZXROYW1lRnJvbVByb3BzKGNvZGVjLnByb3BzKSArIFwiIHx9XCIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJFeGFjdDxcIiArIGNvZGVjLm5hbWUgKyBcIj5cIjtcbn07XG4vKipcbiAqIFN0cmlwcyBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAqIEBzaW5jZSAxLjEuMFxuICovXG5leHBvcnQgdmFyIGV4YWN0ID0gZnVuY3Rpb24gKGNvZGVjLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gZ2V0RXhhY3RUeXBlTmFtZShjb2RlYyk7IH1cbiAgICB2YXIgcHJvcHMgPSBnZXRQcm9wcyhjb2RlYyk7XG4gICAgcmV0dXJuIG5ldyBFeGFjdFR5cGUobmFtZSwgY29kZWMuaXMsIGZ1bmN0aW9uICh1LCBjKSB7XG4gICAgICAgIHJldHVybiBVbmtub3duUmVjb3JkLnZhbGlkYXRlKHUsIGMpLmNoYWluKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVjLnZhbGlkYXRlKHUsIGMpLmZvbGQobGVmdCwgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHN1Y2Nlc3Moc3RyaXBLZXlzKGEsIHByb3BzKSk7IH0pOyB9KTtcbiAgICB9LCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gY29kZWMuZW5jb2RlKHN0cmlwS2V5cyhhLCBwcm9wcykpOyB9LCBjb2RlYyk7XG59O1xuZXhwb3J0IHsgbnVsbFR5cGUgYXMgbnVsbCB9O1xuZXhwb3J0IHsgdW5kZWZpbmVkVHlwZSBhcyB1bmRlZmluZWQgfTtcbi8qKlxuICogVXNlIGBVbmtub3duQXJyYXlgIGluc3RlYWRcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCB7IFVua25vd25BcnJheSBhcyBBcnJheSB9O1xuLyoqXG4gKiBVc2UgYHR5cGVgIGluc3RlYWRcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCB7IHR5cGUgYXMgaW50ZXJmYWNlIH07XG5leHBvcnQgeyB2b2lkVHlwZSBhcyB2b2lkIH07XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IHZhciBnZXRWYWxpZGF0aW9uRXJyb3IgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gPSBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHsgcmV0dXJuICh7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGNvbnRleHQ6IGNvbnRleHRcbn0pOyB9O1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCB2YXIgZ2V0RGVmYXVsdENvbnRleHQgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gPSBmdW5jdGlvbiAoZGVjb2RlcikgeyByZXR1cm4gW1xuICAgIHsga2V5OiAnJywgdHlwZTogZGVjb2RlciB9XG5dOyB9O1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbnZhciBOZXZlclR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5ldmVyVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOZXZlclR5cGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICduZXZlcicsIGZ1bmN0aW9uIChfKSB7IHJldHVybiBmYWxzZTsgfSwgZnVuY3Rpb24gKHUsIGMpIHsgcmV0dXJuIGZhaWx1cmUodSwgYyk7IH0sIFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBlbmNvZGUgbmV2ZXInKTtcbiAgICAgICAgfSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3RhZyA9ICdOZXZlclR5cGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBOZXZlclR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydCB7IE5ldmVyVHlwZSB9O1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGVwcmVjYXRpb25cbmV4cG9ydCB2YXIgbmV2ZXIgPSBuZXcgTmV2ZXJUeXBlKCk7XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xudmFyIEFueVR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFueVR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQW55VHlwZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ2FueScsIGZ1bmN0aW9uIChfKSB7IHJldHVybiB0cnVlOyB9LCBzdWNjZXNzLCBpZGVudGl0eSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3RhZyA9ICdBbnlUeXBlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQW55VHlwZTtcbn0oVHlwZSkpO1xuZXhwb3J0IHsgQW55VHlwZSB9O1xuLyoqXG4gKiBVc2UgYHVua25vd25gIGluc3RlYWRcbiAqIEBzaW5jZSAxLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBkZXByZWNhdGlvblxuZXhwb3J0IHZhciBhbnkgPSBuZXcgQW55VHlwZSgpO1xuLyoqXG4gKiBVc2UgYFVua25vd25SZWNvcmRgIGluc3RlYWRcbiAqIEBzaW5jZSAxLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IHZhciBEaWN0aW9uYXJ5ID0gVW5rbm93blJlY29yZDtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG52YXIgT2JqZWN0VHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT2JqZWN0VHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPYmplY3RUeXBlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAnb2JqZWN0JywgVW5rbm93blJlY29yZC5pcywgVW5rbm93blJlY29yZC52YWxpZGF0ZSwgaWRlbnRpdHkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl90YWcgPSAnT2JqZWN0VHlwZSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdFR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydCB7IE9iamVjdFR5cGUgfTtcbi8qKlxuICogVXNlIGBVbmtub3duUmVjb3JkYCBpbnN0ZWFkXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGVwcmVjYXRpb25cbmV4cG9ydCB2YXIgb2JqZWN0ID0gbmV3IE9iamVjdFR5cGUoKTtcbi8qKlxuICogVXNlIGBicmFuZGAgaW5zdGVhZFxuICogQHNpbmNlIDEuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVmaW5lbWVudChjb2RlYywgcHJlZGljYXRlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gXCIoXCIgKyBjb2RlYy5uYW1lICsgXCIgfCBcIiArIGdldEZ1bmN0aW9uTmFtZShwcmVkaWNhdGUpICsgXCIpXCI7IH1cbiAgICByZXR1cm4gbmV3IFJlZmluZW1lbnRUeXBlKG5hbWUsIGZ1bmN0aW9uICh1KSB7IHJldHVybiBjb2RlYy5pcyh1KSAmJiBwcmVkaWNhdGUodSk7IH0sIGZ1bmN0aW9uIChpLCBjKSB7IHJldHVybiBjb2RlYy52YWxpZGF0ZShpLCBjKS5jaGFpbihmdW5jdGlvbiAoYSkgeyByZXR1cm4gKHByZWRpY2F0ZShhKSA/IHN1Y2Nlc3MoYSkgOiBmYWlsdXJlKGEsIGMpKTsgfSk7IH0sIGNvZGVjLmVuY29kZSwgY29kZWMsIHByZWRpY2F0ZSk7XG59XG4vKipcbiAqIFVzZSBgSW50YCBpbnN0ZWFkXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGVwcmVjYXRpb25cbmV4cG9ydCB2YXIgSW50ZWdlciA9IHJlZmluZW1lbnQobnVtYmVyLCBOdW1iZXIuaXNJbnRlZ2VyLCAnSW50ZWdlcicpO1xuLyoqXG4gKiBVc2UgYHJlY29yZGAgaW5zdGVhZFxuICogQHNpbmNlIDEuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgdmFyIGRpY3Rpb25hcnkgPSByZWNvcmQ7XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xudmFyIFN0cmljdFR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0cmljdFR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RyaWN0VHlwZShuYW1lLCBcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGRlcHJlY2F0aW9uXG4gICAgaXMsIFxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGVwcmVjYXRpb25cbiAgICB2YWxpZGF0ZSwgXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBkZXByZWNhdGlvblxuICAgIGVuY29kZSwgcHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgaXMsIHZhbGlkYXRlLCBlbmNvZGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIF90aGlzLl90YWcgPSAnU3RyaWN0VHlwZSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFN0cmljdFR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydCB7IFN0cmljdFR5cGUgfTtcbi8qKlxuICogRHJvcHMgdGhlIGNvZGVjIFwia2luZFwiXG4gKiBAc2luY2UgMS4xLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbihjb2RlYykge1xuICAgIHJldHVybiBjb2RlYztcbn1cbmV4cG9ydCBmdW5jdGlvbiBhbGlhcyhjb2RlYykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlYzsgfTtcbn1cbnZhciBpc05vbkVtcHR5ID0gZnVuY3Rpb24gKGFzKSB7IHJldHVybiBhcy5sZW5ndGggPiAwOyB9O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHZhciBlbXB0eVRhZ3MgPSB7fTtcbmZ1bmN0aW9uIGludGVyc2VjdChhLCBiKSB7XG4gICAgdmFyIHIgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGFfMSA9IGE7IF9pIDwgYV8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgdiA9IGFfMVtfaV07XG4gICAgICAgIGlmIChiLmluZGV4T2YodikgIT09IC0xKSB7XG4gICAgICAgICAgICByLnB1c2godik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBtZXJnZVRhZ3MoYSwgYikge1xuICAgIGlmIChhID09PSBlbXB0eVRhZ3MpIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIGlmIChiID09PSBlbXB0eVRhZ3MpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIHZhciByID0gT2JqZWN0LmFzc2lnbih7fSwgYSk7XG4gICAgZm9yICh2YXIgayBpbiBiKSB7XG4gICAgICAgIGlmIChhLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uXzEgPSBpbnRlcnNlY3QoYVtrXSwgYltrXSk7XG4gICAgICAgICAgICBpZiAoaXNOb25FbXB0eShpbnRlcnNlY3Rpb25fMSkpIHtcbiAgICAgICAgICAgICAgICByW2tdID0gaW50ZXJzZWN0aW9uXzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByID0gZW1wdHlUYWdzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcltrXSA9IGJba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RUYWdzKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gZW1wdHlUYWdzIHx8IGIgPT09IGVtcHR5VGFncykge1xuICAgICAgICByZXR1cm4gZW1wdHlUYWdzO1xuICAgIH1cbiAgICB2YXIgciA9IGVtcHR5VGFncztcbiAgICBmb3IgKHZhciBrIGluIGEpIHtcbiAgICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb25fMiA9IGludGVyc2VjdChhW2tdLCBiW2tdKTtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb25fMi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAociA9PT0gZW1wdHlUYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcltrXSA9IGFba10uY29uY2F0KGJba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xufVxuZnVuY3Rpb24gaXNMaXRlcmFsQyhjb2RlYykge1xuICAgIHJldHVybiBjb2RlYy5fdGFnID09PSAnTGl0ZXJhbFR5cGUnO1xufVxuZnVuY3Rpb24gaXNUeXBlQyhjb2RlYykge1xuICAgIHJldHVybiBjb2RlYy5fdGFnID09PSAnSW50ZXJmYWNlVHlwZSc7XG59XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGRlcHJlY2F0aW9uXG5mdW5jdGlvbiBpc1N0cmljdEMoY29kZWMpIHtcbiAgICByZXR1cm4gY29kZWMuX3RhZyA9PT0gJ1N0cmljdFR5cGUnO1xufVxuZnVuY3Rpb24gaXNFeGFjdEMoY29kZWMpIHtcbiAgICByZXR1cm4gY29kZWMuX3RhZyA9PT0gJ0V4YWN0VHlwZSc7XG59XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGRlcHJlY2F0aW9uXG5mdW5jdGlvbiBpc1JlZmluZW1lbnRDKGNvZGVjKSB7XG4gICAgcmV0dXJuIGNvZGVjLl90YWcgPT09ICdSZWZpbmVtZW50VHlwZSc7XG59XG5mdW5jdGlvbiBpc0ludGVyc2VjdGlvbkMoY29kZWMpIHtcbiAgICByZXR1cm4gY29kZWMuX3RhZyA9PT0gJ0ludGVyc2VjdGlvblR5cGUnO1xufVxuZnVuY3Rpb24gaXNVbmlvbkMoY29kZWMpIHtcbiAgICByZXR1cm4gY29kZWMuX3RhZyA9PT0gJ1VuaW9uVHlwZSc7XG59XG5mdW5jdGlvbiBpc1JlY3Vyc2l2ZUMoY29kZWMpIHtcbiAgICByZXR1cm4gY29kZWMuX3RhZyA9PT0gJ1JlY3Vyc2l2ZVR5cGUnO1xufVxudmFyIGxhenlDb2RlYyA9IG51bGw7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGFncyhjb2RlYykge1xuICAgIGlmIChjb2RlYyA9PT0gbGF6eUNvZGVjKSB7XG4gICAgICAgIHJldHVybiBlbXB0eVRhZ3M7XG4gICAgfVxuICAgIGlmIChpc1R5cGVDKGNvZGVjKSB8fCBpc1N0cmljdEMoY29kZWMpKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGVtcHR5VGFncztcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBmb3JpblxuICAgICAgICBmb3IgKHZhciBrIGluIGNvZGVjLnByb3BzKSB7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IGNvZGVjLnByb3BzW2tdO1xuICAgICAgICAgICAgaWYgKGlzTGl0ZXJhbEMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IGVtcHR5VGFncykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleFtrXSA9IFtwcm9wLnZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRXhhY3RDKGNvZGVjKSB8fCBpc1JlZmluZW1lbnRDKGNvZGVjKSkge1xuICAgICAgICByZXR1cm4gZ2V0VGFncyhjb2RlYy50eXBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNJbnRlcnNlY3Rpb25DKGNvZGVjKSkge1xuICAgICAgICByZXR1cm4gY29kZWMudHlwZXMucmVkdWNlKGZ1bmN0aW9uICh0YWdzLCBjb2RlYykgeyByZXR1cm4gbWVyZ2VUYWdzKHRhZ3MsIGdldFRhZ3MoY29kZWMpKTsgfSwgZW1wdHlUYWdzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNVbmlvbkMoY29kZWMpKSB7XG4gICAgICAgIHJldHVybiBjb2RlYy50eXBlcy5zbGljZSgxKS5yZWR1Y2UoZnVuY3Rpb24gKHRhZ3MsIGNvZGVjKSB7IHJldHVybiBpbnRlcnNlY3RUYWdzKHRhZ3MsIGdldFRhZ3MoY29kZWMpKTsgfSwgZ2V0VGFncyhjb2RlYy50eXBlc1swXSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1JlY3Vyc2l2ZUMoY29kZWMpKSB7XG4gICAgICAgIGxhenlDb2RlYyA9IGNvZGVjO1xuICAgICAgICB2YXIgdGFncyA9IGdldFRhZ3MoY29kZWMudHlwZSk7XG4gICAgICAgIGxhenlDb2RlYyA9IG51bGw7XG4gICAgICAgIHJldHVybiB0YWdzO1xuICAgIH1cbiAgICByZXR1cm4gZW1wdHlUYWdzO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEluZGV4KGNvZGVjcykge1xuICAgIHZhciB0YWdzID0gZ2V0VGFncyhjb2RlY3NbMF0pO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGFncyk7XG4gICAgdmFyIGxlbiA9IGNvZGVjcy5sZW5ndGg7XG4gICAgdmFyIF9sb29wXzYgPSBmdW5jdGlvbiAoaykge1xuICAgICAgICB2YXIgYWxsID0gdGFnc1trXS5zbGljZSgpO1xuICAgICAgICB2YXIgaW5kZXggPSBbdGFnc1trXV07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb2RlYyA9IGNvZGVjc1tpXTtcbiAgICAgICAgICAgIHZhciBjdGFncyA9IGdldFRhZ3MoY29kZWMpO1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IGN0YWdzW2tdO1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBzdHJpY3QtdHlwZS1wcmVkaWNhdGVzXG4gICAgICAgICAgICBpZiAodmFsdWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZS1rZXlzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGFsbC5pbmRleE9mKHYpICE9PSAtMTsgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWUta2V5c1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsLnB1c2guYXBwbHkoYWxsLCB2YWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleC5wdXNoKHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBbaywgaW5kZXhdIH07XG4gICAgfTtcbiAgICBrZXlzOiBmb3IgKHZhciBfaSA9IDAsIGtleXNfMSA9IGtleXM7IF9pIDwga2V5c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgayA9IGtleXNfMVtfaV07XG4gICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfNihrKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZV8xID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlXzEudmFsdWU7XG4gICAgICAgIHN3aXRjaCAoc3RhdGVfMSkge1xuICAgICAgICAgICAgY2FzZSBcImNvbnRpbnVlLWtleXNcIjogY29udGludWUga2V5cztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/io-ts/es6/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/io-ts/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/io-ts/lib/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Either_1 = __webpack_require__(/*! fp-ts/lib/Either */ \"(ssr)/./node_modules/io-ts/node_modules/fp-ts/lib/Either.js\");\n/**\n * @since 1.0.0\n */\nvar Type = /** @class */ (function () {\n    function Type(\n    /** a unique name for this codec */\n    name, \n    /** a custom type guard */\n    is, \n    /** succeeds if a value of type I can be decoded to a value of type A */\n    validate, \n    /** converts a value of type A to a value of type O */\n    encode) {\n        this.name = name;\n        this.is = is;\n        this.validate = validate;\n        this.encode = encode;\n        this.decode = this.decode.bind(this);\n    }\n    Type.prototype.pipe = function (ab, name) {\n        var _this = this;\n        if (name === void 0) { name = \"pipe(\" + this.name + \", \" + ab.name + \")\"; }\n        return new Type(name, ab.is, function (i, c) { return _this.validate(i, c).chain(function (a) { return ab.validate(a, c); }); }, this.encode === exports.identity && ab.encode === exports.identity ? exports.identity : function (b) { return _this.encode(ab.encode(b)); });\n    };\n    Type.prototype.asDecoder = function () {\n        return this;\n    };\n    Type.prototype.asEncoder = function () {\n        return this;\n    };\n    /** a version of `validate` with a default context */\n    Type.prototype.decode = function (i) {\n        return this.validate(i, [{ key: '', type: this, actual: i }]);\n    };\n    return Type;\n}());\nexports.Type = Type;\n/**\n * @since 1.0.0\n */\nexports.identity = function (a) { return a; };\n/**\n * @since 1.0.0\n */\nexports.getFunctionName = function (f) {\n    return f.displayName || f.name || \"<function\" + f.length + \">\";\n};\n/**\n * @since 1.0.0\n */\nexports.getContextEntry = function (key, decoder) { return ({ key: key, type: decoder }); };\n/**\n * @since 1.0.0\n */\nexports.appendContext = function (c, key, decoder, actual) {\n    var len = c.length;\n    var r = Array(len + 1);\n    for (var i = 0; i < len; i++) {\n        r[i] = c[i];\n    }\n    r[len] = { key: key, type: decoder, actual: actual };\n    return r;\n};\n/**\n * @since 1.0.0\n */\nexports.failures = Either_1.left;\n/**\n * @since 1.0.0\n */\nexports.failure = function (value, context, message) {\n    return exports.failures([{ value: value, context: context, message: message }]);\n};\n/**\n * @since 1.0.0\n */\nexports.success = Either_1.right;\nvar pushAll = function (xs, ys) {\n    var l = ys.length;\n    for (var i = 0; i < l; i++) {\n        xs.push(ys[i]);\n    }\n};\nvar getIsCodec = function (tag) { return function (codec) { return codec._tag === tag; }; };\nvar isUnknownCodec = getIsCodec('UnknownType');\n// tslint:disable-next-line: deprecation\nvar isAnyCodec = getIsCodec('AnyType');\nvar isInterfaceCodec = getIsCodec('InterfaceType');\nvar isPartialCodec = getIsCodec('PartialType');\n//\n// basic types\n//\n/**\n * @since 1.0.0\n */\nvar NullType = /** @class */ (function (_super) {\n    __extends(NullType, _super);\n    function NullType() {\n        var _this = _super.call(this, 'null', function (u) { return u === null; }, function (u, c) { return (_this.is(u) ? exports.success(u) : exports.failure(u, c)); }, exports.identity) || this;\n        _this._tag = 'NullType';\n        return _this;\n    }\n    return NullType;\n}(Type));\nexports.NullType = NullType;\n/**\n * @alias `null`\n * @since 1.0.0\n */\nexports.nullType = new NullType();\nexports[\"null\"] = exports.nullType;\n/**\n * @since 1.0.0\n */\nvar UndefinedType = /** @class */ (function (_super) {\n    __extends(UndefinedType, _super);\n    function UndefinedType() {\n        var _this = _super.call(this, 'undefined', function (u) { return u === void 0; }, function (u, c) { return (_this.is(u) ? exports.success(u) : exports.failure(u, c)); }, exports.identity) || this;\n        _this._tag = 'UndefinedType';\n        return _this;\n    }\n    return UndefinedType;\n}(Type));\nexports.UndefinedType = UndefinedType;\nvar undefinedType = new UndefinedType();\nexports.undefined = undefinedType;\n/**\n * @since 1.2.0\n */\nvar VoidType = /** @class */ (function (_super) {\n    __extends(VoidType, _super);\n    function VoidType() {\n        var _this = _super.call(this, 'void', undefinedType.is, undefinedType.validate, exports.identity) || this;\n        _this._tag = 'VoidType';\n        return _this;\n    }\n    return VoidType;\n}(Type));\nexports.VoidType = VoidType;\n/**\n * @alias `void`\n * @since 1.2.0\n */\nexports.voidType = new VoidType();\nexports[\"void\"] = exports.voidType;\n/**\n * @since 1.5.0\n */\nvar UnknownType = /** @class */ (function (_super) {\n    __extends(UnknownType, _super);\n    function UnknownType() {\n        var _this = _super.call(this, 'unknown', function (_) { return true; }, exports.success, exports.identity) || this;\n        _this._tag = 'UnknownType';\n        return _this;\n    }\n    return UnknownType;\n}(Type));\nexports.UnknownType = UnknownType;\n/**\n * @since 1.5.0\n */\nexports.unknown = new UnknownType();\n/**\n * @since 1.0.0\n */\nvar StringType = /** @class */ (function (_super) {\n    __extends(StringType, _super);\n    function StringType() {\n        var _this = _super.call(this, 'string', function (u) { return typeof u === 'string'; }, function (u, c) { return (_this.is(u) ? exports.success(u) : exports.failure(u, c)); }, exports.identity) || this;\n        _this._tag = 'StringType';\n        return _this;\n    }\n    return StringType;\n}(Type));\nexports.StringType = StringType;\n/**\n * @since 1.0.0\n */\nexports.string = new StringType();\n/**\n * @since 1.0.0\n */\nvar NumberType = /** @class */ (function (_super) {\n    __extends(NumberType, _super);\n    function NumberType() {\n        var _this = _super.call(this, 'number', function (u) { return typeof u === 'number'; }, function (u, c) { return (_this.is(u) ? exports.success(u) : exports.failure(u, c)); }, exports.identity) || this;\n        _this._tag = 'NumberType';\n        return _this;\n    }\n    return NumberType;\n}(Type));\nexports.NumberType = NumberType;\n/**\n * @since 1.0.0\n */\nexports.number = new NumberType();\n/**\n * @since 1.0.0\n */\nvar BooleanType = /** @class */ (function (_super) {\n    __extends(BooleanType, _super);\n    function BooleanType() {\n        var _this = _super.call(this, 'boolean', function (u) { return typeof u === 'boolean'; }, function (u, c) { return (_this.is(u) ? exports.success(u) : exports.failure(u, c)); }, exports.identity) || this;\n        _this._tag = 'BooleanType';\n        return _this;\n    }\n    return BooleanType;\n}(Type));\nexports.BooleanType = BooleanType;\n/**\n * @since 1.0.0\n */\nexports.boolean = new BooleanType();\n/**\n * @since 1.0.0\n */\nvar AnyArrayType = /** @class */ (function (_super) {\n    __extends(AnyArrayType, _super);\n    function AnyArrayType() {\n        var _this = _super.call(this, 'UnknownArray', Array.isArray, function (u, c) { return (_this.is(u) ? exports.success(u) : exports.failure(u, c)); }, exports.identity) || this;\n        _this._tag = 'AnyArrayType';\n        return _this;\n    }\n    return AnyArrayType;\n}(Type));\nexports.AnyArrayType = AnyArrayType;\n/**\n * @since 1.7.1\n */\nexports.UnknownArray = new AnyArrayType();\nexports.Array = exports.UnknownArray;\n/**\n * @since 1.0.0\n */\nvar AnyDictionaryType = /** @class */ (function (_super) {\n    __extends(AnyDictionaryType, _super);\n    function AnyDictionaryType() {\n        var _this = _super.call(this, 'UnknownRecord', function (u) { return u !== null && typeof u === 'object'; }, function (u, c) { return (_this.is(u) ? exports.success(u) : exports.failure(u, c)); }, exports.identity) || this;\n        _this._tag = 'AnyDictionaryType';\n        return _this;\n    }\n    return AnyDictionaryType;\n}(Type));\nexports.AnyDictionaryType = AnyDictionaryType;\n/**\n * @since 1.7.1\n */\nexports.UnknownRecord = new AnyDictionaryType();\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar FunctionType = /** @class */ (function (_super) {\n    __extends(FunctionType, _super);\n    function FunctionType() {\n        var _this = _super.call(this, 'Function', \n        // tslint:disable-next-line:strict-type-predicates\n        function (u) { return typeof u === 'function'; }, function (u, c) { return (_this.is(u) ? exports.success(u) : exports.failure(u, c)); }, exports.identity) || this;\n        _this._tag = 'FunctionType';\n        return _this;\n    }\n    return FunctionType;\n}(Type));\nexports.FunctionType = FunctionType;\n/**\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nexports.Function = new FunctionType();\n/**\n * @since 1.0.0\n */\nvar RefinementType = /** @class */ (function (_super) {\n    __extends(RefinementType, _super);\n    function RefinementType(name, is, validate, encode, type, predicate) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        _this.predicate = predicate;\n        _this._tag = 'RefinementType';\n        return _this;\n    }\n    return RefinementType;\n}(Type));\nexports.RefinementType = RefinementType;\n/**\n * @since 1.8.1\n */\nexports.brand = function (codec, predicate, name) {\n    // tslint:disable-next-line: deprecation\n    return refinement(codec, predicate, name);\n};\n/**\n * A branded codec representing an integer\n * @since 1.8.1\n */\nexports.Int = exports.brand(exports.number, function (n) { return Number.isInteger(n); }, 'Int');\n/**\n * @since 1.0.0\n */\nvar LiteralType = /** @class */ (function (_super) {\n    __extends(LiteralType, _super);\n    function LiteralType(name, is, validate, encode, value) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.value = value;\n        _this._tag = 'LiteralType';\n        return _this;\n    }\n    return LiteralType;\n}(Type));\nexports.LiteralType = LiteralType;\n/**\n * @since 1.0.0\n */\nexports.literal = function (value, name) {\n    if (name === void 0) { name = JSON.stringify(value); }\n    var is = function (u) { return u === value; };\n    return new LiteralType(name, is, function (u, c) { return (is(u) ? exports.success(value) : exports.failure(u, c)); }, exports.identity, value);\n};\n/**\n * @since 1.0.0\n */\nvar KeyofType = /** @class */ (function (_super) {\n    __extends(KeyofType, _super);\n    function KeyofType(name, is, validate, encode, keys) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.keys = keys;\n        _this._tag = 'KeyofType';\n        return _this;\n    }\n    return KeyofType;\n}(Type));\nexports.KeyofType = KeyofType;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * @since 1.0.0\n */\nexports.keyof = function (keys, name) {\n    if (name === void 0) { name = Object.keys(keys)\n        .map(function (k) { return JSON.stringify(k); })\n        .join(' | '); }\n    var is = function (u) { return exports.string.is(u) && hasOwnProperty.call(keys, u); };\n    return new KeyofType(name, is, function (u, c) { return (is(u) ? exports.success(u) : exports.failure(u, c)); }, exports.identity, keys);\n};\n/**\n * @since 1.0.0\n */\nvar RecursiveType = /** @class */ (function (_super) {\n    __extends(RecursiveType, _super);\n    function RecursiveType(name, is, validate, encode, runDefinition) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.runDefinition = runDefinition;\n        _this._tag = 'RecursiveType';\n        return _this;\n    }\n    Object.defineProperty(RecursiveType.prototype, \"type\", {\n        get: function () {\n            return this.runDefinition();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return RecursiveType;\n}(Type));\nexports.RecursiveType = RecursiveType;\n/**\n * @since 1.0.0\n */\nexports.recursion = function (name, definition) {\n    var cache;\n    var runDefinition = function () {\n        if (!cache) {\n            cache = definition(Self);\n            cache.name = name;\n        }\n        return cache;\n    };\n    var Self = new RecursiveType(name, function (u) { return runDefinition().is(u); }, function (u, c) { return runDefinition().validate(u, c); }, function (a) { return runDefinition().encode(a); }, runDefinition);\n    return Self;\n};\n/**\n * @since 1.0.0\n */\nvar ArrayType = /** @class */ (function (_super) {\n    __extends(ArrayType, _super);\n    function ArrayType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        _this._tag = 'ArrayType';\n        return _this;\n    }\n    return ArrayType;\n}(Type));\nexports.ArrayType = ArrayType;\n/**\n * @since 1.0.0\n */\nexports.array = function (codec, name) {\n    if (name === void 0) { name = \"Array<\" + codec.name + \">\"; }\n    return new ArrayType(name, function (u) { return exports.UnknownArray.is(u) && u.every(codec.is); }, function (u, c) {\n        return exports.UnknownArray.validate(u, c).chain(function (us) {\n            var len = us.length;\n            var as = us;\n            var errors = [];\n            var _loop_1 = function (i) {\n                var ui = us[i];\n                codec.validate(ui, exports.appendContext(c, String(i), codec, ui)).fold(function (e) { return pushAll(errors, e); }, function (ai) {\n                    if (ai !== ui) {\n                        if (as === us) {\n                            as = us.slice();\n                        }\n                        as[i] = ai;\n                    }\n                });\n            };\n            for (var i = 0; i < len; i++) {\n                _loop_1(i);\n            }\n            return errors.length > 0 ? exports.failures(errors) : exports.success(as);\n        });\n    }, codec.encode === exports.identity ? exports.identity : function (a) { return a.map(codec.encode); }, codec);\n};\n/**\n * @since 1.0.0\n */\nvar InterfaceType = /** @class */ (function (_super) {\n    __extends(InterfaceType, _super);\n    function InterfaceType(name, is, validate, encode, props) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.props = props;\n        _this._tag = 'InterfaceType';\n        return _this;\n    }\n    return InterfaceType;\n}(Type));\nexports.InterfaceType = InterfaceType;\nvar getNameFromProps = function (props) {\n    return Object.keys(props)\n        .map(function (k) { return k + \": \" + props[k].name; })\n        .join(', ');\n};\nvar useIdentity = function (codecs) {\n    for (var i = 0; i < codecs.length; i++) {\n        if (codecs[i].encode !== exports.identity) {\n            return false;\n        }\n    }\n    return true;\n};\nvar getInterfaceTypeName = function (props) {\n    return \"{ \" + getNameFromProps(props) + \" }\";\n};\n/**\n * @alias `interface`\n * @since 1.0.0\n */\nexports.type = function (props, name) {\n    if (name === void 0) { name = getInterfaceTypeName(props); }\n    var keys = Object.keys(props);\n    var types = keys.map(function (key) { return props[key]; });\n    var len = keys.length;\n    return new InterfaceType(name, function (u) {\n        if (!exports.UnknownRecord.is(u)) {\n            return false;\n        }\n        for (var i = 0; i < len; i++) {\n            var k = keys[i];\n            if (!hasOwnProperty.call(u, k) || !types[i].is(u[k])) {\n                return false;\n            }\n        }\n        return true;\n    }, function (u, c) {\n        return exports.UnknownRecord.validate(u, c).chain(function (o) {\n            var a = o;\n            var errors = [];\n            var _loop_2 = function (i) {\n                var k = keys[i];\n                if (!hasOwnProperty.call(a, k)) {\n                    if (a === o) {\n                        a = __assign({}, o);\n                    }\n                    a[k] = a[k];\n                }\n                var ak = a[k];\n                var type_1 = types[i];\n                type_1.validate(ak, exports.appendContext(c, k, type_1, ak)).fold(function (e) { return pushAll(errors, e); }, function (vak) {\n                    if (vak !== ak) {\n                        /* istanbul ignore next */\n                        if (a === o) {\n                            a = __assign({}, o);\n                        }\n                        a[k] = vak;\n                    }\n                });\n            };\n            for (var i = 0; i < len; i++) {\n                _loop_2(i);\n            }\n            return errors.length > 0 ? exports.failures(errors) : exports.success(a);\n        });\n    }, useIdentity(types)\n        ? exports.identity\n        : function (a) {\n            var s = __assign({}, a);\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                var encode = types[i].encode;\n                if (encode !== exports.identity) {\n                    s[k] = encode(a[k]);\n                }\n            }\n            return s;\n        }, props);\n};\nexports[\"interface\"] = exports.type;\n/**\n * @since 1.0.0\n */\nvar PartialType = /** @class */ (function (_super) {\n    __extends(PartialType, _super);\n    function PartialType(name, is, validate, encode, props) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.props = props;\n        _this._tag = 'PartialType';\n        return _this;\n    }\n    return PartialType;\n}(Type));\nexports.PartialType = PartialType;\nvar getPartialTypeName = function (inner) {\n    return \"Partial<\" + inner + \">\";\n};\n/**\n * @since 1.0.0\n */\nexports.partial = function (props, name) {\n    if (name === void 0) { name = getPartialTypeName(getInterfaceTypeName(props)); }\n    var keys = Object.keys(props);\n    var types = keys.map(function (key) { return props[key]; });\n    var len = keys.length;\n    return new PartialType(name, function (u) {\n        if (!exports.UnknownRecord.is(u)) {\n            return false;\n        }\n        for (var i = 0; i < len; i++) {\n            var k = keys[i];\n            var uk = u[k];\n            if (uk !== undefined && !props[k].is(uk)) {\n                return false;\n            }\n        }\n        return true;\n    }, function (u, c) {\n        return exports.UnknownRecord.validate(u, c).chain(function (o) {\n            var a = o;\n            var errors = [];\n            var _loop_3 = function (i) {\n                var k = keys[i];\n                var ak = a[k];\n                var type_2 = props[k];\n                type_2.validate(ak, exports.appendContext(c, k, type_2, ak)).fold(function (e) {\n                    if (ak !== undefined) {\n                        pushAll(errors, e);\n                    }\n                }, function (vak) {\n                    if (vak !== ak) {\n                        /* istanbul ignore next */\n                        if (a === o) {\n                            a = __assign({}, o);\n                        }\n                        a[k] = vak;\n                    }\n                });\n            };\n            for (var i = 0; i < len; i++) {\n                _loop_3(i);\n            }\n            return errors.length > 0 ? exports.failures(errors) : exports.success(a);\n        });\n    }, useIdentity(types)\n        ? exports.identity\n        : function (a) {\n            var s = __assign({}, a);\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                var ak = a[k];\n                if (ak !== undefined) {\n                    s[k] = types[i].encode(ak);\n                }\n            }\n            return s;\n        }, props);\n};\n/**\n * @since 1.0.0\n */\nvar DictionaryType = /** @class */ (function (_super) {\n    __extends(DictionaryType, _super);\n    function DictionaryType(name, is, validate, encode, domain, codomain) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.domain = domain;\n        _this.codomain = codomain;\n        _this._tag = 'DictionaryType';\n        return _this;\n    }\n    return DictionaryType;\n}(Type));\nexports.DictionaryType = DictionaryType;\nvar isObject = function (r) { return Object.prototype.toString.call(r) === '[object Object]'; };\n/**\n * @since 1.7.1\n */\nexports.record = function (domain, codomain, name) {\n    if (name === void 0) { name = \"{ [K in \" + domain.name + \"]: \" + codomain.name + \" }\"; }\n    return new DictionaryType(name, function (u) {\n        if (!exports.UnknownRecord.is(u)) {\n            return false;\n        }\n        if (!isUnknownCodec(codomain) && !isAnyCodec(codomain) && !isObject(u)) {\n            return false;\n        }\n        return Object.keys(u).every(function (k) { return domain.is(k) && codomain.is(u[k]); });\n    }, function (u, c) {\n        return exports.UnknownRecord.validate(u, c).chain(function (o) {\n            if (!isUnknownCodec(codomain) && !isAnyCodec(codomain) && !isObject(o)) {\n                return exports.failure(u, c);\n            }\n            var a = {};\n            var errors = [];\n            var keys = Object.keys(o);\n            var len = keys.length;\n            var changed = false;\n            var _loop_4 = function (i) {\n                var k = keys[i];\n                var ok = o[k];\n                domain.validate(k, exports.appendContext(c, k, domain, k)).fold(function (e) { return pushAll(errors, e); }, function (vk) {\n                    changed = changed || vk !== k;\n                    k = vk;\n                    codomain.validate(ok, exports.appendContext(c, k, codomain, ok)).fold(function (e) { return pushAll(errors, e); }, function (vok) {\n                        changed = changed || vok !== ok;\n                        a[k] = vok;\n                    });\n                });\n            };\n            for (var i = 0; i < len; i++) {\n                _loop_4(i);\n            }\n            return errors.length > 0 ? exports.failures(errors) : exports.success((changed ? a : o));\n        });\n    }, domain.encode === exports.identity && codomain.encode === exports.identity\n        ? exports.identity\n        : function (a) {\n            var s = {};\n            var keys = Object.keys(a);\n            var len = keys.length;\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                s[String(domain.encode(k))] = codomain.encode(a[k]);\n            }\n            return s;\n        }, domain, codomain);\n};\n/**\n * @since 1.0.0\n */\nvar UnionType = /** @class */ (function (_super) {\n    __extends(UnionType, _super);\n    function UnionType(name, is, validate, encode, types) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.types = types;\n        _this._tag = 'UnionType';\n        return _this;\n    }\n    return UnionType;\n}(Type));\nexports.UnionType = UnionType;\nvar getUnionName = function (codecs) {\n    return '(' + codecs.map(function (type) { return type.name; }).join(' | ') + ')';\n};\n/**\n * @since 1.0.0\n */\nexports.union = function (codecs, name) {\n    if (name === void 0) { name = getUnionName(codecs); }\n    var index = getIndex(codecs);\n    if (index !== undefined && codecs.length > 0) {\n        var tag_1 = index[0], groups_1 = index[1];\n        var len_1 = groups_1.length;\n        var find_1 = function (value) {\n            for (var i = 0; i < len_1; i++) {\n                if (groups_1[i].indexOf(value) !== -1) {\n                    return i;\n                }\n            }\n            return undefined;\n        };\n        // tslint:disable-next-line: deprecation\n        return new TaggedUnionType(name, function (u) {\n            if (!exports.UnknownRecord.is(u)) {\n                return false;\n            }\n            var i = find_1(u[tag_1]);\n            return i !== undefined ? codecs[i].is(u) : false;\n        }, function (u, c) {\n            return exports.UnknownRecord.validate(u, c).chain(function (r) {\n                var i = find_1(r[tag_1]);\n                if (i === undefined) {\n                    return exports.failure(u, c);\n                }\n                var codec = codecs[i];\n                return codec.validate(r, exports.appendContext(c, String(i), codec, r));\n            });\n        }, useIdentity(codecs)\n            ? exports.identity\n            : function (a) {\n                var i = find_1(a[tag_1]);\n                if (i === undefined) {\n                    // https://github.com/gcanti/io-ts/pull/305\n                    throw new Error(\"no codec found to encode value in union codec \" + name);\n                }\n                else {\n                    return codecs[i].encode(a);\n                }\n            }, codecs, tag_1);\n    }\n    else {\n        return new UnionType(name, function (u) { return codecs.some(function (type) { return type.is(u); }); }, function (u, c) {\n            var errors = [];\n            for (var i = 0; i < codecs.length; i++) {\n                var codec = codecs[i];\n                var r = codec\n                    .validate(u, exports.appendContext(c, String(i), codec, u))\n                    .fold(function (e) { return pushAll(errors, e); }, exports.success);\n                if (r !== undefined) {\n                    return r;\n                }\n            }\n            return exports.failures(errors);\n        }, useIdentity(codecs)\n            ? exports.identity\n            : function (a) {\n                for (var _i = 0, codecs_1 = codecs; _i < codecs_1.length; _i++) {\n                    var codec = codecs_1[_i];\n                    if (codec.is(a)) {\n                        return codec.encode(a);\n                    }\n                }\n                // https://github.com/gcanti/io-ts/pull/305\n                throw new Error(\"no codec found to encode value in union type \" + name);\n            }, codecs);\n    }\n};\n/**\n * @since 1.0.0\n */\nvar IntersectionType = /** @class */ (function (_super) {\n    __extends(IntersectionType, _super);\n    function IntersectionType(name, is, validate, encode, types) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.types = types;\n        _this._tag = 'IntersectionType';\n        return _this;\n    }\n    return IntersectionType;\n}(Type));\nexports.IntersectionType = IntersectionType;\nvar mergeAll = function (base, us) {\n    var r = base;\n    for (var i = 0; i < us.length; i++) {\n        var u = us[i];\n        if (u !== base) {\n            // `u` contains a prismatic value or is the result of a stripping combinator\n            if (r === base) {\n                r = Object.assign({}, u);\n                continue;\n            }\n            for (var k in u) {\n                if (u[k] !== base[k] || !r.hasOwnProperty(k)) {\n                    r[k] = u[k];\n                }\n            }\n        }\n    }\n    return r;\n};\nfunction intersection(codecs, name) {\n    if (name === void 0) { name = \"(\" + codecs.map(function (type) { return type.name; }).join(' & ') + \")\"; }\n    var len = codecs.length;\n    return new IntersectionType(name, function (u) { return codecs.every(function (type) { return type.is(u); }); }, codecs.length === 0\n        ? exports.success\n        : function (u, c) {\n            var us = [];\n            var errors = [];\n            for (var i = 0; i < len; i++) {\n                var codec = codecs[i];\n                codec.validate(u, exports.appendContext(c, String(i), codec, u)).fold(function (e) { return pushAll(errors, e); }, function (a) { return us.push(a); });\n            }\n            return errors.length > 0 ? exports.failures(errors) : exports.success(mergeAll(u, us));\n        }, codecs.length === 0 ? exports.identity : function (a) { return mergeAll(a, codecs.map(function (codec) { return codec.encode(a); })); }, codecs);\n}\nexports.intersection = intersection;\n/**\n * @since 1.0.0\n */\nvar TupleType = /** @class */ (function (_super) {\n    __extends(TupleType, _super);\n    function TupleType(name, is, validate, encode, types) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.types = types;\n        _this._tag = 'TupleType';\n        return _this;\n    }\n    return TupleType;\n}(Type));\nexports.TupleType = TupleType;\nfunction tuple(codecs, name) {\n    if (name === void 0) { name = \"[\" + codecs.map(function (type) { return type.name; }).join(', ') + \"]\"; }\n    var len = codecs.length;\n    return new TupleType(name, function (u) { return exports.UnknownArray.is(u) && u.length === len && codecs.every(function (type, i) { return type.is(u[i]); }); }, function (u, c) {\n        return exports.UnknownArray.validate(u, c).chain(function (us) {\n            var as = us.length > len ? us.slice(0, len) : us; // strip additional components\n            var errors = [];\n            var _loop_5 = function (i) {\n                var a = us[i];\n                var type_3 = codecs[i];\n                type_3.validate(a, exports.appendContext(c, String(i), type_3, a)).fold(function (e) { return pushAll(errors, e); }, function (va) {\n                    if (va !== a) {\n                        /* istanbul ignore next */\n                        if (as === us) {\n                            as = us.slice();\n                        }\n                        as[i] = va;\n                    }\n                });\n            };\n            for (var i = 0; i < len; i++) {\n                _loop_5(i);\n            }\n            return errors.length > 0 ? exports.failures(errors) : exports.success(as);\n        });\n    }, useIdentity(codecs) ? exports.identity : function (a) { return codecs.map(function (type, i) { return type.encode(a[i]); }); }, codecs);\n}\nexports.tuple = tuple;\n/**\n * @since 1.0.0\n */\nvar ReadonlyType = /** @class */ (function (_super) {\n    __extends(ReadonlyType, _super);\n    function ReadonlyType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        _this._tag = 'ReadonlyType';\n        return _this;\n    }\n    return ReadonlyType;\n}(Type));\nexports.ReadonlyType = ReadonlyType;\n/**\n * @since 1.0.0\n */\nexports.readonly = function (codec, name) {\n    if (name === void 0) { name = \"Readonly<\" + codec.name + \">\"; }\n    return new ReadonlyType(name, codec.is, function (u, c) {\n        return codec.validate(u, c).map(function (x) {\n            if (true) {\n                return Object.freeze(x);\n            }\n            return x;\n        });\n    }, codec.encode === exports.identity ? exports.identity : codec.encode, codec);\n};\n/**\n * @since 1.0.0\n */\nvar ReadonlyArrayType = /** @class */ (function (_super) {\n    __extends(ReadonlyArrayType, _super);\n    function ReadonlyArrayType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        _this._tag = 'ReadonlyArrayType';\n        return _this;\n    }\n    return ReadonlyArrayType;\n}(Type));\nexports.ReadonlyArrayType = ReadonlyArrayType;\n/**\n * @since 1.0.0\n */\nexports.readonlyArray = function (codec, name) {\n    if (name === void 0) { name = \"ReadonlyArray<\" + codec.name + \">\"; }\n    var arrayType = exports.array(codec);\n    return new ReadonlyArrayType(name, arrayType.is, function (u, c) {\n        return arrayType.validate(u, c).map(function (x) {\n            if (true) {\n                return Object.freeze(x);\n            }\n            return x;\n        });\n    }, arrayType.encode, codec);\n};\n/**\n * Strips additional properties\n * @since 1.0.0\n */\nexports.strict = function (props, name) {\n    return exports.exact(exports.type(props), name);\n};\n/**\n * @since 1.3.0\n * @deprecated\n */\nvar TaggedUnionType = /** @class */ (function (_super) {\n    __extends(TaggedUnionType, _super);\n    function TaggedUnionType(name, \n    // tslint:disable-next-line: deprecation\n    is, \n    // tslint:disable-next-line: deprecation\n    validate, \n    // tslint:disable-next-line: deprecation\n    encode, codecs, tag) {\n        var _this = _super.call(this, name, is, validate, encode, codecs) /* istanbul ignore next */ // <= workaround for https://github.com/Microsoft/TypeScript/issues/13455\n         || this;\n        _this.tag = tag;\n        return _this;\n    }\n    return TaggedUnionType;\n}(UnionType));\nexports.TaggedUnionType = TaggedUnionType;\n/**\n * Use `union` instead\n *\n * @since 1.3.0\n * @deprecated\n */\nexports.taggedUnion = function (tag, codecs, name\n// tslint:disable-next-line: deprecation\n) {\n    if (name === void 0) { name = getUnionName(codecs); }\n    var U = exports.union(codecs, name);\n    // tslint:disable-next-line: deprecation\n    if (U instanceof TaggedUnionType) {\n        return U;\n    }\n    else {\n        console.warn(\"[io-ts] Cannot build a tagged union for \" + name + \", returning a de-optimized union\");\n        // tslint:disable-next-line: deprecation\n        return new TaggedUnionType(name, U.is, U.validate, U.encode, codecs, tag);\n    }\n};\n/**\n * @since 1.1.0\n */\nvar ExactType = /** @class */ (function (_super) {\n    __extends(ExactType, _super);\n    function ExactType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        _this._tag = 'ExactType';\n        return _this;\n    }\n    return ExactType;\n}(Type));\nexports.ExactType = ExactType;\nvar getProps = function (codec) {\n    switch (codec._tag) {\n        case 'RefinementType':\n        case 'ReadonlyType':\n            return getProps(codec.type);\n        case 'InterfaceType':\n        case 'StrictType':\n        case 'PartialType':\n            return codec.props;\n        case 'IntersectionType':\n            return codec.types.reduce(function (props, type) { return Object.assign(props, getProps(type)); }, {});\n    }\n};\nvar stripKeys = function (o, props) {\n    var keys = Object.getOwnPropertyNames(o);\n    var shouldStrip = false;\n    var r = {};\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        if (!hasOwnProperty.call(props, key)) {\n            shouldStrip = true;\n        }\n        else {\n            r[key] = o[key];\n        }\n    }\n    return shouldStrip ? r : o;\n};\nvar getExactTypeName = function (codec) {\n    if (isInterfaceCodec(codec)) {\n        return \"{| \" + getNameFromProps(codec.props) + \" |}\";\n    }\n    else if (isPartialCodec(codec)) {\n        return getPartialTypeName(\"{| \" + getNameFromProps(codec.props) + \" |}\");\n    }\n    return \"Exact<\" + codec.name + \">\";\n};\n/**\n * Strips additional properties\n * @since 1.1.0\n */\nexports.exact = function (codec, name) {\n    if (name === void 0) { name = getExactTypeName(codec); }\n    var props = getProps(codec);\n    return new ExactType(name, codec.is, function (u, c) {\n        return exports.UnknownRecord.validate(u, c).chain(function () { return codec.validate(u, c).fold(Either_1.left, function (a) { return exports.success(stripKeys(a, props)); }); });\n    }, function (a) { return codec.encode(stripKeys(a, props)); }, codec);\n};\n/**\n * @since 1.0.0\n * @deprecated\n */\nexports.getValidationError /* istanbul ignore next */ = function (value, context) { return ({\n    value: value,\n    context: context\n}); };\n/**\n * @since 1.0.0\n * @deprecated\n */\nexports.getDefaultContext /* istanbul ignore next */ = function (decoder) { return [\n    { key: '', type: decoder }\n]; };\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar NeverType = /** @class */ (function (_super) {\n    __extends(NeverType, _super);\n    function NeverType() {\n        var _this = _super.call(this, 'never', function (_) { return false; }, function (u, c) { return exports.failure(u, c); }, \n        /* istanbul ignore next */\n        function () {\n            throw new Error('cannot encode never');\n        }) || this;\n        _this._tag = 'NeverType';\n        return _this;\n    }\n    return NeverType;\n}(Type));\nexports.NeverType = NeverType;\n/**\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nexports.never = new NeverType();\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar AnyType = /** @class */ (function (_super) {\n    __extends(AnyType, _super);\n    function AnyType() {\n        var _this = _super.call(this, 'any', function (_) { return true; }, exports.success, exports.identity) || this;\n        _this._tag = 'AnyType';\n        return _this;\n    }\n    return AnyType;\n}(Type));\nexports.AnyType = AnyType;\n/**\n * Use `unknown` instead\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nexports.any = new AnyType();\n/**\n * Use `UnknownRecord` instead\n * @since 1.0.0\n * @deprecated\n */\nexports.Dictionary = exports.UnknownRecord;\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar ObjectType = /** @class */ (function (_super) {\n    __extends(ObjectType, _super);\n    function ObjectType() {\n        var _this = _super.call(this, 'object', exports.UnknownRecord.is, exports.UnknownRecord.validate, exports.identity) || this;\n        _this._tag = 'ObjectType';\n        return _this;\n    }\n    return ObjectType;\n}(Type));\nexports.ObjectType = ObjectType;\n/**\n * Use `UnknownRecord` instead\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nexports.object = new ObjectType();\n/**\n * Use `brand` instead\n * @since 1.0.0\n * @deprecated\n */\nfunction refinement(codec, predicate, name) {\n    if (name === void 0) { name = \"(\" + codec.name + \" | \" + exports.getFunctionName(predicate) + \")\"; }\n    return new RefinementType(name, function (u) { return codec.is(u) && predicate(u); }, function (i, c) { return codec.validate(i, c).chain(function (a) { return (predicate(a) ? exports.success(a) : exports.failure(a, c)); }); }, codec.encode, codec, predicate);\n}\nexports.refinement = refinement;\n/**\n * Use `Int` instead\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nexports.Integer = refinement(exports.number, Number.isInteger, 'Integer');\n/**\n * Use `record` instead\n * @since 1.0.0\n * @deprecated\n */\nexports.dictionary = exports.record;\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar StrictType = /** @class */ (function (_super) {\n    __extends(StrictType, _super);\n    function StrictType(name, \n    // tslint:disable-next-line: deprecation\n    is, \n    // tslint:disable-next-line: deprecation\n    validate, \n    // tslint:disable-next-line: deprecation\n    encode, props) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.props = props;\n        _this._tag = 'StrictType';\n        return _this;\n    }\n    return StrictType;\n}(Type));\nexports.StrictType = StrictType;\n/**\n * Drops the codec \"kind\"\n * @since 1.1.0\n * @deprecated\n */\nfunction clean(codec) {\n    return codec;\n}\nexports.clean = clean;\nfunction alias(codec) {\n    return function () { return codec; };\n}\nexports.alias = alias;\nvar isNonEmpty = function (as) { return as.length > 0; };\n/**\n * @internal\n */\nexports.emptyTags = {};\nfunction intersect(a, b) {\n    var r = [];\n    for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {\n        var v = a_1[_i];\n        if (b.indexOf(v) !== -1) {\n            r.push(v);\n        }\n    }\n    return r;\n}\nfunction mergeTags(a, b) {\n    if (a === exports.emptyTags) {\n        return b;\n    }\n    if (b === exports.emptyTags) {\n        return a;\n    }\n    var r = Object.assign({}, a);\n    for (var k in b) {\n        if (a.hasOwnProperty(k)) {\n            var intersection_1 = intersect(a[k], b[k]);\n            if (isNonEmpty(intersection_1)) {\n                r[k] = intersection_1;\n            }\n            else {\n                r = exports.emptyTags;\n                break;\n            }\n        }\n        else {\n            r[k] = b[k];\n        }\n    }\n    return r;\n}\nfunction intersectTags(a, b) {\n    if (a === exports.emptyTags || b === exports.emptyTags) {\n        return exports.emptyTags;\n    }\n    var r = exports.emptyTags;\n    for (var k in a) {\n        if (b.hasOwnProperty(k)) {\n            var intersection_2 = intersect(a[k], b[k]);\n            if (intersection_2.length === 0) {\n                if (r === exports.emptyTags) {\n                    r = {};\n                }\n                r[k] = a[k].concat(b[k]);\n            }\n        }\n    }\n    return r;\n}\nfunction isLiteralC(codec) {\n    return codec._tag === 'LiteralType';\n}\nfunction isTypeC(codec) {\n    return codec._tag === 'InterfaceType';\n}\n// tslint:disable-next-line: deprecation\nfunction isStrictC(codec) {\n    return codec._tag === 'StrictType';\n}\nfunction isExactC(codec) {\n    return codec._tag === 'ExactType';\n}\n// tslint:disable-next-line: deprecation\nfunction isRefinementC(codec) {\n    return codec._tag === 'RefinementType';\n}\nfunction isIntersectionC(codec) {\n    return codec._tag === 'IntersectionType';\n}\nfunction isUnionC(codec) {\n    return codec._tag === 'UnionType';\n}\nfunction isRecursiveC(codec) {\n    return codec._tag === 'RecursiveType';\n}\nvar lazyCodec = null;\n/**\n * @internal\n */\nfunction getTags(codec) {\n    if (codec === lazyCodec) {\n        return exports.emptyTags;\n    }\n    if (isTypeC(codec) || isStrictC(codec)) {\n        var index = exports.emptyTags;\n        // tslint:disable-next-line: forin\n        for (var k in codec.props) {\n            var prop = codec.props[k];\n            if (isLiteralC(prop)) {\n                if (index === exports.emptyTags) {\n                    index = {};\n                }\n                index[k] = [prop.value];\n            }\n        }\n        return index;\n    }\n    else if (isExactC(codec) || isRefinementC(codec)) {\n        return getTags(codec.type);\n    }\n    else if (isIntersectionC(codec)) {\n        return codec.types.reduce(function (tags, codec) { return mergeTags(tags, getTags(codec)); }, exports.emptyTags);\n    }\n    else if (isUnionC(codec)) {\n        return codec.types.slice(1).reduce(function (tags, codec) { return intersectTags(tags, getTags(codec)); }, getTags(codec.types[0]));\n    }\n    else if (isRecursiveC(codec)) {\n        lazyCodec = codec;\n        var tags = getTags(codec.type);\n        lazyCodec = null;\n        return tags;\n    }\n    return exports.emptyTags;\n}\nexports.getTags = getTags;\n/**\n * @internal\n */\nfunction getIndex(codecs) {\n    var tags = getTags(codecs[0]);\n    var keys = Object.keys(tags);\n    var len = codecs.length;\n    var _loop_6 = function (k) {\n        var all = tags[k].slice();\n        var index = [tags[k]];\n        for (var i = 1; i < len; i++) {\n            var codec = codecs[i];\n            var ctags = getTags(codec);\n            var values = ctags[k];\n            // tslint:disable-next-line: strict-type-predicates\n            if (values === undefined) {\n                return \"continue-keys\";\n            }\n            else {\n                if (values.some(function (v) { return all.indexOf(v) !== -1; })) {\n                    return \"continue-keys\";\n                }\n                else {\n                    all.push.apply(all, values);\n                    index.push(values);\n                }\n            }\n        }\n        return { value: [k, index] };\n    };\n    keys: for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var k = keys_1[_i];\n        var state_1 = _loop_6(k);\n        if (typeof state_1 === \"object\")\n            return state_1.value;\n        switch (state_1) {\n            case \"continue-keys\": continue keys;\n        }\n    }\n    return undefined;\n}\nexports.getIndex = getIndex;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW8tdHMvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLG1CQUFPLENBQUMscUZBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQix1REFBdUQsaURBQWlELDJCQUEyQixJQUFJLHlHQUF5RyxvQ0FBb0M7QUFDcFI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdDQUFnQztBQUNuRTtBQUNBO0FBQ0EsQ0FBQztBQUNELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZCQUE2QixVQUFVLHlCQUF5QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsK0JBQStCLGtEQUFrRDtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0Es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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCx5Q0FBeUM7QUFDcEc7QUFDQTtBQUNBLG9FQUFvRSw2Q0FBNkM7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywrQkFBK0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDBDQUEwQyxvQkFBb0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL2lvLXRzL2xpYi9pbmRleC5qcz9lZGJmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEVpdGhlcl8xID0gcmVxdWlyZShcImZwLXRzL2xpYi9FaXRoZXJcIik7XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG52YXIgVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUeXBlKFxuICAgIC8qKiBhIHVuaXF1ZSBuYW1lIGZvciB0aGlzIGNvZGVjICovXG4gICAgbmFtZSwgXG4gICAgLyoqIGEgY3VzdG9tIHR5cGUgZ3VhcmQgKi9cbiAgICBpcywgXG4gICAgLyoqIHN1Y2NlZWRzIGlmIGEgdmFsdWUgb2YgdHlwZSBJIGNhbiBiZSBkZWNvZGVkIHRvIGEgdmFsdWUgb2YgdHlwZSBBICovXG4gICAgdmFsaWRhdGUsIFxuICAgIC8qKiBjb252ZXJ0cyBhIHZhbHVlIG9mIHR5cGUgQSB0byBhIHZhbHVlIG9mIHR5cGUgTyAqL1xuICAgIGVuY29kZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmlzID0gaXM7XG4gICAgICAgIHRoaXMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbiAgICAgICAgdGhpcy5lbmNvZGUgPSBlbmNvZGU7XG4gICAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWNvZGUuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgVHlwZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChhYiwgbmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSBcInBpcGUoXCIgKyB0aGlzLm5hbWUgKyBcIiwgXCIgKyBhYi5uYW1lICsgXCIpXCI7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlKG5hbWUsIGFiLmlzLCBmdW5jdGlvbiAoaSwgYykgeyByZXR1cm4gX3RoaXMudmFsaWRhdGUoaSwgYykuY2hhaW4oZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFiLnZhbGlkYXRlKGEsIGMpOyB9KTsgfSwgdGhpcy5lbmNvZGUgPT09IGV4cG9ydHMuaWRlbnRpdHkgJiYgYWIuZW5jb2RlID09PSBleHBvcnRzLmlkZW50aXR5ID8gZXhwb3J0cy5pZGVudGl0eSA6IGZ1bmN0aW9uIChiKSB7IHJldHVybiBfdGhpcy5lbmNvZGUoYWIuZW5jb2RlKGIpKTsgfSk7XG4gICAgfTtcbiAgICBUeXBlLnByb3RvdHlwZS5hc0RlY29kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHlwZS5wcm90b3R5cGUuYXNFbmNvZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBhIHZlcnNpb24gb2YgYHZhbGlkYXRlYCB3aXRoIGEgZGVmYXVsdCBjb250ZXh0ICovXG4gICAgVHlwZS5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGUoaSwgW3sga2V5OiAnJywgdHlwZTogdGhpcywgYWN0dWFsOiBpIH1dKTtcbiAgICB9O1xuICAgIHJldHVybiBUeXBlO1xufSgpKTtcbmV4cG9ydHMuVHlwZSA9IFR5cGU7XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG5leHBvcnRzLmlkZW50aXR5ID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGE7IH07XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG5leHBvcnRzLmdldEZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGYuZGlzcGxheU5hbWUgfHwgZi5uYW1lIHx8IFwiPGZ1bmN0aW9uXCIgKyBmLmxlbmd0aCArIFwiPlwiO1xufTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydHMuZ2V0Q29udGV4dEVudHJ5ID0gZnVuY3Rpb24gKGtleSwgZGVjb2RlcikgeyByZXR1cm4gKHsga2V5OiBrZXksIHR5cGU6IGRlY29kZXIgfSk7IH07XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG5leHBvcnRzLmFwcGVuZENvbnRleHQgPSBmdW5jdGlvbiAoYywga2V5LCBkZWNvZGVyLCBhY3R1YWwpIHtcbiAgICB2YXIgbGVuID0gYy5sZW5ndGg7XG4gICAgdmFyIHIgPSBBcnJheShsZW4gKyAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJbaV0gPSBjW2ldO1xuICAgIH1cbiAgICByW2xlbl0gPSB7IGtleToga2V5LCB0eXBlOiBkZWNvZGVyLCBhY3R1YWw6IGFjdHVhbCB9O1xuICAgIHJldHVybiByO1xufTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydHMuZmFpbHVyZXMgPSBFaXRoZXJfMS5sZWZ0O1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xuZXhwb3J0cy5mYWlsdXJlID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZmFpbHVyZXMoW3sgdmFsdWU6IHZhbHVlLCBjb250ZXh0OiBjb250ZXh0LCBtZXNzYWdlOiBtZXNzYWdlIH1dKTtcbn07XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG5leHBvcnRzLnN1Y2Nlc3MgPSBFaXRoZXJfMS5yaWdodDtcbnZhciBwdXNoQWxsID0gZnVuY3Rpb24gKHhzLCB5cykge1xuICAgIHZhciBsID0geXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHhzLnB1c2goeXNbaV0pO1xuICAgIH1cbn07XG52YXIgZ2V0SXNDb2RlYyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIGZ1bmN0aW9uIChjb2RlYykgeyByZXR1cm4gY29kZWMuX3RhZyA9PT0gdGFnOyB9OyB9O1xudmFyIGlzVW5rbm93bkNvZGVjID0gZ2V0SXNDb2RlYygnVW5rbm93blR5cGUnKTtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGVwcmVjYXRpb25cbnZhciBpc0FueUNvZGVjID0gZ2V0SXNDb2RlYygnQW55VHlwZScpO1xudmFyIGlzSW50ZXJmYWNlQ29kZWMgPSBnZXRJc0NvZGVjKCdJbnRlcmZhY2VUeXBlJyk7XG52YXIgaXNQYXJ0aWFsQ29kZWMgPSBnZXRJc0NvZGVjKCdQYXJ0aWFsVHlwZScpO1xuLy9cbi8vIGJhc2ljIHR5cGVzXG4vL1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xudmFyIE51bGxUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOdWxsVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOdWxsVHlwZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ251bGwnLCBmdW5jdGlvbiAodSkgeyByZXR1cm4gdSA9PT0gbnVsbDsgfSwgZnVuY3Rpb24gKHUsIGMpIHsgcmV0dXJuIChfdGhpcy5pcyh1KSA/IGV4cG9ydHMuc3VjY2Vzcyh1KSA6IGV4cG9ydHMuZmFpbHVyZSh1LCBjKSk7IH0sIGV4cG9ydHMuaWRlbnRpdHkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl90YWcgPSAnTnVsbFR5cGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBOdWxsVHlwZTtcbn0oVHlwZSkpO1xuZXhwb3J0cy5OdWxsVHlwZSA9IE51bGxUeXBlO1xuLyoqXG4gKiBAYWxpYXMgYG51bGxgXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xuZXhwb3J0cy5udWxsVHlwZSA9IG5ldyBOdWxsVHlwZSgpO1xuZXhwb3J0cy5udWxsID0gZXhwb3J0cy5udWxsVHlwZTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbnZhciBVbmRlZmluZWRUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVbmRlZmluZWRUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFVuZGVmaW5lZFR5cGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICd1bmRlZmluZWQnLCBmdW5jdGlvbiAodSkgeyByZXR1cm4gdSA9PT0gdm9pZCAwOyB9LCBmdW5jdGlvbiAodSwgYykgeyByZXR1cm4gKF90aGlzLmlzKHUpID8gZXhwb3J0cy5zdWNjZXNzKHUpIDogZXhwb3J0cy5mYWlsdXJlKHUsIGMpKTsgfSwgZXhwb3J0cy5pZGVudGl0eSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3RhZyA9ICdVbmRlZmluZWRUeXBlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVW5kZWZpbmVkVHlwZTtcbn0oVHlwZSkpO1xuZXhwb3J0cy5VbmRlZmluZWRUeXBlID0gVW5kZWZpbmVkVHlwZTtcbnZhciB1bmRlZmluZWRUeXBlID0gbmV3IFVuZGVmaW5lZFR5cGUoKTtcbmV4cG9ydHMudW5kZWZpbmVkID0gdW5kZWZpbmVkVHlwZTtcbi8qKlxuICogQHNpbmNlIDEuMi4wXG4gKi9cbnZhciBWb2lkVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVm9pZFR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVm9pZFR5cGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICd2b2lkJywgdW5kZWZpbmVkVHlwZS5pcywgdW5kZWZpbmVkVHlwZS52YWxpZGF0ZSwgZXhwb3J0cy5pZGVudGl0eSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3RhZyA9ICdWb2lkVHlwZSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFZvaWRUeXBlO1xufShUeXBlKSk7XG5leHBvcnRzLlZvaWRUeXBlID0gVm9pZFR5cGU7XG4vKipcbiAqIEBhbGlhcyBgdm9pZGBcbiAqIEBzaW5jZSAxLjIuMFxuICovXG5leHBvcnRzLnZvaWRUeXBlID0gbmV3IFZvaWRUeXBlKCk7XG5leHBvcnRzLnZvaWQgPSBleHBvcnRzLnZvaWRUeXBlO1xuLyoqXG4gKiBAc2luY2UgMS41LjBcbiAqL1xudmFyIFVua25vd25UeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVbmtub3duVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVbmtub3duVHlwZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ3Vua25vd24nLCBmdW5jdGlvbiAoXykgeyByZXR1cm4gdHJ1ZTsgfSwgZXhwb3J0cy5zdWNjZXNzLCBleHBvcnRzLmlkZW50aXR5KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fdGFnID0gJ1Vua25vd25UeXBlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVW5rbm93blR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydHMuVW5rbm93blR5cGUgPSBVbmtub3duVHlwZTtcbi8qKlxuICogQHNpbmNlIDEuNS4wXG4gKi9cbmV4cG9ydHMudW5rbm93biA9IG5ldyBVbmtub3duVHlwZSgpO1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xudmFyIFN0cmluZ1R5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0cmluZ1R5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RyaW5nVHlwZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ3N0cmluZycsIGZ1bmN0aW9uICh1KSB7IHJldHVybiB0eXBlb2YgdSA9PT0gJ3N0cmluZyc7IH0sIGZ1bmN0aW9uICh1LCBjKSB7IHJldHVybiAoX3RoaXMuaXModSkgPyBleHBvcnRzLnN1Y2Nlc3ModSkgOiBleHBvcnRzLmZhaWx1cmUodSwgYykpOyB9LCBleHBvcnRzLmlkZW50aXR5KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fdGFnID0gJ1N0cmluZ1R5cGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmdUeXBlO1xufShUeXBlKSk7XG5leHBvcnRzLlN0cmluZ1R5cGUgPSBTdHJpbmdUeXBlO1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xuZXhwb3J0cy5zdHJpbmcgPSBuZXcgU3RyaW5nVHlwZSgpO1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xudmFyIE51bWJlclR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE51bWJlclR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTnVtYmVyVHlwZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ251bWJlcicsIGZ1bmN0aW9uICh1KSB7IHJldHVybiB0eXBlb2YgdSA9PT0gJ251bWJlcic7IH0sIGZ1bmN0aW9uICh1LCBjKSB7IHJldHVybiAoX3RoaXMuaXModSkgPyBleHBvcnRzLnN1Y2Nlc3ModSkgOiBleHBvcnRzLmZhaWx1cmUodSwgYykpOyB9LCBleHBvcnRzLmlkZW50aXR5KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fdGFnID0gJ051bWJlclR5cGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXJUeXBlO1xufShUeXBlKSk7XG5leHBvcnRzLk51bWJlclR5cGUgPSBOdW1iZXJUeXBlO1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xuZXhwb3J0cy5udW1iZXIgPSBuZXcgTnVtYmVyVHlwZSgpO1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xudmFyIEJvb2xlYW5UeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCb29sZWFuVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCb29sZWFuVHlwZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ2Jvb2xlYW4nLCBmdW5jdGlvbiAodSkgeyByZXR1cm4gdHlwZW9mIHUgPT09ICdib29sZWFuJzsgfSwgZnVuY3Rpb24gKHUsIGMpIHsgcmV0dXJuIChfdGhpcy5pcyh1KSA/IGV4cG9ydHMuc3VjY2Vzcyh1KSA6IGV4cG9ydHMuZmFpbHVyZSh1LCBjKSk7IH0sIGV4cG9ydHMuaWRlbnRpdHkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl90YWcgPSAnQm9vbGVhblR5cGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBCb29sZWFuVHlwZTtcbn0oVHlwZSkpO1xuZXhwb3J0cy5Cb29sZWFuVHlwZSA9IEJvb2xlYW5UeXBlO1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xuZXhwb3J0cy5ib29sZWFuID0gbmV3IEJvb2xlYW5UeXBlKCk7XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG52YXIgQW55QXJyYXlUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBbnlBcnJheVR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQW55QXJyYXlUeXBlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAnVW5rbm93bkFycmF5JywgQXJyYXkuaXNBcnJheSwgZnVuY3Rpb24gKHUsIGMpIHsgcmV0dXJuIChfdGhpcy5pcyh1KSA/IGV4cG9ydHMuc3VjY2Vzcyh1KSA6IGV4cG9ydHMuZmFpbHVyZSh1LCBjKSk7IH0sIGV4cG9ydHMuaWRlbnRpdHkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl90YWcgPSAnQW55QXJyYXlUeXBlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQW55QXJyYXlUeXBlO1xufShUeXBlKSk7XG5leHBvcnRzLkFueUFycmF5VHlwZSA9IEFueUFycmF5VHlwZTtcbi8qKlxuICogQHNpbmNlIDEuNy4xXG4gKi9cbmV4cG9ydHMuVW5rbm93bkFycmF5ID0gbmV3IEFueUFycmF5VHlwZSgpO1xuZXhwb3J0cy5BcnJheSA9IGV4cG9ydHMuVW5rbm93bkFycmF5O1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xudmFyIEFueURpY3Rpb25hcnlUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBbnlEaWN0aW9uYXJ5VHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBbnlEaWN0aW9uYXJ5VHlwZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ1Vua25vd25SZWNvcmQnLCBmdW5jdGlvbiAodSkgeyByZXR1cm4gdSAhPT0gbnVsbCAmJiB0eXBlb2YgdSA9PT0gJ29iamVjdCc7IH0sIGZ1bmN0aW9uICh1LCBjKSB7IHJldHVybiAoX3RoaXMuaXModSkgPyBleHBvcnRzLnN1Y2Nlc3ModSkgOiBleHBvcnRzLmZhaWx1cmUodSwgYykpOyB9LCBleHBvcnRzLmlkZW50aXR5KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fdGFnID0gJ0FueURpY3Rpb25hcnlUeXBlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQW55RGljdGlvbmFyeVR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydHMuQW55RGljdGlvbmFyeVR5cGUgPSBBbnlEaWN0aW9uYXJ5VHlwZTtcbi8qKlxuICogQHNpbmNlIDEuNy4xXG4gKi9cbmV4cG9ydHMuVW5rbm93blJlY29yZCA9IG5ldyBBbnlEaWN0aW9uYXJ5VHlwZSgpO1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbnZhciBGdW5jdGlvblR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZ1bmN0aW9uVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGdW5jdGlvblR5cGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICdGdW5jdGlvbicsIFxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6c3RyaWN0LXR5cGUtcHJlZGljYXRlc1xuICAgICAgICBmdW5jdGlvbiAodSkgeyByZXR1cm4gdHlwZW9mIHUgPT09ICdmdW5jdGlvbic7IH0sIGZ1bmN0aW9uICh1LCBjKSB7IHJldHVybiAoX3RoaXMuaXModSkgPyBleHBvcnRzLnN1Y2Nlc3ModSkgOiBleHBvcnRzLmZhaWx1cmUodSwgYykpOyB9LCBleHBvcnRzLmlkZW50aXR5KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fdGFnID0gJ0Z1bmN0aW9uVHlwZSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEZ1bmN0aW9uVHlwZTtcbn0oVHlwZSkpO1xuZXhwb3J0cy5GdW5jdGlvblR5cGUgPSBGdW5jdGlvblR5cGU7XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBkZXByZWNhdGlvblxuZXhwb3J0cy5GdW5jdGlvbiA9IG5ldyBGdW5jdGlvblR5cGUoKTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbnZhciBSZWZpbmVtZW50VHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVmaW5lbWVudFR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVmaW5lbWVudFR5cGUobmFtZSwgaXMsIHZhbGlkYXRlLCBlbmNvZGUsIHR5cGUsIHByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIF90aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgX3RoaXMuX3RhZyA9ICdSZWZpbmVtZW50VHlwZSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJlZmluZW1lbnRUeXBlO1xufShUeXBlKSk7XG5leHBvcnRzLlJlZmluZW1lbnRUeXBlID0gUmVmaW5lbWVudFR5cGU7XG4vKipcbiAqIEBzaW5jZSAxLjguMVxuICovXG5leHBvcnRzLmJyYW5kID0gZnVuY3Rpb24gKGNvZGVjLCBwcmVkaWNhdGUsIG5hbWUpIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGRlcHJlY2F0aW9uXG4gICAgcmV0dXJuIHJlZmluZW1lbnQoY29kZWMsIHByZWRpY2F0ZSwgbmFtZSk7XG59O1xuLyoqXG4gKiBBIGJyYW5kZWQgY29kZWMgcmVwcmVzZW50aW5nIGFuIGludGVnZXJcbiAqIEBzaW5jZSAxLjguMVxuICovXG5leHBvcnRzLkludCA9IGV4cG9ydHMuYnJhbmQoZXhwb3J0cy5udW1iZXIsIGZ1bmN0aW9uIChuKSB7IHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKG4pOyB9LCAnSW50Jyk7XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG52YXIgTGl0ZXJhbFR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpdGVyYWxUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpdGVyYWxUeXBlKG5hbWUsIGlzLCB2YWxpZGF0ZSwgZW5jb2RlLCB2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgX3RoaXMuX3RhZyA9ICdMaXRlcmFsVHlwZSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIExpdGVyYWxUeXBlO1xufShUeXBlKSk7XG5leHBvcnRzLkxpdGVyYWxUeXBlID0gTGl0ZXJhbFR5cGU7XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG5leHBvcnRzLmxpdGVyYWwgPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7IH1cbiAgICB2YXIgaXMgPSBmdW5jdGlvbiAodSkgeyByZXR1cm4gdSA9PT0gdmFsdWU7IH07XG4gICAgcmV0dXJuIG5ldyBMaXRlcmFsVHlwZShuYW1lLCBpcywgZnVuY3Rpb24gKHUsIGMpIHsgcmV0dXJuIChpcyh1KSA/IGV4cG9ydHMuc3VjY2Vzcyh2YWx1ZSkgOiBleHBvcnRzLmZhaWx1cmUodSwgYykpOyB9LCBleHBvcnRzLmlkZW50aXR5LCB2YWx1ZSk7XG59O1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xudmFyIEtleW9mVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoS2V5b2ZUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEtleW9mVHlwZShuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSwga2V5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMua2V5cyA9IGtleXM7XG4gICAgICAgIF90aGlzLl90YWcgPSAnS2V5b2ZUeXBlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gS2V5b2ZUeXBlO1xufShUeXBlKSk7XG5leHBvcnRzLktleW9mVHlwZSA9IEtleW9mVHlwZTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG5leHBvcnRzLmtleW9mID0gZnVuY3Rpb24gKGtleXMsIG5hbWUpIHtcbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSBPYmplY3Qua2V5cyhrZXlzKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBKU09OLnN0cmluZ2lmeShrKTsgfSlcbiAgICAgICAgLmpvaW4oJyB8ICcpOyB9XG4gICAgdmFyIGlzID0gZnVuY3Rpb24gKHUpIHsgcmV0dXJuIGV4cG9ydHMuc3RyaW5nLmlzKHUpICYmIGhhc093blByb3BlcnR5LmNhbGwoa2V5cywgdSk7IH07XG4gICAgcmV0dXJuIG5ldyBLZXlvZlR5cGUobmFtZSwgaXMsIGZ1bmN0aW9uICh1LCBjKSB7IHJldHVybiAoaXModSkgPyBleHBvcnRzLnN1Y2Nlc3ModSkgOiBleHBvcnRzLmZhaWx1cmUodSwgYykpOyB9LCBleHBvcnRzLmlkZW50aXR5LCBrZXlzKTtcbn07XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG52YXIgUmVjdXJzaXZlVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVjdXJzaXZlVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWN1cnNpdmVUeXBlKG5hbWUsIGlzLCB2YWxpZGF0ZSwgZW5jb2RlLCBydW5EZWZpbml0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIGlzLCB2YWxpZGF0ZSwgZW5jb2RlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5ydW5EZWZpbml0aW9uID0gcnVuRGVmaW5pdGlvbjtcbiAgICAgICAgX3RoaXMuX3RhZyA9ICdSZWN1cnNpdmVUeXBlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVjdXJzaXZlVHlwZS5wcm90b3R5cGUsIFwidHlwZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVuRGVmaW5pdGlvbigpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gUmVjdXJzaXZlVHlwZTtcbn0oVHlwZSkpO1xuZXhwb3J0cy5SZWN1cnNpdmVUeXBlID0gUmVjdXJzaXZlVHlwZTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydHMucmVjdXJzaW9uID0gZnVuY3Rpb24gKG5hbWUsIGRlZmluaXRpb24pIHtcbiAgICB2YXIgY2FjaGU7XG4gICAgdmFyIHJ1bkRlZmluaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghY2FjaGUpIHtcbiAgICAgICAgICAgIGNhY2hlID0gZGVmaW5pdGlvbihTZWxmKTtcbiAgICAgICAgICAgIGNhY2hlLm5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9O1xuICAgIHZhciBTZWxmID0gbmV3IFJlY3Vyc2l2ZVR5cGUobmFtZSwgZnVuY3Rpb24gKHUpIHsgcmV0dXJuIHJ1bkRlZmluaXRpb24oKS5pcyh1KTsgfSwgZnVuY3Rpb24gKHUsIGMpIHsgcmV0dXJuIHJ1bkRlZmluaXRpb24oKS52YWxpZGF0ZSh1LCBjKTsgfSwgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHJ1bkRlZmluaXRpb24oKS5lbmNvZGUoYSk7IH0sIHJ1bkRlZmluaXRpb24pO1xuICAgIHJldHVybiBTZWxmO1xufTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbnZhciBBcnJheVR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5VHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcnJheVR5cGUobmFtZSwgaXMsIHZhbGlkYXRlLCBlbmNvZGUsIHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgaXMsIHZhbGlkYXRlLCBlbmNvZGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICBfdGhpcy5fdGFnID0gJ0FycmF5VHlwZSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5VHlwZTtcbn0oVHlwZSkpO1xuZXhwb3J0cy5BcnJheVR5cGUgPSBBcnJheVR5cGU7XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG5leHBvcnRzLmFycmF5ID0gZnVuY3Rpb24gKGNvZGVjLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gXCJBcnJheTxcIiArIGNvZGVjLm5hbWUgKyBcIj5cIjsgfVxuICAgIHJldHVybiBuZXcgQXJyYXlUeXBlKG5hbWUsIGZ1bmN0aW9uICh1KSB7IHJldHVybiBleHBvcnRzLlVua25vd25BcnJheS5pcyh1KSAmJiB1LmV2ZXJ5KGNvZGVjLmlzKTsgfSwgZnVuY3Rpb24gKHUsIGMpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuVW5rbm93bkFycmF5LnZhbGlkYXRlKHUsIGMpLmNoYWluKGZ1bmN0aW9uICh1cykge1xuICAgICAgICAgICAgdmFyIGxlbiA9IHVzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBhcyA9IHVzO1xuICAgICAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHZhciB1aSA9IHVzW2ldO1xuICAgICAgICAgICAgICAgIGNvZGVjLnZhbGlkYXRlKHVpLCBleHBvcnRzLmFwcGVuZENvbnRleHQoYywgU3RyaW5nKGkpLCBjb2RlYywgdWkpKS5mb2xkKGZ1bmN0aW9uIChlKSB7IHJldHVybiBwdXNoQWxsKGVycm9ycywgZSk7IH0sIGZ1bmN0aW9uIChhaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWkgIT09IHVpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXMgPT09IHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXMgPSB1cy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXNbaV0gPSBhaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPiAwID8gZXhwb3J0cy5mYWlsdXJlcyhlcnJvcnMpIDogZXhwb3J0cy5zdWNjZXNzKGFzKTtcbiAgICAgICAgfSk7XG4gICAgfSwgY29kZWMuZW5jb2RlID09PSBleHBvcnRzLmlkZW50aXR5ID8gZXhwb3J0cy5pZGVudGl0eSA6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLm1hcChjb2RlYy5lbmNvZGUpOyB9LCBjb2RlYyk7XG59O1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xudmFyIEludGVyZmFjZVR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEludGVyZmFjZVR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW50ZXJmYWNlVHlwZShuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSwgcHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgaXMsIHZhbGlkYXRlLCBlbmNvZGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIF90aGlzLl90YWcgPSAnSW50ZXJmYWNlVHlwZSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEludGVyZmFjZVR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydHMuSW50ZXJmYWNlVHlwZSA9IEludGVyZmFjZVR5cGU7XG52YXIgZ2V0TmFtZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhwcm9wcylcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gayArIFwiOiBcIiArIHByb3BzW2tdLm5hbWU7IH0pXG4gICAgICAgIC5qb2luKCcsICcpO1xufTtcbnZhciB1c2VJZGVudGl0eSA9IGZ1bmN0aW9uIChjb2RlY3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZGVjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY29kZWNzW2ldLmVuY29kZSAhPT0gZXhwb3J0cy5pZGVudGl0eSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbnZhciBnZXRJbnRlcmZhY2VUeXBlTmFtZSA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHJldHVybiBcInsgXCIgKyBnZXROYW1lRnJvbVByb3BzKHByb3BzKSArIFwiIH1cIjtcbn07XG4vKipcbiAqIEBhbGlhcyBgaW50ZXJmYWNlYFxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydHMudHlwZSA9IGZ1bmN0aW9uIChwcm9wcywgbmFtZSkge1xuICAgIGlmIChuYW1lID09PSB2b2lkIDApIHsgbmFtZSA9IGdldEludGVyZmFjZVR5cGVOYW1lKHByb3BzKTsgfVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpO1xuICAgIHZhciB0eXBlcyA9IGtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHByb3BzW2tleV07IH0pO1xuICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICByZXR1cm4gbmV3IEludGVyZmFjZVR5cGUobmFtZSwgZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgaWYgKCFleHBvcnRzLlVua25vd25SZWNvcmQuaXModSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgayA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwodSwgaykgfHwgIXR5cGVzW2ldLmlzKHVba10pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIGZ1bmN0aW9uICh1LCBjKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlVua25vd25SZWNvcmQudmFsaWRhdGUodSwgYykuY2hhaW4oZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhID0gbztcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBfbG9vcF8yID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgayA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhID09PSBvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gX19hc3NpZ24oe30sIG8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFba10gPSBhW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYWsgPSBhW2tdO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlXzEgPSB0eXBlc1tpXTtcbiAgICAgICAgICAgICAgICB0eXBlXzEudmFsaWRhdGUoYWssIGV4cG9ydHMuYXBwZW5kQ29udGV4dChjLCBrLCB0eXBlXzEsIGFrKSkuZm9sZChmdW5jdGlvbiAoZSkgeyByZXR1cm4gcHVzaEFsbChlcnJvcnMsIGUpOyB9LCBmdW5jdGlvbiAodmFrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWsgIT09IGFrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgPT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gX19hc3NpZ24oe30sIG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYVtrXSA9IHZhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcF8yKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPiAwID8gZXhwb3J0cy5mYWlsdXJlcyhlcnJvcnMpIDogZXhwb3J0cy5zdWNjZXNzKGEpO1xuICAgICAgICB9KTtcbiAgICB9LCB1c2VJZGVudGl0eSh0eXBlcylcbiAgICAgICAgPyBleHBvcnRzLmlkZW50aXR5XG4gICAgICAgIDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHZhciBzID0gX19hc3NpZ24oe30sIGEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgZW5jb2RlID0gdHlwZXNbaV0uZW5jb2RlO1xuICAgICAgICAgICAgICAgIGlmIChlbmNvZGUgIT09IGV4cG9ydHMuaWRlbnRpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgc1trXSA9IGVuY29kZShhW2tdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSwgcHJvcHMpO1xufTtcbmV4cG9ydHMuaW50ZXJmYWNlID0gZXhwb3J0cy50eXBlO1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xudmFyIFBhcnRpYWxUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYXJ0aWFsVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXJ0aWFsVHlwZShuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSwgcHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgaXMsIHZhbGlkYXRlLCBlbmNvZGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIF90aGlzLl90YWcgPSAnUGFydGlhbFR5cGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYXJ0aWFsVHlwZTtcbn0oVHlwZSkpO1xuZXhwb3J0cy5QYXJ0aWFsVHlwZSA9IFBhcnRpYWxUeXBlO1xudmFyIGdldFBhcnRpYWxUeXBlTmFtZSA9IGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBcIlBhcnRpYWw8XCIgKyBpbm5lciArIFwiPlwiO1xufTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydHMucGFydGlhbCA9IGZ1bmN0aW9uIChwcm9wcywgbmFtZSkge1xuICAgIGlmIChuYW1lID09PSB2b2lkIDApIHsgbmFtZSA9IGdldFBhcnRpYWxUeXBlTmFtZShnZXRJbnRlcmZhY2VUeXBlTmFtZShwcm9wcykpOyB9XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcyk7XG4gICAgdmFyIHR5cGVzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gcHJvcHNba2V5XTsgfSk7XG4gICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIHJldHVybiBuZXcgUGFydGlhbFR5cGUobmFtZSwgZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgaWYgKCFleHBvcnRzLlVua25vd25SZWNvcmQuaXModSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgayA9IGtleXNbaV07XG4gICAgICAgICAgICB2YXIgdWsgPSB1W2tdO1xuICAgICAgICAgICAgaWYgKHVrICE9PSB1bmRlZmluZWQgJiYgIXByb3BzW2tdLmlzKHVrKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCBmdW5jdGlvbiAodSwgYykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5Vbmtub3duUmVjb3JkLnZhbGlkYXRlKHUsIGMpLmNoYWluKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYSA9IG87XG4gICAgICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgICAgICB2YXIgX2xvb3BfMyA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBhayA9IGFba107XG4gICAgICAgICAgICAgICAgdmFyIHR5cGVfMiA9IHByb3BzW2tdO1xuICAgICAgICAgICAgICAgIHR5cGVfMi52YWxpZGF0ZShhaywgZXhwb3J0cy5hcHBlbmRDb250ZXh0KGMsIGssIHR5cGVfMiwgYWspKS5mb2xkKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoQWxsKGVycm9ycywgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAodmFrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWsgIT09IGFrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgPT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gX19hc3NpZ24oe30sIG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYVtrXSA9IHZhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcF8zKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPiAwID8gZXhwb3J0cy5mYWlsdXJlcyhlcnJvcnMpIDogZXhwb3J0cy5zdWNjZXNzKGEpO1xuICAgICAgICB9KTtcbiAgICB9LCB1c2VJZGVudGl0eSh0eXBlcylcbiAgICAgICAgPyBleHBvcnRzLmlkZW50aXR5XG4gICAgICAgIDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHZhciBzID0gX19hc3NpZ24oe30sIGEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgYWsgPSBhW2tdO1xuICAgICAgICAgICAgICAgIGlmIChhayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNba10gPSB0eXBlc1tpXS5lbmNvZGUoYWspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9LCBwcm9wcyk7XG59O1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xudmFyIERpY3Rpb25hcnlUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWN0aW9uYXJ5VHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaWN0aW9uYXJ5VHlwZShuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSwgZG9tYWluLCBjb2RvbWFpbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZG9tYWluID0gZG9tYWluO1xuICAgICAgICBfdGhpcy5jb2RvbWFpbiA9IGNvZG9tYWluO1xuICAgICAgICBfdGhpcy5fdGFnID0gJ0RpY3Rpb25hcnlUeXBlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRGljdGlvbmFyeVR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydHMuRGljdGlvbmFyeVR5cGUgPSBEaWN0aW9uYXJ5VHlwZTtcbnZhciBpc09iamVjdCA9IGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocikgPT09ICdbb2JqZWN0IE9iamVjdF0nOyB9O1xuLyoqXG4gKiBAc2luY2UgMS43LjFcbiAqL1xuZXhwb3J0cy5yZWNvcmQgPSBmdW5jdGlvbiAoZG9tYWluLCBjb2RvbWFpbiwgbmFtZSkge1xuICAgIGlmIChuYW1lID09PSB2b2lkIDApIHsgbmFtZSA9IFwieyBbSyBpbiBcIiArIGRvbWFpbi5uYW1lICsgXCJdOiBcIiArIGNvZG9tYWluLm5hbWUgKyBcIiB9XCI7IH1cbiAgICByZXR1cm4gbmV3IERpY3Rpb25hcnlUeXBlKG5hbWUsIGZ1bmN0aW9uICh1KSB7XG4gICAgICAgIGlmICghZXhwb3J0cy5Vbmtub3duUmVjb3JkLmlzKHUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1Vua25vd25Db2RlYyhjb2RvbWFpbikgJiYgIWlzQW55Q29kZWMoY29kb21haW4pICYmICFpc09iamVjdCh1KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh1KS5ldmVyeShmdW5jdGlvbiAoaykgeyByZXR1cm4gZG9tYWluLmlzKGspICYmIGNvZG9tYWluLmlzKHVba10pOyB9KTtcbiAgICB9LCBmdW5jdGlvbiAodSwgYykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5Vbmtub3duUmVjb3JkLnZhbGlkYXRlKHUsIGMpLmNoYWluKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICBpZiAoIWlzVW5rbm93bkNvZGVjKGNvZG9tYWluKSAmJiAhaXNBbnlDb2RlYyhjb2RvbWFpbikgJiYgIWlzT2JqZWN0KG8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuZmFpbHVyZSh1LCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhID0ge307XG4gICAgICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG8pO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBfbG9vcF80ID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgayA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIG9rID0gb1trXTtcbiAgICAgICAgICAgICAgICBkb21haW4udmFsaWRhdGUoaywgZXhwb3J0cy5hcHBlbmRDb250ZXh0KGMsIGssIGRvbWFpbiwgaykpLmZvbGQoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHB1c2hBbGwoZXJyb3JzLCBlKTsgfSwgZnVuY3Rpb24gKHZrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IHZrICE9PSBrO1xuICAgICAgICAgICAgICAgICAgICBrID0gdms7XG4gICAgICAgICAgICAgICAgICAgIGNvZG9tYWluLnZhbGlkYXRlKG9rLCBleHBvcnRzLmFwcGVuZENvbnRleHQoYywgaywgY29kb21haW4sIG9rKSkuZm9sZChmdW5jdGlvbiAoZSkgeyByZXR1cm4gcHVzaEFsbChlcnJvcnMsIGUpOyB9LCBmdW5jdGlvbiAodm9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCB2b2sgIT09IG9rO1xuICAgICAgICAgICAgICAgICAgICAgICAgYVtrXSA9IHZvaztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIF9sb29wXzQoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JzLmxlbmd0aCA+IDAgPyBleHBvcnRzLmZhaWx1cmVzKGVycm9ycykgOiBleHBvcnRzLnN1Y2Nlc3MoKGNoYW5nZWQgPyBhIDogbykpO1xuICAgICAgICB9KTtcbiAgICB9LCBkb21haW4uZW5jb2RlID09PSBleHBvcnRzLmlkZW50aXR5ICYmIGNvZG9tYWluLmVuY29kZSA9PT0gZXhwb3J0cy5pZGVudGl0eVxuICAgICAgICA/IGV4cG9ydHMuaWRlbnRpdHlcbiAgICAgICAgOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgdmFyIHMgPSB7fTtcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgICAgICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIHNbU3RyaW5nKGRvbWFpbi5lbmNvZGUoaykpXSA9IGNvZG9tYWluLmVuY29kZShhW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9LCBkb21haW4sIGNvZG9tYWluKTtcbn07XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG52YXIgVW5pb25UeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVbmlvblR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVW5pb25UeXBlKG5hbWUsIGlzLCB2YWxpZGF0ZSwgZW5jb2RlLCB0eXBlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgX3RoaXMuX3RhZyA9ICdVbmlvblR5cGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBVbmlvblR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydHMuVW5pb25UeXBlID0gVW5pb25UeXBlO1xudmFyIGdldFVuaW9uTmFtZSA9IGZ1bmN0aW9uIChjb2RlY3MpIHtcbiAgICByZXR1cm4gJygnICsgY29kZWNzLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZS5uYW1lOyB9KS5qb2luKCcgfCAnKSArICcpJztcbn07XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG5leHBvcnRzLnVuaW9uID0gZnVuY3Rpb24gKGNvZGVjcywgbmFtZSkge1xuICAgIGlmIChuYW1lID09PSB2b2lkIDApIHsgbmFtZSA9IGdldFVuaW9uTmFtZShjb2RlY3MpOyB9XG4gICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgoY29kZWNzKTtcbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBjb2RlY3MubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdGFnXzEgPSBpbmRleFswXSwgZ3JvdXBzXzEgPSBpbmRleFsxXTtcbiAgICAgICAgdmFyIGxlbl8xID0gZ3JvdXBzXzEubGVuZ3RoO1xuICAgICAgICB2YXIgZmluZF8xID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbl8xOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBzXzFbaV0uaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGVwcmVjYXRpb25cbiAgICAgICAgcmV0dXJuIG5ldyBUYWdnZWRVbmlvblR5cGUobmFtZSwgZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgICAgIGlmICghZXhwb3J0cy5Vbmtub3duUmVjb3JkLmlzKHUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGkgPSBmaW5kXzEodVt0YWdfMV0pO1xuICAgICAgICAgICAgcmV0dXJuIGkgIT09IHVuZGVmaW5lZCA/IGNvZGVjc1tpXS5pcyh1KSA6IGZhbHNlO1xuICAgICAgICB9LCBmdW5jdGlvbiAodSwgYykge1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuVW5rbm93blJlY29yZC52YWxpZGF0ZSh1LCBjKS5jaGFpbihmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgIHZhciBpID0gZmluZF8xKHJbdGFnXzFdKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLmZhaWx1cmUodSwgYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb2RlYyA9IGNvZGVjc1tpXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZWMudmFsaWRhdGUociwgZXhwb3J0cy5hcHBlbmRDb250ZXh0KGMsIFN0cmluZyhpKSwgY29kZWMsIHIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB1c2VJZGVudGl0eShjb2RlY3MpXG4gICAgICAgICAgICA/IGV4cG9ydHMuaWRlbnRpdHlcbiAgICAgICAgICAgIDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGZpbmRfMShhW3RhZ18xXSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2NhbnRpL2lvLXRzL3B1bGwvMzA1XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIGNvZGVjIGZvdW5kIHRvIGVuY29kZSB2YWx1ZSBpbiB1bmlvbiBjb2RlYyBcIiArIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVjc1tpXS5lbmNvZGUoYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgY29kZWNzLCB0YWdfMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFVuaW9uVHlwZShuYW1lLCBmdW5jdGlvbiAodSkgeyByZXR1cm4gY29kZWNzLnNvbWUoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHR5cGUuaXModSk7IH0pOyB9LCBmdW5jdGlvbiAodSwgYykge1xuICAgICAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2RlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZWMgPSBjb2RlY3NbaV07XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBjb2RlY1xuICAgICAgICAgICAgICAgICAgICAudmFsaWRhdGUodSwgZXhwb3J0cy5hcHBlbmRDb250ZXh0KGMsIFN0cmluZyhpKSwgY29kZWMsIHUpKVxuICAgICAgICAgICAgICAgICAgICAuZm9sZChmdW5jdGlvbiAoZSkgeyByZXR1cm4gcHVzaEFsbChlcnJvcnMsIGUpOyB9LCBleHBvcnRzLnN1Y2Nlc3MpO1xuICAgICAgICAgICAgICAgIGlmIChyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuZmFpbHVyZXMoZXJyb3JzKTtcbiAgICAgICAgfSwgdXNlSWRlbnRpdHkoY29kZWNzKVxuICAgICAgICAgICAgPyBleHBvcnRzLmlkZW50aXR5XG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjb2RlY3NfMSA9IGNvZGVjczsgX2kgPCBjb2RlY3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGVjID0gY29kZWNzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZWMuaXMoYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlYy5lbmNvZGUoYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2djYW50aS9pby10cy9wdWxsLzMwNVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIGNvZGVjIGZvdW5kIHRvIGVuY29kZSB2YWx1ZSBpbiB1bmlvbiB0eXBlIFwiICsgbmFtZSk7XG4gICAgICAgICAgICB9LCBjb2RlY3MpO1xuICAgIH1cbn07XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG52YXIgSW50ZXJzZWN0aW9uVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW50ZXJzZWN0aW9uVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbnRlcnNlY3Rpb25UeXBlKG5hbWUsIGlzLCB2YWxpZGF0ZSwgZW5jb2RlLCB0eXBlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgX3RoaXMuX3RhZyA9ICdJbnRlcnNlY3Rpb25UeXBlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSW50ZXJzZWN0aW9uVHlwZTtcbn0oVHlwZSkpO1xuZXhwb3J0cy5JbnRlcnNlY3Rpb25UeXBlID0gSW50ZXJzZWN0aW9uVHlwZTtcbnZhciBtZXJnZUFsbCA9IGZ1bmN0aW9uIChiYXNlLCB1cykge1xuICAgIHZhciByID0gYmFzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB1ID0gdXNbaV07XG4gICAgICAgIGlmICh1ICE9PSBiYXNlKSB7XG4gICAgICAgICAgICAvLyBgdWAgY29udGFpbnMgYSBwcmlzbWF0aWMgdmFsdWUgb3IgaXMgdGhlIHJlc3VsdCBvZiBhIHN0cmlwcGluZyBjb21iaW5hdG9yXG4gICAgICAgICAgICBpZiAociA9PT0gYmFzZSkge1xuICAgICAgICAgICAgICAgIHIgPSBPYmplY3QuYXNzaWduKHt9LCB1KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gdSkge1xuICAgICAgICAgICAgICAgIGlmICh1W2tdICE9PSBiYXNlW2tdIHx8ICFyLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgIHJba10gPSB1W2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbn07XG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oY29kZWNzLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gXCIoXCIgKyBjb2RlY3MubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLm5hbWU7IH0pLmpvaW4oJyAmICcpICsgXCIpXCI7IH1cbiAgICB2YXIgbGVuID0gY29kZWNzLmxlbmd0aDtcbiAgICByZXR1cm4gbmV3IEludGVyc2VjdGlvblR5cGUobmFtZSwgZnVuY3Rpb24gKHUpIHsgcmV0dXJuIGNvZGVjcy5ldmVyeShmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZS5pcyh1KTsgfSk7IH0sIGNvZGVjcy5sZW5ndGggPT09IDBcbiAgICAgICAgPyBleHBvcnRzLnN1Y2Nlc3NcbiAgICAgICAgOiBmdW5jdGlvbiAodSwgYykge1xuICAgICAgICAgICAgdmFyIHVzID0gW107XG4gICAgICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGVjID0gY29kZWNzW2ldO1xuICAgICAgICAgICAgICAgIGNvZGVjLnZhbGlkYXRlKHUsIGV4cG9ydHMuYXBwZW5kQ29udGV4dChjLCBTdHJpbmcoaSksIGNvZGVjLCB1KSkuZm9sZChmdW5jdGlvbiAoZSkgeyByZXR1cm4gcHVzaEFsbChlcnJvcnMsIGUpOyB9LCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gdXMucHVzaChhKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JzLmxlbmd0aCA+IDAgPyBleHBvcnRzLmZhaWx1cmVzKGVycm9ycykgOiBleHBvcnRzLnN1Y2Nlc3MobWVyZ2VBbGwodSwgdXMpKTtcbiAgICAgICAgfSwgY29kZWNzLmxlbmd0aCA9PT0gMCA/IGV4cG9ydHMuaWRlbnRpdHkgOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gbWVyZ2VBbGwoYSwgY29kZWNzLm1hcChmdW5jdGlvbiAoY29kZWMpIHsgcmV0dXJuIGNvZGVjLmVuY29kZShhKTsgfSkpOyB9LCBjb2RlY3MpO1xufVxuZXhwb3J0cy5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG52YXIgVHVwbGVUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUdXBsZVR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVHVwbGVUeXBlKG5hbWUsIGlzLCB2YWxpZGF0ZSwgZW5jb2RlLCB0eXBlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgX3RoaXMuX3RhZyA9ICdUdXBsZVR5cGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUdXBsZVR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydHMuVHVwbGVUeXBlID0gVHVwbGVUeXBlO1xuZnVuY3Rpb24gdHVwbGUoY29kZWNzLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gXCJbXCIgKyBjb2RlY3MubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLm5hbWU7IH0pLmpvaW4oJywgJykgKyBcIl1cIjsgfVxuICAgIHZhciBsZW4gPSBjb2RlY3MubGVuZ3RoO1xuICAgIHJldHVybiBuZXcgVHVwbGVUeXBlKG5hbWUsIGZ1bmN0aW9uICh1KSB7IHJldHVybiBleHBvcnRzLlVua25vd25BcnJheS5pcyh1KSAmJiB1Lmxlbmd0aCA9PT0gbGVuICYmIGNvZGVjcy5ldmVyeShmdW5jdGlvbiAodHlwZSwgaSkgeyByZXR1cm4gdHlwZS5pcyh1W2ldKTsgfSk7IH0sIGZ1bmN0aW9uICh1LCBjKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlVua25vd25BcnJheS52YWxpZGF0ZSh1LCBjKS5jaGFpbihmdW5jdGlvbiAodXMpIHtcbiAgICAgICAgICAgIHZhciBhcyA9IHVzLmxlbmd0aCA+IGxlbiA/IHVzLnNsaWNlKDAsIGxlbikgOiB1czsgLy8gc3RyaXAgYWRkaXRpb25hbCBjb21wb25lbnRzXG4gICAgICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgICAgICB2YXIgX2xvb3BfNSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSB1c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZV8zID0gY29kZWNzW2ldO1xuICAgICAgICAgICAgICAgIHR5cGVfMy52YWxpZGF0ZShhLCBleHBvcnRzLmFwcGVuZENvbnRleHQoYywgU3RyaW5nKGkpLCB0eXBlXzMsIGEpKS5mb2xkKGZ1bmN0aW9uIChlKSB7IHJldHVybiBwdXNoQWxsKGVycm9ycywgZSk7IH0sIGZ1bmN0aW9uICh2YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmEgIT09IGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXMgPT09IHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXMgPSB1cy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXNbaV0gPSB2YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcF81KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPiAwID8gZXhwb3J0cy5mYWlsdXJlcyhlcnJvcnMpIDogZXhwb3J0cy5zdWNjZXNzKGFzKTtcbiAgICAgICAgfSk7XG4gICAgfSwgdXNlSWRlbnRpdHkoY29kZWNzKSA/IGV4cG9ydHMuaWRlbnRpdHkgOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gY29kZWNzLm1hcChmdW5jdGlvbiAodHlwZSwgaSkgeyByZXR1cm4gdHlwZS5lbmNvZGUoYVtpXSk7IH0pOyB9LCBjb2RlY3MpO1xufVxuZXhwb3J0cy50dXBsZSA9IHR1cGxlO1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xudmFyIFJlYWRvbmx5VHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVhZG9ubHlUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlYWRvbmx5VHlwZShuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSwgdHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBpcywgdmFsaWRhdGUsIGVuY29kZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIF90aGlzLl90YWcgPSAnUmVhZG9ubHlUeXBlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmVhZG9ubHlUeXBlO1xufShUeXBlKSk7XG5leHBvcnRzLlJlYWRvbmx5VHlwZSA9IFJlYWRvbmx5VHlwZTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydHMucmVhZG9ubHkgPSBmdW5jdGlvbiAoY29kZWMsIG5hbWUpIHtcbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSBcIlJlYWRvbmx5PFwiICsgY29kZWMubmFtZSArIFwiPlwiOyB9XG4gICAgcmV0dXJuIG5ldyBSZWFkb25seVR5cGUobmFtZSwgY29kZWMuaXMsIGZ1bmN0aW9uICh1LCBjKSB7XG4gICAgICAgIHJldHVybiBjb2RlYy52YWxpZGF0ZSh1LCBjKS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSk7XG4gICAgfSwgY29kZWMuZW5jb2RlID09PSBleHBvcnRzLmlkZW50aXR5ID8gZXhwb3J0cy5pZGVudGl0eSA6IGNvZGVjLmVuY29kZSwgY29kZWMpO1xufTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbnZhciBSZWFkb25seUFycmF5VHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVhZG9ubHlBcnJheVR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVhZG9ubHlBcnJheVR5cGUobmFtZSwgaXMsIHZhbGlkYXRlLCBlbmNvZGUsIHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgaXMsIHZhbGlkYXRlLCBlbmNvZGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICBfdGhpcy5fdGFnID0gJ1JlYWRvbmx5QXJyYXlUeXBlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmVhZG9ubHlBcnJheVR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydHMuUmVhZG9ubHlBcnJheVR5cGUgPSBSZWFkb25seUFycmF5VHlwZTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydHMucmVhZG9ubHlBcnJheSA9IGZ1bmN0aW9uIChjb2RlYywgbmFtZSkge1xuICAgIGlmIChuYW1lID09PSB2b2lkIDApIHsgbmFtZSA9IFwiUmVhZG9ubHlBcnJheTxcIiArIGNvZGVjLm5hbWUgKyBcIj5cIjsgfVxuICAgIHZhciBhcnJheVR5cGUgPSBleHBvcnRzLmFycmF5KGNvZGVjKTtcbiAgICByZXR1cm4gbmV3IFJlYWRvbmx5QXJyYXlUeXBlKG5hbWUsIGFycmF5VHlwZS5pcywgZnVuY3Rpb24gKHUsIGMpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5VHlwZS52YWxpZGF0ZSh1LCBjKS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSk7XG4gICAgfSwgYXJyYXlUeXBlLmVuY29kZSwgY29kZWMpO1xufTtcbi8qKlxuICogU3RyaXBzIGFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydHMuc3RyaWN0ID0gZnVuY3Rpb24gKHByb3BzLCBuYW1lKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZXhhY3QoZXhwb3J0cy50eXBlKHByb3BzKSwgbmFtZSk7XG59O1xuLyoqXG4gKiBAc2luY2UgMS4zLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbnZhciBUYWdnZWRVbmlvblR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhZ2dlZFVuaW9uVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWdnZWRVbmlvblR5cGUobmFtZSwgXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBkZXByZWNhdGlvblxuICAgIGlzLCBcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGRlcHJlY2F0aW9uXG4gICAgdmFsaWRhdGUsIFxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGVwcmVjYXRpb25cbiAgICBlbmNvZGUsIGNvZGVjcywgdGFnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIGlzLCB2YWxpZGF0ZSwgZW5jb2RlLCBjb2RlY3MpIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIC8vIDw9IHdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMTM0NTVcbiAgICAgICAgIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRhZyA9IHRhZztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGFnZ2VkVW5pb25UeXBlO1xufShVbmlvblR5cGUpKTtcbmV4cG9ydHMuVGFnZ2VkVW5pb25UeXBlID0gVGFnZ2VkVW5pb25UeXBlO1xuLyoqXG4gKiBVc2UgYHVuaW9uYCBpbnN0ZWFkXG4gKlxuICogQHNpbmNlIDEuMy4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnRzLnRhZ2dlZFVuaW9uID0gZnVuY3Rpb24gKHRhZywgY29kZWNzLCBuYW1lXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGRlcHJlY2F0aW9uXG4pIHtcbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSBnZXRVbmlvbk5hbWUoY29kZWNzKTsgfVxuICAgIHZhciBVID0gZXhwb3J0cy51bmlvbihjb2RlY3MsIG5hbWUpO1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGVwcmVjYXRpb25cbiAgICBpZiAoVSBpbnN0YW5jZW9mIFRhZ2dlZFVuaW9uVHlwZSkge1xuICAgICAgICByZXR1cm4gVTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltpby10c10gQ2Fubm90IGJ1aWxkIGEgdGFnZ2VkIHVuaW9uIGZvciBcIiArIG5hbWUgKyBcIiwgcmV0dXJuaW5nIGEgZGUtb3B0aW1pemVkIHVuaW9uXCIpO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGRlcHJlY2F0aW9uXG4gICAgICAgIHJldHVybiBuZXcgVGFnZ2VkVW5pb25UeXBlKG5hbWUsIFUuaXMsIFUudmFsaWRhdGUsIFUuZW5jb2RlLCBjb2RlY3MsIHRhZyk7XG4gICAgfVxufTtcbi8qKlxuICogQHNpbmNlIDEuMS4wXG4gKi9cbnZhciBFeGFjdFR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4YWN0VHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeGFjdFR5cGUobmFtZSwgaXMsIHZhbGlkYXRlLCBlbmNvZGUsIHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgaXMsIHZhbGlkYXRlLCBlbmNvZGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICBfdGhpcy5fdGFnID0gJ0V4YWN0VHlwZSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEV4YWN0VHlwZTtcbn0oVHlwZSkpO1xuZXhwb3J0cy5FeGFjdFR5cGUgPSBFeGFjdFR5cGU7XG52YXIgZ2V0UHJvcHMgPSBmdW5jdGlvbiAoY29kZWMpIHtcbiAgICBzd2l0Y2ggKGNvZGVjLl90YWcpIHtcbiAgICAgICAgY2FzZSAnUmVmaW5lbWVudFR5cGUnOlxuICAgICAgICBjYXNlICdSZWFkb25seVR5cGUnOlxuICAgICAgICAgICAgcmV0dXJuIGdldFByb3BzKGNvZGVjLnR5cGUpO1xuICAgICAgICBjYXNlICdJbnRlcmZhY2VUeXBlJzpcbiAgICAgICAgY2FzZSAnU3RyaWN0VHlwZSc6XG4gICAgICAgIGNhc2UgJ1BhcnRpYWxUeXBlJzpcbiAgICAgICAgICAgIHJldHVybiBjb2RlYy5wcm9wcztcbiAgICAgICAgY2FzZSAnSW50ZXJzZWN0aW9uVHlwZSc6XG4gICAgICAgICAgICByZXR1cm4gY29kZWMudHlwZXMucmVkdWNlKGZ1bmN0aW9uIChwcm9wcywgdHlwZSkgeyByZXR1cm4gT2JqZWN0LmFzc2lnbihwcm9wcywgZ2V0UHJvcHModHlwZSkpOyB9LCB7fSk7XG4gICAgfVxufTtcbnZhciBzdHJpcEtleXMgPSBmdW5jdGlvbiAobywgcHJvcHMpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG8pO1xuICAgIHZhciBzaG91bGRTdHJpcCA9IGZhbHNlO1xuICAgIHZhciByID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIGtleSkpIHtcbiAgICAgICAgICAgIHNob3VsZFN0cmlwID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJba2V5XSA9IG9ba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkU3RyaXAgPyByIDogbztcbn07XG52YXIgZ2V0RXhhY3RUeXBlTmFtZSA9IGZ1bmN0aW9uIChjb2RlYykge1xuICAgIGlmIChpc0ludGVyZmFjZUNvZGVjKGNvZGVjKSkge1xuICAgICAgICByZXR1cm4gXCJ7fCBcIiArIGdldE5hbWVGcm9tUHJvcHMoY29kZWMucHJvcHMpICsgXCIgfH1cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQYXJ0aWFsQ29kZWMoY29kZWMpKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJ0aWFsVHlwZU5hbWUoXCJ7fCBcIiArIGdldE5hbWVGcm9tUHJvcHMoY29kZWMucHJvcHMpICsgXCIgfH1cIik7XG4gICAgfVxuICAgIHJldHVybiBcIkV4YWN0PFwiICsgY29kZWMubmFtZSArIFwiPlwiO1xufTtcbi8qKlxuICogU3RyaXBzIGFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogQHNpbmNlIDEuMS4wXG4gKi9cbmV4cG9ydHMuZXhhY3QgPSBmdW5jdGlvbiAoY29kZWMsIG5hbWUpIHtcbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSBnZXRFeGFjdFR5cGVOYW1lKGNvZGVjKTsgfVxuICAgIHZhciBwcm9wcyA9IGdldFByb3BzKGNvZGVjKTtcbiAgICByZXR1cm4gbmV3IEV4YWN0VHlwZShuYW1lLCBjb2RlYy5pcywgZnVuY3Rpb24gKHUsIGMpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuVW5rbm93blJlY29yZC52YWxpZGF0ZSh1LCBjKS5jaGFpbihmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlYy52YWxpZGF0ZSh1LCBjKS5mb2xkKEVpdGhlcl8xLmxlZnQsIGZ1bmN0aW9uIChhKSB7IHJldHVybiBleHBvcnRzLnN1Y2Nlc3Moc3RyaXBLZXlzKGEsIHByb3BzKSk7IH0pOyB9KTtcbiAgICB9LCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gY29kZWMuZW5jb2RlKHN0cmlwS2V5cyhhLCBwcm9wcykpOyB9LCBjb2RlYyk7XG59O1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuZ2V0VmFsaWRhdGlvbkVycm9yIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7IHJldHVybiAoe1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBjb250ZXh0OiBjb250ZXh0XG59KTsgfTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnRzLmdldERlZmF1bHRDb250ZXh0IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovID0gZnVuY3Rpb24gKGRlY29kZXIpIHsgcmV0dXJuIFtcbiAgICB7IGtleTogJycsIHR5cGU6IGRlY29kZXIgfVxuXTsgfTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG52YXIgTmV2ZXJUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZXZlclR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmV2ZXJUeXBlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAnbmV2ZXInLCBmdW5jdGlvbiAoXykgeyByZXR1cm4gZmFsc2U7IH0sIGZ1bmN0aW9uICh1LCBjKSB7IHJldHVybiBleHBvcnRzLmZhaWx1cmUodSwgYyk7IH0sIFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBlbmNvZGUgbmV2ZXInKTtcbiAgICAgICAgfSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3RhZyA9ICdOZXZlclR5cGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBOZXZlclR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydHMuTmV2ZXJUeXBlID0gTmV2ZXJUeXBlO1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGVwcmVjYXRpb25cbmV4cG9ydHMubmV2ZXIgPSBuZXcgTmV2ZXJUeXBlKCk7XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xudmFyIEFueVR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFueVR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQW55VHlwZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ2FueScsIGZ1bmN0aW9uIChfKSB7IHJldHVybiB0cnVlOyB9LCBleHBvcnRzLnN1Y2Nlc3MsIGV4cG9ydHMuaWRlbnRpdHkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl90YWcgPSAnQW55VHlwZSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEFueVR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydHMuQW55VHlwZSA9IEFueVR5cGU7XG4vKipcbiAqIFVzZSBgdW5rbm93bmAgaW5zdGVhZFxuICogQHNpbmNlIDEuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGRlcHJlY2F0aW9uXG5leHBvcnRzLmFueSA9IG5ldyBBbnlUeXBlKCk7XG4vKipcbiAqIFVzZSBgVW5rbm93blJlY29yZGAgaW5zdGVhZFxuICogQHNpbmNlIDEuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnRzLkRpY3Rpb25hcnkgPSBleHBvcnRzLlVua25vd25SZWNvcmQ7XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xudmFyIE9iamVjdFR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9iamVjdFR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT2JqZWN0VHlwZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ29iamVjdCcsIGV4cG9ydHMuVW5rbm93blJlY29yZC5pcywgZXhwb3J0cy5Vbmtub3duUmVjb3JkLnZhbGlkYXRlLCBleHBvcnRzLmlkZW50aXR5KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fdGFnID0gJ09iamVjdFR5cGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3RUeXBlO1xufShUeXBlKSk7XG5leHBvcnRzLk9iamVjdFR5cGUgPSBPYmplY3RUeXBlO1xuLyoqXG4gKiBVc2UgYFVua25vd25SZWNvcmRgIGluc3RlYWRcbiAqIEBzaW5jZSAxLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBkZXByZWNhdGlvblxuZXhwb3J0cy5vYmplY3QgPSBuZXcgT2JqZWN0VHlwZSgpO1xuLyoqXG4gKiBVc2UgYGJyYW5kYCBpbnN0ZWFkXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmZ1bmN0aW9uIHJlZmluZW1lbnQoY29kZWMsIHByZWRpY2F0ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lID09PSB2b2lkIDApIHsgbmFtZSA9IFwiKFwiICsgY29kZWMubmFtZSArIFwiIHwgXCIgKyBleHBvcnRzLmdldEZ1bmN0aW9uTmFtZShwcmVkaWNhdGUpICsgXCIpXCI7IH1cbiAgICByZXR1cm4gbmV3IFJlZmluZW1lbnRUeXBlKG5hbWUsIGZ1bmN0aW9uICh1KSB7IHJldHVybiBjb2RlYy5pcyh1KSAmJiBwcmVkaWNhdGUodSk7IH0sIGZ1bmN0aW9uIChpLCBjKSB7IHJldHVybiBjb2RlYy52YWxpZGF0ZShpLCBjKS5jaGFpbihmdW5jdGlvbiAoYSkgeyByZXR1cm4gKHByZWRpY2F0ZShhKSA/IGV4cG9ydHMuc3VjY2VzcyhhKSA6IGV4cG9ydHMuZmFpbHVyZShhLCBjKSk7IH0pOyB9LCBjb2RlYy5lbmNvZGUsIGNvZGVjLCBwcmVkaWNhdGUpO1xufVxuZXhwb3J0cy5yZWZpbmVtZW50ID0gcmVmaW5lbWVudDtcbi8qKlxuICogVXNlIGBJbnRgIGluc3RlYWRcbiAqIEBzaW5jZSAxLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBkZXByZWNhdGlvblxuZXhwb3J0cy5JbnRlZ2VyID0gcmVmaW5lbWVudChleHBvcnRzLm51bWJlciwgTnVtYmVyLmlzSW50ZWdlciwgJ0ludGVnZXInKTtcbi8qKlxuICogVXNlIGByZWNvcmRgIGluc3RlYWRcbiAqIEBzaW5jZSAxLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0cy5kaWN0aW9uYXJ5ID0gZXhwb3J0cy5yZWNvcmQ7XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xudmFyIFN0cmljdFR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0cmljdFR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RyaWN0VHlwZShuYW1lLCBcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGRlcHJlY2F0aW9uXG4gICAgaXMsIFxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGVwcmVjYXRpb25cbiAgICB2YWxpZGF0ZSwgXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBkZXByZWNhdGlvblxuICAgIGVuY29kZSwgcHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgaXMsIHZhbGlkYXRlLCBlbmNvZGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIF90aGlzLl90YWcgPSAnU3RyaWN0VHlwZSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFN0cmljdFR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydHMuU3RyaWN0VHlwZSA9IFN0cmljdFR5cGU7XG4vKipcbiAqIERyb3BzIHRoZSBjb2RlYyBcImtpbmRcIlxuICogQHNpbmNlIDEuMS4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5mdW5jdGlvbiBjbGVhbihjb2RlYykge1xuICAgIHJldHVybiBjb2RlYztcbn1cbmV4cG9ydHMuY2xlYW4gPSBjbGVhbjtcbmZ1bmN0aW9uIGFsaWFzKGNvZGVjKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVjOyB9O1xufVxuZXhwb3J0cy5hbGlhcyA9IGFsaWFzO1xudmFyIGlzTm9uRW1wdHkgPSBmdW5jdGlvbiAoYXMpIHsgcmV0dXJuIGFzLmxlbmd0aCA+IDA7IH07XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnRzLmVtcHR5VGFncyA9IHt9O1xuZnVuY3Rpb24gaW50ZXJzZWN0KGEsIGIpIHtcbiAgICB2YXIgciA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMCwgYV8xID0gYTsgX2kgPCBhXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciB2ID0gYV8xW19pXTtcbiAgICAgICAgaWYgKGIuaW5kZXhPZih2KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHIucHVzaCh2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIG1lcmdlVGFncyhhLCBiKSB7XG4gICAgaWYgKGEgPT09IGV4cG9ydHMuZW1wdHlUYWdzKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICBpZiAoYiA9PT0gZXhwb3J0cy5lbXB0eVRhZ3MpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIHZhciByID0gT2JqZWN0LmFzc2lnbih7fSwgYSk7XG4gICAgZm9yICh2YXIgayBpbiBiKSB7XG4gICAgICAgIGlmIChhLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uXzEgPSBpbnRlcnNlY3QoYVtrXSwgYltrXSk7XG4gICAgICAgICAgICBpZiAoaXNOb25FbXB0eShpbnRlcnNlY3Rpb25fMSkpIHtcbiAgICAgICAgICAgICAgICByW2tdID0gaW50ZXJzZWN0aW9uXzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByID0gZXhwb3J0cy5lbXB0eVRhZ3M7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByW2tdID0gYltrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdFRhZ3MoYSwgYikge1xuICAgIGlmIChhID09PSBleHBvcnRzLmVtcHR5VGFncyB8fCBiID09PSBleHBvcnRzLmVtcHR5VGFncykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5lbXB0eVRhZ3M7XG4gICAgfVxuICAgIHZhciByID0gZXhwb3J0cy5lbXB0eVRhZ3M7XG4gICAgZm9yICh2YXIgayBpbiBhKSB7XG4gICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uXzIgPSBpbnRlcnNlY3QoYVtrXSwgYltrXSk7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uXzIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHIgPT09IGV4cG9ydHMuZW1wdHlUYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcltrXSA9IGFba10uY29uY2F0KGJba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xufVxuZnVuY3Rpb24gaXNMaXRlcmFsQyhjb2RlYykge1xuICAgIHJldHVybiBjb2RlYy5fdGFnID09PSAnTGl0ZXJhbFR5cGUnO1xufVxuZnVuY3Rpb24gaXNUeXBlQyhjb2RlYykge1xuICAgIHJldHVybiBjb2RlYy5fdGFnID09PSAnSW50ZXJmYWNlVHlwZSc7XG59XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGRlcHJlY2F0aW9uXG5mdW5jdGlvbiBpc1N0cmljdEMoY29kZWMpIHtcbiAgICByZXR1cm4gY29kZWMuX3RhZyA9PT0gJ1N0cmljdFR5cGUnO1xufVxuZnVuY3Rpb24gaXNFeGFjdEMoY29kZWMpIHtcbiAgICByZXR1cm4gY29kZWMuX3RhZyA9PT0gJ0V4YWN0VHlwZSc7XG59XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGRlcHJlY2F0aW9uXG5mdW5jdGlvbiBpc1JlZmluZW1lbnRDKGNvZGVjKSB7XG4gICAgcmV0dXJuIGNvZGVjLl90YWcgPT09ICdSZWZpbmVtZW50VHlwZSc7XG59XG5mdW5jdGlvbiBpc0ludGVyc2VjdGlvbkMoY29kZWMpIHtcbiAgICByZXR1cm4gY29kZWMuX3RhZyA9PT0gJ0ludGVyc2VjdGlvblR5cGUnO1xufVxuZnVuY3Rpb24gaXNVbmlvbkMoY29kZWMpIHtcbiAgICByZXR1cm4gY29kZWMuX3RhZyA9PT0gJ1VuaW9uVHlwZSc7XG59XG5mdW5jdGlvbiBpc1JlY3Vyc2l2ZUMoY29kZWMpIHtcbiAgICByZXR1cm4gY29kZWMuX3RhZyA9PT0gJ1JlY3Vyc2l2ZVR5cGUnO1xufVxudmFyIGxhenlDb2RlYyA9IG51bGw7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRUYWdzKGNvZGVjKSB7XG4gICAgaWYgKGNvZGVjID09PSBsYXp5Q29kZWMpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuZW1wdHlUYWdzO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlQyhjb2RlYykgfHwgaXNTdHJpY3RDKGNvZGVjKSkge1xuICAgICAgICB2YXIgaW5kZXggPSBleHBvcnRzLmVtcHR5VGFncztcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBmb3JpblxuICAgICAgICBmb3IgKHZhciBrIGluIGNvZGVjLnByb3BzKSB7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IGNvZGVjLnByb3BzW2tdO1xuICAgICAgICAgICAgaWYgKGlzTGl0ZXJhbEMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IGV4cG9ydHMuZW1wdHlUYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4W2tdID0gW3Byb3AudmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNFeGFjdEMoY29kZWMpIHx8IGlzUmVmaW5lbWVudEMoY29kZWMpKSB7XG4gICAgICAgIHJldHVybiBnZXRUYWdzKGNvZGVjLnR5cGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0ludGVyc2VjdGlvbkMoY29kZWMpKSB7XG4gICAgICAgIHJldHVybiBjb2RlYy50eXBlcy5yZWR1Y2UoZnVuY3Rpb24gKHRhZ3MsIGNvZGVjKSB7IHJldHVybiBtZXJnZVRhZ3ModGFncywgZ2V0VGFncyhjb2RlYykpOyB9LCBleHBvcnRzLmVtcHR5VGFncyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzVW5pb25DKGNvZGVjKSkge1xuICAgICAgICByZXR1cm4gY29kZWMudHlwZXMuc2xpY2UoMSkucmVkdWNlKGZ1bmN0aW9uICh0YWdzLCBjb2RlYykgeyByZXR1cm4gaW50ZXJzZWN0VGFncyh0YWdzLCBnZXRUYWdzKGNvZGVjKSk7IH0sIGdldFRhZ3MoY29kZWMudHlwZXNbMF0pKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNSZWN1cnNpdmVDKGNvZGVjKSkge1xuICAgICAgICBsYXp5Q29kZWMgPSBjb2RlYztcbiAgICAgICAgdmFyIHRhZ3MgPSBnZXRUYWdzKGNvZGVjLnR5cGUpO1xuICAgICAgICBsYXp5Q29kZWMgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGFncztcbiAgICB9XG4gICAgcmV0dXJuIGV4cG9ydHMuZW1wdHlUYWdzO1xufVxuZXhwb3J0cy5nZXRUYWdzID0gZ2V0VGFncztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldEluZGV4KGNvZGVjcykge1xuICAgIHZhciB0YWdzID0gZ2V0VGFncyhjb2RlY3NbMF0pO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGFncyk7XG4gICAgdmFyIGxlbiA9IGNvZGVjcy5sZW5ndGg7XG4gICAgdmFyIF9sb29wXzYgPSBmdW5jdGlvbiAoaykge1xuICAgICAgICB2YXIgYWxsID0gdGFnc1trXS5zbGljZSgpO1xuICAgICAgICB2YXIgaW5kZXggPSBbdGFnc1trXV07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb2RlYyA9IGNvZGVjc1tpXTtcbiAgICAgICAgICAgIHZhciBjdGFncyA9IGdldFRhZ3MoY29kZWMpO1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IGN0YWdzW2tdO1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBzdHJpY3QtdHlwZS1wcmVkaWNhdGVzXG4gICAgICAgICAgICBpZiAodmFsdWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZS1rZXlzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGFsbC5pbmRleE9mKHYpICE9PSAtMTsgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWUta2V5c1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsLnB1c2guYXBwbHkoYWxsLCB2YWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleC5wdXNoKHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBbaywgaW5kZXhdIH07XG4gICAgfTtcbiAgICBrZXlzOiBmb3IgKHZhciBfaSA9IDAsIGtleXNfMSA9IGtleXM7IF9pIDwga2V5c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgayA9IGtleXNfMVtfaV07XG4gICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfNihrKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZV8xID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlXzEudmFsdWU7XG4gICAgICAgIHN3aXRjaCAoc3RhdGVfMSkge1xuICAgICAgICAgICAgY2FzZSBcImNvbnRpbnVlLWtleXNcIjogY29udGludWUga2V5cztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5nZXRJbmRleCA9IGdldEluZGV4O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/io-ts/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/io-ts/node_modules/fp-ts/lib/ChainRec.js":
/*!***************************************************************!*\
  !*** ./node_modules/io-ts/node_modules/fp-ts/lib/ChainRec.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * @since 1.0.0\n */\nexports.tailRec = function (f, a) {\n    var v = f(a);\n    while (v.isLeft()) {\n        v = f(v.value);\n    }\n    return v.value;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW8tdHMvbm9kZV9tb2R1bGVzL2ZwLXRzL2xpYi9DaGFpblJlYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9pby10cy9ub2RlX21vZHVsZXMvZnAtdHMvbGliL0NoYWluUmVjLmpzPzE1OTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG5leHBvcnRzLnRhaWxSZWMgPSBmdW5jdGlvbiAoZiwgYSkge1xuICAgIHZhciB2ID0gZihhKTtcbiAgICB3aGlsZSAodi5pc0xlZnQoKSkge1xuICAgICAgICB2ID0gZih2LnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHYudmFsdWU7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/io-ts/node_modules/fp-ts/lib/ChainRec.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/io-ts/node_modules/fp-ts/lib/Either.js":
/*!*************************************************************!*\
  !*** ./node_modules/io-ts/node_modules/fp-ts/lib/Either.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * @file Represents a value of one of two possible types (a disjoint union).\n *\n * An instance of `Either` is either an instance of `Left` or `Right`.\n *\n * A common use of `Either` is as an alternative to `Option` for dealing with possible missing values. In this usage,\n * `None` is replaced with a `Left` which can contain useful information. `Right` takes the place of `Some`. Convention\n * dictates that `Left` is used for failure and `Right` is used for success.\n *\n * For example, you could use `Either<string, number>` to detect whether a received input is a `string` or a `number`.\n *\n * ```ts\n * const parse = (errorMessage: string) => (input: string): Either<string, number> => {\n *   const n = parseInt(input, 10)\n *   return isNaN(n) ? left(errorMessage) : right(n)\n * }\n * ```\n *\n * `Either` is right-biased, which means that `Right` is assumed to be the default case to operate on. If it is `Left`,\n * operations like `map`, `chain`, ... return the `Left` value unchanged:\n *\n * ```ts\n * right(12).map(double) // right(24)\n * left(23).map(double)  // left(23)\n * ```\n */\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar ChainRec_1 = __webpack_require__(/*! ./ChainRec */ \"(ssr)/./node_modules/io-ts/node_modules/fp-ts/lib/ChainRec.js\");\nvar function_1 = __webpack_require__(/*! ./function */ \"(ssr)/./node_modules/io-ts/node_modules/fp-ts/lib/function.js\");\nvar Eq_1 = __webpack_require__(/*! ./Eq */ \"(ssr)/./node_modules/io-ts/node_modules/fp-ts/lib/Eq.js\");\nvar pipeable_1 = __webpack_require__(/*! ./pipeable */ \"(ssr)/./node_modules/io-ts/node_modules/fp-ts/lib/pipeable.js\");\nexports.URI = 'Either';\n/**\n * Left side of `Either`\n */\nvar Left = /** @class */ (function () {\n    function Left(value) {\n        this.value = value;\n        this._tag = 'Left';\n    }\n    /**\n     * The given function is applied if this is a `Right`\n     * @obsolete\n     */\n    Left.prototype.map = function (f) {\n        return this;\n    };\n    /** @obsolete */\n    Left.prototype.ap = function (fab) {\n        return (fab.isLeft() ? fab : this);\n    };\n    /**\n     * Flipped version of `ap`\n     * @obsolete\n     */\n    Left.prototype.ap_ = function (fb) {\n        return fb.ap(this);\n    };\n    /**\n     * Binds the given function across `Right`\n     * @obsolete\n     */\n    Left.prototype.chain = function (f) {\n        return this;\n    };\n    /** @obsolete */\n    Left.prototype.bimap = function (f, g) {\n        return new Left(f(this.value));\n    };\n    /** @obsolete */\n    Left.prototype.alt = function (fy) {\n        return fy;\n    };\n    /**\n     * Lazy version of `alt`\n     *\n     * @example\n     * import { right } from 'fp-ts/lib/Either'\n     *\n     * assert.deepStrictEqual(right(1).orElse(() => right(2)), right(1))\n     *\n     * @since 1.6.0\n     * @obsolete\n     */\n    Left.prototype.orElse = function (fy) {\n        return fy(this.value);\n    };\n    /** @obsolete */\n    Left.prototype.extend = function (f) {\n        return this;\n    };\n    /** @obsolete */\n    Left.prototype.reduce = function (b, f) {\n        return b;\n    };\n    /**\n     * Applies a function to each case in the data structure\n     * @obsolete\n     */\n    Left.prototype.fold = function (onLeft, onRight) {\n        return onLeft(this.value);\n    };\n    /**\n     * Returns the value from this `Right` or the given argument if this is a `Left`\n     * @obsolete\n     */\n    Left.prototype.getOrElse = function (a) {\n        return a;\n    };\n    /**\n     * Returns the value from this `Right` or the result of given argument if this is a `Left`\n     * @obsolete\n     */\n    Left.prototype.getOrElseL = function (f) {\n        return f(this.value);\n    };\n    /**\n     * Maps the left side of the disjunction\n     * @obsolete\n     */\n    Left.prototype.mapLeft = function (f) {\n        return new Left(f(this.value));\n    };\n    Left.prototype.inspect = function () {\n        return this.toString();\n    };\n    Left.prototype.toString = function () {\n        // tslint:disable-next-line: deprecation\n        return \"left(\" + function_1.toString(this.value) + \")\";\n    };\n    /**\n     * Returns `true` if the either is an instance of `Left`, `false` otherwise\n     * @obsolete\n     */\n    Left.prototype.isLeft = function () {\n        return true;\n    };\n    /**\n     * Returns `true` if the either is an instance of `Right`, `false` otherwise\n     * @obsolete\n     */\n    Left.prototype.isRight = function () {\n        return false;\n    };\n    /**\n     * Swaps the disjunction values\n     * @obsolete\n     */\n    Left.prototype.swap = function () {\n        return new Right(this.value);\n    };\n    Left.prototype.filterOrElse = function (_, zero) {\n        return this;\n    };\n    Left.prototype.filterOrElseL = function (_, zero) {\n        return this;\n    };\n    /**\n     * Use `filterOrElse` instead\n     * @since 1.6.0\n     * @deprecated\n     */\n    Left.prototype.refineOrElse = function (p, zero) {\n        return this;\n    };\n    /**\n     * Lazy version of `refineOrElse`\n     * Use `filterOrElseL` instead\n     * @since 1.6.0\n     * @deprecated\n     */\n    Left.prototype.refineOrElseL = function (p, zero) {\n        return this;\n    };\n    return Left;\n}());\nexports.Left = Left;\n/**\n * Right side of `Either`\n */\nvar Right = /** @class */ (function () {\n    function Right(value) {\n        this.value = value;\n        this._tag = 'Right';\n    }\n    Right.prototype.map = function (f) {\n        return new Right(f(this.value));\n    };\n    Right.prototype.ap = function (fab) {\n        return fab.isRight() ? this.map(fab.value) : exports.left(fab.value);\n    };\n    Right.prototype.ap_ = function (fb) {\n        return fb.ap(this);\n    };\n    Right.prototype.chain = function (f) {\n        return f(this.value);\n    };\n    Right.prototype.bimap = function (f, g) {\n        return new Right(g(this.value));\n    };\n    Right.prototype.alt = function (fy) {\n        return this;\n    };\n    Right.prototype.orElse = function (fy) {\n        return this;\n    };\n    Right.prototype.extend = function (f) {\n        return new Right(f(this));\n    };\n    Right.prototype.reduce = function (b, f) {\n        return f(b, this.value);\n    };\n    Right.prototype.fold = function (onLeft, onRight) {\n        return onRight(this.value);\n    };\n    Right.prototype.getOrElse = function (a) {\n        return this.value;\n    };\n    Right.prototype.getOrElseL = function (f) {\n        return this.value;\n    };\n    Right.prototype.mapLeft = function (f) {\n        return new Right(this.value);\n    };\n    Right.prototype.inspect = function () {\n        return this.toString();\n    };\n    Right.prototype.toString = function () {\n        // tslint:disable-next-line: deprecation\n        return \"right(\" + function_1.toString(this.value) + \")\";\n    };\n    Right.prototype.isLeft = function () {\n        return false;\n    };\n    Right.prototype.isRight = function () {\n        return true;\n    };\n    Right.prototype.swap = function () {\n        return new Left(this.value);\n    };\n    Right.prototype.filterOrElse = function (p, zero) {\n        return p(this.value) ? this : exports.left(zero);\n    };\n    Right.prototype.filterOrElseL = function (p, zero) {\n        return p(this.value) ? this : exports.left(zero(this.value));\n    };\n    Right.prototype.refineOrElse = function (p, zero) {\n        return p(this.value) ? this : exports.left(zero);\n    };\n    Right.prototype.refineOrElseL = function (p, zero) {\n        return p(this.value) ? this : exports.left(zero(this.value));\n    };\n    return Right;\n}());\nexports.Right = Right;\n/**\n * @since 1.17.0\n */\nexports.getShow = function (SL, SA) {\n    return {\n        show: function (e) { return e.fold(function (l) { return \"left(\" + SL.show(l) + \")\"; }, function (a) { return \"right(\" + SA.show(a) + \")\"; }); }\n    };\n};\n/**\n * Use `getEq`\n *\n * @since 1.0.0\n * @deprecated\n */\nexports.getSetoid = getEq;\n/**\n * @since 1.19.0\n */\nfunction getEq(EL, EA) {\n    return Eq_1.fromEquals(function (x, y) {\n        return x.isLeft() ? y.isLeft() && EL.equals(x.value, y.value) : y.isRight() && EA.equals(x.value, y.value);\n    });\n}\nexports.getEq = getEq;\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * appended using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/lib/Either'\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n *\n * const S = getSemigroup<string, number>(semigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n *\n * @since 1.7.0\n */\nexports.getSemigroup = function (S) {\n    return {\n        concat: function (x, y) { return (y.isLeft() ? x : x.isLeft() ? y : exports.right(S.concat(x.value, y.value))); }\n    };\n};\n/**\n * `Apply` semigroup\n *\n * @example\n * import { getApplySemigroup, left, right } from 'fp-ts/lib/Either'\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n *\n * const S = getApplySemigroup<string, number>(semigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), left('a'))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), left('b'))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n *\n * @since 1.7.0\n */\nexports.getApplySemigroup = function (S) {\n    return {\n        concat: function (x, y) { return (x.isLeft() ? x : y.isLeft() ? y : exports.right(S.concat(x.value, y.value))); }\n    };\n};\n/**\n * @since 1.7.0\n */\nexports.getApplyMonoid = function (M) {\n    return __assign({}, exports.getApplySemigroup(M), { empty: exports.right(M.empty) });\n};\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure\n *\n * @since 1.0.0\n */\nexports.left = function (l) {\n    return new Left(l);\n};\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure\n *\n * @since 1.0.0\n */\nexports.right = function (a) {\n    return new Right(a);\n};\n/**\n * Use `fromPredicate` instead\n *\n * @since 1.6.0\n * @deprecated\n */\nexports.fromRefinement = function (refinement, onFalse) { return function (a) {\n    return refinement(a) ? exports.right(a) : exports.left(onFalse(a));\n}; };\n/**\n * Takes a default and a `Option` value, if the value is a `Some`, turn it into a `Right`, if the value is a `None` use\n * the provided default as a `Left`\n *\n * @since 1.0.0\n */\nexports.fromOption = function (onNone) { return function (fa) {\n    return fa.isNone() ? exports.left(onNone) : exports.right(fa.value);\n}; };\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`\n *\n * @since 1.0.0\n */\nexports.fromNullable = function (defaultValue) { return function (a) {\n    return a == null ? exports.left(defaultValue) : exports.right(a);\n}; };\n/**\n * Default value for the optional `onerror` argument of `tryCatch`\n *\n * @since 1.0.0\n */\nexports.toError = function (e) {\n    if (e instanceof Error) {\n        return e;\n    }\n    else {\n        return new Error(String(e));\n    }\n};\n/**\n * Use `tryCatch2v` instead\n *\n * @since 1.0.0\n * @deprecated\n */\nexports.tryCatch = function (f, onerror) {\n    if (onerror === void 0) { onerror = exports.toError; }\n    return exports.tryCatch2v(f, onerror);\n};\n/**\n * Constructs a new `Either` from a function that might throw\n *\n * @example\n * import { Either, left, right, tryCatch2v } from 'fp-ts/lib/Either'\n *\n * const unsafeHead = <A>(as: Array<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: Array<A>): Either<Error, A> => {\n *   return tryCatch2v(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n * }\n *\n * assert.deepStrictEqual(head([]), left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), right(1))\n *\n * @since 1.11.0\n */\nexports.tryCatch2v = function (f, onerror) {\n    try {\n        return exports.right(f());\n    }\n    catch (e) {\n        return exports.left(onerror(e));\n    }\n};\n/**\n * @since 1.0.0\n */\nexports.fromValidation = function (fa) {\n    return fa.isFailure() ? exports.left(fa.value) : exports.right(fa.value);\n};\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise\n *\n * @since 1.0.0\n */\nexports.isLeft = function (fa) {\n    return fa.isLeft();\n};\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise\n *\n * @since 1.0.0\n */\nexports.isRight = function (fa) {\n    return fa.isRight();\n};\n/**\n * Use `getWitherable`\n *\n * @since 1.7.0\n * @deprecated\n */\nfunction getCompactable(ML) {\n    var compact = function (fa) {\n        if (fa.isLeft()) {\n            return fa;\n        }\n        if (fa.value.isNone()) {\n            return exports.left(ML.empty);\n        }\n        return exports.right(fa.value.value);\n    };\n    var separate = function (fa) {\n        if (fa.isLeft()) {\n            return {\n                left: fa,\n                right: fa\n            };\n        }\n        if (fa.value.isLeft()) {\n            return {\n                left: exports.right(fa.value.value),\n                right: exports.left(ML.empty)\n            };\n        }\n        return {\n            left: exports.left(ML.empty),\n            right: exports.right(fa.value.value)\n        };\n    };\n    return {\n        URI: exports.URI,\n        _L: undefined,\n        compact: compact,\n        separate: separate\n    };\n}\nexports.getCompactable = getCompactable;\n/**\n * Use `getWitherable`\n *\n * @since 1.7.0\n * @deprecated\n */\nfunction getFilterable(ML) {\n    // tslint:disable-next-line: deprecation\n    var C = getCompactable(ML);\n    var partitionMap = function (fa, f) {\n        if (fa.isLeft()) {\n            return {\n                left: fa,\n                right: fa\n            };\n        }\n        var e = f(fa.value);\n        if (e.isLeft()) {\n            return {\n                left: exports.right(e.value),\n                right: exports.left(ML.empty)\n            };\n        }\n        return {\n            left: exports.left(ML.empty),\n            right: exports.right(e.value)\n        };\n    };\n    var partition = function (fa, p) {\n        if (fa.isLeft()) {\n            return {\n                left: fa,\n                right: fa\n            };\n        }\n        if (p(fa.value)) {\n            return {\n                left: exports.left(ML.empty),\n                right: exports.right(fa.value)\n            };\n        }\n        return {\n            left: exports.right(fa.value),\n            right: exports.left(ML.empty)\n        };\n    };\n    var filterMap = function (fa, f) {\n        if (fa.isLeft()) {\n            return fa;\n        }\n        var optionB = f(fa.value);\n        if (optionB.isSome()) {\n            return exports.right(optionB.value);\n        }\n        return exports.left(ML.empty);\n    };\n    var filter = function (fa, p) { return fa.filterOrElse(p, ML.empty); };\n    return __assign({}, C, { map: exports.either.map, partitionMap: partitionMap,\n        filterMap: filterMap,\n        partition: partition,\n        filter: filter });\n}\nexports.getFilterable = getFilterable;\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @since 1.7.0\n */\nfunction getWitherable(ML) {\n    // tslint:disable-next-line: deprecation\n    var filterableEither = getFilterable(ML);\n    var wither = function (F) {\n        var traverseF = exports.either.traverse(F);\n        return function (wa, f) { return F.map(traverseF(wa, f), filterableEither.compact); };\n    };\n    var wilt = function (F) {\n        var traverseF = exports.either.traverse(F);\n        return function (wa, f) { return F.map(traverseF(wa, f), filterableEither.separate); };\n    };\n    return __assign({}, filterableEither, { traverse: exports.either.traverse, reduce: exports.either.reduce, wither: wither,\n        wilt: wilt });\n}\nexports.getWitherable = getWitherable;\n/**\n * Converts a JavaScript Object Notation (JSON) string into an object.\n *\n * @example\n * import { parseJSON, toError } from 'fp-ts/lib/Either'\n *\n * assert.deepStrictEqual(parseJSON('{\"a\":1}', toError).value, { a: 1 })\n * assert.deepStrictEqual(parseJSON('{\"a\":}', toError).value, new SyntaxError('Unexpected token } in JSON at position 5'))\n *\n * @since 1.16.0\n */\nexports.parseJSON = function (s, onError) {\n    return exports.tryCatch2v(function () { return JSON.parse(s); }, onError);\n};\n/**\n * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n *\n * @example\n * import { stringifyJSON, toError } from 'fp-ts/lib/Either'\n *\n * assert.deepStrictEqual(stringifyJSON({ a: 1 }, toError).value, '{\"a\":1}')\n * const circular: any = { ref: null }\n * circular.ref = circular\n * assert.deepStrictEqual(stringifyJSON(circular, toError).value, new TypeError('Converting circular structure to JSON'))\n *\n * @since 1.16.0\n */\nexports.stringifyJSON = function (u, onError) {\n    return exports.tryCatch2v(function () { return JSON.stringify(u); }, onError);\n};\nvar throwError = exports.left;\nvar fromEither = function_1.identity;\n/**\n * @since 1.0.0\n */\nexports.either = {\n    URI: exports.URI,\n    map: function (ma, f) { return ma.map(f); },\n    of: exports.right,\n    ap: function (mab, ma) { return ma.ap(mab); },\n    chain: function (ma, f) { return ma.chain(f); },\n    reduce: function (fa, b, f) { return fa.reduce(b, f); },\n    foldMap: function (M) { return function (fa, f) { return (fa.isLeft() ? M.empty : f(fa.value)); }; },\n    foldr: function (fa, b, f) { return (fa.isLeft() ? b : f(fa.value, b)); },\n    traverse: function (F) { return function (ta, f) {\n        return ta.isLeft() ? F.of(exports.left(ta.value)) : F.map(f(ta.value), exports.right);\n    }; },\n    sequence: function (F) { return function (ta) {\n        return ta.isLeft() ? F.of(exports.left(ta.value)) : F.map(ta.value, exports.right);\n    }; },\n    bimap: function (fla, f, g) { return fla.bimap(f, g); },\n    alt: function (mx, my) { return mx.alt(my); },\n    extend: function (wa, f) { return wa.extend(f); },\n    chainRec: function (a, f) {\n        return ChainRec_1.tailRec(function (e) {\n            if (e.isLeft()) {\n                return exports.right(exports.left(e.value));\n            }\n            else {\n                var r = e.value;\n                return r.isLeft() ? exports.left(f(r.value)) : exports.right(exports.right(r.value));\n            }\n        }, f(a));\n    },\n    throwError: throwError,\n    fromEither: fromEither,\n    fromOption: function (o, e) { return (o.isNone() ? throwError(e) : exports.right(o.value)); }\n};\n//\n// backporting\n//\n/**\n * @since 1.19.0\n */\nfunction fold(onLeft, onRight) {\n    return function (ma) { return ma.fold(onLeft, onRight); };\n}\nexports.fold = fold;\n/**\n * @since 1.19.0\n */\nfunction orElse(f) {\n    return function (ma) { return ma.orElse(f); };\n}\nexports.orElse = orElse;\n/**\n * @since 1.19.0\n */\nfunction getOrElse(f) {\n    return function (ma) { return ma.getOrElseL(f); };\n}\nexports.getOrElse = getOrElse;\n/**\n * @since 1.19.0\n */\nfunction elem(E) {\n    return function (a) { return function (ma) { return (exports.isLeft(ma) ? false : E.equals(a, ma.value)); }; };\n}\nexports.elem = elem;\n/**\n * @since 1.19.0\n */\nfunction getValidation(S) {\n    return {\n        URI: exports.URI,\n        _L: undefined,\n        map: exports.either.map,\n        of: exports.either.of,\n        ap: function (mab, ma) {\n            return exports.isLeft(mab)\n                ? exports.isLeft(ma)\n                    ? exports.left(S.concat(mab.value, ma.value))\n                    : mab\n                : exports.isLeft(ma)\n                    ? ma\n                    : exports.right(mab.value(ma.value));\n        },\n        chain: exports.either.chain,\n        alt: function (fx, fy) {\n            if (exports.isRight(fx)) {\n                return fx;\n            }\n            return exports.isLeft(fy) ? exports.left(S.concat(fx.value, fy.value)) : fy;\n        }\n    };\n}\nexports.getValidation = getValidation;\n/**\n * @since 1.19.0\n */\nfunction getValidationSemigroup(SE, SA) {\n    return {\n        concat: function (fx, fy) {\n            return exports.isLeft(fx)\n                ? exports.isLeft(fy)\n                    ? exports.left(SE.concat(fx.value, fy.value))\n                    : fx\n                : exports.isLeft(fy)\n                    ? fy\n                    : exports.right(SA.concat(fx.value, fy.value));\n        }\n    };\n}\nexports.getValidationSemigroup = getValidationSemigroup;\n/**\n * @since 1.19.0\n */\nfunction getValidationMonoid(SE, SA) {\n    return {\n        concat: getValidationSemigroup(SE, SA).concat,\n        empty: exports.right(SA.empty)\n    };\n}\nexports.getValidationMonoid = getValidationMonoid;\nvar _a = pipeable_1.pipeable(exports.either), alt = _a.alt, ap = _a.ap, apFirst = _a.apFirst, apSecond = _a.apSecond, bimap = _a.bimap, chain = _a.chain, chainFirst = _a.chainFirst, duplicate = _a.duplicate, extend = _a.extend, flatten = _a.flatten, foldMap = _a.foldMap, map = _a.map, mapLeft = _a.mapLeft, reduce = _a.reduce, reduceRight = _a.reduceRight, fromPredicate = _a.fromPredicate, filterOrElse = _a.filterOrElse, pipeableFromOption = _a.fromOption;\nexports.alt = alt;\nexports.ap = ap;\nexports.apFirst = apFirst;\nexports.apSecond = apSecond;\nexports.bimap = bimap;\nexports.chain = chain;\nexports.chainFirst = chainFirst;\nexports.duplicate = duplicate;\nexports.extend = extend;\nexports.flatten = flatten;\nexports.foldMap = foldMap;\nexports.map = map;\nexports.mapLeft = mapLeft;\nexports.reduce = reduce;\nexports.reduceRight = reduceRight;\nexports.fromPredicate = fromPredicate;\nexports.filterOrElse = filterOrElse;\n/**\n * Lazy version of `fromOption`\n *\n * @since 1.3.0\n */\nexports.fromOptionL = pipeableFromOption;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW8tdHMvbm9kZV9tb2R1bGVzL2ZwLXRzL2xpYi9FaXRoZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLG1CQUFPLENBQUMsaUZBQVk7QUFDckMsaUJBQWlCLG1CQUFPLENBQUMsaUZBQVk7QUFDckMsV0FBVyxtQkFBTyxDQUFDLHFFQUFNO0FBQ3pCLGlCQUFpQixtQkFBTyxDQUFDLGlGQUFZO0FBQ3JDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLDZCQUE2Qiw2QkFBNkIsb0NBQW9DLGlCQUFpQixxQ0FBcUM7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1YsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2IsYUFBYTtBQUNiLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakIsY0FBYztBQUNkLGVBQWU7QUFDZixlQUFlO0FBQ2YsV0FBVztBQUNYLGVBQWU7QUFDZixjQUFjO0FBQ2QsbUJBQW1CO0FBQ25CLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvaW8tdHMvbm9kZV9tb2R1bGVzL2ZwLXRzL2xpYi9FaXRoZXIuanM/OWNlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGUgUmVwcmVzZW50cyBhIHZhbHVlIG9mIG9uZSBvZiB0d28gcG9zc2libGUgdHlwZXMgKGEgZGlzam9pbnQgdW5pb24pLlxuICpcbiAqIEFuIGluc3RhbmNlIG9mIGBFaXRoZXJgIGlzIGVpdGhlciBhbiBpbnN0YW5jZSBvZiBgTGVmdGAgb3IgYFJpZ2h0YC5cbiAqXG4gKiBBIGNvbW1vbiB1c2Ugb2YgYEVpdGhlcmAgaXMgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gYE9wdGlvbmAgZm9yIGRlYWxpbmcgd2l0aCBwb3NzaWJsZSBtaXNzaW5nIHZhbHVlcy4gSW4gdGhpcyB1c2FnZSxcbiAqIGBOb25lYCBpcyByZXBsYWNlZCB3aXRoIGEgYExlZnRgIHdoaWNoIGNhbiBjb250YWluIHVzZWZ1bCBpbmZvcm1hdGlvbi4gYFJpZ2h0YCB0YWtlcyB0aGUgcGxhY2Ugb2YgYFNvbWVgLiBDb252ZW50aW9uXG4gKiBkaWN0YXRlcyB0aGF0IGBMZWZ0YCBpcyB1c2VkIGZvciBmYWlsdXJlIGFuZCBgUmlnaHRgIGlzIHVzZWQgZm9yIHN1Y2Nlc3MuXG4gKlxuICogRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCB1c2UgYEVpdGhlcjxzdHJpbmcsIG51bWJlcj5gIHRvIGRldGVjdCB3aGV0aGVyIGEgcmVjZWl2ZWQgaW5wdXQgaXMgYSBgc3RyaW5nYCBvciBhIGBudW1iZXJgLlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBwYXJzZSA9IChlcnJvck1lc3NhZ2U6IHN0cmluZykgPT4gKGlucHV0OiBzdHJpbmcpOiBFaXRoZXI8c3RyaW5nLCBudW1iZXI+ID0+IHtcbiAqICAgY29uc3QgbiA9IHBhcnNlSW50KGlucHV0LCAxMClcbiAqICAgcmV0dXJuIGlzTmFOKG4pID8gbGVmdChlcnJvck1lc3NhZ2UpIDogcmlnaHQobilcbiAqIH1cbiAqIGBgYFxuICpcbiAqIGBFaXRoZXJgIGlzIHJpZ2h0LWJpYXNlZCwgd2hpY2ggbWVhbnMgdGhhdCBgUmlnaHRgIGlzIGFzc3VtZWQgdG8gYmUgdGhlIGRlZmF1bHQgY2FzZSB0byBvcGVyYXRlIG9uLiBJZiBpdCBpcyBgTGVmdGAsXG4gKiBvcGVyYXRpb25zIGxpa2UgYG1hcGAsIGBjaGFpbmAsIC4uLiByZXR1cm4gdGhlIGBMZWZ0YCB2YWx1ZSB1bmNoYW5nZWQ6XG4gKlxuICogYGBgdHNcbiAqIHJpZ2h0KDEyKS5tYXAoZG91YmxlKSAvLyByaWdodCgyNClcbiAqIGxlZnQoMjMpLm1hcChkb3VibGUpICAvLyBsZWZ0KDIzKVxuICogYGBgXG4gKi9cbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ2hhaW5SZWNfMSA9IHJlcXVpcmUoXCIuL0NoYWluUmVjXCIpO1xudmFyIGZ1bmN0aW9uXzEgPSByZXF1aXJlKFwiLi9mdW5jdGlvblwiKTtcbnZhciBFcV8xID0gcmVxdWlyZShcIi4vRXFcIik7XG52YXIgcGlwZWFibGVfMSA9IHJlcXVpcmUoXCIuL3BpcGVhYmxlXCIpO1xuZXhwb3J0cy5VUkkgPSAnRWl0aGVyJztcbi8qKlxuICogTGVmdCBzaWRlIG9mIGBFaXRoZXJgXG4gKi9cbnZhciBMZWZ0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExlZnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl90YWcgPSAnTGVmdCc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBnaXZlbiBmdW5jdGlvbiBpcyBhcHBsaWVkIGlmIHRoaXMgaXMgYSBgUmlnaHRgXG4gICAgICogQG9ic29sZXRlXG4gICAgICovXG4gICAgTGVmdC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogQG9ic29sZXRlICovXG4gICAgTGVmdC5wcm90b3R5cGUuYXAgPSBmdW5jdGlvbiAoZmFiKSB7XG4gICAgICAgIHJldHVybiAoZmFiLmlzTGVmdCgpID8gZmFiIDogdGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGbGlwcGVkIHZlcnNpb24gb2YgYGFwYFxuICAgICAqIEBvYnNvbGV0ZVxuICAgICAqL1xuICAgIExlZnQucHJvdG90eXBlLmFwXyA9IGZ1bmN0aW9uIChmYikge1xuICAgICAgICByZXR1cm4gZmIuYXAodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCaW5kcyB0aGUgZ2l2ZW4gZnVuY3Rpb24gYWNyb3NzIGBSaWdodGBcbiAgICAgKiBAb2Jzb2xldGVcbiAgICAgKi9cbiAgICBMZWZ0LnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIEBvYnNvbGV0ZSAqL1xuICAgIExlZnQucHJvdG90eXBlLmJpbWFwID0gZnVuY3Rpb24gKGYsIGcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMZWZ0KGYodGhpcy52YWx1ZSkpO1xuICAgIH07XG4gICAgLyoqIEBvYnNvbGV0ZSAqL1xuICAgIExlZnQucHJvdG90eXBlLmFsdCA9IGZ1bmN0aW9uIChmeSkge1xuICAgICAgICByZXR1cm4gZnk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMYXp5IHZlcnNpb24gb2YgYGFsdGBcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW1wb3J0IHsgcmlnaHQgfSBmcm9tICdmcC10cy9saWIvRWl0aGVyJ1xuICAgICAqXG4gICAgICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChyaWdodCgxKS5vckVsc2UoKCkgPT4gcmlnaHQoMikpLCByaWdodCgxKSlcbiAgICAgKlxuICAgICAqIEBzaW5jZSAxLjYuMFxuICAgICAqIEBvYnNvbGV0ZVxuICAgICAqL1xuICAgIExlZnQucHJvdG90eXBlLm9yRWxzZSA9IGZ1bmN0aW9uIChmeSkge1xuICAgICAgICByZXR1cm4gZnkodGhpcy52YWx1ZSk7XG4gICAgfTtcbiAgICAvKiogQG9ic29sZXRlICovXG4gICAgTGVmdC5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogQG9ic29sZXRlICovXG4gICAgTGVmdC5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGIsIGYpIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgZnVuY3Rpb24gdG8gZWFjaCBjYXNlIGluIHRoZSBkYXRhIHN0cnVjdHVyZVxuICAgICAqIEBvYnNvbGV0ZVxuICAgICAqL1xuICAgIExlZnQucHJvdG90eXBlLmZvbGQgPSBmdW5jdGlvbiAob25MZWZ0LCBvblJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBvbkxlZnQodGhpcy52YWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBmcm9tIHRoaXMgYFJpZ2h0YCBvciB0aGUgZ2l2ZW4gYXJndW1lbnQgaWYgdGhpcyBpcyBhIGBMZWZ0YFxuICAgICAqIEBvYnNvbGV0ZVxuICAgICAqL1xuICAgIExlZnQucHJvdG90eXBlLmdldE9yRWxzZSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgZnJvbSB0aGlzIGBSaWdodGAgb3IgdGhlIHJlc3VsdCBvZiBnaXZlbiBhcmd1bWVudCBpZiB0aGlzIGlzIGEgYExlZnRgXG4gICAgICogQG9ic29sZXRlXG4gICAgICovXG4gICAgTGVmdC5wcm90b3R5cGUuZ2V0T3JFbHNlTCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmKHRoaXMudmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWFwcyB0aGUgbGVmdCBzaWRlIG9mIHRoZSBkaXNqdW5jdGlvblxuICAgICAqIEBvYnNvbGV0ZVxuICAgICAqL1xuICAgIExlZnQucHJvdG90eXBlLm1hcExlZnQgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gbmV3IExlZnQoZih0aGlzLnZhbHVlKSk7XG4gICAgfTtcbiAgICBMZWZ0LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgIH07XG4gICAgTGVmdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGVwcmVjYXRpb25cbiAgICAgICAgcmV0dXJuIFwibGVmdChcIiArIGZ1bmN0aW9uXzEudG9TdHJpbmcodGhpcy52YWx1ZSkgKyBcIilcIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBlaXRoZXIgaXMgYW4gaW5zdGFuY2Ugb2YgYExlZnRgLCBgZmFsc2VgIG90aGVyd2lzZVxuICAgICAqIEBvYnNvbGV0ZVxuICAgICAqL1xuICAgIExlZnQucHJvdG90eXBlLmlzTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZWl0aGVyIGlzIGFuIGluc3RhbmNlIG9mIGBSaWdodGAsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gICAgICogQG9ic29sZXRlXG4gICAgICovXG4gICAgTGVmdC5wcm90b3R5cGUuaXNSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3dhcHMgdGhlIGRpc2p1bmN0aW9uIHZhbHVlc1xuICAgICAqIEBvYnNvbGV0ZVxuICAgICAqL1xuICAgIExlZnQucHJvdG90eXBlLnN3YXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlnaHQodGhpcy52YWx1ZSk7XG4gICAgfTtcbiAgICBMZWZ0LnByb3RvdHlwZS5maWx0ZXJPckVsc2UgPSBmdW5jdGlvbiAoXywgemVybykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIExlZnQucHJvdG90eXBlLmZpbHRlck9yRWxzZUwgPSBmdW5jdGlvbiAoXywgemVybykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVzZSBgZmlsdGVyT3JFbHNlYCBpbnN0ZWFkXG4gICAgICogQHNpbmNlIDEuNi4wXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBMZWZ0LnByb3RvdHlwZS5yZWZpbmVPckVsc2UgPSBmdW5jdGlvbiAocCwgemVybykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExhenkgdmVyc2lvbiBvZiBgcmVmaW5lT3JFbHNlYFxuICAgICAqIFVzZSBgZmlsdGVyT3JFbHNlTGAgaW5zdGVhZFxuICAgICAqIEBzaW5jZSAxLjYuMFxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgTGVmdC5wcm90b3R5cGUucmVmaW5lT3JFbHNlTCA9IGZ1bmN0aW9uIChwLCB6ZXJvKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIExlZnQ7XG59KCkpO1xuZXhwb3J0cy5MZWZ0ID0gTGVmdDtcbi8qKlxuICogUmlnaHQgc2lkZSBvZiBgRWl0aGVyYFxuICovXG52YXIgUmlnaHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmlnaHQodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl90YWcgPSAnUmlnaHQnO1xuICAgIH1cbiAgICBSaWdodC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaWdodChmKHRoaXMudmFsdWUpKTtcbiAgICB9O1xuICAgIFJpZ2h0LnByb3RvdHlwZS5hcCA9IGZ1bmN0aW9uIChmYWIpIHtcbiAgICAgICAgcmV0dXJuIGZhYi5pc1JpZ2h0KCkgPyB0aGlzLm1hcChmYWIudmFsdWUpIDogZXhwb3J0cy5sZWZ0KGZhYi52YWx1ZSk7XG4gICAgfTtcbiAgICBSaWdodC5wcm90b3R5cGUuYXBfID0gZnVuY3Rpb24gKGZiKSB7XG4gICAgICAgIHJldHVybiBmYi5hcCh0aGlzKTtcbiAgICB9O1xuICAgIFJpZ2h0LnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmKHRoaXMudmFsdWUpO1xuICAgIH07XG4gICAgUmlnaHQucHJvdG90eXBlLmJpbWFwID0gZnVuY3Rpb24gKGYsIGcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaWdodChnKHRoaXMudmFsdWUpKTtcbiAgICB9O1xuICAgIFJpZ2h0LnByb3RvdHlwZS5hbHQgPSBmdW5jdGlvbiAoZnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBSaWdodC5wcm90b3R5cGUub3JFbHNlID0gZnVuY3Rpb24gKGZ5KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUmlnaHQucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlnaHQoZih0aGlzKSk7XG4gICAgfTtcbiAgICBSaWdodC5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGIsIGYpIHtcbiAgICAgICAgcmV0dXJuIGYoYiwgdGhpcy52YWx1ZSk7XG4gICAgfTtcbiAgICBSaWdodC5wcm90b3R5cGUuZm9sZCA9IGZ1bmN0aW9uIChvbkxlZnQsIG9uUmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIG9uUmlnaHQodGhpcy52YWx1ZSk7XG4gICAgfTtcbiAgICBSaWdodC5wcm90b3R5cGUuZ2V0T3JFbHNlID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfTtcbiAgICBSaWdodC5wcm90b3R5cGUuZ2V0T3JFbHNlTCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH07XG4gICAgUmlnaHQucHJvdG90eXBlLm1hcExlZnQgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gbmV3IFJpZ2h0KHRoaXMudmFsdWUpO1xuICAgIH07XG4gICAgUmlnaHQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICBSaWdodC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGVwcmVjYXRpb25cbiAgICAgICAgcmV0dXJuIFwicmlnaHQoXCIgKyBmdW5jdGlvbl8xLnRvU3RyaW5nKHRoaXMudmFsdWUpICsgXCIpXCI7XG4gICAgfTtcbiAgICBSaWdodC5wcm90b3R5cGUuaXNMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBSaWdodC5wcm90b3R5cGUuaXNSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBSaWdodC5wcm90b3R5cGUuc3dhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMZWZ0KHRoaXMudmFsdWUpO1xuICAgIH07XG4gICAgUmlnaHQucHJvdG90eXBlLmZpbHRlck9yRWxzZSA9IGZ1bmN0aW9uIChwLCB6ZXJvKSB7XG4gICAgICAgIHJldHVybiBwKHRoaXMudmFsdWUpID8gdGhpcyA6IGV4cG9ydHMubGVmdCh6ZXJvKTtcbiAgICB9O1xuICAgIFJpZ2h0LnByb3RvdHlwZS5maWx0ZXJPckVsc2VMID0gZnVuY3Rpb24gKHAsIHplcm8pIHtcbiAgICAgICAgcmV0dXJuIHAodGhpcy52YWx1ZSkgPyB0aGlzIDogZXhwb3J0cy5sZWZ0KHplcm8odGhpcy52YWx1ZSkpO1xuICAgIH07XG4gICAgUmlnaHQucHJvdG90eXBlLnJlZmluZU9yRWxzZSA9IGZ1bmN0aW9uIChwLCB6ZXJvKSB7XG4gICAgICAgIHJldHVybiBwKHRoaXMudmFsdWUpID8gdGhpcyA6IGV4cG9ydHMubGVmdCh6ZXJvKTtcbiAgICB9O1xuICAgIFJpZ2h0LnByb3RvdHlwZS5yZWZpbmVPckVsc2VMID0gZnVuY3Rpb24gKHAsIHplcm8pIHtcbiAgICAgICAgcmV0dXJuIHAodGhpcy52YWx1ZSkgPyB0aGlzIDogZXhwb3J0cy5sZWZ0KHplcm8odGhpcy52YWx1ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFJpZ2h0O1xufSgpKTtcbmV4cG9ydHMuUmlnaHQgPSBSaWdodDtcbi8qKlxuICogQHNpbmNlIDEuMTcuMFxuICovXG5leHBvcnRzLmdldFNob3cgPSBmdW5jdGlvbiAoU0wsIFNBKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2hvdzogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUuZm9sZChmdW5jdGlvbiAobCkgeyByZXR1cm4gXCJsZWZ0KFwiICsgU0wuc2hvdyhsKSArIFwiKVwiOyB9LCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gXCJyaWdodChcIiArIFNBLnNob3coYSkgKyBcIilcIjsgfSk7IH1cbiAgICB9O1xufTtcbi8qKlxuICogVXNlIGBnZXRFcWBcbiAqXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuZ2V0U2V0b2lkID0gZ2V0RXE7XG4vKipcbiAqIEBzaW5jZSAxLjE5LjBcbiAqL1xuZnVuY3Rpb24gZ2V0RXEoRUwsIEVBKSB7XG4gICAgcmV0dXJuIEVxXzEuZnJvbUVxdWFscyhmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4geC5pc0xlZnQoKSA/IHkuaXNMZWZ0KCkgJiYgRUwuZXF1YWxzKHgudmFsdWUsIHkudmFsdWUpIDogeS5pc1JpZ2h0KCkgJiYgRUEuZXF1YWxzKHgudmFsdWUsIHkudmFsdWUpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5nZXRFcSA9IGdldEVxO1xuLyoqXG4gKiBTZW1pZ3JvdXAgcmV0dXJuaW5nIHRoZSBsZWZ0LW1vc3Qgbm9uLWBMZWZ0YCB2YWx1ZS4gSWYgYm90aCBvcGVyYW5kcyBhcmUgYFJpZ2h0YHMgdGhlbiB0aGUgaW5uZXIgdmFsdWVzIGFyZVxuICogYXBwZW5kZWQgdXNpbmcgdGhlIHByb3ZpZGVkIGBTZW1pZ3JvdXBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGdldFNlbWlncm91cCwgbGVmdCwgcmlnaHQgfSBmcm9tICdmcC10cy9saWIvRWl0aGVyJ1xuICogaW1wb3J0IHsgc2VtaWdyb3VwU3VtIH0gZnJvbSAnZnAtdHMvbGliL1NlbWlncm91cCdcbiAqXG4gKiBjb25zdCBTID0gZ2V0U2VtaWdyb3VwPHN0cmluZywgbnVtYmVyPihzZW1pZ3JvdXBTdW0pXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFMuY29uY2F0KGxlZnQoJ2EnKSwgbGVmdCgnYicpKSwgbGVmdCgnYScpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChTLmNvbmNhdChsZWZ0KCdhJyksIHJpZ2h0KDIpKSwgcmlnaHQoMikpXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFMuY29uY2F0KHJpZ2h0KDEpLCBsZWZ0KCdiJykpLCByaWdodCgxKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoUy5jb25jYXQocmlnaHQoMSksIHJpZ2h0KDIpKSwgcmlnaHQoMykpXG4gKlxuICpcbiAqIEBzaW5jZSAxLjcuMFxuICovXG5leHBvcnRzLmdldFNlbWlncm91cCA9IGZ1bmN0aW9uIChTKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uY2F0OiBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4gKHkuaXNMZWZ0KCkgPyB4IDogeC5pc0xlZnQoKSA/IHkgOiBleHBvcnRzLnJpZ2h0KFMuY29uY2F0KHgudmFsdWUsIHkudmFsdWUpKSk7IH1cbiAgICB9O1xufTtcbi8qKlxuICogYEFwcGx5YCBzZW1pZ3JvdXBcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgZ2V0QXBwbHlTZW1pZ3JvdXAsIGxlZnQsIHJpZ2h0IH0gZnJvbSAnZnAtdHMvbGliL0VpdGhlcidcbiAqIGltcG9ydCB7IHNlbWlncm91cFN1bSB9IGZyb20gJ2ZwLXRzL2xpYi9TZW1pZ3JvdXAnXG4gKlxuICogY29uc3QgUyA9IGdldEFwcGx5U2VtaWdyb3VwPHN0cmluZywgbnVtYmVyPihzZW1pZ3JvdXBTdW0pXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKFMuY29uY2F0KGxlZnQoJ2EnKSwgbGVmdCgnYicpKSwgbGVmdCgnYScpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChTLmNvbmNhdChsZWZ0KCdhJyksIHJpZ2h0KDIpKSwgbGVmdCgnYScpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChTLmNvbmNhdChyaWdodCgxKSwgbGVmdCgnYicpKSwgbGVmdCgnYicpKVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChTLmNvbmNhdChyaWdodCgxKSwgcmlnaHQoMikpLCByaWdodCgzKSlcbiAqXG4gKlxuICogQHNpbmNlIDEuNy4wXG4gKi9cbmV4cG9ydHMuZ2V0QXBwbHlTZW1pZ3JvdXAgPSBmdW5jdGlvbiAoUykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbmNhdDogZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuICh4LmlzTGVmdCgpID8geCA6IHkuaXNMZWZ0KCkgPyB5IDogZXhwb3J0cy5yaWdodChTLmNvbmNhdCh4LnZhbHVlLCB5LnZhbHVlKSkpOyB9XG4gICAgfTtcbn07XG4vKipcbiAqIEBzaW5jZSAxLjcuMFxuICovXG5leHBvcnRzLmdldEFwcGx5TW9ub2lkID0gZnVuY3Rpb24gKE0pIHtcbiAgICByZXR1cm4gX19hc3NpZ24oe30sIGV4cG9ydHMuZ2V0QXBwbHlTZW1pZ3JvdXAoTSksIHsgZW1wdHk6IGV4cG9ydHMucmlnaHQoTS5lbXB0eSkgfSk7XG59O1xuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGBFaXRoZXJgIGhvbGRpbmcgYSBgTGVmdGAgdmFsdWUuIFRoaXMgdXN1YWxseSByZXByZXNlbnRzIGEgZmFpbHVyZSwgZHVlIHRvIHRoZSByaWdodC1iaWFzIG9mIHRoaXNcbiAqIHN0cnVjdHVyZVxuICpcbiAqIEBzaW5jZSAxLjAuMFxuICovXG5leHBvcnRzLmxlZnQgPSBmdW5jdGlvbiAobCkge1xuICAgIHJldHVybiBuZXcgTGVmdChsKTtcbn07XG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYEVpdGhlcmAgaG9sZGluZyBhIGBSaWdodGAgdmFsdWUuIFRoaXMgdXN1YWxseSByZXByZXNlbnRzIGEgc3VjY2Vzc2Z1bCB2YWx1ZSBkdWUgdG8gdGhlIHJpZ2h0IGJpYXNcbiAqIG9mIHRoaXMgc3RydWN0dXJlXG4gKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydHMucmlnaHQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBuZXcgUmlnaHQoYSk7XG59O1xuLyoqXG4gKiBVc2UgYGZyb21QcmVkaWNhdGVgIGluc3RlYWRcbiAqXG4gKiBAc2luY2UgMS42LjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuZnJvbVJlZmluZW1lbnQgPSBmdW5jdGlvbiAocmVmaW5lbWVudCwgb25GYWxzZSkgeyByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gcmVmaW5lbWVudChhKSA/IGV4cG9ydHMucmlnaHQoYSkgOiBleHBvcnRzLmxlZnQob25GYWxzZShhKSk7XG59OyB9O1xuLyoqXG4gKiBUYWtlcyBhIGRlZmF1bHQgYW5kIGEgYE9wdGlvbmAgdmFsdWUsIGlmIHRoZSB2YWx1ZSBpcyBhIGBTb21lYCwgdHVybiBpdCBpbnRvIGEgYFJpZ2h0YCwgaWYgdGhlIHZhbHVlIGlzIGEgYE5vbmVgIHVzZVxuICogdGhlIHByb3ZpZGVkIGRlZmF1bHQgYXMgYSBgTGVmdGBcbiAqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xuZXhwb3J0cy5mcm9tT3B0aW9uID0gZnVuY3Rpb24gKG9uTm9uZSkgeyByZXR1cm4gZnVuY3Rpb24gKGZhKSB7XG4gICAgcmV0dXJuIGZhLmlzTm9uZSgpID8gZXhwb3J0cy5sZWZ0KG9uTm9uZSkgOiBleHBvcnRzLnJpZ2h0KGZhLnZhbHVlKTtcbn07IH07XG4vKipcbiAqIFRha2VzIGEgZGVmYXVsdCBhbmQgYSBudWxsYWJsZSB2YWx1ZSwgaWYgdGhlIHZhbHVlIGlzIG5vdCBudWxseSwgdHVybiBpdCBpbnRvIGEgYFJpZ2h0YCwgaWYgdGhlIHZhbHVlIGlzIG51bGx5IHVzZVxuICogdGhlIHByb3ZpZGVkIGRlZmF1bHQgYXMgYSBgTGVmdGBcbiAqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xuZXhwb3J0cy5mcm9tTnVsbGFibGUgPSBmdW5jdGlvbiAoZGVmYXVsdFZhbHVlKSB7IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBhID09IG51bGwgPyBleHBvcnRzLmxlZnQoZGVmYXVsdFZhbHVlKSA6IGV4cG9ydHMucmlnaHQoYSk7XG59OyB9O1xuLyoqXG4gKiBEZWZhdWx0IHZhbHVlIGZvciB0aGUgb3B0aW9uYWwgYG9uZXJyb3JgIGFyZ3VtZW50IG9mIGB0cnlDYXRjaGBcbiAqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xuZXhwb3J0cy50b0Vycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihTdHJpbmcoZSkpO1xuICAgIH1cbn07XG4vKipcbiAqIFVzZSBgdHJ5Q2F0Y2gydmAgaW5zdGVhZFxuICpcbiAqIEBzaW5jZSAxLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0cy50cnlDYXRjaCA9IGZ1bmN0aW9uIChmLCBvbmVycm9yKSB7XG4gICAgaWYgKG9uZXJyb3IgPT09IHZvaWQgMCkgeyBvbmVycm9yID0gZXhwb3J0cy50b0Vycm9yOyB9XG4gICAgcmV0dXJuIGV4cG9ydHMudHJ5Q2F0Y2gydihmLCBvbmVycm9yKTtcbn07XG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYEVpdGhlcmAgZnJvbSBhIGZ1bmN0aW9uIHRoYXQgbWlnaHQgdGhyb3dcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgRWl0aGVyLCBsZWZ0LCByaWdodCwgdHJ5Q2F0Y2gydiB9IGZyb20gJ2ZwLXRzL2xpYi9FaXRoZXInXG4gKlxuICogY29uc3QgdW5zYWZlSGVhZCA9IDxBPihhczogQXJyYXk8QT4pOiBBID0+IHtcbiAqICAgaWYgKGFzLmxlbmd0aCA+IDApIHtcbiAqICAgICByZXR1cm4gYXNbMF1cbiAqICAgfSBlbHNlIHtcbiAqICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VtcHR5IGFycmF5JylcbiAqICAgfVxuICogfVxuICpcbiAqIGNvbnN0IGhlYWQgPSA8QT4oYXM6IEFycmF5PEE+KTogRWl0aGVyPEVycm9yLCBBPiA9PiB7XG4gKiAgIHJldHVybiB0cnlDYXRjaDJ2KCgpID0+IHVuc2FmZUhlYWQoYXMpLCBlID0+IChlIGluc3RhbmNlb2YgRXJyb3IgPyBlIDogbmV3IEVycm9yKCd1bmtub3duIGVycm9yJykpKVxuICogfVxuICpcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaGVhZChbXSksIGxlZnQobmV3IEVycm9yKCdlbXB0eSBhcnJheScpKSlcbiAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoaGVhZChbMSwgMiwgM10pLCByaWdodCgxKSlcbiAqXG4gKiBAc2luY2UgMS4xMS4wXG4gKi9cbmV4cG9ydHMudHJ5Q2F0Y2gydiA9IGZ1bmN0aW9uIChmLCBvbmVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucmlnaHQoZigpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMubGVmdChvbmVycm9yKGUpKTtcbiAgICB9XG59O1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xuZXhwb3J0cy5mcm9tVmFsaWRhdGlvbiA9IGZ1bmN0aW9uIChmYSkge1xuICAgIHJldHVybiBmYS5pc0ZhaWx1cmUoKSA/IGV4cG9ydHMubGVmdChmYS52YWx1ZSkgOiBleHBvcnRzLnJpZ2h0KGZhLnZhbHVlKTtcbn07XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBlaXRoZXIgaXMgYW4gaW5zdGFuY2Ugb2YgYExlZnRgLCBgZmFsc2VgIG90aGVyd2lzZVxuICpcbiAqIEBzaW5jZSAxLjAuMFxuICovXG5leHBvcnRzLmlzTGVmdCA9IGZ1bmN0aW9uIChmYSkge1xuICAgIHJldHVybiBmYS5pc0xlZnQoKTtcbn07XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBlaXRoZXIgaXMgYW4gaW5zdGFuY2Ugb2YgYFJpZ2h0YCwgYGZhbHNlYCBvdGhlcndpc2VcbiAqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xuZXhwb3J0cy5pc1JpZ2h0ID0gZnVuY3Rpb24gKGZhKSB7XG4gICAgcmV0dXJuIGZhLmlzUmlnaHQoKTtcbn07XG4vKipcbiAqIFVzZSBgZ2V0V2l0aGVyYWJsZWBcbiAqXG4gKiBAc2luY2UgMS43LjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmZ1bmN0aW9uIGdldENvbXBhY3RhYmxlKE1MKSB7XG4gICAgdmFyIGNvbXBhY3QgPSBmdW5jdGlvbiAoZmEpIHtcbiAgICAgICAgaWYgKGZhLmlzTGVmdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZhLnZhbHVlLmlzTm9uZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5sZWZ0KE1MLmVtcHR5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5yaWdodChmYS52YWx1ZS52YWx1ZSk7XG4gICAgfTtcbiAgICB2YXIgc2VwYXJhdGUgPSBmdW5jdGlvbiAoZmEpIHtcbiAgICAgICAgaWYgKGZhLmlzTGVmdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGZhLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBmYVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmEudmFsdWUuaXNMZWZ0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGVmdDogZXhwb3J0cy5yaWdodChmYS52YWx1ZS52YWx1ZSksXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGV4cG9ydHMubGVmdChNTC5lbXB0eSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IGV4cG9ydHMubGVmdChNTC5lbXB0eSksXG4gICAgICAgICAgICByaWdodDogZXhwb3J0cy5yaWdodChmYS52YWx1ZS52YWx1ZSlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIFVSSTogZXhwb3J0cy5VUkksXG4gICAgICAgIF9MOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbXBhY3Q6IGNvbXBhY3QsXG4gICAgICAgIHNlcGFyYXRlOiBzZXBhcmF0ZVxuICAgIH07XG59XG5leHBvcnRzLmdldENvbXBhY3RhYmxlID0gZ2V0Q29tcGFjdGFibGU7XG4vKipcbiAqIFVzZSBgZ2V0V2l0aGVyYWJsZWBcbiAqXG4gKiBAc2luY2UgMS43LjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmZ1bmN0aW9uIGdldEZpbHRlcmFibGUoTUwpIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGRlcHJlY2F0aW9uXG4gICAgdmFyIEMgPSBnZXRDb21wYWN0YWJsZShNTCk7XG4gICAgdmFyIHBhcnRpdGlvbk1hcCA9IGZ1bmN0aW9uIChmYSwgZikge1xuICAgICAgICBpZiAoZmEuaXNMZWZ0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGVmdDogZmEsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGZhXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBlID0gZihmYS52YWx1ZSk7XG4gICAgICAgIGlmIChlLmlzTGVmdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGV4cG9ydHMucmlnaHQoZS52YWx1ZSksXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGV4cG9ydHMubGVmdChNTC5lbXB0eSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IGV4cG9ydHMubGVmdChNTC5lbXB0eSksXG4gICAgICAgICAgICByaWdodDogZXhwb3J0cy5yaWdodChlLnZhbHVlKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIHBhcnRpdGlvbiA9IGZ1bmN0aW9uIChmYSwgcCkge1xuICAgICAgICBpZiAoZmEuaXNMZWZ0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGVmdDogZmEsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGZhXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwKGZhLnZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBleHBvcnRzLmxlZnQoTUwuZW1wdHkpLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBleHBvcnRzLnJpZ2h0KGZhLnZhbHVlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogZXhwb3J0cy5yaWdodChmYS52YWx1ZSksXG4gICAgICAgICAgICByaWdodDogZXhwb3J0cy5sZWZ0KE1MLmVtcHR5KVxuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIGZpbHRlck1hcCA9IGZ1bmN0aW9uIChmYSwgZikge1xuICAgICAgICBpZiAoZmEuaXNMZWZ0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9uQiA9IGYoZmEudmFsdWUpO1xuICAgICAgICBpZiAob3B0aW9uQi5pc1NvbWUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMucmlnaHQob3B0aW9uQi52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cG9ydHMubGVmdChNTC5lbXB0eSk7XG4gICAgfTtcbiAgICB2YXIgZmlsdGVyID0gZnVuY3Rpb24gKGZhLCBwKSB7IHJldHVybiBmYS5maWx0ZXJPckVsc2UocCwgTUwuZW1wdHkpOyB9O1xuICAgIHJldHVybiBfX2Fzc2lnbih7fSwgQywgeyBtYXA6IGV4cG9ydHMuZWl0aGVyLm1hcCwgcGFydGl0aW9uTWFwOiBwYXJ0aXRpb25NYXAsXG4gICAgICAgIGZpbHRlck1hcDogZmlsdGVyTWFwLFxuICAgICAgICBwYXJ0aXRpb246IHBhcnRpdGlvbixcbiAgICAgICAgZmlsdGVyOiBmaWx0ZXIgfSk7XG59XG5leHBvcnRzLmdldEZpbHRlcmFibGUgPSBnZXRGaWx0ZXJhYmxlO1xuLyoqXG4gKiBCdWlsZHMgYFdpdGhlcmFibGVgIGluc3RhbmNlIGZvciBgRWl0aGVyYCBnaXZlbiBgTW9ub2lkYCBmb3IgdGhlIGxlZnQgc2lkZVxuICpcbiAqIEBzaW5jZSAxLjcuMFxuICovXG5mdW5jdGlvbiBnZXRXaXRoZXJhYmxlKE1MKSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBkZXByZWNhdGlvblxuICAgIHZhciBmaWx0ZXJhYmxlRWl0aGVyID0gZ2V0RmlsdGVyYWJsZShNTCk7XG4gICAgdmFyIHdpdGhlciA9IGZ1bmN0aW9uIChGKSB7XG4gICAgICAgIHZhciB0cmF2ZXJzZUYgPSBleHBvcnRzLmVpdGhlci50cmF2ZXJzZShGKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh3YSwgZikgeyByZXR1cm4gRi5tYXAodHJhdmVyc2VGKHdhLCBmKSwgZmlsdGVyYWJsZUVpdGhlci5jb21wYWN0KTsgfTtcbiAgICB9O1xuICAgIHZhciB3aWx0ID0gZnVuY3Rpb24gKEYpIHtcbiAgICAgICAgdmFyIHRyYXZlcnNlRiA9IGV4cG9ydHMuZWl0aGVyLnRyYXZlcnNlKEYpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHdhLCBmKSB7IHJldHVybiBGLm1hcCh0cmF2ZXJzZUYod2EsIGYpLCBmaWx0ZXJhYmxlRWl0aGVyLnNlcGFyYXRlKTsgfTtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbih7fSwgZmlsdGVyYWJsZUVpdGhlciwgeyB0cmF2ZXJzZTogZXhwb3J0cy5laXRoZXIudHJhdmVyc2UsIHJlZHVjZTogZXhwb3J0cy5laXRoZXIucmVkdWNlLCB3aXRoZXI6IHdpdGhlcixcbiAgICAgICAgd2lsdDogd2lsdCB9KTtcbn1cbmV4cG9ydHMuZ2V0V2l0aGVyYWJsZSA9IGdldFdpdGhlcmFibGU7XG4vKipcbiAqIENvbnZlcnRzIGEgSmF2YVNjcmlwdCBPYmplY3QgTm90YXRpb24gKEpTT04pIHN0cmluZyBpbnRvIGFuIG9iamVjdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgcGFyc2VKU09OLCB0b0Vycm9yIH0gZnJvbSAnZnAtdHMvbGliL0VpdGhlcidcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHBhcnNlSlNPTigne1wiYVwiOjF9JywgdG9FcnJvcikudmFsdWUsIHsgYTogMSB9KVxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChwYXJzZUpTT04oJ3tcImFcIjp9JywgdG9FcnJvcikudmFsdWUsIG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCB0b2tlbiB9IGluIEpTT04gYXQgcG9zaXRpb24gNScpKVxuICpcbiAqIEBzaW5jZSAxLjE2LjBcbiAqL1xuZXhwb3J0cy5wYXJzZUpTT04gPSBmdW5jdGlvbiAocywgb25FcnJvcikge1xuICAgIHJldHVybiBleHBvcnRzLnRyeUNhdGNoMnYoZnVuY3Rpb24gKCkgeyByZXR1cm4gSlNPTi5wYXJzZShzKTsgfSwgb25FcnJvcik7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIEphdmFTY3JpcHQgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IE9iamVjdCBOb3RhdGlvbiAoSlNPTikgc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBzdHJpbmdpZnlKU09OLCB0b0Vycm9yIH0gZnJvbSAnZnAtdHMvbGliL0VpdGhlcidcbiAqXG4gKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHN0cmluZ2lmeUpTT04oeyBhOiAxIH0sIHRvRXJyb3IpLnZhbHVlLCAne1wiYVwiOjF9JylcbiAqIGNvbnN0IGNpcmN1bGFyOiBhbnkgPSB7IHJlZjogbnVsbCB9XG4gKiBjaXJjdWxhci5yZWYgPSBjaXJjdWxhclxuICogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChzdHJpbmdpZnlKU09OKGNpcmN1bGFyLCB0b0Vycm9yKS52YWx1ZSwgbmV3IFR5cGVFcnJvcignQ29udmVydGluZyBjaXJjdWxhciBzdHJ1Y3R1cmUgdG8gSlNPTicpKVxuICpcbiAqIEBzaW5jZSAxLjE2LjBcbiAqL1xuZXhwb3J0cy5zdHJpbmdpZnlKU09OID0gZnVuY3Rpb24gKHUsIG9uRXJyb3IpIHtcbiAgICByZXR1cm4gZXhwb3J0cy50cnlDYXRjaDJ2KGZ1bmN0aW9uICgpIHsgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHUpOyB9LCBvbkVycm9yKTtcbn07XG52YXIgdGhyb3dFcnJvciA9IGV4cG9ydHMubGVmdDtcbnZhciBmcm9tRWl0aGVyID0gZnVuY3Rpb25fMS5pZGVudGl0eTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydHMuZWl0aGVyID0ge1xuICAgIFVSSTogZXhwb3J0cy5VUkksXG4gICAgbWFwOiBmdW5jdGlvbiAobWEsIGYpIHsgcmV0dXJuIG1hLm1hcChmKTsgfSxcbiAgICBvZjogZXhwb3J0cy5yaWdodCxcbiAgICBhcDogZnVuY3Rpb24gKG1hYiwgbWEpIHsgcmV0dXJuIG1hLmFwKG1hYik7IH0sXG4gICAgY2hhaW46IGZ1bmN0aW9uIChtYSwgZikgeyByZXR1cm4gbWEuY2hhaW4oZik7IH0sXG4gICAgcmVkdWNlOiBmdW5jdGlvbiAoZmEsIGIsIGYpIHsgcmV0dXJuIGZhLnJlZHVjZShiLCBmKTsgfSxcbiAgICBmb2xkTWFwOiBmdW5jdGlvbiAoTSkgeyByZXR1cm4gZnVuY3Rpb24gKGZhLCBmKSB7IHJldHVybiAoZmEuaXNMZWZ0KCkgPyBNLmVtcHR5IDogZihmYS52YWx1ZSkpOyB9OyB9LFxuICAgIGZvbGRyOiBmdW5jdGlvbiAoZmEsIGIsIGYpIHsgcmV0dXJuIChmYS5pc0xlZnQoKSA/IGIgOiBmKGZhLnZhbHVlLCBiKSk7IH0sXG4gICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChGKSB7IHJldHVybiBmdW5jdGlvbiAodGEsIGYpIHtcbiAgICAgICAgcmV0dXJuIHRhLmlzTGVmdCgpID8gRi5vZihleHBvcnRzLmxlZnQodGEudmFsdWUpKSA6IEYubWFwKGYodGEudmFsdWUpLCBleHBvcnRzLnJpZ2h0KTtcbiAgICB9OyB9LFxuICAgIHNlcXVlbmNlOiBmdW5jdGlvbiAoRikgeyByZXR1cm4gZnVuY3Rpb24gKHRhKSB7XG4gICAgICAgIHJldHVybiB0YS5pc0xlZnQoKSA/IEYub2YoZXhwb3J0cy5sZWZ0KHRhLnZhbHVlKSkgOiBGLm1hcCh0YS52YWx1ZSwgZXhwb3J0cy5yaWdodCk7XG4gICAgfTsgfSxcbiAgICBiaW1hcDogZnVuY3Rpb24gKGZsYSwgZiwgZykgeyByZXR1cm4gZmxhLmJpbWFwKGYsIGcpOyB9LFxuICAgIGFsdDogZnVuY3Rpb24gKG14LCBteSkgeyByZXR1cm4gbXguYWx0KG15KTsgfSxcbiAgICBleHRlbmQ6IGZ1bmN0aW9uICh3YSwgZikgeyByZXR1cm4gd2EuZXh0ZW5kKGYpOyB9LFxuICAgIGNoYWluUmVjOiBmdW5jdGlvbiAoYSwgZikge1xuICAgICAgICByZXR1cm4gQ2hhaW5SZWNfMS50YWlsUmVjKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5pc0xlZnQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLnJpZ2h0KGV4cG9ydHMubGVmdChlLnZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IGUudmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIuaXNMZWZ0KCkgPyBleHBvcnRzLmxlZnQoZihyLnZhbHVlKSkgOiBleHBvcnRzLnJpZ2h0KGV4cG9ydHMucmlnaHQoci52YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmKGEpKTtcbiAgICB9LFxuICAgIHRocm93RXJyb3I6IHRocm93RXJyb3IsXG4gICAgZnJvbUVpdGhlcjogZnJvbUVpdGhlcixcbiAgICBmcm9tT3B0aW9uOiBmdW5jdGlvbiAobywgZSkgeyByZXR1cm4gKG8uaXNOb25lKCkgPyB0aHJvd0Vycm9yKGUpIDogZXhwb3J0cy5yaWdodChvLnZhbHVlKSk7IH1cbn07XG4vL1xuLy8gYmFja3BvcnRpbmdcbi8vXG4vKipcbiAqIEBzaW5jZSAxLjE5LjBcbiAqL1xuZnVuY3Rpb24gZm9sZChvbkxlZnQsIG9uUmlnaHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1hKSB7IHJldHVybiBtYS5mb2xkKG9uTGVmdCwgb25SaWdodCk7IH07XG59XG5leHBvcnRzLmZvbGQgPSBmb2xkO1xuLyoqXG4gKiBAc2luY2UgMS4xOS4wXG4gKi9cbmZ1bmN0aW9uIG9yRWxzZShmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtYSkgeyByZXR1cm4gbWEub3JFbHNlKGYpOyB9O1xufVxuZXhwb3J0cy5vckVsc2UgPSBvckVsc2U7XG4vKipcbiAqIEBzaW5jZSAxLjE5LjBcbiAqL1xuZnVuY3Rpb24gZ2V0T3JFbHNlKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1hKSB7IHJldHVybiBtYS5nZXRPckVsc2VMKGYpOyB9O1xufVxuZXhwb3J0cy5nZXRPckVsc2UgPSBnZXRPckVsc2U7XG4vKipcbiAqIEBzaW5jZSAxLjE5LjBcbiAqL1xuZnVuY3Rpb24gZWxlbShFKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBmdW5jdGlvbiAobWEpIHsgcmV0dXJuIChleHBvcnRzLmlzTGVmdChtYSkgPyBmYWxzZSA6IEUuZXF1YWxzKGEsIG1hLnZhbHVlKSk7IH07IH07XG59XG5leHBvcnRzLmVsZW0gPSBlbGVtO1xuLyoqXG4gKiBAc2luY2UgMS4xOS4wXG4gKi9cbmZ1bmN0aW9uIGdldFZhbGlkYXRpb24oUykge1xuICAgIHJldHVybiB7XG4gICAgICAgIFVSSTogZXhwb3J0cy5VUkksXG4gICAgICAgIF9MOiB1bmRlZmluZWQsXG4gICAgICAgIG1hcDogZXhwb3J0cy5laXRoZXIubWFwLFxuICAgICAgICBvZjogZXhwb3J0cy5laXRoZXIub2YsXG4gICAgICAgIGFwOiBmdW5jdGlvbiAobWFiLCBtYSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuaXNMZWZ0KG1hYilcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuaXNMZWZ0KG1hKVxuICAgICAgICAgICAgICAgICAgICA/IGV4cG9ydHMubGVmdChTLmNvbmNhdChtYWIudmFsdWUsIG1hLnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgOiBtYWJcbiAgICAgICAgICAgICAgICA6IGV4cG9ydHMuaXNMZWZ0KG1hKVxuICAgICAgICAgICAgICAgICAgICA/IG1hXG4gICAgICAgICAgICAgICAgICAgIDogZXhwb3J0cy5yaWdodChtYWIudmFsdWUobWEudmFsdWUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2hhaW46IGV4cG9ydHMuZWl0aGVyLmNoYWluLFxuICAgICAgICBhbHQ6IGZ1bmN0aW9uIChmeCwgZnkpIHtcbiAgICAgICAgICAgIGlmIChleHBvcnRzLmlzUmlnaHQoZngpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuaXNMZWZ0KGZ5KSA/IGV4cG9ydHMubGVmdChTLmNvbmNhdChmeC52YWx1ZSwgZnkudmFsdWUpKSA6IGZ5O1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0VmFsaWRhdGlvbiA9IGdldFZhbGlkYXRpb247XG4vKipcbiAqIEBzaW5jZSAxLjE5LjBcbiAqL1xuZnVuY3Rpb24gZ2V0VmFsaWRhdGlvblNlbWlncm91cChTRSwgU0EpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25jYXQ6IGZ1bmN0aW9uIChmeCwgZnkpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLmlzTGVmdChmeClcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuaXNMZWZ0KGZ5KVxuICAgICAgICAgICAgICAgICAgICA/IGV4cG9ydHMubGVmdChTRS5jb25jYXQoZngudmFsdWUsIGZ5LnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgOiBmeFxuICAgICAgICAgICAgICAgIDogZXhwb3J0cy5pc0xlZnQoZnkpXG4gICAgICAgICAgICAgICAgICAgID8gZnlcbiAgICAgICAgICAgICAgICAgICAgOiBleHBvcnRzLnJpZ2h0KFNBLmNvbmNhdChmeC52YWx1ZSwgZnkudmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLmdldFZhbGlkYXRpb25TZW1pZ3JvdXAgPSBnZXRWYWxpZGF0aW9uU2VtaWdyb3VwO1xuLyoqXG4gKiBAc2luY2UgMS4xOS4wXG4gKi9cbmZ1bmN0aW9uIGdldFZhbGlkYXRpb25Nb25vaWQoU0UsIFNBKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uY2F0OiBnZXRWYWxpZGF0aW9uU2VtaWdyb3VwKFNFLCBTQSkuY29uY2F0LFxuICAgICAgICBlbXB0eTogZXhwb3J0cy5yaWdodChTQS5lbXB0eSlcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRWYWxpZGF0aW9uTW9ub2lkID0gZ2V0VmFsaWRhdGlvbk1vbm9pZDtcbnZhciBfYSA9IHBpcGVhYmxlXzEucGlwZWFibGUoZXhwb3J0cy5laXRoZXIpLCBhbHQgPSBfYS5hbHQsIGFwID0gX2EuYXAsIGFwRmlyc3QgPSBfYS5hcEZpcnN0LCBhcFNlY29uZCA9IF9hLmFwU2Vjb25kLCBiaW1hcCA9IF9hLmJpbWFwLCBjaGFpbiA9IF9hLmNoYWluLCBjaGFpbkZpcnN0ID0gX2EuY2hhaW5GaXJzdCwgZHVwbGljYXRlID0gX2EuZHVwbGljYXRlLCBleHRlbmQgPSBfYS5leHRlbmQsIGZsYXR0ZW4gPSBfYS5mbGF0dGVuLCBmb2xkTWFwID0gX2EuZm9sZE1hcCwgbWFwID0gX2EubWFwLCBtYXBMZWZ0ID0gX2EubWFwTGVmdCwgcmVkdWNlID0gX2EucmVkdWNlLCByZWR1Y2VSaWdodCA9IF9hLnJlZHVjZVJpZ2h0LCBmcm9tUHJlZGljYXRlID0gX2EuZnJvbVByZWRpY2F0ZSwgZmlsdGVyT3JFbHNlID0gX2EuZmlsdGVyT3JFbHNlLCBwaXBlYWJsZUZyb21PcHRpb24gPSBfYS5mcm9tT3B0aW9uO1xuZXhwb3J0cy5hbHQgPSBhbHQ7XG5leHBvcnRzLmFwID0gYXA7XG5leHBvcnRzLmFwRmlyc3QgPSBhcEZpcnN0O1xuZXhwb3J0cy5hcFNlY29uZCA9IGFwU2Vjb25kO1xuZXhwb3J0cy5iaW1hcCA9IGJpbWFwO1xuZXhwb3J0cy5jaGFpbiA9IGNoYWluO1xuZXhwb3J0cy5jaGFpbkZpcnN0ID0gY2hhaW5GaXJzdDtcbmV4cG9ydHMuZHVwbGljYXRlID0gZHVwbGljYXRlO1xuZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7XG5leHBvcnRzLmZsYXR0ZW4gPSBmbGF0dGVuO1xuZXhwb3J0cy5mb2xkTWFwID0gZm9sZE1hcDtcbmV4cG9ydHMubWFwID0gbWFwO1xuZXhwb3J0cy5tYXBMZWZ0ID0gbWFwTGVmdDtcbmV4cG9ydHMucmVkdWNlID0gcmVkdWNlO1xuZXhwb3J0cy5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuZXhwb3J0cy5mcm9tUHJlZGljYXRlID0gZnJvbVByZWRpY2F0ZTtcbmV4cG9ydHMuZmlsdGVyT3JFbHNlID0gZmlsdGVyT3JFbHNlO1xuLyoqXG4gKiBMYXp5IHZlcnNpb24gb2YgYGZyb21PcHRpb25gXG4gKlxuICogQHNpbmNlIDEuMy4wXG4gKi9cbmV4cG9ydHMuZnJvbU9wdGlvbkwgPSBwaXBlYWJsZUZyb21PcHRpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/io-ts/node_modules/fp-ts/lib/Either.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/io-ts/node_modules/fp-ts/lib/Eq.js":
/*!*********************************************************!*\
  !*** ./node_modules/io-ts/node_modules/fp-ts/lib/Eq.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar pipeable_1 = __webpack_require__(/*! ./pipeable */ \"(ssr)/./node_modules/io-ts/node_modules/fp-ts/lib/pipeable.js\");\n/**\n * @since 1.19.0\n */\nexports.URI = 'Eq';\n/**\n * @since 1.19.0\n */\nfunction fromEquals(equals) {\n    return {\n        equals: function (x, y) { return x === y || equals(x, y); }\n    };\n}\nexports.fromEquals = fromEquals;\n/**\n * @since 1.19.0\n */\nfunction strictEqual(a, b) {\n    return a === b;\n}\nexports.strictEqual = strictEqual;\nvar eqStrict = { equals: strictEqual };\n/**\n * @since 1.19.0\n */\nexports.eqString = eqStrict;\n/**\n * @since 1.19.0\n */\nexports.eqNumber = eqStrict;\n/**\n * @since 1.19.0\n */\nexports.eqBoolean = eqStrict;\n/**\n * @since 1.19.0\n */\nfunction getStructEq(eqs) {\n    return fromEquals(function (x, y) {\n        for (var k in eqs) {\n            if (!eqs[k].equals(x[k], y[k])) {\n                return false;\n            }\n        }\n        return true;\n    });\n}\nexports.getStructEq = getStructEq;\n/**\n * Given a tuple of `Eq`s returns a `Eq` for the tuple\n *\n * @example\n * import { getTupleEq, eqString, eqNumber, eqBoolean } from 'fp-ts/lib/Eq'\n *\n * const E = getTupleEq(eqString, eqNumber, eqBoolean)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, true]), true)\n * assert.strictEqual(E.equals(['a', 1, true], ['b', 1, true]), false)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 2, true]), false)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, false]), false)\n *\n * @since 1.19.0\n */\nfunction getTupleEq() {\n    var eqs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        eqs[_i] = arguments[_i];\n    }\n    return fromEquals(function (x, y) { return eqs.every(function (E, i) { return E.equals(x[i], y[i]); }); });\n}\nexports.getTupleEq = getTupleEq;\n/**\n * @since 1.19.0\n */\nexports.eq = {\n    URI: exports.URI,\n    contramap: function (fa, f) { return fromEquals(function (x, y) { return fa.equals(f(x), f(y)); }); }\n};\nvar contramap = pipeable_1.pipeable(exports.eq).contramap;\nexports.contramap = contramap;\n/**\n * @since 1.19.0\n */\nexports.eqDate = exports.eq.contramap(exports.eqNumber, function (date) { return date.valueOf(); });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW8tdHMvbm9kZV9tb2R1bGVzL2ZwLXRzL2xpYi9FcS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNENBQTRDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSx3Q0FBd0MsbUNBQW1DLDhCQUE4QixJQUFJO0FBQzdHO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGtDQUFrQyxvQ0FBb0MsK0JBQStCO0FBQ3JHO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0REFBNEQsd0JBQXdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9pby10cy9ub2RlX21vZHVsZXMvZnAtdHMvbGliL0VxLmpzP2I2N2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcGlwZWFibGVfMSA9IHJlcXVpcmUoXCIuL3BpcGVhYmxlXCIpO1xuLyoqXG4gKiBAc2luY2UgMS4xOS4wXG4gKi9cbmV4cG9ydHMuVVJJID0gJ0VxJztcbi8qKlxuICogQHNpbmNlIDEuMTkuMFxuICovXG5mdW5jdGlvbiBmcm9tRXF1YWxzKGVxdWFscykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVxdWFsczogZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHggPT09IHkgfHwgZXF1YWxzKHgsIHkpOyB9XG4gICAgfTtcbn1cbmV4cG9ydHMuZnJvbUVxdWFscyA9IGZyb21FcXVhbHM7XG4vKipcbiAqIEBzaW5jZSAxLjE5LjBcbiAqL1xuZnVuY3Rpb24gc3RyaWN0RXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhID09PSBiO1xufVxuZXhwb3J0cy5zdHJpY3RFcXVhbCA9IHN0cmljdEVxdWFsO1xudmFyIGVxU3RyaWN0ID0geyBlcXVhbHM6IHN0cmljdEVxdWFsIH07XG4vKipcbiAqIEBzaW5jZSAxLjE5LjBcbiAqL1xuZXhwb3J0cy5lcVN0cmluZyA9IGVxU3RyaWN0O1xuLyoqXG4gKiBAc2luY2UgMS4xOS4wXG4gKi9cbmV4cG9ydHMuZXFOdW1iZXIgPSBlcVN0cmljdDtcbi8qKlxuICogQHNpbmNlIDEuMTkuMFxuICovXG5leHBvcnRzLmVxQm9vbGVhbiA9IGVxU3RyaWN0O1xuLyoqXG4gKiBAc2luY2UgMS4xOS4wXG4gKi9cbmZ1bmN0aW9uIGdldFN0cnVjdEVxKGVxcykge1xuICAgIHJldHVybiBmcm9tRXF1YWxzKGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gZXFzKSB7XG4gICAgICAgICAgICBpZiAoIWVxc1trXS5lcXVhbHMoeFtrXSwgeVtrXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG59XG5leHBvcnRzLmdldFN0cnVjdEVxID0gZ2V0U3RydWN0RXE7XG4vKipcbiAqIEdpdmVuIGEgdHVwbGUgb2YgYEVxYHMgcmV0dXJucyBhIGBFcWAgZm9yIHRoZSB0dXBsZVxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBnZXRUdXBsZUVxLCBlcVN0cmluZywgZXFOdW1iZXIsIGVxQm9vbGVhbiB9IGZyb20gJ2ZwLXRzL2xpYi9FcSdcbiAqXG4gKiBjb25zdCBFID0gZ2V0VHVwbGVFcShlcVN0cmluZywgZXFOdW1iZXIsIGVxQm9vbGVhbilcbiAqIGFzc2VydC5zdHJpY3RFcXVhbChFLmVxdWFscyhbJ2EnLCAxLCB0cnVlXSwgWydhJywgMSwgdHJ1ZV0pLCB0cnVlKVxuICogYXNzZXJ0LnN0cmljdEVxdWFsKEUuZXF1YWxzKFsnYScsIDEsIHRydWVdLCBbJ2InLCAxLCB0cnVlXSksIGZhbHNlKVxuICogYXNzZXJ0LnN0cmljdEVxdWFsKEUuZXF1YWxzKFsnYScsIDEsIHRydWVdLCBbJ2EnLCAyLCB0cnVlXSksIGZhbHNlKVxuICogYXNzZXJ0LnN0cmljdEVxdWFsKEUuZXF1YWxzKFsnYScsIDEsIHRydWVdLCBbJ2EnLCAxLCBmYWxzZV0pLCBmYWxzZSlcbiAqXG4gKiBAc2luY2UgMS4xOS4wXG4gKi9cbmZ1bmN0aW9uIGdldFR1cGxlRXEoKSB7XG4gICAgdmFyIGVxcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGVxc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbUVxdWFscyhmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4gZXFzLmV2ZXJ5KGZ1bmN0aW9uIChFLCBpKSB7IHJldHVybiBFLmVxdWFscyh4W2ldLCB5W2ldKTsgfSk7IH0pO1xufVxuZXhwb3J0cy5nZXRUdXBsZUVxID0gZ2V0VHVwbGVFcTtcbi8qKlxuICogQHNpbmNlIDEuMTkuMFxuICovXG5leHBvcnRzLmVxID0ge1xuICAgIFVSSTogZXhwb3J0cy5VUkksXG4gICAgY29udHJhbWFwOiBmdW5jdGlvbiAoZmEsIGYpIHsgcmV0dXJuIGZyb21FcXVhbHMoZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIGZhLmVxdWFscyhmKHgpLCBmKHkpKTsgfSk7IH1cbn07XG52YXIgY29udHJhbWFwID0gcGlwZWFibGVfMS5waXBlYWJsZShleHBvcnRzLmVxKS5jb250cmFtYXA7XG5leHBvcnRzLmNvbnRyYW1hcCA9IGNvbnRyYW1hcDtcbi8qKlxuICogQHNpbmNlIDEuMTkuMFxuICovXG5leHBvcnRzLmVxRGF0ZSA9IGV4cG9ydHMuZXEuY29udHJhbWFwKGV4cG9ydHMuZXFOdW1iZXIsIGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLnZhbHVlT2YoKTsgfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/io-ts/node_modules/fp-ts/lib/Eq.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/io-ts/node_modules/fp-ts/lib/function.js":
/*!***************************************************************!*\
  !*** ./node_modules/io-ts/node_modules/fp-ts/lib/function.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * @since 1.0.0\n */\nexports.identity = function (a) {\n    return a;\n};\n/**\n * @since 1.0.0\n */\nexports.unsafeCoerce = exports.identity;\n/**\n * @since 1.0.0\n */\nexports.not = function (predicate) {\n    return function (a) { return !predicate(a); };\n};\nfunction or(p1, p2) {\n    return function (a) { return p1(a) || p2(a); };\n}\nexports.or = or;\n/**\n * @since 1.0.0\n * @deprecated\n */\nexports.and = function (p1, p2) {\n    return function (a) { return p1(a) && p2(a); };\n};\n/**\n * @since 1.0.0\n */\nexports.constant = function (a) {\n    return function () { return a; };\n};\n/**\n * A thunk that returns always `true`\n *\n * @since 1.0.0\n */\nexports.constTrue = function () {\n    return true;\n};\n/**\n * A thunk that returns always `false`\n *\n * @since 1.0.0\n */\nexports.constFalse = function () {\n    return false;\n};\n/**\n * A thunk that returns always `null`\n *\n * @since 1.0.0\n */\nexports.constNull = function () {\n    return null;\n};\n/**\n * A thunk that returns always `undefined`\n *\n * @since 1.0.0\n */\nexports.constUndefined = function () {\n    return;\n};\n/**\n * A thunk that returns always `void`\n *\n * @since 1.14.0\n */\nexports.constVoid = function () {\n    return;\n};\n/**\n * Flips the order of the arguments to a function of two arguments.\n *\n * @since 1.0.0\n */\n// tslint:disable-next-line: deprecation\nexports.flip = function (f) {\n    return function (b) { return function (a) { return f(a)(b); }; };\n};\n/**\n * The `on` function is used to change the domain of a binary operator.\n *\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nexports.on = function (op) { return function (f) {\n    return function (x, y) { return op(f(x), f(y)); };\n}; };\nfunction compose() {\n    var fns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fns[_i] = arguments[_i];\n    }\n    var len = fns.length - 1;\n    return function (x) {\n        var y = x;\n        for (var i = len; i > -1; i--) {\n            y = fns[i].call(this, y);\n        }\n        return y;\n    };\n}\nexports.compose = compose;\nfunction pipe() {\n    var fns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fns[_i] = arguments[_i];\n    }\n    var len = fns.length - 1;\n    return function (x) {\n        var y = x;\n        for (var i = 0; i <= len; i++) {\n            y = fns[i].call(this, y);\n        }\n        return y;\n    };\n}\nexports.pipe = pipe;\n/**\n * @since 1.0.0\n * @deprecated\n */\nexports.concat = function (x, y) {\n    var lenx = x.length;\n    if (lenx === 0) {\n        return y;\n    }\n    var leny = y.length;\n    if (leny === 0) {\n        return x;\n    }\n    var r = Array(lenx + leny);\n    for (var i = 0; i < lenx; i++) {\n        r[i] = x[i];\n    }\n    for (var i = 0; i < leny; i++) {\n        r[i + lenx] = y[i];\n    }\n    return r;\n};\n/**\n * @since 1.0.0\n * @deprecated\n */\nfunction curried(f, n, acc) {\n    return function (x) {\n        // tslint:disable-next-line: deprecation\n        var combined = exports.concat(acc, [x]);\n        // tslint:disable-next-line: deprecation\n        return n === 0 ? f.apply(this, combined) : curried(f, n - 1, combined);\n    };\n}\nexports.curried = curried;\nfunction curry(f) {\n    // tslint:disable-next-line: deprecation\n    return curried(f, f.length - 1, []);\n}\nexports.curry = curry;\n/* tslint:disable-next-line */\nvar getFunctionName = function (f) { return f.displayName || f.name || \"<function\" + f.length + \">\"; };\n/**\n * @since 1.0.0\n * @deprecated\n */\nexports.toString = function (x) {\n    if (typeof x === 'string') {\n        return JSON.stringify(x);\n    }\n    if (x instanceof Date) {\n        return \"new Date('\" + x.toISOString() + \"')\";\n    }\n    if (Array.isArray(x)) {\n        // tslint:disable-next-line: deprecation\n        return \"[\" + x.map(exports.toString).join(', ') + \"]\";\n    }\n    if (typeof x === 'function') {\n        return getFunctionName(x);\n    }\n    if (x == null) {\n        return String(x);\n    }\n    if (typeof x.toString === 'function' && x.toString !== Object.prototype.toString) {\n        return x.toString();\n    }\n    try {\n        return JSON.stringify(x, null, 2);\n    }\n    catch (e) {\n        return String(x);\n    }\n};\n/**\n * @since 1.0.0\n */\nexports.tuple = function () {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n};\n/**\n * @since 1.0.0\n * @deprecated\n */\nexports.tupleCurried = function (a) { return function (b) {\n    return [a, b];\n}; };\n/**\n * Applies a function to an argument ($)\n *\n * @since 1.0.0\n * @deprecated\n */\nexports.apply = function (f) { return function (a) {\n    return f(a);\n}; };\n/**\n * Applies an argument to a function (#)\n *\n * @since 1.0.0\n * @deprecated\n */\nexports.applyFlipped = function (a) { return function (f) {\n    return f(a);\n}; };\n/**\n * For use with phantom fields\n *\n * @since 1.0.0\n * @deprecated\n */\nexports.phantom = undefined;\n/**\n * A thunk that returns always the `identity` function.\n * For use with `applySecond` methods.\n *\n * @since 1.5.0\n * @deprecated\n */\nexports.constIdentity = function () {\n    return exports.identity;\n};\n/**\n * @since 1.9.0\n */\nexports.increment = function (n) {\n    return n + 1;\n};\n/**\n * @since 1.9.0\n */\nexports.decrement = function (n) {\n    return n - 1;\n};\n/**\n * @since 1.18.0\n */\nfunction absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\nexports.absurd = absurd;\nfunction flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n}\nexports.flow = flow;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW8tdHMvbm9kZV9tb2R1bGVzL2ZwLXRzL2xpYi9mdW5jdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQjtBQUM3Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL2lvLXRzL25vZGVfbW9kdWxlcy9mcC10cy9saWIvZnVuY3Rpb24uanM/MmRjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydHMuaWRlbnRpdHkgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBhO1xufTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydHMudW5zYWZlQ29lcmNlID0gZXhwb3J0cy5pZGVudGl0eTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydHMubm90ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gIXByZWRpY2F0ZShhKTsgfTtcbn07XG5mdW5jdGlvbiBvcihwMSwgcDIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHAxKGEpIHx8IHAyKGEpOyB9O1xufVxuZXhwb3J0cy5vciA9IG9yO1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuYW5kID0gZnVuY3Rpb24gKHAxLCBwMikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gcDEoYSkgJiYgcDIoYSk7IH07XG59O1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xuZXhwb3J0cy5jb25zdGFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGE7IH07XG59O1xuLyoqXG4gKiBBIHRodW5rIHRoYXQgcmV0dXJucyBhbHdheXMgYHRydWVgXG4gKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydHMuY29uc3RUcnVlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogQSB0aHVuayB0aGF0IHJldHVybnMgYWx3YXlzIGBmYWxzZWBcbiAqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xuZXhwb3J0cy5jb25zdEZhbHNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIEEgdGh1bmsgdGhhdCByZXR1cm5zIGFsd2F5cyBgbnVsbGBcbiAqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xuZXhwb3J0cy5jb25zdE51bGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGw7XG59O1xuLyoqXG4gKiBBIHRodW5rIHRoYXQgcmV0dXJucyBhbHdheXMgYHVuZGVmaW5lZGBcbiAqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xuZXhwb3J0cy5jb25zdFVuZGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm47XG59O1xuLyoqXG4gKiBBIHRodW5rIHRoYXQgcmV0dXJucyBhbHdheXMgYHZvaWRgXG4gKlxuICogQHNpbmNlIDEuMTQuMFxuICovXG5leHBvcnRzLmNvbnN0Vm9pZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm47XG59O1xuLyoqXG4gKiBGbGlwcyB0aGUgb3JkZXIgb2YgdGhlIGFyZ3VtZW50cyB0byBhIGZ1bmN0aW9uIG9mIHR3byBhcmd1bWVudHMuXG4gKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGVwcmVjYXRpb25cbmV4cG9ydHMuZmxpcCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7IHJldHVybiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZihhKShiKTsgfTsgfTtcbn07XG4vKipcbiAqIFRoZSBgb25gIGZ1bmN0aW9uIGlzIHVzZWQgdG8gY2hhbmdlIHRoZSBkb21haW4gb2YgYSBiaW5hcnkgb3BlcmF0b3IuXG4gKlxuICogQHNpbmNlIDEuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGRlcHJlY2F0aW9uXG5leHBvcnRzLm9uID0gZnVuY3Rpb24gKG9wKSB7IHJldHVybiBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4gb3AoZih4KSwgZih5KSk7IH07XG59OyB9O1xuZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgICB2YXIgZm5zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgZm5zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBsZW4gPSBmbnMubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHkgPSB4O1xuICAgICAgICBmb3IgKHZhciBpID0gbGVuOyBpID4gLTE7IGktLSkge1xuICAgICAgICAgICAgeSA9IGZuc1tpXS5jYWxsKHRoaXMsIHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5O1xuICAgIH07XG59XG5leHBvcnRzLmNvbXBvc2UgPSBjb21wb3NlO1xuZnVuY3Rpb24gcGlwZSgpIHtcbiAgICB2YXIgZm5zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgZm5zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBsZW4gPSBmbnMubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHkgPSB4O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBsZW47IGkrKykge1xuICAgICAgICAgICAgeSA9IGZuc1tpXS5jYWxsKHRoaXMsIHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5O1xuICAgIH07XG59XG5leHBvcnRzLnBpcGUgPSBwaXBlO1xuLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuY29uY2F0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgbGVueCA9IHgubGVuZ3RoO1xuICAgIGlmIChsZW54ID09PSAwKSB7XG4gICAgICAgIHJldHVybiB5O1xuICAgIH1cbiAgICB2YXIgbGVueSA9IHkubGVuZ3RoO1xuICAgIGlmIChsZW55ID09PSAwKSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICB2YXIgciA9IEFycmF5KGxlbnggKyBsZW55KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbng7IGkrKykge1xuICAgICAgICByW2ldID0geFtpXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW55OyBpKyspIHtcbiAgICAgICAgcltpICsgbGVueF0gPSB5W2ldO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbn07XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZnVuY3Rpb24gY3VycmllZChmLCBuLCBhY2MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBkZXByZWNhdGlvblxuICAgICAgICB2YXIgY29tYmluZWQgPSBleHBvcnRzLmNvbmNhdChhY2MsIFt4XSk7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGVwcmVjYXRpb25cbiAgICAgICAgcmV0dXJuIG4gPT09IDAgPyBmLmFwcGx5KHRoaXMsIGNvbWJpbmVkKSA6IGN1cnJpZWQoZiwgbiAtIDEsIGNvbWJpbmVkKTtcbiAgICB9O1xufVxuZXhwb3J0cy5jdXJyaWVkID0gY3VycmllZDtcbmZ1bmN0aW9uIGN1cnJ5KGYpIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGRlcHJlY2F0aW9uXG4gICAgcmV0dXJuIGN1cnJpZWQoZiwgZi5sZW5ndGggLSAxLCBbXSk7XG59XG5leHBvcnRzLmN1cnJ5ID0gY3Vycnk7XG4vKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgKi9cbnZhciBnZXRGdW5jdGlvbk5hbWUgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZi5kaXNwbGF5TmFtZSB8fCBmLm5hbWUgfHwgXCI8ZnVuY3Rpb25cIiArIGYubGVuZ3RoICsgXCI+XCI7IH07XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0cy50b1N0cmluZyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeCk7XG4gICAgfVxuICAgIGlmICh4IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gXCJuZXcgRGF0ZSgnXCIgKyB4LnRvSVNPU3RyaW5nKCkgKyBcIicpXCI7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGVwcmVjYXRpb25cbiAgICAgICAgcmV0dXJuIFwiW1wiICsgeC5tYXAoZXhwb3J0cy50b1N0cmluZykuam9pbignLCAnKSArIFwiXVwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGdldEZ1bmN0aW9uTmFtZSh4KTtcbiAgICB9XG4gICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHgudG9TdHJpbmcgPT09ICdmdW5jdGlvbicgJiYgeC50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykge1xuICAgICAgICByZXR1cm4geC50b1N0cmluZygpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeCwgbnVsbCwgMik7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoeCk7XG4gICAgfVxufTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydHMudHVwbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHQgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB0W19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiB0O1xufTtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnRzLnR1cGxlQ3VycmllZCA9IGZ1bmN0aW9uIChhKSB7IHJldHVybiBmdW5jdGlvbiAoYikge1xuICAgIHJldHVybiBbYSwgYl07XG59OyB9O1xuLyoqXG4gKiBBcHBsaWVzIGEgZnVuY3Rpb24gdG8gYW4gYXJndW1lbnQgKCQpXG4gKlxuICogQHNpbmNlIDEuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnRzLmFwcGx5ID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGYoYSk7XG59OyB9O1xuLyoqXG4gKiBBcHBsaWVzIGFuIGFyZ3VtZW50IHRvIGEgZnVuY3Rpb24gKCMpXG4gKlxuICogQHNpbmNlIDEuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnRzLmFwcGx5RmxpcHBlZCA9IGZ1bmN0aW9uIChhKSB7IHJldHVybiBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmKGEpO1xufTsgfTtcbi8qKlxuICogRm9yIHVzZSB3aXRoIHBoYW50b20gZmllbGRzXG4gKlxuICogQHNpbmNlIDEuMC4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnRzLnBoYW50b20gPSB1bmRlZmluZWQ7XG4vKipcbiAqIEEgdGh1bmsgdGhhdCByZXR1cm5zIGFsd2F5cyB0aGUgYGlkZW50aXR5YCBmdW5jdGlvbi5cbiAqIEZvciB1c2Ugd2l0aCBgYXBwbHlTZWNvbmRgIG1ldGhvZHMuXG4gKlxuICogQHNpbmNlIDEuNS4wXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnRzLmNvbnN0SWRlbnRpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuaWRlbnRpdHk7XG59O1xuLyoqXG4gKiBAc2luY2UgMS45LjBcbiAqL1xuZXhwb3J0cy5pbmNyZW1lbnQgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBuICsgMTtcbn07XG4vKipcbiAqIEBzaW5jZSAxLjkuMFxuICovXG5leHBvcnRzLmRlY3JlbWVudCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIG4gLSAxO1xufTtcbi8qKlxuICogQHNpbmNlIDEuMTguMFxuICovXG5mdW5jdGlvbiBhYnN1cmQoXykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGVkIGBhYnN1cmRgIGZ1bmN0aW9uIHdoaWNoIHNob3VsZCBiZSB1bmNhbGxhYmxlJyk7XG59XG5leHBvcnRzLmFic3VyZCA9IGFic3VyZDtcbmZ1bmN0aW9uIGZsb3coYWIsIGJjLCBjZCwgZGUsIGVmLCBmZywgZ2gsIGhpLCBpaikge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gYWI7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJjKGFiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2QoYmMoYWIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGUoY2QoYmMoYWIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVmKGRlKGNkKGJjKGFiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpKSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmcoZWYoZGUoY2QoYmMoYWIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2goZmcoZWYoZGUoY2QoYmMoYWIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKSkpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhpKGdoKGZnKGVmKGRlKGNkKGJjKGFiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpKSkpKSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWooaGkoZ2goZmcoZWYoZGUoY2QoYmMoYWIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKSkpKSkpO1xuICAgICAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLmZsb3cgPSBmbG93O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/io-ts/node_modules/fp-ts/lib/function.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/io-ts/node_modules/fp-ts/lib/pipeable.js":
/*!***************************************************************!*\
  !*** ./node_modules/io-ts/node_modules/fp-ts/lib/pipeable.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar function_1 = __webpack_require__(/*! ./function */ \"(ssr)/./node_modules/io-ts/node_modules/fp-ts/lib/function.js\");\nfunction pipe(a, ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        case 10:\n            return ij(hi(gh(fg(ef(de(cd(bc(ab(a)))))))));\n    }\n}\nexports.pipe = pipe;\nvar isFunctor = function (I) { return typeof I.map === 'function'; };\nvar isContravariant = function (I) { return typeof I.contramap === 'function'; };\nvar isFunctorWithIndex = function (I) { return typeof I.mapWithIndex === 'function'; };\nvar isApply = function (I) { return typeof I.ap === 'function'; };\nvar isChain = function (I) { return typeof I.chain === 'function'; };\nvar isBifunctor = function (I) { return typeof I.bimap === 'function'; };\nvar isExtend = function (I) { return typeof I.extend === 'function'; };\nvar isFoldable = function (I) { return typeof I.reduce === 'function'; };\nvar isFoldableWithIndex = function (I) { return typeof I.reduceWithIndex === 'function'; };\nvar isAlt = function (I) { return typeof I.alt === 'function'; };\nvar isCompactable = function (I) { return typeof I.compact === 'function'; };\nvar isFilterable = function (I) { return typeof I.filter === 'function'; };\nvar isFilterableWithIndex = function (I) {\n    return typeof I.filterWithIndex === 'function';\n};\nvar isProfunctor = function (I) { return typeof I.promap === 'function'; };\nvar isSemigroupoid = function (I) { return typeof I.compose === 'function'; };\nvar isMonadThrow = function (I) { return typeof I.throwError === 'function'; };\nfunction pipeable(I) {\n    var r = {};\n    if (isFunctor(I)) {\n        var map = function (f) { return function (fa) { return I.map(fa, f); }; };\n        r.map = map;\n    }\n    if (isContravariant(I)) {\n        var contramap = function (f) { return function (fa) { return I.contramap(fa, f); }; };\n        r.contramap = contramap;\n    }\n    if (isFunctorWithIndex(I)) {\n        var mapWithIndex = function (f) { return function (fa) { return I.mapWithIndex(fa, f); }; };\n        r.mapWithIndex = mapWithIndex;\n    }\n    if (isApply(I)) {\n        var ap = function (fa) { return function (fab) { return I.ap(fab, fa); }; };\n        var apFirst = function (fb) { return function (fa) { return I.ap(I.map(fa, function (a) { return function () { return a; }; }), fb); }; };\n        r.ap = ap;\n        r.apFirst = apFirst;\n        r.apSecond = function (fb) { return function (fa) { return I.ap(I.map(fa, function () { return function (b) { return b; }; }), fb); }; };\n    }\n    if (isChain(I)) {\n        var chain = function (f) { return function (ma) { return I.chain(ma, f); }; };\n        var chainFirst = function (f) { return function (ma) { return I.chain(ma, function (a) { return I.map(f(a), function () { return a; }); }); }; };\n        var flatten = function (mma) { return I.chain(mma, function_1.identity); };\n        r.chain = chain;\n        r.chainFirst = chainFirst;\n        r.flatten = flatten;\n    }\n    if (isBifunctor(I)) {\n        var bimap = function (f, g) { return function (fa) { return I.bimap(fa, f, g); }; };\n        var mapLeft = function (f) { return function (fa) { return I.bimap(fa, f, function_1.identity); }; };\n        r.bimap = bimap;\n        r.mapLeft = mapLeft;\n    }\n    if (isExtend(I)) {\n        var extend = function (f) { return function (wa) { return I.extend(wa, f); }; };\n        var duplicate = function (wa) { return I.extend(wa, function_1.identity); };\n        r.extend = extend;\n        r.duplicate = duplicate;\n    }\n    if (isFoldable(I)) {\n        var reduce = function (b, f) { return function (fa) { return I.reduce(fa, b, f); }; };\n        var foldMap = function (M) {\n            var foldMapM = I.foldMap(M);\n            return function (f) { return function (fa) { return foldMapM(fa, f); }; };\n        };\n        var reduceRight = function (b, f) { return function (fa) { return I.foldr(fa, b, f); }; };\n        r.reduce = reduce;\n        r.foldMap = foldMap;\n        r.reduceRight = reduceRight;\n    }\n    if (isFoldableWithIndex(I)) {\n        var reduceWithIndex = function (b, f) { return function (fa) {\n            return I.reduceWithIndex(fa, b, f);\n        }; };\n        var foldMapWithIndex = function (M) {\n            var foldMapM = I.foldMapWithIndex(M);\n            return function (f) { return function (fa) { return foldMapM(fa, f); }; };\n        };\n        var reduceRightWithIndex = function (b, f) { return function (fa) {\n            return I.foldrWithIndex(fa, b, f);\n        }; };\n        r.reduceWithIndex = reduceWithIndex;\n        r.foldMapWithIndex = foldMapWithIndex;\n        r.reduceRightWithIndex = reduceRightWithIndex;\n    }\n    if (isAlt(I)) {\n        var alt = function (that) { return function (fa) { return I.alt(fa, that()); }; };\n        r.alt = alt;\n    }\n    if (isCompactable(I)) {\n        r.compact = I.compact;\n        r.separate = I.separate;\n    }\n    if (isFilterable(I)) {\n        var filter = function (predicate) { return function (fa) {\n            return I.filter(fa, predicate);\n        }; };\n        var filterMap = function (f) { return function (fa) { return I.filterMap(fa, f); }; };\n        var partition = function (predicate) { return function (fa) {\n            return I.partition(fa, predicate);\n        }; };\n        var partitionMap = function (f) { return function (fa) { return I.partitionMap(fa, f); }; };\n        r.filter = filter;\n        r.filterMap = filterMap;\n        r.partition = partition;\n        r.partitionMap = partitionMap;\n    }\n    if (isFilterableWithIndex(I)) {\n        var filterWithIndex = function (predicateWithIndex) { return function (fa) { return I.filterWithIndex(fa, predicateWithIndex); }; };\n        var filterMapWithIndex = function (f) { return function (fa) {\n            return I.filterMapWithIndex(fa, f);\n        }; };\n        var partitionWithIndex = function (predicateWithIndex) { return function (fa) { return I.partitionWithIndex(fa, predicateWithIndex); }; };\n        var partitionMapWithIndex = function (f) { return function (fa) {\n            return I.partitionMapWithIndex(fa, f);\n        }; };\n        r.filterWithIndex = filterWithIndex;\n        r.filterMapWithIndex = filterMapWithIndex;\n        r.partitionWithIndex = partitionWithIndex;\n        r.partitionMapWithIndex = partitionMapWithIndex;\n    }\n    if (isProfunctor(I)) {\n        var promap = function (f, g) { return function (fa) { return I.promap(fa, f, g); }; };\n        r.promap = promap;\n    }\n    if (isSemigroupoid(I)) {\n        var compose = function (that) { return function (fa) {\n            return I.compose(fa, that);\n        }; };\n        r.compose = compose;\n    }\n    if (isMonadThrow(I)) {\n        var fromOption = function (onNone) { return function (ma) {\n            return ma._tag === 'None' ? I.throwError(onNone()) : I.of(ma.value);\n        }; };\n        var fromEither = function (ma) {\n            return ma._tag === 'Left' ? I.throwError(ma.value) : I.of(ma.value);\n        };\n        var fromPredicate = function (predicate, onFalse) { return function (a) { return (predicate(a) ? I.of(a) : I.throwError(onFalse(a))); }; };\n        var filterOrElse = function (predicate, onFalse) { return function (ma) { return I.chain(ma, function (a) { return (predicate(a) ? I.of(a) : I.throwError(onFalse(a))); }); }; };\n        r.fromOption = fromOption;\n        r.fromEither = fromEither;\n        r.fromPredicate = fromPredicate;\n        r.filterOrElse = filterOrElse;\n    }\n    return r;\n}\nexports.pipeable = pipeable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW8tdHMvbm9kZV9tb2R1bGVzL2ZwLXRzL2xpYi9waXBlYWJsZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osK0JBQStCO0FBQy9CLHFDQUFxQztBQUNyQyx3Q0FBd0M7QUFDeEMsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QixpQ0FBaUM7QUFDakMsOEJBQThCO0FBQzlCLGdDQUFnQztBQUNoQyx5Q0FBeUM7QUFDekMsMkJBQTJCO0FBQzNCLG1DQUFtQztBQUNuQyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLG9DQUFvQztBQUNwQyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1QkFBdUI7QUFDakU7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHdCQUF3QjtBQUN6RCxzQ0FBc0MsdUJBQXVCLHFDQUFxQyxxQkFBcUIsY0FBYztBQUNySTtBQUNBO0FBQ0EscUNBQXFDLHVCQUF1QixvQ0FBb0Msc0JBQXNCLGNBQWM7QUFDcEk7QUFDQTtBQUNBLG1DQUFtQyx1QkFBdUI7QUFDMUQsd0NBQXdDLHVCQUF1QixrQ0FBa0MsaUNBQWlDLFdBQVcsSUFBSTtBQUNqSix1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx1QkFBdUI7QUFDN0QscUNBQXFDLHVCQUF1QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1QkFBdUI7QUFDM0Qsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVCQUF1QjtBQUM5RDtBQUNBO0FBQ0Esa0NBQWtDLHVCQUF1QjtBQUN6RDtBQUNBLDRDQUE0Qyx1QkFBdUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsdUJBQXVCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCO0FBQzlELCtDQUErQztBQUMvQztBQUNBO0FBQ0EsMENBQTBDLHVCQUF1QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsdUJBQXVCO0FBQ3JGLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsaUVBQWlFLHVCQUF1QjtBQUN4RixtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxzQkFBc0I7QUFDbEYsMkRBQTJELHVCQUF1QixrQ0FBa0MsNkRBQTZEO0FBQ2pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9pby10cy9ub2RlX21vZHVsZXMvZnAtdHMvbGliL3BpcGVhYmxlLmpzPzYxMTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZnVuY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uXCIpO1xuZnVuY3Rpb24gcGlwZShhLCBhYiwgYmMsIGNkLCBkZSwgZWYsIGZnLCBnaCwgaGksIGlqKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gYWIoYSk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBiYyhhYihhKSk7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiBjZChiYyhhYihhKSkpO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gZGUoY2QoYmMoYWIoYSkpKSk7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiBlZihkZShjZChiYyhhYihhKSkpKSk7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiBmZyhlZihkZShjZChiYyhhYihhKSkpKSkpO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gZ2goZmcoZWYoZGUoY2QoYmMoYWIoYSkpKSkpKSk7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBoaShnaChmZyhlZihkZShjZChiYyhhYihhKSkpKSkpKSk7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZXR1cm4gaWooaGkoZ2goZmcoZWYoZGUoY2QoYmMoYWIoYSkpKSkpKSkpKTtcbiAgICB9XG59XG5leHBvcnRzLnBpcGUgPSBwaXBlO1xudmFyIGlzRnVuY3RvciA9IGZ1bmN0aW9uIChJKSB7IHJldHVybiB0eXBlb2YgSS5tYXAgPT09ICdmdW5jdGlvbic7IH07XG52YXIgaXNDb250cmF2YXJpYW50ID0gZnVuY3Rpb24gKEkpIHsgcmV0dXJuIHR5cGVvZiBJLmNvbnRyYW1hcCA9PT0gJ2Z1bmN0aW9uJzsgfTtcbnZhciBpc0Z1bmN0b3JXaXRoSW5kZXggPSBmdW5jdGlvbiAoSSkgeyByZXR1cm4gdHlwZW9mIEkubWFwV2l0aEluZGV4ID09PSAnZnVuY3Rpb24nOyB9O1xudmFyIGlzQXBwbHkgPSBmdW5jdGlvbiAoSSkgeyByZXR1cm4gdHlwZW9mIEkuYXAgPT09ICdmdW5jdGlvbic7IH07XG52YXIgaXNDaGFpbiA9IGZ1bmN0aW9uIChJKSB7IHJldHVybiB0eXBlb2YgSS5jaGFpbiA9PT0gJ2Z1bmN0aW9uJzsgfTtcbnZhciBpc0JpZnVuY3RvciA9IGZ1bmN0aW9uIChJKSB7IHJldHVybiB0eXBlb2YgSS5iaW1hcCA9PT0gJ2Z1bmN0aW9uJzsgfTtcbnZhciBpc0V4dGVuZCA9IGZ1bmN0aW9uIChJKSB7IHJldHVybiB0eXBlb2YgSS5leHRlbmQgPT09ICdmdW5jdGlvbic7IH07XG52YXIgaXNGb2xkYWJsZSA9IGZ1bmN0aW9uIChJKSB7IHJldHVybiB0eXBlb2YgSS5yZWR1Y2UgPT09ICdmdW5jdGlvbic7IH07XG52YXIgaXNGb2xkYWJsZVdpdGhJbmRleCA9IGZ1bmN0aW9uIChJKSB7IHJldHVybiB0eXBlb2YgSS5yZWR1Y2VXaXRoSW5kZXggPT09ICdmdW5jdGlvbic7IH07XG52YXIgaXNBbHQgPSBmdW5jdGlvbiAoSSkgeyByZXR1cm4gdHlwZW9mIEkuYWx0ID09PSAnZnVuY3Rpb24nOyB9O1xudmFyIGlzQ29tcGFjdGFibGUgPSBmdW5jdGlvbiAoSSkgeyByZXR1cm4gdHlwZW9mIEkuY29tcGFjdCA9PT0gJ2Z1bmN0aW9uJzsgfTtcbnZhciBpc0ZpbHRlcmFibGUgPSBmdW5jdGlvbiAoSSkgeyByZXR1cm4gdHlwZW9mIEkuZmlsdGVyID09PSAnZnVuY3Rpb24nOyB9O1xudmFyIGlzRmlsdGVyYWJsZVdpdGhJbmRleCA9IGZ1bmN0aW9uIChJKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBJLmZpbHRlcldpdGhJbmRleCA9PT0gJ2Z1bmN0aW9uJztcbn07XG52YXIgaXNQcm9mdW5jdG9yID0gZnVuY3Rpb24gKEkpIHsgcmV0dXJuIHR5cGVvZiBJLnByb21hcCA9PT0gJ2Z1bmN0aW9uJzsgfTtcbnZhciBpc1NlbWlncm91cG9pZCA9IGZ1bmN0aW9uIChJKSB7IHJldHVybiB0eXBlb2YgSS5jb21wb3NlID09PSAnZnVuY3Rpb24nOyB9O1xudmFyIGlzTW9uYWRUaHJvdyA9IGZ1bmN0aW9uIChJKSB7IHJldHVybiB0eXBlb2YgSS50aHJvd0Vycm9yID09PSAnZnVuY3Rpb24nOyB9O1xuZnVuY3Rpb24gcGlwZWFibGUoSSkge1xuICAgIHZhciByID0ge307XG4gICAgaWYgKGlzRnVuY3RvcihJKSkge1xuICAgICAgICB2YXIgbWFwID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChmYSkgeyByZXR1cm4gSS5tYXAoZmEsIGYpOyB9OyB9O1xuICAgICAgICByLm1hcCA9IG1hcDtcbiAgICB9XG4gICAgaWYgKGlzQ29udHJhdmFyaWFudChJKSkge1xuICAgICAgICB2YXIgY29udHJhbWFwID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChmYSkgeyByZXR1cm4gSS5jb250cmFtYXAoZmEsIGYpOyB9OyB9O1xuICAgICAgICByLmNvbnRyYW1hcCA9IGNvbnRyYW1hcDtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3RvcldpdGhJbmRleChJKSkge1xuICAgICAgICB2YXIgbWFwV2l0aEluZGV4ID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChmYSkgeyByZXR1cm4gSS5tYXBXaXRoSW5kZXgoZmEsIGYpOyB9OyB9O1xuICAgICAgICByLm1hcFdpdGhJbmRleCA9IG1hcFdpdGhJbmRleDtcbiAgICB9XG4gICAgaWYgKGlzQXBwbHkoSSkpIHtcbiAgICAgICAgdmFyIGFwID0gZnVuY3Rpb24gKGZhKSB7IHJldHVybiBmdW5jdGlvbiAoZmFiKSB7IHJldHVybiBJLmFwKGZhYiwgZmEpOyB9OyB9O1xuICAgICAgICB2YXIgYXBGaXJzdCA9IGZ1bmN0aW9uIChmYikgeyByZXR1cm4gZnVuY3Rpb24gKGZhKSB7IHJldHVybiBJLmFwKEkubWFwKGZhLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gYTsgfTsgfSksIGZiKTsgfTsgfTtcbiAgICAgICAgci5hcCA9IGFwO1xuICAgICAgICByLmFwRmlyc3QgPSBhcEZpcnN0O1xuICAgICAgICByLmFwU2Vjb25kID0gZnVuY3Rpb24gKGZiKSB7IHJldHVybiBmdW5jdGlvbiAoZmEpIHsgcmV0dXJuIEkuYXAoSS5tYXAoZmEsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChiKSB7IHJldHVybiBiOyB9OyB9KSwgZmIpOyB9OyB9O1xuICAgIH1cbiAgICBpZiAoaXNDaGFpbihJKSkge1xuICAgICAgICB2YXIgY2hhaW4gPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZnVuY3Rpb24gKG1hKSB7IHJldHVybiBJLmNoYWluKG1hLCBmKTsgfTsgfTtcbiAgICAgICAgdmFyIGNoYWluRmlyc3QgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZnVuY3Rpb24gKG1hKSB7IHJldHVybiBJLmNoYWluKG1hLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gSS5tYXAoZihhKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gYTsgfSk7IH0pOyB9OyB9O1xuICAgICAgICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uIChtbWEpIHsgcmV0dXJuIEkuY2hhaW4obW1hLCBmdW5jdGlvbl8xLmlkZW50aXR5KTsgfTtcbiAgICAgICAgci5jaGFpbiA9IGNoYWluO1xuICAgICAgICByLmNoYWluRmlyc3QgPSBjaGFpbkZpcnN0O1xuICAgICAgICByLmZsYXR0ZW4gPSBmbGF0dGVuO1xuICAgIH1cbiAgICBpZiAoaXNCaWZ1bmN0b3IoSSkpIHtcbiAgICAgICAgdmFyIGJpbWFwID0gZnVuY3Rpb24gKGYsIGcpIHsgcmV0dXJuIGZ1bmN0aW9uIChmYSkgeyByZXR1cm4gSS5iaW1hcChmYSwgZiwgZyk7IH07IH07XG4gICAgICAgIHZhciBtYXBMZWZ0ID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChmYSkgeyByZXR1cm4gSS5iaW1hcChmYSwgZiwgZnVuY3Rpb25fMS5pZGVudGl0eSk7IH07IH07XG4gICAgICAgIHIuYmltYXAgPSBiaW1hcDtcbiAgICAgICAgci5tYXBMZWZ0ID0gbWFwTGVmdDtcbiAgICB9XG4gICAgaWYgKGlzRXh0ZW5kKEkpKSB7XG4gICAgICAgIHZhciBleHRlbmQgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZnVuY3Rpb24gKHdhKSB7IHJldHVybiBJLmV4dGVuZCh3YSwgZik7IH07IH07XG4gICAgICAgIHZhciBkdXBsaWNhdGUgPSBmdW5jdGlvbiAod2EpIHsgcmV0dXJuIEkuZXh0ZW5kKHdhLCBmdW5jdGlvbl8xLmlkZW50aXR5KTsgfTtcbiAgICAgICAgci5leHRlbmQgPSBleHRlbmQ7XG4gICAgICAgIHIuZHVwbGljYXRlID0gZHVwbGljYXRlO1xuICAgIH1cbiAgICBpZiAoaXNGb2xkYWJsZShJKSkge1xuICAgICAgICB2YXIgcmVkdWNlID0gZnVuY3Rpb24gKGIsIGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChmYSkgeyByZXR1cm4gSS5yZWR1Y2UoZmEsIGIsIGYpOyB9OyB9O1xuICAgICAgICB2YXIgZm9sZE1hcCA9IGZ1bmN0aW9uIChNKSB7XG4gICAgICAgICAgICB2YXIgZm9sZE1hcE0gPSBJLmZvbGRNYXAoTSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChmYSkgeyByZXR1cm4gZm9sZE1hcE0oZmEsIGYpOyB9OyB9O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVkdWNlUmlnaHQgPSBmdW5jdGlvbiAoYiwgZikgeyByZXR1cm4gZnVuY3Rpb24gKGZhKSB7IHJldHVybiBJLmZvbGRyKGZhLCBiLCBmKTsgfTsgfTtcbiAgICAgICAgci5yZWR1Y2UgPSByZWR1Y2U7XG4gICAgICAgIHIuZm9sZE1hcCA9IGZvbGRNYXA7XG4gICAgICAgIHIucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbiAgICB9XG4gICAgaWYgKGlzRm9sZGFibGVXaXRoSW5kZXgoSSkpIHtcbiAgICAgICAgdmFyIHJlZHVjZVdpdGhJbmRleCA9IGZ1bmN0aW9uIChiLCBmKSB7IHJldHVybiBmdW5jdGlvbiAoZmEpIHtcbiAgICAgICAgICAgIHJldHVybiBJLnJlZHVjZVdpdGhJbmRleChmYSwgYiwgZik7XG4gICAgICAgIH07IH07XG4gICAgICAgIHZhciBmb2xkTWFwV2l0aEluZGV4ID0gZnVuY3Rpb24gKE0pIHtcbiAgICAgICAgICAgIHZhciBmb2xkTWFwTSA9IEkuZm9sZE1hcFdpdGhJbmRleChNKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gZnVuY3Rpb24gKGZhKSB7IHJldHVybiBmb2xkTWFwTShmYSwgZik7IH07IH07XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZWR1Y2VSaWdodFdpdGhJbmRleCA9IGZ1bmN0aW9uIChiLCBmKSB7IHJldHVybiBmdW5jdGlvbiAoZmEpIHtcbiAgICAgICAgICAgIHJldHVybiBJLmZvbGRyV2l0aEluZGV4KGZhLCBiLCBmKTtcbiAgICAgICAgfTsgfTtcbiAgICAgICAgci5yZWR1Y2VXaXRoSW5kZXggPSByZWR1Y2VXaXRoSW5kZXg7XG4gICAgICAgIHIuZm9sZE1hcFdpdGhJbmRleCA9IGZvbGRNYXBXaXRoSW5kZXg7XG4gICAgICAgIHIucmVkdWNlUmlnaHRXaXRoSW5kZXggPSByZWR1Y2VSaWdodFdpdGhJbmRleDtcbiAgICB9XG4gICAgaWYgKGlzQWx0KEkpKSB7XG4gICAgICAgIHZhciBhbHQgPSBmdW5jdGlvbiAodGhhdCkgeyByZXR1cm4gZnVuY3Rpb24gKGZhKSB7IHJldHVybiBJLmFsdChmYSwgdGhhdCgpKTsgfTsgfTtcbiAgICAgICAgci5hbHQgPSBhbHQ7XG4gICAgfVxuICAgIGlmIChpc0NvbXBhY3RhYmxlKEkpKSB7XG4gICAgICAgIHIuY29tcGFjdCA9IEkuY29tcGFjdDtcbiAgICAgICAgci5zZXBhcmF0ZSA9IEkuc2VwYXJhdGU7XG4gICAgfVxuICAgIGlmIChpc0ZpbHRlcmFibGUoSSkpIHtcbiAgICAgICAgdmFyIGZpbHRlciA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHsgcmV0dXJuIGZ1bmN0aW9uIChmYSkge1xuICAgICAgICAgICAgcmV0dXJuIEkuZmlsdGVyKGZhLCBwcmVkaWNhdGUpO1xuICAgICAgICB9OyB9O1xuICAgICAgICB2YXIgZmlsdGVyTWFwID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChmYSkgeyByZXR1cm4gSS5maWx0ZXJNYXAoZmEsIGYpOyB9OyB9O1xuICAgICAgICB2YXIgcGFydGl0aW9uID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkgeyByZXR1cm4gZnVuY3Rpb24gKGZhKSB7XG4gICAgICAgICAgICByZXR1cm4gSS5wYXJ0aXRpb24oZmEsIHByZWRpY2F0ZSk7XG4gICAgICAgIH07IH07XG4gICAgICAgIHZhciBwYXJ0aXRpb25NYXAgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZnVuY3Rpb24gKGZhKSB7IHJldHVybiBJLnBhcnRpdGlvbk1hcChmYSwgZik7IH07IH07XG4gICAgICAgIHIuZmlsdGVyID0gZmlsdGVyO1xuICAgICAgICByLmZpbHRlck1hcCA9IGZpbHRlck1hcDtcbiAgICAgICAgci5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG4gICAgICAgIHIucGFydGl0aW9uTWFwID0gcGFydGl0aW9uTWFwO1xuICAgIH1cbiAgICBpZiAoaXNGaWx0ZXJhYmxlV2l0aEluZGV4KEkpKSB7XG4gICAgICAgIHZhciBmaWx0ZXJXaXRoSW5kZXggPSBmdW5jdGlvbiAocHJlZGljYXRlV2l0aEluZGV4KSB7IHJldHVybiBmdW5jdGlvbiAoZmEpIHsgcmV0dXJuIEkuZmlsdGVyV2l0aEluZGV4KGZhLCBwcmVkaWNhdGVXaXRoSW5kZXgpOyB9OyB9O1xuICAgICAgICB2YXIgZmlsdGVyTWFwV2l0aEluZGV4ID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChmYSkge1xuICAgICAgICAgICAgcmV0dXJuIEkuZmlsdGVyTWFwV2l0aEluZGV4KGZhLCBmKTtcbiAgICAgICAgfTsgfTtcbiAgICAgICAgdmFyIHBhcnRpdGlvbldpdGhJbmRleCA9IGZ1bmN0aW9uIChwcmVkaWNhdGVXaXRoSW5kZXgpIHsgcmV0dXJuIGZ1bmN0aW9uIChmYSkgeyByZXR1cm4gSS5wYXJ0aXRpb25XaXRoSW5kZXgoZmEsIHByZWRpY2F0ZVdpdGhJbmRleCk7IH07IH07XG4gICAgICAgIHZhciBwYXJ0aXRpb25NYXBXaXRoSW5kZXggPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZnVuY3Rpb24gKGZhKSB7XG4gICAgICAgICAgICByZXR1cm4gSS5wYXJ0aXRpb25NYXBXaXRoSW5kZXgoZmEsIGYpO1xuICAgICAgICB9OyB9O1xuICAgICAgICByLmZpbHRlcldpdGhJbmRleCA9IGZpbHRlcldpdGhJbmRleDtcbiAgICAgICAgci5maWx0ZXJNYXBXaXRoSW5kZXggPSBmaWx0ZXJNYXBXaXRoSW5kZXg7XG4gICAgICAgIHIucGFydGl0aW9uV2l0aEluZGV4ID0gcGFydGl0aW9uV2l0aEluZGV4O1xuICAgICAgICByLnBhcnRpdGlvbk1hcFdpdGhJbmRleCA9IHBhcnRpdGlvbk1hcFdpdGhJbmRleDtcbiAgICB9XG4gICAgaWYgKGlzUHJvZnVuY3RvcihJKSkge1xuICAgICAgICB2YXIgcHJvbWFwID0gZnVuY3Rpb24gKGYsIGcpIHsgcmV0dXJuIGZ1bmN0aW9uIChmYSkgeyByZXR1cm4gSS5wcm9tYXAoZmEsIGYsIGcpOyB9OyB9O1xuICAgICAgICByLnByb21hcCA9IHByb21hcDtcbiAgICB9XG4gICAgaWYgKGlzU2VtaWdyb3Vwb2lkKEkpKSB7XG4gICAgICAgIHZhciBjb21wb3NlID0gZnVuY3Rpb24gKHRoYXQpIHsgcmV0dXJuIGZ1bmN0aW9uIChmYSkge1xuICAgICAgICAgICAgcmV0dXJuIEkuY29tcG9zZShmYSwgdGhhdCk7XG4gICAgICAgIH07IH07XG4gICAgICAgIHIuY29tcG9zZSA9IGNvbXBvc2U7XG4gICAgfVxuICAgIGlmIChpc01vbmFkVGhyb3coSSkpIHtcbiAgICAgICAgdmFyIGZyb21PcHRpb24gPSBmdW5jdGlvbiAob25Ob25lKSB7IHJldHVybiBmdW5jdGlvbiAobWEpIHtcbiAgICAgICAgICAgIHJldHVybiBtYS5fdGFnID09PSAnTm9uZScgPyBJLnRocm93RXJyb3Iob25Ob25lKCkpIDogSS5vZihtYS52YWx1ZSk7XG4gICAgICAgIH07IH07XG4gICAgICAgIHZhciBmcm9tRWl0aGVyID0gZnVuY3Rpb24gKG1hKSB7XG4gICAgICAgICAgICByZXR1cm4gbWEuX3RhZyA9PT0gJ0xlZnQnID8gSS50aHJvd0Vycm9yKG1hLnZhbHVlKSA6IEkub2YobWEudmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZnJvbVByZWRpY2F0ZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIG9uRmFsc2UpIHsgcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiAocHJlZGljYXRlKGEpID8gSS5vZihhKSA6IEkudGhyb3dFcnJvcihvbkZhbHNlKGEpKSk7IH07IH07XG4gICAgICAgIHZhciBmaWx0ZXJPckVsc2UgPSBmdW5jdGlvbiAocHJlZGljYXRlLCBvbkZhbHNlKSB7IHJldHVybiBmdW5jdGlvbiAobWEpIHsgcmV0dXJuIEkuY2hhaW4obWEsIGZ1bmN0aW9uIChhKSB7IHJldHVybiAocHJlZGljYXRlKGEpID8gSS5vZihhKSA6IEkudGhyb3dFcnJvcihvbkZhbHNlKGEpKSk7IH0pOyB9OyB9O1xuICAgICAgICByLmZyb21PcHRpb24gPSBmcm9tT3B0aW9uO1xuICAgICAgICByLmZyb21FaXRoZXIgPSBmcm9tRWl0aGVyO1xuICAgICAgICByLmZyb21QcmVkaWNhdGUgPSBmcm9tUHJlZGljYXRlO1xuICAgICAgICByLmZpbHRlck9yRWxzZSA9IGZpbHRlck9yRWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG59XG5leHBvcnRzLnBpcGVhYmxlID0gcGlwZWFibGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/io-ts/node_modules/fp-ts/lib/pipeable.js\n");

/***/ })

};
;