/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/json-stream-stringify";
exports.ids = ["vendor-chunks/json-stream-stringify"];
exports.modules = {

/***/ "(ssr)/./node_modules/json-stream-stringify/lib/umd/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/json-stream-stringify/lib/umd/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! stream */ \"stream\")) :\n  0;\n})(this, (function (exports, stream) { 'use strict';\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  var _global, _global$JSON;\n\n  const rxEscapable = /[\\\\\"\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g; // table of character substitutions\n\n  const meta = {\n    '\\b': '\\\\b',\n    '\\t': '\\\\t',\n    '\\n': '\\\\n',\n    '\\f': '\\\\f',\n    '\\r': '\\\\r',\n    '\"': '\\\\\"',\n    '\\\\': '\\\\\\\\'\n  };\n\n  function isReadableStream(value) {\n    return typeof value.read === 'function' && typeof value.pause === 'function' && typeof value.resume === 'function' && typeof value.pipe === 'function' && typeof value.once === 'function' && typeof value.removeListener === 'function';\n  }\n\n  var Types;\n\n  (function (Types) {\n    Types[Types[\"Array\"] = 0] = \"Array\";\n    Types[Types[\"Object\"] = 1] = \"Object\";\n    Types[Types[\"ReadableString\"] = 2] = \"ReadableString\";\n    Types[Types[\"ReadableObject\"] = 3] = \"ReadableObject\";\n    Types[Types[\"Primitive\"] = 4] = \"Primitive\";\n    Types[Types[\"Promise\"] = 5] = \"Promise\";\n  })(Types || (Types = {}));\n\n  function getType(value) {\n    if (!value) return Types.Primitive;\n    if (typeof value.then === 'function') return Types.Promise;\n    if (isReadableStream(value)) return value._readableState.objectMode ? Types.ReadableObject : Types.ReadableString;\n    if (Array.isArray(value)) return Types.Array;\n    if (typeof value === 'object' || value instanceof Object) return Types.Object;\n    return Types.Primitive;\n  }\n\n  function escapeString(string) {\n    // Modified code, original code by Douglas Crockford\n    // Original: https://github.com/douglascrockford/JSON-js/blob/master/json2.js\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    return string.replace(rxEscapable, a => {\n      const c = meta[a];\n      return typeof c === 'string' ? c : `\\\\u${a.charCodeAt(0).toString(16).padStart(4, '0')}`;\n    });\n  }\n\n  let primitiveToJSON;\n\n  if (((_global = global) === null || _global === void 0 ? void 0 : (_global$JSON = _global.JSON) === null || _global$JSON === void 0 ? void 0 : _global$JSON.stringify) instanceof Function) {\n    try {\n      if (JSON.stringify(global.BigInt ? global.BigInt('123') : '') !== '123') throw new Error();\n      primitiveToJSON = JSON.stringify;\n    } catch (err) {\n      // Add support for bigint for primitiveToJSON\n      // eslint-disable-next-line no-confusing-arrow\n      primitiveToJSON = value => typeof value === 'bigint' ? String(value) : JSON.stringify(value);\n    }\n  } else {\n    primitiveToJSON = value => {\n      switch (typeof value) {\n        case 'string':\n          return `\"${escapeString(value)}\"`;\n\n        case 'number':\n          return Number.isFinite(value) ? String(value) : 'null';\n\n        case 'bigint':\n          return String(value);\n\n        case 'boolean':\n          return value ? 'true' : 'false';\n\n        case 'object':\n          if (!value) {\n            return 'null';\n          }\n\n        // eslint-disable-next-line no-fallthrough\n\n        default:\n          // This should never happen, I can't imagine a situation where this executes.\n          // If you find a way, please open a ticket or PR\n          throw Object.assign(new Error(`Not a primitive \"${typeof value}\".`), {\n            value\n          });\n      }\n    };\n  }\n  /*\r\n  function quoteString(string: string) {\r\n    return primitiveToJSON(String(string));\r\n  }\r\n  */\n\n\n  const cache = new Map();\n\n  function quoteString(string) {\n    const useCache = string.length < 10000; // eslint-disable-next-line no-lonely-if\n\n    if (useCache && cache.has(string)) {\n      return cache.get(string);\n    }\n\n    const str = primitiveToJSON(String(string));\n    if (useCache) cache.set(string, str);\n    return str;\n  }\n\n  function readAsPromised(stream, size) {\n    var _stream$_readableStat;\n\n    const value = stream.read(size);\n\n    if (value === null && !(stream.readableEnded || (_stream$_readableStat = stream._readableState) !== null && _stream$_readableStat !== void 0 && _stream$_readableStat.ended)) {\n      return new Promise((resolve, reject) => {\n        const endListener = () => resolve(null);\n\n        stream.once('end', endListener);\n        stream.once('error', reject);\n        stream.once('readable', () => {\n          stream.removeListener('end', endListener);\n          stream.removeListener('error', reject);\n          readAsPromised(stream, size).then(resolve, reject);\n        });\n      });\n    }\n\n    return Promise.resolve(value);\n  }\n\n  var ReadState;\n\n  (function (ReadState) {\n    ReadState[ReadState[\"Inactive\"] = 0] = \"Inactive\";\n    ReadState[ReadState[\"Reading\"] = 1] = \"Reading\";\n    ReadState[ReadState[\"ReadMore\"] = 2] = \"ReadMore\";\n    ReadState[ReadState[\"Consumed\"] = 3] = \"Consumed\";\n  })(ReadState || (ReadState = {}));\n\n  class JsonStreamStringify extends stream.Readable {\n    constructor(input, replacer, spaces, cycle = false, bufferSize = 512) {\n      super({\n        encoding: 'utf8'\n      });\n\n      _defineProperty(this, \"cycle\", void 0);\n\n      _defineProperty(this, \"bufferSize\", void 0);\n\n      _defineProperty(this, \"item\", void 0);\n\n      _defineProperty(this, \"indent\", void 0);\n\n      _defineProperty(this, \"root\", void 0);\n\n      _defineProperty(this, \"include\", void 0);\n\n      _defineProperty(this, \"replacer\", void 0);\n\n      _defineProperty(this, \"visited\", void 0);\n\n      _defineProperty(this, \"objectItem\", void 0);\n\n      _defineProperty(this, \"buffer\", '');\n\n      _defineProperty(this, \"bufferLength\", 0);\n\n      _defineProperty(this, \"pushCalled\", false);\n\n      _defineProperty(this, \"readSize\", 0);\n\n      _defineProperty(this, \"prePush\", void 0);\n\n      _defineProperty(this, \"readState\", ReadState.Inactive);\n\n      this.cycle = cycle;\n      this.bufferSize = bufferSize;\n      const spaceType = typeof spaces;\n\n      if (spaceType === 'number') {\n        this.indent = ' '.repeat(spaces);\n      } else if (spaceType === 'string') {\n        this.indent = spaces;\n      }\n\n      const replacerType = typeof replacer;\n\n      if (replacerType === 'object') {\n        this.include = replacer;\n      } else if (replacerType === 'function') {\n        this.replacer = replacer;\n      }\n\n      this.visited = cycle ? new WeakMap() : [];\n      this.root = {\n        value: {\n          '': input\n        },\n        depth: 0,\n        indent: '',\n        path: []\n      };\n      this.setItem(input, this.root, '');\n    }\n\n    setItem(value, parent, key = '') {\n      // call toJSON where applicable\n      if (value && typeof value === 'object' && typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n      } // use replacer if applicable\n\n\n      if (this.replacer) {\n        value = this.replacer.call(parent.value, key, value);\n      } // coerece functions and symbols into undefined\n\n\n      if (value instanceof Function || typeof value === 'symbol') {\n        value = undefined;\n      }\n\n      const type = getType(value);\n      let path; // check for circular structure\n\n      if (!this.cycle && type !== Types.Primitive) {\n        if (this.visited.some(v => v === value)) {\n          this.destroy(Object.assign(new Error('Converting circular structure to JSON'), {\n            value,\n            key\n          }));\n          return;\n        }\n\n        this.visited.push(value);\n      } else if (this.cycle && type !== Types.Primitive) {\n        path = this.visited.get(value);\n\n        if (path) {\n          this._push(`{\"$ref\":\"$${path.map(v => `[${Number.isInteger(v) ? v : escapeString(quoteString(v))}]`).join('')}\"}`);\n\n          this.item = parent;\n          return;\n        }\n\n        path = parent === this.root ? [] : parent.path.concat(key);\n        this.visited.set(value, path);\n      }\n\n      if (type === Types.Object) {\n        this.setObjectItem(value, parent);\n      } else if (type === Types.Array) {\n        this.setArrayItem(value, parent);\n      } else if (type === Types.Primitive) {\n        if (parent !== this.root && typeof key === 'string') {\n          // (<any>parent).write(key, primitiveToJSON(value));\n          if (value === undefined) ; else {\n            this._push(primitiveToJSON(value));\n          } // undefined values in objects should be rejected\n\n        } else if (value === undefined && typeof key === 'number') {\n          // undefined values in array should be null\n          this._push('null');\n        } else if (value === undefined) ; else {\n          this._push(primitiveToJSON(value));\n        }\n\n        this.item = parent;\n        return;\n      } else if (type === Types.Promise) {\n        this.setPromiseItem(value, parent, key);\n      } else if (type === Types.ReadableString) {\n        this.setReadableStringItem(value, parent);\n      } else if (type === Types.ReadableObject) {\n        this.setReadableObjectItem(value, parent);\n      }\n\n      this.item.value = value;\n      this.item.depth = parent.depth + 1;\n      if (this.indent) this.item.indent = this.indent.repeat(this.item.depth);\n      this.item.path = path;\n    }\n\n    setReadableStringItem(input, parent) {\n      var _input$_readableState, _input$_readableState2;\n\n      if (input.readableEnded || (_input$_readableState = input._readableState) !== null && _input$_readableState !== void 0 && _input$_readableState.endEmitted) {\n        this.emit('error', new Error('Readable Stream has ended before it was serialized. All stream data have been lost'), input, parent.path);\n      } else if (input.readableFlowing || (_input$_readableState2 = input._readableState) !== null && _input$_readableState2 !== void 0 && _input$_readableState2.flowing) {\n        input.pause();\n        this.emit('error', new Error('Readable Stream is in flowing mode, data may have been lost. Trying to pause stream.'), input, parent.path);\n      }\n\n      const that = this;\n      this.prePush = '\"';\n      this.item = {\n        type: 'readable string',\n\n        async read(size) {\n          try {\n            const data = await readAsPromised(input, size);\n\n            if (data === null) {\n              that._push('\"');\n\n              that.item = parent;\n              that.unvisit(input);\n              return;\n            }\n\n            if (data) that._push(escapeString(data.toString()));\n          } catch (err) {\n            that.emit('error', err);\n            that.destroy();\n          }\n        }\n\n      };\n    }\n\n    setReadableObjectItem(input, parent) {\n      var _input$_readableState3, _input$_readableState4;\n\n      if (input.readableEnded || (_input$_readableState3 = input._readableState) !== null && _input$_readableState3 !== void 0 && _input$_readableState3.endEmitted) {\n        this.emit('error', new Error('Readable Stream has ended before it was serialized. All stream data have been lost'), input, parent.path);\n      } else if (input.readableFlowing || (_input$_readableState4 = input._readableState) !== null && _input$_readableState4 !== void 0 && _input$_readableState4.flowing) {\n        input.pause();\n        this.emit('error', new Error('Readable Stream is in flowing mode, data may have been lost. Trying to pause stream.'), input, parent.path);\n      }\n\n      const that = this;\n\n      this._push('[');\n\n      let first = true;\n      let i = 0;\n      const item = {\n        type: 'readable object',\n\n        async read() {\n          try {\n            let out = '';\n            const data = await readAsPromised(input);\n\n            if (data === null) {\n              if (i && that.indent) {\n                out += `\\n${parent.indent}`;\n              }\n\n              out += ']';\n\n              that._push(out);\n\n              that.item = parent;\n              that.unvisit(input);\n              return;\n            }\n\n            if (first) first = false;else out += ',';\n            if (that.indent) out += `\\n${item.indent}`;\n            that.prePush = out;\n            that.setItem(data, item, i);\n            i += 1;\n          } catch (err) {\n            that.emit('error', err);\n            that.destroy();\n          }\n        }\n\n      };\n      this.item = item;\n    }\n\n    setPromiseItem(input, parent, key) {\n      const that = this;\n      let read = false;\n      this.item = {\n        async read() {\n          if (read) return;\n\n          try {\n            read = true;\n            that.setItem(await input, parent, key);\n          } catch (err) {\n            that.emit('error', err);\n            that.destroy();\n          }\n        }\n\n      };\n    }\n\n    setArrayItem(input, parent) {\n      // const entries = input.slice().reverse();\n      let i = 0;\n      const len = input.length;\n      let first = true;\n      const that = this;\n      const item = {\n        read() {\n          let out = '';\n          let wasFirst = false;\n\n          if (first) {\n            first = false;\n            wasFirst = true;\n\n            if (!len) {\n              that._push('[]');\n\n              that.unvisit(input);\n              that.item = parent;\n              return;\n            }\n\n            out += '[';\n          }\n\n          const entry = input[i];\n\n          if (i === len) {\n            if (that.indent) out += `\\n${parent.indent}`;\n            out += ']';\n\n            that._push(out);\n\n            that.item = parent;\n            that.unvisit(input);\n            return;\n          }\n\n          if (!wasFirst) out += ',';\n          if (that.indent) out += `\\n${item.indent}`;\n\n          that._push(out);\n\n          that.setItem(entry, item, i);\n          i += 1;\n        }\n\n      };\n      this.item = item;\n    }\n\n    unvisit(item) {\n      if (this.cycle) return;\n\n      const _i = this.visited.indexOf(item);\n\n      if (_i > -1) this.visited.splice(_i, 1);\n    }\n\n    setObjectItem(input, parent = undefined) {\n      const keys = Object.keys(input);\n      let i = 0;\n      const len = keys.length;\n      let first = true;\n      const that = this;\n      const {\n        include\n      } = this;\n      let hasItems = false;\n      let key;\n      const item = {\n        read() {\n          var _include$indexOf;\n\n          if (i === 0) that._push('{');\n\n          if (i === len) {\n            that.objectItem = undefined;\n\n            if (!hasItems) {\n              that._push('}');\n            } else {\n              that._push(`${that.indent ? `\\n${parent.indent}` : ''}}`);\n            }\n\n            that.item = parent;\n            that.unvisit(input);\n            return;\n          }\n\n          key = keys[i];\n\n          if ((include === null || include === void 0 ? void 0 : (_include$indexOf = include.indexOf) === null || _include$indexOf === void 0 ? void 0 : _include$indexOf.call(include, key)) === -1) {\n            // replacer array excludes this key\n            i += 1;\n            return;\n          }\n\n          that.objectItem = item;\n          i += 1;\n          that.setItem(input[key], item, key);\n        },\n\n        write() {\n          const out = `${hasItems && !first ? ',' : ''}${item.indent ? `\\n${item.indent}` : ''}${quoteString(key)}:${that.indent ? ' ' : ''}`;\n          first = false;\n          hasItems = true;\n          that.objectItem = undefined;\n          return out;\n        }\n\n      };\n      this.item = item;\n    }\n\n    _push(data) {\n      const out = (this.objectItem ? this.objectItem.write() : '') + data;\n\n      if (this.prePush && out.length) {\n        this.buffer += this.prePush;\n        this.prePush = undefined;\n      }\n\n      this.buffer += out;\n\n      if (this.buffer.length >= this.bufferSize) {\n        this.pushCalled = !this.push(this.buffer);\n        this.buffer = '';\n        this.bufferLength = 0;\n        return false;\n      }\n\n      return true;\n    }\n\n    async _read(size) {\n      if (this.readState === ReadState.Consumed) return;\n\n      if (this.readState !== ReadState.Inactive) {\n        this.readState = ReadState.ReadMore;\n        return;\n      }\n\n      this.readState = ReadState.Reading;\n      this.pushCalled = false;\n      let p;\n\n      while (!this.pushCalled && this.item !== this.root && this.buffer !== undefined) {\n        p = this.item.read(size); // eslint-disable-next-line no-await-in-loop\n\n        if (p) await p;\n      }\n\n      if (this.buffer === undefined) return;\n\n      if (this.item === this.root) {\n        if (this.buffer.length) this.push(this.buffer);\n        this.push(null);\n        this.readState = ReadState.Consumed;\n        this.cleanup();\n        return;\n      }\n\n      if (this.readState === ReadState.ReadMore) {\n        this.readState = ReadState.Inactive;\n        await this._read(size);\n        return;\n      }\n\n      this.readState = ReadState.Inactive;\n    }\n\n    cleanup() {\n      this.readState = ReadState.Consumed;\n      this.buffer = undefined;\n      this.visited = undefined;\n      this.item = undefined;\n      this.root = undefined;\n      this.prePush = undefined;\n    }\n\n    destroy(error) {\n      var _super$destroy;\n\n      if (error) this.emit('error', error);\n      (_super$destroy = super.destroy) === null || _super$destroy === void 0 ? void 0 : _super$destroy.call(this);\n      this.cleanup();\n      return this;\n    }\n\n  }\n\n  exports.JsonStreamStringify = JsonStreamStringify;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbi1zdHJlYW0tc3RyaW5naWZ5L2xpYi91bWQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2xHLEVBQUUsQ0FDbUk7QUFDckksQ0FBQyxzQ0FBc0M7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEseUpBQXlKOztBQUV6SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxzQkFBc0I7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDhDQUE4QztBQUM3RixLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjs7QUFFekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGFBQWE7QUFDekU7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxT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QUFDQSxTQUFTOztBQUVUO0FBQ0EseUJBQXlCLDhCQUE4QixFQUFFLG1CQUFtQixZQUFZLE9BQU8sRUFBRSxpQkFBaUIsR0FBRyx1QkFBdUI7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsaURBQWlELGFBQWE7O0FBRTlELENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvanNvbi1zdHJlYW0tc3RyaW5naWZ5L2xpYi91bWQvaW5kZXguanM/ODAzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ3N0cmVhbScpKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnc3RyZWFtJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuanNvblN0cmVhbVN0cmluZ2lmeSA9IHt9LCBnbG9iYWwuc3RyZWFtKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIHN0cmVhbSkgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIF9nbG9iYWwsIF9nbG9iYWwkSlNPTjtcblxuICBjb25zdCByeEVzY2FwYWJsZSA9IC9bXFxcXFwiXFx1MDAwMC1cXHUwMDFmXFx1MDA3Zi1cXHUwMDlmXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2c7IC8vIHRhYmxlIG9mIGNoYXJhY3RlciBzdWJzdGl0dXRpb25zXG5cbiAgY29uc3QgbWV0YSA9IHtcbiAgICAnXFxiJzogJ1xcXFxiJyxcbiAgICAnXFx0JzogJ1xcXFx0JyxcbiAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAnXFxmJzogJ1xcXFxmJyxcbiAgICAnXFxyJzogJ1xcXFxyJyxcbiAgICAnXCInOiAnXFxcXFwiJyxcbiAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgfTtcblxuICBmdW5jdGlvbiBpc1JlYWRhYmxlU3RyZWFtKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5yZWFkID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5wYXVzZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUucmVzdW1lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5waXBlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5vbmNlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIHZhciBUeXBlcztcblxuICAoZnVuY3Rpb24gKFR5cGVzKSB7XG4gICAgVHlwZXNbVHlwZXNbXCJBcnJheVwiXSA9IDBdID0gXCJBcnJheVwiO1xuICAgIFR5cGVzW1R5cGVzW1wiT2JqZWN0XCJdID0gMV0gPSBcIk9iamVjdFwiO1xuICAgIFR5cGVzW1R5cGVzW1wiUmVhZGFibGVTdHJpbmdcIl0gPSAyXSA9IFwiUmVhZGFibGVTdHJpbmdcIjtcbiAgICBUeXBlc1tUeXBlc1tcIlJlYWRhYmxlT2JqZWN0XCJdID0gM10gPSBcIlJlYWRhYmxlT2JqZWN0XCI7XG4gICAgVHlwZXNbVHlwZXNbXCJQcmltaXRpdmVcIl0gPSA0XSA9IFwiUHJpbWl0aXZlXCI7XG4gICAgVHlwZXNbVHlwZXNbXCJQcm9taXNlXCJdID0gNV0gPSBcIlByb21pc2VcIjtcbiAgfSkoVHlwZXMgfHwgKFR5cGVzID0ge30pKTtcblxuICBmdW5jdGlvbiBnZXRUeXBlKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuIFR5cGVzLlByaW1pdGl2ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHJldHVybiBUeXBlcy5Qcm9taXNlO1xuICAgIGlmIChpc1JlYWRhYmxlU3RyZWFtKHZhbHVlKSkgcmV0dXJuIHZhbHVlLl9yZWFkYWJsZVN0YXRlLm9iamVjdE1vZGUgPyBUeXBlcy5SZWFkYWJsZU9iamVjdCA6IFR5cGVzLlJlYWRhYmxlU3RyaW5nO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIFR5cGVzLkFycmF5O1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSByZXR1cm4gVHlwZXMuT2JqZWN0O1xuICAgIHJldHVybiBUeXBlcy5QcmltaXRpdmU7XG4gIH1cblxuICBmdW5jdGlvbiBlc2NhcGVTdHJpbmcoc3RyaW5nKSB7XG4gICAgLy8gTW9kaWZpZWQgY29kZSwgb3JpZ2luYWwgY29kZSBieSBEb3VnbGFzIENyb2NrZm9yZFxuICAgIC8vIE9yaWdpbmFsOiBodHRwczovL2dpdGh1Yi5jb20vZG91Z2xhc2Nyb2NrZm9yZC9KU09OLWpzL2Jsb2IvbWFzdGVyL2pzb24yLmpzXG4gICAgLy8gSWYgdGhlIHN0cmluZyBjb250YWlucyBubyBjb250cm9sIGNoYXJhY3RlcnMsIG5vIHF1b3RlIGNoYXJhY3RlcnMsIGFuZCBub1xuICAgIC8vIGJhY2tzbGFzaCBjaGFyYWN0ZXJzLCB0aGVuIHdlIGNhbiBzYWZlbHkgc2xhcCBzb21lIHF1b3RlcyBhcm91bmQgaXQuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIG11c3QgYWxzbyByZXBsYWNlIHRoZSBvZmZlbmRpbmcgY2hhcmFjdGVycyB3aXRoIHNhZmUgZXNjYXBlXG4gICAgLy8gc2VxdWVuY2VzLlxuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyeEVzY2FwYWJsZSwgYSA9PiB7XG4gICAgICBjb25zdCBjID0gbWV0YVthXTtcbiAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgPyBjIDogYFxcXFx1JHthLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDQsICcwJyl9YDtcbiAgICB9KTtcbiAgfVxuXG4gIGxldCBwcmltaXRpdmVUb0pTT047XG5cbiAgaWYgKCgoX2dsb2JhbCA9IGdsb2JhbCkgPT09IG51bGwgfHwgX2dsb2JhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9nbG9iYWwkSlNPTiA9IF9nbG9iYWwuSlNPTikgPT09IG51bGwgfHwgX2dsb2JhbCRKU09OID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2xvYmFsJEpTT04uc3RyaW5naWZ5KSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChKU09OLnN0cmluZ2lmeShnbG9iYWwuQmlnSW50ID8gZ2xvYmFsLkJpZ0ludCgnMTIzJykgOiAnJykgIT09ICcxMjMnKSB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgIHByaW1pdGl2ZVRvSlNPTiA9IEpTT04uc3RyaW5naWZ5O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gQWRkIHN1cHBvcnQgZm9yIGJpZ2ludCBmb3IgcHJpbWl0aXZlVG9KU09OXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZnVzaW5nLWFycm93XG4gICAgICBwcmltaXRpdmVUb0pTT04gPSB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnID8gU3RyaW5nKHZhbHVlKSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcHJpbWl0aXZlVG9KU09OID0gdmFsdWUgPT4ge1xuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICByZXR1cm4gYFwiJHtlc2NhcGVTdHJpbmcodmFsdWUpfVwiYDtcblxuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpID8gU3RyaW5nKHZhbHVlKSA6ICdudWxsJztcblxuICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgIHJldHVybiB2YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICAgIH1cblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgSSBjYW4ndCBpbWFnaW5lIGEgc2l0dWF0aW9uIHdoZXJlIHRoaXMgZXhlY3V0ZXMuXG4gICAgICAgICAgLy8gSWYgeW91IGZpbmQgYSB3YXksIHBsZWFzZSBvcGVuIGEgdGlja2V0IG9yIFBSXG4gICAgICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoYE5vdCBhIHByaW1pdGl2ZSBcIiR7dHlwZW9mIHZhbHVlfVwiLmApLCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLypcclxuICBmdW5jdGlvbiBxdW90ZVN0cmluZyhzdHJpbmc6IHN0cmluZykge1xyXG4gICAgcmV0dXJuIHByaW1pdGl2ZVRvSlNPTihTdHJpbmcoc3RyaW5nKSk7XHJcbiAgfVxyXG4gICovXG5cblxuICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcblxuICBmdW5jdGlvbiBxdW90ZVN0cmluZyhzdHJpbmcpIHtcbiAgICBjb25zdCB1c2VDYWNoZSA9IHN0cmluZy5sZW5ndGggPCAxMDAwMDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmVseS1pZlxuXG4gICAgaWYgKHVzZUNhY2hlICYmIGNhY2hlLmhhcyhzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KHN0cmluZyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyID0gcHJpbWl0aXZlVG9KU09OKFN0cmluZyhzdHJpbmcpKTtcbiAgICBpZiAodXNlQ2FjaGUpIGNhY2hlLnNldChzdHJpbmcsIHN0cik7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBc1Byb21pc2VkKHN0cmVhbSwgc2l6ZSkge1xuICAgIHZhciBfc3RyZWFtJF9yZWFkYWJsZVN0YXQ7XG5cbiAgICBjb25zdCB2YWx1ZSA9IHN0cmVhbS5yZWFkKHNpemUpO1xuXG4gICAgaWYgKHZhbHVlID09PSBudWxsICYmICEoc3RyZWFtLnJlYWRhYmxlRW5kZWQgfHwgKF9zdHJlYW0kX3JlYWRhYmxlU3RhdCA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZSkgIT09IG51bGwgJiYgX3N0cmVhbSRfcmVhZGFibGVTdGF0ICE9PSB2b2lkIDAgJiYgX3N0cmVhbSRfcmVhZGFibGVTdGF0LmVuZGVkKSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgZW5kTGlzdGVuZXIgPSAoKSA9PiByZXNvbHZlKG51bGwpO1xuXG4gICAgICAgIHN0cmVhbS5vbmNlKCdlbmQnLCBlbmRMaXN0ZW5lcik7XG4gICAgICAgIHN0cmVhbS5vbmNlKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICAgIHN0cmVhbS5vbmNlKCdyZWFkYWJsZScsICgpID0+IHtcbiAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGVuZExpc3RlbmVyKTtcbiAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgICByZWFkQXNQcm9taXNlZChzdHJlYW0sIHNpemUpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcbiAgfVxuXG4gIHZhciBSZWFkU3RhdGU7XG5cbiAgKGZ1bmN0aW9uIChSZWFkU3RhdGUpIHtcbiAgICBSZWFkU3RhdGVbUmVhZFN0YXRlW1wiSW5hY3RpdmVcIl0gPSAwXSA9IFwiSW5hY3RpdmVcIjtcbiAgICBSZWFkU3RhdGVbUmVhZFN0YXRlW1wiUmVhZGluZ1wiXSA9IDFdID0gXCJSZWFkaW5nXCI7XG4gICAgUmVhZFN0YXRlW1JlYWRTdGF0ZVtcIlJlYWRNb3JlXCJdID0gMl0gPSBcIlJlYWRNb3JlXCI7XG4gICAgUmVhZFN0YXRlW1JlYWRTdGF0ZVtcIkNvbnN1bWVkXCJdID0gM10gPSBcIkNvbnN1bWVkXCI7XG4gIH0pKFJlYWRTdGF0ZSB8fCAoUmVhZFN0YXRlID0ge30pKTtcblxuICBjbGFzcyBKc29uU3RyZWFtU3RyaW5naWZ5IGV4dGVuZHMgc3RyZWFtLlJlYWRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihpbnB1dCwgcmVwbGFjZXIsIHNwYWNlcywgY3ljbGUgPSBmYWxzZSwgYnVmZmVyU2l6ZSA9IDUxMikge1xuICAgICAgc3VwZXIoe1xuICAgICAgICBlbmNvZGluZzogJ3V0ZjgnXG4gICAgICB9KTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY3ljbGVcIiwgdm9pZCAwKTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYnVmZmVyU2l6ZVwiLCB2b2lkIDApO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpdGVtXCIsIHZvaWQgMCk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluZGVudFwiLCB2b2lkIDApO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyb290XCIsIHZvaWQgMCk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVcIiwgdm9pZCAwKTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmVwbGFjZXJcIiwgdm9pZCAwKTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidmlzaXRlZFwiLCB2b2lkIDApO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvYmplY3RJdGVtXCIsIHZvaWQgMCk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJ1ZmZlclwiLCAnJyk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJ1ZmZlckxlbmd0aFwiLCAwKTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicHVzaENhbGxlZFwiLCBmYWxzZSk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlYWRTaXplXCIsIDApO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcmVQdXNoXCIsIHZvaWQgMCk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlYWRTdGF0ZVwiLCBSZWFkU3RhdGUuSW5hY3RpdmUpO1xuXG4gICAgICB0aGlzLmN5Y2xlID0gY3ljbGU7XG4gICAgICB0aGlzLmJ1ZmZlclNpemUgPSBidWZmZXJTaXplO1xuICAgICAgY29uc3Qgc3BhY2VUeXBlID0gdHlwZW9mIHNwYWNlcztcblxuICAgICAgaWYgKHNwYWNlVHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhpcy5pbmRlbnQgPSAnICcucmVwZWF0KHNwYWNlcyk7XG4gICAgICB9IGVsc2UgaWYgKHNwYWNlVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5pbmRlbnQgPSBzcGFjZXM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcGxhY2VyVHlwZSA9IHR5cGVvZiByZXBsYWNlcjtcblxuICAgICAgaWYgKHJlcGxhY2VyVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhpcy5pbmNsdWRlID0gcmVwbGFjZXI7XG4gICAgICB9IGVsc2UgaWYgKHJlcGxhY2VyVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmlzaXRlZCA9IGN5Y2xlID8gbmV3IFdlYWtNYXAoKSA6IFtdO1xuICAgICAgdGhpcy5yb290ID0ge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICcnOiBpbnB1dFxuICAgICAgICB9LFxuICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgaW5kZW50OiAnJyxcbiAgICAgICAgcGF0aDogW11cbiAgICAgIH07XG4gICAgICB0aGlzLnNldEl0ZW0oaW5wdXQsIHRoaXMucm9vdCwgJycpO1xuICAgIH1cblxuICAgIHNldEl0ZW0odmFsdWUsIHBhcmVudCwga2V5ID0gJycpIHtcbiAgICAgIC8vIGNhbGwgdG9KU09OIHdoZXJlIGFwcGxpY2FibGVcbiAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oa2V5KTtcbiAgICAgIH0gLy8gdXNlIHJlcGxhY2VyIGlmIGFwcGxpY2FibGVcblxuXG4gICAgICBpZiAodGhpcy5yZXBsYWNlcikge1xuICAgICAgICB2YWx1ZSA9IHRoaXMucmVwbGFjZXIuY2FsbChwYXJlbnQudmFsdWUsIGtleSwgdmFsdWUpO1xuICAgICAgfSAvLyBjb2VyZWNlIGZ1bmN0aW9ucyBhbmQgc3ltYm9scyBpbnRvIHVuZGVmaW5lZFxuXG5cbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlKHZhbHVlKTtcbiAgICAgIGxldCBwYXRoOyAvLyBjaGVjayBmb3IgY2lyY3VsYXIgc3RydWN0dXJlXG5cbiAgICAgIGlmICghdGhpcy5jeWNsZSAmJiB0eXBlICE9PSBUeXBlcy5QcmltaXRpdmUpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaXRlZC5zb21lKHYgPT4gdiA9PT0gdmFsdWUpKSB7XG4gICAgICAgICAgdGhpcy5kZXN0cm95KE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCdDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09OJyksIHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAga2V5XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmlzaXRlZC5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jeWNsZSAmJiB0eXBlICE9PSBUeXBlcy5QcmltaXRpdmUpIHtcbiAgICAgICAgcGF0aCA9IHRoaXMudmlzaXRlZC5nZXQodmFsdWUpO1xuXG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgdGhpcy5fcHVzaChge1wiJHJlZlwiOlwiJCR7cGF0aC5tYXAodiA9PiBgWyR7TnVtYmVyLmlzSW50ZWdlcih2KSA/IHYgOiBlc2NhcGVTdHJpbmcocXVvdGVTdHJpbmcodikpfV1gKS5qb2luKCcnKX1cIn1gKTtcblxuICAgICAgICAgIHRoaXMuaXRlbSA9IHBhcmVudDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoID0gcGFyZW50ID09PSB0aGlzLnJvb3QgPyBbXSA6IHBhcmVudC5wYXRoLmNvbmNhdChrZXkpO1xuICAgICAgICB0aGlzLnZpc2l0ZWQuc2V0KHZhbHVlLCBwYXRoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09IFR5cGVzLk9iamVjdCkge1xuICAgICAgICB0aGlzLnNldE9iamVjdEl0ZW0odmFsdWUsIHBhcmVudCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFR5cGVzLkFycmF5KSB7XG4gICAgICAgIHRoaXMuc2V0QXJyYXlJdGVtKHZhbHVlLCBwYXJlbnQpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUeXBlcy5QcmltaXRpdmUpIHtcbiAgICAgICAgaWYgKHBhcmVudCAhPT0gdGhpcy5yb290ICYmIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gKDxhbnk+cGFyZW50KS53cml0ZShrZXksIHByaW1pdGl2ZVRvSlNPTih2YWx1ZSkpO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSA7IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHVzaChwcmltaXRpdmVUb0pTT04odmFsdWUpKTtcbiAgICAgICAgICB9IC8vIHVuZGVmaW5lZCB2YWx1ZXMgaW4gb2JqZWN0cyBzaG91bGQgYmUgcmVqZWN0ZWRcblxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIGtleSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAvLyB1bmRlZmluZWQgdmFsdWVzIGluIGFycmF5IHNob3VsZCBiZSBudWxsXG4gICAgICAgICAgdGhpcy5fcHVzaCgnbnVsbCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIDsgZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcHVzaChwcmltaXRpdmVUb0pTT04odmFsdWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXRlbSA9IHBhcmVudDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUeXBlcy5Qcm9taXNlKSB7XG4gICAgICAgIHRoaXMuc2V0UHJvbWlzZUl0ZW0odmFsdWUsIHBhcmVudCwga2V5KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVHlwZXMuUmVhZGFibGVTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZXRSZWFkYWJsZVN0cmluZ0l0ZW0odmFsdWUsIHBhcmVudCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFR5cGVzLlJlYWRhYmxlT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuc2V0UmVhZGFibGVPYmplY3RJdGVtKHZhbHVlLCBwYXJlbnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLml0ZW0udmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuaXRlbS5kZXB0aCA9IHBhcmVudC5kZXB0aCArIDE7XG4gICAgICBpZiAodGhpcy5pbmRlbnQpIHRoaXMuaXRlbS5pbmRlbnQgPSB0aGlzLmluZGVudC5yZXBlYXQodGhpcy5pdGVtLmRlcHRoKTtcbiAgICAgIHRoaXMuaXRlbS5wYXRoID0gcGF0aDtcbiAgICB9XG5cbiAgICBzZXRSZWFkYWJsZVN0cmluZ0l0ZW0oaW5wdXQsIHBhcmVudCkge1xuICAgICAgdmFyIF9pbnB1dCRfcmVhZGFibGVTdGF0ZSwgX2lucHV0JF9yZWFkYWJsZVN0YXRlMjtcblxuICAgICAgaWYgKGlucHV0LnJlYWRhYmxlRW5kZWQgfHwgKF9pbnB1dCRfcmVhZGFibGVTdGF0ZSA9IGlucHV0Ll9yZWFkYWJsZVN0YXRlKSAhPT0gbnVsbCAmJiBfaW5wdXQkX3JlYWRhYmxlU3RhdGUgIT09IHZvaWQgMCAmJiBfaW5wdXQkX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdSZWFkYWJsZSBTdHJlYW0gaGFzIGVuZGVkIGJlZm9yZSBpdCB3YXMgc2VyaWFsaXplZC4gQWxsIHN0cmVhbSBkYXRhIGhhdmUgYmVlbiBsb3N0JyksIGlucHV0LCBwYXJlbnQucGF0aCk7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0LnJlYWRhYmxlRmxvd2luZyB8fCAoX2lucHV0JF9yZWFkYWJsZVN0YXRlMiA9IGlucHV0Ll9yZWFkYWJsZVN0YXRlKSAhPT0gbnVsbCAmJiBfaW5wdXQkX3JlYWRhYmxlU3RhdGUyICE9PSB2b2lkIDAgJiYgX2lucHV0JF9yZWFkYWJsZVN0YXRlMi5mbG93aW5nKSB7XG4gICAgICAgIGlucHV0LnBhdXNlKCk7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1JlYWRhYmxlIFN0cmVhbSBpcyBpbiBmbG93aW5nIG1vZGUsIGRhdGEgbWF5IGhhdmUgYmVlbiBsb3N0LiBUcnlpbmcgdG8gcGF1c2Ugc3RyZWFtLicpLCBpbnB1dCwgcGFyZW50LnBhdGgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0aGF0ID0gdGhpcztcbiAgICAgIHRoaXMucHJlUHVzaCA9ICdcIic7XG4gICAgICB0aGlzLml0ZW0gPSB7XG4gICAgICAgIHR5cGU6ICdyZWFkYWJsZSBzdHJpbmcnLFxuXG4gICAgICAgIGFzeW5jIHJlYWQoc2l6ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVhZEFzUHJvbWlzZWQoaW5wdXQsIHNpemUpO1xuXG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aGF0Ll9wdXNoKCdcIicpO1xuXG4gICAgICAgICAgICAgIHRoYXQuaXRlbSA9IHBhcmVudDtcbiAgICAgICAgICAgICAgdGhhdC51bnZpc2l0KGlucHV0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkgdGhhdC5fcHVzaChlc2NhcGVTdHJpbmcoZGF0YS50b1N0cmluZygpKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGF0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgIHRoYXQuZGVzdHJveSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9O1xuICAgIH1cblxuICAgIHNldFJlYWRhYmxlT2JqZWN0SXRlbShpbnB1dCwgcGFyZW50KSB7XG4gICAgICB2YXIgX2lucHV0JF9yZWFkYWJsZVN0YXRlMywgX2lucHV0JF9yZWFkYWJsZVN0YXRlNDtcblxuICAgICAgaWYgKGlucHV0LnJlYWRhYmxlRW5kZWQgfHwgKF9pbnB1dCRfcmVhZGFibGVTdGF0ZTMgPSBpbnB1dC5fcmVhZGFibGVTdGF0ZSkgIT09IG51bGwgJiYgX2lucHV0JF9yZWFkYWJsZVN0YXRlMyAhPT0gdm9pZCAwICYmIF9pbnB1dCRfcmVhZGFibGVTdGF0ZTMuZW5kRW1pdHRlZCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdSZWFkYWJsZSBTdHJlYW0gaGFzIGVuZGVkIGJlZm9yZSBpdCB3YXMgc2VyaWFsaXplZC4gQWxsIHN0cmVhbSBkYXRhIGhhdmUgYmVlbiBsb3N0JyksIGlucHV0LCBwYXJlbnQucGF0aCk7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0LnJlYWRhYmxlRmxvd2luZyB8fCAoX2lucHV0JF9yZWFkYWJsZVN0YXRlNCA9IGlucHV0Ll9yZWFkYWJsZVN0YXRlKSAhPT0gbnVsbCAmJiBfaW5wdXQkX3JlYWRhYmxlU3RhdGU0ICE9PSB2b2lkIDAgJiYgX2lucHV0JF9yZWFkYWJsZVN0YXRlNC5mbG93aW5nKSB7XG4gICAgICAgIGlucHV0LnBhdXNlKCk7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1JlYWRhYmxlIFN0cmVhbSBpcyBpbiBmbG93aW5nIG1vZGUsIGRhdGEgbWF5IGhhdmUgYmVlbiBsb3N0LiBUcnlpbmcgdG8gcGF1c2Ugc3RyZWFtLicpLCBpbnB1dCwgcGFyZW50LnBhdGgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0aGF0ID0gdGhpcztcblxuICAgICAgdGhpcy5fcHVzaCgnWycpO1xuXG4gICAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgdHlwZTogJ3JlYWRhYmxlIG9iamVjdCcsXG5cbiAgICAgICAgYXN5bmMgcmVhZCgpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IG91dCA9ICcnO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlYWRBc1Byb21pc2VkKGlucHV0KTtcblxuICAgICAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKGkgJiYgdGhhdC5pbmRlbnQpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gYFxcbiR7cGFyZW50LmluZGVudH1gO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb3V0ICs9ICddJztcblxuICAgICAgICAgICAgICB0aGF0Ll9wdXNoKG91dCk7XG5cbiAgICAgICAgICAgICAgdGhhdC5pdGVtID0gcGFyZW50O1xuICAgICAgICAgICAgICB0aGF0LnVudmlzaXQoaW5wdXQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaXJzdCkgZmlyc3QgPSBmYWxzZTtlbHNlIG91dCArPSAnLCc7XG4gICAgICAgICAgICBpZiAodGhhdC5pbmRlbnQpIG91dCArPSBgXFxuJHtpdGVtLmluZGVudH1gO1xuICAgICAgICAgICAgdGhhdC5wcmVQdXNoID0gb3V0O1xuICAgICAgICAgICAgdGhhdC5zZXRJdGVtKGRhdGEsIGl0ZW0sIGkpO1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhhdC5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICB0aGF0LmRlc3Ryb3koKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfTtcbiAgICAgIHRoaXMuaXRlbSA9IGl0ZW07XG4gICAgfVxuXG4gICAgc2V0UHJvbWlzZUl0ZW0oaW5wdXQsIHBhcmVudCwga2V5KSB7XG4gICAgICBjb25zdCB0aGF0ID0gdGhpcztcbiAgICAgIGxldCByZWFkID0gZmFsc2U7XG4gICAgICB0aGlzLml0ZW0gPSB7XG4gICAgICAgIGFzeW5jIHJlYWQoKSB7XG4gICAgICAgICAgaWYgKHJlYWQpIHJldHVybjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZWFkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoYXQuc2V0SXRlbShhd2FpdCBpbnB1dCwgcGFyZW50LCBrZXkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhhdC5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICB0aGF0LmRlc3Ryb3koKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfTtcbiAgICB9XG5cbiAgICBzZXRBcnJheUl0ZW0oaW5wdXQsIHBhcmVudCkge1xuICAgICAgLy8gY29uc3QgZW50cmllcyA9IGlucHV0LnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgY29uc3QgbGVuID0gaW5wdXQubGVuZ3RoO1xuICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xuICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICBsZXQgb3V0ID0gJyc7XG4gICAgICAgICAgbGV0IHdhc0ZpcnN0ID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICB3YXNGaXJzdCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICghbGVuKSB7XG4gICAgICAgICAgICAgIHRoYXQuX3B1c2goJ1tdJyk7XG5cbiAgICAgICAgICAgICAgdGhhdC51bnZpc2l0KGlucHV0KTtcbiAgICAgICAgICAgICAgdGhhdC5pdGVtID0gcGFyZW50O1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG91dCArPSAnWyc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZW50cnkgPSBpbnB1dFtpXTtcblxuICAgICAgICAgIGlmIChpID09PSBsZW4pIHtcbiAgICAgICAgICAgIGlmICh0aGF0LmluZGVudCkgb3V0ICs9IGBcXG4ke3BhcmVudC5pbmRlbnR9YDtcbiAgICAgICAgICAgIG91dCArPSAnXSc7XG5cbiAgICAgICAgICAgIHRoYXQuX3B1c2gob3V0KTtcblxuICAgICAgICAgICAgdGhhdC5pdGVtID0gcGFyZW50O1xuICAgICAgICAgICAgdGhhdC51bnZpc2l0KGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXdhc0ZpcnN0KSBvdXQgKz0gJywnO1xuICAgICAgICAgIGlmICh0aGF0LmluZGVudCkgb3V0ICs9IGBcXG4ke2l0ZW0uaW5kZW50fWA7XG5cbiAgICAgICAgICB0aGF0Ll9wdXNoKG91dCk7XG5cbiAgICAgICAgICB0aGF0LnNldEl0ZW0oZW50cnksIGl0ZW0sIGkpO1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICB9O1xuICAgICAgdGhpcy5pdGVtID0gaXRlbTtcbiAgICB9XG5cbiAgICB1bnZpc2l0KGl0ZW0pIHtcbiAgICAgIGlmICh0aGlzLmN5Y2xlKSByZXR1cm47XG5cbiAgICAgIGNvbnN0IF9pID0gdGhpcy52aXNpdGVkLmluZGV4T2YoaXRlbSk7XG5cbiAgICAgIGlmIChfaSA+IC0xKSB0aGlzLnZpc2l0ZWQuc3BsaWNlKF9pLCAxKTtcbiAgICB9XG5cbiAgICBzZXRPYmplY3RJdGVtKGlucHV0LCBwYXJlbnQgPSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpbnB1dCk7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgICBjb25zdCB0aGF0ID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaW5jbHVkZVxuICAgICAgfSA9IHRoaXM7XG4gICAgICBsZXQgaGFzSXRlbXMgPSBmYWxzZTtcbiAgICAgIGxldCBrZXk7XG4gICAgICBjb25zdCBpdGVtID0ge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIHZhciBfaW5jbHVkZSRpbmRleE9mO1xuXG4gICAgICAgICAgaWYgKGkgPT09IDApIHRoYXQuX3B1c2goJ3snKTtcblxuICAgICAgICAgIGlmIChpID09PSBsZW4pIHtcbiAgICAgICAgICAgIHRoYXQub2JqZWN0SXRlbSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgaWYgKCFoYXNJdGVtcykge1xuICAgICAgICAgICAgICB0aGF0Ll9wdXNoKCd9Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGF0Ll9wdXNoKGAke3RoYXQuaW5kZW50ID8gYFxcbiR7cGFyZW50LmluZGVudH1gIDogJyd9fWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGF0Lml0ZW0gPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGF0LnVudmlzaXQoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgICBpZiAoKGluY2x1ZGUgPT09IG51bGwgfHwgaW5jbHVkZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9pbmNsdWRlJGluZGV4T2YgPSBpbmNsdWRlLmluZGV4T2YpID09PSBudWxsIHx8IF9pbmNsdWRlJGluZGV4T2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9pbmNsdWRlJGluZGV4T2YuY2FsbChpbmNsdWRlLCBrZXkpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIHJlcGxhY2VyIGFycmF5IGV4Y2x1ZGVzIHRoaXMga2V5XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhhdC5vYmplY3RJdGVtID0gaXRlbTtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgdGhhdC5zZXRJdGVtKGlucHV0W2tleV0sIGl0ZW0sIGtleSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGUoKSB7XG4gICAgICAgICAgY29uc3Qgb3V0ID0gYCR7aGFzSXRlbXMgJiYgIWZpcnN0ID8gJywnIDogJyd9JHtpdGVtLmluZGVudCA/IGBcXG4ke2l0ZW0uaW5kZW50fWAgOiAnJ30ke3F1b3RlU3RyaW5nKGtleSl9OiR7dGhhdC5pbmRlbnQgPyAnICcgOiAnJ31gO1xuICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgaGFzSXRlbXMgPSB0cnVlO1xuICAgICAgICAgIHRoYXQub2JqZWN0SXRlbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgIH07XG4gICAgICB0aGlzLml0ZW0gPSBpdGVtO1xuICAgIH1cblxuICAgIF9wdXNoKGRhdGEpIHtcbiAgICAgIGNvbnN0IG91dCA9ICh0aGlzLm9iamVjdEl0ZW0gPyB0aGlzLm9iamVjdEl0ZW0ud3JpdGUoKSA6ICcnKSArIGRhdGE7XG5cbiAgICAgIGlmICh0aGlzLnByZVB1c2ggJiYgb3V0Lmxlbmd0aCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciArPSB0aGlzLnByZVB1c2g7XG4gICAgICAgIHRoaXMucHJlUHVzaCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5idWZmZXIgKz0gb3V0O1xuXG4gICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID49IHRoaXMuYnVmZmVyU2l6ZSkge1xuICAgICAgICB0aGlzLnB1c2hDYWxsZWQgPSAhdGhpcy5wdXNoKHRoaXMuYnVmZmVyKTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSAnJztcbiAgICAgICAgdGhpcy5idWZmZXJMZW5ndGggPSAwO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGFzeW5jIF9yZWFkKHNpemUpIHtcbiAgICAgIGlmICh0aGlzLnJlYWRTdGF0ZSA9PT0gUmVhZFN0YXRlLkNvbnN1bWVkKSByZXR1cm47XG5cbiAgICAgIGlmICh0aGlzLnJlYWRTdGF0ZSAhPT0gUmVhZFN0YXRlLkluYWN0aXZlKSB7XG4gICAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLlJlYWRNb3JlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLlJlYWRpbmc7XG4gICAgICB0aGlzLnB1c2hDYWxsZWQgPSBmYWxzZTtcbiAgICAgIGxldCBwO1xuXG4gICAgICB3aGlsZSAoIXRoaXMucHVzaENhbGxlZCAmJiB0aGlzLml0ZW0gIT09IHRoaXMucm9vdCAmJiB0aGlzLmJ1ZmZlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHAgPSB0aGlzLml0ZW0ucmVhZChzaXplKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcblxuICAgICAgICBpZiAocCkgYXdhaXQgcDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYnVmZmVyID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgaWYgKHRoaXMuaXRlbSA9PT0gdGhpcy5yb290KSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGgpIHRoaXMucHVzaCh0aGlzLmJ1ZmZlcik7XG4gICAgICAgIHRoaXMucHVzaChudWxsKTtcbiAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuQ29uc3VtZWQ7XG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnJlYWRTdGF0ZSA9PT0gUmVhZFN0YXRlLlJlYWRNb3JlKSB7XG4gICAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLkluYWN0aXZlO1xuICAgICAgICBhd2FpdCB0aGlzLl9yZWFkKHNpemUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLkluYWN0aXZlO1xuICAgIH1cblxuICAgIGNsZWFudXAoKSB7XG4gICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5Db25zdW1lZDtcbiAgICAgIHRoaXMuYnVmZmVyID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy52aXNpdGVkID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5pdGVtID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yb290ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5wcmVQdXNoID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGRlc3Ryb3koZXJyb3IpIHtcbiAgICAgIHZhciBfc3VwZXIkZGVzdHJveTtcblxuICAgICAgaWYgKGVycm9yKSB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgKF9zdXBlciRkZXN0cm95ID0gc3VwZXIuZGVzdHJveSkgPT09IG51bGwgfHwgX3N1cGVyJGRlc3Ryb3kgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdXBlciRkZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICB9XG5cbiAgZXhwb3J0cy5Kc29uU3RyZWFtU3RyaW5naWZ5ID0gSnNvblN0cmVhbVN0cmluZ2lmeTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/json-stream-stringify/lib/umd/index.js\n");

/***/ })

};
;