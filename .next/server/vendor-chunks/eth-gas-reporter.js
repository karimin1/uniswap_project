/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/eth-gas-reporter";
exports.ids = ["vendor-chunks/eth-gas-reporter"];
exports.modules = {

/***/ "(ssr)/./node_modules/eth-gas-reporter/lib/config.js":
/*!*****************************************************!*\
  !*** ./node_modules/eth-gas-reporter/lib/config.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/**\n * Configuration defaults\n */\n\nclass Config {\n  constructor(options = {}) {\n    this.token = options.token || \"ETH\";\n    this.blockLimit = options.blockLimit || 6718946;\n    this.defaultGasPrice = 5;\n\n    this.currency = options.currency || \"eur\";\n    this.gasPriceApi =\n      options.gasPriceApi ||\n      \"https://api.etherscan.io/api?module=proxy&action=eth_gasPrice\";\n    this.coinmarketcap = options.coinmarketcap || null;\n    this.ethPrice = options.ethPrice || null;\n    this.gasPrice = options.gasPrice || null;\n    this.outputFile = options.outputFile || null;\n    this.forceConsoleOutput = options.forceConsoleOutput || false;\n    this.rst = options.rst || false;\n    this.rstTitle = options.rstTitle || \"\";\n    this.showTimeSpent = options.showTimeSpent || false;\n    this.srcPath = options.src || \"contracts\";\n    this.artifactType = options.artifactType || \"truffle-v5\";\n    this.getContracts = options.getContracts || null;\n    this.noColors = options.noColors;\n    this.proxyResolver = options.proxyResolver || null;\n    this.metadata = options.metadata || null;\n    this.showMethodSig = options.showMethodSig || false;\n    this.provider = options.provider || null;\n    this.maxMethodDiff = options.maxMethodDiff;\n    this.maxDeploymentDiff = options.maxDeploymentDiff;\n\n    this.excludeContracts = Array.isArray(options.excludeContracts)\n      ? options.excludeContracts\n      : [];\n\n    this.onlyCalledMethods = options.onlyCalledMethods === false ? false : true;\n\n    this.url = options.url\n      ? this._normalizeUrl(options.url)\n      : this.resolveClientUrl();\n  }\n\n  /**\n   * Tries to obtain the client url reporter's sync-requests will target.\n   * @return {String}         url e.g http://localhost:8545\n   */\n  resolveClientUrl() {\n    // Case: web3 globally available in mocha test context\n    try {\n      if (web3 && web3.currentProvider) {\n        const cp = web3.currentProvider;\n\n        // Truffle/Web3 http\n        if (cp.host) return cp.host;\n\n        // Truffle/Web3 websockets\n        if (cp.connection) return this._normalizeUrl(cp.connection.url);\n      }\n    } catch (err) {\n      // Web3 undefined\n    }\n\n    // Case: Failure\n    const message =\n      `ERROR: eth-gas-reporter was unable to resolve a client url ` +\n      `from the provider available in your test context. Try setting the ` +\n      `url as a mocha reporter option (ex: url='http://localhost:8545')`;\n\n    console.log(message);\n    process.exit(1);\n  }\n\n  /**\n   * Forces websockets to http\n   * @param  {String} url e.g web3.provider.connection.url\n   * @return {String}     http:// prefixed url\n   */\n  _normalizeUrl(url) {\n    return url.replace(\"ws://\", \"http://\");\n  }\n}\n\nmodule.exports = Config;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWdhcy1yZXBvcnRlci9saWIvY29uZmlnLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9ldGgtZ2FzLXJlcG9ydGVyL2xpYi9jb25maWcuanM/MDUxNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbmZpZ3VyYXRpb24gZGVmYXVsdHNcbiAqL1xuXG5jbGFzcyBDb25maWcge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnRva2VuID0gb3B0aW9ucy50b2tlbiB8fCBcIkVUSFwiO1xuICAgIHRoaXMuYmxvY2tMaW1pdCA9IG9wdGlvbnMuYmxvY2tMaW1pdCB8fCA2NzE4OTQ2O1xuICAgIHRoaXMuZGVmYXVsdEdhc1ByaWNlID0gNTtcblxuICAgIHRoaXMuY3VycmVuY3kgPSBvcHRpb25zLmN1cnJlbmN5IHx8IFwiZXVyXCI7XG4gICAgdGhpcy5nYXNQcmljZUFwaSA9XG4gICAgICBvcHRpb25zLmdhc1ByaWNlQXBpIHx8XG4gICAgICBcImh0dHBzOi8vYXBpLmV0aGVyc2Nhbi5pby9hcGk/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfZ2FzUHJpY2VcIjtcbiAgICB0aGlzLmNvaW5tYXJrZXRjYXAgPSBvcHRpb25zLmNvaW5tYXJrZXRjYXAgfHwgbnVsbDtcbiAgICB0aGlzLmV0aFByaWNlID0gb3B0aW9ucy5ldGhQcmljZSB8fCBudWxsO1xuICAgIHRoaXMuZ2FzUHJpY2UgPSBvcHRpb25zLmdhc1ByaWNlIHx8IG51bGw7XG4gICAgdGhpcy5vdXRwdXRGaWxlID0gb3B0aW9ucy5vdXRwdXRGaWxlIHx8IG51bGw7XG4gICAgdGhpcy5mb3JjZUNvbnNvbGVPdXRwdXQgPSBvcHRpb25zLmZvcmNlQ29uc29sZU91dHB1dCB8fCBmYWxzZTtcbiAgICB0aGlzLnJzdCA9IG9wdGlvbnMucnN0IHx8IGZhbHNlO1xuICAgIHRoaXMucnN0VGl0bGUgPSBvcHRpb25zLnJzdFRpdGxlIHx8IFwiXCI7XG4gICAgdGhpcy5zaG93VGltZVNwZW50ID0gb3B0aW9ucy5zaG93VGltZVNwZW50IHx8IGZhbHNlO1xuICAgIHRoaXMuc3JjUGF0aCA9IG9wdGlvbnMuc3JjIHx8IFwiY29udHJhY3RzXCI7XG4gICAgdGhpcy5hcnRpZmFjdFR5cGUgPSBvcHRpb25zLmFydGlmYWN0VHlwZSB8fCBcInRydWZmbGUtdjVcIjtcbiAgICB0aGlzLmdldENvbnRyYWN0cyA9IG9wdGlvbnMuZ2V0Q29udHJhY3RzIHx8IG51bGw7XG4gICAgdGhpcy5ub0NvbG9ycyA9IG9wdGlvbnMubm9Db2xvcnM7XG4gICAgdGhpcy5wcm94eVJlc29sdmVyID0gb3B0aW9ucy5wcm94eVJlc29sdmVyIHx8IG51bGw7XG4gICAgdGhpcy5tZXRhZGF0YSA9IG9wdGlvbnMubWV0YWRhdGEgfHwgbnVsbDtcbiAgICB0aGlzLnNob3dNZXRob2RTaWcgPSBvcHRpb25zLnNob3dNZXRob2RTaWcgfHwgZmFsc2U7XG4gICAgdGhpcy5wcm92aWRlciA9IG9wdGlvbnMucHJvdmlkZXIgfHwgbnVsbDtcbiAgICB0aGlzLm1heE1ldGhvZERpZmYgPSBvcHRpb25zLm1heE1ldGhvZERpZmY7XG4gICAgdGhpcy5tYXhEZXBsb3ltZW50RGlmZiA9IG9wdGlvbnMubWF4RGVwbG95bWVudERpZmY7XG5cbiAgICB0aGlzLmV4Y2x1ZGVDb250cmFjdHMgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMuZXhjbHVkZUNvbnRyYWN0cylcbiAgICAgID8gb3B0aW9ucy5leGNsdWRlQ29udHJhY3RzXG4gICAgICA6IFtdO1xuXG4gICAgdGhpcy5vbmx5Q2FsbGVkTWV0aG9kcyA9IG9wdGlvbnMub25seUNhbGxlZE1ldGhvZHMgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xuXG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybFxuICAgICAgPyB0aGlzLl9ub3JtYWxpemVVcmwob3B0aW9ucy51cmwpXG4gICAgICA6IHRoaXMucmVzb2x2ZUNsaWVudFVybCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWVzIHRvIG9idGFpbiB0aGUgY2xpZW50IHVybCByZXBvcnRlcidzIHN5bmMtcmVxdWVzdHMgd2lsbCB0YXJnZXQuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICB1cmwgZS5nIGh0dHA6Ly9sb2NhbGhvc3Q6ODU0NVxuICAgKi9cbiAgcmVzb2x2ZUNsaWVudFVybCgpIHtcbiAgICAvLyBDYXNlOiB3ZWIzIGdsb2JhbGx5IGF2YWlsYWJsZSBpbiBtb2NoYSB0ZXN0IGNvbnRleHRcbiAgICB0cnkge1xuICAgICAgaWYgKHdlYjMgJiYgd2ViMy5jdXJyZW50UHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgY3AgPSB3ZWIzLmN1cnJlbnRQcm92aWRlcjtcblxuICAgICAgICAvLyBUcnVmZmxlL1dlYjMgaHR0cFxuICAgICAgICBpZiAoY3AuaG9zdCkgcmV0dXJuIGNwLmhvc3Q7XG5cbiAgICAgICAgLy8gVHJ1ZmZsZS9XZWIzIHdlYnNvY2tldHNcbiAgICAgICAgaWYgKGNwLmNvbm5lY3Rpb24pIHJldHVybiB0aGlzLl9ub3JtYWxpemVVcmwoY3AuY29ubmVjdGlvbi51cmwpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gV2ViMyB1bmRlZmluZWRcbiAgICB9XG5cbiAgICAvLyBDYXNlOiBGYWlsdXJlXG4gICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICBgRVJST1I6IGV0aC1nYXMtcmVwb3J0ZXIgd2FzIHVuYWJsZSB0byByZXNvbHZlIGEgY2xpZW50IHVybCBgICtcbiAgICAgIGBmcm9tIHRoZSBwcm92aWRlciBhdmFpbGFibGUgaW4geW91ciB0ZXN0IGNvbnRleHQuIFRyeSBzZXR0aW5nIHRoZSBgICtcbiAgICAgIGB1cmwgYXMgYSBtb2NoYSByZXBvcnRlciBvcHRpb24gKGV4OiB1cmw9J2h0dHA6Ly9sb2NhbGhvc3Q6ODU0NScpYDtcblxuICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZXMgd2Vic29ja2V0cyB0byBodHRwXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdXJsIGUuZyB3ZWIzLnByb3ZpZGVyLmNvbm5lY3Rpb24udXJsXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgIGh0dHA6Ly8gcHJlZml4ZWQgdXJsXG4gICAqL1xuICBfbm9ybWFsaXplVXJsKHVybCkge1xuICAgIHJldHVybiB1cmwucmVwbGFjZShcIndzOi8vXCIsIFwiaHR0cDovL1wiKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbmZpZztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-gas-reporter/lib/config.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-gas-reporter/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/eth-gas-reporter/lib/utils.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const fs = __webpack_require__(/*! fs */ \"fs\");\nconst parser = __webpack_require__(/*! @solidity-parser/parser */ \"(ssr)/./node_modules/eth-gas-reporter/node_modules/@solidity-parser/parser/dist/index.cjs.js\");\nconst axios = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/dist/node/axios.cjs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst read = __webpack_require__(/*! fs-readdir-recursive */ \"(ssr)/./node_modules/fs-readdir-recursive/index.js\");\nconst colors = __webpack_require__(/*! colors/safe */ \"(ssr)/./node_modules/colors/safe.js\");\nconst log = console.log;\n\nconst utils = {\n  /**\n   * Expresses gas usage as a nation-state currency price\n   * @param  {Number} gas      gas used\n   * @param  {Number} ethPrice e.g chf/eth\n   * @param  {Number} gasPrice in wei e.g 5000000000 (5 gwei)\n   * @return {Number}          cost of gas used (0.00)\n   */\n  gasToCost: function(gas, ethPrice, gasPrice) {\n    ethPrice = parseFloat(ethPrice);\n    gasPrice = parseInt(gasPrice);\n    return ((gasPrice / 1e9) * gas * ethPrice).toFixed(2);\n  },\n\n  /**\n   * Expresses gas usage as a % of the block gasLimit. Source: NeuFund (see issues)\n   * @param  {Number} gasUsed    gas value\n   * @param  {Number} blockLimit gas limit of a block\n   * @return {Number}            percent (0.0)\n   */\n  gasToPercentOfLimit: function(gasUsed, blockLimit) {\n    return Math.round((1000 * gasUsed) / blockLimit) / 10;\n  },\n\n  /**\n   * Generates id for a GasData.methods entry from the input of a web3.eth.getTransaction\n   * and a contract name\n   * @param  {String} code hex data\n   * @return {String}      id\n   */\n  getMethodID: function(contractName, code) {\n    return contractName + \"_\" + code.slice(2, 10);\n  },\n\n  /**\n   * Extracts solc settings and version info from solidity metadata\n   * @param  {Object} metadata solidity metadata\n   * @return {Object}          {version, optimizer, runs}\n   */\n  getSolcInfo: function(metadata) {\n    const missing = \"----\";\n    const info = {\n      version: missing,\n      optimizer: missing,\n      runs: missing\n    };\n    if (metadata) {\n      info.version = metadata.compiler.version;\n      info.optimizer = metadata.settings.optimizer.enabled;\n      info.runs = metadata.settings.optimizer.runs;\n    }\n    return info;\n  },\n\n  /**\n   * Return true if transaction input and bytecode are same, ignoring library link code.\n   * @param  {String} code\n   * @return {Bool}\n   */\n  matchBinaries: function(input, bytecode) {\n    const regExp = utils.bytecodeToBytecodeRegex(bytecode);\n    return input.match(regExp) !== null;\n  },\n\n  /**\n   * Generate a regular expression string which is library link agnostic so we can match\n   * linked bytecode deployment transaction inputs to the evm.bytecode solc output.\n   * @param  {String} bytecode\n   * @return {String}\n   */\n  bytecodeToBytecodeRegex: function(bytecode = \"\") {\n    const bytecodeRegex = bytecode\n      .replace(/__.{38}/g, \".{40}\")\n      .replace(/73f{40}/g, \".{42}\");\n\n    // HACK: Node regexes can't be longer that 32767 characters.\n    // Contracts bytecode can. We just truncate the regexes. It's safe in practice.\n    const MAX_REGEX_LENGTH = 32767;\n    const truncatedBytecodeRegex = bytecodeRegex.slice(0, MAX_REGEX_LENGTH);\n    return truncatedBytecodeRegex;\n  },\n\n  /**\n   * Parses files for contract names\n   * @param  {String} filePath path to file\n   * @return {String[]}        contract names\n   */\n  getContractNames: function(filePath) {\n    const names = [];\n    const code = fs.readFileSync(filePath, \"utf-8\");\n\n    let ast;\n    try {\n      ast = parser.parse(code, { tolerant: true });\n    } catch (err) {\n      utils.warnParser(filePath, err);\n      return names;\n    }\n\n    parser.visit(ast, {\n      ContractDefinition: function(node) {\n        names.push(node.name);\n      }\n    });\n\n    return names;\n  },\n\n  /**\n   * Message for un-parseable files\n   * @param  {String} filePath\n   * @param  {Error} err\n   * @return {void}\n   */\n  warnParser: function(filePath, err) {\n    log();\n    log(colors.red(`>>>>> WARNING <<<<<<`));\n    log(\n      `Failed to parse file: \"${filePath}\". No data will collected for its contract(s).`\n    );\n    log(\n      `NB: some Solidity 0.6.x syntax is not supported by the JS parser yet.`\n    );\n    log(\n      `Please report the error below to github.com/consensys/solidity-parser-antlr`\n    );\n    log(colors.red(`>>>>>>>>>>>>>>>>>>>>`));\n    log(colors.red(`${err}`));\n    log();\n  },\n\n  /**\n   * Message for un-parseable ABI (ethers)\n   * @param  {String} name contract name\n   * @param  {Error} err\n   * @return {void}\n   */\n  warnEthers: function(name, err) {\n    log();\n    log(colors.red(`>>>>> WARNING <<<<<<`));\n    log(\n      `Failed to parse ABI for contract: \"${name}\". (Its method data will not be collected).`\n    );\n    log(\n      `NB: Some Solidity 0.6.x syntax is not supported by Ethers.js V5 AbiCoder yet.`\n    );\n    log(`Please report the error below to github.com/ethers-io/ethers.js`);\n    log(colors.red(`>>>>>>>>>>>>>>>>>>>>`));\n    log(colors.red(`${err}`));\n    log();\n  },\n\n  /**\n   * Converts hex gas to decimal\n   * @param  {Number} val hex gas returned by RPC\n   * @return {Number}     decimal gas consumed by human eyes.\n   */\n  gas: function(val) {\n    return parseInt(val, 16);\n  },\n\n  /**\n   * Fetches gasPrices from ethgasstation (defaults to the lowest safe gas price)\n   * and current market value of eth in currency specified by the config from\n   * coinmarketcap (defaults to euros). Sets config.ethPrice, config.gasPrice unless these\n   * are already set as constants in the reporter options\n   * @param  {Object} config\n   */\n  setGasAndPriceRates: async function(config) {\n    if ((config.ethPrice && config.gasPrice) || !config.coinmarketcap) return;\n\n    const token = config.token.toUpperCase();\n    const gasPriceApi = config.gasPriceApi;\n\n    const axiosInstance = axios.create({\n      baseURL: `https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/`\n    });\n\n    const requestArgs = `latest?symbol=${token}&CMC_PRO_API_KEY=${\n      config.coinmarketcap\n    }&convert=`;\n\n    const currencyKey = config.currency.toUpperCase();\n    const currencyPath = `${requestArgs}${currencyKey}`;\n\n    // Currency market data: coinmarketcap\n    if (!config.ethPrice) {\n      try {\n        let response = await axiosInstance.get(currencyPath);\n        config.ethPrice = response.data.data[token].quote[\n          currencyKey\n        ].price.toFixed(2);\n      } catch (error) {\n        config.ethPrice = null;\n      }\n    }\n\n    // Gas price data: etherscan (or `gasPriceAPI`)\n    if (!config.gasPrice) {\n      try {\n        let response = await axiosInstance.get(gasPriceApi);\n        config.gasPrice = Math.round(\n          parseInt(response.data.result, 16) / Math.pow(10, 9)\n        );\n      } catch (error) {\n        config.gasPrice = config.defaultGasPrice;\n      }\n    }\n  },\n\n  listSolidityFiles(srcPath) {\n    let base = `./${srcPath}/`;\n\n    if (process.platform === \"win32\") {\n      base = base.replace(/\\\\/g, \"/\");\n    }\n\n    const paths = read(base)\n      .filter(file => path.extname(file) === \".sol\")\n      .map(file => base + file);\n\n    return paths;\n  },\n\n  /**\n   * Loads and parses Solidity files, returning a filtered array of contract names.\n   * @return {string[]}\n   */\n  parseSoliditySources(config) {\n    const names = [];\n    const files = utils.listSolidityFiles(config.srcPath);\n    files.forEach(file => {\n      const namesForFile = utils.getContractNames(file);\n      const filtered = namesForFile.filter(\n        name => !config.excludeContracts.includes(name)\n      );\n      filtered.forEach(item => names.push(item));\n    });\n    return names;\n  },\n\n  // Debugging helper\n  pretty: function(msg, obj) {\n    console.log(`<------ ${msg} ------>\\n` + JSON.stringify(obj, null, \" \"));\n    console.log(`<------- END -------->\\n`);\n  }\n};\n\nmodule.exports = utils;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWdhcy1yZXBvcnRlci9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUEsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsZUFBZSxtQkFBTyxDQUFDLDZIQUF5QjtBQUNoRCxjQUFjLG1CQUFPLENBQUMsNkRBQU87QUFDN0IsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGFBQWEsbUJBQU8sQ0FBQyxnRkFBc0I7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLHdEQUFhO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEdBQUcsT0FBTyxHQUFHO0FBQ2pDLG9CQUFvQixHQUFHLE9BQU8sR0FBRzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLE9BQU87QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUk7QUFDMUI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxPQUFPO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEtBQUs7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUk7QUFDMUI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCx5Q0FBeUMsTUFBTTtBQUMvQztBQUNBLEtBQUs7O0FBRUw7QUFDQSw0QkFBNEIsWUFBWSxFQUFFLFlBQVk7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esb0JBQW9CLFFBQVE7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSztBQUNoQztBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL2V0aC1nYXMtcmVwb3J0ZXIvbGliL3V0aWxzLmpzPzVkOTUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBwYXJzZXIgPSByZXF1aXJlKFwiQHNvbGlkaXR5LXBhcnNlci9wYXJzZXJcIik7XG5jb25zdCBheGlvcyA9IHJlcXVpcmUoXCJheGlvc1wiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IHJlYWQgPSByZXF1aXJlKFwiZnMtcmVhZGRpci1yZWN1cnNpdmVcIik7XG5jb25zdCBjb2xvcnMgPSByZXF1aXJlKFwiY29sb3JzL3NhZmVcIik7XG5jb25zdCBsb2cgPSBjb25zb2xlLmxvZztcblxuY29uc3QgdXRpbHMgPSB7XG4gIC8qKlxuICAgKiBFeHByZXNzZXMgZ2FzIHVzYWdlIGFzIGEgbmF0aW9uLXN0YXRlIGN1cnJlbmN5IHByaWNlXG4gICAqIEBwYXJhbSAge051bWJlcn0gZ2FzICAgICAgZ2FzIHVzZWRcbiAgICogQHBhcmFtICB7TnVtYmVyfSBldGhQcmljZSBlLmcgY2hmL2V0aFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGdhc1ByaWNlIGluIHdlaSBlLmcgNTAwMDAwMDAwMCAoNSBnd2VpKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgIGNvc3Qgb2YgZ2FzIHVzZWQgKDAuMDApXG4gICAqL1xuICBnYXNUb0Nvc3Q6IGZ1bmN0aW9uKGdhcywgZXRoUHJpY2UsIGdhc1ByaWNlKSB7XG4gICAgZXRoUHJpY2UgPSBwYXJzZUZsb2F0KGV0aFByaWNlKTtcbiAgICBnYXNQcmljZSA9IHBhcnNlSW50KGdhc1ByaWNlKTtcbiAgICByZXR1cm4gKChnYXNQcmljZSAvIDFlOSkgKiBnYXMgKiBldGhQcmljZSkudG9GaXhlZCgyKTtcbiAgfSxcblxuICAvKipcbiAgICogRXhwcmVzc2VzIGdhcyB1c2FnZSBhcyBhICUgb2YgdGhlIGJsb2NrIGdhc0xpbWl0LiBTb3VyY2U6IE5ldUZ1bmQgKHNlZSBpc3N1ZXMpXG4gICAqIEBwYXJhbSAge051bWJlcn0gZ2FzVXNlZCAgICBnYXMgdmFsdWVcbiAgICogQHBhcmFtICB7TnVtYmVyfSBibG9ja0xpbWl0IGdhcyBsaW1pdCBvZiBhIGJsb2NrXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICBwZXJjZW50ICgwLjApXG4gICAqL1xuICBnYXNUb1BlcmNlbnRPZkxpbWl0OiBmdW5jdGlvbihnYXNVc2VkLCBibG9ja0xpbWl0KSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoKDEwMDAgKiBnYXNVc2VkKSAvIGJsb2NrTGltaXQpIC8gMTA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBpZCBmb3IgYSBHYXNEYXRhLm1ldGhvZHMgZW50cnkgZnJvbSB0aGUgaW5wdXQgb2YgYSB3ZWIzLmV0aC5nZXRUcmFuc2FjdGlvblxuICAgKiBhbmQgYSBjb250cmFjdCBuYW1lXG4gICAqIEBwYXJhbSAge1N0cmluZ30gY29kZSBoZXggZGF0YVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgaWRcbiAgICovXG4gIGdldE1ldGhvZElEOiBmdW5jdGlvbihjb250cmFjdE5hbWUsIGNvZGUpIHtcbiAgICByZXR1cm4gY29udHJhY3ROYW1lICsgXCJfXCIgKyBjb2RlLnNsaWNlKDIsIDEwKTtcbiAgfSxcblxuICAvKipcbiAgICogRXh0cmFjdHMgc29sYyBzZXR0aW5ncyBhbmQgdmVyc2lvbiBpbmZvIGZyb20gc29saWRpdHkgbWV0YWRhdGFcbiAgICogQHBhcmFtICB7T2JqZWN0fSBtZXRhZGF0YSBzb2xpZGl0eSBtZXRhZGF0YVxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgIHt2ZXJzaW9uLCBvcHRpbWl6ZXIsIHJ1bnN9XG4gICAqL1xuICBnZXRTb2xjSW5mbzogZnVuY3Rpb24obWV0YWRhdGEpIHtcbiAgICBjb25zdCBtaXNzaW5nID0gXCItLS0tXCI7XG4gICAgY29uc3QgaW5mbyA9IHtcbiAgICAgIHZlcnNpb246IG1pc3NpbmcsXG4gICAgICBvcHRpbWl6ZXI6IG1pc3NpbmcsXG4gICAgICBydW5zOiBtaXNzaW5nXG4gICAgfTtcbiAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgIGluZm8udmVyc2lvbiA9IG1ldGFkYXRhLmNvbXBpbGVyLnZlcnNpb247XG4gICAgICBpbmZvLm9wdGltaXplciA9IG1ldGFkYXRhLnNldHRpbmdzLm9wdGltaXplci5lbmFibGVkO1xuICAgICAgaW5mby5ydW5zID0gbWV0YWRhdGEuc2V0dGluZ3Mub3B0aW1pemVyLnJ1bnM7XG4gICAgfVxuICAgIHJldHVybiBpbmZvO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0cmFuc2FjdGlvbiBpbnB1dCBhbmQgYnl0ZWNvZGUgYXJlIHNhbWUsIGlnbm9yaW5nIGxpYnJhcnkgbGluayBjb2RlLlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGNvZGVcbiAgICogQHJldHVybiB7Qm9vbH1cbiAgICovXG4gIG1hdGNoQmluYXJpZXM6IGZ1bmN0aW9uKGlucHV0LCBieXRlY29kZSkge1xuICAgIGNvbnN0IHJlZ0V4cCA9IHV0aWxzLmJ5dGVjb2RlVG9CeXRlY29kZVJlZ2V4KGJ5dGVjb2RlKTtcbiAgICByZXR1cm4gaW5wdXQubWF0Y2gocmVnRXhwKSAhPT0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2VuZXJhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nIHdoaWNoIGlzIGxpYnJhcnkgbGluayBhZ25vc3RpYyBzbyB3ZSBjYW4gbWF0Y2hcbiAgICogbGlua2VkIGJ5dGVjb2RlIGRlcGxveW1lbnQgdHJhbnNhY3Rpb24gaW5wdXRzIHRvIHRoZSBldm0uYnl0ZWNvZGUgc29sYyBvdXRwdXQuXG4gICAqIEBwYXJhbSAge1N0cmluZ30gYnl0ZWNvZGVcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgYnl0ZWNvZGVUb0J5dGVjb2RlUmVnZXg6IGZ1bmN0aW9uKGJ5dGVjb2RlID0gXCJcIikge1xuICAgIGNvbnN0IGJ5dGVjb2RlUmVnZXggPSBieXRlY29kZVxuICAgICAgLnJlcGxhY2UoL19fLnszOH0vZywgXCIuezQwfVwiKVxuICAgICAgLnJlcGxhY2UoLzczZns0MH0vZywgXCIuezQyfVwiKTtcblxuICAgIC8vIEhBQ0s6IE5vZGUgcmVnZXhlcyBjYW4ndCBiZSBsb25nZXIgdGhhdCAzMjc2NyBjaGFyYWN0ZXJzLlxuICAgIC8vIENvbnRyYWN0cyBieXRlY29kZSBjYW4uIFdlIGp1c3QgdHJ1bmNhdGUgdGhlIHJlZ2V4ZXMuIEl0J3Mgc2FmZSBpbiBwcmFjdGljZS5cbiAgICBjb25zdCBNQVhfUkVHRVhfTEVOR1RIID0gMzI3Njc7XG4gICAgY29uc3QgdHJ1bmNhdGVkQnl0ZWNvZGVSZWdleCA9IGJ5dGVjb2RlUmVnZXguc2xpY2UoMCwgTUFYX1JFR0VYX0xFTkdUSCk7XG4gICAgcmV0dXJuIHRydW5jYXRlZEJ5dGVjb2RlUmVnZXg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBhcnNlcyBmaWxlcyBmb3IgY29udHJhY3QgbmFtZXNcbiAgICogQHBhcmFtICB7U3RyaW5nfSBmaWxlUGF0aCBwYXRoIHRvIGZpbGVcbiAgICogQHJldHVybiB7U3RyaW5nW119ICAgICAgICBjb250cmFjdCBuYW1lc1xuICAgKi9cbiAgZ2V0Q29udHJhY3ROYW1lczogZnVuY3Rpb24oZmlsZVBhdGgpIHtcbiAgICBjb25zdCBuYW1lcyA9IFtdO1xuICAgIGNvbnN0IGNvZGUgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsIFwidXRmLThcIik7XG5cbiAgICBsZXQgYXN0O1xuICAgIHRyeSB7XG4gICAgICBhc3QgPSBwYXJzZXIucGFyc2UoY29kZSwgeyB0b2xlcmFudDogdHJ1ZSB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHV0aWxzLndhcm5QYXJzZXIoZmlsZVBhdGgsIGVycik7XG4gICAgICByZXR1cm4gbmFtZXM7XG4gICAgfVxuXG4gICAgcGFyc2VyLnZpc2l0KGFzdCwge1xuICAgICAgQ29udHJhY3REZWZpbml0aW9uOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIG5hbWVzLnB1c2gobm9kZS5uYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBuYW1lcztcbiAgfSxcblxuICAvKipcbiAgICogTWVzc2FnZSBmb3IgdW4tcGFyc2VhYmxlIGZpbGVzXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZmlsZVBhdGhcbiAgICogQHBhcmFtICB7RXJyb3J9IGVyclxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgd2FyblBhcnNlcjogZnVuY3Rpb24oZmlsZVBhdGgsIGVycikge1xuICAgIGxvZygpO1xuICAgIGxvZyhjb2xvcnMucmVkKGA+Pj4+PiBXQVJOSU5HIDw8PDw8PGApKTtcbiAgICBsb2coXG4gICAgICBgRmFpbGVkIHRvIHBhcnNlIGZpbGU6IFwiJHtmaWxlUGF0aH1cIi4gTm8gZGF0YSB3aWxsIGNvbGxlY3RlZCBmb3IgaXRzIGNvbnRyYWN0KHMpLmBcbiAgICApO1xuICAgIGxvZyhcbiAgICAgIGBOQjogc29tZSBTb2xpZGl0eSAwLjYueCBzeW50YXggaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgSlMgcGFyc2VyIHlldC5gXG4gICAgKTtcbiAgICBsb2coXG4gICAgICBgUGxlYXNlIHJlcG9ydCB0aGUgZXJyb3IgYmVsb3cgdG8gZ2l0aHViLmNvbS9jb25zZW5zeXMvc29saWRpdHktcGFyc2VyLWFudGxyYFxuICAgICk7XG4gICAgbG9nKGNvbG9ycy5yZWQoYD4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+YCkpO1xuICAgIGxvZyhjb2xvcnMucmVkKGAke2Vycn1gKSk7XG4gICAgbG9nKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1lc3NhZ2UgZm9yIHVuLXBhcnNlYWJsZSBBQkkgKGV0aGVycylcbiAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIGNvbnRyYWN0IG5hbWVcbiAgICogQHBhcmFtICB7RXJyb3J9IGVyclxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgd2FybkV0aGVyczogZnVuY3Rpb24obmFtZSwgZXJyKSB7XG4gICAgbG9nKCk7XG4gICAgbG9nKGNvbG9ycy5yZWQoYD4+Pj4+IFdBUk5JTkcgPDw8PDw8YCkpO1xuICAgIGxvZyhcbiAgICAgIGBGYWlsZWQgdG8gcGFyc2UgQUJJIGZvciBjb250cmFjdDogXCIke25hbWV9XCIuIChJdHMgbWV0aG9kIGRhdGEgd2lsbCBub3QgYmUgY29sbGVjdGVkKS5gXG4gICAgKTtcbiAgICBsb2coXG4gICAgICBgTkI6IFNvbWUgU29saWRpdHkgMC42Lnggc3ludGF4IGlzIG5vdCBzdXBwb3J0ZWQgYnkgRXRoZXJzLmpzIFY1IEFiaUNvZGVyIHlldC5gXG4gICAgKTtcbiAgICBsb2coYFBsZWFzZSByZXBvcnQgdGhlIGVycm9yIGJlbG93IHRvIGdpdGh1Yi5jb20vZXRoZXJzLWlvL2V0aGVycy5qc2ApO1xuICAgIGxvZyhjb2xvcnMucmVkKGA+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+PmApKTtcbiAgICBsb2coY29sb3JzLnJlZChgJHtlcnJ9YCkpO1xuICAgIGxvZygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBoZXggZ2FzIHRvIGRlY2ltYWxcbiAgICogQHBhcmFtICB7TnVtYmVyfSB2YWwgaGV4IGdhcyByZXR1cm5lZCBieSBSUENcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgZGVjaW1hbCBnYXMgY29uc3VtZWQgYnkgaHVtYW4gZXllcy5cbiAgICovXG4gIGdhczogZnVuY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTYpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIGdhc1ByaWNlcyBmcm9tIGV0aGdhc3N0YXRpb24gKGRlZmF1bHRzIHRvIHRoZSBsb3dlc3Qgc2FmZSBnYXMgcHJpY2UpXG4gICAqIGFuZCBjdXJyZW50IG1hcmtldCB2YWx1ZSBvZiBldGggaW4gY3VycmVuY3kgc3BlY2lmaWVkIGJ5IHRoZSBjb25maWcgZnJvbVxuICAgKiBjb2lubWFya2V0Y2FwIChkZWZhdWx0cyB0byBldXJvcykuIFNldHMgY29uZmlnLmV0aFByaWNlLCBjb25maWcuZ2FzUHJpY2UgdW5sZXNzIHRoZXNlXG4gICAqIGFyZSBhbHJlYWR5IHNldCBhcyBjb25zdGFudHMgaW4gdGhlIHJlcG9ydGVyIG9wdGlvbnNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjb25maWdcbiAgICovXG4gIHNldEdhc0FuZFByaWNlUmF0ZXM6IGFzeW5jIGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIGlmICgoY29uZmlnLmV0aFByaWNlICYmIGNvbmZpZy5nYXNQcmljZSkgfHwgIWNvbmZpZy5jb2lubWFya2V0Y2FwKSByZXR1cm47XG5cbiAgICBjb25zdCB0b2tlbiA9IGNvbmZpZy50b2tlbi50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IGdhc1ByaWNlQXBpID0gY29uZmlnLmdhc1ByaWNlQXBpO1xuXG4gICAgY29uc3QgYXhpb3NJbnN0YW5jZSA9IGF4aW9zLmNyZWF0ZSh7XG4gICAgICBiYXNlVVJMOiBgaHR0cHM6Ly9wcm8tYXBpLmNvaW5tYXJrZXRjYXAuY29tL3YxL2NyeXB0b2N1cnJlbmN5L3F1b3Rlcy9gXG4gICAgfSk7XG5cbiAgICBjb25zdCByZXF1ZXN0QXJncyA9IGBsYXRlc3Q/c3ltYm9sPSR7dG9rZW59JkNNQ19QUk9fQVBJX0tFWT0ke1xuICAgICAgY29uZmlnLmNvaW5tYXJrZXRjYXBcbiAgICB9JmNvbnZlcnQ9YDtcblxuICAgIGNvbnN0IGN1cnJlbmN5S2V5ID0gY29uZmlnLmN1cnJlbmN5LnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgY3VycmVuY3lQYXRoID0gYCR7cmVxdWVzdEFyZ3N9JHtjdXJyZW5jeUtleX1gO1xuXG4gICAgLy8gQ3VycmVuY3kgbWFya2V0IGRhdGE6IGNvaW5tYXJrZXRjYXBcbiAgICBpZiAoIWNvbmZpZy5ldGhQcmljZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3NJbnN0YW5jZS5nZXQoY3VycmVuY3lQYXRoKTtcbiAgICAgICAgY29uZmlnLmV0aFByaWNlID0gcmVzcG9uc2UuZGF0YS5kYXRhW3Rva2VuXS5xdW90ZVtcbiAgICAgICAgICBjdXJyZW5jeUtleVxuICAgICAgICBdLnByaWNlLnRvRml4ZWQoMik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25maWcuZXRoUHJpY2UgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdhcyBwcmljZSBkYXRhOiBldGhlcnNjYW4gKG9yIGBnYXNQcmljZUFQSWApXG4gICAgaWYgKCFjb25maWcuZ2FzUHJpY2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGF4aW9zSW5zdGFuY2UuZ2V0KGdhc1ByaWNlQXBpKTtcbiAgICAgICAgY29uZmlnLmdhc1ByaWNlID0gTWF0aC5yb3VuZChcbiAgICAgICAgICBwYXJzZUludChyZXNwb25zZS5kYXRhLnJlc3VsdCwgMTYpIC8gTWF0aC5wb3coMTAsIDkpXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25maWcuZ2FzUHJpY2UgPSBjb25maWcuZGVmYXVsdEdhc1ByaWNlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBsaXN0U29saWRpdHlGaWxlcyhzcmNQYXRoKSB7XG4gICAgbGV0IGJhc2UgPSBgLi8ke3NyY1BhdGh9L2A7XG5cbiAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgICBiYXNlID0gYmFzZS5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXRocyA9IHJlYWQoYmFzZSlcbiAgICAgIC5maWx0ZXIoZmlsZSA9PiBwYXRoLmV4dG5hbWUoZmlsZSkgPT09IFwiLnNvbFwiKVxuICAgICAgLm1hcChmaWxlID0+IGJhc2UgKyBmaWxlKTtcblxuICAgIHJldHVybiBwYXRocztcbiAgfSxcblxuICAvKipcbiAgICogTG9hZHMgYW5kIHBhcnNlcyBTb2xpZGl0eSBmaWxlcywgcmV0dXJuaW5nIGEgZmlsdGVyZWQgYXJyYXkgb2YgY29udHJhY3QgbmFtZXMuXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdfVxuICAgKi9cbiAgcGFyc2VTb2xpZGl0eVNvdXJjZXMoY29uZmlnKSB7XG4gICAgY29uc3QgbmFtZXMgPSBbXTtcbiAgICBjb25zdCBmaWxlcyA9IHV0aWxzLmxpc3RTb2xpZGl0eUZpbGVzKGNvbmZpZy5zcmNQYXRoKTtcbiAgICBmaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgY29uc3QgbmFtZXNGb3JGaWxlID0gdXRpbHMuZ2V0Q29udHJhY3ROYW1lcyhmaWxlKTtcbiAgICAgIGNvbnN0IGZpbHRlcmVkID0gbmFtZXNGb3JGaWxlLmZpbHRlcihcbiAgICAgICAgbmFtZSA9PiAhY29uZmlnLmV4Y2x1ZGVDb250cmFjdHMuaW5jbHVkZXMobmFtZSlcbiAgICAgICk7XG4gICAgICBmaWx0ZXJlZC5mb3JFYWNoKGl0ZW0gPT4gbmFtZXMucHVzaChpdGVtKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5hbWVzO1xuICB9LFxuXG4gIC8vIERlYnVnZ2luZyBoZWxwZXJcbiAgcHJldHR5OiBmdW5jdGlvbihtc2csIG9iaikge1xuICAgIGNvbnNvbGUubG9nKGA8LS0tLS0tICR7bXNnfSAtLS0tLS0+XFxuYCArIEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgXCIgXCIpKTtcbiAgICBjb25zb2xlLmxvZyhgPC0tLS0tLS0gRU5EIC0tLS0tLS0tPlxcbmApO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWxzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-gas-reporter/lib/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-gas-reporter/node_modules/@solidity-parser/parser/dist/index.cjs.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/eth-gas-reporter/node_modules/@solidity-parser/parser/dist/index.cjs.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;\nvar __objSpread = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", {value: true});\nvar __commonJS = (cb, mod) => () => (mod || cb((mod = {exports: {}}).exports, mod), mod.exports);\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, {get: all[name], enumerable: true});\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);\n};\n\n// node_modules/antlr4ts/ANTLRErrorListener.js\nvar require_ANTLRErrorListener = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n});\n\n// node_modules/antlr4ts/ANTLRErrorStrategy.js\nvar require_ANTLRErrorStrategy = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n});\n\n// node_modules/antlr4ts/Decorators.js\nvar require_Decorators = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.SuppressWarnings = exports.Override = exports.Nullable = exports.NotNull = void 0;\n  function NotNull(target, propertyKey, propertyDescriptor) {\n  }\n  exports.NotNull = NotNull;\n  function Nullable(target, propertyKey, propertyDescriptor) {\n  }\n  exports.Nullable = Nullable;\n  function Override(target, propertyKey, propertyDescriptor) {\n  }\n  exports.Override = Override;\n  function SuppressWarnings(options) {\n    return (target, propertyKey, descriptor) => {\n    };\n  }\n  exports.SuppressWarnings = SuppressWarnings;\n});\n\n// node_modules/antlr4ts/IntStream.js\nvar require_IntStream = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.IntStream = void 0;\n  var IntStream;\n  (function(IntStream2) {\n    IntStream2.EOF = -1;\n    IntStream2.UNKNOWN_SOURCE_NAME = \"<unknown>\";\n  })(IntStream = exports.IntStream || (exports.IntStream = {}));\n});\n\n// node_modules/antlr4ts/ANTLRInputStream.js\nvar require_ANTLRInputStream = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ANTLRInputStream = void 0;\n  var assert = __webpack_require__(/*! assert */ \"assert\");\n  var Decorators_1 = require_Decorators();\n  var IntStream_1 = require_IntStream();\n  var ANTLRInputStream2 = class {\n    constructor(input) {\n      this.p = 0;\n      this.data = input;\n      this.n = input.length;\n    }\n    reset() {\n      this.p = 0;\n    }\n    consume() {\n      if (this.p >= this.n) {\n        assert(this.LA(1) === IntStream_1.IntStream.EOF);\n        throw new Error(\"cannot consume EOF\");\n      }\n      if (this.p < this.n) {\n        this.p++;\n      }\n    }\n    LA(i) {\n      if (i === 0) {\n        return 0;\n      }\n      if (i < 0) {\n        i++;\n        if (this.p + i - 1 < 0) {\n          return IntStream_1.IntStream.EOF;\n        }\n      }\n      if (this.p + i - 1 >= this.n) {\n        return IntStream_1.IntStream.EOF;\n      }\n      return this.data.charCodeAt(this.p + i - 1);\n    }\n    LT(i) {\n      return this.LA(i);\n    }\n    get index() {\n      return this.p;\n    }\n    get size() {\n      return this.n;\n    }\n    mark() {\n      return -1;\n    }\n    release(marker) {\n    }\n    seek(index) {\n      if (index <= this.p) {\n        this.p = index;\n        return;\n      }\n      index = Math.min(index, this.n);\n      while (this.p < index) {\n        this.consume();\n      }\n    }\n    getText(interval) {\n      let start = interval.a;\n      let stop = interval.b;\n      if (stop >= this.n) {\n        stop = this.n - 1;\n      }\n      let count = stop - start + 1;\n      if (start >= this.n) {\n        return \"\";\n      }\n      return this.data.substr(start, count);\n    }\n    get sourceName() {\n      if (!this.name) {\n        return IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;\n      }\n      return this.name;\n    }\n    toString() {\n      return this.data;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], ANTLRInputStream2.prototype, \"consume\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ANTLRInputStream2.prototype, \"LA\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ANTLRInputStream2.prototype, \"index\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ANTLRInputStream2.prototype, \"size\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ANTLRInputStream2.prototype, \"mark\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ANTLRInputStream2.prototype, \"release\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ANTLRInputStream2.prototype, \"seek\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ANTLRInputStream2.prototype, \"getText\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ANTLRInputStream2.prototype, \"sourceName\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ANTLRInputStream2.prototype, \"toString\", null);\n  exports.ANTLRInputStream = ANTLRInputStream2;\n});\n\n// node_modules/antlr4ts/atn/ATNState.js\nvar require_ATNState = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ATNState = void 0;\n  var Decorators_1 = require_Decorators();\n  var ATNState = class {\n    constructor() {\n      this.stateNumber = ATNState.INVALID_STATE_NUMBER;\n      this.ruleIndex = 0;\n      this.epsilonOnlyTransitions = false;\n      this.transitions = [];\n      this.optimizedTransitions = this.transitions;\n    }\n    getStateNumber() {\n      return this.stateNumber;\n    }\n    get nonStopStateNumber() {\n      return this.getStateNumber();\n    }\n    hashCode() {\n      return this.stateNumber;\n    }\n    equals(o) {\n      if (o instanceof ATNState) {\n        return this.stateNumber === o.stateNumber;\n      }\n      return false;\n    }\n    get isNonGreedyExitState() {\n      return false;\n    }\n    toString() {\n      return String(this.stateNumber);\n    }\n    getTransitions() {\n      return this.transitions.slice(0);\n    }\n    get numberOfTransitions() {\n      return this.transitions.length;\n    }\n    addTransition(e, index) {\n      if (this.transitions.length === 0) {\n        this.epsilonOnlyTransitions = e.isEpsilon;\n      } else if (this.epsilonOnlyTransitions !== e.isEpsilon) {\n        this.epsilonOnlyTransitions = false;\n        throw new Error(\"ATN state \" + this.stateNumber + \" has both epsilon and non-epsilon transitions.\");\n      }\n      this.transitions.splice(index !== void 0 ? index : this.transitions.length, 0, e);\n    }\n    transition(i) {\n      return this.transitions[i];\n    }\n    setTransition(i, e) {\n      this.transitions[i] = e;\n    }\n    removeTransition(index) {\n      return this.transitions.splice(index, 1)[0];\n    }\n    get onlyHasEpsilonTransitions() {\n      return this.epsilonOnlyTransitions;\n    }\n    setRuleIndex(ruleIndex) {\n      this.ruleIndex = ruleIndex;\n    }\n    get isOptimized() {\n      return this.optimizedTransitions !== this.transitions;\n    }\n    get numberOfOptimizedTransitions() {\n      return this.optimizedTransitions.length;\n    }\n    getOptimizedTransition(i) {\n      return this.optimizedTransitions[i];\n    }\n    addOptimizedTransition(e) {\n      if (!this.isOptimized) {\n        this.optimizedTransitions = new Array();\n      }\n      this.optimizedTransitions.push(e);\n    }\n    setOptimizedTransition(i, e) {\n      if (!this.isOptimized) {\n        throw new Error(\"This ATNState is not optimized.\");\n      }\n      this.optimizedTransitions[i] = e;\n    }\n    removeOptimizedTransition(i) {\n      if (!this.isOptimized) {\n        throw new Error(\"This ATNState is not optimized.\");\n      }\n      this.optimizedTransitions.splice(i, 1);\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], ATNState.prototype, \"hashCode\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ATNState.prototype, \"equals\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ATNState.prototype, \"toString\", null);\n  exports.ATNState = ATNState;\n  (function(ATNState2) {\n    ATNState2.INVALID_STATE_NUMBER = -1;\n  })(ATNState = exports.ATNState || (exports.ATNState = {}));\n});\n\n// node_modules/antlr4ts/atn/ATNStateType.js\nvar require_ATNStateType = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ATNStateType = void 0;\n  var ATNStateType;\n  (function(ATNStateType2) {\n    ATNStateType2[ATNStateType2[\"INVALID_TYPE\"] = 0] = \"INVALID_TYPE\";\n    ATNStateType2[ATNStateType2[\"BASIC\"] = 1] = \"BASIC\";\n    ATNStateType2[ATNStateType2[\"RULE_START\"] = 2] = \"RULE_START\";\n    ATNStateType2[ATNStateType2[\"BLOCK_START\"] = 3] = \"BLOCK_START\";\n    ATNStateType2[ATNStateType2[\"PLUS_BLOCK_START\"] = 4] = \"PLUS_BLOCK_START\";\n    ATNStateType2[ATNStateType2[\"STAR_BLOCK_START\"] = 5] = \"STAR_BLOCK_START\";\n    ATNStateType2[ATNStateType2[\"TOKEN_START\"] = 6] = \"TOKEN_START\";\n    ATNStateType2[ATNStateType2[\"RULE_STOP\"] = 7] = \"RULE_STOP\";\n    ATNStateType2[ATNStateType2[\"BLOCK_END\"] = 8] = \"BLOCK_END\";\n    ATNStateType2[ATNStateType2[\"STAR_LOOP_BACK\"] = 9] = \"STAR_LOOP_BACK\";\n    ATNStateType2[ATNStateType2[\"STAR_LOOP_ENTRY\"] = 10] = \"STAR_LOOP_ENTRY\";\n    ATNStateType2[ATNStateType2[\"PLUS_LOOP_BACK\"] = 11] = \"PLUS_LOOP_BACK\";\n    ATNStateType2[ATNStateType2[\"LOOP_END\"] = 12] = \"LOOP_END\";\n  })(ATNStateType = exports.ATNStateType || (exports.ATNStateType = {}));\n});\n\n// node_modules/antlr4ts/RecognitionException.js\nvar require_RecognitionException = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.RecognitionException = void 0;\n  var RecognitionException2 = class extends Error {\n    constructor(recognizer, input, ctx, message) {\n      super(message);\n      this._offendingState = -1;\n      this._recognizer = recognizer;\n      this.input = input;\n      this.ctx = ctx;\n      if (recognizer) {\n        this._offendingState = recognizer.state;\n      }\n    }\n    get offendingState() {\n      return this._offendingState;\n    }\n    setOffendingState(offendingState) {\n      this._offendingState = offendingState;\n    }\n    get expectedTokens() {\n      if (this._recognizer) {\n        return this._recognizer.atn.getExpectedTokens(this._offendingState, this.ctx);\n      }\n      return void 0;\n    }\n    get context() {\n      return this.ctx;\n    }\n    get inputStream() {\n      return this.input;\n    }\n    getOffendingToken(recognizer) {\n      if (recognizer && recognizer !== this._recognizer) {\n        return void 0;\n      }\n      return this.offendingToken;\n    }\n    setOffendingToken(recognizer, offendingToken) {\n      if (recognizer === this._recognizer) {\n        this.offendingToken = offendingToken;\n      }\n    }\n    get recognizer() {\n      return this._recognizer;\n    }\n  };\n  exports.RecognitionException = RecognitionException2;\n});\n\n// node_modules/antlr4ts/atn/Transition.js\nvar require_Transition = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.Transition = void 0;\n  var Decorators_1 = require_Decorators();\n  var Transition = class Transition {\n    constructor(target) {\n      if (target == null) {\n        throw new Error(\"target cannot be null.\");\n      }\n      this.target = target;\n    }\n    get isEpsilon() {\n      return false;\n    }\n    get label() {\n      return void 0;\n    }\n  };\n  Transition.serializationNames = [\n    \"INVALID\",\n    \"EPSILON\",\n    \"RANGE\",\n    \"RULE\",\n    \"PREDICATE\",\n    \"ATOM\",\n    \"ACTION\",\n    \"SET\",\n    \"NOT_SET\",\n    \"WILDCARD\",\n    \"PRECEDENCE\"\n  ];\n  __decorate([\n    Decorators_1.NotNull\n  ], Transition.prototype, \"target\", void 0);\n  Transition = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], Transition);\n  exports.Transition = Transition;\n});\n\n// node_modules/antlr4ts/atn/AbstractPredicateTransition.js\nvar require_AbstractPredicateTransition = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.AbstractPredicateTransition = void 0;\n  var Transition_1 = require_Transition();\n  var AbstractPredicateTransition = class extends Transition_1.Transition {\n    constructor(target) {\n      super(target);\n    }\n  };\n  exports.AbstractPredicateTransition = AbstractPredicateTransition;\n});\n\n// node_modules/antlr4ts/misc/MurmurHash.js\nvar require_MurmurHash = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.MurmurHash = void 0;\n  var MurmurHash;\n  (function(MurmurHash2) {\n    const DEFAULT_SEED = 0;\n    function initialize(seed = DEFAULT_SEED) {\n      return seed;\n    }\n    MurmurHash2.initialize = initialize;\n    function update(hash, value) {\n      const c1 = 3432918353;\n      const c2 = 461845907;\n      const r1 = 15;\n      const r2 = 13;\n      const m = 5;\n      const n = 3864292196;\n      if (value == null) {\n        value = 0;\n      } else if (typeof value === \"string\") {\n        value = hashString(value);\n      } else if (typeof value === \"object\") {\n        value = value.hashCode();\n      }\n      let k = value;\n      k = Math.imul(k, c1);\n      k = k << r1 | k >>> 32 - r1;\n      k = Math.imul(k, c2);\n      hash = hash ^ k;\n      hash = hash << r2 | hash >>> 32 - r2;\n      hash = Math.imul(hash, m) + n;\n      return hash & 4294967295;\n    }\n    MurmurHash2.update = update;\n    function finish(hash, numberOfWords) {\n      hash = hash ^ numberOfWords * 4;\n      hash = hash ^ hash >>> 16;\n      hash = Math.imul(hash, 2246822507);\n      hash = hash ^ hash >>> 13;\n      hash = Math.imul(hash, 3266489909);\n      hash = hash ^ hash >>> 16;\n      return hash;\n    }\n    MurmurHash2.finish = finish;\n    function hashCode(data, seed = DEFAULT_SEED) {\n      let hash = initialize(seed);\n      let length = 0;\n      for (let value of data) {\n        hash = update(hash, value);\n        length++;\n      }\n      hash = finish(hash, length);\n      return hash;\n    }\n    MurmurHash2.hashCode = hashCode;\n    function hashString(str) {\n      let len = str.length;\n      if (len === 0) {\n        return 0;\n      }\n      let hash = 0;\n      for (let i = 0; i < len; i++) {\n        let c = str.charCodeAt(i);\n        hash = (hash << 5 >>> 0) - hash + c;\n        hash |= 0;\n      }\n      return hash;\n    }\n  })(MurmurHash = exports.MurmurHash || (exports.MurmurHash = {}));\n});\n\n// node_modules/antlr4ts/misc/ObjectEqualityComparator.js\nvar require_ObjectEqualityComparator = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ObjectEqualityComparator = void 0;\n  var Decorators_1 = require_Decorators();\n  var ObjectEqualityComparator = class {\n    hashCode(obj) {\n      if (obj == null) {\n        return 0;\n      }\n      return obj.hashCode();\n    }\n    equals(a, b) {\n      if (a == null) {\n        return b == null;\n      }\n      return a.equals(b);\n    }\n  };\n  ObjectEqualityComparator.INSTANCE = new ObjectEqualityComparator();\n  __decorate([\n    Decorators_1.Override\n  ], ObjectEqualityComparator.prototype, \"hashCode\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ObjectEqualityComparator.prototype, \"equals\", null);\n  exports.ObjectEqualityComparator = ObjectEqualityComparator;\n});\n\n// node_modules/antlr4ts/misc/DefaultEqualityComparator.js\nvar require_DefaultEqualityComparator = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.DefaultEqualityComparator = void 0;\n  var Decorators_1 = require_Decorators();\n  var MurmurHash_1 = require_MurmurHash();\n  var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();\n  var DefaultEqualityComparator = class {\n    hashCode(obj) {\n      if (obj == null) {\n        return 0;\n      } else if (typeof obj === \"string\" || typeof obj === \"number\") {\n        return MurmurHash_1.MurmurHash.hashCode([obj]);\n      } else {\n        return ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.hashCode(obj);\n      }\n    }\n    equals(a, b) {\n      if (a == null) {\n        return b == null;\n      } else if (typeof a === \"string\" || typeof a === \"number\") {\n        return a === b;\n      } else {\n        return ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(a, b);\n      }\n    }\n  };\n  DefaultEqualityComparator.INSTANCE = new DefaultEqualityComparator();\n  __decorate([\n    Decorators_1.Override\n  ], DefaultEqualityComparator.prototype, \"hashCode\", null);\n  __decorate([\n    Decorators_1.Override\n  ], DefaultEqualityComparator.prototype, \"equals\", null);\n  exports.DefaultEqualityComparator = DefaultEqualityComparator;\n});\n\n// node_modules/antlr4ts/misc/Array2DHashSet.js\nvar require_Array2DHashSet = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.Array2DHashSet = void 0;\n  var assert = __webpack_require__(/*! assert */ \"assert\");\n  var DefaultEqualityComparator_1 = require_DefaultEqualityComparator();\n  var Decorators_1 = require_Decorators();\n  var MurmurHash_1 = require_MurmurHash();\n  var INITAL_CAPACITY = 16;\n  var LOAD_FACTOR = 0.75;\n  var Array2DHashSet = class {\n    constructor(comparatorOrSet, initialCapacity = INITAL_CAPACITY) {\n      this.n = 0;\n      this.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR);\n      if (comparatorOrSet instanceof Array2DHashSet) {\n        this.comparator = comparatorOrSet.comparator;\n        this.buckets = comparatorOrSet.buckets.slice(0);\n        for (let i = 0; i < this.buckets.length; i++) {\n          let bucket = this.buckets[i];\n          if (bucket) {\n            this.buckets[i] = bucket.slice(0);\n          }\n        }\n        this.n = comparatorOrSet.n;\n        this.threshold = comparatorOrSet.threshold;\n      } else {\n        this.comparator = comparatorOrSet || DefaultEqualityComparator_1.DefaultEqualityComparator.INSTANCE;\n        this.buckets = this.createBuckets(initialCapacity);\n      }\n    }\n    getOrAdd(o) {\n      if (this.n > this.threshold) {\n        this.expand();\n      }\n      return this.getOrAddImpl(o);\n    }\n    getOrAddImpl(o) {\n      let b = this.getBucket(o);\n      let bucket = this.buckets[b];\n      if (!bucket) {\n        bucket = [o];\n        this.buckets[b] = bucket;\n        this.n++;\n        return o;\n      }\n      for (let existing of bucket) {\n        if (this.comparator.equals(existing, o)) {\n          return existing;\n        }\n      }\n      bucket.push(o);\n      this.n++;\n      return o;\n    }\n    get(o) {\n      if (o == null) {\n        return o;\n      }\n      let b = this.getBucket(o);\n      let bucket = this.buckets[b];\n      if (!bucket) {\n        return void 0;\n      }\n      for (let e of bucket) {\n        if (this.comparator.equals(e, o)) {\n          return e;\n        }\n      }\n      return void 0;\n    }\n    getBucket(o) {\n      let hash = this.comparator.hashCode(o);\n      let b = hash & this.buckets.length - 1;\n      return b;\n    }\n    hashCode() {\n      let hash = MurmurHash_1.MurmurHash.initialize();\n      for (let bucket of this.buckets) {\n        if (bucket == null) {\n          continue;\n        }\n        for (let o of bucket) {\n          if (o == null) {\n            break;\n          }\n          hash = MurmurHash_1.MurmurHash.update(hash, this.comparator.hashCode(o));\n        }\n      }\n      hash = MurmurHash_1.MurmurHash.finish(hash, this.size);\n      return hash;\n    }\n    equals(o) {\n      if (o === this) {\n        return true;\n      }\n      if (!(o instanceof Array2DHashSet)) {\n        return false;\n      }\n      if (o.size !== this.size) {\n        return false;\n      }\n      let same = this.containsAll(o);\n      return same;\n    }\n    expand() {\n      let old = this.buckets;\n      let newCapacity = this.buckets.length * 2;\n      let newTable = this.createBuckets(newCapacity);\n      this.buckets = newTable;\n      this.threshold = Math.floor(newCapacity * LOAD_FACTOR);\n      let oldSize = this.size;\n      for (let bucket of old) {\n        if (!bucket) {\n          continue;\n        }\n        for (let o of bucket) {\n          let b = this.getBucket(o);\n          let newBucket = this.buckets[b];\n          if (!newBucket) {\n            newBucket = [];\n            this.buckets[b] = newBucket;\n          }\n          newBucket.push(o);\n        }\n      }\n      assert(this.n === oldSize);\n    }\n    add(t) {\n      let existing = this.getOrAdd(t);\n      return existing === t;\n    }\n    get size() {\n      return this.n;\n    }\n    get isEmpty() {\n      return this.n === 0;\n    }\n    contains(o) {\n      return this.containsFast(this.asElementType(o));\n    }\n    containsFast(obj) {\n      if (obj == null) {\n        return false;\n      }\n      return this.get(obj) != null;\n    }\n    *[Symbol.iterator]() {\n      yield* this.toArray();\n    }\n    toArray() {\n      const a = new Array(this.size);\n      let i = 0;\n      for (let bucket of this.buckets) {\n        if (bucket == null) {\n          continue;\n        }\n        for (let o of bucket) {\n          if (o == null) {\n            break;\n          }\n          a[i++] = o;\n        }\n      }\n      return a;\n    }\n    containsAll(collection) {\n      if (collection instanceof Array2DHashSet) {\n        let s = collection;\n        for (let bucket of s.buckets) {\n          if (bucket == null) {\n            continue;\n          }\n          for (let o of bucket) {\n            if (o == null) {\n              break;\n            }\n            if (!this.containsFast(this.asElementType(o))) {\n              return false;\n            }\n          }\n        }\n      } else {\n        for (let o of collection) {\n          if (!this.containsFast(this.asElementType(o))) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    addAll(c) {\n      let changed = false;\n      for (let o of c) {\n        let existing = this.getOrAdd(o);\n        if (existing !== o) {\n          changed = true;\n        }\n      }\n      return changed;\n    }\n    clear() {\n      this.buckets = this.createBuckets(INITAL_CAPACITY);\n      this.n = 0;\n      this.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR);\n    }\n    toString() {\n      if (this.size === 0) {\n        return \"{}\";\n      }\n      let buf = \"{\";\n      let first = true;\n      for (let bucket of this.buckets) {\n        if (bucket == null) {\n          continue;\n        }\n        for (let o of bucket) {\n          if (o == null) {\n            break;\n          }\n          if (first) {\n            first = false;\n          } else {\n            buf += \", \";\n          }\n          buf += o.toString();\n        }\n      }\n      buf += \"}\";\n      return buf;\n    }\n    toTableString() {\n      let buf = \"\";\n      for (let bucket of this.buckets) {\n        if (bucket == null) {\n          buf += \"null\\n\";\n          continue;\n        }\n        buf += \"[\";\n        let first = true;\n        for (let o of bucket) {\n          if (first) {\n            first = false;\n          } else {\n            buf += \" \";\n          }\n          if (o == null) {\n            buf += \"_\";\n          } else {\n            buf += o.toString();\n          }\n        }\n        buf += \"]\\n\";\n      }\n      return buf;\n    }\n    asElementType(o) {\n      return o;\n    }\n    createBuckets(capacity) {\n      return new Array(capacity);\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], Array2DHashSet.prototype, \"comparator\", void 0);\n  __decorate([\n    Decorators_1.Override\n  ], Array2DHashSet.prototype, \"hashCode\", null);\n  __decorate([\n    Decorators_1.Override\n  ], Array2DHashSet.prototype, \"equals\", null);\n  __decorate([\n    Decorators_1.Override\n  ], Array2DHashSet.prototype, \"add\", null);\n  __decorate([\n    Decorators_1.Override\n  ], Array2DHashSet.prototype, \"size\", null);\n  __decorate([\n    Decorators_1.Override\n  ], Array2DHashSet.prototype, \"isEmpty\", null);\n  __decorate([\n    Decorators_1.Override\n  ], Array2DHashSet.prototype, \"contains\", null);\n  __decorate([\n    __param(0, Decorators_1.Nullable)\n  ], Array2DHashSet.prototype, \"containsFast\", null);\n  __decorate([\n    Decorators_1.Override\n  ], Array2DHashSet.prototype, Symbol.iterator, null);\n  __decorate([\n    Decorators_1.Override\n  ], Array2DHashSet.prototype, \"toArray\", null);\n  __decorate([\n    Decorators_1.Override\n  ], Array2DHashSet.prototype, \"containsAll\", null);\n  __decorate([\n    Decorators_1.Override\n  ], Array2DHashSet.prototype, \"addAll\", null);\n  __decorate([\n    Decorators_1.Override\n  ], Array2DHashSet.prototype, \"clear\", null);\n  __decorate([\n    Decorators_1.Override\n  ], Array2DHashSet.prototype, \"toString\", null);\n  __decorate([\n    Decorators_1.SuppressWarnings(\"unchecked\")\n  ], Array2DHashSet.prototype, \"asElementType\", null);\n  __decorate([\n    Decorators_1.SuppressWarnings(\"unchecked\")\n  ], Array2DHashSet.prototype, \"createBuckets\", null);\n  exports.Array2DHashSet = Array2DHashSet;\n});\n\n// node_modules/antlr4ts/misc/ArrayEqualityComparator.js\nvar require_ArrayEqualityComparator = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ArrayEqualityComparator = void 0;\n  var Decorators_1 = require_Decorators();\n  var MurmurHash_1 = require_MurmurHash();\n  var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();\n  var ArrayEqualityComparator = class {\n    hashCode(obj) {\n      if (obj == null) {\n        return 0;\n      }\n      return MurmurHash_1.MurmurHash.hashCode(obj, 0);\n    }\n    equals(a, b) {\n      if (a == null) {\n        return b == null;\n      } else if (b == null) {\n        return false;\n      }\n      if (a.length !== b.length) {\n        return false;\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (!ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  };\n  ArrayEqualityComparator.INSTANCE = new ArrayEqualityComparator();\n  __decorate([\n    Decorators_1.Override\n  ], ArrayEqualityComparator.prototype, \"hashCode\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ArrayEqualityComparator.prototype, \"equals\", null);\n  exports.ArrayEqualityComparator = ArrayEqualityComparator;\n});\n\n// node_modules/antlr4ts/misc/Utils.js\nvar require_Utils = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.toCharArray = exports.toMap = exports.equals = exports.join = exports.escapeWhitespace = void 0;\n  function escapeWhitespace(s, escapeSpaces) {\n    return escapeSpaces ? s.replace(/ /, \"\\xB7\") : s.replace(/\\t/, \"\\\\t\").replace(/\\n/, \"\\\\n\").replace(/\\r/, \"\\\\r\");\n  }\n  exports.escapeWhitespace = escapeWhitespace;\n  function join3(collection, separator) {\n    let buf = \"\";\n    let first = true;\n    for (let current of collection) {\n      if (first) {\n        first = false;\n      } else {\n        buf += separator;\n      }\n      buf += current;\n    }\n    return buf;\n  }\n  exports.join = join3;\n  function equals(x, y) {\n    if (x === y) {\n      return true;\n    }\n    if (x === void 0 || y === void 0) {\n      return false;\n    }\n    return x.equals(y);\n  }\n  exports.equals = equals;\n  function toMap(keys) {\n    let m = new Map();\n    for (let i = 0; i < keys.length; i++) {\n      m.set(keys[i], i);\n    }\n    return m;\n  }\n  exports.toMap = toMap;\n  function toCharArray3(str) {\n    if (typeof str === \"string\") {\n      let result = new Uint16Array(str.length);\n      for (let i = 0; i < str.length; i++) {\n        result[i] = str.charCodeAt(i);\n      }\n      return result;\n    } else {\n      return str.toCharArray();\n    }\n  }\n  exports.toCharArray = toCharArray3;\n});\n\n// node_modules/antlr4ts/atn/SemanticContext.js\nvar require_SemanticContext = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.SemanticContext = void 0;\n  var Array2DHashSet_1 = require_Array2DHashSet();\n  var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();\n  var MurmurHash_1 = require_MurmurHash();\n  var Decorators_1 = require_Decorators();\n  var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();\n  var Utils3 = require_Utils();\n  function max(items) {\n    let result;\n    for (let current of items) {\n      if (result === void 0) {\n        result = current;\n        continue;\n      }\n      let comparison = result.compareTo(current);\n      if (comparison < 0) {\n        result = current;\n      }\n    }\n    return result;\n  }\n  function min(items) {\n    let result;\n    for (let current of items) {\n      if (result === void 0) {\n        result = current;\n        continue;\n      }\n      let comparison = result.compareTo(current);\n      if (comparison > 0) {\n        result = current;\n      }\n    }\n    return result;\n  }\n  var SemanticContext = class {\n    static get NONE() {\n      if (SemanticContext._NONE === void 0) {\n        SemanticContext._NONE = new SemanticContext.Predicate();\n      }\n      return SemanticContext._NONE;\n    }\n    evalPrecedence(parser, parserCallStack) {\n      return this;\n    }\n    static and(a, b) {\n      if (!a || a === SemanticContext.NONE) {\n        return b;\n      }\n      if (b === SemanticContext.NONE) {\n        return a;\n      }\n      let result = new SemanticContext.AND(a, b);\n      if (result.opnds.length === 1) {\n        return result.opnds[0];\n      }\n      return result;\n    }\n    static or(a, b) {\n      if (!a) {\n        return b;\n      }\n      if (a === SemanticContext.NONE || b === SemanticContext.NONE) {\n        return SemanticContext.NONE;\n      }\n      let result = new SemanticContext.OR(a, b);\n      if (result.opnds.length === 1) {\n        return result.opnds[0];\n      }\n      return result;\n    }\n  };\n  exports.SemanticContext = SemanticContext;\n  (function(SemanticContext2) {\n    const AND_HASHCODE = 40363613;\n    const OR_HASHCODE = 486279973;\n    function filterPrecedencePredicates(collection) {\n      let result = [];\n      for (let i = 0; i < collection.length; i++) {\n        let context = collection[i];\n        if (context instanceof SemanticContext2.PrecedencePredicate) {\n          result.push(context);\n          collection.splice(i, 1);\n          i--;\n        }\n      }\n      return result;\n    }\n    class Predicate extends SemanticContext2 {\n      constructor(ruleIndex = -1, predIndex = -1, isCtxDependent = false) {\n        super();\n        this.ruleIndex = ruleIndex;\n        this.predIndex = predIndex;\n        this.isCtxDependent = isCtxDependent;\n      }\n      eval(parser, parserCallStack) {\n        let localctx = this.isCtxDependent ? parserCallStack : void 0;\n        return parser.sempred(localctx, this.ruleIndex, this.predIndex);\n      }\n      hashCode() {\n        let hashCode = MurmurHash_1.MurmurHash.initialize();\n        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.ruleIndex);\n        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.predIndex);\n        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.isCtxDependent ? 1 : 0);\n        hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 3);\n        return hashCode;\n      }\n      equals(obj) {\n        if (!(obj instanceof Predicate)) {\n          return false;\n        }\n        if (this === obj) {\n          return true;\n        }\n        return this.ruleIndex === obj.ruleIndex && this.predIndex === obj.predIndex && this.isCtxDependent === obj.isCtxDependent;\n      }\n      toString() {\n        return \"{\" + this.ruleIndex + \":\" + this.predIndex + \"}?\";\n      }\n    }\n    __decorate([\n      Decorators_1.Override\n    ], Predicate.prototype, \"eval\", null);\n    __decorate([\n      Decorators_1.Override\n    ], Predicate.prototype, \"hashCode\", null);\n    __decorate([\n      Decorators_1.Override\n    ], Predicate.prototype, \"equals\", null);\n    __decorate([\n      Decorators_1.Override\n    ], Predicate.prototype, \"toString\", null);\n    SemanticContext2.Predicate = Predicate;\n    class PrecedencePredicate extends SemanticContext2 {\n      constructor(precedence) {\n        super();\n        this.precedence = precedence;\n      }\n      eval(parser, parserCallStack) {\n        return parser.precpred(parserCallStack, this.precedence);\n      }\n      evalPrecedence(parser, parserCallStack) {\n        if (parser.precpred(parserCallStack, this.precedence)) {\n          return SemanticContext2.NONE;\n        } else {\n          return void 0;\n        }\n      }\n      compareTo(o) {\n        return this.precedence - o.precedence;\n      }\n      hashCode() {\n        let hashCode = 1;\n        hashCode = 31 * hashCode + this.precedence;\n        return hashCode;\n      }\n      equals(obj) {\n        if (!(obj instanceof PrecedencePredicate)) {\n          return false;\n        }\n        if (this === obj) {\n          return true;\n        }\n        return this.precedence === obj.precedence;\n      }\n      toString() {\n        return \"{\" + this.precedence + \">=prec}?\";\n      }\n    }\n    __decorate([\n      Decorators_1.Override\n    ], PrecedencePredicate.prototype, \"eval\", null);\n    __decorate([\n      Decorators_1.Override\n    ], PrecedencePredicate.prototype, \"evalPrecedence\", null);\n    __decorate([\n      Decorators_1.Override\n    ], PrecedencePredicate.prototype, \"compareTo\", null);\n    __decorate([\n      Decorators_1.Override\n    ], PrecedencePredicate.prototype, \"hashCode\", null);\n    __decorate([\n      Decorators_1.Override\n    ], PrecedencePredicate.prototype, \"equals\", null);\n    __decorate([\n      Decorators_1.Override\n    ], PrecedencePredicate.prototype, \"toString\", null);\n    SemanticContext2.PrecedencePredicate = PrecedencePredicate;\n    class Operator extends SemanticContext2 {\n    }\n    SemanticContext2.Operator = Operator;\n    let AND = class AND2 extends Operator {\n      constructor(a, b) {\n        super();\n        let operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);\n        if (a instanceof AND2) {\n          operands.addAll(a.opnds);\n        } else {\n          operands.add(a);\n        }\n        if (b instanceof AND2) {\n          operands.addAll(b.opnds);\n        } else {\n          operands.add(b);\n        }\n        this.opnds = operands.toArray();\n        let precedencePredicates = filterPrecedencePredicates(this.opnds);\n        let reduced = min(precedencePredicates);\n        if (reduced) {\n          this.opnds.push(reduced);\n        }\n      }\n      get operands() {\n        return this.opnds;\n      }\n      equals(obj) {\n        if (this === obj) {\n          return true;\n        }\n        if (!(obj instanceof AND2)) {\n          return false;\n        }\n        return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);\n      }\n      hashCode() {\n        return MurmurHash_1.MurmurHash.hashCode(this.opnds, AND_HASHCODE);\n      }\n      eval(parser, parserCallStack) {\n        for (let opnd of this.opnds) {\n          if (!opnd.eval(parser, parserCallStack)) {\n            return false;\n          }\n        }\n        return true;\n      }\n      evalPrecedence(parser, parserCallStack) {\n        let differs = false;\n        let operands = [];\n        for (let context of this.opnds) {\n          let evaluated = context.evalPrecedence(parser, parserCallStack);\n          differs = differs || evaluated !== context;\n          if (evaluated == null) {\n            return void 0;\n          } else if (evaluated !== SemanticContext2.NONE) {\n            operands.push(evaluated);\n          }\n        }\n        if (!differs) {\n          return this;\n        }\n        if (operands.length === 0) {\n          return SemanticContext2.NONE;\n        }\n        let result = operands[0];\n        for (let i = 1; i < operands.length; i++) {\n          result = SemanticContext2.and(result, operands[i]);\n        }\n        return result;\n      }\n      toString() {\n        return Utils3.join(this.opnds, \"&&\");\n      }\n    };\n    __decorate([\n      Decorators_1.Override\n    ], AND.prototype, \"operands\", null);\n    __decorate([\n      Decorators_1.Override\n    ], AND.prototype, \"equals\", null);\n    __decorate([\n      Decorators_1.Override\n    ], AND.prototype, \"hashCode\", null);\n    __decorate([\n      Decorators_1.Override\n    ], AND.prototype, \"eval\", null);\n    __decorate([\n      Decorators_1.Override\n    ], AND.prototype, \"evalPrecedence\", null);\n    __decorate([\n      Decorators_1.Override\n    ], AND.prototype, \"toString\", null);\n    AND = __decorate([\n      __param(0, Decorators_1.NotNull),\n      __param(1, Decorators_1.NotNull)\n    ], AND);\n    SemanticContext2.AND = AND;\n    let OR = class OR2 extends Operator {\n      constructor(a, b) {\n        super();\n        let operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);\n        if (a instanceof OR2) {\n          operands.addAll(a.opnds);\n        } else {\n          operands.add(a);\n        }\n        if (b instanceof OR2) {\n          operands.addAll(b.opnds);\n        } else {\n          operands.add(b);\n        }\n        this.opnds = operands.toArray();\n        let precedencePredicates = filterPrecedencePredicates(this.opnds);\n        let reduced = max(precedencePredicates);\n        if (reduced) {\n          this.opnds.push(reduced);\n        }\n      }\n      get operands() {\n        return this.opnds;\n      }\n      equals(obj) {\n        if (this === obj) {\n          return true;\n        }\n        if (!(obj instanceof OR2)) {\n          return false;\n        }\n        return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);\n      }\n      hashCode() {\n        return MurmurHash_1.MurmurHash.hashCode(this.opnds, OR_HASHCODE);\n      }\n      eval(parser, parserCallStack) {\n        for (let opnd of this.opnds) {\n          if (opnd.eval(parser, parserCallStack)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      evalPrecedence(parser, parserCallStack) {\n        let differs = false;\n        let operands = [];\n        for (let context of this.opnds) {\n          let evaluated = context.evalPrecedence(parser, parserCallStack);\n          differs = differs || evaluated !== context;\n          if (evaluated === SemanticContext2.NONE) {\n            return SemanticContext2.NONE;\n          } else if (evaluated) {\n            operands.push(evaluated);\n          }\n        }\n        if (!differs) {\n          return this;\n        }\n        if (operands.length === 0) {\n          return void 0;\n        }\n        let result = operands[0];\n        for (let i = 1; i < operands.length; i++) {\n          result = SemanticContext2.or(result, operands[i]);\n        }\n        return result;\n      }\n      toString() {\n        return Utils3.join(this.opnds, \"||\");\n      }\n    };\n    __decorate([\n      Decorators_1.Override\n    ], OR.prototype, \"operands\", null);\n    __decorate([\n      Decorators_1.Override\n    ], OR.prototype, \"equals\", null);\n    __decorate([\n      Decorators_1.Override\n    ], OR.prototype, \"hashCode\", null);\n    __decorate([\n      Decorators_1.Override\n    ], OR.prototype, \"eval\", null);\n    __decorate([\n      Decorators_1.Override\n    ], OR.prototype, \"evalPrecedence\", null);\n    __decorate([\n      Decorators_1.Override\n    ], OR.prototype, \"toString\", null);\n    OR = __decorate([\n      __param(0, Decorators_1.NotNull),\n      __param(1, Decorators_1.NotNull)\n    ], OR);\n    SemanticContext2.OR = OR;\n  })(SemanticContext = exports.SemanticContext || (exports.SemanticContext = {}));\n});\n\n// node_modules/antlr4ts/atn/PredicateTransition.js\nvar require_PredicateTransition = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.PredicateTransition = void 0;\n  var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();\n  var Decorators_1 = require_Decorators();\n  var SemanticContext_1 = require_SemanticContext();\n  var PredicateTransition = class PredicateTransition extends AbstractPredicateTransition_1.AbstractPredicateTransition {\n    constructor(target, ruleIndex, predIndex, isCtxDependent) {\n      super(target);\n      this.ruleIndex = ruleIndex;\n      this.predIndex = predIndex;\n      this.isCtxDependent = isCtxDependent;\n    }\n    get serializationType() {\n      return 4;\n    }\n    get isEpsilon() {\n      return true;\n    }\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n      return false;\n    }\n    get predicate() {\n      return new SemanticContext_1.SemanticContext.Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);\n    }\n    toString() {\n      return \"pred_\" + this.ruleIndex + \":\" + this.predIndex;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], PredicateTransition.prototype, \"serializationType\", null);\n  __decorate([\n    Decorators_1.Override\n  ], PredicateTransition.prototype, \"isEpsilon\", null);\n  __decorate([\n    Decorators_1.Override\n  ], PredicateTransition.prototype, \"matches\", null);\n  __decorate([\n    Decorators_1.Override,\n    Decorators_1.NotNull\n  ], PredicateTransition.prototype, \"toString\", null);\n  PredicateTransition = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], PredicateTransition);\n  exports.PredicateTransition = PredicateTransition;\n});\n\n// node_modules/antlr4ts/FailedPredicateException.js\nvar require_FailedPredicateException = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.FailedPredicateException = void 0;\n  var RecognitionException_1 = require_RecognitionException();\n  var Decorators_1 = require_Decorators();\n  var PredicateTransition_1 = require_PredicateTransition();\n  var FailedPredicateException2 = class FailedPredicateException3 extends RecognitionException_1.RecognitionException {\n    constructor(recognizer, predicate, message) {\n      super(recognizer, recognizer.inputStream, recognizer.context, FailedPredicateException3.formatMessage(predicate, message));\n      let s = recognizer.interpreter.atn.states[recognizer.state];\n      let trans = s.transition(0);\n      if (trans instanceof PredicateTransition_1.PredicateTransition) {\n        this._ruleIndex = trans.ruleIndex;\n        this._predicateIndex = trans.predIndex;\n      } else {\n        this._ruleIndex = 0;\n        this._predicateIndex = 0;\n      }\n      this._predicate = predicate;\n      super.setOffendingToken(recognizer, recognizer.currentToken);\n    }\n    get ruleIndex() {\n      return this._ruleIndex;\n    }\n    get predicateIndex() {\n      return this._predicateIndex;\n    }\n    get predicate() {\n      return this._predicate;\n    }\n    static formatMessage(predicate, message) {\n      if (message) {\n        return message;\n      }\n      return `failed predicate: {${predicate}}?`;\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], FailedPredicateException2, \"formatMessage\", null);\n  FailedPredicateException2 = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], FailedPredicateException2);\n  exports.FailedPredicateException = FailedPredicateException2;\n});\n\n// node_modules/antlr4ts/InputMismatchException.js\nvar require_InputMismatchException = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.InputMismatchException = void 0;\n  var RecognitionException_1 = require_RecognitionException();\n  var Decorators_1 = require_Decorators();\n  var InputMismatchException = class InputMismatchException extends RecognitionException_1.RecognitionException {\n    constructor(recognizer, state, context) {\n      if (context === void 0) {\n        context = recognizer.context;\n      }\n      super(recognizer, recognizer.inputStream, context);\n      if (state !== void 0) {\n        this.setOffendingState(state);\n      }\n      this.setOffendingToken(recognizer, recognizer.currentToken);\n    }\n  };\n  InputMismatchException = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], InputMismatchException);\n  exports.InputMismatchException = InputMismatchException;\n});\n\n// node_modules/antlr4ts/misc/Arrays.js\nvar require_Arrays = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.Arrays = void 0;\n  var Arrays;\n  (function(Arrays2) {\n    function binarySearch(array, key, fromIndex, toIndex) {\n      return binarySearch0(array, fromIndex !== void 0 ? fromIndex : 0, toIndex !== void 0 ? toIndex : array.length, key);\n    }\n    Arrays2.binarySearch = binarySearch;\n    function binarySearch0(array, fromIndex, toIndex, key) {\n      let low = fromIndex;\n      let high = toIndex - 1;\n      while (low <= high) {\n        let mid = low + high >>> 1;\n        let midVal = array[mid];\n        if (midVal < key) {\n          low = mid + 1;\n        } else if (midVal > key) {\n          high = mid - 1;\n        } else {\n          return mid;\n        }\n      }\n      return -(low + 1);\n    }\n    function toString(array) {\n      let result = \"[\";\n      let first = true;\n      for (let element of array) {\n        if (first) {\n          first = false;\n        } else {\n          result += \", \";\n        }\n        if (element === null) {\n          result += \"null\";\n        } else if (element === void 0) {\n          result += \"undefined\";\n        } else {\n          result += element;\n        }\n      }\n      result += \"]\";\n      return result;\n    }\n    Arrays2.toString = toString;\n  })(Arrays = exports.Arrays || (exports.Arrays = {}));\n});\n\n// node_modules/antlr4ts/misc/IntegerList.js\nvar require_IntegerList = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.IntegerList = void 0;\n  var Arrays_1 = require_Arrays();\n  var Decorators_1 = require_Decorators();\n  var EMPTY_DATA = new Int32Array(0);\n  var INITIAL_SIZE = 4;\n  var MAX_ARRAY_SIZE = (1 << 31 >>> 0) - 1 - 8;\n  var IntegerList = class {\n    constructor(arg) {\n      if (!arg) {\n        this._data = EMPTY_DATA;\n        this._size = 0;\n      } else if (arg instanceof IntegerList) {\n        this._data = arg._data.slice(0);\n        this._size = arg._size;\n      } else if (typeof arg === \"number\") {\n        if (arg === 0) {\n          this._data = EMPTY_DATA;\n          this._size = 0;\n        } else {\n          this._data = new Int32Array(arg);\n          this._size = 0;\n        }\n      } else {\n        this._data = EMPTY_DATA;\n        this._size = 0;\n        for (let value of arg) {\n          this.add(value);\n        }\n      }\n    }\n    add(value) {\n      if (this._data.length === this._size) {\n        this.ensureCapacity(this._size + 1);\n      }\n      this._data[this._size] = value;\n      this._size++;\n    }\n    addAll(list) {\n      if (Array.isArray(list)) {\n        this.ensureCapacity(this._size + list.length);\n        this._data.subarray(this._size, this._size + list.length).set(list);\n        this._size += list.length;\n      } else if (list instanceof IntegerList) {\n        this.ensureCapacity(this._size + list._size);\n        this._data.subarray(this._size, this._size + list.size).set(list._data);\n        this._size += list._size;\n      } else {\n        this.ensureCapacity(this._size + list.size);\n        let current = 0;\n        for (let xi of list) {\n          this._data[this._size + current] = xi;\n          current++;\n        }\n        this._size += list.size;\n      }\n    }\n    get(index) {\n      if (index < 0 || index >= this._size) {\n        throw RangeError();\n      }\n      return this._data[index];\n    }\n    contains(value) {\n      for (let i = 0; i < this._size; i++) {\n        if (this._data[i] === value) {\n          return true;\n        }\n      }\n      return false;\n    }\n    set(index, value) {\n      if (index < 0 || index >= this._size) {\n        throw RangeError();\n      }\n      let previous = this._data[index];\n      this._data[index] = value;\n      return previous;\n    }\n    removeAt(index) {\n      let value = this.get(index);\n      this._data.copyWithin(index, index + 1, this._size);\n      this._data[this._size - 1] = 0;\n      this._size--;\n      return value;\n    }\n    removeRange(fromIndex, toIndex) {\n      if (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {\n        throw RangeError();\n      }\n      if (fromIndex > toIndex) {\n        throw RangeError();\n      }\n      this._data.copyWithin(toIndex, fromIndex, this._size);\n      this._data.fill(0, this._size - (toIndex - fromIndex), this._size);\n      this._size -= toIndex - fromIndex;\n    }\n    get isEmpty() {\n      return this._size === 0;\n    }\n    get size() {\n      return this._size;\n    }\n    trimToSize() {\n      if (this._data.length === this._size) {\n        return;\n      }\n      this._data = this._data.slice(0, this._size);\n    }\n    clear() {\n      this._data.fill(0, 0, this._size);\n      this._size = 0;\n    }\n    toArray() {\n      if (this._size === 0) {\n        return [];\n      }\n      return Array.from(this._data.subarray(0, this._size));\n    }\n    sort() {\n      this._data.subarray(0, this._size).sort();\n    }\n    equals(o) {\n      if (o === this) {\n        return true;\n      }\n      if (!(o instanceof IntegerList)) {\n        return false;\n      }\n      if (this._size !== o._size) {\n        return false;\n      }\n      for (let i = 0; i < this._size; i++) {\n        if (this._data[i] !== o._data[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    hashCode() {\n      let hashCode = 1;\n      for (let i = 0; i < this._size; i++) {\n        hashCode = 31 * hashCode + this._data[i];\n      }\n      return hashCode;\n    }\n    toString() {\n      return this._data.toString();\n    }\n    binarySearch(key, fromIndex, toIndex) {\n      if (fromIndex === void 0) {\n        fromIndex = 0;\n      }\n      if (toIndex === void 0) {\n        toIndex = this._size;\n      }\n      if (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {\n        throw new RangeError();\n      }\n      if (fromIndex > toIndex) {\n        throw new RangeError();\n      }\n      return Arrays_1.Arrays.binarySearch(this._data, key, fromIndex, toIndex);\n    }\n    ensureCapacity(capacity) {\n      if (capacity < 0 || capacity > MAX_ARRAY_SIZE) {\n        throw new RangeError();\n      }\n      let newLength;\n      if (this._data.length === 0) {\n        newLength = INITIAL_SIZE;\n      } else {\n        newLength = this._data.length;\n      }\n      while (newLength < capacity) {\n        newLength = newLength * 2;\n        if (newLength < 0 || newLength > MAX_ARRAY_SIZE) {\n          newLength = MAX_ARRAY_SIZE;\n        }\n      }\n      let tmp = new Int32Array(newLength);\n      tmp.set(this._data);\n      this._data = tmp;\n    }\n    toCharArray() {\n      let resultArray = new Uint16Array(this._size);\n      let resultIdx = 0;\n      let calculatedPreciseResultSize = false;\n      for (let i = 0; i < this._size; i++) {\n        let codePoint = this._data[i];\n        if (codePoint >= 0 && codePoint < 65536) {\n          resultArray[resultIdx] = codePoint;\n          resultIdx++;\n          continue;\n        }\n        if (!calculatedPreciseResultSize) {\n          let newResultArray = new Uint16Array(this.charArraySize());\n          newResultArray.set(resultArray, 0);\n          resultArray = newResultArray;\n          calculatedPreciseResultSize = true;\n        }\n        let pair = String.fromCodePoint(codePoint);\n        resultArray[resultIdx] = pair.charCodeAt(0);\n        resultArray[resultIdx + 1] = pair.charCodeAt(1);\n        resultIdx += 2;\n      }\n      return resultArray;\n    }\n    charArraySize() {\n      let result = 0;\n      for (let i = 0; i < this._size; i++) {\n        result += this._data[i] >= 65536 ? 2 : 1;\n      }\n      return result;\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], IntegerList.prototype, \"_data\", void 0);\n  __decorate([\n    Decorators_1.Override\n  ], IntegerList.prototype, \"equals\", null);\n  __decorate([\n    Decorators_1.Override\n  ], IntegerList.prototype, \"hashCode\", null);\n  __decorate([\n    Decorators_1.Override\n  ], IntegerList.prototype, \"toString\", null);\n  exports.IntegerList = IntegerList;\n});\n\n// node_modules/antlr4ts/misc/Interval.js\nvar require_Interval = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.Interval = void 0;\n  var Decorators_1 = require_Decorators();\n  var INTERVAL_POOL_MAX_VALUE = 1e3;\n  var Interval = class {\n    constructor(a, b) {\n      this.a = a;\n      this.b = b;\n    }\n    static get INVALID() {\n      return Interval._INVALID;\n    }\n    static of(a, b) {\n      if (a !== b || a < 0 || a > INTERVAL_POOL_MAX_VALUE) {\n        return new Interval(a, b);\n      }\n      if (Interval.cache[a] == null) {\n        Interval.cache[a] = new Interval(a, a);\n      }\n      return Interval.cache[a];\n    }\n    get length() {\n      if (this.b < this.a) {\n        return 0;\n      }\n      return this.b - this.a + 1;\n    }\n    equals(o) {\n      if (o === this) {\n        return true;\n      } else if (!(o instanceof Interval)) {\n        return false;\n      }\n      return this.a === o.a && this.b === o.b;\n    }\n    hashCode() {\n      let hash = 23;\n      hash = hash * 31 + this.a;\n      hash = hash * 31 + this.b;\n      return hash;\n    }\n    startsBeforeDisjoint(other) {\n      return this.a < other.a && this.b < other.a;\n    }\n    startsBeforeNonDisjoint(other) {\n      return this.a <= other.a && this.b >= other.a;\n    }\n    startsAfter(other) {\n      return this.a > other.a;\n    }\n    startsAfterDisjoint(other) {\n      return this.a > other.b;\n    }\n    startsAfterNonDisjoint(other) {\n      return this.a > other.a && this.a <= other.b;\n    }\n    disjoint(other) {\n      return this.startsBeforeDisjoint(other) || this.startsAfterDisjoint(other);\n    }\n    adjacent(other) {\n      return this.a === other.b + 1 || this.b === other.a - 1;\n    }\n    properlyContains(other) {\n      return other.a >= this.a && other.b <= this.b;\n    }\n    union(other) {\n      return Interval.of(Math.min(this.a, other.a), Math.max(this.b, other.b));\n    }\n    intersection(other) {\n      return Interval.of(Math.max(this.a, other.a), Math.min(this.b, other.b));\n    }\n    differenceNotProperlyContained(other) {\n      let diff;\n      if (other.startsBeforeNonDisjoint(this)) {\n        diff = Interval.of(Math.max(this.a, other.b + 1), this.b);\n      } else if (other.startsAfterNonDisjoint(this)) {\n        diff = Interval.of(this.a, other.a - 1);\n      }\n      return diff;\n    }\n    toString() {\n      return this.a + \"..\" + this.b;\n    }\n  };\n  Interval._INVALID = new Interval(-1, -2);\n  Interval.cache = new Array(INTERVAL_POOL_MAX_VALUE + 1);\n  __decorate([\n    Decorators_1.Override\n  ], Interval.prototype, \"equals\", null);\n  __decorate([\n    Decorators_1.Override\n  ], Interval.prototype, \"hashCode\", null);\n  __decorate([\n    Decorators_1.Override\n  ], Interval.prototype, \"toString\", null);\n  exports.Interval = Interval;\n});\n\n// node_modules/antlr4ts/Token.js\nvar require_Token = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.Token = void 0;\n  var IntStream_1 = require_IntStream();\n  var Token2;\n  (function(Token3) {\n    Token3.INVALID_TYPE = 0;\n    Token3.EPSILON = -2;\n    Token3.MIN_USER_TOKEN_TYPE = 1;\n    Token3.EOF = IntStream_1.IntStream.EOF;\n    Token3.DEFAULT_CHANNEL = 0;\n    Token3.HIDDEN_CHANNEL = 1;\n    Token3.MIN_USER_CHANNEL_VALUE = 2;\n  })(Token2 = exports.Token || (exports.Token = {}));\n});\n\n// node_modules/antlr4ts/CommonToken.js\nvar require_CommonToken = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.CommonToken = void 0;\n  var Interval_1 = require_Interval();\n  var Decorators_1 = require_Decorators();\n  var Token_1 = require_Token();\n  var CommonToken = class CommonToken2 {\n    constructor(type, text, source = CommonToken2.EMPTY_SOURCE, channel = Token_1.Token.DEFAULT_CHANNEL, start = 0, stop = 0) {\n      this._line = 0;\n      this._charPositionInLine = -1;\n      this._channel = Token_1.Token.DEFAULT_CHANNEL;\n      this.index = -1;\n      this._text = text;\n      this._type = type;\n      this.source = source;\n      this._channel = channel;\n      this.start = start;\n      this.stop = stop;\n      if (source.source != null) {\n        this._line = source.source.line;\n        this._charPositionInLine = source.source.charPositionInLine;\n      }\n    }\n    static fromToken(oldToken) {\n      let result = new CommonToken2(oldToken.type, void 0, CommonToken2.EMPTY_SOURCE, oldToken.channel, oldToken.startIndex, oldToken.stopIndex);\n      result._line = oldToken.line;\n      result.index = oldToken.tokenIndex;\n      result._charPositionInLine = oldToken.charPositionInLine;\n      if (oldToken instanceof CommonToken2) {\n        result._text = oldToken._text;\n        result.source = oldToken.source;\n      } else {\n        result._text = oldToken.text;\n        result.source = {source: oldToken.tokenSource, stream: oldToken.inputStream};\n      }\n      return result;\n    }\n    get type() {\n      return this._type;\n    }\n    set type(type) {\n      this._type = type;\n    }\n    get line() {\n      return this._line;\n    }\n    set line(line) {\n      this._line = line;\n    }\n    get text() {\n      if (this._text != null) {\n        return this._text;\n      }\n      let input = this.inputStream;\n      if (input == null) {\n        return void 0;\n      }\n      let n = input.size;\n      if (this.start < n && this.stop < n) {\n        return input.getText(Interval_1.Interval.of(this.start, this.stop));\n      } else {\n        return \"<EOF>\";\n      }\n    }\n    set text(text) {\n      this._text = text;\n    }\n    get charPositionInLine() {\n      return this._charPositionInLine;\n    }\n    set charPositionInLine(charPositionInLine) {\n      this._charPositionInLine = charPositionInLine;\n    }\n    get channel() {\n      return this._channel;\n    }\n    set channel(channel) {\n      this._channel = channel;\n    }\n    get startIndex() {\n      return this.start;\n    }\n    set startIndex(start) {\n      this.start = start;\n    }\n    get stopIndex() {\n      return this.stop;\n    }\n    set stopIndex(stop) {\n      this.stop = stop;\n    }\n    get tokenIndex() {\n      return this.index;\n    }\n    set tokenIndex(index) {\n      this.index = index;\n    }\n    get tokenSource() {\n      return this.source.source;\n    }\n    get inputStream() {\n      return this.source.stream;\n    }\n    toString(recognizer) {\n      let channelStr = \"\";\n      if (this._channel > 0) {\n        channelStr = \",channel=\" + this._channel;\n      }\n      let txt = this.text;\n      if (txt != null) {\n        txt = txt.replace(/\\n/g, \"\\\\n\");\n        txt = txt.replace(/\\r/g, \"\\\\r\");\n        txt = txt.replace(/\\t/g, \"\\\\t\");\n      } else {\n        txt = \"<no text>\";\n      }\n      let typeString = String(this._type);\n      if (recognizer) {\n        typeString = recognizer.vocabulary.getDisplayName(this._type);\n      }\n      return \"[@\" + this.tokenIndex + \",\" + this.start + \":\" + this.stop + \"='\" + txt + \"',<\" + typeString + \">\" + channelStr + \",\" + this._line + \":\" + this.charPositionInLine + \"]\";\n    }\n  };\n  CommonToken.EMPTY_SOURCE = {source: void 0, stream: void 0};\n  __decorate([\n    Decorators_1.NotNull\n  ], CommonToken.prototype, \"source\", void 0);\n  __decorate([\n    Decorators_1.Override\n  ], CommonToken.prototype, \"type\", null);\n  __decorate([\n    Decorators_1.Override\n  ], CommonToken.prototype, \"line\", null);\n  __decorate([\n    Decorators_1.Override\n  ], CommonToken.prototype, \"text\", null);\n  __decorate([\n    Decorators_1.Override\n  ], CommonToken.prototype, \"charPositionInLine\", null);\n  __decorate([\n    Decorators_1.Override\n  ], CommonToken.prototype, \"channel\", null);\n  __decorate([\n    Decorators_1.Override\n  ], CommonToken.prototype, \"startIndex\", null);\n  __decorate([\n    Decorators_1.Override\n  ], CommonToken.prototype, \"stopIndex\", null);\n  __decorate([\n    Decorators_1.Override\n  ], CommonToken.prototype, \"tokenIndex\", null);\n  __decorate([\n    Decorators_1.Override\n  ], CommonToken.prototype, \"tokenSource\", null);\n  __decorate([\n    Decorators_1.Override\n  ], CommonToken.prototype, \"inputStream\", null);\n  __decorate([\n    Decorators_1.Override\n  ], CommonToken.prototype, \"toString\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], CommonToken, \"fromToken\", null);\n  CommonToken = __decorate([\n    __param(2, Decorators_1.NotNull)\n  ], CommonToken);\n  exports.CommonToken = CommonToken;\n});\n\n// node_modules/antlr4ts/CommonTokenFactory.js\nvar require_CommonTokenFactory = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.CommonTokenFactory = void 0;\n  var CommonToken_1 = require_CommonToken();\n  var Interval_1 = require_Interval();\n  var Decorators_1 = require_Decorators();\n  var CommonTokenFactory = class {\n    constructor(copyText = false) {\n      this.copyText = copyText;\n    }\n    create(source, type, text, channel, start, stop, line, charPositionInLine) {\n      let t = new CommonToken_1.CommonToken(type, text, source, channel, start, stop);\n      t.line = line;\n      t.charPositionInLine = charPositionInLine;\n      if (text == null && this.copyText && source.stream != null) {\n        t.text = source.stream.getText(Interval_1.Interval.of(start, stop));\n      }\n      return t;\n    }\n    createSimple(type, text) {\n      return new CommonToken_1.CommonToken(type, text);\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], CommonTokenFactory.prototype, \"create\", null);\n  __decorate([\n    Decorators_1.Override\n  ], CommonTokenFactory.prototype, \"createSimple\", null);\n  exports.CommonTokenFactory = CommonTokenFactory;\n  (function(CommonTokenFactory2) {\n    CommonTokenFactory2.DEFAULT = new CommonTokenFactory2();\n  })(CommonTokenFactory = exports.CommonTokenFactory || (exports.CommonTokenFactory = {}));\n});\n\n// node_modules/antlr4ts/misc/IntegerStack.js\nvar require_IntegerStack = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.IntegerStack = void 0;\n  var IntegerList_1 = require_IntegerList();\n  var IntegerStack = class extends IntegerList_1.IntegerList {\n    constructor(arg) {\n      super(arg);\n    }\n    push(value) {\n      this.add(value);\n    }\n    pop() {\n      return this.removeAt(this.size - 1);\n    }\n    peek() {\n      return this.get(this.size - 1);\n    }\n  };\n  exports.IntegerStack = IntegerStack;\n});\n\n// node_modules/antlr4ts/dfa/AcceptStateInfo.js\nvar require_AcceptStateInfo = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.AcceptStateInfo = void 0;\n  var AcceptStateInfo = class {\n    constructor(prediction, lexerActionExecutor) {\n      this._prediction = prediction;\n      this._lexerActionExecutor = lexerActionExecutor;\n    }\n    get prediction() {\n      return this._prediction;\n    }\n    get lexerActionExecutor() {\n      return this._lexerActionExecutor;\n    }\n  };\n  exports.AcceptStateInfo = AcceptStateInfo;\n});\n\n// node_modules/antlr4ts/misc/Array2DHashMap.js\nvar require_Array2DHashMap = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.Array2DHashMap = void 0;\n  var Array2DHashSet_1 = require_Array2DHashSet();\n  var MapKeyEqualityComparator = class {\n    constructor(keyComparator) {\n      this.keyComparator = keyComparator;\n    }\n    hashCode(obj) {\n      return this.keyComparator.hashCode(obj.key);\n    }\n    equals(a, b) {\n      return this.keyComparator.equals(a.key, b.key);\n    }\n  };\n  var Array2DHashMap = class {\n    constructor(keyComparer) {\n      if (keyComparer instanceof Array2DHashMap) {\n        this.backingStore = new Array2DHashSet_1.Array2DHashSet(keyComparer.backingStore);\n      } else {\n        this.backingStore = new Array2DHashSet_1.Array2DHashSet(new MapKeyEqualityComparator(keyComparer));\n      }\n    }\n    clear() {\n      this.backingStore.clear();\n    }\n    containsKey(key) {\n      return this.backingStore.contains({key});\n    }\n    get(key) {\n      let bucket = this.backingStore.get({key});\n      if (!bucket) {\n        return void 0;\n      }\n      return bucket.value;\n    }\n    get isEmpty() {\n      return this.backingStore.isEmpty;\n    }\n    put(key, value) {\n      let element = this.backingStore.get({key, value});\n      let result;\n      if (!element) {\n        this.backingStore.add({key, value});\n      } else {\n        result = element.value;\n        element.value = value;\n      }\n      return result;\n    }\n    putIfAbsent(key, value) {\n      let element = this.backingStore.get({key, value});\n      let result;\n      if (!element) {\n        this.backingStore.add({key, value});\n      } else {\n        result = element.value;\n      }\n      return result;\n    }\n    get size() {\n      return this.backingStore.size;\n    }\n    hashCode() {\n      return this.backingStore.hashCode();\n    }\n    equals(o) {\n      if (!(o instanceof Array2DHashMap)) {\n        return false;\n      }\n      return this.backingStore.equals(o.backingStore);\n    }\n  };\n  exports.Array2DHashMap = Array2DHashMap;\n});\n\n// node_modules/antlr4ts/atn/DecisionState.js\nvar require_DecisionState = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.DecisionState = void 0;\n  var ATNState_1 = require_ATNState();\n  var DecisionState = class extends ATNState_1.ATNState {\n    constructor() {\n      super(...arguments);\n      this.decision = -1;\n      this.nonGreedy = false;\n      this.sll = false;\n    }\n  };\n  exports.DecisionState = DecisionState;\n});\n\n// node_modules/antlr4ts/atn/PredictionContextCache.js\nvar require_PredictionContextCache = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.PredictionContextCache = void 0;\n  var Array2DHashMap_1 = require_Array2DHashMap();\n  var Decorators_1 = require_Decorators();\n  var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();\n  var PredictionContext_1 = require_PredictionContext();\n  var assert = __webpack_require__(/*! assert */ \"assert\");\n  var PredictionContextCache = class {\n    constructor(enableCache = true) {\n      this.contexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);\n      this.childContexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);\n      this.joinContexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);\n      this.enableCache = enableCache;\n    }\n    getAsCached(context) {\n      if (!this.enableCache) {\n        return context;\n      }\n      let result = this.contexts.get(context);\n      if (!result) {\n        result = context;\n        this.contexts.put(context, context);\n      }\n      return result;\n    }\n    getChild(context, invokingState) {\n      if (!this.enableCache) {\n        return context.getChild(invokingState);\n      }\n      let operands = new PredictionContextCache.PredictionContextAndInt(context, invokingState);\n      let result = this.childContexts.get(operands);\n      if (!result) {\n        result = context.getChild(invokingState);\n        result = this.getAsCached(result);\n        this.childContexts.put(operands, result);\n      }\n      return result;\n    }\n    join(x, y) {\n      if (!this.enableCache) {\n        return PredictionContext_1.PredictionContext.join(x, y, this);\n      }\n      let operands = new PredictionContextCache.IdentityCommutativePredictionContextOperands(x, y);\n      let result = this.joinContexts.get(operands);\n      if (result) {\n        return result;\n      }\n      result = PredictionContext_1.PredictionContext.join(x, y, this);\n      result = this.getAsCached(result);\n      this.joinContexts.put(operands, result);\n      return result;\n    }\n  };\n  exports.PredictionContextCache = PredictionContextCache;\n  PredictionContextCache.UNCACHED = new PredictionContextCache(false);\n  (function(PredictionContextCache2) {\n    class PredictionContextAndInt {\n      constructor(obj, value) {\n        this.obj = obj;\n        this.value = value;\n      }\n      equals(obj) {\n        if (!(obj instanceof PredictionContextAndInt)) {\n          return false;\n        } else if (obj === this) {\n          return true;\n        }\n        let other = obj;\n        return this.value === other.value && (this.obj === other.obj || this.obj != null && this.obj.equals(other.obj));\n      }\n      hashCode() {\n        let hashCode = 5;\n        hashCode = 7 * hashCode + (this.obj != null ? this.obj.hashCode() : 0);\n        hashCode = 7 * hashCode + this.value;\n        return hashCode;\n      }\n    }\n    __decorate([\n      Decorators_1.Override\n    ], PredictionContextAndInt.prototype, \"equals\", null);\n    __decorate([\n      Decorators_1.Override\n    ], PredictionContextAndInt.prototype, \"hashCode\", null);\n    PredictionContextCache2.PredictionContextAndInt = PredictionContextAndInt;\n    class IdentityCommutativePredictionContextOperands {\n      constructor(x, y) {\n        assert(x != null);\n        assert(y != null);\n        this._x = x;\n        this._y = y;\n      }\n      get x() {\n        return this._x;\n      }\n      get y() {\n        return this._y;\n      }\n      equals(o) {\n        if (!(o instanceof IdentityCommutativePredictionContextOperands)) {\n          return false;\n        } else if (this === o) {\n          return true;\n        }\n        let other = o;\n        return this._x === other._x && this._y === other._y || this._x === other._y && this._y === other._x;\n      }\n      hashCode() {\n        return this._x.hashCode() ^ this._y.hashCode();\n      }\n    }\n    __decorate([\n      Decorators_1.Override\n    ], IdentityCommutativePredictionContextOperands.prototype, \"equals\", null);\n    __decorate([\n      Decorators_1.Override\n    ], IdentityCommutativePredictionContextOperands.prototype, \"hashCode\", null);\n    PredictionContextCache2.IdentityCommutativePredictionContextOperands = IdentityCommutativePredictionContextOperands;\n  })(PredictionContextCache = exports.PredictionContextCache || (exports.PredictionContextCache = {}));\n});\n\n// node_modules/antlr4ts/atn/PredictionContext.js\nvar require_PredictionContext = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.SingletonPredictionContext = exports.PredictionContext = void 0;\n  var Array2DHashMap_1 = require_Array2DHashMap();\n  var Array2DHashSet_1 = require_Array2DHashSet();\n  var Arrays_1 = require_Arrays();\n  var MurmurHash_1 = require_MurmurHash();\n  var Decorators_1 = require_Decorators();\n  var PredictionContextCache_1 = require_PredictionContextCache();\n  var assert = __webpack_require__(/*! assert */ \"assert\");\n  var INITIAL_HASH = 1;\n  var PredictionContext = class {\n    constructor(cachedHashCode) {\n      this.cachedHashCode = cachedHashCode;\n    }\n    static calculateEmptyHashCode() {\n      let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);\n      hash = MurmurHash_1.MurmurHash.finish(hash, 0);\n      return hash;\n    }\n    static calculateSingleHashCode(parent, returnState) {\n      let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);\n      hash = MurmurHash_1.MurmurHash.update(hash, parent);\n      hash = MurmurHash_1.MurmurHash.update(hash, returnState);\n      hash = MurmurHash_1.MurmurHash.finish(hash, 2);\n      return hash;\n    }\n    static calculateHashCode(parents, returnStates) {\n      let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);\n      for (let parent of parents) {\n        hash = MurmurHash_1.MurmurHash.update(hash, parent);\n      }\n      for (let returnState of returnStates) {\n        hash = MurmurHash_1.MurmurHash.update(hash, returnState);\n      }\n      hash = MurmurHash_1.MurmurHash.finish(hash, 2 * parents.length);\n      return hash;\n    }\n    static fromRuleContext(atn, outerContext, fullContext = true) {\n      if (outerContext.isEmpty) {\n        return fullContext ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL;\n      }\n      let parent;\n      if (outerContext._parent) {\n        parent = PredictionContext.fromRuleContext(atn, outerContext._parent, fullContext);\n      } else {\n        parent = fullContext ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL;\n      }\n      let state = atn.states[outerContext.invokingState];\n      let transition = state.transition(0);\n      return parent.getChild(transition.followState.stateNumber);\n    }\n    static addEmptyContext(context) {\n      return context.addEmptyContext();\n    }\n    static removeEmptyContext(context) {\n      return context.removeEmptyContext();\n    }\n    static join(context0, context1, contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED) {\n      if (context0 === context1) {\n        return context0;\n      }\n      if (context0.isEmpty) {\n        return PredictionContext.isEmptyLocal(context0) ? context0 : PredictionContext.addEmptyContext(context1);\n      } else if (context1.isEmpty) {\n        return PredictionContext.isEmptyLocal(context1) ? context1 : PredictionContext.addEmptyContext(context0);\n      }\n      let context0size = context0.size;\n      let context1size = context1.size;\n      if (context0size === 1 && context1size === 1 && context0.getReturnState(0) === context1.getReturnState(0)) {\n        let merged = contextCache.join(context0.getParent(0), context1.getParent(0));\n        if (merged === context0.getParent(0)) {\n          return context0;\n        } else if (merged === context1.getParent(0)) {\n          return context1;\n        } else {\n          return merged.getChild(context0.getReturnState(0));\n        }\n      }\n      let count = 0;\n      let parentsList = new Array(context0size + context1size);\n      let returnStatesList = new Array(parentsList.length);\n      let leftIndex = 0;\n      let rightIndex = 0;\n      let canReturnLeft = true;\n      let canReturnRight = true;\n      while (leftIndex < context0size && rightIndex < context1size) {\n        if (context0.getReturnState(leftIndex) === context1.getReturnState(rightIndex)) {\n          parentsList[count] = contextCache.join(context0.getParent(leftIndex), context1.getParent(rightIndex));\n          returnStatesList[count] = context0.getReturnState(leftIndex);\n          canReturnLeft = canReturnLeft && parentsList[count] === context0.getParent(leftIndex);\n          canReturnRight = canReturnRight && parentsList[count] === context1.getParent(rightIndex);\n          leftIndex++;\n          rightIndex++;\n        } else if (context0.getReturnState(leftIndex) < context1.getReturnState(rightIndex)) {\n          parentsList[count] = context0.getParent(leftIndex);\n          returnStatesList[count] = context0.getReturnState(leftIndex);\n          canReturnRight = false;\n          leftIndex++;\n        } else {\n          assert(context1.getReturnState(rightIndex) < context0.getReturnState(leftIndex));\n          parentsList[count] = context1.getParent(rightIndex);\n          returnStatesList[count] = context1.getReturnState(rightIndex);\n          canReturnLeft = false;\n          rightIndex++;\n        }\n        count++;\n      }\n      while (leftIndex < context0size) {\n        parentsList[count] = context0.getParent(leftIndex);\n        returnStatesList[count] = context0.getReturnState(leftIndex);\n        leftIndex++;\n        canReturnRight = false;\n        count++;\n      }\n      while (rightIndex < context1size) {\n        parentsList[count] = context1.getParent(rightIndex);\n        returnStatesList[count] = context1.getReturnState(rightIndex);\n        rightIndex++;\n        canReturnLeft = false;\n        count++;\n      }\n      if (canReturnLeft) {\n        return context0;\n      } else if (canReturnRight) {\n        return context1;\n      }\n      if (count < parentsList.length) {\n        parentsList = parentsList.slice(0, count);\n        returnStatesList = returnStatesList.slice(0, count);\n      }\n      if (parentsList.length === 0) {\n        return PredictionContext.EMPTY_FULL;\n      } else if (parentsList.length === 1) {\n        return new SingletonPredictionContext(parentsList[0], returnStatesList[0]);\n      } else {\n        return new ArrayPredictionContext(parentsList, returnStatesList);\n      }\n    }\n    static isEmptyLocal(context) {\n      return context === PredictionContext.EMPTY_LOCAL;\n    }\n    static getCachedContext(context, contextCache, visited) {\n      if (context.isEmpty) {\n        return context;\n      }\n      let existing = visited.get(context);\n      if (existing) {\n        return existing;\n      }\n      existing = contextCache.get(context);\n      if (existing) {\n        visited.put(context, existing);\n        return existing;\n      }\n      let changed = false;\n      let parents = new Array(context.size);\n      for (let i = 0; i < parents.length; i++) {\n        let parent = PredictionContext.getCachedContext(context.getParent(i), contextCache, visited);\n        if (changed || parent !== context.getParent(i)) {\n          if (!changed) {\n            parents = new Array(context.size);\n            for (let j = 0; j < context.size; j++) {\n              parents[j] = context.getParent(j);\n            }\n            changed = true;\n          }\n          parents[i] = parent;\n        }\n      }\n      if (!changed) {\n        existing = contextCache.putIfAbsent(context, context);\n        visited.put(context, existing != null ? existing : context);\n        return context;\n      }\n      let updated;\n      if (parents.length === 1) {\n        updated = new SingletonPredictionContext(parents[0], context.getReturnState(0));\n      } else {\n        let returnStates = new Array(context.size);\n        for (let i = 0; i < context.size; i++) {\n          returnStates[i] = context.getReturnState(i);\n        }\n        updated = new ArrayPredictionContext(parents, returnStates, context.hashCode());\n      }\n      existing = contextCache.putIfAbsent(updated, updated);\n      visited.put(updated, existing || updated);\n      visited.put(context, existing || updated);\n      return updated;\n    }\n    appendSingleContext(returnContext, contextCache) {\n      return this.appendContext(PredictionContext.EMPTY_FULL.getChild(returnContext), contextCache);\n    }\n    getChild(returnState) {\n      return new SingletonPredictionContext(this, returnState);\n    }\n    hashCode() {\n      return this.cachedHashCode;\n    }\n    toStrings(recognizer, currentState, stop = PredictionContext.EMPTY_FULL) {\n      let result = [];\n      outer:\n        for (let perm = 0; ; perm++) {\n          let offset = 0;\n          let last = true;\n          let p = this;\n          let stateNumber = currentState;\n          let localBuffer = \"\";\n          localBuffer += \"[\";\n          while (!p.isEmpty && p !== stop) {\n            let index = 0;\n            if (p.size > 0) {\n              let bits = 1;\n              while (1 << bits >>> 0 < p.size) {\n                bits++;\n              }\n              let mask = (1 << bits >>> 0) - 1;\n              index = perm >> offset & mask;\n              last = last && index >= p.size - 1;\n              if (index >= p.size) {\n                continue outer;\n              }\n              offset += bits;\n            }\n            if (recognizer) {\n              if (localBuffer.length > 1) {\n                localBuffer += \" \";\n              }\n              let atn = recognizer.atn;\n              let s = atn.states[stateNumber];\n              let ruleName = recognizer.ruleNames[s.ruleIndex];\n              localBuffer += ruleName;\n            } else if (p.getReturnState(index) !== PredictionContext.EMPTY_FULL_STATE_KEY) {\n              if (!p.isEmpty) {\n                if (localBuffer.length > 1) {\n                  localBuffer += \" \";\n                }\n                localBuffer += p.getReturnState(index);\n              }\n            }\n            stateNumber = p.getReturnState(index);\n            p = p.getParent(index);\n          }\n          localBuffer += \"]\";\n          result.push(localBuffer);\n          if (last) {\n            break;\n          }\n        }\n      return result;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], PredictionContext.prototype, \"hashCode\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n  ], PredictionContext, \"join\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n  ], PredictionContext, \"getCachedContext\", null);\n  exports.PredictionContext = PredictionContext;\n  var EmptyPredictionContext = class extends PredictionContext {\n    constructor(fullContext) {\n      super(PredictionContext.calculateEmptyHashCode());\n      this.fullContext = fullContext;\n    }\n    get isFullContext() {\n      return this.fullContext;\n    }\n    addEmptyContext() {\n      return this;\n    }\n    removeEmptyContext() {\n      throw new Error(\"Cannot remove the empty context from itself.\");\n    }\n    getParent(index) {\n      throw new Error(\"index out of bounds\");\n    }\n    getReturnState(index) {\n      throw new Error(\"index out of bounds\");\n    }\n    findReturnState(returnState) {\n      return -1;\n    }\n    get size() {\n      return 0;\n    }\n    appendSingleContext(returnContext, contextCache) {\n      return contextCache.getChild(this, returnContext);\n    }\n    appendContext(suffix, contextCache) {\n      return suffix;\n    }\n    get isEmpty() {\n      return true;\n    }\n    get hasEmpty() {\n      return true;\n    }\n    equals(o) {\n      return this === o;\n    }\n    toStrings(recognizer, currentState, stop) {\n      return [\"[]\"];\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], EmptyPredictionContext.prototype, \"addEmptyContext\", null);\n  __decorate([\n    Decorators_1.Override\n  ], EmptyPredictionContext.prototype, \"removeEmptyContext\", null);\n  __decorate([\n    Decorators_1.Override\n  ], EmptyPredictionContext.prototype, \"getParent\", null);\n  __decorate([\n    Decorators_1.Override\n  ], EmptyPredictionContext.prototype, \"getReturnState\", null);\n  __decorate([\n    Decorators_1.Override\n  ], EmptyPredictionContext.prototype, \"findReturnState\", null);\n  __decorate([\n    Decorators_1.Override\n  ], EmptyPredictionContext.prototype, \"size\", null);\n  __decorate([\n    Decorators_1.Override\n  ], EmptyPredictionContext.prototype, \"appendSingleContext\", null);\n  __decorate([\n    Decorators_1.Override\n  ], EmptyPredictionContext.prototype, \"appendContext\", null);\n  __decorate([\n    Decorators_1.Override\n  ], EmptyPredictionContext.prototype, \"isEmpty\", null);\n  __decorate([\n    Decorators_1.Override\n  ], EmptyPredictionContext.prototype, \"hasEmpty\", null);\n  __decorate([\n    Decorators_1.Override\n  ], EmptyPredictionContext.prototype, \"equals\", null);\n  __decorate([\n    Decorators_1.Override\n  ], EmptyPredictionContext.prototype, \"toStrings\", null);\n  var ArrayPredictionContext = class ArrayPredictionContext2 extends PredictionContext {\n    constructor(parents, returnStates, hashCode) {\n      super(hashCode || PredictionContext.calculateHashCode(parents, returnStates));\n      assert(parents.length === returnStates.length);\n      assert(returnStates.length > 1 || returnStates[0] !== PredictionContext.EMPTY_FULL_STATE_KEY, \"Should be using PredictionContext.EMPTY instead.\");\n      this.parents = parents;\n      this.returnStates = returnStates;\n    }\n    getParent(index) {\n      return this.parents[index];\n    }\n    getReturnState(index) {\n      return this.returnStates[index];\n    }\n    findReturnState(returnState) {\n      return Arrays_1.Arrays.binarySearch(this.returnStates, returnState);\n    }\n    get size() {\n      return this.returnStates.length;\n    }\n    get isEmpty() {\n      return false;\n    }\n    get hasEmpty() {\n      return this.returnStates[this.returnStates.length - 1] === PredictionContext.EMPTY_FULL_STATE_KEY;\n    }\n    addEmptyContext() {\n      if (this.hasEmpty) {\n        return this;\n      }\n      let parents2 = this.parents.slice(0);\n      let returnStates2 = this.returnStates.slice(0);\n      parents2.push(PredictionContext.EMPTY_FULL);\n      returnStates2.push(PredictionContext.EMPTY_FULL_STATE_KEY);\n      return new ArrayPredictionContext2(parents2, returnStates2);\n    }\n    removeEmptyContext() {\n      if (!this.hasEmpty) {\n        return this;\n      }\n      if (this.returnStates.length === 2) {\n        return new SingletonPredictionContext(this.parents[0], this.returnStates[0]);\n      } else {\n        let parents2 = this.parents.slice(0, this.parents.length - 1);\n        let returnStates2 = this.returnStates.slice(0, this.returnStates.length - 1);\n        return new ArrayPredictionContext2(parents2, returnStates2);\n      }\n    }\n    appendContext(suffix, contextCache) {\n      return ArrayPredictionContext2.appendContextImpl(this, suffix, new PredictionContext.IdentityHashMap());\n    }\n    static appendContextImpl(context, suffix, visited) {\n      if (suffix.isEmpty) {\n        if (PredictionContext.isEmptyLocal(suffix)) {\n          if (context.hasEmpty) {\n            return PredictionContext.EMPTY_LOCAL;\n          }\n          throw new Error(\"what to do here?\");\n        }\n        return context;\n      }\n      if (suffix.size !== 1) {\n        throw new Error(\"Appending a tree suffix is not yet supported.\");\n      }\n      let result = visited.get(context);\n      if (!result) {\n        if (context.isEmpty) {\n          result = suffix;\n        } else {\n          let parentCount = context.size;\n          if (context.hasEmpty) {\n            parentCount--;\n          }\n          let updatedParents = new Array(parentCount);\n          let updatedReturnStates = new Array(parentCount);\n          for (let i = 0; i < parentCount; i++) {\n            updatedReturnStates[i] = context.getReturnState(i);\n          }\n          for (let i = 0; i < parentCount; i++) {\n            updatedParents[i] = ArrayPredictionContext2.appendContextImpl(context.getParent(i), suffix, visited);\n          }\n          if (updatedParents.length === 1) {\n            result = new SingletonPredictionContext(updatedParents[0], updatedReturnStates[0]);\n          } else {\n            assert(updatedParents.length > 1);\n            result = new ArrayPredictionContext2(updatedParents, updatedReturnStates);\n          }\n          if (context.hasEmpty) {\n            result = PredictionContext.join(result, suffix);\n          }\n        }\n        visited.put(context, result);\n      }\n      return result;\n    }\n    equals(o) {\n      if (this === o) {\n        return true;\n      } else if (!(o instanceof ArrayPredictionContext2)) {\n        return false;\n      }\n      if (this.hashCode() !== o.hashCode()) {\n        return false;\n      }\n      let other = o;\n      return this.equalsImpl(other, new Array2DHashSet_1.Array2DHashSet());\n    }\n    equalsImpl(other, visited) {\n      let selfWorkList = [];\n      let otherWorkList = [];\n      selfWorkList.push(this);\n      otherWorkList.push(other);\n      while (true) {\n        let currentSelf = selfWorkList.pop();\n        let currentOther = otherWorkList.pop();\n        if (!currentSelf || !currentOther) {\n          break;\n        }\n        let operands = new PredictionContextCache_1.PredictionContextCache.IdentityCommutativePredictionContextOperands(currentSelf, currentOther);\n        if (!visited.add(operands)) {\n          continue;\n        }\n        let selfSize = operands.x.size;\n        if (selfSize === 0) {\n          if (!operands.x.equals(operands.y)) {\n            return false;\n          }\n          continue;\n        }\n        let otherSize = operands.y.size;\n        if (selfSize !== otherSize) {\n          return false;\n        }\n        for (let i = 0; i < selfSize; i++) {\n          if (operands.x.getReturnState(i) !== operands.y.getReturnState(i)) {\n            return false;\n          }\n          let selfParent = operands.x.getParent(i);\n          let otherParent = operands.y.getParent(i);\n          if (selfParent.hashCode() !== otherParent.hashCode()) {\n            return false;\n          }\n          if (selfParent !== otherParent) {\n            selfWorkList.push(selfParent);\n            otherWorkList.push(otherParent);\n          }\n        }\n      }\n      return true;\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], ArrayPredictionContext.prototype, \"parents\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], ArrayPredictionContext.prototype, \"returnStates\", void 0);\n  __decorate([\n    Decorators_1.Override\n  ], ArrayPredictionContext.prototype, \"getParent\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ArrayPredictionContext.prototype, \"getReturnState\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ArrayPredictionContext.prototype, \"findReturnState\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ArrayPredictionContext.prototype, \"size\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ArrayPredictionContext.prototype, \"isEmpty\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ArrayPredictionContext.prototype, \"hasEmpty\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ArrayPredictionContext.prototype, \"addEmptyContext\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ArrayPredictionContext.prototype, \"removeEmptyContext\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ArrayPredictionContext.prototype, \"appendContext\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ArrayPredictionContext.prototype, \"equals\", null);\n  ArrayPredictionContext = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], ArrayPredictionContext);\n  var SingletonPredictionContext = class SingletonPredictionContext2 extends PredictionContext {\n    constructor(parent, returnState) {\n      super(PredictionContext.calculateSingleHashCode(parent, returnState));\n      this.parent = parent;\n      this.returnState = returnState;\n    }\n    getParent(index) {\n      return this.parent;\n    }\n    getReturnState(index) {\n      return this.returnState;\n    }\n    findReturnState(returnState) {\n      return this.returnState === returnState ? 0 : -1;\n    }\n    get size() {\n      return 1;\n    }\n    get isEmpty() {\n      return false;\n    }\n    get hasEmpty() {\n      return false;\n    }\n    appendContext(suffix, contextCache) {\n      return contextCache.getChild(this.parent.appendContext(suffix, contextCache), this.returnState);\n    }\n    addEmptyContext() {\n      let parents = [this.parent, PredictionContext.EMPTY_FULL];\n      let returnStates = [this.returnState, PredictionContext.EMPTY_FULL_STATE_KEY];\n      return new ArrayPredictionContext(parents, returnStates);\n    }\n    removeEmptyContext() {\n      return this;\n    }\n    equals(o) {\n      if (o === this) {\n        return true;\n      } else if (!(o instanceof SingletonPredictionContext2)) {\n        return false;\n      }\n      let other = o;\n      if (this.hashCode() !== other.hashCode()) {\n        return false;\n      }\n      return this.returnState === other.returnState && this.parent.equals(other.parent);\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], SingletonPredictionContext.prototype, \"parent\", void 0);\n  __decorate([\n    Decorators_1.Override\n  ], SingletonPredictionContext.prototype, \"getParent\", null);\n  __decorate([\n    Decorators_1.Override\n  ], SingletonPredictionContext.prototype, \"getReturnState\", null);\n  __decorate([\n    Decorators_1.Override\n  ], SingletonPredictionContext.prototype, \"findReturnState\", null);\n  __decorate([\n    Decorators_1.Override\n  ], SingletonPredictionContext.prototype, \"size\", null);\n  __decorate([\n    Decorators_1.Override\n  ], SingletonPredictionContext.prototype, \"isEmpty\", null);\n  __decorate([\n    Decorators_1.Override\n  ], SingletonPredictionContext.prototype, \"hasEmpty\", null);\n  __decorate([\n    Decorators_1.Override\n  ], SingletonPredictionContext.prototype, \"appendContext\", null);\n  __decorate([\n    Decorators_1.Override\n  ], SingletonPredictionContext.prototype, \"addEmptyContext\", null);\n  __decorate([\n    Decorators_1.Override\n  ], SingletonPredictionContext.prototype, \"removeEmptyContext\", null);\n  __decorate([\n    Decorators_1.Override\n  ], SingletonPredictionContext.prototype, \"equals\", null);\n  SingletonPredictionContext = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], SingletonPredictionContext);\n  exports.SingletonPredictionContext = SingletonPredictionContext;\n  (function(PredictionContext2) {\n    PredictionContext2.EMPTY_LOCAL = new EmptyPredictionContext(false);\n    PredictionContext2.EMPTY_FULL = new EmptyPredictionContext(true);\n    PredictionContext2.EMPTY_LOCAL_STATE_KEY = -(1 << 31 >>> 0);\n    PredictionContext2.EMPTY_FULL_STATE_KEY = (1 << 31 >>> 0) - 1;\n    class IdentityHashMap extends Array2DHashMap_1.Array2DHashMap {\n      constructor() {\n        super(IdentityEqualityComparator.INSTANCE);\n      }\n    }\n    PredictionContext2.IdentityHashMap = IdentityHashMap;\n    class IdentityEqualityComparator {\n      IdentityEqualityComparator() {\n      }\n      hashCode(obj) {\n        return obj.hashCode();\n      }\n      equals(a, b) {\n        return a === b;\n      }\n    }\n    IdentityEqualityComparator.INSTANCE = new IdentityEqualityComparator();\n    __decorate([\n      Decorators_1.Override\n    ], IdentityEqualityComparator.prototype, \"hashCode\", null);\n    __decorate([\n      Decorators_1.Override\n    ], IdentityEqualityComparator.prototype, \"equals\", null);\n    PredictionContext2.IdentityEqualityComparator = IdentityEqualityComparator;\n  })(PredictionContext = exports.PredictionContext || (exports.PredictionContext = {}));\n});\n\n// node_modules/antlr4ts/atn/ATNConfig.js\nvar require_ATNConfig = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ATNConfig = void 0;\n  var Array2DHashMap_1 = require_Array2DHashMap();\n  var DecisionState_1 = require_DecisionState();\n  var MurmurHash_1 = require_MurmurHash();\n  var Decorators_1 = require_Decorators();\n  var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();\n  var PredictionContext_1 = require_PredictionContext();\n  var SemanticContext_1 = require_SemanticContext();\n  var assert = __webpack_require__(/*! assert */ \"assert\");\n  var SUPPRESS_PRECEDENCE_FILTER = 2147483648;\n  var ATNConfig = class ATNConfig2 {\n    constructor(state, altOrConfig, context) {\n      if (typeof altOrConfig === \"number\") {\n        assert((altOrConfig & 16777215) === altOrConfig);\n        this._state = state;\n        this.altAndOuterContextDepth = altOrConfig;\n        this._context = context;\n      } else {\n        this._state = state;\n        this.altAndOuterContextDepth = altOrConfig.altAndOuterContextDepth;\n        this._context = context;\n      }\n    }\n    static create(state, alt, context, semanticContext = SemanticContext_1.SemanticContext.NONE, lexerActionExecutor) {\n      if (semanticContext !== SemanticContext_1.SemanticContext.NONE) {\n        if (lexerActionExecutor != null) {\n          return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, alt, context, false);\n        } else {\n          return new SemanticContextATNConfig(semanticContext, state, alt, context);\n        }\n      } else if (lexerActionExecutor != null) {\n        return new ActionATNConfig(lexerActionExecutor, state, alt, context, false);\n      } else {\n        return new ATNConfig2(state, alt, context);\n      }\n    }\n    get state() {\n      return this._state;\n    }\n    get alt() {\n      return this.altAndOuterContextDepth & 16777215;\n    }\n    get context() {\n      return this._context;\n    }\n    set context(context) {\n      this._context = context;\n    }\n    get reachesIntoOuterContext() {\n      return this.outerContextDepth !== 0;\n    }\n    get outerContextDepth() {\n      return this.altAndOuterContextDepth >>> 24 & 127;\n    }\n    set outerContextDepth(outerContextDepth) {\n      assert(outerContextDepth >= 0);\n      outerContextDepth = Math.min(outerContextDepth, 127);\n      this.altAndOuterContextDepth = outerContextDepth << 24 | (this.altAndOuterContextDepth & ~2130706432) >>> 0;\n    }\n    get lexerActionExecutor() {\n      return void 0;\n    }\n    get semanticContext() {\n      return SemanticContext_1.SemanticContext.NONE;\n    }\n    get hasPassedThroughNonGreedyDecision() {\n      return false;\n    }\n    clone() {\n      return this.transform(this.state, false);\n    }\n    transform(state, checkNonGreedy, arg2) {\n      if (arg2 == null) {\n        return this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);\n      } else if (arg2 instanceof PredictionContext_1.PredictionContext) {\n        return this.transformImpl(state, arg2, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);\n      } else if (arg2 instanceof SemanticContext_1.SemanticContext) {\n        return this.transformImpl(state, this._context, arg2, checkNonGreedy, this.lexerActionExecutor);\n      } else {\n        return this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, arg2);\n      }\n    }\n    transformImpl(state, context, semanticContext, checkNonGreedy, lexerActionExecutor) {\n      let passedThroughNonGreedy = checkNonGreedy && ATNConfig2.checkNonGreedyDecision(this, state);\n      if (semanticContext !== SemanticContext_1.SemanticContext.NONE) {\n        if (lexerActionExecutor != null || passedThroughNonGreedy) {\n          return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, this, context, passedThroughNonGreedy);\n        } else {\n          return new SemanticContextATNConfig(semanticContext, state, this, context);\n        }\n      } else if (lexerActionExecutor != null || passedThroughNonGreedy) {\n        return new ActionATNConfig(lexerActionExecutor, state, this, context, passedThroughNonGreedy);\n      } else {\n        return new ATNConfig2(state, this, context);\n      }\n    }\n    static checkNonGreedyDecision(source, target) {\n      return source.hasPassedThroughNonGreedyDecision || target instanceof DecisionState_1.DecisionState && target.nonGreedy;\n    }\n    appendContext(context, contextCache) {\n      if (typeof context === \"number\") {\n        let appendedContext = this.context.appendSingleContext(context, contextCache);\n        let result = this.transform(this.state, false, appendedContext);\n        return result;\n      } else {\n        let appendedContext = this.context.appendContext(context, contextCache);\n        let result = this.transform(this.state, false, appendedContext);\n        return result;\n      }\n    }\n    contains(subconfig) {\n      if (this.state.stateNumber !== subconfig.state.stateNumber || this.alt !== subconfig.alt || !this.semanticContext.equals(subconfig.semanticContext)) {\n        return false;\n      }\n      let leftWorkList = [];\n      let rightWorkList = [];\n      leftWorkList.push(this.context);\n      rightWorkList.push(subconfig.context);\n      while (true) {\n        let left = leftWorkList.pop();\n        let right = rightWorkList.pop();\n        if (!left || !right) {\n          break;\n        }\n        if (left === right) {\n          return true;\n        }\n        if (left.size < right.size) {\n          return false;\n        }\n        if (right.isEmpty) {\n          return left.hasEmpty;\n        } else {\n          for (let i = 0; i < right.size; i++) {\n            let index = left.findReturnState(right.getReturnState(i));\n            if (index < 0) {\n              return false;\n            }\n            leftWorkList.push(left.getParent(index));\n            rightWorkList.push(right.getParent(i));\n          }\n        }\n      }\n      return false;\n    }\n    get isPrecedenceFilterSuppressed() {\n      return (this.altAndOuterContextDepth & SUPPRESS_PRECEDENCE_FILTER) !== 0;\n    }\n    set isPrecedenceFilterSuppressed(value) {\n      if (value) {\n        this.altAndOuterContextDepth |= SUPPRESS_PRECEDENCE_FILTER;\n      } else {\n        this.altAndOuterContextDepth &= ~SUPPRESS_PRECEDENCE_FILTER;\n      }\n    }\n    equals(o) {\n      if (this === o) {\n        return true;\n      } else if (!(o instanceof ATNConfig2)) {\n        return false;\n      }\n      return this.state.stateNumber === o.state.stateNumber && this.alt === o.alt && this.reachesIntoOuterContext === o.reachesIntoOuterContext && this.context.equals(o.context) && this.semanticContext.equals(o.semanticContext) && this.isPrecedenceFilterSuppressed === o.isPrecedenceFilterSuppressed && this.hasPassedThroughNonGreedyDecision === o.hasPassedThroughNonGreedyDecision && ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(this.lexerActionExecutor, o.lexerActionExecutor);\n    }\n    hashCode() {\n      let hashCode = MurmurHash_1.MurmurHash.initialize(7);\n      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.state.stateNumber);\n      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.alt);\n      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.reachesIntoOuterContext ? 1 : 0);\n      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.context);\n      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.semanticContext);\n      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.hasPassedThroughNonGreedyDecision ? 1 : 0);\n      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.lexerActionExecutor);\n      hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 7);\n      return hashCode;\n    }\n    toDotString() {\n      let builder = \"\";\n      builder += \"digraph G {\\n\";\n      builder += \"rankdir=LR;\\n\";\n      let visited = new Array2DHashMap_1.Array2DHashMap(PredictionContext_1.PredictionContext.IdentityEqualityComparator.INSTANCE);\n      let workList = [];\n      function getOrAddContext(context) {\n        let newNumber = visited.size;\n        let result = visited.putIfAbsent(context, newNumber);\n        if (result != null) {\n          return result;\n        }\n        workList.push(context);\n        return newNumber;\n      }\n      workList.push(this.context);\n      visited.put(this.context, 0);\n      while (true) {\n        let current = workList.pop();\n        if (!current) {\n          break;\n        }\n        for (let i = 0; i < current.size; i++) {\n          builder += \"  s\" + getOrAddContext(current);\n          builder += \"->\";\n          builder += \"s\" + getOrAddContext(current.getParent(i));\n          builder += '[label=\"' + current.getReturnState(i) + '\"];\\n';\n        }\n      }\n      builder += \"}\\n\";\n      return builder.toString();\n    }\n    toString(recog, showAlt, showContext) {\n      if (showContext == null) {\n        showContext = showAlt != null;\n      }\n      if (showAlt == null) {\n        showAlt = true;\n      }\n      let buf = \"\";\n      let contexts;\n      if (showContext) {\n        contexts = this.context.toStrings(recog, this.state.stateNumber);\n      } else {\n        contexts = [\"?\"];\n      }\n      let first = true;\n      for (let contextDesc of contexts) {\n        if (first) {\n          first = false;\n        } else {\n          buf += \", \";\n        }\n        buf += \"(\";\n        buf += this.state;\n        if (showAlt) {\n          buf += \",\";\n          buf += this.alt;\n        }\n        if (this.context) {\n          buf += \",\";\n          buf += contextDesc;\n        }\n        if (this.semanticContext !== SemanticContext_1.SemanticContext.NONE) {\n          buf += \",\";\n          buf += this.semanticContext;\n        }\n        if (this.reachesIntoOuterContext) {\n          buf += \",up=\" + this.outerContextDepth;\n        }\n        buf += \")\";\n      }\n      return buf.toString();\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], ATNConfig.prototype, \"_state\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], ATNConfig.prototype, \"_context\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], ATNConfig.prototype, \"state\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n  ], ATNConfig.prototype, \"context\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], ATNConfig.prototype, \"semanticContext\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ATNConfig.prototype, \"clone\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n  ], ATNConfig.prototype, \"transformImpl\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ATNConfig.prototype, \"equals\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ATNConfig.prototype, \"hashCode\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(3, Decorators_1.NotNull)\n  ], ATNConfig, \"create\", null);\n  ATNConfig = __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n  ], ATNConfig);\n  exports.ATNConfig = ATNConfig;\n  var SemanticContextATNConfig = class SemanticContextATNConfig extends ATNConfig {\n    constructor(semanticContext, state, altOrConfig, context) {\n      if (typeof altOrConfig === \"number\") {\n        super(state, altOrConfig, context);\n      } else {\n        super(state, altOrConfig, context);\n      }\n      this._semanticContext = semanticContext;\n    }\n    get semanticContext() {\n      return this._semanticContext;\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], SemanticContextATNConfig.prototype, \"_semanticContext\", void 0);\n  __decorate([\n    Decorators_1.Override\n  ], SemanticContextATNConfig.prototype, \"semanticContext\", null);\n  SemanticContextATNConfig = __decorate([\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n  ], SemanticContextATNConfig);\n  var ActionATNConfig = class ActionATNConfig extends ATNConfig {\n    constructor(lexerActionExecutor, state, altOrConfig, context, passedThroughNonGreedyDecision) {\n      if (typeof altOrConfig === \"number\") {\n        super(state, altOrConfig, context);\n      } else {\n        super(state, altOrConfig, context);\n        if (altOrConfig.semanticContext !== SemanticContext_1.SemanticContext.NONE) {\n          throw new Error(\"Not supported\");\n        }\n      }\n      this._lexerActionExecutor = lexerActionExecutor;\n      this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;\n    }\n    get lexerActionExecutor() {\n      return this._lexerActionExecutor;\n    }\n    get hasPassedThroughNonGreedyDecision() {\n      return this.passedThroughNonGreedyDecision;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], ActionATNConfig.prototype, \"lexerActionExecutor\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ActionATNConfig.prototype, \"hasPassedThroughNonGreedyDecision\", null);\n  ActionATNConfig = __decorate([\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n  ], ActionATNConfig);\n  var ActionSemanticContextATNConfig = class ActionSemanticContextATNConfig extends SemanticContextATNConfig {\n    constructor(lexerActionExecutor, semanticContext, state, altOrConfig, context, passedThroughNonGreedyDecision) {\n      if (typeof altOrConfig === \"number\") {\n        super(semanticContext, state, altOrConfig, context);\n      } else {\n        super(semanticContext, state, altOrConfig, context);\n      }\n      this._lexerActionExecutor = lexerActionExecutor;\n      this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;\n    }\n    get lexerActionExecutor() {\n      return this._lexerActionExecutor;\n    }\n    get hasPassedThroughNonGreedyDecision() {\n      return this.passedThroughNonGreedyDecision;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], ActionSemanticContextATNConfig.prototype, \"lexerActionExecutor\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ActionSemanticContextATNConfig.prototype, \"hasPassedThroughNonGreedyDecision\", null);\n  ActionSemanticContextATNConfig = __decorate([\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n  ], ActionSemanticContextATNConfig);\n});\n\n// node_modules/antlr4ts/misc/BitSet.js\nvar require_BitSet = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.BitSet = void 0;\n  var util = __webpack_require__(/*! util */ \"util\");\n  var MurmurHash_1 = require_MurmurHash();\n  var EMPTY_DATA = new Uint16Array(0);\n  function getIndex(bitNumber) {\n    return bitNumber >>> 4;\n  }\n  function unIndex(n) {\n    return n * 16;\n  }\n  function findLSBSet(word) {\n    let bit = 1;\n    for (let i = 0; i < 16; i++) {\n      if ((word & bit) !== 0) {\n        return i;\n      }\n      bit = bit << 1 >>> 0;\n    }\n    throw new RangeError(\"No specified bit found\");\n  }\n  function findMSBSet(word) {\n    let bit = 1 << 15 >>> 0;\n    for (let i = 15; i >= 0; i--) {\n      if ((word & bit) !== 0) {\n        return i;\n      }\n      bit = bit >>> 1;\n    }\n    throw new RangeError(\"No specified bit found\");\n  }\n  function bitsFor(fromBit, toBit) {\n    fromBit &= 15;\n    toBit &= 15;\n    if (fromBit === toBit) {\n      return 1 << fromBit >>> 0;\n    }\n    return 65535 >>> 15 - toBit ^ 65535 >>> 16 - fromBit;\n  }\n  var POP_CNT = new Uint8Array(65536);\n  for (let i = 0; i < 16; i++) {\n    const stride = 1 << i >>> 0;\n    let index = 0;\n    while (index < POP_CNT.length) {\n      index += stride;\n      for (let j = 0; j < stride; j++) {\n        POP_CNT[index]++;\n        index++;\n      }\n    }\n  }\n  var BitSet = class {\n    constructor(arg) {\n      if (!arg) {\n        this.data = EMPTY_DATA;\n      } else if (typeof arg === \"number\") {\n        if (arg < 0) {\n          throw new RangeError(\"nbits cannot be negative\");\n        } else {\n          this.data = new Uint16Array(getIndex(arg - 1) + 1);\n        }\n      } else {\n        if (arg instanceof BitSet) {\n          this.data = arg.data.slice(0);\n        } else {\n          let max = -1;\n          for (let v of arg) {\n            if (max < v) {\n              max = v;\n            }\n          }\n          this.data = new Uint16Array(getIndex(max - 1) + 1);\n          for (let v of arg) {\n            this.set(v);\n          }\n        }\n      }\n    }\n    and(set) {\n      const data = this.data;\n      const other = set.data;\n      const words = Math.min(data.length, other.length);\n      let lastWord = -1;\n      for (let i = 0; i < words; i++) {\n        let value = data[i] &= other[i];\n        if (value !== 0) {\n          lastWord = i;\n        }\n      }\n      if (lastWord === -1) {\n        this.data = EMPTY_DATA;\n      }\n      if (lastWord < data.length - 1) {\n        this.data = data.slice(0, lastWord + 1);\n      }\n    }\n    andNot(set) {\n      const data = this.data;\n      const other = set.data;\n      const words = Math.min(data.length, other.length);\n      let lastWord = -1;\n      for (let i = 0; i < words; i++) {\n        let value = data[i] &= other[i] ^ 65535;\n        if (value !== 0) {\n          lastWord = i;\n        }\n      }\n      if (lastWord === -1) {\n        this.data = EMPTY_DATA;\n      }\n      if (lastWord < data.length - 1) {\n        this.data = data.slice(0, lastWord + 1);\n      }\n    }\n    cardinality() {\n      if (this.isEmpty) {\n        return 0;\n      }\n      const data = this.data;\n      const length = data.length;\n      let result = 0;\n      for (let i = 0; i < length; i++) {\n        result += POP_CNT[data[i]];\n      }\n      return result;\n    }\n    clear(fromIndex, toIndex) {\n      if (fromIndex == null) {\n        this.data.fill(0);\n      } else if (toIndex == null) {\n        this.set(fromIndex, false);\n      } else {\n        this.set(fromIndex, toIndex, false);\n      }\n    }\n    flip(fromIndex, toIndex) {\n      if (toIndex == null) {\n        toIndex = fromIndex;\n      }\n      if (fromIndex < 0 || toIndex < fromIndex) {\n        throw new RangeError();\n      }\n      let word = getIndex(fromIndex);\n      const lastWord = getIndex(toIndex);\n      if (word === lastWord) {\n        this.data[word] ^= bitsFor(fromIndex, toIndex);\n      } else {\n        this.data[word++] ^= bitsFor(fromIndex, 15);\n        while (word < lastWord) {\n          this.data[word++] ^= 65535;\n        }\n        this.data[word++] ^= bitsFor(0, toIndex);\n      }\n    }\n    get(fromIndex, toIndex) {\n      if (toIndex === void 0) {\n        return !!(this.data[getIndex(fromIndex)] & bitsFor(fromIndex, fromIndex));\n      } else {\n        let result = new BitSet(toIndex + 1);\n        for (let i = fromIndex; i <= toIndex; i++) {\n          result.set(i, this.get(i));\n        }\n        return result;\n      }\n    }\n    intersects(set) {\n      let smallerLength = Math.min(this.length(), set.length());\n      if (smallerLength === 0) {\n        return false;\n      }\n      let bound = getIndex(smallerLength - 1);\n      for (let i = 0; i <= bound; i++) {\n        if ((this.data[i] & set.data[i]) !== 0) {\n          return true;\n        }\n      }\n      return false;\n    }\n    get isEmpty() {\n      return this.length() === 0;\n    }\n    length() {\n      if (!this.data.length) {\n        return 0;\n      }\n      return this.previousSetBit(unIndex(this.data.length) - 1) + 1;\n    }\n    nextClearBit(fromIndex) {\n      if (fromIndex < 0) {\n        throw new RangeError(\"fromIndex cannot be negative\");\n      }\n      const data = this.data;\n      const length = data.length;\n      let word = getIndex(fromIndex);\n      if (word > length) {\n        return -1;\n      }\n      let ignore = 65535 ^ bitsFor(fromIndex, 15);\n      if ((data[word] | ignore) === 65535) {\n        word++;\n        ignore = 0;\n        for (; word < length; word++) {\n          if (data[word] !== 65535) {\n            break;\n          }\n        }\n        if (word === length) {\n          return -1;\n        }\n      }\n      return unIndex(word) + findLSBSet((data[word] | ignore) ^ 65535);\n    }\n    nextSetBit(fromIndex) {\n      if (fromIndex < 0) {\n        throw new RangeError(\"fromIndex cannot be negative\");\n      }\n      const data = this.data;\n      const length = data.length;\n      let word = getIndex(fromIndex);\n      if (word > length) {\n        return -1;\n      }\n      let mask = bitsFor(fromIndex, 15);\n      if ((data[word] & mask) === 0) {\n        word++;\n        mask = 65535;\n        for (; word < length; word++) {\n          if (data[word] !== 0) {\n            break;\n          }\n        }\n        if (word >= length) {\n          return -1;\n        }\n      }\n      return unIndex(word) + findLSBSet(data[word] & mask);\n    }\n    or(set) {\n      const data = this.data;\n      const other = set.data;\n      const minWords = Math.min(data.length, other.length);\n      const words = Math.max(data.length, other.length);\n      const dest = data.length === words ? data : new Uint16Array(words);\n      let lastWord = -1;\n      for (let i = 0; i < minWords; i++) {\n        let value = dest[i] = data[i] | other[i];\n        if (value !== 0) {\n          lastWord = i;\n        }\n      }\n      const longer = data.length > other.length ? data : other;\n      for (let i = minWords; i < words; i++) {\n        let value = dest[i] = longer[i];\n        if (value !== 0) {\n          lastWord = i;\n        }\n      }\n      if (lastWord === -1) {\n        this.data = EMPTY_DATA;\n      } else if (dest.length === lastWord + 1) {\n        this.data = dest;\n      } else {\n        this.data = dest.slice(0, lastWord);\n      }\n    }\n    previousClearBit(fromIndex) {\n      if (fromIndex < 0) {\n        throw new RangeError(\"fromIndex cannot be negative\");\n      }\n      const data = this.data;\n      const length = data.length;\n      let word = getIndex(fromIndex);\n      if (word >= length) {\n        word = length - 1;\n      }\n      let ignore = 65535 ^ bitsFor(0, fromIndex);\n      if ((data[word] | ignore) === 65535) {\n        ignore = 0;\n        word--;\n        for (; word >= 0; word--) {\n          if (data[word] !== 65535) {\n            break;\n          }\n        }\n        if (word < 0) {\n          return -1;\n        }\n      }\n      return unIndex(word) + findMSBSet((data[word] | ignore) ^ 65535);\n    }\n    previousSetBit(fromIndex) {\n      if (fromIndex < 0) {\n        throw new RangeError(\"fromIndex cannot be negative\");\n      }\n      const data = this.data;\n      const length = data.length;\n      let word = getIndex(fromIndex);\n      if (word >= length) {\n        word = length - 1;\n      }\n      let mask = bitsFor(0, fromIndex);\n      if ((data[word] & mask) === 0) {\n        word--;\n        mask = 65535;\n        for (; word >= 0; word--) {\n          if (data[word] !== 0) {\n            break;\n          }\n        }\n        if (word < 0) {\n          return -1;\n        }\n      }\n      return unIndex(word) + findMSBSet(data[word] & mask);\n    }\n    set(fromIndex, toIndex, value) {\n      if (toIndex === void 0) {\n        toIndex = fromIndex;\n        value = true;\n      } else if (typeof toIndex === \"boolean\") {\n        value = toIndex;\n        toIndex = fromIndex;\n      }\n      if (value === void 0) {\n        value = true;\n      }\n      if (fromIndex < 0 || fromIndex > toIndex) {\n        throw new RangeError();\n      }\n      let word = getIndex(fromIndex);\n      let lastWord = getIndex(toIndex);\n      if (value && lastWord >= this.data.length) {\n        let temp = new Uint16Array(lastWord + 1);\n        this.data.forEach((value2, index) => temp[index] = value2);\n        this.data = temp;\n      } else if (!value) {\n        if (word >= this.data.length) {\n          return;\n        }\n        if (lastWord >= this.data.length) {\n          lastWord = this.data.length - 1;\n          toIndex = this.data.length * 16 - 1;\n        }\n      }\n      if (word === lastWord) {\n        this._setBits(word, value, bitsFor(fromIndex, toIndex));\n      } else {\n        this._setBits(word++, value, bitsFor(fromIndex, 15));\n        while (word < lastWord) {\n          this.data[word++] = value ? 65535 : 0;\n        }\n        this._setBits(word, value, bitsFor(0, toIndex));\n      }\n    }\n    _setBits(word, value, mask) {\n      if (value) {\n        this.data[word] |= mask;\n      } else {\n        this.data[word] &= 65535 ^ mask;\n      }\n    }\n    get size() {\n      return this.data.byteLength * 8;\n    }\n    hashCode() {\n      return MurmurHash_1.MurmurHash.hashCode(this.data, 22);\n    }\n    equals(obj) {\n      if (obj === this) {\n        return true;\n      } else if (!(obj instanceof BitSet)) {\n        return false;\n      }\n      const len = this.length();\n      if (len !== obj.length()) {\n        return false;\n      }\n      if (len === 0) {\n        return true;\n      }\n      let bound = getIndex(len - 1);\n      for (let i = 0; i <= bound; i++) {\n        if (this.data[i] !== obj.data[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    toString() {\n      let result = \"{\";\n      let first = true;\n      for (let i = this.nextSetBit(0); i >= 0; i = this.nextSetBit(i + 1)) {\n        if (first) {\n          first = false;\n        } else {\n          result += \", \";\n        }\n        result += i;\n      }\n      result += \"}\";\n      return result;\n    }\n    xor(set) {\n      const data = this.data;\n      const other = set.data;\n      const minWords = Math.min(data.length, other.length);\n      const words = Math.max(data.length, other.length);\n      const dest = data.length === words ? data : new Uint16Array(words);\n      let lastWord = -1;\n      for (let i = 0; i < minWords; i++) {\n        let value = dest[i] = data[i] ^ other[i];\n        if (value !== 0) {\n          lastWord = i;\n        }\n      }\n      const longer = data.length > other.length ? data : other;\n      for (let i = minWords; i < words; i++) {\n        let value = dest[i] = longer[i];\n        if (value !== 0) {\n          lastWord = i;\n        }\n      }\n      if (lastWord === -1) {\n        this.data = EMPTY_DATA;\n      } else if (dest.length === lastWord + 1) {\n        this.data = dest;\n      } else {\n        this.data = dest.slice(0, lastWord + 1);\n      }\n    }\n    clone() {\n      return new BitSet(this);\n    }\n    [Symbol.iterator]() {\n      return new BitSetIterator(this.data);\n    }\n    [util.inspect.custom]() {\n      return \"BitSet \" + this.toString();\n    }\n  };\n  exports.BitSet = BitSet;\n  var BitSetIterator = class {\n    constructor(data) {\n      this.data = data;\n      this.index = 0;\n      this.mask = 65535;\n    }\n    next() {\n      while (this.index < this.data.length) {\n        const bits = this.data[this.index] & this.mask;\n        if (bits !== 0) {\n          const bitNumber = unIndex(this.index) + findLSBSet(bits);\n          this.mask = bitsFor(bitNumber + 1, 15);\n          return {done: false, value: bitNumber};\n        }\n        this.index++;\n        this.mask = 65535;\n      }\n      return {done: true, value: -1};\n    }\n    [Symbol.iterator]() {\n      return this;\n    }\n  };\n});\n\n// node_modules/antlr4ts/atn/ATNConfigSet.js\nvar require_ATNConfigSet = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ATNConfigSet = void 0;\n  var Array2DHashMap_1 = require_Array2DHashMap();\n  var Array2DHashSet_1 = require_Array2DHashSet();\n  var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();\n  var ATN_1 = require_ATN();\n  var ATNConfig_1 = require_ATNConfig();\n  var BitSet_1 = require_BitSet();\n  var Decorators_1 = require_Decorators();\n  var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();\n  var PredictionContext_1 = require_PredictionContext();\n  var PredictionContextCache_1 = require_PredictionContextCache();\n  var SemanticContext_1 = require_SemanticContext();\n  var assert = __webpack_require__(/*! assert */ \"assert\");\n  var Utils3 = require_Utils();\n  var KeyTypeEqualityComparer = class {\n    hashCode(key) {\n      return key.state ^ key.alt;\n    }\n    equals(a, b) {\n      return a.state === b.state && a.alt === b.alt;\n    }\n  };\n  KeyTypeEqualityComparer.INSTANCE = new KeyTypeEqualityComparer();\n  function NewKeyedConfigMap(map) {\n    if (map) {\n      return new Array2DHashMap_1.Array2DHashMap(map);\n    } else {\n      return new Array2DHashMap_1.Array2DHashMap(KeyTypeEqualityComparer.INSTANCE);\n    }\n  }\n  var ATNConfigSet = class {\n    constructor(set, readonly) {\n      this._uniqueAlt = 0;\n      this._hasSemanticContext = false;\n      this._dipsIntoOuterContext = false;\n      this.outermostConfigSet = false;\n      this.cachedHashCode = -1;\n      if (!set) {\n        this.mergedConfigs = NewKeyedConfigMap();\n        this.unmerged = [];\n        this.configs = [];\n        this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;\n      } else {\n        if (readonly) {\n          this.mergedConfigs = void 0;\n          this.unmerged = void 0;\n        } else if (!set.isReadOnly) {\n          this.mergedConfigs = NewKeyedConfigMap(set.mergedConfigs);\n          this.unmerged = set.unmerged.slice(0);\n        } else {\n          this.mergedConfigs = NewKeyedConfigMap();\n          this.unmerged = [];\n        }\n        this.configs = set.configs.slice(0);\n        this._dipsIntoOuterContext = set._dipsIntoOuterContext;\n        this._hasSemanticContext = set._hasSemanticContext;\n        this.outermostConfigSet = set.outermostConfigSet;\n        if (readonly || !set.isReadOnly) {\n          this._uniqueAlt = set._uniqueAlt;\n          this._conflictInfo = set._conflictInfo;\n        }\n      }\n    }\n    getRepresentedAlternatives() {\n      if (this._conflictInfo != null) {\n        return this._conflictInfo.conflictedAlts.clone();\n      }\n      let alts = new BitSet_1.BitSet();\n      for (let config of this) {\n        alts.set(config.alt);\n      }\n      return alts;\n    }\n    get isReadOnly() {\n      return this.mergedConfigs == null;\n    }\n    get isOutermostConfigSet() {\n      return this.outermostConfigSet;\n    }\n    set isOutermostConfigSet(outermostConfigSet) {\n      if (this.outermostConfigSet && !outermostConfigSet) {\n        throw new Error(\"IllegalStateException\");\n      }\n      assert(!outermostConfigSet || !this._dipsIntoOuterContext);\n      this.outermostConfigSet = outermostConfigSet;\n    }\n    getStates() {\n      let states = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);\n      for (let c of this.configs) {\n        states.add(c.state);\n      }\n      return states;\n    }\n    optimizeConfigs(interpreter) {\n      if (this.configs.length === 0) {\n        return;\n      }\n      for (let config of this.configs) {\n        config.context = interpreter.atn.getCachedContext(config.context);\n      }\n    }\n    clone(readonly) {\n      let copy = new ATNConfigSet(this, readonly);\n      if (!readonly && this.isReadOnly) {\n        copy.addAll(this.configs);\n      }\n      return copy;\n    }\n    get size() {\n      return this.configs.length;\n    }\n    get isEmpty() {\n      return this.configs.length === 0;\n    }\n    contains(o) {\n      if (!(o instanceof ATNConfig_1.ATNConfig)) {\n        return false;\n      }\n      if (this.mergedConfigs && this.unmerged) {\n        let config = o;\n        let configKey = this.getKey(config);\n        let mergedConfig = this.mergedConfigs.get(configKey);\n        if (mergedConfig != null && this.canMerge(config, configKey, mergedConfig)) {\n          return mergedConfig.contains(config);\n        }\n        for (let c of this.unmerged) {\n          if (c.contains(o)) {\n            return true;\n          }\n        }\n      } else {\n        for (let c of this.configs) {\n          if (c.contains(o)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n    *[Symbol.iterator]() {\n      yield* this.configs;\n    }\n    toArray() {\n      return this.configs;\n    }\n    add(e, contextCache) {\n      this.ensureWritable();\n      if (!this.mergedConfigs || !this.unmerged) {\n        throw new Error(\"Covered by ensureWritable but duplicated here for strict null check limitation\");\n      }\n      assert(!this.outermostConfigSet || !e.reachesIntoOuterContext);\n      if (contextCache == null) {\n        contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;\n      }\n      let addKey;\n      let key = this.getKey(e);\n      let mergedConfig = this.mergedConfigs.get(key);\n      addKey = mergedConfig == null;\n      if (mergedConfig != null && this.canMerge(e, key, mergedConfig)) {\n        mergedConfig.outerContextDepth = Math.max(mergedConfig.outerContextDepth, e.outerContextDepth);\n        if (e.isPrecedenceFilterSuppressed) {\n          mergedConfig.isPrecedenceFilterSuppressed = true;\n        }\n        let joined = PredictionContext_1.PredictionContext.join(mergedConfig.context, e.context, contextCache);\n        this.updatePropertiesForMergedConfig(e);\n        if (mergedConfig.context === joined) {\n          return false;\n        }\n        mergedConfig.context = joined;\n        return true;\n      }\n      for (let i = 0; i < this.unmerged.length; i++) {\n        let unmergedConfig = this.unmerged[i];\n        if (this.canMerge(e, key, unmergedConfig)) {\n          unmergedConfig.outerContextDepth = Math.max(unmergedConfig.outerContextDepth, e.outerContextDepth);\n          if (e.isPrecedenceFilterSuppressed) {\n            unmergedConfig.isPrecedenceFilterSuppressed = true;\n          }\n          let joined = PredictionContext_1.PredictionContext.join(unmergedConfig.context, e.context, contextCache);\n          this.updatePropertiesForMergedConfig(e);\n          if (unmergedConfig.context === joined) {\n            return false;\n          }\n          unmergedConfig.context = joined;\n          if (addKey) {\n            this.mergedConfigs.put(key, unmergedConfig);\n            this.unmerged.splice(i, 1);\n          }\n          return true;\n        }\n      }\n      this.configs.push(e);\n      if (addKey) {\n        this.mergedConfigs.put(key, e);\n      } else {\n        this.unmerged.push(e);\n      }\n      this.updatePropertiesForAddedConfig(e);\n      return true;\n    }\n    updatePropertiesForMergedConfig(config) {\n      this._dipsIntoOuterContext = this._dipsIntoOuterContext || config.reachesIntoOuterContext;\n      assert(!this.outermostConfigSet || !this._dipsIntoOuterContext);\n    }\n    updatePropertiesForAddedConfig(config) {\n      if (this.configs.length === 1) {\n        this._uniqueAlt = config.alt;\n      } else if (this._uniqueAlt !== config.alt) {\n        this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;\n      }\n      this._hasSemanticContext = this._hasSemanticContext || !SemanticContext_1.SemanticContext.NONE.equals(config.semanticContext);\n      this._dipsIntoOuterContext = this._dipsIntoOuterContext || config.reachesIntoOuterContext;\n      assert(!this.outermostConfigSet || !this._dipsIntoOuterContext);\n    }\n    canMerge(left, leftKey, right) {\n      if (left.state.stateNumber !== right.state.stateNumber) {\n        return false;\n      }\n      if (leftKey.alt !== right.alt) {\n        return false;\n      }\n      return left.semanticContext.equals(right.semanticContext);\n    }\n    getKey(e) {\n      return {state: e.state.stateNumber, alt: e.alt};\n    }\n    containsAll(c) {\n      for (let o of c) {\n        if (!(o instanceof ATNConfig_1.ATNConfig)) {\n          return false;\n        }\n        if (!this.contains(o)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    addAll(c, contextCache) {\n      this.ensureWritable();\n      let changed = false;\n      for (let group of c) {\n        if (this.add(group, contextCache)) {\n          changed = true;\n        }\n      }\n      return changed;\n    }\n    clear() {\n      this.ensureWritable();\n      if (!this.mergedConfigs || !this.unmerged) {\n        throw new Error(\"Covered by ensureWritable but duplicated here for strict null check limitation\");\n      }\n      this.mergedConfigs.clear();\n      this.unmerged.length = 0;\n      this.configs.length = 0;\n      this._dipsIntoOuterContext = false;\n      this._hasSemanticContext = false;\n      this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;\n      this._conflictInfo = void 0;\n    }\n    equals(obj) {\n      if (this === obj) {\n        return true;\n      }\n      if (!(obj instanceof ATNConfigSet)) {\n        return false;\n      }\n      return this.outermostConfigSet === obj.outermostConfigSet && Utils3.equals(this._conflictInfo, obj._conflictInfo) && ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.configs, obj.configs);\n    }\n    hashCode() {\n      if (this.isReadOnly && this.cachedHashCode !== -1) {\n        return this.cachedHashCode;\n      }\n      let hashCode = 1;\n      hashCode = 5 * hashCode ^ (this.outermostConfigSet ? 1 : 0);\n      hashCode = 5 * hashCode ^ ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.hashCode(this.configs);\n      if (this.isReadOnly) {\n        this.cachedHashCode = hashCode;\n      }\n      return hashCode;\n    }\n    toString(showContext) {\n      if (showContext == null) {\n        showContext = false;\n      }\n      let buf = \"\";\n      let sortedConfigs = this.configs.slice(0);\n      sortedConfigs.sort((o1, o2) => {\n        if (o1.alt !== o2.alt) {\n          return o1.alt - o2.alt;\n        } else if (o1.state.stateNumber !== o2.state.stateNumber) {\n          return o1.state.stateNumber - o2.state.stateNumber;\n        } else {\n          return o1.semanticContext.toString().localeCompare(o2.semanticContext.toString());\n        }\n      });\n      buf += \"[\";\n      for (let i = 0; i < sortedConfigs.length; i++) {\n        if (i > 0) {\n          buf += \", \";\n        }\n        buf += sortedConfigs[i].toString(void 0, true, showContext);\n      }\n      buf += \"]\";\n      if (this._hasSemanticContext) {\n        buf += \",hasSemanticContext=\" + this._hasSemanticContext;\n      }\n      if (this._uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {\n        buf += \",uniqueAlt=\" + this._uniqueAlt;\n      }\n      if (this._conflictInfo != null) {\n        buf += \",conflictingAlts=\" + this._conflictInfo.conflictedAlts;\n        if (!this._conflictInfo.isExact) {\n          buf += \"*\";\n        }\n      }\n      if (this._dipsIntoOuterContext) {\n        buf += \",dipsIntoOuterContext\";\n      }\n      return buf.toString();\n    }\n    get uniqueAlt() {\n      return this._uniqueAlt;\n    }\n    get hasSemanticContext() {\n      return this._hasSemanticContext;\n    }\n    set hasSemanticContext(value) {\n      this.ensureWritable();\n      this._hasSemanticContext = value;\n    }\n    get conflictInfo() {\n      return this._conflictInfo;\n    }\n    set conflictInfo(conflictInfo) {\n      this.ensureWritable();\n      this._conflictInfo = conflictInfo;\n    }\n    get conflictingAlts() {\n      if (this._conflictInfo == null) {\n        return void 0;\n      }\n      return this._conflictInfo.conflictedAlts;\n    }\n    get isExactConflict() {\n      if (this._conflictInfo == null) {\n        return false;\n      }\n      return this._conflictInfo.isExact;\n    }\n    get dipsIntoOuterContext() {\n      return this._dipsIntoOuterContext;\n    }\n    get(index) {\n      return this.configs[index];\n    }\n    ensureWritable() {\n      if (this.isReadOnly) {\n        throw new Error(\"This ATNConfigSet is read only.\");\n      }\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], ATNConfigSet.prototype, \"getRepresentedAlternatives\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ATNConfigSet.prototype, \"size\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ATNConfigSet.prototype, \"isEmpty\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ATNConfigSet.prototype, \"contains\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ATNConfigSet.prototype, Symbol.iterator, null);\n  __decorate([\n    Decorators_1.Override\n  ], ATNConfigSet.prototype, \"toArray\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ATNConfigSet.prototype, \"containsAll\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ATNConfigSet.prototype, \"clear\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ATNConfigSet.prototype, \"equals\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ATNConfigSet.prototype, \"hashCode\", null);\n  exports.ATNConfigSet = ATNConfigSet;\n});\n\n// node_modules/antlr4ts/dfa/DFAState.js\nvar require_DFAState = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.DFAState = void 0;\n  var ATN_1 = require_ATN();\n  var BitSet_1 = require_BitSet();\n  var MurmurHash_1 = require_MurmurHash();\n  var Decorators_1 = require_Decorators();\n  var PredictionContext_1 = require_PredictionContext();\n  var assert = __webpack_require__(/*! assert */ \"assert\");\n  var DFAState = class {\n    constructor(configs) {\n      this.stateNumber = -1;\n      this.configs = configs;\n      this.edges = new Map();\n      this.contextEdges = new Map();\n    }\n    get isContextSensitive() {\n      return !!this.contextSymbols;\n    }\n    isContextSymbol(symbol) {\n      if (!this.isContextSensitive) {\n        return false;\n      }\n      return this.contextSymbols.get(symbol);\n    }\n    setContextSymbol(symbol) {\n      assert(this.isContextSensitive);\n      this.contextSymbols.set(symbol);\n    }\n    setContextSensitive(atn) {\n      assert(!this.configs.isOutermostConfigSet);\n      if (this.isContextSensitive) {\n        return;\n      }\n      if (!this.contextSymbols) {\n        this.contextSymbols = new BitSet_1.BitSet();\n      }\n    }\n    get acceptStateInfo() {\n      return this._acceptStateInfo;\n    }\n    set acceptStateInfo(acceptStateInfo) {\n      this._acceptStateInfo = acceptStateInfo;\n    }\n    get isAcceptState() {\n      return !!this._acceptStateInfo;\n    }\n    get prediction() {\n      if (!this._acceptStateInfo) {\n        return ATN_1.ATN.INVALID_ALT_NUMBER;\n      }\n      return this._acceptStateInfo.prediction;\n    }\n    get lexerActionExecutor() {\n      if (!this._acceptStateInfo) {\n        return void 0;\n      }\n      return this._acceptStateInfo.lexerActionExecutor;\n    }\n    getTarget(symbol) {\n      return this.edges.get(symbol);\n    }\n    setTarget(symbol, target) {\n      this.edges.set(symbol, target);\n    }\n    getEdgeMap() {\n      return this.edges;\n    }\n    getContextTarget(invokingState) {\n      if (invokingState === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {\n        invokingState = -1;\n      }\n      return this.contextEdges.get(invokingState);\n    }\n    setContextTarget(invokingState, target) {\n      if (!this.isContextSensitive) {\n        throw new Error(\"The state is not context sensitive.\");\n      }\n      if (invokingState === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {\n        invokingState = -1;\n      }\n      this.contextEdges.set(invokingState, target);\n    }\n    getContextEdgeMap() {\n      let map = new Map(this.contextEdges);\n      let existing = map.get(-1);\n      if (existing !== void 0) {\n        if (map.size === 1) {\n          let result = new Map();\n          result.set(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY, existing);\n          return result;\n        } else {\n          map.delete(-1);\n          map.set(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY, existing);\n        }\n      }\n      return map;\n    }\n    hashCode() {\n      let hash = MurmurHash_1.MurmurHash.initialize(7);\n      hash = MurmurHash_1.MurmurHash.update(hash, this.configs.hashCode());\n      hash = MurmurHash_1.MurmurHash.finish(hash, 1);\n      return hash;\n    }\n    equals(o) {\n      if (this === o) {\n        return true;\n      }\n      if (!(o instanceof DFAState)) {\n        return false;\n      }\n      let other = o;\n      let sameSet = this.configs.equals(other.configs);\n      return sameSet;\n    }\n    toString() {\n      let buf = \"\";\n      buf += this.stateNumber + \":\" + this.configs;\n      if (this.isAcceptState) {\n        buf += \"=>\";\n        if (this.predicates) {\n          buf += this.predicates;\n        } else {\n          buf += this.prediction;\n        }\n      }\n      return buf.toString();\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], DFAState.prototype, \"configs\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], DFAState.prototype, \"edges\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], DFAState.prototype, \"contextEdges\", void 0);\n  __decorate([\n    Decorators_1.Override\n  ], DFAState.prototype, \"hashCode\", null);\n  __decorate([\n    Decorators_1.Override\n  ], DFAState.prototype, \"equals\", null);\n  __decorate([\n    Decorators_1.Override\n  ], DFAState.prototype, \"toString\", null);\n  exports.DFAState = DFAState;\n  (function(DFAState2) {\n    let PredPrediction = class PredPrediction {\n      constructor(pred, alt) {\n        this.alt = alt;\n        this.pred = pred;\n      }\n      toString() {\n        return \"(\" + this.pred + \", \" + this.alt + \")\";\n      }\n    };\n    __decorate([\n      Decorators_1.NotNull\n    ], PredPrediction.prototype, \"pred\", void 0);\n    __decorate([\n      Decorators_1.Override\n    ], PredPrediction.prototype, \"toString\", null);\n    PredPrediction = __decorate([\n      __param(0, Decorators_1.NotNull)\n    ], PredPrediction);\n    DFAState2.PredPrediction = PredPrediction;\n  })(DFAState = exports.DFAState || (exports.DFAState = {}));\n});\n\n// node_modules/antlr4ts/atn/ATNSimulator.js\nvar require_ATNSimulator = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ATNSimulator = void 0;\n  var ATNConfigSet_1 = require_ATNConfigSet();\n  var DFAState_1 = require_DFAState();\n  var Decorators_1 = require_Decorators();\n  var PredictionContext_1 = require_PredictionContext();\n  var ATNSimulator = class ATNSimulator2 {\n    constructor(atn) {\n      this.atn = atn;\n    }\n    static get ERROR() {\n      if (!ATNSimulator2._ERROR) {\n        ATNSimulator2._ERROR = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());\n        ATNSimulator2._ERROR.stateNumber = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;\n      }\n      return ATNSimulator2._ERROR;\n    }\n    clearDFA() {\n      this.atn.clearDFA();\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], ATNSimulator.prototype, \"atn\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], ATNSimulator, \"ERROR\", null);\n  ATNSimulator = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], ATNSimulator);\n  exports.ATNSimulator = ATNSimulator;\n  (function(ATNSimulator2) {\n    const RULE_VARIANT_DELIMITER = \"$\";\n    const RULE_LF_VARIANT_MARKER = \"$lf$\";\n    const RULE_NOLF_VARIANT_MARKER = \"$nolf$\";\n  })(ATNSimulator = exports.ATNSimulator || (exports.ATNSimulator = {}));\n  exports.ATNSimulator = ATNSimulator;\n});\n\n// node_modules/antlr4ts/ConsoleErrorListener.js\nvar require_ConsoleErrorListener = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ConsoleErrorListener = void 0;\n  var ConsoleErrorListener = class {\n    syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {\n      console.error(`line ${line}:${charPositionInLine} ${msg}`);\n    }\n  };\n  exports.ConsoleErrorListener = ConsoleErrorListener;\n  ConsoleErrorListener.INSTANCE = new ConsoleErrorListener();\n});\n\n// node_modules/antlr4ts/ProxyErrorListener.js\nvar require_ProxyErrorListener = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ProxyErrorListener = void 0;\n  var Decorators_1 = require_Decorators();\n  var ProxyErrorListener = class {\n    constructor(delegates) {\n      this.delegates = delegates;\n      if (!delegates) {\n        throw new Error(\"Invalid delegates\");\n      }\n    }\n    getDelegates() {\n      return this.delegates;\n    }\n    syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {\n      this.delegates.forEach((listener) => {\n        if (listener.syntaxError) {\n          listener.syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e);\n        }\n      });\n    }\n  };\n  __decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull),\n    __param(4, Decorators_1.NotNull)\n  ], ProxyErrorListener.prototype, \"syntaxError\", null);\n  exports.ProxyErrorListener = ProxyErrorListener;\n});\n\n// node_modules/antlr4ts/Recognizer.js\nvar require_Recognizer = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.Recognizer = void 0;\n  var ConsoleErrorListener_1 = require_ConsoleErrorListener();\n  var ProxyErrorListener_1 = require_ProxyErrorListener();\n  var Decorators_1 = require_Decorators();\n  var Token_1 = require_Token();\n  var Utils3 = require_Utils();\n  var Recognizer = class {\n    constructor() {\n      this._listeners = [ConsoleErrorListener_1.ConsoleErrorListener.INSTANCE];\n      this._stateNumber = -1;\n    }\n    getTokenTypeMap() {\n      let vocabulary = this.vocabulary;\n      let result = Recognizer.tokenTypeMapCache.get(vocabulary);\n      if (result == null) {\n        let intermediateResult = new Map();\n        for (let i = 0; i <= this.atn.maxTokenType; i++) {\n          let literalName = vocabulary.getLiteralName(i);\n          if (literalName != null) {\n            intermediateResult.set(literalName, i);\n          }\n          let symbolicName = vocabulary.getSymbolicName(i);\n          if (symbolicName != null) {\n            intermediateResult.set(symbolicName, i);\n          }\n        }\n        intermediateResult.set(\"EOF\", Token_1.Token.EOF);\n        result = intermediateResult;\n        Recognizer.tokenTypeMapCache.set(vocabulary, result);\n      }\n      return result;\n    }\n    getRuleIndexMap() {\n      let ruleNames = this.ruleNames;\n      if (ruleNames == null) {\n        throw new Error(\"The current recognizer does not provide a list of rule names.\");\n      }\n      let result = Recognizer.ruleIndexMapCache.get(ruleNames);\n      if (result == null) {\n        result = Utils3.toMap(ruleNames);\n        Recognizer.ruleIndexMapCache.set(ruleNames, result);\n      }\n      return result;\n    }\n    getTokenType(tokenName) {\n      let ttype = this.getTokenTypeMap().get(tokenName);\n      if (ttype != null) {\n        return ttype;\n      }\n      return Token_1.Token.INVALID_TYPE;\n    }\n    get serializedATN() {\n      throw new Error(\"there is no serialized ATN\");\n    }\n    get atn() {\n      return this._interp.atn;\n    }\n    get interpreter() {\n      return this._interp;\n    }\n    set interpreter(interpreter) {\n      this._interp = interpreter;\n    }\n    get parseInfo() {\n      return Promise.resolve(void 0);\n    }\n    getErrorHeader(e) {\n      let token = e.getOffendingToken();\n      if (!token) {\n        return \"\";\n      }\n      let line = token.line;\n      let charPositionInLine = token.charPositionInLine;\n      return \"line \" + line + \":\" + charPositionInLine;\n    }\n    addErrorListener(listener) {\n      if (!listener) {\n        throw new TypeError(\"listener must not be null\");\n      }\n      this._listeners.push(listener);\n    }\n    removeErrorListener(listener) {\n      let position = this._listeners.indexOf(listener);\n      if (position !== -1) {\n        this._listeners.splice(position, 1);\n      }\n    }\n    removeErrorListeners() {\n      this._listeners.length = 0;\n    }\n    getErrorListeners() {\n      return this._listeners.slice(0);\n    }\n    getErrorListenerDispatch() {\n      return new ProxyErrorListener_1.ProxyErrorListener(this.getErrorListeners());\n    }\n    sempred(_localctx, ruleIndex, actionIndex) {\n      return true;\n    }\n    precpred(localctx, precedence) {\n      return true;\n    }\n    action(_localctx, ruleIndex, actionIndex) {\n    }\n    get state() {\n      return this._stateNumber;\n    }\n    set state(atnState) {\n      this._stateNumber = atnState;\n    }\n  };\n  Recognizer.EOF = -1;\n  Recognizer.tokenTypeMapCache = new WeakMap();\n  Recognizer.ruleIndexMapCache = new WeakMap();\n  __decorate([\n    Decorators_1.SuppressWarnings(\"serial\"),\n    Decorators_1.NotNull\n  ], Recognizer.prototype, \"_listeners\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], Recognizer.prototype, \"getTokenTypeMap\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], Recognizer.prototype, \"getRuleIndexMap\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], Recognizer.prototype, \"serializedATN\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], Recognizer.prototype, \"atn\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n  ], Recognizer.prototype, \"interpreter\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n  ], Recognizer.prototype, \"getErrorHeader\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], Recognizer.prototype, \"addErrorListener\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], Recognizer.prototype, \"removeErrorListener\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], Recognizer.prototype, \"getErrorListeners\", null);\n  exports.Recognizer = Recognizer;\n});\n\n// node_modules/antlr4ts/VocabularyImpl.js\nvar require_VocabularyImpl = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.VocabularyImpl = void 0;\n  var Decorators_1 = require_Decorators();\n  var Token_1 = require_Token();\n  var VocabularyImpl3 = class {\n    constructor(literalNames, symbolicNames, displayNames) {\n      this.literalNames = literalNames;\n      this.symbolicNames = symbolicNames;\n      this.displayNames = displayNames;\n      this._maxTokenType = Math.max(this.displayNames.length, Math.max(this.literalNames.length, this.symbolicNames.length)) - 1;\n    }\n    get maxTokenType() {\n      return this._maxTokenType;\n    }\n    getLiteralName(tokenType) {\n      if (tokenType >= 0 && tokenType < this.literalNames.length) {\n        return this.literalNames[tokenType];\n      }\n      return void 0;\n    }\n    getSymbolicName(tokenType) {\n      if (tokenType >= 0 && tokenType < this.symbolicNames.length) {\n        return this.symbolicNames[tokenType];\n      }\n      if (tokenType === Token_1.Token.EOF) {\n        return \"EOF\";\n      }\n      return void 0;\n    }\n    getDisplayName(tokenType) {\n      if (tokenType >= 0 && tokenType < this.displayNames.length) {\n        let displayName = this.displayNames[tokenType];\n        if (displayName) {\n          return displayName;\n        }\n      }\n      let literalName = this.getLiteralName(tokenType);\n      if (literalName) {\n        return literalName;\n      }\n      let symbolicName = this.getSymbolicName(tokenType);\n      if (symbolicName) {\n        return symbolicName;\n      }\n      return String(tokenType);\n    }\n  };\n  VocabularyImpl3.EMPTY_VOCABULARY = new VocabularyImpl3([], [], []);\n  __decorate([\n    Decorators_1.NotNull\n  ], VocabularyImpl3.prototype, \"literalNames\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], VocabularyImpl3.prototype, \"symbolicNames\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], VocabularyImpl3.prototype, \"displayNames\", void 0);\n  __decorate([\n    Decorators_1.Override\n  ], VocabularyImpl3.prototype, \"maxTokenType\", null);\n  __decorate([\n    Decorators_1.Override\n  ], VocabularyImpl3.prototype, \"getLiteralName\", null);\n  __decorate([\n    Decorators_1.Override\n  ], VocabularyImpl3.prototype, \"getSymbolicName\", null);\n  __decorate([\n    Decorators_1.Override,\n    Decorators_1.NotNull\n  ], VocabularyImpl3.prototype, \"getDisplayName\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], VocabularyImpl3, \"EMPTY_VOCABULARY\", void 0);\n  exports.VocabularyImpl = VocabularyImpl3;\n});\n\n// node_modules/antlr4ts/dfa/DFASerializer.js\nvar require_DFASerializer = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.DFASerializer = void 0;\n  var ATNSimulator_1 = require_ATNSimulator();\n  var Decorators_1 = require_Decorators();\n  var PredictionContext_1 = require_PredictionContext();\n  var Recognizer_1 = require_Recognizer();\n  var VocabularyImpl_1 = require_VocabularyImpl();\n  var DFASerializer = class {\n    constructor(dfa, vocabulary, ruleNames, atn) {\n      if (vocabulary instanceof Recognizer_1.Recognizer) {\n        ruleNames = vocabulary.ruleNames;\n        atn = vocabulary.atn;\n        vocabulary = vocabulary.vocabulary;\n      } else if (!vocabulary) {\n        vocabulary = VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;\n      }\n      this.dfa = dfa;\n      this.vocabulary = vocabulary;\n      this.ruleNames = ruleNames;\n      this.atn = atn;\n    }\n    toString() {\n      if (!this.dfa.s0) {\n        return \"\";\n      }\n      let buf = \"\";\n      if (this.dfa.states) {\n        let states = new Array(...this.dfa.states.toArray());\n        states.sort((o1, o2) => o1.stateNumber - o2.stateNumber);\n        for (let s of states) {\n          let edges = s.getEdgeMap();\n          let edgeKeys = [...edges.keys()].sort((a, b) => a - b);\n          let contextEdges = s.getContextEdgeMap();\n          let contextEdgeKeys = [...contextEdges.keys()].sort((a, b) => a - b);\n          for (let entry of edgeKeys) {\n            let value = edges.get(entry);\n            if ((value == null || value === ATNSimulator_1.ATNSimulator.ERROR) && !s.isContextSymbol(entry)) {\n              continue;\n            }\n            let contextSymbol = false;\n            buf += this.getStateString(s) + \"-\" + this.getEdgeLabel(entry) + \"->\";\n            if (s.isContextSymbol(entry)) {\n              buf += \"!\";\n              contextSymbol = true;\n            }\n            let t = value;\n            if (t && t.stateNumber !== ATNSimulator_1.ATNSimulator.ERROR.stateNumber) {\n              buf += this.getStateString(t) + \"\\n\";\n            } else if (contextSymbol) {\n              buf += \"ctx\\n\";\n            }\n          }\n          if (s.isContextSensitive) {\n            for (let entry of contextEdgeKeys) {\n              buf += this.getStateString(s) + \"-\" + this.getContextLabel(entry) + \"->\" + this.getStateString(contextEdges.get(entry)) + \"\\n\";\n            }\n          }\n        }\n      }\n      let output = buf;\n      if (output.length === 0) {\n        return \"\";\n      }\n      return output;\n    }\n    getContextLabel(i) {\n      if (i === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {\n        return \"ctx:EMPTY_FULL\";\n      } else if (i === PredictionContext_1.PredictionContext.EMPTY_LOCAL_STATE_KEY) {\n        return \"ctx:EMPTY_LOCAL\";\n      }\n      if (this.atn && i > 0 && i <= this.atn.states.length) {\n        let state = this.atn.states[i];\n        let ruleIndex = state.ruleIndex;\n        if (this.ruleNames && ruleIndex >= 0 && ruleIndex < this.ruleNames.length) {\n          return \"ctx:\" + String(i) + \"(\" + this.ruleNames[ruleIndex] + \")\";\n        }\n      }\n      return \"ctx:\" + String(i);\n    }\n    getEdgeLabel(i) {\n      return this.vocabulary.getDisplayName(i);\n    }\n    getStateString(s) {\n      if (s === ATNSimulator_1.ATNSimulator.ERROR) {\n        return \"ERROR\";\n      }\n      let n = s.stateNumber;\n      let stateStr = \"s\" + n;\n      if (s.isAcceptState) {\n        if (s.predicates) {\n          stateStr = \":s\" + n + \"=>\" + s.predicates;\n        } else {\n          stateStr = \":s\" + n + \"=>\" + s.prediction;\n        }\n      }\n      if (s.isContextSensitive) {\n        stateStr += \"*\";\n        for (let config of s.configs) {\n          if (config.reachesIntoOuterContext) {\n            stateStr += \"*\";\n            break;\n          }\n        }\n      }\n      return stateStr;\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], DFASerializer.prototype, \"dfa\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], DFASerializer.prototype, \"vocabulary\", void 0);\n  __decorate([\n    Decorators_1.Override\n  ], DFASerializer.prototype, \"toString\", null);\n  exports.DFASerializer = DFASerializer;\n});\n\n// node_modules/antlr4ts/dfa/LexerDFASerializer.js\nvar require_LexerDFASerializer = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.LexerDFASerializer = void 0;\n  var DFASerializer_1 = require_DFASerializer();\n  var Decorators_1 = require_Decorators();\n  var VocabularyImpl_1 = require_VocabularyImpl();\n  var LexerDFASerializer = class LexerDFASerializer extends DFASerializer_1.DFASerializer {\n    constructor(dfa) {\n      super(dfa, VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY);\n    }\n    getEdgeLabel(i) {\n      return \"'\" + String.fromCodePoint(i) + \"'\";\n    }\n  };\n  __decorate([\n    Decorators_1.Override,\n    Decorators_1.NotNull\n  ], LexerDFASerializer.prototype, \"getEdgeLabel\", null);\n  LexerDFASerializer = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], LexerDFASerializer);\n  exports.LexerDFASerializer = LexerDFASerializer;\n});\n\n// node_modules/antlr4ts/atn/StarLoopEntryState.js\nvar require_StarLoopEntryState = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.StarLoopEntryState = void 0;\n  var ATNStateType_1 = require_ATNStateType();\n  var BitSet_1 = require_BitSet();\n  var DecisionState_1 = require_DecisionState();\n  var Decorators_1 = require_Decorators();\n  var StarLoopEntryState = class extends DecisionState_1.DecisionState {\n    constructor() {\n      super(...arguments);\n      this.precedenceRuleDecision = false;\n      this.precedenceLoopbackStates = new BitSet_1.BitSet();\n    }\n    get stateType() {\n      return ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], StarLoopEntryState.prototype, \"stateType\", null);\n  exports.StarLoopEntryState = StarLoopEntryState;\n});\n\n// node_modules/antlr4ts/dfa/DFA.js\nvar require_DFA = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.DFA = void 0;\n  var Array2DHashSet_1 = require_Array2DHashSet();\n  var ATNConfigSet_1 = require_ATNConfigSet();\n  var DFASerializer_1 = require_DFASerializer();\n  var DFAState_1 = require_DFAState();\n  var LexerDFASerializer_1 = require_LexerDFASerializer();\n  var Decorators_1 = require_Decorators();\n  var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();\n  var StarLoopEntryState_1 = require_StarLoopEntryState();\n  var VocabularyImpl_1 = require_VocabularyImpl();\n  var DFA = class DFA {\n    constructor(atnStartState, decision = 0) {\n      this.states = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);\n      this.nextStateNumber = 0;\n      if (!atnStartState.atn) {\n        throw new Error(\"The ATNState must be associated with an ATN\");\n      }\n      this.atnStartState = atnStartState;\n      this.atn = atnStartState.atn;\n      this.decision = decision;\n      let isPrecedenceDfa = false;\n      if (atnStartState instanceof StarLoopEntryState_1.StarLoopEntryState) {\n        if (atnStartState.precedenceRuleDecision) {\n          isPrecedenceDfa = true;\n          this.s0 = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());\n          this.s0full = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());\n        }\n      }\n      this.precedenceDfa = isPrecedenceDfa;\n    }\n    get isPrecedenceDfa() {\n      return this.precedenceDfa;\n    }\n    getPrecedenceStartState(precedence, fullContext) {\n      if (!this.isPrecedenceDfa) {\n        throw new Error(\"Only precedence DFAs may contain a precedence start state.\");\n      }\n      if (fullContext) {\n        return this.s0full.getTarget(precedence);\n      } else {\n        return this.s0.getTarget(precedence);\n      }\n    }\n    setPrecedenceStartState(precedence, fullContext, startState) {\n      if (!this.isPrecedenceDfa) {\n        throw new Error(\"Only precedence DFAs may contain a precedence start state.\");\n      }\n      if (precedence < 0) {\n        return;\n      }\n      if (fullContext) {\n        this.s0full.setTarget(precedence, startState);\n      } else {\n        this.s0.setTarget(precedence, startState);\n      }\n    }\n    get isEmpty() {\n      if (this.isPrecedenceDfa) {\n        return this.s0.getEdgeMap().size === 0 && this.s0full.getEdgeMap().size === 0;\n      }\n      return this.s0 == null && this.s0full == null;\n    }\n    get isContextSensitive() {\n      if (this.isPrecedenceDfa) {\n        return this.s0full.getEdgeMap().size > 0;\n      }\n      return this.s0full != null;\n    }\n    addState(state) {\n      state.stateNumber = this.nextStateNumber++;\n      return this.states.getOrAdd(state);\n    }\n    toString(vocabulary, ruleNames) {\n      if (!vocabulary) {\n        vocabulary = VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;\n      }\n      if (!this.s0) {\n        return \"\";\n      }\n      let serializer;\n      if (ruleNames) {\n        serializer = new DFASerializer_1.DFASerializer(this, vocabulary, ruleNames, this.atnStartState.atn);\n      } else {\n        serializer = new DFASerializer_1.DFASerializer(this, vocabulary);\n      }\n      return serializer.toString();\n    }\n    toLexerString() {\n      if (!this.s0) {\n        return \"\";\n      }\n      let serializer = new LexerDFASerializer_1.LexerDFASerializer(this);\n      return serializer.toString();\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], DFA.prototype, \"states\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], DFA.prototype, \"atnStartState\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], DFA.prototype, \"atn\", void 0);\n  DFA = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], DFA);\n  exports.DFA = DFA;\n});\n\n// node_modules/antlr4ts/atn/BasicState.js\nvar require_BasicState = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.BasicState = void 0;\n  var ATNState_1 = require_ATNState();\n  var ATNStateType_1 = require_ATNStateType();\n  var Decorators_1 = require_Decorators();\n  var BasicState = class extends ATNState_1.ATNState {\n    get stateType() {\n      return ATNStateType_1.ATNStateType.BASIC;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], BasicState.prototype, \"stateType\", null);\n  exports.BasicState = BasicState;\n});\n\n// node_modules/antlr4ts/atn/InvalidState.js\nvar require_InvalidState = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.InvalidState = void 0;\n  var ATNStateType_1 = require_ATNStateType();\n  var BasicState_1 = require_BasicState();\n  var Decorators_1 = require_Decorators();\n  var InvalidState = class extends BasicState_1.BasicState {\n    get stateType() {\n      return ATNStateType_1.ATNStateType.INVALID_TYPE;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], InvalidState.prototype, \"stateType\", null);\n  exports.InvalidState = InvalidState;\n});\n\n// node_modules/antlr4ts/atn/SetTransition.js\nvar require_SetTransition = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.SetTransition = void 0;\n  var IntervalSet_1 = require_IntervalSet();\n  var Decorators_1 = require_Decorators();\n  var Token_1 = require_Token();\n  var Transition_1 = require_Transition();\n  var SetTransition = class SetTransition extends Transition_1.Transition {\n    constructor(target, set) {\n      super(target);\n      if (set == null) {\n        set = IntervalSet_1.IntervalSet.of(Token_1.Token.INVALID_TYPE);\n      }\n      this.set = set;\n    }\n    get serializationType() {\n      return 7;\n    }\n    get label() {\n      return this.set;\n    }\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n      return this.set.contains(symbol);\n    }\n    toString() {\n      return this.set.toString();\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], SetTransition.prototype, \"set\", void 0);\n  __decorate([\n    Decorators_1.Override\n  ], SetTransition.prototype, \"serializationType\", null);\n  __decorate([\n    Decorators_1.Override,\n    Decorators_1.NotNull\n  ], SetTransition.prototype, \"label\", null);\n  __decorate([\n    Decorators_1.Override\n  ], SetTransition.prototype, \"matches\", null);\n  __decorate([\n    Decorators_1.Override,\n    Decorators_1.NotNull\n  ], SetTransition.prototype, \"toString\", null);\n  SetTransition = __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.Nullable)\n  ], SetTransition);\n  exports.SetTransition = SetTransition;\n});\n\n// node_modules/antlr4ts/atn/NotSetTransition.js\nvar require_NotSetTransition = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.NotSetTransition = void 0;\n  var Decorators_1 = require_Decorators();\n  var SetTransition_1 = require_SetTransition();\n  var NotSetTransition = class NotSetTransition extends SetTransition_1.SetTransition {\n    constructor(target, set) {\n      super(target, set);\n    }\n    get serializationType() {\n      return 8;\n    }\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n      return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !super.matches(symbol, minVocabSymbol, maxVocabSymbol);\n    }\n    toString() {\n      return \"~\" + super.toString();\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], NotSetTransition.prototype, \"serializationType\", null);\n  __decorate([\n    Decorators_1.Override\n  ], NotSetTransition.prototype, \"matches\", null);\n  __decorate([\n    Decorators_1.Override\n  ], NotSetTransition.prototype, \"toString\", null);\n  NotSetTransition = __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.Nullable)\n  ], NotSetTransition);\n  exports.NotSetTransition = NotSetTransition;\n});\n\n// node_modules/antlr4ts/atn/RuleStopState.js\nvar require_RuleStopState = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.RuleStopState = void 0;\n  var ATNState_1 = require_ATNState();\n  var ATNStateType_1 = require_ATNStateType();\n  var Decorators_1 = require_Decorators();\n  var RuleStopState = class extends ATNState_1.ATNState {\n    get nonStopStateNumber() {\n      return -1;\n    }\n    get stateType() {\n      return ATNStateType_1.ATNStateType.RULE_STOP;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], RuleStopState.prototype, \"nonStopStateNumber\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleStopState.prototype, \"stateType\", null);\n  exports.RuleStopState = RuleStopState;\n});\n\n// node_modules/antlr4ts/atn/RuleTransition.js\nvar require_RuleTransition = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.RuleTransition = void 0;\n  var Decorators_1 = require_Decorators();\n  var Transition_1 = require_Transition();\n  var RuleTransition = class RuleTransition extends Transition_1.Transition {\n    constructor(ruleStart, ruleIndex, precedence, followState) {\n      super(ruleStart);\n      this.tailCall = false;\n      this.optimizedTailCall = false;\n      this.ruleIndex = ruleIndex;\n      this.precedence = precedence;\n      this.followState = followState;\n    }\n    get serializationType() {\n      return 3;\n    }\n    get isEpsilon() {\n      return true;\n    }\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n      return false;\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], RuleTransition.prototype, \"followState\", void 0);\n  __decorate([\n    Decorators_1.Override\n  ], RuleTransition.prototype, \"serializationType\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleTransition.prototype, \"isEpsilon\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleTransition.prototype, \"matches\", null);\n  RuleTransition = __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(3, Decorators_1.NotNull)\n  ], RuleTransition);\n  exports.RuleTransition = RuleTransition;\n});\n\n// node_modules/antlr4ts/atn/WildcardTransition.js\nvar require_WildcardTransition = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.WildcardTransition = void 0;\n  var Decorators_1 = require_Decorators();\n  var Transition_1 = require_Transition();\n  var WildcardTransition = class WildcardTransition extends Transition_1.Transition {\n    constructor(target) {\n      super(target);\n    }\n    get serializationType() {\n      return 9;\n    }\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n      return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;\n    }\n    toString() {\n      return \".\";\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], WildcardTransition.prototype, \"serializationType\", null);\n  __decorate([\n    Decorators_1.Override\n  ], WildcardTransition.prototype, \"matches\", null);\n  __decorate([\n    Decorators_1.Override,\n    Decorators_1.NotNull\n  ], WildcardTransition.prototype, \"toString\", null);\n  WildcardTransition = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], WildcardTransition);\n  exports.WildcardTransition = WildcardTransition;\n});\n\n// node_modules/antlr4ts/atn/LL1Analyzer.js\nvar require_LL1Analyzer = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.LL1Analyzer = void 0;\n  var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();\n  var Array2DHashSet_1 = require_Array2DHashSet();\n  var ATNConfig_1 = require_ATNConfig();\n  var BitSet_1 = require_BitSet();\n  var IntervalSet_1 = require_IntervalSet();\n  var Decorators_1 = require_Decorators();\n  var NotSetTransition_1 = require_NotSetTransition();\n  var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();\n  var PredictionContext_1 = require_PredictionContext();\n  var RuleStopState_1 = require_RuleStopState();\n  var RuleTransition_1 = require_RuleTransition();\n  var Token_1 = require_Token();\n  var WildcardTransition_1 = require_WildcardTransition();\n  var LL1Analyzer = class LL1Analyzer2 {\n    constructor(atn) {\n      this.atn = atn;\n    }\n    getDecisionLookahead(s) {\n      if (s == null) {\n        return void 0;\n      }\n      let look = new Array(s.numberOfTransitions);\n      for (let alt = 0; alt < s.numberOfTransitions; alt++) {\n        let current = new IntervalSet_1.IntervalSet();\n        look[alt] = current;\n        let lookBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);\n        let seeThruPreds = false;\n        this._LOOK(s.transition(alt).target, void 0, PredictionContext_1.PredictionContext.EMPTY_LOCAL, current, lookBusy, new BitSet_1.BitSet(), seeThruPreds, false);\n        if (current.size === 0 || current.contains(LL1Analyzer2.HIT_PRED)) {\n          current = void 0;\n          look[alt] = current;\n        }\n      }\n      return look;\n    }\n    LOOK(s, ctx, stopState) {\n      if (stopState === void 0) {\n        if (s.atn == null) {\n          throw new Error(\"Illegal state\");\n        }\n        stopState = s.atn.ruleToStopState[s.ruleIndex];\n      } else if (stopState === null) {\n        stopState = void 0;\n      }\n      let r = new IntervalSet_1.IntervalSet();\n      let seeThruPreds = true;\n      let addEOF = true;\n      this._LOOK(s, stopState, ctx, r, new Array2DHashSet_1.Array2DHashSet(), new BitSet_1.BitSet(), seeThruPreds, addEOF);\n      return r;\n    }\n    _LOOK(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {\n      let c = ATNConfig_1.ATNConfig.create(s, 0, ctx);\n      if (!lookBusy.add(c)) {\n        return;\n      }\n      if (s === stopState) {\n        if (PredictionContext_1.PredictionContext.isEmptyLocal(ctx)) {\n          look.add(Token_1.Token.EPSILON);\n          return;\n        } else if (ctx.isEmpty) {\n          if (addEOF) {\n            look.add(Token_1.Token.EOF);\n          }\n          return;\n        }\n      }\n      if (s instanceof RuleStopState_1.RuleStopState) {\n        if (ctx.isEmpty && !PredictionContext_1.PredictionContext.isEmptyLocal(ctx)) {\n          if (addEOF) {\n            look.add(Token_1.Token.EOF);\n          }\n          return;\n        }\n        let removed = calledRuleStack.get(s.ruleIndex);\n        try {\n          calledRuleStack.clear(s.ruleIndex);\n          for (let i = 0; i < ctx.size; i++) {\n            if (ctx.getReturnState(i) === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {\n              continue;\n            }\n            let returnState = this.atn.states[ctx.getReturnState(i)];\n            this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n          }\n        } finally {\n          if (removed) {\n            calledRuleStack.set(s.ruleIndex);\n          }\n        }\n      }\n      let n = s.numberOfTransitions;\n      for (let i = 0; i < n; i++) {\n        let t = s.transition(i);\n        if (t instanceof RuleTransition_1.RuleTransition) {\n          if (calledRuleStack.get(t.ruleIndex)) {\n            continue;\n          }\n          let newContext = ctx.getChild(t.followState.stateNumber);\n          try {\n            calledRuleStack.set(t.ruleIndex);\n            this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n          } finally {\n            calledRuleStack.clear(t.ruleIndex);\n          }\n        } else if (t instanceof AbstractPredicateTransition_1.AbstractPredicateTransition) {\n          if (seeThruPreds) {\n            this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n          } else {\n            look.add(LL1Analyzer2.HIT_PRED);\n          }\n        } else if (t.isEpsilon) {\n          this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t instanceof WildcardTransition_1.WildcardTransition) {\n          look.addAll(IntervalSet_1.IntervalSet.of(Token_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));\n        } else {\n          let set = t.label;\n          if (set != null) {\n            if (t instanceof NotSetTransition_1.NotSetTransition) {\n              set = set.complement(IntervalSet_1.IntervalSet.of(Token_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));\n            }\n            look.addAll(set);\n          }\n        }\n      }\n    }\n  };\n  LL1Analyzer.HIT_PRED = Token_1.Token.INVALID_TYPE;\n  __decorate([\n    Decorators_1.NotNull\n  ], LL1Analyzer.prototype, \"atn\", void 0);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n  ], LL1Analyzer.prototype, \"LOOK\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull),\n    __param(3, Decorators_1.NotNull),\n    __param(4, Decorators_1.NotNull),\n    __param(5, Decorators_1.NotNull)\n  ], LL1Analyzer.prototype, \"_LOOK\", null);\n  LL1Analyzer = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], LL1Analyzer);\n  exports.LL1Analyzer = LL1Analyzer;\n});\n\n// node_modules/antlr4ts/atn/ATN.js\nvar require_ATN = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ATN = void 0;\n  var Array2DHashMap_1 = require_Array2DHashMap();\n  var DFA_1 = require_DFA();\n  var IntervalSet_1 = require_IntervalSet();\n  var InvalidState_1 = require_InvalidState();\n  var LL1Analyzer_1 = require_LL1Analyzer();\n  var Decorators_1 = require_Decorators();\n  var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();\n  var PredictionContext_1 = require_PredictionContext();\n  var Token_1 = require_Token();\n  var assert = __webpack_require__(/*! assert */ \"assert\");\n  var ATN2 = class ATN {\n    constructor(grammarType, maxTokenType) {\n      this.states = [];\n      this.decisionToState = [];\n      this.modeNameToStartState = new Map();\n      this.modeToStartState = [];\n      this.contextCache = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);\n      this.decisionToDFA = [];\n      this.modeToDFA = [];\n      this.LL1Table = new Map();\n      this.grammarType = grammarType;\n      this.maxTokenType = maxTokenType;\n    }\n    clearDFA() {\n      this.decisionToDFA = new Array(this.decisionToState.length);\n      for (let i = 0; i < this.decisionToDFA.length; i++) {\n        this.decisionToDFA[i] = new DFA_1.DFA(this.decisionToState[i], i);\n      }\n      this.modeToDFA = new Array(this.modeToStartState.length);\n      for (let i = 0; i < this.modeToDFA.length; i++) {\n        this.modeToDFA[i] = new DFA_1.DFA(this.modeToStartState[i]);\n      }\n      this.contextCache.clear();\n      this.LL1Table.clear();\n    }\n    get contextCacheSize() {\n      return this.contextCache.size;\n    }\n    getCachedContext(context) {\n      return PredictionContext_1.PredictionContext.getCachedContext(context, this.contextCache, new PredictionContext_1.PredictionContext.IdentityHashMap());\n    }\n    getDecisionToDFA() {\n      assert(this.decisionToDFA != null && this.decisionToDFA.length === this.decisionToState.length);\n      return this.decisionToDFA;\n    }\n    nextTokens(s, ctx) {\n      if (ctx) {\n        let anal = new LL1Analyzer_1.LL1Analyzer(this);\n        let next = anal.LOOK(s, ctx);\n        return next;\n      } else {\n        if (s.nextTokenWithinRule) {\n          return s.nextTokenWithinRule;\n        }\n        s.nextTokenWithinRule = this.nextTokens(s, PredictionContext_1.PredictionContext.EMPTY_LOCAL);\n        s.nextTokenWithinRule.setReadonly(true);\n        return s.nextTokenWithinRule;\n      }\n    }\n    addState(state) {\n      state.atn = this;\n      state.stateNumber = this.states.length;\n      this.states.push(state);\n    }\n    removeState(state) {\n      let invalidState = new InvalidState_1.InvalidState();\n      invalidState.atn = this;\n      invalidState.stateNumber = state.stateNumber;\n      this.states[state.stateNumber] = invalidState;\n    }\n    defineMode(name, s) {\n      this.modeNameToStartState.set(name, s);\n      this.modeToStartState.push(s);\n      this.modeToDFA.push(new DFA_1.DFA(s));\n      this.defineDecisionState(s);\n    }\n    defineDecisionState(s) {\n      this.decisionToState.push(s);\n      s.decision = this.decisionToState.length - 1;\n      this.decisionToDFA.push(new DFA_1.DFA(s, s.decision));\n      return s.decision;\n    }\n    getDecisionState(decision) {\n      if (this.decisionToState.length > 0) {\n        return this.decisionToState[decision];\n      }\n      return void 0;\n    }\n    get numberOfDecisions() {\n      return this.decisionToState.length;\n    }\n    getExpectedTokens(stateNumber, context) {\n      if (stateNumber < 0 || stateNumber >= this.states.length) {\n        throw new RangeError(\"Invalid state number.\");\n      }\n      let ctx = context;\n      let s = this.states[stateNumber];\n      let following = this.nextTokens(s);\n      if (!following.contains(Token_1.Token.EPSILON)) {\n        return following;\n      }\n      let expected = new IntervalSet_1.IntervalSet();\n      expected.addAll(following);\n      expected.remove(Token_1.Token.EPSILON);\n      while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {\n        let invokingState = this.states[ctx.invokingState];\n        let rt = invokingState.transition(0);\n        following = this.nextTokens(rt.followState);\n        expected.addAll(following);\n        expected.remove(Token_1.Token.EPSILON);\n        ctx = ctx._parent;\n      }\n      if (following.contains(Token_1.Token.EPSILON)) {\n        expected.add(Token_1.Token.EOF);\n      }\n      return expected;\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], ATN2.prototype, \"states\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], ATN2.prototype, \"decisionToState\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], ATN2.prototype, \"modeNameToStartState\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], ATN2.prototype, \"modeToStartState\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], ATN2.prototype, \"decisionToDFA\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], ATN2.prototype, \"modeToDFA\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], ATN2.prototype, \"nextTokens\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], ATN2.prototype, \"removeState\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n  ], ATN2.prototype, \"defineMode\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], ATN2.prototype, \"defineDecisionState\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], ATN2.prototype, \"getExpectedTokens\", null);\n  ATN2 = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], ATN2);\n  exports.ATN = ATN2;\n  (function(ATN3) {\n    ATN3.INVALID_ALT_NUMBER = 0;\n  })(ATN2 = exports.ATN || (exports.ATN = {}));\n  exports.ATN = ATN2;\n});\n\n// node_modules/antlr4ts/atn/LexerIndexedCustomAction.js\nvar require_LexerIndexedCustomAction = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.LexerIndexedCustomAction = void 0;\n  var MurmurHash_1 = require_MurmurHash();\n  var Decorators_1 = require_Decorators();\n  var LexerIndexedCustomAction = class LexerIndexedCustomAction2 {\n    constructor(offset, action) {\n      this._offset = offset;\n      this._action = action;\n    }\n    get offset() {\n      return this._offset;\n    }\n    get action() {\n      return this._action;\n    }\n    get actionType() {\n      return this._action.actionType;\n    }\n    get isPositionDependent() {\n      return true;\n    }\n    execute(lexer) {\n      this._action.execute(lexer);\n    }\n    hashCode() {\n      let hash = MurmurHash_1.MurmurHash.initialize();\n      hash = MurmurHash_1.MurmurHash.update(hash, this._offset);\n      hash = MurmurHash_1.MurmurHash.update(hash, this._action);\n      return MurmurHash_1.MurmurHash.finish(hash, 2);\n    }\n    equals(obj) {\n      if (obj === this) {\n        return true;\n      } else if (!(obj instanceof LexerIndexedCustomAction2)) {\n        return false;\n      }\n      return this._offset === obj._offset && this._action.equals(obj._action);\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], LexerIndexedCustomAction.prototype, \"action\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerIndexedCustomAction.prototype, \"actionType\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerIndexedCustomAction.prototype, \"isPositionDependent\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerIndexedCustomAction.prototype, \"execute\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerIndexedCustomAction.prototype, \"hashCode\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerIndexedCustomAction.prototype, \"equals\", null);\n  LexerIndexedCustomAction = __decorate([\n    __param(1, Decorators_1.NotNull)\n  ], LexerIndexedCustomAction);\n  exports.LexerIndexedCustomAction = LexerIndexedCustomAction;\n});\n\n// node_modules/antlr4ts/atn/LexerActionExecutor.js\nvar require_LexerActionExecutor = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.LexerActionExecutor = void 0;\n  var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();\n  var LexerIndexedCustomAction_1 = require_LexerIndexedCustomAction();\n  var MurmurHash_1 = require_MurmurHash();\n  var Decorators_1 = require_Decorators();\n  var LexerActionExecutor = class LexerActionExecutor2 {\n    constructor(lexerActions) {\n      this._lexerActions = lexerActions;\n      let hash = MurmurHash_1.MurmurHash.initialize();\n      for (let lexerAction of lexerActions) {\n        hash = MurmurHash_1.MurmurHash.update(hash, lexerAction);\n      }\n      this.cachedHashCode = MurmurHash_1.MurmurHash.finish(hash, lexerActions.length);\n    }\n    static append(lexerActionExecutor, lexerAction) {\n      if (!lexerActionExecutor) {\n        return new LexerActionExecutor2([lexerAction]);\n      }\n      let lexerActions = lexerActionExecutor._lexerActions.slice(0);\n      lexerActions.push(lexerAction);\n      return new LexerActionExecutor2(lexerActions);\n    }\n    fixOffsetBeforeMatch(offset) {\n      let updatedLexerActions;\n      for (let i = 0; i < this._lexerActions.length; i++) {\n        if (this._lexerActions[i].isPositionDependent && !(this._lexerActions[i] instanceof LexerIndexedCustomAction_1.LexerIndexedCustomAction)) {\n          if (!updatedLexerActions) {\n            updatedLexerActions = this._lexerActions.slice(0);\n          }\n          updatedLexerActions[i] = new LexerIndexedCustomAction_1.LexerIndexedCustomAction(offset, this._lexerActions[i]);\n        }\n      }\n      if (!updatedLexerActions) {\n        return this;\n      }\n      return new LexerActionExecutor2(updatedLexerActions);\n    }\n    get lexerActions() {\n      return this._lexerActions;\n    }\n    execute(lexer, input, startIndex) {\n      let requiresSeek = false;\n      let stopIndex = input.index;\n      try {\n        for (let lexerAction of this._lexerActions) {\n          if (lexerAction instanceof LexerIndexedCustomAction_1.LexerIndexedCustomAction) {\n            let offset = lexerAction.offset;\n            input.seek(startIndex + offset);\n            lexerAction = lexerAction.action;\n            requiresSeek = startIndex + offset !== stopIndex;\n          } else if (lexerAction.isPositionDependent) {\n            input.seek(stopIndex);\n            requiresSeek = false;\n          }\n          lexerAction.execute(lexer);\n        }\n      } finally {\n        if (requiresSeek) {\n          input.seek(stopIndex);\n        }\n      }\n    }\n    hashCode() {\n      return this.cachedHashCode;\n    }\n    equals(obj) {\n      if (obj === this) {\n        return true;\n      } else if (!(obj instanceof LexerActionExecutor2)) {\n        return false;\n      }\n      return this.cachedHashCode === obj.cachedHashCode && ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this._lexerActions, obj._lexerActions);\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], LexerActionExecutor.prototype, \"_lexerActions\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], LexerActionExecutor.prototype, \"lexerActions\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], LexerActionExecutor.prototype, \"execute\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerActionExecutor.prototype, \"hashCode\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerActionExecutor.prototype, \"equals\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(1, Decorators_1.NotNull)\n  ], LexerActionExecutor, \"append\", null);\n  LexerActionExecutor = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], LexerActionExecutor);\n  exports.LexerActionExecutor = LexerActionExecutor;\n});\n\n// node_modules/antlr4ts/LexerNoViableAltException.js\nvar require_LexerNoViableAltException = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.LexerNoViableAltException = void 0;\n  var RecognitionException_1 = require_RecognitionException();\n  var Decorators_1 = require_Decorators();\n  var Interval_1 = require_Interval();\n  var Utils3 = require_Utils();\n  var LexerNoViableAltException = class LexerNoViableAltException extends RecognitionException_1.RecognitionException {\n    constructor(lexer, input, startIndex, deadEndConfigs) {\n      super(lexer, input);\n      this._startIndex = startIndex;\n      this._deadEndConfigs = deadEndConfigs;\n    }\n    get startIndex() {\n      return this._startIndex;\n    }\n    get deadEndConfigs() {\n      return this._deadEndConfigs;\n    }\n    get inputStream() {\n      return super.inputStream;\n    }\n    toString() {\n      let symbol = \"\";\n      if (this._startIndex >= 0 && this._startIndex < this.inputStream.size) {\n        symbol = this.inputStream.getText(Interval_1.Interval.of(this._startIndex, this._startIndex));\n        symbol = Utils3.escapeWhitespace(symbol, false);\n      }\n      return `LexerNoViableAltException('${symbol}')`;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], LexerNoViableAltException.prototype, \"inputStream\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerNoViableAltException.prototype, \"toString\", null);\n  LexerNoViableAltException = __decorate([\n    __param(1, Decorators_1.NotNull)\n  ], LexerNoViableAltException);\n  exports.LexerNoViableAltException = LexerNoViableAltException;\n});\n\n// node_modules/antlr4ts/atn/OrderedATNConfigSet.js\nvar require_OrderedATNConfigSet = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.OrderedATNConfigSet = void 0;\n  var ATNConfigSet_1 = require_ATNConfigSet();\n  var Decorators_1 = require_Decorators();\n  var OrderedATNConfigSet = class extends ATNConfigSet_1.ATNConfigSet {\n    constructor(set, readonly) {\n      if (set != null && readonly != null) {\n        super(set, readonly);\n      } else {\n        super();\n      }\n    }\n    clone(readonly) {\n      let copy = new OrderedATNConfigSet(this, readonly);\n      if (!readonly && this.isReadOnly) {\n        copy.addAll(this);\n      }\n      return copy;\n    }\n    getKey(e) {\n      return {state: 0, alt: e.hashCode()};\n    }\n    canMerge(left, leftKey, right) {\n      return left.equals(right);\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], OrderedATNConfigSet.prototype, \"clone\", null);\n  __decorate([\n    Decorators_1.Override\n  ], OrderedATNConfigSet.prototype, \"getKey\", null);\n  __decorate([\n    Decorators_1.Override\n  ], OrderedATNConfigSet.prototype, \"canMerge\", null);\n  exports.OrderedATNConfigSet = OrderedATNConfigSet;\n});\n\n// node_modules/antlr4ts/atn/LexerATNSimulator.js\nvar require_LexerATNSimulator = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.LexerATNSimulator = void 0;\n  var AcceptStateInfo_1 = require_AcceptStateInfo();\n  var ATN_1 = require_ATN();\n  var ATNConfig_1 = require_ATNConfig();\n  var ATNConfigSet_1 = require_ATNConfigSet();\n  var ATNSimulator_1 = require_ATNSimulator();\n  var DFAState_1 = require_DFAState();\n  var Interval_1 = require_Interval();\n  var IntStream_1 = require_IntStream();\n  var Lexer_1 = require_Lexer();\n  var LexerActionExecutor_1 = require_LexerActionExecutor();\n  var LexerNoViableAltException_1 = require_LexerNoViableAltException();\n  var Decorators_1 = require_Decorators();\n  var OrderedATNConfigSet_1 = require_OrderedATNConfigSet();\n  var PredictionContext_1 = require_PredictionContext();\n  var RuleStopState_1 = require_RuleStopState();\n  var Token_1 = require_Token();\n  var assert = __webpack_require__(/*! assert */ \"assert\");\n  var LexerATNSimulator2 = class LexerATNSimulator3 extends ATNSimulator_1.ATNSimulator {\n    constructor(atn, recog) {\n      super(atn);\n      this.optimize_tail_calls = true;\n      this.startIndex = -1;\n      this._line = 1;\n      this._charPositionInLine = 0;\n      this.mode = Lexer_1.Lexer.DEFAULT_MODE;\n      this.prevAccept = new LexerATNSimulator3.SimState();\n      this.recog = recog;\n    }\n    copyState(simulator) {\n      this._charPositionInLine = simulator.charPositionInLine;\n      this._line = simulator._line;\n      this.mode = simulator.mode;\n      this.startIndex = simulator.startIndex;\n    }\n    match(input, mode) {\n      this.mode = mode;\n      let mark = input.mark();\n      try {\n        this.startIndex = input.index;\n        this.prevAccept.reset();\n        let s0 = this.atn.modeToDFA[mode].s0;\n        if (s0 == null) {\n          return this.matchATN(input);\n        } else {\n          return this.execATN(input, s0);\n        }\n      } finally {\n        input.release(mark);\n      }\n    }\n    reset() {\n      this.prevAccept.reset();\n      this.startIndex = -1;\n      this._line = 1;\n      this._charPositionInLine = 0;\n      this.mode = Lexer_1.Lexer.DEFAULT_MODE;\n    }\n    matchATN(input) {\n      let startState = this.atn.modeToStartState[this.mode];\n      if (LexerATNSimulator3.debug) {\n        console.log(`matchATN mode ${this.mode} start: ${startState}`);\n      }\n      let old_mode = this.mode;\n      let s0_closure = this.computeStartState(input, startState);\n      let suppressEdge = s0_closure.hasSemanticContext;\n      if (suppressEdge) {\n        s0_closure.hasSemanticContext = false;\n      }\n      let next = this.addDFAState(s0_closure);\n      if (!suppressEdge) {\n        let dfa = this.atn.modeToDFA[this.mode];\n        if (!dfa.s0) {\n          dfa.s0 = next;\n        } else {\n          next = dfa.s0;\n        }\n      }\n      let predict = this.execATN(input, next);\n      if (LexerATNSimulator3.debug) {\n        console.log(`DFA after matchATN: ${this.atn.modeToDFA[old_mode].toLexerString()}`);\n      }\n      return predict;\n    }\n    execATN(input, ds0) {\n      if (LexerATNSimulator3.debug) {\n        console.log(`start state closure=${ds0.configs}`);\n      }\n      if (ds0.isAcceptState) {\n        this.captureSimState(this.prevAccept, input, ds0);\n      }\n      let t = input.LA(1);\n      let s = ds0;\n      while (true) {\n        if (LexerATNSimulator3.debug) {\n          console.log(`execATN loop starting closure: ${s.configs}`);\n        }\n        let target = this.getExistingTargetState(s, t);\n        if (target == null) {\n          target = this.computeTargetState(input, s, t);\n        }\n        if (target === ATNSimulator_1.ATNSimulator.ERROR) {\n          break;\n        }\n        if (t !== IntStream_1.IntStream.EOF) {\n          this.consume(input);\n        }\n        if (target.isAcceptState) {\n          this.captureSimState(this.prevAccept, input, target);\n          if (t === IntStream_1.IntStream.EOF) {\n            break;\n          }\n        }\n        t = input.LA(1);\n        s = target;\n      }\n      return this.failOrAccept(this.prevAccept, input, s.configs, t);\n    }\n    getExistingTargetState(s, t) {\n      let target = s.getTarget(t);\n      if (LexerATNSimulator3.debug && target != null) {\n        console.log(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n      }\n      return target;\n    }\n    computeTargetState(input, s, t) {\n      let reach = new OrderedATNConfigSet_1.OrderedATNConfigSet();\n      this.getReachableConfigSet(input, s.configs, reach, t);\n      if (reach.isEmpty) {\n        if (!reach.hasSemanticContext) {\n          this.addDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);\n        }\n        return ATNSimulator_1.ATNSimulator.ERROR;\n      }\n      return this.addDFAEdge(s, t, reach);\n    }\n    failOrAccept(prevAccept, input, reach, t) {\n      if (prevAccept.dfaState != null) {\n        let lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;\n        this.accept(input, lexerActionExecutor, this.startIndex, prevAccept.index, prevAccept.line, prevAccept.charPos);\n        return prevAccept.dfaState.prediction;\n      } else {\n        if (t === IntStream_1.IntStream.EOF && input.index === this.startIndex) {\n          return Token_1.Token.EOF;\n        }\n        throw new LexerNoViableAltException_1.LexerNoViableAltException(this.recog, input, this.startIndex, reach);\n      }\n    }\n    getReachableConfigSet(input, closure, reach, t) {\n      let skipAlt = ATN_1.ATN.INVALID_ALT_NUMBER;\n      for (let c of closure) {\n        let currentAltReachedAcceptState = c.alt === skipAlt;\n        if (currentAltReachedAcceptState && c.hasPassedThroughNonGreedyDecision) {\n          continue;\n        }\n        if (LexerATNSimulator3.debug) {\n          console.log(`testing ${this.getTokenName(t)} at ${c.toString(this.recog, true)}`);\n        }\n        let n = c.state.numberOfOptimizedTransitions;\n        for (let ti = 0; ti < n; ti++) {\n          let trans = c.state.getOptimizedTransition(ti);\n          let target = this.getReachableTarget(trans, t);\n          if (target != null) {\n            let lexerActionExecutor = c.lexerActionExecutor;\n            let config;\n            if (lexerActionExecutor != null) {\n              lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);\n              config = c.transform(target, true, lexerActionExecutor);\n            } else {\n              assert(c.lexerActionExecutor == null);\n              config = c.transform(target, true);\n            }\n            let treatEofAsEpsilon = t === IntStream_1.IntStream.EOF;\n            if (this.closure(input, config, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {\n              skipAlt = c.alt;\n              break;\n            }\n          }\n        }\n      }\n    }\n    accept(input, lexerActionExecutor, startIndex, index, line, charPos) {\n      if (LexerATNSimulator3.debug) {\n        console.log(`ACTION ${lexerActionExecutor}`);\n      }\n      input.seek(index);\n      this._line = line;\n      this._charPositionInLine = charPos;\n      if (lexerActionExecutor != null && this.recog != null) {\n        lexerActionExecutor.execute(this.recog, input, startIndex);\n      }\n    }\n    getReachableTarget(trans, t) {\n      if (trans.matches(t, Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE)) {\n        return trans.target;\n      }\n      return void 0;\n    }\n    computeStartState(input, p) {\n      let initialContext = PredictionContext_1.PredictionContext.EMPTY_FULL;\n      let configs = new OrderedATNConfigSet_1.OrderedATNConfigSet();\n      for (let i = 0; i < p.numberOfTransitions; i++) {\n        let target = p.transition(i).target;\n        let c = ATNConfig_1.ATNConfig.create(target, i + 1, initialContext);\n        this.closure(input, c, configs, false, false, false);\n      }\n      return configs;\n    }\n    closure(input, config, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {\n      if (LexerATNSimulator3.debug) {\n        console.log(\"closure(\" + config.toString(this.recog, true) + \")\");\n      }\n      if (config.state instanceof RuleStopState_1.RuleStopState) {\n        if (LexerATNSimulator3.debug) {\n          if (this.recog != null) {\n            console.log(`closure at ${this.recog.ruleNames[config.state.ruleIndex]} rule stop ${config}`);\n          } else {\n            console.log(`closure at rule stop ${config}`);\n          }\n        }\n        let context = config.context;\n        if (context.isEmpty) {\n          configs.add(config);\n          return true;\n        } else if (context.hasEmpty) {\n          configs.add(config.transform(config.state, true, PredictionContext_1.PredictionContext.EMPTY_FULL));\n          currentAltReachedAcceptState = true;\n        }\n        for (let i = 0; i < context.size; i++) {\n          let returnStateNumber = context.getReturnState(i);\n          if (returnStateNumber === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {\n            continue;\n          }\n          let newContext = context.getParent(i);\n          let returnState = this.atn.states[returnStateNumber];\n          let c = config.transform(returnState, false, newContext);\n          currentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);\n        }\n        return currentAltReachedAcceptState;\n      }\n      if (!config.state.onlyHasEpsilonTransitions) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision) {\n          configs.add(config);\n        }\n      }\n      let p = config.state;\n      for (let i = 0; i < p.numberOfOptimizedTransitions; i++) {\n        let t = p.getOptimizedTransition(i);\n        let c = this.getEpsilonTarget(input, config, t, configs, speculative, treatEofAsEpsilon);\n        if (c != null) {\n          currentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);\n        }\n      }\n      return currentAltReachedAcceptState;\n    }\n    getEpsilonTarget(input, config, t, configs, speculative, treatEofAsEpsilon) {\n      let c;\n      switch (t.serializationType) {\n        case 3:\n          let ruleTransition = t;\n          if (this.optimize_tail_calls && ruleTransition.optimizedTailCall && !config.context.hasEmpty) {\n            c = config.transform(t.target, true);\n          } else {\n            let newContext = config.context.getChild(ruleTransition.followState.stateNumber);\n            c = config.transform(t.target, true, newContext);\n          }\n          break;\n        case 10:\n          throw new Error(\"Precedence predicates are not supported in lexers.\");\n        case 4:\n          let pt = t;\n          if (LexerATNSimulator3.debug) {\n            console.log(\"EVAL rule \" + pt.ruleIndex + \":\" + pt.predIndex);\n          }\n          configs.hasSemanticContext = true;\n          if (this.evaluatePredicate(input, pt.ruleIndex, pt.predIndex, speculative)) {\n            c = config.transform(t.target, true);\n          } else {\n            c = void 0;\n          }\n          break;\n        case 6:\n          if (config.context.hasEmpty) {\n            let lexerActionExecutor = LexerActionExecutor_1.LexerActionExecutor.append(config.lexerActionExecutor, this.atn.lexerActions[t.actionIndex]);\n            c = config.transform(t.target, true, lexerActionExecutor);\n            break;\n          } else {\n            c = config.transform(t.target, true);\n            break;\n          }\n        case 1:\n          c = config.transform(t.target, true);\n          break;\n        case 5:\n        case 2:\n        case 7:\n          if (treatEofAsEpsilon) {\n            if (t.matches(IntStream_1.IntStream.EOF, Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE)) {\n              c = config.transform(t.target, false);\n              break;\n            }\n          }\n          c = void 0;\n          break;\n        default:\n          c = void 0;\n          break;\n      }\n      return c;\n    }\n    evaluatePredicate(input, ruleIndex, predIndex, speculative) {\n      if (this.recog == null) {\n        return true;\n      }\n      if (!speculative) {\n        return this.recog.sempred(void 0, ruleIndex, predIndex);\n      }\n      let savedCharPositionInLine = this._charPositionInLine;\n      let savedLine = this._line;\n      let index = input.index;\n      let marker = input.mark();\n      try {\n        this.consume(input);\n        return this.recog.sempred(void 0, ruleIndex, predIndex);\n      } finally {\n        this._charPositionInLine = savedCharPositionInLine;\n        this._line = savedLine;\n        input.seek(index);\n        input.release(marker);\n      }\n    }\n    captureSimState(settings, input, dfaState) {\n      settings.index = input.index;\n      settings.line = this._line;\n      settings.charPos = this._charPositionInLine;\n      settings.dfaState = dfaState;\n    }\n    addDFAEdge(p, t, q) {\n      if (q instanceof ATNConfigSet_1.ATNConfigSet) {\n        let suppressEdge = q.hasSemanticContext;\n        if (suppressEdge) {\n          q.hasSemanticContext = false;\n        }\n        let to = this.addDFAState(q);\n        if (suppressEdge) {\n          return to;\n        }\n        this.addDFAEdge(p, t, to);\n        return to;\n      } else {\n        if (LexerATNSimulator3.debug) {\n          console.log(\"EDGE \" + p + \" -> \" + q + \" upon \" + String.fromCharCode(t));\n        }\n        if (p != null) {\n          p.setTarget(t, q);\n        }\n      }\n    }\n    addDFAState(configs) {\n      assert(!configs.hasSemanticContext);\n      let proposed = new DFAState_1.DFAState(configs);\n      let existing = this.atn.modeToDFA[this.mode].states.get(proposed);\n      if (existing != null) {\n        return existing;\n      }\n      configs.optimizeConfigs(this);\n      let newState = new DFAState_1.DFAState(configs.clone(true));\n      let firstConfigWithRuleStopState;\n      for (let c of configs) {\n        if (c.state instanceof RuleStopState_1.RuleStopState) {\n          firstConfigWithRuleStopState = c;\n          break;\n        }\n      }\n      if (firstConfigWithRuleStopState != null) {\n        let prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];\n        let lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;\n        newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(prediction, lexerActionExecutor);\n      }\n      return this.atn.modeToDFA[this.mode].addState(newState);\n    }\n    getDFA(mode) {\n      return this.atn.modeToDFA[mode];\n    }\n    getText(input) {\n      return input.getText(Interval_1.Interval.of(this.startIndex, input.index - 1));\n    }\n    get line() {\n      return this._line;\n    }\n    set line(line) {\n      this._line = line;\n    }\n    get charPositionInLine() {\n      return this._charPositionInLine;\n    }\n    set charPositionInLine(charPositionInLine) {\n      this._charPositionInLine = charPositionInLine;\n    }\n    consume(input) {\n      let curChar = input.LA(1);\n      if (curChar === \"\\n\".charCodeAt(0)) {\n        this._line++;\n        this._charPositionInLine = 0;\n      } else {\n        this._charPositionInLine++;\n      }\n      input.consume();\n    }\n    getTokenName(t) {\n      if (t === -1) {\n        return \"EOF\";\n      }\n      return \"'\" + String.fromCharCode(t) + \"'\";\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], LexerATNSimulator2.prototype, \"prevAccept\", void 0);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], LexerATNSimulator2.prototype, \"copyState\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], LexerATNSimulator2.prototype, \"match\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerATNSimulator2.prototype, \"reset\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], LexerATNSimulator2.prototype, \"matchATN\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n  ], LexerATNSimulator2.prototype, \"execATN\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], LexerATNSimulator2.prototype, \"getExistingTargetState\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n  ], LexerATNSimulator2.prototype, \"computeTargetState\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n  ], LexerATNSimulator2.prototype, \"getReachableConfigSet\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], LexerATNSimulator2.prototype, \"accept\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n  ], LexerATNSimulator2.prototype, \"computeStartState\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n  ], LexerATNSimulator2.prototype, \"closure\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull),\n    __param(3, Decorators_1.NotNull)\n  ], LexerATNSimulator2.prototype, \"getEpsilonTarget\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], LexerATNSimulator2.prototype, \"evaluatePredicate\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n  ], LexerATNSimulator2.prototype, \"captureSimState\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n  ], LexerATNSimulator2.prototype, \"addDFAState\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], LexerATNSimulator2.prototype, \"getDFA\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n  ], LexerATNSimulator2.prototype, \"getText\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], LexerATNSimulator2.prototype, \"consume\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], LexerATNSimulator2.prototype, \"getTokenName\", null);\n  LexerATNSimulator2 = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], LexerATNSimulator2);\n  exports.LexerATNSimulator = LexerATNSimulator2;\n  (function(LexerATNSimulator3) {\n    LexerATNSimulator3.debug = false;\n    LexerATNSimulator3.dfa_debug = false;\n    class SimState {\n      constructor() {\n        this.index = -1;\n        this.line = 0;\n        this.charPos = -1;\n      }\n      reset() {\n        this.index = -1;\n        this.line = 0;\n        this.charPos = -1;\n        this.dfaState = void 0;\n      }\n    }\n    LexerATNSimulator3.SimState = SimState;\n  })(LexerATNSimulator2 = exports.LexerATNSimulator || (exports.LexerATNSimulator = {}));\n  exports.LexerATNSimulator = LexerATNSimulator2;\n});\n\n// node_modules/antlr4ts/Lexer.js\nvar require_Lexer = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.Lexer = void 0;\n  var CommonTokenFactory_1 = require_CommonTokenFactory();\n  var IntegerStack_1 = require_IntegerStack();\n  var Interval_1 = require_Interval();\n  var IntStream_1 = require_IntStream();\n  var LexerATNSimulator_1 = require_LexerATNSimulator();\n  var LexerNoViableAltException_1 = require_LexerNoViableAltException();\n  var Decorators_1 = require_Decorators();\n  var Recognizer_1 = require_Recognizer();\n  var Token_1 = require_Token();\n  var Lexer2 = class extends Recognizer_1.Recognizer {\n    constructor(input) {\n      super();\n      this._factory = CommonTokenFactory_1.CommonTokenFactory.DEFAULT;\n      this._tokenStartCharIndex = -1;\n      this._tokenStartLine = 0;\n      this._tokenStartCharPositionInLine = 0;\n      this._hitEOF = false;\n      this._channel = 0;\n      this._type = 0;\n      this._modeStack = new IntegerStack_1.IntegerStack();\n      this._mode = Lexer2.DEFAULT_MODE;\n      this._input = input;\n      this._tokenFactorySourcePair = {source: this, stream: input};\n    }\n    static get DEFAULT_TOKEN_CHANNEL() {\n      return Token_1.Token.DEFAULT_CHANNEL;\n    }\n    static get HIDDEN() {\n      return Token_1.Token.HIDDEN_CHANNEL;\n    }\n    reset(resetInput) {\n      if (resetInput === void 0 || resetInput) {\n        this._input.seek(0);\n      }\n      this._token = void 0;\n      this._type = Token_1.Token.INVALID_TYPE;\n      this._channel = Token_1.Token.DEFAULT_CHANNEL;\n      this._tokenStartCharIndex = -1;\n      this._tokenStartCharPositionInLine = -1;\n      this._tokenStartLine = -1;\n      this._text = void 0;\n      this._hitEOF = false;\n      this._mode = Lexer2.DEFAULT_MODE;\n      this._modeStack.clear();\n      this.interpreter.reset();\n    }\n    nextToken() {\n      if (this._input == null) {\n        throw new Error(\"nextToken requires a non-null input stream.\");\n      }\n      let tokenStartMarker = this._input.mark();\n      try {\n        outer:\n          while (true) {\n            if (this._hitEOF) {\n              return this.emitEOF();\n            }\n            this._token = void 0;\n            this._channel = Token_1.Token.DEFAULT_CHANNEL;\n            this._tokenStartCharIndex = this._input.index;\n            this._tokenStartCharPositionInLine = this.interpreter.charPositionInLine;\n            this._tokenStartLine = this.interpreter.line;\n            this._text = void 0;\n            do {\n              this._type = Token_1.Token.INVALID_TYPE;\n              let ttype;\n              try {\n                ttype = this.interpreter.match(this._input, this._mode);\n              } catch (e) {\n                if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {\n                  this.notifyListeners(e);\n                  this.recover(e);\n                  ttype = Lexer2.SKIP;\n                } else {\n                  throw e;\n                }\n              }\n              if (this._input.LA(1) === IntStream_1.IntStream.EOF) {\n                this._hitEOF = true;\n              }\n              if (this._type === Token_1.Token.INVALID_TYPE) {\n                this._type = ttype;\n              }\n              if (this._type === Lexer2.SKIP) {\n                continue outer;\n              }\n            } while (this._type === Lexer2.MORE);\n            if (this._token == null) {\n              return this.emit();\n            }\n            return this._token;\n          }\n      } finally {\n        this._input.release(tokenStartMarker);\n      }\n    }\n    skip() {\n      this._type = Lexer2.SKIP;\n    }\n    more() {\n      this._type = Lexer2.MORE;\n    }\n    mode(m) {\n      this._mode = m;\n    }\n    pushMode(m) {\n      if (LexerATNSimulator_1.LexerATNSimulator.debug) {\n        console.log(\"pushMode \" + m);\n      }\n      this._modeStack.push(this._mode);\n      this.mode(m);\n    }\n    popMode() {\n      if (this._modeStack.isEmpty) {\n        throw new Error(\"EmptyStackException\");\n      }\n      if (LexerATNSimulator_1.LexerATNSimulator.debug) {\n        console.log(\"popMode back to \" + this._modeStack.peek());\n      }\n      this.mode(this._modeStack.pop());\n      return this._mode;\n    }\n    get tokenFactory() {\n      return this._factory;\n    }\n    set tokenFactory(factory) {\n      this._factory = factory;\n    }\n    get inputStream() {\n      return this._input;\n    }\n    set inputStream(input) {\n      this.reset(false);\n      this._input = input;\n      this._tokenFactorySourcePair = {source: this, stream: this._input};\n    }\n    get sourceName() {\n      return this._input.sourceName;\n    }\n    emit(token) {\n      if (!token) {\n        token = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.charIndex - 1, this._tokenStartLine, this._tokenStartCharPositionInLine);\n      }\n      this._token = token;\n      return token;\n    }\n    emitEOF() {\n      let cpos = this.charPositionInLine;\n      let line = this.line;\n      let eof = this._factory.create(this._tokenFactorySourcePair, Token_1.Token.EOF, void 0, Token_1.Token.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, line, cpos);\n      this.emit(eof);\n      return eof;\n    }\n    get line() {\n      return this.interpreter.line;\n    }\n    set line(line) {\n      this.interpreter.line = line;\n    }\n    get charPositionInLine() {\n      return this.interpreter.charPositionInLine;\n    }\n    set charPositionInLine(charPositionInLine) {\n      this.interpreter.charPositionInLine = charPositionInLine;\n    }\n    get charIndex() {\n      return this._input.index;\n    }\n    get text() {\n      if (this._text != null) {\n        return this._text;\n      }\n      return this.interpreter.getText(this._input);\n    }\n    set text(text) {\n      this._text = text;\n    }\n    get token() {\n      return this._token;\n    }\n    set token(_token) {\n      this._token = _token;\n    }\n    set type(ttype) {\n      this._type = ttype;\n    }\n    get type() {\n      return this._type;\n    }\n    set channel(channel) {\n      this._channel = channel;\n    }\n    get channel() {\n      return this._channel;\n    }\n    getAllTokens() {\n      let tokens2 = [];\n      let t = this.nextToken();\n      while (t.type !== Token_1.Token.EOF) {\n        tokens2.push(t);\n        t = this.nextToken();\n      }\n      return tokens2;\n    }\n    notifyListeners(e) {\n      let text = this._input.getText(Interval_1.Interval.of(this._tokenStartCharIndex, this._input.index));\n      let msg = \"token recognition error at: '\" + this.getErrorDisplay(text) + \"'\";\n      let listener = this.getErrorListenerDispatch();\n      if (listener.syntaxError) {\n        listener.syntaxError(this, void 0, this._tokenStartLine, this._tokenStartCharPositionInLine, msg, e);\n      }\n    }\n    getErrorDisplay(s) {\n      if (typeof s === \"number\") {\n        switch (s) {\n          case Token_1.Token.EOF:\n            return \"<EOF>\";\n          case 10:\n            return \"\\\\n\";\n          case 9:\n            return \"\\\\t\";\n          case 13:\n            return \"\\\\r\";\n        }\n        return String.fromCharCode(s);\n      }\n      return s.replace(/\\n/g, \"\\\\n\").replace(/\\t/g, \"\\\\t\").replace(/\\r/g, \"\\\\r\");\n    }\n    getCharErrorDisplay(c) {\n      let s = this.getErrorDisplay(c);\n      return \"'\" + s + \"'\";\n    }\n    recover(re) {\n      if (re instanceof LexerNoViableAltException_1.LexerNoViableAltException) {\n        if (this._input.LA(1) !== IntStream_1.IntStream.EOF) {\n          this.interpreter.consume(this._input);\n        }\n      } else {\n        this._input.consume();\n      }\n    }\n  };\n  Lexer2.DEFAULT_MODE = 0;\n  Lexer2.MORE = -2;\n  Lexer2.SKIP = -3;\n  Lexer2.MIN_CHAR_VALUE = 0;\n  Lexer2.MAX_CHAR_VALUE = 1114111;\n  __decorate([\n    Decorators_1.Override\n  ], Lexer2.prototype, \"nextToken\", null);\n  __decorate([\n    Decorators_1.Override\n  ], Lexer2.prototype, \"tokenFactory\", null);\n  __decorate([\n    Decorators_1.Override\n  ], Lexer2.prototype, \"inputStream\", null);\n  __decorate([\n    Decorators_1.Override\n  ], Lexer2.prototype, \"sourceName\", null);\n  __decorate([\n    Decorators_1.Override\n  ], Lexer2.prototype, \"line\", null);\n  __decorate([\n    Decorators_1.Override\n  ], Lexer2.prototype, \"charPositionInLine\", null);\n  exports.Lexer = Lexer2;\n});\n\n// node_modules/antlr4ts/misc/IntervalSet.js\nvar require_IntervalSet = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.IntervalSet = void 0;\n  var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();\n  var IntegerList_1 = require_IntegerList();\n  var Interval_1 = require_Interval();\n  var Lexer_1 = require_Lexer();\n  var MurmurHash_1 = require_MurmurHash();\n  var Decorators_1 = require_Decorators();\n  var Token_1 = require_Token();\n  var IntervalSet = class {\n    constructor(intervals) {\n      this.readonly = false;\n      if (intervals != null) {\n        this._intervals = intervals.slice(0);\n      } else {\n        this._intervals = [];\n      }\n    }\n    static get COMPLETE_CHAR_SET() {\n      if (IntervalSet._COMPLETE_CHAR_SET === void 0) {\n        IntervalSet._COMPLETE_CHAR_SET = IntervalSet.of(Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE);\n        IntervalSet._COMPLETE_CHAR_SET.setReadonly(true);\n      }\n      return IntervalSet._COMPLETE_CHAR_SET;\n    }\n    static get EMPTY_SET() {\n      if (IntervalSet._EMPTY_SET == null) {\n        IntervalSet._EMPTY_SET = new IntervalSet();\n        IntervalSet._EMPTY_SET.setReadonly(true);\n      }\n      return IntervalSet._EMPTY_SET;\n    }\n    static of(a, b = a) {\n      let s = new IntervalSet();\n      s.add(a, b);\n      return s;\n    }\n    clear() {\n      if (this.readonly) {\n        throw new Error(\"can't alter readonly IntervalSet\");\n      }\n      this._intervals.length = 0;\n    }\n    add(a, b = a) {\n      this.addRange(Interval_1.Interval.of(a, b));\n    }\n    addRange(addition) {\n      if (this.readonly) {\n        throw new Error(\"can't alter readonly IntervalSet\");\n      }\n      if (addition.b < addition.a) {\n        return;\n      }\n      for (let i = 0; i < this._intervals.length; i++) {\n        let r = this._intervals[i];\n        if (addition.equals(r)) {\n          return;\n        }\n        if (addition.adjacent(r) || !addition.disjoint(r)) {\n          let bigger = addition.union(r);\n          this._intervals[i] = bigger;\n          while (i < this._intervals.length - 1) {\n            i++;\n            let next = this._intervals[i];\n            if (!bigger.adjacent(next) && bigger.disjoint(next)) {\n              break;\n            }\n            this._intervals.splice(i, 1);\n            i--;\n            this._intervals[i] = bigger.union(next);\n          }\n          return;\n        }\n        if (addition.startsBeforeDisjoint(r)) {\n          this._intervals.splice(i, 0, addition);\n          return;\n        }\n      }\n      this._intervals.push(addition);\n    }\n    static or(sets) {\n      let r = new IntervalSet();\n      for (let s of sets) {\n        r.addAll(s);\n      }\n      return r;\n    }\n    addAll(set) {\n      if (set == null) {\n        return this;\n      }\n      if (set instanceof IntervalSet) {\n        let other = set;\n        let n = other._intervals.length;\n        for (let i = 0; i < n; i++) {\n          let I = other._intervals[i];\n          this.add(I.a, I.b);\n        }\n      } else {\n        for (let value of set.toArray()) {\n          this.add(value);\n        }\n      }\n      return this;\n    }\n    complementRange(minElement, maxElement) {\n      return this.complement(IntervalSet.of(minElement, maxElement));\n    }\n    complement(vocabulary) {\n      if (vocabulary.isNil) {\n        return IntervalSet.EMPTY_SET;\n      }\n      let vocabularyIS;\n      if (vocabulary instanceof IntervalSet) {\n        vocabularyIS = vocabulary;\n      } else {\n        vocabularyIS = new IntervalSet();\n        vocabularyIS.addAll(vocabulary);\n      }\n      return vocabularyIS.subtract(this);\n    }\n    subtract(a) {\n      if (a == null || a.isNil) {\n        return new IntervalSet(this._intervals);\n      }\n      if (a instanceof IntervalSet) {\n        return IntervalSet.subtract(this, a);\n      }\n      let other = new IntervalSet();\n      other.addAll(a);\n      return IntervalSet.subtract(this, other);\n    }\n    static subtract(left, right) {\n      if (left.isNil) {\n        return new IntervalSet();\n      }\n      let result = new IntervalSet(left._intervals);\n      if (right.isNil) {\n        return result;\n      }\n      let resultI = 0;\n      let rightI = 0;\n      while (resultI < result._intervals.length && rightI < right._intervals.length) {\n        let resultInterval = result._intervals[resultI];\n        let rightInterval = right._intervals[rightI];\n        if (rightInterval.b < resultInterval.a) {\n          rightI++;\n          continue;\n        }\n        if (rightInterval.a > resultInterval.b) {\n          resultI++;\n          continue;\n        }\n        let beforeCurrent;\n        let afterCurrent;\n        if (rightInterval.a > resultInterval.a) {\n          beforeCurrent = new Interval_1.Interval(resultInterval.a, rightInterval.a - 1);\n        }\n        if (rightInterval.b < resultInterval.b) {\n          afterCurrent = new Interval_1.Interval(rightInterval.b + 1, resultInterval.b);\n        }\n        if (beforeCurrent) {\n          if (afterCurrent) {\n            result._intervals[resultI] = beforeCurrent;\n            result._intervals.splice(resultI + 1, 0, afterCurrent);\n            resultI++;\n            rightI++;\n            continue;\n          } else {\n            result._intervals[resultI] = beforeCurrent;\n            resultI++;\n            continue;\n          }\n        } else {\n          if (afterCurrent) {\n            result._intervals[resultI] = afterCurrent;\n            rightI++;\n            continue;\n          } else {\n            result._intervals.splice(resultI, 1);\n            continue;\n          }\n        }\n      }\n      return result;\n    }\n    or(a) {\n      let o = new IntervalSet();\n      o.addAll(this);\n      o.addAll(a);\n      return o;\n    }\n    and(other) {\n      if (other.isNil) {\n        return new IntervalSet();\n      }\n      let myIntervals = this._intervals;\n      let theirIntervals = other._intervals;\n      let intersection;\n      let mySize = myIntervals.length;\n      let theirSize = theirIntervals.length;\n      let i = 0;\n      let j = 0;\n      while (i < mySize && j < theirSize) {\n        let mine = myIntervals[i];\n        let theirs = theirIntervals[j];\n        if (mine.startsBeforeDisjoint(theirs)) {\n          i++;\n        } else if (theirs.startsBeforeDisjoint(mine)) {\n          j++;\n        } else if (mine.properlyContains(theirs)) {\n          if (!intersection) {\n            intersection = new IntervalSet();\n          }\n          intersection.addRange(mine.intersection(theirs));\n          j++;\n        } else if (theirs.properlyContains(mine)) {\n          if (!intersection) {\n            intersection = new IntervalSet();\n          }\n          intersection.addRange(mine.intersection(theirs));\n          i++;\n        } else if (!mine.disjoint(theirs)) {\n          if (!intersection) {\n            intersection = new IntervalSet();\n          }\n          intersection.addRange(mine.intersection(theirs));\n          if (mine.startsAfterNonDisjoint(theirs)) {\n            j++;\n          } else if (theirs.startsAfterNonDisjoint(mine)) {\n            i++;\n          }\n        }\n      }\n      if (!intersection) {\n        return new IntervalSet();\n      }\n      return intersection;\n    }\n    contains(el) {\n      let n = this._intervals.length;\n      let l = 0;\n      let r = n - 1;\n      while (l <= r) {\n        let m = l + r >> 1;\n        let I = this._intervals[m];\n        let a = I.a;\n        let b = I.b;\n        if (b < el) {\n          l = m + 1;\n        } else if (a > el) {\n          r = m - 1;\n        } else {\n          return true;\n        }\n      }\n      return false;\n    }\n    get isNil() {\n      return this._intervals == null || this._intervals.length === 0;\n    }\n    get maxElement() {\n      if (this.isNil) {\n        throw new RangeError(\"set is empty\");\n      }\n      let last = this._intervals[this._intervals.length - 1];\n      return last.b;\n    }\n    get minElement() {\n      if (this.isNil) {\n        throw new RangeError(\"set is empty\");\n      }\n      return this._intervals[0].a;\n    }\n    get intervals() {\n      return this._intervals;\n    }\n    hashCode() {\n      let hash = MurmurHash_1.MurmurHash.initialize();\n      for (let I of this._intervals) {\n        hash = MurmurHash_1.MurmurHash.update(hash, I.a);\n        hash = MurmurHash_1.MurmurHash.update(hash, I.b);\n      }\n      hash = MurmurHash_1.MurmurHash.finish(hash, this._intervals.length * 2);\n      return hash;\n    }\n    equals(o) {\n      if (o == null || !(o instanceof IntervalSet)) {\n        return false;\n      }\n      return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this._intervals, o._intervals);\n    }\n    toString(elemAreChar = false) {\n      let buf = \"\";\n      if (this._intervals == null || this._intervals.length === 0) {\n        return \"{}\";\n      }\n      if (this.size > 1) {\n        buf += \"{\";\n      }\n      let first = true;\n      for (let I of this._intervals) {\n        if (first) {\n          first = false;\n        } else {\n          buf += \", \";\n        }\n        let a = I.a;\n        let b = I.b;\n        if (a === b) {\n          if (a === Token_1.Token.EOF) {\n            buf += \"<EOF>\";\n          } else if (elemAreChar) {\n            buf += \"'\" + String.fromCodePoint(a) + \"'\";\n          } else {\n            buf += a;\n          }\n        } else {\n          if (elemAreChar) {\n            buf += \"'\" + String.fromCodePoint(a) + \"'..'\" + String.fromCodePoint(b) + \"'\";\n          } else {\n            buf += a + \"..\" + b;\n          }\n        }\n      }\n      if (this.size > 1) {\n        buf += \"}\";\n      }\n      return buf;\n    }\n    toStringVocabulary(vocabulary) {\n      if (this._intervals == null || this._intervals.length === 0) {\n        return \"{}\";\n      }\n      let buf = \"\";\n      if (this.size > 1) {\n        buf += \"{\";\n      }\n      let first = true;\n      for (let I of this._intervals) {\n        if (first) {\n          first = false;\n        } else {\n          buf += \", \";\n        }\n        let a = I.a;\n        let b = I.b;\n        if (a === b) {\n          buf += this.elementName(vocabulary, a);\n        } else {\n          for (let i = a; i <= b; i++) {\n            if (i > a) {\n              buf += \", \";\n            }\n            buf += this.elementName(vocabulary, i);\n          }\n        }\n      }\n      if (this.size > 1) {\n        buf += \"}\";\n      }\n      return buf;\n    }\n    elementName(vocabulary, a) {\n      if (a === Token_1.Token.EOF) {\n        return \"<EOF>\";\n      } else if (a === Token_1.Token.EPSILON) {\n        return \"<EPSILON>\";\n      } else {\n        return vocabulary.getDisplayName(a);\n      }\n    }\n    get size() {\n      let n = 0;\n      let numIntervals = this._intervals.length;\n      if (numIntervals === 1) {\n        let firstInterval = this._intervals[0];\n        return firstInterval.b - firstInterval.a + 1;\n      }\n      for (let i = 0; i < numIntervals; i++) {\n        let I = this._intervals[i];\n        n += I.b - I.a + 1;\n      }\n      return n;\n    }\n    toIntegerList() {\n      let values = new IntegerList_1.IntegerList(this.size);\n      let n = this._intervals.length;\n      for (let i = 0; i < n; i++) {\n        let I = this._intervals[i];\n        let a = I.a;\n        let b = I.b;\n        for (let v = a; v <= b; v++) {\n          values.add(v);\n        }\n      }\n      return values;\n    }\n    toSet() {\n      let s = new Set();\n      for (let I of this._intervals) {\n        let a = I.a;\n        let b = I.b;\n        for (let v = a; v <= b; v++) {\n          s.add(v);\n        }\n      }\n      return s;\n    }\n    toArray() {\n      let values = new Array();\n      let n = this._intervals.length;\n      for (let i = 0; i < n; i++) {\n        let I = this._intervals[i];\n        let a = I.a;\n        let b = I.b;\n        for (let v = a; v <= b; v++) {\n          values.push(v);\n        }\n      }\n      return values;\n    }\n    remove(el) {\n      if (this.readonly) {\n        throw new Error(\"can't alter readonly IntervalSet\");\n      }\n      let n = this._intervals.length;\n      for (let i = 0; i < n; i++) {\n        let I = this._intervals[i];\n        let a = I.a;\n        let b = I.b;\n        if (el < a) {\n          break;\n        }\n        if (el === a && el === b) {\n          this._intervals.splice(i, 1);\n          break;\n        }\n        if (el === a) {\n          this._intervals[i] = Interval_1.Interval.of(I.a + 1, I.b);\n          break;\n        }\n        if (el === b) {\n          this._intervals[i] = Interval_1.Interval.of(I.a, I.b - 1);\n          break;\n        }\n        if (el > a && el < b) {\n          let oldb = I.b;\n          this._intervals[i] = Interval_1.Interval.of(I.a, el - 1);\n          this.add(el + 1, oldb);\n        }\n      }\n    }\n    get isReadonly() {\n      return this.readonly;\n    }\n    setReadonly(readonly) {\n      if (this.readonly && !readonly) {\n        throw new Error(\"can't alter readonly IntervalSet\");\n      }\n      this.readonly = readonly;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], IntervalSet.prototype, \"addAll\", null);\n  __decorate([\n    Decorators_1.Override\n  ], IntervalSet.prototype, \"complement\", null);\n  __decorate([\n    Decorators_1.Override\n  ], IntervalSet.prototype, \"subtract\", null);\n  __decorate([\n    Decorators_1.Override\n  ], IntervalSet.prototype, \"or\", null);\n  __decorate([\n    Decorators_1.Override\n  ], IntervalSet.prototype, \"and\", null);\n  __decorate([\n    Decorators_1.Override\n  ], IntervalSet.prototype, \"contains\", null);\n  __decorate([\n    Decorators_1.Override\n  ], IntervalSet.prototype, \"isNil\", null);\n  __decorate([\n    Decorators_1.Override\n  ], IntervalSet.prototype, \"hashCode\", null);\n  __decorate([\n    Decorators_1.Override\n  ], IntervalSet.prototype, \"equals\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], IntervalSet.prototype, \"toStringVocabulary\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n  ], IntervalSet.prototype, \"elementName\", null);\n  __decorate([\n    Decorators_1.Override\n  ], IntervalSet.prototype, \"size\", null);\n  __decorate([\n    Decorators_1.Override\n  ], IntervalSet.prototype, \"remove\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], IntervalSet, \"of\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], IntervalSet, \"subtract\", null);\n  exports.IntervalSet = IntervalSet;\n});\n\n// node_modules/antlr4ts/atn/ATNDeserializationOptions.js\nvar require_ATNDeserializationOptions = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ATNDeserializationOptions = void 0;\n  var Decorators_1 = require_Decorators();\n  var ATNDeserializationOptions = class {\n    constructor(options) {\n      this.readOnly = false;\n      if (options) {\n        this.verifyATN = options.verifyATN;\n        this.generateRuleBypassTransitions = options.generateRuleBypassTransitions;\n        this.optimize = options.optimize;\n      } else {\n        this.verifyATN = true;\n        this.generateRuleBypassTransitions = false;\n        this.optimize = true;\n      }\n    }\n    static get defaultOptions() {\n      if (ATNDeserializationOptions._defaultOptions == null) {\n        ATNDeserializationOptions._defaultOptions = new ATNDeserializationOptions();\n        ATNDeserializationOptions._defaultOptions.makeReadOnly();\n      }\n      return ATNDeserializationOptions._defaultOptions;\n    }\n    get isReadOnly() {\n      return this.readOnly;\n    }\n    makeReadOnly() {\n      this.readOnly = true;\n    }\n    get isVerifyATN() {\n      return this.verifyATN;\n    }\n    set isVerifyATN(verifyATN) {\n      this.throwIfReadOnly();\n      this.verifyATN = verifyATN;\n    }\n    get isGenerateRuleBypassTransitions() {\n      return this.generateRuleBypassTransitions;\n    }\n    set isGenerateRuleBypassTransitions(generateRuleBypassTransitions) {\n      this.throwIfReadOnly();\n      this.generateRuleBypassTransitions = generateRuleBypassTransitions;\n    }\n    get isOptimize() {\n      return this.optimize;\n    }\n    set isOptimize(optimize) {\n      this.throwIfReadOnly();\n      this.optimize = optimize;\n    }\n    throwIfReadOnly() {\n      if (this.isReadOnly) {\n        throw new Error(\"The object is read only.\");\n      }\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], ATNDeserializationOptions, \"defaultOptions\", null);\n  exports.ATNDeserializationOptions = ATNDeserializationOptions;\n});\n\n// node_modules/antlr4ts/atn/ActionTransition.js\nvar require_ActionTransition = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ActionTransition = void 0;\n  var Decorators_1 = require_Decorators();\n  var Transition_1 = require_Transition();\n  var ActionTransition = class ActionTransition extends Transition_1.Transition {\n    constructor(target, ruleIndex, actionIndex = -1, isCtxDependent = false) {\n      super(target);\n      this.ruleIndex = ruleIndex;\n      this.actionIndex = actionIndex;\n      this.isCtxDependent = isCtxDependent;\n    }\n    get serializationType() {\n      return 6;\n    }\n    get isEpsilon() {\n      return true;\n    }\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n      return false;\n    }\n    toString() {\n      return \"action_\" + this.ruleIndex + \":\" + this.actionIndex;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], ActionTransition.prototype, \"serializationType\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ActionTransition.prototype, \"isEpsilon\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ActionTransition.prototype, \"matches\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ActionTransition.prototype, \"toString\", null);\n  ActionTransition = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], ActionTransition);\n  exports.ActionTransition = ActionTransition;\n});\n\n// node_modules/antlr4ts/atn/AtomTransition.js\nvar require_AtomTransition = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.AtomTransition = void 0;\n  var IntervalSet_1 = require_IntervalSet();\n  var Decorators_1 = require_Decorators();\n  var Transition_1 = require_Transition();\n  var AtomTransition2 = class AtomTransition extends Transition_1.Transition {\n    constructor(target, label) {\n      super(target);\n      this._label = label;\n    }\n    get serializationType() {\n      return 5;\n    }\n    get label() {\n      return IntervalSet_1.IntervalSet.of(this._label);\n    }\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n      return this._label === symbol;\n    }\n    toString() {\n      return String(this.label);\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], AtomTransition2.prototype, \"serializationType\", null);\n  __decorate([\n    Decorators_1.Override,\n    Decorators_1.NotNull\n  ], AtomTransition2.prototype, \"label\", null);\n  __decorate([\n    Decorators_1.Override\n  ], AtomTransition2.prototype, \"matches\", null);\n  __decorate([\n    Decorators_1.Override,\n    Decorators_1.NotNull\n  ], AtomTransition2.prototype, \"toString\", null);\n  AtomTransition2 = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], AtomTransition2);\n  exports.AtomTransition = AtomTransition2;\n});\n\n// node_modules/antlr4ts/atn/BlockStartState.js\nvar require_BlockStartState = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.BlockStartState = void 0;\n  var DecisionState_1 = require_DecisionState();\n  var BlockStartState = class extends DecisionState_1.DecisionState {\n  };\n  exports.BlockStartState = BlockStartState;\n});\n\n// node_modules/antlr4ts/atn/BasicBlockStartState.js\nvar require_BasicBlockStartState = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.BasicBlockStartState = void 0;\n  var ATNStateType_1 = require_ATNStateType();\n  var BlockStartState_1 = require_BlockStartState();\n  var Decorators_1 = require_Decorators();\n  var BasicBlockStartState = class extends BlockStartState_1.BlockStartState {\n    get stateType() {\n      return ATNStateType_1.ATNStateType.BLOCK_START;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], BasicBlockStartState.prototype, \"stateType\", null);\n  exports.BasicBlockStartState = BasicBlockStartState;\n});\n\n// node_modules/antlr4ts/atn/BlockEndState.js\nvar require_BlockEndState = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.BlockEndState = void 0;\n  var ATNState_1 = require_ATNState();\n  var ATNStateType_1 = require_ATNStateType();\n  var Decorators_1 = require_Decorators();\n  var BlockEndState = class extends ATNState_1.ATNState {\n    get stateType() {\n      return ATNStateType_1.ATNStateType.BLOCK_END;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], BlockEndState.prototype, \"stateType\", null);\n  exports.BlockEndState = BlockEndState;\n});\n\n// node_modules/antlr4ts/atn/EpsilonTransition.js\nvar require_EpsilonTransition = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.EpsilonTransition = void 0;\n  var Decorators_1 = require_Decorators();\n  var Transition_1 = require_Transition();\n  var EpsilonTransition = class EpsilonTransition extends Transition_1.Transition {\n    constructor(target, outermostPrecedenceReturn = -1) {\n      super(target);\n      this._outermostPrecedenceReturn = outermostPrecedenceReturn;\n    }\n    get outermostPrecedenceReturn() {\n      return this._outermostPrecedenceReturn;\n    }\n    get serializationType() {\n      return 1;\n    }\n    get isEpsilon() {\n      return true;\n    }\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n      return false;\n    }\n    toString() {\n      return \"epsilon\";\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], EpsilonTransition.prototype, \"serializationType\", null);\n  __decorate([\n    Decorators_1.Override\n  ], EpsilonTransition.prototype, \"isEpsilon\", null);\n  __decorate([\n    Decorators_1.Override\n  ], EpsilonTransition.prototype, \"matches\", null);\n  __decorate([\n    Decorators_1.Override,\n    Decorators_1.NotNull\n  ], EpsilonTransition.prototype, \"toString\", null);\n  EpsilonTransition = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], EpsilonTransition);\n  exports.EpsilonTransition = EpsilonTransition;\n});\n\n// node_modules/antlr4ts/atn/LexerChannelAction.js\nvar require_LexerChannelAction = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.LexerChannelAction = void 0;\n  var MurmurHash_1 = require_MurmurHash();\n  var Decorators_1 = require_Decorators();\n  var LexerChannelAction = class {\n    constructor(channel) {\n      this._channel = channel;\n    }\n    get channel() {\n      return this._channel;\n    }\n    get actionType() {\n      return 0;\n    }\n    get isPositionDependent() {\n      return false;\n    }\n    execute(lexer) {\n      lexer.channel = this._channel;\n    }\n    hashCode() {\n      let hash = MurmurHash_1.MurmurHash.initialize();\n      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);\n      hash = MurmurHash_1.MurmurHash.update(hash, this._channel);\n      return MurmurHash_1.MurmurHash.finish(hash, 2);\n    }\n    equals(obj) {\n      if (obj === this) {\n        return true;\n      } else if (!(obj instanceof LexerChannelAction)) {\n        return false;\n      }\n      return this._channel === obj._channel;\n    }\n    toString() {\n      return `channel(${this._channel})`;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], LexerChannelAction.prototype, \"actionType\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerChannelAction.prototype, \"isPositionDependent\", null);\n  __decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull)\n  ], LexerChannelAction.prototype, \"execute\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerChannelAction.prototype, \"hashCode\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerChannelAction.prototype, \"equals\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerChannelAction.prototype, \"toString\", null);\n  exports.LexerChannelAction = LexerChannelAction;\n});\n\n// node_modules/antlr4ts/atn/LexerCustomAction.js\nvar require_LexerCustomAction = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.LexerCustomAction = void 0;\n  var MurmurHash_1 = require_MurmurHash();\n  var Decorators_1 = require_Decorators();\n  var LexerCustomAction = class {\n    constructor(ruleIndex, actionIndex) {\n      this._ruleIndex = ruleIndex;\n      this._actionIndex = actionIndex;\n    }\n    get ruleIndex() {\n      return this._ruleIndex;\n    }\n    get actionIndex() {\n      return this._actionIndex;\n    }\n    get actionType() {\n      return 1;\n    }\n    get isPositionDependent() {\n      return true;\n    }\n    execute(lexer) {\n      lexer.action(void 0, this._ruleIndex, this._actionIndex);\n    }\n    hashCode() {\n      let hash = MurmurHash_1.MurmurHash.initialize();\n      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);\n      hash = MurmurHash_1.MurmurHash.update(hash, this._ruleIndex);\n      hash = MurmurHash_1.MurmurHash.update(hash, this._actionIndex);\n      return MurmurHash_1.MurmurHash.finish(hash, 3);\n    }\n    equals(obj) {\n      if (obj === this) {\n        return true;\n      } else if (!(obj instanceof LexerCustomAction)) {\n        return false;\n      }\n      return this._ruleIndex === obj._ruleIndex && this._actionIndex === obj._actionIndex;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], LexerCustomAction.prototype, \"actionType\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerCustomAction.prototype, \"isPositionDependent\", null);\n  __decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull)\n  ], LexerCustomAction.prototype, \"execute\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerCustomAction.prototype, \"hashCode\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerCustomAction.prototype, \"equals\", null);\n  exports.LexerCustomAction = LexerCustomAction;\n});\n\n// node_modules/antlr4ts/atn/LexerModeAction.js\nvar require_LexerModeAction = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.LexerModeAction = void 0;\n  var MurmurHash_1 = require_MurmurHash();\n  var Decorators_1 = require_Decorators();\n  var LexerModeAction = class {\n    constructor(mode) {\n      this._mode = mode;\n    }\n    get mode() {\n      return this._mode;\n    }\n    get actionType() {\n      return 2;\n    }\n    get isPositionDependent() {\n      return false;\n    }\n    execute(lexer) {\n      lexer.mode(this._mode);\n    }\n    hashCode() {\n      let hash = MurmurHash_1.MurmurHash.initialize();\n      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);\n      hash = MurmurHash_1.MurmurHash.update(hash, this._mode);\n      return MurmurHash_1.MurmurHash.finish(hash, 2);\n    }\n    equals(obj) {\n      if (obj === this) {\n        return true;\n      } else if (!(obj instanceof LexerModeAction)) {\n        return false;\n      }\n      return this._mode === obj._mode;\n    }\n    toString() {\n      return `mode(${this._mode})`;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], LexerModeAction.prototype, \"actionType\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerModeAction.prototype, \"isPositionDependent\", null);\n  __decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull)\n  ], LexerModeAction.prototype, \"execute\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerModeAction.prototype, \"hashCode\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerModeAction.prototype, \"equals\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerModeAction.prototype, \"toString\", null);\n  exports.LexerModeAction = LexerModeAction;\n});\n\n// node_modules/antlr4ts/atn/LexerMoreAction.js\nvar require_LexerMoreAction = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.LexerMoreAction = void 0;\n  var MurmurHash_1 = require_MurmurHash();\n  var Decorators_1 = require_Decorators();\n  var LexerMoreAction = class {\n    constructor() {\n    }\n    get actionType() {\n      return 3;\n    }\n    get isPositionDependent() {\n      return false;\n    }\n    execute(lexer) {\n      lexer.more();\n    }\n    hashCode() {\n      let hash = MurmurHash_1.MurmurHash.initialize();\n      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);\n      return MurmurHash_1.MurmurHash.finish(hash, 1);\n    }\n    equals(obj) {\n      return obj === this;\n    }\n    toString() {\n      return \"more\";\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], LexerMoreAction.prototype, \"actionType\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerMoreAction.prototype, \"isPositionDependent\", null);\n  __decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull)\n  ], LexerMoreAction.prototype, \"execute\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerMoreAction.prototype, \"hashCode\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerMoreAction.prototype, \"equals\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerMoreAction.prototype, \"toString\", null);\n  exports.LexerMoreAction = LexerMoreAction;\n  (function(LexerMoreAction2) {\n    LexerMoreAction2.INSTANCE = new LexerMoreAction2();\n  })(LexerMoreAction = exports.LexerMoreAction || (exports.LexerMoreAction = {}));\n});\n\n// node_modules/antlr4ts/atn/LexerPopModeAction.js\nvar require_LexerPopModeAction = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.LexerPopModeAction = void 0;\n  var MurmurHash_1 = require_MurmurHash();\n  var Decorators_1 = require_Decorators();\n  var LexerPopModeAction = class {\n    constructor() {\n    }\n    get actionType() {\n      return 4;\n    }\n    get isPositionDependent() {\n      return false;\n    }\n    execute(lexer) {\n      lexer.popMode();\n    }\n    hashCode() {\n      let hash = MurmurHash_1.MurmurHash.initialize();\n      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);\n      return MurmurHash_1.MurmurHash.finish(hash, 1);\n    }\n    equals(obj) {\n      return obj === this;\n    }\n    toString() {\n      return \"popMode\";\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], LexerPopModeAction.prototype, \"actionType\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerPopModeAction.prototype, \"isPositionDependent\", null);\n  __decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull)\n  ], LexerPopModeAction.prototype, \"execute\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerPopModeAction.prototype, \"hashCode\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerPopModeAction.prototype, \"equals\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerPopModeAction.prototype, \"toString\", null);\n  exports.LexerPopModeAction = LexerPopModeAction;\n  (function(LexerPopModeAction2) {\n    LexerPopModeAction2.INSTANCE = new LexerPopModeAction2();\n  })(LexerPopModeAction = exports.LexerPopModeAction || (exports.LexerPopModeAction = {}));\n});\n\n// node_modules/antlr4ts/atn/LexerPushModeAction.js\nvar require_LexerPushModeAction = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.LexerPushModeAction = void 0;\n  var MurmurHash_1 = require_MurmurHash();\n  var Decorators_1 = require_Decorators();\n  var LexerPushModeAction = class {\n    constructor(mode) {\n      this._mode = mode;\n    }\n    get mode() {\n      return this._mode;\n    }\n    get actionType() {\n      return 5;\n    }\n    get isPositionDependent() {\n      return false;\n    }\n    execute(lexer) {\n      lexer.pushMode(this._mode);\n    }\n    hashCode() {\n      let hash = MurmurHash_1.MurmurHash.initialize();\n      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);\n      hash = MurmurHash_1.MurmurHash.update(hash, this._mode);\n      return MurmurHash_1.MurmurHash.finish(hash, 2);\n    }\n    equals(obj) {\n      if (obj === this) {\n        return true;\n      } else if (!(obj instanceof LexerPushModeAction)) {\n        return false;\n      }\n      return this._mode === obj._mode;\n    }\n    toString() {\n      return `pushMode(${this._mode})`;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], LexerPushModeAction.prototype, \"actionType\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerPushModeAction.prototype, \"isPositionDependent\", null);\n  __decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull)\n  ], LexerPushModeAction.prototype, \"execute\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerPushModeAction.prototype, \"hashCode\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerPushModeAction.prototype, \"equals\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerPushModeAction.prototype, \"toString\", null);\n  exports.LexerPushModeAction = LexerPushModeAction;\n});\n\n// node_modules/antlr4ts/atn/LexerSkipAction.js\nvar require_LexerSkipAction = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.LexerSkipAction = void 0;\n  var MurmurHash_1 = require_MurmurHash();\n  var Decorators_1 = require_Decorators();\n  var LexerSkipAction = class {\n    constructor() {\n    }\n    get actionType() {\n      return 6;\n    }\n    get isPositionDependent() {\n      return false;\n    }\n    execute(lexer) {\n      lexer.skip();\n    }\n    hashCode() {\n      let hash = MurmurHash_1.MurmurHash.initialize();\n      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);\n      return MurmurHash_1.MurmurHash.finish(hash, 1);\n    }\n    equals(obj) {\n      return obj === this;\n    }\n    toString() {\n      return \"skip\";\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], LexerSkipAction.prototype, \"actionType\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerSkipAction.prototype, \"isPositionDependent\", null);\n  __decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull)\n  ], LexerSkipAction.prototype, \"execute\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerSkipAction.prototype, \"hashCode\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerSkipAction.prototype, \"equals\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerSkipAction.prototype, \"toString\", null);\n  exports.LexerSkipAction = LexerSkipAction;\n  (function(LexerSkipAction2) {\n    LexerSkipAction2.INSTANCE = new LexerSkipAction2();\n  })(LexerSkipAction = exports.LexerSkipAction || (exports.LexerSkipAction = {}));\n});\n\n// node_modules/antlr4ts/atn/LexerTypeAction.js\nvar require_LexerTypeAction = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.LexerTypeAction = void 0;\n  var MurmurHash_1 = require_MurmurHash();\n  var Decorators_1 = require_Decorators();\n  var LexerTypeAction = class {\n    constructor(type) {\n      this._type = type;\n    }\n    get type() {\n      return this._type;\n    }\n    get actionType() {\n      return 7;\n    }\n    get isPositionDependent() {\n      return false;\n    }\n    execute(lexer) {\n      lexer.type = this._type;\n    }\n    hashCode() {\n      let hash = MurmurHash_1.MurmurHash.initialize();\n      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);\n      hash = MurmurHash_1.MurmurHash.update(hash, this._type);\n      return MurmurHash_1.MurmurHash.finish(hash, 2);\n    }\n    equals(obj) {\n      if (obj === this) {\n        return true;\n      } else if (!(obj instanceof LexerTypeAction)) {\n        return false;\n      }\n      return this._type === obj._type;\n    }\n    toString() {\n      return `type(${this._type})`;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], LexerTypeAction.prototype, \"actionType\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerTypeAction.prototype, \"isPositionDependent\", null);\n  __decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull)\n  ], LexerTypeAction.prototype, \"execute\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerTypeAction.prototype, \"hashCode\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerTypeAction.prototype, \"equals\", null);\n  __decorate([\n    Decorators_1.Override\n  ], LexerTypeAction.prototype, \"toString\", null);\n  exports.LexerTypeAction = LexerTypeAction;\n});\n\n// node_modules/antlr4ts/atn/LoopEndState.js\nvar require_LoopEndState = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.LoopEndState = void 0;\n  var ATNState_1 = require_ATNState();\n  var ATNStateType_1 = require_ATNStateType();\n  var Decorators_1 = require_Decorators();\n  var LoopEndState = class extends ATNState_1.ATNState {\n    get stateType() {\n      return ATNStateType_1.ATNStateType.LOOP_END;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], LoopEndState.prototype, \"stateType\", null);\n  exports.LoopEndState = LoopEndState;\n});\n\n// node_modules/antlr4ts/atn/ConflictInfo.js\nvar require_ConflictInfo = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ConflictInfo = void 0;\n  var Decorators_1 = require_Decorators();\n  var Utils3 = require_Utils();\n  var ConflictInfo = class {\n    constructor(conflictedAlts, exact) {\n      this._conflictedAlts = conflictedAlts;\n      this.exact = exact;\n    }\n    get conflictedAlts() {\n      return this._conflictedAlts;\n    }\n    get isExact() {\n      return this.exact;\n    }\n    equals(obj) {\n      if (obj === this) {\n        return true;\n      } else if (!(obj instanceof ConflictInfo)) {\n        return false;\n      }\n      return this.isExact === obj.isExact && Utils3.equals(this.conflictedAlts, obj.conflictedAlts);\n    }\n    hashCode() {\n      return this.conflictedAlts.hashCode();\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], ConflictInfo.prototype, \"equals\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ConflictInfo.prototype, \"hashCode\", null);\n  exports.ConflictInfo = ConflictInfo;\n});\n\n// node_modules/antlr4ts/tree/TerminalNode.js\nvar require_TerminalNode = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.TerminalNode = void 0;\n  var Interval_1 = require_Interval();\n  var Decorators_1 = require_Decorators();\n  var Token_1 = require_Token();\n  var TerminalNode = class {\n    constructor(symbol) {\n      this._symbol = symbol;\n    }\n    getChild(i) {\n      throw new RangeError(\"Terminal Node has no children.\");\n    }\n    get symbol() {\n      return this._symbol;\n    }\n    get parent() {\n      return this._parent;\n    }\n    setParent(parent) {\n      this._parent = parent;\n    }\n    get payload() {\n      return this._symbol;\n    }\n    get sourceInterval() {\n      let tokenIndex = this._symbol.tokenIndex;\n      return new Interval_1.Interval(tokenIndex, tokenIndex);\n    }\n    get childCount() {\n      return 0;\n    }\n    accept(visitor) {\n      return visitor.visitTerminal(this);\n    }\n    get text() {\n      return this._symbol.text || \"\";\n    }\n    toStringTree(parser) {\n      return this.toString();\n    }\n    toString() {\n      if (this._symbol.type === Token_1.Token.EOF) {\n        return \"<EOF>\";\n      }\n      return this._symbol.text || \"\";\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], TerminalNode.prototype, \"getChild\", null);\n  __decorate([\n    Decorators_1.Override\n  ], TerminalNode.prototype, \"parent\", null);\n  __decorate([\n    Decorators_1.Override\n  ], TerminalNode.prototype, \"setParent\", null);\n  __decorate([\n    Decorators_1.Override\n  ], TerminalNode.prototype, \"payload\", null);\n  __decorate([\n    Decorators_1.Override\n  ], TerminalNode.prototype, \"sourceInterval\", null);\n  __decorate([\n    Decorators_1.Override\n  ], TerminalNode.prototype, \"childCount\", null);\n  __decorate([\n    Decorators_1.Override\n  ], TerminalNode.prototype, \"accept\", null);\n  __decorate([\n    Decorators_1.Override\n  ], TerminalNode.prototype, \"text\", null);\n  __decorate([\n    Decorators_1.Override\n  ], TerminalNode.prototype, \"toStringTree\", null);\n  __decorate([\n    Decorators_1.Override\n  ], TerminalNode.prototype, \"toString\", null);\n  exports.TerminalNode = TerminalNode;\n});\n\n// node_modules/antlr4ts/tree/ErrorNode.js\nvar require_ErrorNode = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ErrorNode = void 0;\n  var Decorators_1 = require_Decorators();\n  var TerminalNode_1 = require_TerminalNode();\n  var ErrorNode2 = class extends TerminalNode_1.TerminalNode {\n    constructor(token) {\n      super(token);\n    }\n    accept(visitor) {\n      return visitor.visitErrorNode(this);\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], ErrorNode2.prototype, \"accept\", null);\n  exports.ErrorNode = ErrorNode2;\n});\n\n// node_modules/antlr4ts/tree/RuleNode.js\nvar require_RuleNode = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.RuleNode = void 0;\n  var RuleNode = class {\n  };\n  exports.RuleNode = RuleNode;\n});\n\n// node_modules/antlr4ts/tree/Trees.js\nvar require_Trees = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.Trees = void 0;\n  var ATN_1 = require_ATN();\n  var CommonToken_1 = require_CommonToken();\n  var ErrorNode_1 = require_ErrorNode();\n  var Decorators_1 = require_Decorators();\n  var Parser_1 = require_Parser();\n  var ParserRuleContext_1 = require_ParserRuleContext();\n  var RuleNode_1 = require_RuleNode();\n  var TerminalNode_1 = require_TerminalNode();\n  var Token_1 = require_Token();\n  var Utils3 = require_Utils();\n  var Trees = class {\n    static toStringTree(t, arg2) {\n      let ruleNames;\n      if (arg2 instanceof Parser_1.Parser) {\n        ruleNames = arg2.ruleNames;\n      } else {\n        ruleNames = arg2;\n      }\n      let s = Utils3.escapeWhitespace(this.getNodeText(t, ruleNames), false);\n      if (t.childCount === 0) {\n        return s;\n      }\n      let buf = \"\";\n      buf += \"(\";\n      s = Utils3.escapeWhitespace(this.getNodeText(t, ruleNames), false);\n      buf += s;\n      buf += \" \";\n      for (let i = 0; i < t.childCount; i++) {\n        if (i > 0) {\n          buf += \" \";\n        }\n        buf += this.toStringTree(t.getChild(i), ruleNames);\n      }\n      buf += \")\";\n      return buf;\n    }\n    static getNodeText(t, arg2) {\n      let ruleNames;\n      if (arg2 instanceof Parser_1.Parser) {\n        ruleNames = arg2.ruleNames;\n      } else if (arg2) {\n        ruleNames = arg2;\n      } else {\n        let payload = t.payload;\n        if (typeof payload.text === \"string\") {\n          return payload.text;\n        }\n        return t.payload.toString();\n      }\n      if (t instanceof RuleNode_1.RuleNode) {\n        let ruleContext = t.ruleContext;\n        let ruleIndex = ruleContext.ruleIndex;\n        let ruleName = ruleNames[ruleIndex];\n        let altNumber = ruleContext.altNumber;\n        if (altNumber !== ATN_1.ATN.INVALID_ALT_NUMBER) {\n          return ruleName + \":\" + altNumber;\n        }\n        return ruleName;\n      } else if (t instanceof ErrorNode_1.ErrorNode) {\n        return t.toString();\n      } else if (t instanceof TerminalNode_1.TerminalNode) {\n        let symbol = t.symbol;\n        return symbol.text || \"\";\n      }\n      throw new TypeError(\"Unexpected node type\");\n    }\n    static getChildren(t) {\n      let kids = [];\n      for (let i = 0; i < t.childCount; i++) {\n        kids.push(t.getChild(i));\n      }\n      return kids;\n    }\n    static getAncestors(t) {\n      let ancestors = [];\n      let p = t.parent;\n      while (p) {\n        ancestors.unshift(p);\n        p = p.parent;\n      }\n      return ancestors;\n    }\n    static isAncestorOf(t, u) {\n      if (!t || !u || !t.parent) {\n        return false;\n      }\n      let p = u.parent;\n      while (p) {\n        if (t === p) {\n          return true;\n        }\n        p = p.parent;\n      }\n      return false;\n    }\n    static findAllTokenNodes(t, ttype) {\n      return Trees.findAllNodes(t, ttype, true);\n    }\n    static findAllRuleNodes(t, ruleIndex) {\n      return Trees.findAllNodes(t, ruleIndex, false);\n    }\n    static findAllNodes(t, index, findTokens) {\n      let nodes = [];\n      Trees._findAllNodes(t, index, findTokens, nodes);\n      return nodes;\n    }\n    static _findAllNodes(t, index, findTokens, nodes) {\n      if (findTokens && t instanceof TerminalNode_1.TerminalNode) {\n        if (t.symbol.type === index) {\n          nodes.push(t);\n        }\n      } else if (!findTokens && t instanceof ParserRuleContext_1.ParserRuleContext) {\n        if (t.ruleIndex === index) {\n          nodes.push(t);\n        }\n      }\n      for (let i = 0; i < t.childCount; i++) {\n        Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);\n      }\n    }\n    static getDescendants(t) {\n      let nodes = [];\n      function recurse(e) {\n        nodes.push(e);\n        const n = e.childCount;\n        for (let i = 0; i < n; i++) {\n          recurse(e.getChild(i));\n        }\n      }\n      recurse(t);\n      return nodes;\n    }\n    static getRootOfSubtreeEnclosingRegion(t, startTokenIndex, stopTokenIndex) {\n      let n = t.childCount;\n      for (let i = 0; i < n; i++) {\n        let child = t.getChild(i);\n        let r = Trees.getRootOfSubtreeEnclosingRegion(child, startTokenIndex, stopTokenIndex);\n        if (r) {\n          return r;\n        }\n      }\n      if (t instanceof ParserRuleContext_1.ParserRuleContext) {\n        let stopToken = t.stop;\n        if (startTokenIndex >= t.start.tokenIndex && (stopToken == null || stopTokenIndex <= stopToken.tokenIndex)) {\n          return t;\n        }\n      }\n      return void 0;\n    }\n    static stripChildrenOutOfRange(t, root, startIndex, stopIndex) {\n      if (!t) {\n        return;\n      }\n      let count = t.childCount;\n      for (let i = 0; i < count; i++) {\n        let child = t.getChild(i);\n        let range = child.sourceInterval;\n        if (child instanceof ParserRuleContext_1.ParserRuleContext && (range.b < startIndex || range.a > stopIndex)) {\n          if (Trees.isAncestorOf(child, root)) {\n            let abbrev = new CommonToken_1.CommonToken(Token_1.Token.INVALID_TYPE, \"...\");\n            t.children[i] = new TerminalNode_1.TerminalNode(abbrev);\n          }\n        }\n      }\n    }\n    static findNodeSuchThat(t, pred) {\n      if (pred(t)) {\n        return t;\n      }\n      let n = t.childCount;\n      for (let i = 0; i < n; i++) {\n        let u = Trees.findNodeSuchThat(t.getChild(i), pred);\n        if (u !== void 0) {\n          return u;\n        }\n      }\n      return void 0;\n    }\n  };\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], Trees, \"toStringTree\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n  ], Trees, \"getAncestors\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], Trees, \"getRootOfSubtreeEnclosingRegion\", null);\n  exports.Trees = Trees;\n});\n\n// node_modules/antlr4ts/RuleContext.js\nvar require_RuleContext = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.RuleContext = void 0;\n  var ATN_1 = require_ATN();\n  var Recognizer_1 = require_Recognizer();\n  var RuleNode_1 = require_RuleNode();\n  var Interval_1 = require_Interval();\n  var Decorators_1 = require_Decorators();\n  var Trees_1 = require_Trees();\n  var ParserRuleContext_1 = require_ParserRuleContext();\n  var RuleContext = class extends RuleNode_1.RuleNode {\n    constructor(parent, invokingState) {\n      super();\n      this._parent = parent;\n      this.invokingState = invokingState != null ? invokingState : -1;\n    }\n    static getChildContext(parent, invokingState) {\n      return new RuleContext(parent, invokingState);\n    }\n    depth() {\n      let n = 0;\n      let p = this;\n      while (p) {\n        p = p._parent;\n        n++;\n      }\n      return n;\n    }\n    get isEmpty() {\n      return this.invokingState === -1;\n    }\n    get sourceInterval() {\n      return Interval_1.Interval.INVALID;\n    }\n    get ruleContext() {\n      return this;\n    }\n    get parent() {\n      return this._parent;\n    }\n    setParent(parent) {\n      this._parent = parent;\n    }\n    get payload() {\n      return this;\n    }\n    get text() {\n      if (this.childCount === 0) {\n        return \"\";\n      }\n      let builder = \"\";\n      for (let i = 0; i < this.childCount; i++) {\n        builder += this.getChild(i).text;\n      }\n      return builder.toString();\n    }\n    get ruleIndex() {\n      return -1;\n    }\n    get altNumber() {\n      return ATN_1.ATN.INVALID_ALT_NUMBER;\n    }\n    set altNumber(altNumber) {\n    }\n    getChild(i) {\n      throw new RangeError(\"i must be greater than or equal to 0 and less than childCount\");\n    }\n    get childCount() {\n      return 0;\n    }\n    accept(visitor) {\n      return visitor.visitChildren(this);\n    }\n    toStringTree(recog) {\n      return Trees_1.Trees.toStringTree(this, recog);\n    }\n    toString(arg1, stop) {\n      const ruleNames = arg1 instanceof Recognizer_1.Recognizer ? arg1.ruleNames : arg1;\n      stop = stop || ParserRuleContext_1.ParserRuleContext.emptyContext();\n      let buf = \"\";\n      let p = this;\n      buf += \"[\";\n      while (p && p !== stop) {\n        if (!ruleNames) {\n          if (!p.isEmpty) {\n            buf += p.invokingState;\n          }\n        } else {\n          let ruleIndex = p.ruleIndex;\n          let ruleName = ruleIndex >= 0 && ruleIndex < ruleNames.length ? ruleNames[ruleIndex] : ruleIndex.toString();\n          buf += ruleName;\n        }\n        if (p._parent && (ruleNames || !p._parent.isEmpty)) {\n          buf += \" \";\n        }\n        p = p._parent;\n      }\n      buf += \"]\";\n      return buf.toString();\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], RuleContext.prototype, \"sourceInterval\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleContext.prototype, \"ruleContext\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleContext.prototype, \"parent\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleContext.prototype, \"setParent\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleContext.prototype, \"payload\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleContext.prototype, \"text\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleContext.prototype, \"getChild\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleContext.prototype, \"childCount\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleContext.prototype, \"accept\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleContext.prototype, \"toStringTree\", null);\n  exports.RuleContext = RuleContext;\n});\n\n// node_modules/antlr4ts/ParserRuleContext.js\nvar require_ParserRuleContext = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ParserRuleContext = void 0;\n  var ErrorNode_1 = require_ErrorNode();\n  var Interval_1 = require_Interval();\n  var Decorators_1 = require_Decorators();\n  var RuleContext_1 = require_RuleContext();\n  var TerminalNode_1 = require_TerminalNode();\n  var ParserRuleContext2 = class extends RuleContext_1.RuleContext {\n    constructor(parent, invokingStateNumber) {\n      if (invokingStateNumber == null) {\n        super();\n      } else {\n        super(parent, invokingStateNumber);\n      }\n    }\n    static emptyContext() {\n      return ParserRuleContext2.EMPTY;\n    }\n    copyFrom(ctx) {\n      this._parent = ctx._parent;\n      this.invokingState = ctx.invokingState;\n      this._start = ctx._start;\n      this._stop = ctx._stop;\n      if (ctx.children) {\n        this.children = [];\n        for (let child of ctx.children) {\n          if (child instanceof ErrorNode_1.ErrorNode) {\n            this.addChild(child);\n          }\n        }\n      }\n    }\n    enterRule(listener) {\n    }\n    exitRule(listener) {\n    }\n    addAnyChild(t) {\n      if (!this.children) {\n        this.children = [t];\n      } else {\n        this.children.push(t);\n      }\n      return t;\n    }\n    addChild(t) {\n      let result;\n      if (t instanceof TerminalNode_1.TerminalNode) {\n        t.setParent(this);\n        this.addAnyChild(t);\n        return;\n      } else if (t instanceof RuleContext_1.RuleContext) {\n        this.addAnyChild(t);\n        return;\n      } else {\n        t = new TerminalNode_1.TerminalNode(t);\n        this.addAnyChild(t);\n        t.setParent(this);\n        return t;\n      }\n    }\n    addErrorNode(node) {\n      if (node instanceof ErrorNode_1.ErrorNode) {\n        const errorNode = node;\n        errorNode.setParent(this);\n        return this.addAnyChild(errorNode);\n      } else {\n        const badToken = node;\n        let t = new ErrorNode_1.ErrorNode(badToken);\n        this.addAnyChild(t);\n        t.setParent(this);\n        return t;\n      }\n    }\n    removeLastChild() {\n      if (this.children) {\n        this.children.pop();\n      }\n    }\n    get parent() {\n      let parent = super.parent;\n      if (parent === void 0 || parent instanceof ParserRuleContext2) {\n        return parent;\n      }\n      throw new TypeError(\"Invalid parent type for ParserRuleContext\");\n    }\n    getChild(i, ctxType) {\n      if (!this.children || i < 0 || i >= this.children.length) {\n        throw new RangeError(\"index parameter must be between >= 0 and <= number of children.\");\n      }\n      if (ctxType == null) {\n        return this.children[i];\n      }\n      let result = this.tryGetChild(i, ctxType);\n      if (result === void 0) {\n        throw new Error(\"The specified node does not exist\");\n      }\n      return result;\n    }\n    tryGetChild(i, ctxType) {\n      if (!this.children || i < 0 || i >= this.children.length) {\n        return void 0;\n      }\n      let j = -1;\n      for (let o of this.children) {\n        if (o instanceof ctxType) {\n          j++;\n          if (j === i) {\n            return o;\n          }\n        }\n      }\n      return void 0;\n    }\n    getToken(ttype, i) {\n      let result = this.tryGetToken(ttype, i);\n      if (result === void 0) {\n        throw new Error(\"The specified token does not exist\");\n      }\n      return result;\n    }\n    tryGetToken(ttype, i) {\n      if (!this.children || i < 0 || i >= this.children.length) {\n        return void 0;\n      }\n      let j = -1;\n      for (let o of this.children) {\n        if (o instanceof TerminalNode_1.TerminalNode) {\n          let symbol = o.symbol;\n          if (symbol.type === ttype) {\n            j++;\n            if (j === i) {\n              return o;\n            }\n          }\n        }\n      }\n      return void 0;\n    }\n    getTokens(ttype) {\n      let tokens2 = [];\n      if (!this.children) {\n        return tokens2;\n      }\n      for (let o of this.children) {\n        if (o instanceof TerminalNode_1.TerminalNode) {\n          let symbol = o.symbol;\n          if (symbol.type === ttype) {\n            tokens2.push(o);\n          }\n        }\n      }\n      return tokens2;\n    }\n    get ruleContext() {\n      return this;\n    }\n    getRuleContext(i, ctxType) {\n      return this.getChild(i, ctxType);\n    }\n    tryGetRuleContext(i, ctxType) {\n      return this.tryGetChild(i, ctxType);\n    }\n    getRuleContexts(ctxType) {\n      let contexts = [];\n      if (!this.children) {\n        return contexts;\n      }\n      for (let o of this.children) {\n        if (o instanceof ctxType) {\n          contexts.push(o);\n        }\n      }\n      return contexts;\n    }\n    get childCount() {\n      return this.children ? this.children.length : 0;\n    }\n    get sourceInterval() {\n      if (!this._start) {\n        return Interval_1.Interval.INVALID;\n      }\n      if (!this._stop || this._stop.tokenIndex < this._start.tokenIndex) {\n        return Interval_1.Interval.of(this._start.tokenIndex, this._start.tokenIndex - 1);\n      }\n      return Interval_1.Interval.of(this._start.tokenIndex, this._stop.tokenIndex);\n    }\n    get start() {\n      return this._start;\n    }\n    get stop() {\n      return this._stop;\n    }\n    toInfoString(recognizer) {\n      let rules = recognizer.getRuleInvocationStack(this).reverse();\n      return \"ParserRuleContext\" + rules + \"{start=\" + this._start + \", stop=\" + this._stop + \"}\";\n    }\n  };\n  ParserRuleContext2.EMPTY = new ParserRuleContext2();\n  __decorate([\n    Decorators_1.Override\n  ], ParserRuleContext2.prototype, \"parent\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ParserRuleContext2.prototype, \"childCount\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ParserRuleContext2.prototype, \"sourceInterval\", null);\n  exports.ParserRuleContext = ParserRuleContext2;\n});\n\n// node_modules/antlr4ts/atn/PredictionMode.js\nvar require_PredictionMode = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.PredictionMode = void 0;\n  var Array2DHashMap_1 = require_Array2DHashMap();\n  var MurmurHash_1 = require_MurmurHash();\n  var Decorators_1 = require_Decorators();\n  var RuleStopState_1 = require_RuleStopState();\n  var PredictionMode;\n  (function(PredictionMode2) {\n    PredictionMode2[PredictionMode2[\"SLL\"] = 0] = \"SLL\";\n    PredictionMode2[PredictionMode2[\"LL\"] = 1] = \"LL\";\n    PredictionMode2[PredictionMode2[\"LL_EXACT_AMBIG_DETECTION\"] = 2] = \"LL_EXACT_AMBIG_DETECTION\";\n  })(PredictionMode = exports.PredictionMode || (exports.PredictionMode = {}));\n  (function(PredictionMode2) {\n    class AltAndContextMap extends Array2DHashMap_1.Array2DHashMap {\n      constructor() {\n        super(AltAndContextConfigEqualityComparator.INSTANCE);\n      }\n    }\n    class AltAndContextConfigEqualityComparator {\n      AltAndContextConfigEqualityComparator() {\n      }\n      hashCode(o) {\n        let hashCode = MurmurHash_1.MurmurHash.initialize(7);\n        hashCode = MurmurHash_1.MurmurHash.update(hashCode, o.state.stateNumber);\n        hashCode = MurmurHash_1.MurmurHash.update(hashCode, o.context);\n        hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 2);\n        return hashCode;\n      }\n      equals(a, b) {\n        if (a === b) {\n          return true;\n        }\n        if (a == null || b == null) {\n          return false;\n        }\n        return a.state.stateNumber === b.state.stateNumber && a.context.equals(b.context);\n      }\n    }\n    AltAndContextConfigEqualityComparator.INSTANCE = new AltAndContextConfigEqualityComparator();\n    __decorate([\n      Decorators_1.Override\n    ], AltAndContextConfigEqualityComparator.prototype, \"hashCode\", null);\n    __decorate([\n      Decorators_1.Override\n    ], AltAndContextConfigEqualityComparator.prototype, \"equals\", null);\n    function hasConfigInRuleStopState(configs) {\n      for (let c of configs) {\n        if (c.state instanceof RuleStopState_1.RuleStopState) {\n          return true;\n        }\n      }\n      return false;\n    }\n    PredictionMode2.hasConfigInRuleStopState = hasConfigInRuleStopState;\n    function allConfigsInRuleStopStates(configs) {\n      for (let config of configs) {\n        if (!(config.state instanceof RuleStopState_1.RuleStopState)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    PredictionMode2.allConfigsInRuleStopStates = allConfigsInRuleStopStates;\n  })(PredictionMode = exports.PredictionMode || (exports.PredictionMode = {}));\n});\n\n// node_modules/antlr4ts/atn/SimulatorState.js\nvar require_SimulatorState = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.SimulatorState = void 0;\n  var Decorators_1 = require_Decorators();\n  var ParserRuleContext_1 = require_ParserRuleContext();\n  var SimulatorState = class SimulatorState {\n    constructor(outerContext, s0, useContext, remainingOuterContext) {\n      this.outerContext = outerContext != null ? outerContext : ParserRuleContext_1.ParserRuleContext.emptyContext();\n      this.s0 = s0;\n      this.useContext = useContext;\n      this.remainingOuterContext = remainingOuterContext;\n    }\n  };\n  SimulatorState = __decorate([\n    __param(1, Decorators_1.NotNull)\n  ], SimulatorState);\n  exports.SimulatorState = SimulatorState;\n});\n\n// node_modules/antlr4ts/atn/ParserATNSimulator.js\nvar require_ParserATNSimulator = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ParserATNSimulator = void 0;\n  var AcceptStateInfo_1 = require_AcceptStateInfo();\n  var ActionTransition_1 = require_ActionTransition();\n  var Array2DHashSet_1 = require_Array2DHashSet();\n  var Arrays_1 = require_Arrays();\n  var ATN_1 = require_ATN();\n  var ATNConfig_1 = require_ATNConfig();\n  var ATNConfigSet_1 = require_ATNConfigSet();\n  var ATNSimulator_1 = require_ATNSimulator();\n  var ATNStateType_1 = require_ATNStateType();\n  var AtomTransition_1 = require_AtomTransition();\n  var BitSet_1 = require_BitSet();\n  var ConflictInfo_1 = require_ConflictInfo();\n  var DecisionState_1 = require_DecisionState();\n  var DFAState_1 = require_DFAState();\n  var IntegerList_1 = require_IntegerList();\n  var Interval_1 = require_Interval();\n  var IntStream_1 = require_IntStream();\n  var Decorators_1 = require_Decorators();\n  var NotSetTransition_1 = require_NotSetTransition();\n  var NoViableAltException_1 = require_NoViableAltException();\n  var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();\n  var ParserRuleContext_1 = require_ParserRuleContext();\n  var PredictionContext_1 = require_PredictionContext();\n  var PredictionContextCache_1 = require_PredictionContextCache();\n  var PredictionMode_1 = require_PredictionMode();\n  var RuleStopState_1 = require_RuleStopState();\n  var RuleTransition_1 = require_RuleTransition();\n  var SemanticContext_1 = require_SemanticContext();\n  var SetTransition_1 = require_SetTransition();\n  var SimulatorState_1 = require_SimulatorState();\n  var Token_1 = require_Token();\n  var VocabularyImpl_1 = require_VocabularyImpl();\n  var assert = __webpack_require__(/*! assert */ \"assert\");\n  var MAX_SHORT_VALUE = 65535;\n  var MIN_INTEGER_VALUE = -(1 << 31 >>> 0);\n  var ParserATNSimulator2 = class ParserATNSimulator3 extends ATNSimulator_1.ATNSimulator {\n    constructor(atn, parser) {\n      super(atn);\n      this.predictionMode = PredictionMode_1.PredictionMode.LL;\n      this.force_global_context = false;\n      this.always_try_local_context = true;\n      this.enable_global_context_dfa = false;\n      this.optimize_unique_closure = true;\n      this.optimize_ll1 = true;\n      this.optimize_tail_calls = true;\n      this.tail_call_preserves_sll = true;\n      this.treat_sllk1_conflict_as_ambiguity = false;\n      this.reportAmbiguities = false;\n      this.userWantsCtxSensitive = true;\n      this._parser = parser;\n    }\n    getPredictionMode() {\n      return this.predictionMode;\n    }\n    setPredictionMode(predictionMode) {\n      this.predictionMode = predictionMode;\n    }\n    reset() {\n    }\n    adaptivePredict(input, decision, outerContext, useContext) {\n      if (useContext === void 0) {\n        useContext = false;\n      }\n      let dfa = this.atn.decisionToDFA[decision];\n      assert(dfa != null);\n      if (this.optimize_ll1 && !dfa.isPrecedenceDfa && !dfa.isEmpty) {\n        let ll_1 = input.LA(1);\n        if (ll_1 >= 0 && ll_1 <= 65535) {\n          let key = (decision << 16 >>> 0) + ll_1;\n          let alt = this.atn.LL1Table.get(key);\n          if (alt != null) {\n            return alt;\n          }\n        }\n      }\n      this.dfa = dfa;\n      if (this.force_global_context) {\n        useContext = true;\n      } else if (!this.always_try_local_context) {\n        useContext = useContext || dfa.isContextSensitive;\n      }\n      this.userWantsCtxSensitive = useContext || this.predictionMode !== PredictionMode_1.PredictionMode.SLL && outerContext != null && !this.atn.decisionToState[decision].sll;\n      if (outerContext == null) {\n        outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();\n      }\n      let state;\n      if (!dfa.isEmpty) {\n        state = this.getStartState(dfa, input, outerContext, useContext);\n      }\n      if (state == null) {\n        if (outerContext == null) {\n          outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();\n        }\n        if (ParserATNSimulator3.debug) {\n          console.log(\"ATN decision \" + dfa.decision + \" exec LA(1)==\" + this.getLookaheadName(input) + \", outerContext=\" + outerContext.toString(this._parser));\n        }\n        state = this.computeStartState(dfa, outerContext, useContext);\n      }\n      let m = input.mark();\n      let index = input.index;\n      try {\n        let alt = this.execDFA(dfa, input, index, state);\n        if (ParserATNSimulator3.debug) {\n          console.log(\"DFA after predictATN: \" + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));\n        }\n        return alt;\n      } finally {\n        this.dfa = void 0;\n        input.seek(index);\n        input.release(m);\n      }\n    }\n    getStartState(dfa, input, outerContext, useContext) {\n      if (!useContext) {\n        if (dfa.isPrecedenceDfa) {\n          let state = dfa.getPrecedenceStartState(this._parser.precedence, false);\n          if (state == null) {\n            return void 0;\n          }\n          return new SimulatorState_1.SimulatorState(outerContext, state, false, outerContext);\n        } else {\n          if (dfa.s0 == null) {\n            return void 0;\n          }\n          return new SimulatorState_1.SimulatorState(outerContext, dfa.s0, false, outerContext);\n        }\n      }\n      if (!this.enable_global_context_dfa) {\n        return void 0;\n      }\n      let remainingContext = outerContext;\n      assert(outerContext != null);\n      let s0;\n      if (dfa.isPrecedenceDfa) {\n        s0 = dfa.getPrecedenceStartState(this._parser.precedence, true);\n      } else {\n        s0 = dfa.s0full;\n      }\n      while (remainingContext != null && s0 != null && s0.isContextSensitive) {\n        remainingContext = this.skipTailCalls(remainingContext);\n        s0 = s0.getContextTarget(this.getReturnState(remainingContext));\n        if (remainingContext.isEmpty) {\n          assert(s0 == null || !s0.isContextSensitive);\n        } else {\n          remainingContext = remainingContext.parent;\n        }\n      }\n      if (s0 == null) {\n        return void 0;\n      }\n      return new SimulatorState_1.SimulatorState(outerContext, s0, useContext, remainingContext);\n    }\n    execDFA(dfa, input, startIndex, state) {\n      let outerContext = state.outerContext;\n      if (ParserATNSimulator3.dfa_debug) {\n        console.log(\"DFA decision \" + dfa.decision + \" exec LA(1)==\" + this.getLookaheadName(input) + \", outerContext=\" + outerContext.toString(this._parser));\n      }\n      if (ParserATNSimulator3.dfa_debug) {\n        console.log(dfa.toString(this._parser.vocabulary, this._parser.ruleNames));\n      }\n      let s = state.s0;\n      let t = input.LA(1);\n      let remainingOuterContext = state.remainingOuterContext;\n      while (true) {\n        if (ParserATNSimulator3.dfa_debug) {\n          console.log(\"DFA state \" + s.stateNumber + \" LA(1)==\" + this.getLookaheadName(input));\n        }\n        if (state.useContext) {\n          while (s.isContextSymbol(t)) {\n            let next;\n            if (remainingOuterContext != null) {\n              remainingOuterContext = this.skipTailCalls(remainingOuterContext);\n              next = s.getContextTarget(this.getReturnState(remainingOuterContext));\n            }\n            if (next == null) {\n              let initialState = new SimulatorState_1.SimulatorState(state.outerContext, s, state.useContext, remainingOuterContext);\n              return this.execATN(dfa, input, startIndex, initialState);\n            }\n            assert(remainingOuterContext != null);\n            remainingOuterContext = remainingOuterContext.parent;\n            s = next;\n          }\n        }\n        if (this.isAcceptState(s, state.useContext)) {\n          if (s.predicates != null) {\n            if (ParserATNSimulator3.dfa_debug) {\n              console.log(\"accept \" + s);\n            }\n          } else {\n            if (ParserATNSimulator3.dfa_debug) {\n              console.log(\"accept; predict \" + s.prediction + \" in state \" + s.stateNumber);\n            }\n          }\n          break;\n        }\n        assert(!this.isAcceptState(s, state.useContext));\n        let target = this.getExistingTargetState(s, t);\n        if (target == null) {\n          if (ParserATNSimulator3.dfa_debug && t >= 0) {\n            console.log(\"no edge for \" + this._parser.vocabulary.getDisplayName(t));\n          }\n          let alt;\n          if (ParserATNSimulator3.dfa_debug) {\n            let interval = Interval_1.Interval.of(startIndex, this._parser.inputStream.index);\n            console.log(\"ATN exec upon \" + this._parser.inputStream.getText(interval) + \" at DFA state \" + s.stateNumber);\n          }\n          let initialState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);\n          alt = this.execATN(dfa, input, startIndex, initialState);\n          if (ParserATNSimulator3.dfa_debug) {\n            console.log(\"back from DFA update, alt=\" + alt + \", dfa=\\n\" + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));\n          }\n          if (ParserATNSimulator3.dfa_debug) {\n            console.log(\"DFA decision \" + dfa.decision + \" predicts \" + alt);\n          }\n          return alt;\n        } else if (target === ATNSimulator_1.ATNSimulator.ERROR) {\n          let errorState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);\n          return this.handleNoViableAlt(input, startIndex, errorState);\n        }\n        s = target;\n        if (!this.isAcceptState(s, state.useContext) && t !== IntStream_1.IntStream.EOF) {\n          input.consume();\n          t = input.LA(1);\n        }\n      }\n      if (!state.useContext && s.configs.conflictInfo != null) {\n        if (dfa.atnStartState instanceof DecisionState_1.DecisionState) {\n          if (!this.userWantsCtxSensitive || !s.configs.dipsIntoOuterContext && s.configs.isExactConflict || this.treat_sllk1_conflict_as_ambiguity && input.index === startIndex) {\n          } else {\n            assert(!state.useContext);\n            let conflictingAlts;\n            let predicates2 = s.predicates;\n            if (predicates2 != null) {\n              let conflictIndex = input.index;\n              if (conflictIndex !== startIndex) {\n                input.seek(startIndex);\n              }\n              conflictingAlts = this.evalSemanticContext(predicates2, outerContext, true);\n              if (conflictingAlts.cardinality() === 1) {\n                return conflictingAlts.nextSetBit(0);\n              }\n              if (conflictIndex !== startIndex) {\n                input.seek(conflictIndex);\n              }\n            }\n            if (this.reportAmbiguities) {\n              let conflictState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);\n              this.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, input.index);\n            }\n            input.seek(startIndex);\n            return this.adaptivePredict(input, dfa.decision, outerContext, true);\n          }\n        }\n      }\n      let predicates = s.predicates;\n      if (predicates != null) {\n        let stopIndex = input.index;\n        if (startIndex !== stopIndex) {\n          input.seek(startIndex);\n        }\n        let alts = this.evalSemanticContext(predicates, outerContext, this.reportAmbiguities && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION);\n        switch (alts.cardinality()) {\n          case 0:\n            throw this.noViableAlt(input, outerContext, s.configs, startIndex);\n          case 1:\n            return alts.nextSetBit(0);\n          default:\n            if (startIndex !== stopIndex) {\n              input.seek(stopIndex);\n            }\n            this.reportAmbiguity(dfa, s, startIndex, stopIndex, s.configs.isExactConflict, alts, s.configs);\n            return alts.nextSetBit(0);\n        }\n      }\n      if (ParserATNSimulator3.dfa_debug) {\n        console.log(\"DFA decision \" + dfa.decision + \" predicts \" + s.prediction);\n      }\n      return s.prediction;\n    }\n    isAcceptState(state, useContext) {\n      if (!state.isAcceptState) {\n        return false;\n      }\n      if (state.configs.conflictingAlts == null) {\n        return true;\n      }\n      if (useContext && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n        return state.configs.isExactConflict;\n      }\n      return true;\n    }\n    execATN(dfa, input, startIndex, initialState) {\n      if (ParserATNSimulator3.debug) {\n        console.log(\"execATN decision \" + dfa.decision + \" exec LA(1)==\" + this.getLookaheadName(input));\n      }\n      let outerContext = initialState.outerContext;\n      let useContext = initialState.useContext;\n      let t = input.LA(1);\n      let previous = initialState;\n      let contextCache = new PredictionContextCache_1.PredictionContextCache();\n      while (true) {\n        let nextState = this.computeReachSet(dfa, previous, t, contextCache);\n        if (nextState == null) {\n          this.setDFAEdge(previous.s0, input.LA(1), ATNSimulator_1.ATNSimulator.ERROR);\n          return this.handleNoViableAlt(input, startIndex, previous);\n        }\n        let D = nextState.s0;\n        assert(D.isAcceptState || D.prediction === ATN_1.ATN.INVALID_ALT_NUMBER);\n        assert(D.isAcceptState || D.configs.conflictInfo == null);\n        if (this.isAcceptState(D, useContext)) {\n          let conflictingAlts = D.configs.conflictingAlts;\n          let predictedAlt = conflictingAlts == null ? D.prediction : ATN_1.ATN.INVALID_ALT_NUMBER;\n          if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {\n            if (this.optimize_ll1 && input.index === startIndex && !dfa.isPrecedenceDfa && nextState.outerContext === nextState.remainingOuterContext && dfa.decision >= 0 && !D.configs.hasSemanticContext) {\n              if (t >= 0 && t <= MAX_SHORT_VALUE) {\n                let key = (dfa.decision << 16 >>> 0) + t;\n                this.atn.LL1Table.set(key, predictedAlt);\n              }\n            }\n            if (useContext && this.always_try_local_context) {\n              this.reportContextSensitivity(dfa, predictedAlt, nextState, startIndex, input.index);\n            }\n          }\n          predictedAlt = D.prediction;\n          let attemptFullContext = conflictingAlts != null && this.userWantsCtxSensitive;\n          if (attemptFullContext) {\n            attemptFullContext = !useContext && (D.configs.dipsIntoOuterContext || !D.configs.isExactConflict) && (!this.treat_sllk1_conflict_as_ambiguity || input.index !== startIndex);\n          }\n          if (D.configs.hasSemanticContext) {\n            let predPredictions = D.predicates;\n            if (predPredictions != null) {\n              let conflictIndex = input.index;\n              if (conflictIndex !== startIndex) {\n                input.seek(startIndex);\n              }\n              conflictingAlts = this.evalSemanticContext(predPredictions, outerContext, attemptFullContext || this.reportAmbiguities);\n              switch (conflictingAlts.cardinality()) {\n                case 0:\n                  throw this.noViableAlt(input, outerContext, D.configs, startIndex);\n                case 1:\n                  return conflictingAlts.nextSetBit(0);\n                default:\n                  break;\n              }\n              if (conflictIndex !== startIndex) {\n                input.seek(conflictIndex);\n              }\n            }\n          }\n          if (!attemptFullContext) {\n            if (conflictingAlts != null) {\n              if (this.reportAmbiguities && conflictingAlts.cardinality() > 1) {\n                this.reportAmbiguity(dfa, D, startIndex, input.index, D.configs.isExactConflict, conflictingAlts, D.configs);\n              }\n              predictedAlt = conflictingAlts.nextSetBit(0);\n            }\n            return predictedAlt;\n          } else {\n            assert(!useContext);\n            assert(this.isAcceptState(D, false));\n            if (ParserATNSimulator3.debug) {\n              console.log(\"RETRY with outerContext=\" + outerContext);\n            }\n            let fullContextState = this.computeStartState(dfa, outerContext, true);\n            if (this.reportAmbiguities) {\n              this.reportAttemptingFullContext(dfa, conflictingAlts, nextState, startIndex, input.index);\n            }\n            input.seek(startIndex);\n            return this.execATN(dfa, input, startIndex, fullContextState);\n          }\n        }\n        previous = nextState;\n        if (t !== IntStream_1.IntStream.EOF) {\n          input.consume();\n          t = input.LA(1);\n        }\n      }\n    }\n    handleNoViableAlt(input, startIndex, previous) {\n      if (previous.s0 != null) {\n        let alts = new BitSet_1.BitSet();\n        let maxAlt = 0;\n        for (let config of previous.s0.configs) {\n          if (config.reachesIntoOuterContext || config.state instanceof RuleStopState_1.RuleStopState) {\n            alts.set(config.alt);\n            maxAlt = Math.max(maxAlt, config.alt);\n          }\n        }\n        switch (alts.cardinality()) {\n          case 0:\n            break;\n          case 1:\n            return alts.nextSetBit(0);\n          default:\n            if (!previous.s0.configs.hasSemanticContext) {\n              return alts.nextSetBit(0);\n            }\n            let filteredConfigs = new ATNConfigSet_1.ATNConfigSet();\n            for (let config of previous.s0.configs) {\n              if (config.reachesIntoOuterContext || config.state instanceof RuleStopState_1.RuleStopState) {\n                filteredConfigs.add(config);\n              }\n            }\n            let altToPred = this.getPredsForAmbigAlts(alts, filteredConfigs, maxAlt);\n            if (altToPred != null) {\n              let predicates = this.getPredicatePredictions(alts, altToPred);\n              if (predicates != null) {\n                let stopIndex = input.index;\n                try {\n                  input.seek(startIndex);\n                  let filteredAlts = this.evalSemanticContext(predicates, previous.outerContext, false);\n                  if (!filteredAlts.isEmpty) {\n                    return filteredAlts.nextSetBit(0);\n                  }\n                } finally {\n                  input.seek(stopIndex);\n                }\n              }\n            }\n            return alts.nextSetBit(0);\n        }\n      }\n      throw this.noViableAlt(input, previous.outerContext, previous.s0.configs, startIndex);\n    }\n    computeReachSet(dfa, previous, t, contextCache) {\n      let useContext = previous.useContext;\n      let remainingGlobalContext = previous.remainingOuterContext;\n      let s = previous.s0;\n      if (useContext) {\n        while (s.isContextSymbol(t)) {\n          let next;\n          if (remainingGlobalContext != null) {\n            remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);\n            next = s.getContextTarget(this.getReturnState(remainingGlobalContext));\n          }\n          if (next == null) {\n            break;\n          }\n          assert(remainingGlobalContext != null);\n          remainingGlobalContext = remainingGlobalContext.parent;\n          s = next;\n        }\n      }\n      assert(!this.isAcceptState(s, useContext));\n      if (this.isAcceptState(s, useContext)) {\n        return new SimulatorState_1.SimulatorState(previous.outerContext, s, useContext, remainingGlobalContext);\n      }\n      let s0 = s;\n      let target = this.getExistingTargetState(s0, t);\n      if (target == null) {\n        let result = this.computeTargetState(dfa, s0, remainingGlobalContext, t, useContext, contextCache);\n        target = result[0];\n        remainingGlobalContext = result[1];\n      }\n      if (target === ATNSimulator_1.ATNSimulator.ERROR) {\n        return void 0;\n      }\n      assert(!useContext || !target.configs.dipsIntoOuterContext);\n      return new SimulatorState_1.SimulatorState(previous.outerContext, target, useContext, remainingGlobalContext);\n    }\n    getExistingTargetState(s, t) {\n      return s.getTarget(t);\n    }\n    computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {\n      let closureConfigs = s.configs.toArray();\n      let contextElements;\n      let reach = new ATNConfigSet_1.ATNConfigSet();\n      let stepIntoGlobal;\n      do {\n        let hasMoreContext = !useContext || remainingGlobalContext != null;\n        if (!hasMoreContext) {\n          reach.isOutermostConfigSet = true;\n        }\n        let reachIntermediate = new ATNConfigSet_1.ATNConfigSet();\n        let skippedStopStates;\n        for (let c of closureConfigs) {\n          if (ParserATNSimulator3.debug) {\n            console.log(\"testing \" + this.getTokenName(t) + \" at \" + c.toString());\n          }\n          if (c.state instanceof RuleStopState_1.RuleStopState) {\n            assert(c.context.isEmpty);\n            if (useContext && !c.reachesIntoOuterContext || t === IntStream_1.IntStream.EOF) {\n              if (skippedStopStates == null) {\n                skippedStopStates = [];\n              }\n              skippedStopStates.push(c);\n            }\n            continue;\n          }\n          let n = c.state.numberOfOptimizedTransitions;\n          for (let ti = 0; ti < n; ti++) {\n            let trans = c.state.getOptimizedTransition(ti);\n            let target = this.getReachableTarget(c, trans, t);\n            if (target != null) {\n              reachIntermediate.add(c.transform(target, false), contextCache);\n            }\n          }\n        }\n        if (this.optimize_unique_closure && skippedStopStates == null && t !== Token_1.Token.EOF && reachIntermediate.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {\n          reachIntermediate.isOutermostConfigSet = reach.isOutermostConfigSet;\n          reach = reachIntermediate;\n          break;\n        }\n        let collectPredicates = false;\n        let treatEofAsEpsilon = t === Token_1.Token.EOF;\n        this.closure(reachIntermediate, reach, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon);\n        stepIntoGlobal = reach.dipsIntoOuterContext;\n        if (t === IntStream_1.IntStream.EOF) {\n          reach = this.removeAllConfigsNotInRuleStopState(reach, contextCache);\n        }\n        if (skippedStopStates != null && (!useContext || !PredictionMode_1.PredictionMode.hasConfigInRuleStopState(reach))) {\n          assert(skippedStopStates.length > 0);\n          for (let c of skippedStopStates) {\n            reach.add(c, contextCache);\n          }\n        }\n        if (useContext && stepIntoGlobal) {\n          reach.clear();\n          remainingGlobalContext = remainingGlobalContext;\n          remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);\n          let nextContextElement = this.getReturnState(remainingGlobalContext);\n          if (contextElements == null) {\n            contextElements = new IntegerList_1.IntegerList();\n          }\n          if (remainingGlobalContext.isEmpty) {\n            remainingGlobalContext = void 0;\n          } else {\n            remainingGlobalContext = remainingGlobalContext.parent;\n          }\n          contextElements.add(nextContextElement);\n          if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {\n            for (let i = 0; i < closureConfigs.length; i++) {\n              closureConfigs[i] = closureConfigs[i].appendContext(nextContextElement, contextCache);\n            }\n          }\n        }\n      } while (useContext && stepIntoGlobal);\n      if (reach.isEmpty) {\n        this.setDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);\n        return [ATNSimulator_1.ATNSimulator.ERROR, remainingGlobalContext];\n      }\n      let result = this.addDFAEdge(dfa, s, t, contextElements, reach, contextCache);\n      return [result, remainingGlobalContext];\n    }\n    removeAllConfigsNotInRuleStopState(configs, contextCache) {\n      if (PredictionMode_1.PredictionMode.allConfigsInRuleStopStates(configs)) {\n        return configs;\n      }\n      let result = new ATNConfigSet_1.ATNConfigSet();\n      for (let config of configs) {\n        if (!(config.state instanceof RuleStopState_1.RuleStopState)) {\n          continue;\n        }\n        result.add(config, contextCache);\n      }\n      return result;\n    }\n    computeStartState(dfa, globalContext, useContext) {\n      let s0 = dfa.isPrecedenceDfa ? dfa.getPrecedenceStartState(this._parser.precedence, useContext) : useContext ? dfa.s0full : dfa.s0;\n      if (s0 != null) {\n        if (!useContext) {\n          return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, globalContext);\n        }\n        s0.setContextSensitive(this.atn);\n      }\n      let decision = dfa.decision;\n      let p = dfa.atnStartState;\n      let previousContext = 0;\n      let remainingGlobalContext = globalContext;\n      let initialContext = useContext ? PredictionContext_1.PredictionContext.EMPTY_FULL : PredictionContext_1.PredictionContext.EMPTY_LOCAL;\n      let contextCache = new PredictionContextCache_1.PredictionContextCache();\n      if (useContext) {\n        if (!this.enable_global_context_dfa) {\n          while (remainingGlobalContext != null) {\n            if (remainingGlobalContext.isEmpty) {\n              previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;\n              remainingGlobalContext = void 0;\n            } else {\n              previousContext = this.getReturnState(remainingGlobalContext);\n              initialContext = initialContext.appendSingleContext(previousContext, contextCache);\n              remainingGlobalContext = remainingGlobalContext.parent;\n            }\n          }\n        }\n        while (s0 != null && s0.isContextSensitive && remainingGlobalContext != null) {\n          let next;\n          remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);\n          if (remainingGlobalContext.isEmpty) {\n            next = s0.getContextTarget(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY);\n            previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;\n            remainingGlobalContext = void 0;\n          } else {\n            previousContext = this.getReturnState(remainingGlobalContext);\n            next = s0.getContextTarget(previousContext);\n            initialContext = initialContext.appendSingleContext(previousContext, contextCache);\n            remainingGlobalContext = remainingGlobalContext.parent;\n          }\n          if (next == null) {\n            break;\n          }\n          s0 = next;\n        }\n      }\n      if (s0 != null && !s0.isContextSensitive) {\n        return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);\n      }\n      let configs = new ATNConfigSet_1.ATNConfigSet();\n      while (true) {\n        let reachIntermediate = new ATNConfigSet_1.ATNConfigSet();\n        let n = p.numberOfTransitions;\n        for (let ti = 0; ti < n; ti++) {\n          let target = p.transition(ti).target;\n          reachIntermediate.add(ATNConfig_1.ATNConfig.create(target, ti + 1, initialContext));\n        }\n        let hasMoreContext = remainingGlobalContext != null;\n        if (!hasMoreContext) {\n          configs.isOutermostConfigSet = true;\n        }\n        let collectPredicates = true;\n        this.closure(reachIntermediate, configs, collectPredicates, hasMoreContext, contextCache, false);\n        let stepIntoGlobal = configs.dipsIntoOuterContext;\n        let next;\n        if (useContext && !this.enable_global_context_dfa) {\n          s0 = this.addDFAState(dfa, configs, contextCache);\n          break;\n        } else if (s0 == null) {\n          if (!dfa.isPrecedenceDfa) {\n            next = this.addDFAState(dfa, configs, contextCache);\n            if (useContext) {\n              if (!dfa.s0full) {\n                dfa.s0full = next;\n              } else {\n                next = dfa.s0full;\n              }\n            } else {\n              if (!dfa.s0) {\n                dfa.s0 = next;\n              } else {\n                next = dfa.s0;\n              }\n            }\n          } else {\n            configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);\n            next = this.addDFAState(dfa, configs, contextCache);\n            dfa.setPrecedenceStartState(this._parser.precedence, useContext, next);\n          }\n        } else {\n          if (dfa.isPrecedenceDfa) {\n            configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);\n          }\n          next = this.addDFAState(dfa, configs, contextCache);\n          s0.setContextTarget(previousContext, next);\n        }\n        s0 = next;\n        if (!useContext || !stepIntoGlobal) {\n          break;\n        }\n        next.setContextSensitive(this.atn);\n        remainingGlobalContext = remainingGlobalContext;\n        configs.clear();\n        remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);\n        let nextContextElement = this.getReturnState(remainingGlobalContext);\n        if (remainingGlobalContext.isEmpty) {\n          remainingGlobalContext = void 0;\n        } else {\n          remainingGlobalContext = remainingGlobalContext.parent;\n        }\n        if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {\n          initialContext = initialContext.appendSingleContext(nextContextElement, contextCache);\n        }\n        previousContext = nextContextElement;\n      }\n      return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);\n    }\n    applyPrecedenceFilter(configs, globalContext, contextCache) {\n      let statesFromAlt1 = new Map();\n      let configSet = new ATNConfigSet_1.ATNConfigSet();\n      for (let config of configs) {\n        if (config.alt !== 1) {\n          continue;\n        }\n        let updatedContext = config.semanticContext.evalPrecedence(this._parser, globalContext);\n        if (updatedContext == null) {\n          continue;\n        }\n        statesFromAlt1.set(config.state.stateNumber, config.context);\n        if (updatedContext !== config.semanticContext) {\n          configSet.add(config.transform(config.state, false, updatedContext), contextCache);\n        } else {\n          configSet.add(config, contextCache);\n        }\n      }\n      for (let config of configs) {\n        if (config.alt === 1) {\n          continue;\n        }\n        if (!config.isPrecedenceFilterSuppressed) {\n          let context = statesFromAlt1.get(config.state.stateNumber);\n          if (context != null && context.equals(config.context)) {\n            continue;\n          }\n        }\n        configSet.add(config, contextCache);\n      }\n      return configSet;\n    }\n    getReachableTarget(source, trans, ttype) {\n      if (trans.matches(ttype, 0, this.atn.maxTokenType)) {\n        return trans.target;\n      }\n      return void 0;\n    }\n    predicateDFAState(D, configs, nalts) {\n      let conflictingAlts = this.getConflictingAltsFromConfigSet(configs);\n      if (!conflictingAlts) {\n        throw new Error(\"This unhandled scenario is intended to be unreachable, but I'm currently not sure of why we know that's the case.\");\n      }\n      if (ParserATNSimulator3.debug) {\n        console.log(\"predicateDFAState \" + D);\n      }\n      let altToPred = this.getPredsForAmbigAlts(conflictingAlts, configs, nalts);\n      let predPredictions;\n      if (altToPred != null) {\n        predPredictions = this.getPredicatePredictions(conflictingAlts, altToPred);\n        D.predicates = predPredictions;\n      }\n      return predPredictions;\n    }\n    getPredsForAmbigAlts(ambigAlts, configs, nalts) {\n      let altToPred = new Array(nalts + 1);\n      let n = altToPred.length;\n      for (let c of configs) {\n        if (ambigAlts.get(c.alt)) {\n          altToPred[c.alt] = SemanticContext_1.SemanticContext.or(altToPred[c.alt], c.semanticContext);\n        }\n      }\n      let nPredAlts = 0;\n      for (let i = 0; i < n; i++) {\n        if (altToPred[i] == null) {\n          altToPred[i] = SemanticContext_1.SemanticContext.NONE;\n        } else if (altToPred[i] !== SemanticContext_1.SemanticContext.NONE) {\n          nPredAlts++;\n        }\n      }\n      let result = altToPred;\n      if (nPredAlts === 0) {\n        result = void 0;\n      }\n      if (ParserATNSimulator3.debug) {\n        console.log(\"getPredsForAmbigAlts result \" + (result ? Arrays_1.Arrays.toString(result) : \"undefined\"));\n      }\n      return result;\n    }\n    getPredicatePredictions(ambigAlts, altToPred) {\n      let pairs = [];\n      let containsPredicate = false;\n      for (let i = 1; i < altToPred.length; i++) {\n        let pred = altToPred[i];\n        assert(pred != null);\n        if (ambigAlts != null && ambigAlts.get(i) && pred === SemanticContext_1.SemanticContext.NONE) {\n          pairs.push(new DFAState_1.DFAState.PredPrediction(pred, i));\n        } else if (pred !== SemanticContext_1.SemanticContext.NONE) {\n          containsPredicate = true;\n          pairs.push(new DFAState_1.DFAState.PredPrediction(pred, i));\n        }\n      }\n      if (!containsPredicate) {\n        return void 0;\n      }\n      return pairs;\n    }\n    evalSemanticContext(predPredictions, outerContext, complete) {\n      let predictions = new BitSet_1.BitSet();\n      for (let pair of predPredictions) {\n        if (pair.pred === SemanticContext_1.SemanticContext.NONE) {\n          predictions.set(pair.alt);\n          if (!complete) {\n            break;\n          }\n          continue;\n        }\n        let evaluatedResult = this.evalSemanticContextImpl(pair.pred, outerContext, pair.alt);\n        if (ParserATNSimulator3.debug || ParserATNSimulator3.dfa_debug) {\n          console.log(\"eval pred \" + pair + \"=\" + evaluatedResult);\n        }\n        if (evaluatedResult) {\n          if (ParserATNSimulator3.debug || ParserATNSimulator3.dfa_debug) {\n            console.log(\"PREDICT \" + pair.alt);\n          }\n          predictions.set(pair.alt);\n          if (!complete) {\n            break;\n          }\n        }\n      }\n      return predictions;\n    }\n    evalSemanticContextImpl(pred, parserCallStack, alt) {\n      return pred.eval(this._parser, parserCallStack);\n    }\n    closure(sourceConfigs, configs, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon) {\n      if (contextCache == null) {\n        contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;\n      }\n      let currentConfigs = sourceConfigs;\n      let closureBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);\n      while (currentConfigs.size > 0) {\n        let intermediate = new ATNConfigSet_1.ATNConfigSet();\n        for (let config of currentConfigs) {\n          this.closureImpl(config, configs, intermediate, closureBusy, collectPredicates, hasMoreContext, contextCache, 0, treatEofAsEpsilon);\n        }\n        currentConfigs = intermediate;\n      }\n    }\n    closureImpl(config, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth, treatEofAsEpsilon) {\n      if (ParserATNSimulator3.debug) {\n        console.log(\"closure(\" + config.toString(this._parser, true) + \")\");\n      }\n      if (config.state instanceof RuleStopState_1.RuleStopState) {\n        if (!config.context.isEmpty) {\n          let hasEmpty = config.context.hasEmpty;\n          let nonEmptySize = config.context.size - (hasEmpty ? 1 : 0);\n          for (let i = 0; i < nonEmptySize; i++) {\n            let newContext = config.context.getParent(i);\n            let returnState = this.atn.states[config.context.getReturnState(i)];\n            let c = ATNConfig_1.ATNConfig.create(returnState, config.alt, newContext, config.semanticContext);\n            c.outerContextDepth = config.outerContextDepth;\n            c.isPrecedenceFilterSuppressed = config.isPrecedenceFilterSuppressed;\n            assert(depth > MIN_INTEGER_VALUE);\n            this.closureImpl(c, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth - 1, treatEofAsEpsilon);\n          }\n          if (!hasEmpty || !hasMoreContexts) {\n            return;\n          }\n          config = config.transform(config.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);\n        } else if (!hasMoreContexts) {\n          configs.add(config, contextCache);\n          return;\n        } else {\n          if (ParserATNSimulator3.debug) {\n            console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n          }\n          if (config.context === PredictionContext_1.PredictionContext.EMPTY_FULL) {\n            config = config.transform(config.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);\n          } else if (!config.reachesIntoOuterContext && PredictionContext_1.PredictionContext.isEmptyLocal(config.context)) {\n            configs.add(config, contextCache);\n          }\n        }\n      }\n      let p = config.state;\n      if (!p.onlyHasEpsilonTransitions) {\n        configs.add(config, contextCache);\n        if (ParserATNSimulator3.debug) {\n          console.log(\"added config \" + configs);\n        }\n      }\n      for (let i = 0; i < p.numberOfOptimizedTransitions; i++) {\n        if (i === 0 && p.stateType === ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY && p.precedenceRuleDecision && !config.context.hasEmpty) {\n          let precedenceDecision = p;\n          let suppress = true;\n          for (let j = 0; j < config.context.size; j++) {\n            if (!precedenceDecision.precedenceLoopbackStates.get(config.context.getReturnState(j))) {\n              suppress = false;\n              break;\n            }\n          }\n          if (suppress) {\n            continue;\n          }\n        }\n        let t = p.getOptimizedTransition(i);\n        let continueCollecting = !(t instanceof ActionTransition_1.ActionTransition) && collectPredicates;\n        let c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, contextCache, treatEofAsEpsilon);\n        if (c != null) {\n          if (t instanceof RuleTransition_1.RuleTransition) {\n            if (intermediate != null && !collectPredicates) {\n              intermediate.add(c, contextCache);\n              continue;\n            }\n          }\n          let newDepth = depth;\n          if (config.state instanceof RuleStopState_1.RuleStopState) {\n            if (this.dfa != null && this.dfa.isPrecedenceDfa) {\n              let outermostPrecedenceReturn = t.outermostPrecedenceReturn;\n              if (outermostPrecedenceReturn === this.dfa.atnStartState.ruleIndex) {\n                c.isPrecedenceFilterSuppressed = true;\n              }\n            }\n            c.outerContextDepth = c.outerContextDepth + 1;\n            if (!closureBusy.add(c)) {\n              continue;\n            }\n            assert(newDepth > MIN_INTEGER_VALUE);\n            newDepth--;\n            if (ParserATNSimulator3.debug) {\n              console.log(\"dips into outer ctx: \" + c);\n            }\n          } else if (t instanceof RuleTransition_1.RuleTransition) {\n            if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config.context))) {\n              assert(c.context === config.context);\n              if (newDepth === 0) {\n                newDepth--;\n                if (!this.tail_call_preserves_sll && PredictionContext_1.PredictionContext.isEmptyLocal(config.context)) {\n                  c.outerContextDepth = c.outerContextDepth + 1;\n                }\n              }\n            } else {\n              if (newDepth >= 0) {\n                newDepth++;\n              }\n            }\n          } else {\n            if (!t.isEpsilon && !closureBusy.add(c)) {\n              continue;\n            }\n          }\n          this.closureImpl(c, configs, intermediate, closureBusy, continueCollecting, hasMoreContexts, contextCache, newDepth, treatEofAsEpsilon);\n        }\n      }\n    }\n    getRuleName(index) {\n      if (this._parser != null && index >= 0) {\n        return this._parser.ruleNames[index];\n      }\n      return \"<rule \" + index + \">\";\n    }\n    getEpsilonTarget(config, t, collectPredicates, inContext, contextCache, treatEofAsEpsilon) {\n      switch (t.serializationType) {\n        case 3:\n          return this.ruleTransition(config, t, contextCache);\n        case 10:\n          return this.precedenceTransition(config, t, collectPredicates, inContext);\n        case 4:\n          return this.predTransition(config, t, collectPredicates, inContext);\n        case 6:\n          return this.actionTransition(config, t);\n        case 1:\n          return config.transform(t.target, false);\n        case 5:\n        case 2:\n        case 7:\n          if (treatEofAsEpsilon) {\n            if (t.matches(Token_1.Token.EOF, 0, 1)) {\n              return config.transform(t.target, false);\n            }\n          }\n          return void 0;\n        default:\n          return void 0;\n      }\n    }\n    actionTransition(config, t) {\n      if (ParserATNSimulator3.debug) {\n        console.log(\"ACTION edge \" + t.ruleIndex + \":\" + t.actionIndex);\n      }\n      return config.transform(t.target, false);\n    }\n    precedenceTransition(config, pt, collectPredicates, inContext) {\n      if (ParserATNSimulator3.debug) {\n        console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" + pt.precedence + \">=_p, ctx dependent=true\");\n        if (this._parser != null) {\n          console.log(\"context surrounding pred is \" + this._parser.getRuleInvocationStack());\n        }\n      }\n      let c;\n      if (collectPredicates && inContext) {\n        let newSemCtx = SemanticContext_1.SemanticContext.and(config.semanticContext, pt.predicate);\n        c = config.transform(pt.target, false, newSemCtx);\n      } else {\n        c = config.transform(pt.target, false);\n      }\n      if (ParserATNSimulator3.debug) {\n        console.log(\"config from pred transition=\" + c);\n      }\n      return c;\n    }\n    predTransition(config, pt, collectPredicates, inContext) {\n      if (ParserATNSimulator3.debug) {\n        console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" + pt.ruleIndex + \":\" + pt.predIndex + \", ctx dependent=\" + pt.isCtxDependent);\n        if (this._parser != null) {\n          console.log(\"context surrounding pred is \" + this._parser.getRuleInvocationStack());\n        }\n      }\n      let c;\n      if (collectPredicates && (!pt.isCtxDependent || pt.isCtxDependent && inContext)) {\n        let newSemCtx = SemanticContext_1.SemanticContext.and(config.semanticContext, pt.predicate);\n        c = config.transform(pt.target, false, newSemCtx);\n      } else {\n        c = config.transform(pt.target, false);\n      }\n      if (ParserATNSimulator3.debug) {\n        console.log(\"config from pred transition=\" + c);\n      }\n      return c;\n    }\n    ruleTransition(config, t, contextCache) {\n      if (ParserATNSimulator3.debug) {\n        console.log(\"CALL rule \" + this.getRuleName(t.target.ruleIndex) + \", ctx=\" + config.context);\n      }\n      let returnState = t.followState;\n      let newContext;\n      if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config.context))) {\n        newContext = config.context;\n      } else if (contextCache != null) {\n        newContext = contextCache.getChild(config.context, returnState.stateNumber);\n      } else {\n        newContext = config.context.getChild(returnState.stateNumber);\n      }\n      return config.transform(t.target, false, newContext);\n    }\n    isConflicted(configset, contextCache) {\n      if (configset.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER || configset.size <= 1) {\n        return void 0;\n      }\n      let configs = configset.toArray();\n      configs.sort(ParserATNSimulator3.STATE_ALT_SORT_COMPARATOR);\n      let exact = !configset.dipsIntoOuterContext;\n      let alts = new BitSet_1.BitSet();\n      let minAlt = configs[0].alt;\n      alts.set(minAlt);\n      let currentState = configs[0].state.nonStopStateNumber;\n      for (let config of configs) {\n        let stateNumber = config.state.nonStopStateNumber;\n        if (stateNumber !== currentState) {\n          if (config.alt !== minAlt) {\n            return void 0;\n          }\n          currentState = stateNumber;\n        }\n      }\n      let representedAlts;\n      if (exact) {\n        currentState = configs[0].state.nonStopStateNumber;\n        representedAlts = new BitSet_1.BitSet();\n        let maxAlt = minAlt;\n        for (let config of configs) {\n          if (config.state.nonStopStateNumber !== currentState) {\n            break;\n          }\n          let alt = config.alt;\n          representedAlts.set(alt);\n          maxAlt = alt;\n        }\n        currentState = configs[0].state.nonStopStateNumber;\n        let currentAlt = minAlt;\n        for (let config of configs) {\n          let stateNumber = config.state.nonStopStateNumber;\n          let alt = config.alt;\n          if (stateNumber !== currentState) {\n            if (currentAlt !== maxAlt) {\n              exact = false;\n              break;\n            }\n            currentState = stateNumber;\n            currentAlt = minAlt;\n          } else if (alt !== currentAlt) {\n            if (alt !== representedAlts.nextSetBit(currentAlt + 1)) {\n              exact = false;\n              break;\n            }\n            currentAlt = alt;\n          }\n        }\n      }\n      currentState = configs[0].state.nonStopStateNumber;\n      let firstIndexCurrentState = 0;\n      let lastIndexCurrentStateMinAlt = 0;\n      let joinedCheckContext = configs[0].context;\n      for (let i = 1; i < configs.length; i++) {\n        let config = configs[i];\n        if (config.alt !== minAlt) {\n          break;\n        }\n        if (config.state.nonStopStateNumber !== currentState) {\n          break;\n        }\n        lastIndexCurrentStateMinAlt = i;\n        joinedCheckContext = contextCache.join(joinedCheckContext, configs[i].context);\n      }\n      for (let i = lastIndexCurrentStateMinAlt + 1; i < configs.length; i++) {\n        let config = configs[i];\n        let state = config.state;\n        alts.set(config.alt);\n        if (state.nonStopStateNumber !== currentState) {\n          currentState = state.nonStopStateNumber;\n          firstIndexCurrentState = i;\n          lastIndexCurrentStateMinAlt = i;\n          joinedCheckContext = config.context;\n          for (let j = firstIndexCurrentState + 1; j < configs.length; j++) {\n            let config2 = configs[j];\n            if (config2.alt !== minAlt) {\n              break;\n            }\n            if (config2.state.nonStopStateNumber !== currentState) {\n              break;\n            }\n            lastIndexCurrentStateMinAlt = j;\n            joinedCheckContext = contextCache.join(joinedCheckContext, config2.context);\n          }\n          i = lastIndexCurrentStateMinAlt;\n          continue;\n        }\n        let joinedCheckContext2 = config.context;\n        let currentAlt = config.alt;\n        let lastIndexCurrentStateCurrentAlt = i;\n        for (let j = lastIndexCurrentStateCurrentAlt + 1; j < configs.length; j++) {\n          let config2 = configs[j];\n          if (config2.alt !== currentAlt) {\n            break;\n          }\n          if (config2.state.nonStopStateNumber !== currentState) {\n            break;\n          }\n          lastIndexCurrentStateCurrentAlt = j;\n          joinedCheckContext2 = contextCache.join(joinedCheckContext2, config2.context);\n        }\n        i = lastIndexCurrentStateCurrentAlt;\n        let check = contextCache.join(joinedCheckContext, joinedCheckContext2);\n        if (!joinedCheckContext.equals(check)) {\n          return void 0;\n        }\n        exact = exact && joinedCheckContext.equals(joinedCheckContext2);\n      }\n      return new ConflictInfo_1.ConflictInfo(alts, exact);\n    }\n    getConflictingAltsFromConfigSet(configs) {\n      let conflictingAlts = configs.conflictingAlts;\n      if (conflictingAlts == null && configs.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {\n        conflictingAlts = new BitSet_1.BitSet();\n        conflictingAlts.set(configs.uniqueAlt);\n      }\n      return conflictingAlts;\n    }\n    getTokenName(t) {\n      if (t === Token_1.Token.EOF) {\n        return \"EOF\";\n      }\n      let vocabulary = this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;\n      let displayName = vocabulary.getDisplayName(t);\n      if (displayName === String(t)) {\n        return displayName;\n      }\n      return displayName + \"<\" + t + \">\";\n    }\n    getLookaheadName(input) {\n      return this.getTokenName(input.LA(1));\n    }\n    dumpDeadEndConfigs(nvae) {\n      console.log(\"dead end configs: \");\n      let deadEndConfigs = nvae.deadEndConfigs;\n      if (!deadEndConfigs) {\n        return;\n      }\n      for (let c of deadEndConfigs) {\n        let trans = \"no edges\";\n        if (c.state.numberOfOptimizedTransitions > 0) {\n          let t = c.state.getOptimizedTransition(0);\n          if (t instanceof AtomTransition_1.AtomTransition) {\n            trans = \"Atom \" + this.getTokenName(t._label);\n          } else if (t instanceof SetTransition_1.SetTransition) {\n            let not = t instanceof NotSetTransition_1.NotSetTransition;\n            trans = (not ? \"~\" : \"\") + \"Set \" + t.set.toString();\n          }\n        }\n        console.log(c.toString(this._parser, true) + \":\" + trans);\n      }\n    }\n    noViableAlt(input, outerContext, configs, startIndex) {\n      return new NoViableAltException_1.NoViableAltException(this._parser, input, input.get(startIndex), input.LT(1), configs, outerContext);\n    }\n    getUniqueAlt(configs) {\n      let alt = ATN_1.ATN.INVALID_ALT_NUMBER;\n      for (let c of configs) {\n        if (alt === ATN_1.ATN.INVALID_ALT_NUMBER) {\n          alt = c.alt;\n        } else if (c.alt !== alt) {\n          return ATN_1.ATN.INVALID_ALT_NUMBER;\n        }\n      }\n      return alt;\n    }\n    configWithAltAtStopState(configs, alt) {\n      for (let c of configs) {\n        if (c.alt === alt) {\n          if (c.state instanceof RuleStopState_1.RuleStopState) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n    addDFAEdge(dfa, fromState, t, contextTransitions, toConfigs, contextCache) {\n      assert(contextTransitions == null || contextTransitions.isEmpty || dfa.isContextSensitive);\n      let from = fromState;\n      let to = this.addDFAState(dfa, toConfigs, contextCache);\n      if (contextTransitions != null) {\n        for (let context of contextTransitions.toArray()) {\n          if (context === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {\n            if (from.configs.isOutermostConfigSet) {\n              continue;\n            }\n          }\n          from.setContextSensitive(this.atn);\n          from.setContextSymbol(t);\n          let next = from.getContextTarget(context);\n          if (next != null) {\n            from = next;\n            continue;\n          }\n          next = this.addDFAContextState(dfa, from.configs, context, contextCache);\n          assert(context !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY || next.configs.isOutermostConfigSet);\n          from.setContextTarget(context, next);\n          from = next;\n        }\n      }\n      if (ParserATNSimulator3.debug) {\n        console.log(\"EDGE \" + from + \" -> \" + to + \" upon \" + this.getTokenName(t));\n      }\n      this.setDFAEdge(from, t, to);\n      if (ParserATNSimulator3.debug) {\n        console.log(\"DFA=\\n\" + dfa.toString(this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY, this._parser != null ? this._parser.ruleNames : void 0));\n      }\n      return to;\n    }\n    setDFAEdge(p, t, q) {\n      if (p != null) {\n        p.setTarget(t, q);\n      }\n    }\n    addDFAContextState(dfa, configs, returnContext, contextCache) {\n      if (returnContext !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {\n        let contextConfigs = new ATNConfigSet_1.ATNConfigSet();\n        for (let config of configs) {\n          contextConfigs.add(config.appendContext(returnContext, contextCache));\n        }\n        return this.addDFAState(dfa, contextConfigs, contextCache);\n      } else {\n        assert(!configs.isOutermostConfigSet, \"Shouldn't be adding a duplicate edge.\");\n        configs = configs.clone(true);\n        configs.isOutermostConfigSet = true;\n        return this.addDFAState(dfa, configs, contextCache);\n      }\n    }\n    addDFAState(dfa, configs, contextCache) {\n      let enableDfa = this.enable_global_context_dfa || !configs.isOutermostConfigSet;\n      if (enableDfa) {\n        if (!configs.isReadOnly) {\n          configs.optimizeConfigs(this);\n        }\n        let proposed = this.createDFAState(dfa, configs);\n        let existing = dfa.states.get(proposed);\n        if (existing != null) {\n          return existing;\n        }\n      }\n      if (!configs.isReadOnly) {\n        if (configs.conflictInfo == null) {\n          configs.conflictInfo = this.isConflicted(configs, contextCache);\n        }\n      }\n      let newState = this.createDFAState(dfa, configs.clone(true));\n      let decisionState = this.atn.getDecisionState(dfa.decision);\n      let predictedAlt = this.getUniqueAlt(configs);\n      if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {\n        newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(predictedAlt);\n      } else if (configs.conflictingAlts != null) {\n        let conflictingAlts = configs.conflictingAlts;\n        if (conflictingAlts) {\n          newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(conflictingAlts.nextSetBit(0));\n        }\n      }\n      if (newState.isAcceptState && configs.hasSemanticContext) {\n        this.predicateDFAState(newState, configs, decisionState.numberOfTransitions);\n      }\n      if (!enableDfa) {\n        return newState;\n      }\n      let added = dfa.addState(newState);\n      if (ParserATNSimulator3.debug && added === newState) {\n        console.log(\"adding new DFA state: \" + newState);\n      }\n      return added;\n    }\n    createDFAState(dfa, configs) {\n      return new DFAState_1.DFAState(configs);\n    }\n    reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {\n      if (ParserATNSimulator3.debug || ParserATNSimulator3.retry_debug) {\n        let interval = Interval_1.Interval.of(startIndex, stopIndex);\n        console.log(\"reportAttemptingFullContext decision=\" + dfa.decision + \":\" + conflictState.s0.configs + \", input=\" + this._parser.inputStream.getText(interval));\n      }\n      if (this._parser != null) {\n        let listener = this._parser.getErrorListenerDispatch();\n        if (listener.reportAttemptingFullContext) {\n          listener.reportAttemptingFullContext(this._parser, dfa, startIndex, stopIndex, conflictingAlts, conflictState);\n        }\n      }\n    }\n    reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {\n      if (ParserATNSimulator3.debug || ParserATNSimulator3.retry_debug) {\n        let interval = Interval_1.Interval.of(startIndex, stopIndex);\n        console.log(\"reportContextSensitivity decision=\" + dfa.decision + \":\" + acceptState.s0.configs + \", input=\" + this._parser.inputStream.getText(interval));\n      }\n      if (this._parser != null) {\n        let listener = this._parser.getErrorListenerDispatch();\n        if (listener.reportContextSensitivity) {\n          listener.reportContextSensitivity(this._parser, dfa, startIndex, stopIndex, prediction, acceptState);\n        }\n      }\n    }\n    reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {\n      if (ParserATNSimulator3.debug || ParserATNSimulator3.retry_debug) {\n        let interval = Interval_1.Interval.of(startIndex, stopIndex);\n        console.log(\"reportAmbiguity \" + ambigAlts + \":\" + configs + \", input=\" + this._parser.inputStream.getText(interval));\n      }\n      if (this._parser != null) {\n        let listener = this._parser.getErrorListenerDispatch();\n        if (listener.reportAmbiguity) {\n          listener.reportAmbiguity(this._parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);\n        }\n      }\n    }\n    getReturnState(context) {\n      if (context.isEmpty) {\n        return PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;\n      }\n      let state = this.atn.states[context.invokingState];\n      let transition = state.transition(0);\n      return transition.followState.stateNumber;\n    }\n    skipTailCalls(context) {\n      if (!this.optimize_tail_calls) {\n        return context;\n      }\n      while (!context.isEmpty) {\n        let state = this.atn.states[context.invokingState];\n        assert(state.numberOfTransitions === 1 && state.transition(0).serializationType === 3);\n        let transition = state.transition(0);\n        if (!transition.tailCall) {\n          break;\n        }\n        context = context.parent;\n      }\n      return context;\n    }\n    get parser() {\n      return this._parser;\n    }\n  };\n  ParserATNSimulator2.debug = false;\n  ParserATNSimulator2.dfa_debug = false;\n  ParserATNSimulator2.retry_debug = false;\n  ParserATNSimulator2.STATE_ALT_SORT_COMPARATOR = (o1, o2) => {\n    let diff = o1.state.nonStopStateNumber - o2.state.nonStopStateNumber;\n    if (diff !== 0) {\n      return diff;\n    }\n    diff = o1.alt - o2.alt;\n    if (diff !== 0) {\n      return diff;\n    }\n    return 0;\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], ParserATNSimulator2.prototype, \"predictionMode\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], ParserATNSimulator2.prototype, \"getPredictionMode\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"setPredictionMode\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ParserATNSimulator2.prototype, \"reset\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"adaptivePredict\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"getStartState\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(3, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"execDFA\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(3, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"execATN\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"handleNoViableAlt\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"getExistingTargetState\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"computeTargetState\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"removeAllConfigsNotInRuleStopState\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], ParserATNSimulator2.prototype, \"computeStartState\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"applyPrecedenceFilter\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"getReachableTarget\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"getPredsForAmbigAlts\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"evalSemanticContext\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"evalSemanticContextImpl\", null);\n  __decorate([\n    __param(1, Decorators_1.NotNull),\n    __param(4, Decorators_1.Nullable)\n  ], ParserATNSimulator2.prototype, \"closure\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.Nullable),\n    __param(3, Decorators_1.NotNull),\n    __param(6, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"closureImpl\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], ParserATNSimulator2.prototype, \"getRuleName\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"getEpsilonTarget\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"actionTransition\", null);\n  __decorate([\n    Decorators_1.Nullable,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"precedenceTransition\", null);\n  __decorate([\n    Decorators_1.Nullable,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"predTransition\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.Nullable)\n  ], ParserATNSimulator2.prototype, \"ruleTransition\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"isConflicted\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], ParserATNSimulator2.prototype, \"getTokenName\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"dumpDeadEndConfigs\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"noViableAlt\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"getUniqueAlt\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"configWithAltAtStopState\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(4, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"addDFAEdge\", null);\n  __decorate([\n    __param(0, Decorators_1.Nullable),\n    __param(2, Decorators_1.Nullable)\n  ], ParserATNSimulator2.prototype, \"setDFAEdge\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"addDFAContextState\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"addDFAState\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"createDFAState\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"reportAttemptingFullContext\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"reportContextSensitivity\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(5, Decorators_1.NotNull),\n    __param(6, Decorators_1.NotNull)\n  ], ParserATNSimulator2.prototype, \"reportAmbiguity\", null);\n  ParserATNSimulator2 = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], ParserATNSimulator2);\n  exports.ParserATNSimulator = ParserATNSimulator2;\n});\n\n// node_modules/antlr4ts/atn/PlusBlockStartState.js\nvar require_PlusBlockStartState = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.PlusBlockStartState = void 0;\n  var ATNStateType_1 = require_ATNStateType();\n  var BlockStartState_1 = require_BlockStartState();\n  var Decorators_1 = require_Decorators();\n  var PlusBlockStartState = class extends BlockStartState_1.BlockStartState {\n    get stateType() {\n      return ATNStateType_1.ATNStateType.PLUS_BLOCK_START;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], PlusBlockStartState.prototype, \"stateType\", null);\n  exports.PlusBlockStartState = PlusBlockStartState;\n});\n\n// node_modules/antlr4ts/atn/PlusLoopbackState.js\nvar require_PlusLoopbackState = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.PlusLoopbackState = void 0;\n  var ATNStateType_1 = require_ATNStateType();\n  var DecisionState_1 = require_DecisionState();\n  var Decorators_1 = require_Decorators();\n  var PlusLoopbackState = class extends DecisionState_1.DecisionState {\n    get stateType() {\n      return ATNStateType_1.ATNStateType.PLUS_LOOP_BACK;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], PlusLoopbackState.prototype, \"stateType\", null);\n  exports.PlusLoopbackState = PlusLoopbackState;\n});\n\n// node_modules/antlr4ts/atn/PrecedencePredicateTransition.js\nvar require_PrecedencePredicateTransition = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.PrecedencePredicateTransition = void 0;\n  var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();\n  var Decorators_1 = require_Decorators();\n  var SemanticContext_1 = require_SemanticContext();\n  var PrecedencePredicateTransition = class PrecedencePredicateTransition extends AbstractPredicateTransition_1.AbstractPredicateTransition {\n    constructor(target, precedence) {\n      super(target);\n      this.precedence = precedence;\n    }\n    get serializationType() {\n      return 10;\n    }\n    get isEpsilon() {\n      return true;\n    }\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n      return false;\n    }\n    get predicate() {\n      return new SemanticContext_1.SemanticContext.PrecedencePredicate(this.precedence);\n    }\n    toString() {\n      return this.precedence + \" >= _p\";\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], PrecedencePredicateTransition.prototype, \"serializationType\", null);\n  __decorate([\n    Decorators_1.Override\n  ], PrecedencePredicateTransition.prototype, \"isEpsilon\", null);\n  __decorate([\n    Decorators_1.Override\n  ], PrecedencePredicateTransition.prototype, \"matches\", null);\n  __decorate([\n    Decorators_1.Override\n  ], PrecedencePredicateTransition.prototype, \"toString\", null);\n  PrecedencePredicateTransition = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], PrecedencePredicateTransition);\n  exports.PrecedencePredicateTransition = PrecedencePredicateTransition;\n});\n\n// node_modules/antlr4ts/atn/RangeTransition.js\nvar require_RangeTransition = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.RangeTransition = void 0;\n  var IntervalSet_1 = require_IntervalSet();\n  var Decorators_1 = require_Decorators();\n  var Transition_1 = require_Transition();\n  var RangeTransition = class RangeTransition extends Transition_1.Transition {\n    constructor(target, from, to) {\n      super(target);\n      this.from = from;\n      this.to = to;\n    }\n    get serializationType() {\n      return 2;\n    }\n    get label() {\n      return IntervalSet_1.IntervalSet.of(this.from, this.to);\n    }\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n      return symbol >= this.from && symbol <= this.to;\n    }\n    toString() {\n      return \"'\" + String.fromCodePoint(this.from) + \"'..'\" + String.fromCodePoint(this.to) + \"'\";\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], RangeTransition.prototype, \"serializationType\", null);\n  __decorate([\n    Decorators_1.Override,\n    Decorators_1.NotNull\n  ], RangeTransition.prototype, \"label\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RangeTransition.prototype, \"matches\", null);\n  __decorate([\n    Decorators_1.Override,\n    Decorators_1.NotNull\n  ], RangeTransition.prototype, \"toString\", null);\n  RangeTransition = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], RangeTransition);\n  exports.RangeTransition = RangeTransition;\n});\n\n// node_modules/antlr4ts/atn/RuleStartState.js\nvar require_RuleStartState = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.RuleStartState = void 0;\n  var ATNState_1 = require_ATNState();\n  var ATNStateType_1 = require_ATNStateType();\n  var Decorators_1 = require_Decorators();\n  var RuleStartState = class extends ATNState_1.ATNState {\n    constructor() {\n      super(...arguments);\n      this.isPrecedenceRule = false;\n      this.leftFactored = false;\n    }\n    get stateType() {\n      return ATNStateType_1.ATNStateType.RULE_START;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], RuleStartState.prototype, \"stateType\", null);\n  exports.RuleStartState = RuleStartState;\n});\n\n// node_modules/antlr4ts/atn/StarBlockStartState.js\nvar require_StarBlockStartState = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.StarBlockStartState = void 0;\n  var ATNStateType_1 = require_ATNStateType();\n  var BlockStartState_1 = require_BlockStartState();\n  var Decorators_1 = require_Decorators();\n  var StarBlockStartState = class extends BlockStartState_1.BlockStartState {\n    get stateType() {\n      return ATNStateType_1.ATNStateType.STAR_BLOCK_START;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], StarBlockStartState.prototype, \"stateType\", null);\n  exports.StarBlockStartState = StarBlockStartState;\n});\n\n// node_modules/antlr4ts/atn/StarLoopbackState.js\nvar require_StarLoopbackState = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.StarLoopbackState = void 0;\n  var ATNState_1 = require_ATNState();\n  var ATNStateType_1 = require_ATNStateType();\n  var Decorators_1 = require_Decorators();\n  var StarLoopbackState = class extends ATNState_1.ATNState {\n    get loopEntryState() {\n      return this.transition(0).target;\n    }\n    get stateType() {\n      return ATNStateType_1.ATNStateType.STAR_LOOP_BACK;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], StarLoopbackState.prototype, \"stateType\", null);\n  exports.StarLoopbackState = StarLoopbackState;\n});\n\n// node_modules/antlr4ts/atn/TokensStartState.js\nvar require_TokensStartState = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.TokensStartState = void 0;\n  var ATNStateType_1 = require_ATNStateType();\n  var DecisionState_1 = require_DecisionState();\n  var Decorators_1 = require_Decorators();\n  var TokensStartState = class extends DecisionState_1.DecisionState {\n    get stateType() {\n      return ATNStateType_1.ATNStateType.TOKEN_START;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], TokensStartState.prototype, \"stateType\", null);\n  exports.TokensStartState = TokensStartState;\n});\n\n// node_modules/antlr4ts/misc/UUID.js\nvar require_UUID = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.UUID = void 0;\n  var MurmurHash_1 = require_MurmurHash();\n  var UUID = class {\n    constructor(mostSigBits, moreSigBits, lessSigBits, leastSigBits) {\n      this.data = new Uint32Array(4);\n      this.data[0] = mostSigBits;\n      this.data[1] = moreSigBits;\n      this.data[2] = lessSigBits;\n      this.data[3] = leastSigBits;\n    }\n    static fromString(data) {\n      if (!/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.test(data)) {\n        throw new Error(\"Incorrectly formatted UUID\");\n      }\n      let segments = data.split(\"-\");\n      let mostSigBits = parseInt(segments[0], 16);\n      let moreSigBits = (parseInt(segments[1], 16) << 16 >>> 0) + parseInt(segments[2], 16);\n      let lessSigBits = (parseInt(segments[3], 16) << 16 >>> 0) + parseInt(segments[4].substr(0, 4), 16);\n      let leastSigBits = parseInt(segments[4].substr(-8), 16);\n      return new UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);\n    }\n    hashCode() {\n      return MurmurHash_1.MurmurHash.hashCode([this.data[0], this.data[1], this.data[2], this.data[3]]);\n    }\n    equals(obj) {\n      if (obj === this) {\n        return true;\n      } else if (!(obj instanceof UUID)) {\n        return false;\n      }\n      return this.data[0] === obj.data[0] && this.data[1] === obj.data[1] && this.data[2] === obj.data[2] && this.data[3] === obj.data[3];\n    }\n    toString() {\n      return (\"00000000\" + this.data[0].toString(16)).substr(-8) + \"-\" + (\"0000\" + (this.data[1] >>> 16).toString(16)).substr(-4) + \"-\" + (\"0000\" + this.data[1].toString(16)).substr(-4) + \"-\" + (\"0000\" + (this.data[2] >>> 16).toString(16)).substr(-4) + \"-\" + (\"0000\" + this.data[2].toString(16)).substr(-4) + (\"00000000\" + this.data[3].toString(16)).substr(-8);\n    }\n  };\n  exports.UUID = UUID;\n});\n\n// node_modules/antlr4ts/atn/ATNDeserializer.js\nvar require_ATNDeserializer = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ATNDeserializer = void 0;\n  var ActionTransition_1 = require_ActionTransition();\n  var Array2DHashSet_1 = require_Array2DHashSet();\n  var ATN_1 = require_ATN();\n  var ATNDeserializationOptions_1 = require_ATNDeserializationOptions();\n  var ATNStateType_1 = require_ATNStateType();\n  var AtomTransition_1 = require_AtomTransition();\n  var BasicBlockStartState_1 = require_BasicBlockStartState();\n  var BasicState_1 = require_BasicState();\n  var BitSet_1 = require_BitSet();\n  var BlockEndState_1 = require_BlockEndState();\n  var BlockStartState_1 = require_BlockStartState();\n  var DecisionState_1 = require_DecisionState();\n  var DFA_1 = require_DFA();\n  var EpsilonTransition_1 = require_EpsilonTransition();\n  var IntervalSet_1 = require_IntervalSet();\n  var InvalidState_1 = require_InvalidState();\n  var LexerChannelAction_1 = require_LexerChannelAction();\n  var LexerCustomAction_1 = require_LexerCustomAction();\n  var LexerModeAction_1 = require_LexerModeAction();\n  var LexerMoreAction_1 = require_LexerMoreAction();\n  var LexerPopModeAction_1 = require_LexerPopModeAction();\n  var LexerPushModeAction_1 = require_LexerPushModeAction();\n  var LexerSkipAction_1 = require_LexerSkipAction();\n  var LexerTypeAction_1 = require_LexerTypeAction();\n  var LoopEndState_1 = require_LoopEndState();\n  var Decorators_1 = require_Decorators();\n  var NotSetTransition_1 = require_NotSetTransition();\n  var ParserATNSimulator_1 = require_ParserATNSimulator();\n  var PlusBlockStartState_1 = require_PlusBlockStartState();\n  var PlusLoopbackState_1 = require_PlusLoopbackState();\n  var PrecedencePredicateTransition_1 = require_PrecedencePredicateTransition();\n  var PredicateTransition_1 = require_PredicateTransition();\n  var RangeTransition_1 = require_RangeTransition();\n  var RuleStartState_1 = require_RuleStartState();\n  var RuleStopState_1 = require_RuleStopState();\n  var RuleTransition_1 = require_RuleTransition();\n  var SetTransition_1 = require_SetTransition();\n  var StarBlockStartState_1 = require_StarBlockStartState();\n  var StarLoopbackState_1 = require_StarLoopbackState();\n  var StarLoopEntryState_1 = require_StarLoopEntryState();\n  var Token_1 = require_Token();\n  var TokensStartState_1 = require_TokensStartState();\n  var UUID_1 = require_UUID();\n  var WildcardTransition_1 = require_WildcardTransition();\n  var UnicodeDeserializingMode;\n  (function(UnicodeDeserializingMode2) {\n    UnicodeDeserializingMode2[UnicodeDeserializingMode2[\"UNICODE_BMP\"] = 0] = \"UNICODE_BMP\";\n    UnicodeDeserializingMode2[UnicodeDeserializingMode2[\"UNICODE_SMP\"] = 1] = \"UNICODE_SMP\";\n  })(UnicodeDeserializingMode || (UnicodeDeserializingMode = {}));\n  var ATNDeserializer3 = class {\n    constructor(deserializationOptions) {\n      if (deserializationOptions === void 0) {\n        deserializationOptions = ATNDeserializationOptions_1.ATNDeserializationOptions.defaultOptions;\n      }\n      this.deserializationOptions = deserializationOptions;\n    }\n    static get SERIALIZED_VERSION() {\n      return 3;\n    }\n    static isFeatureSupported(feature, actualUuid) {\n      let featureIndex = ATNDeserializer3.SUPPORTED_UUIDS.findIndex((e) => e.equals(feature));\n      if (featureIndex < 0) {\n        return false;\n      }\n      return ATNDeserializer3.SUPPORTED_UUIDS.findIndex((e) => e.equals(actualUuid)) >= featureIndex;\n    }\n    static getUnicodeDeserializer(mode) {\n      if (mode === 0) {\n        return {\n          readUnicode: (data, p) => {\n            return ATNDeserializer3.toInt(data[p]);\n          },\n          size: 1\n        };\n      } else {\n        return {\n          readUnicode: (data, p) => {\n            return ATNDeserializer3.toInt32(data, p);\n          },\n          size: 2\n        };\n      }\n    }\n    deserialize(data) {\n      data = data.slice(0);\n      for (let i = 1; i < data.length; i++) {\n        data[i] = data[i] - 2 & 65535;\n      }\n      let p = 0;\n      let version = ATNDeserializer3.toInt(data[p++]);\n      if (version !== ATNDeserializer3.SERIALIZED_VERSION) {\n        let reason = `Could not deserialize ATN with version ${version} (expected ${ATNDeserializer3.SERIALIZED_VERSION}).`;\n        throw new Error(reason);\n      }\n      let uuid = ATNDeserializer3.toUUID(data, p);\n      p += 8;\n      if (ATNDeserializer3.SUPPORTED_UUIDS.findIndex((e) => e.equals(uuid)) < 0) {\n        let reason = `Could not deserialize ATN with UUID ${uuid} (expected ${ATNDeserializer3.SERIALIZED_UUID} or a legacy UUID).`;\n        throw new Error(reason);\n      }\n      let supportsLexerActions = ATNDeserializer3.isFeatureSupported(ATNDeserializer3.ADDED_LEXER_ACTIONS, uuid);\n      let grammarType = ATNDeserializer3.toInt(data[p++]);\n      let maxTokenType = ATNDeserializer3.toInt(data[p++]);\n      let atn = new ATN_1.ATN(grammarType, maxTokenType);\n      let loopBackStateNumbers = [];\n      let endStateNumbers = [];\n      let nstates = ATNDeserializer3.toInt(data[p++]);\n      for (let i = 0; i < nstates; i++) {\n        let stype = ATNDeserializer3.toInt(data[p++]);\n        if (stype === ATNStateType_1.ATNStateType.INVALID_TYPE) {\n          atn.addState(new InvalidState_1.InvalidState());\n          continue;\n        }\n        let ruleIndex = ATNDeserializer3.toInt(data[p++]);\n        if (ruleIndex === 65535) {\n          ruleIndex = -1;\n        }\n        let s = this.stateFactory(stype, ruleIndex);\n        if (stype === ATNStateType_1.ATNStateType.LOOP_END) {\n          let loopBackStateNumber = ATNDeserializer3.toInt(data[p++]);\n          loopBackStateNumbers.push([s, loopBackStateNumber]);\n        } else if (s instanceof BlockStartState_1.BlockStartState) {\n          let endStateNumber = ATNDeserializer3.toInt(data[p++]);\n          endStateNumbers.push([s, endStateNumber]);\n        }\n        atn.addState(s);\n      }\n      for (let pair of loopBackStateNumbers) {\n        pair[0].loopBackState = atn.states[pair[1]];\n      }\n      for (let pair of endStateNumbers) {\n        pair[0].endState = atn.states[pair[1]];\n      }\n      let numNonGreedyStates = ATNDeserializer3.toInt(data[p++]);\n      for (let i = 0; i < numNonGreedyStates; i++) {\n        let stateNumber = ATNDeserializer3.toInt(data[p++]);\n        atn.states[stateNumber].nonGreedy = true;\n      }\n      let numSllDecisions = ATNDeserializer3.toInt(data[p++]);\n      for (let i = 0; i < numSllDecisions; i++) {\n        let stateNumber = ATNDeserializer3.toInt(data[p++]);\n        atn.states[stateNumber].sll = true;\n      }\n      let numPrecedenceStates = ATNDeserializer3.toInt(data[p++]);\n      for (let i = 0; i < numPrecedenceStates; i++) {\n        let stateNumber = ATNDeserializer3.toInt(data[p++]);\n        atn.states[stateNumber].isPrecedenceRule = true;\n      }\n      let nrules = ATNDeserializer3.toInt(data[p++]);\n      if (atn.grammarType === 0) {\n        atn.ruleToTokenType = new Int32Array(nrules);\n      }\n      atn.ruleToStartState = new Array(nrules);\n      for (let i = 0; i < nrules; i++) {\n        let s = ATNDeserializer3.toInt(data[p++]);\n        let startState = atn.states[s];\n        startState.leftFactored = ATNDeserializer3.toInt(data[p++]) !== 0;\n        atn.ruleToStartState[i] = startState;\n        if (atn.grammarType === 0) {\n          let tokenType = ATNDeserializer3.toInt(data[p++]);\n          if (tokenType === 65535) {\n            tokenType = Token_1.Token.EOF;\n          }\n          atn.ruleToTokenType[i] = tokenType;\n          if (!ATNDeserializer3.isFeatureSupported(ATNDeserializer3.ADDED_LEXER_ACTIONS, uuid)) {\n            let actionIndexIgnored = ATNDeserializer3.toInt(data[p++]);\n            if (actionIndexIgnored === 65535) {\n              actionIndexIgnored = -1;\n            }\n          }\n        }\n      }\n      atn.ruleToStopState = new Array(nrules);\n      for (let state of atn.states) {\n        if (!(state instanceof RuleStopState_1.RuleStopState)) {\n          continue;\n        }\n        atn.ruleToStopState[state.ruleIndex] = state;\n        atn.ruleToStartState[state.ruleIndex].stopState = state;\n      }\n      let nmodes = ATNDeserializer3.toInt(data[p++]);\n      for (let i = 0; i < nmodes; i++) {\n        let s = ATNDeserializer3.toInt(data[p++]);\n        atn.modeToStartState.push(atn.states[s]);\n      }\n      atn.modeToDFA = new Array(nmodes);\n      for (let i = 0; i < nmodes; i++) {\n        atn.modeToDFA[i] = new DFA_1.DFA(atn.modeToStartState[i]);\n      }\n      let sets = [];\n      p = this.deserializeSets(data, p, sets, ATNDeserializer3.getUnicodeDeserializer(0));\n      if (ATNDeserializer3.isFeatureSupported(ATNDeserializer3.ADDED_UNICODE_SMP, uuid)) {\n        p = this.deserializeSets(data, p, sets, ATNDeserializer3.getUnicodeDeserializer(1));\n      }\n      let nedges = ATNDeserializer3.toInt(data[p++]);\n      for (let i = 0; i < nedges; i++) {\n        let src = ATNDeserializer3.toInt(data[p]);\n        let trg = ATNDeserializer3.toInt(data[p + 1]);\n        let ttype = ATNDeserializer3.toInt(data[p + 2]);\n        let arg1 = ATNDeserializer3.toInt(data[p + 3]);\n        let arg2 = ATNDeserializer3.toInt(data[p + 4]);\n        let arg3 = ATNDeserializer3.toInt(data[p + 5]);\n        let trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);\n        let srcState = atn.states[src];\n        srcState.addTransition(trans);\n        p += 6;\n      }\n      let returnTransitionsSet = new Array2DHashSet_1.Array2DHashSet({\n        hashCode: (o) => o.stopState ^ o.returnState ^ o.outermostPrecedenceReturn,\n        equals: (a, b) => {\n          return a.stopState === b.stopState && a.returnState === b.returnState && a.outermostPrecedenceReturn === b.outermostPrecedenceReturn;\n        }\n      });\n      let returnTransitions = [];\n      for (let state of atn.states) {\n        let returningToLeftFactored = state.ruleIndex >= 0 && atn.ruleToStartState[state.ruleIndex].leftFactored;\n        for (let i = 0; i < state.numberOfTransitions; i++) {\n          let t = state.transition(i);\n          if (!(t instanceof RuleTransition_1.RuleTransition)) {\n            continue;\n          }\n          let ruleTransition = t;\n          let returningFromLeftFactored = atn.ruleToStartState[ruleTransition.target.ruleIndex].leftFactored;\n          if (!returningFromLeftFactored && returningToLeftFactored) {\n            continue;\n          }\n          let outermostPrecedenceReturn = -1;\n          if (atn.ruleToStartState[ruleTransition.target.ruleIndex].isPrecedenceRule) {\n            if (ruleTransition.precedence === 0) {\n              outermostPrecedenceReturn = ruleTransition.target.ruleIndex;\n            }\n          }\n          let current = {stopState: ruleTransition.target.ruleIndex, returnState: ruleTransition.followState.stateNumber, outermostPrecedenceReturn};\n          if (returnTransitionsSet.add(current)) {\n            returnTransitions.push(current);\n          }\n        }\n      }\n      for (let returnTransition of returnTransitions) {\n        let transition = new EpsilonTransition_1.EpsilonTransition(atn.states[returnTransition.returnState], returnTransition.outermostPrecedenceReturn);\n        atn.ruleToStopState[returnTransition.stopState].addTransition(transition);\n      }\n      for (let state of atn.states) {\n        if (state instanceof BlockStartState_1.BlockStartState) {\n          if (state.endState === void 0) {\n            throw new Error(\"IllegalStateException\");\n          }\n          if (state.endState.startState !== void 0) {\n            throw new Error(\"IllegalStateException\");\n          }\n          state.endState.startState = state;\n        }\n        if (state instanceof PlusLoopbackState_1.PlusLoopbackState) {\n          let loopbackState = state;\n          for (let i = 0; i < loopbackState.numberOfTransitions; i++) {\n            let target = loopbackState.transition(i).target;\n            if (target instanceof PlusBlockStartState_1.PlusBlockStartState) {\n              target.loopBackState = loopbackState;\n            }\n          }\n        } else if (state instanceof StarLoopbackState_1.StarLoopbackState) {\n          let loopbackState = state;\n          for (let i = 0; i < loopbackState.numberOfTransitions; i++) {\n            let target = loopbackState.transition(i).target;\n            if (target instanceof StarLoopEntryState_1.StarLoopEntryState) {\n              target.loopBackState = loopbackState;\n            }\n          }\n        }\n      }\n      let ndecisions = ATNDeserializer3.toInt(data[p++]);\n      for (let i = 1; i <= ndecisions; i++) {\n        let s = ATNDeserializer3.toInt(data[p++]);\n        let decState = atn.states[s];\n        atn.decisionToState.push(decState);\n        decState.decision = i - 1;\n      }\n      if (atn.grammarType === 0) {\n        if (supportsLexerActions) {\n          atn.lexerActions = new Array(ATNDeserializer3.toInt(data[p++]));\n          for (let i = 0; i < atn.lexerActions.length; i++) {\n            let actionType = ATNDeserializer3.toInt(data[p++]);\n            let data1 = ATNDeserializer3.toInt(data[p++]);\n            if (data1 === 65535) {\n              data1 = -1;\n            }\n            let data2 = ATNDeserializer3.toInt(data[p++]);\n            if (data2 === 65535) {\n              data2 = -1;\n            }\n            let lexerAction = this.lexerActionFactory(actionType, data1, data2);\n            atn.lexerActions[i] = lexerAction;\n          }\n        } else {\n          let legacyLexerActions = [];\n          for (let state of atn.states) {\n            for (let i = 0; i < state.numberOfTransitions; i++) {\n              let transition = state.transition(i);\n              if (!(transition instanceof ActionTransition_1.ActionTransition)) {\n                continue;\n              }\n              let ruleIndex = transition.ruleIndex;\n              let actionIndex = transition.actionIndex;\n              let lexerAction = new LexerCustomAction_1.LexerCustomAction(ruleIndex, actionIndex);\n              state.setTransition(i, new ActionTransition_1.ActionTransition(transition.target, ruleIndex, legacyLexerActions.length, false));\n              legacyLexerActions.push(lexerAction);\n            }\n          }\n          atn.lexerActions = legacyLexerActions;\n        }\n      }\n      this.markPrecedenceDecisions(atn);\n      atn.decisionToDFA = new Array(ndecisions);\n      for (let i = 0; i < ndecisions; i++) {\n        atn.decisionToDFA[i] = new DFA_1.DFA(atn.decisionToState[i], i);\n      }\n      if (this.deserializationOptions.isVerifyATN) {\n        this.verifyATN(atn);\n      }\n      if (this.deserializationOptions.isGenerateRuleBypassTransitions && atn.grammarType === 1) {\n        atn.ruleToTokenType = new Int32Array(atn.ruleToStartState.length);\n        for (let i = 0; i < atn.ruleToStartState.length; i++) {\n          atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;\n        }\n        for (let i = 0; i < atn.ruleToStartState.length; i++) {\n          let bypassStart = new BasicBlockStartState_1.BasicBlockStartState();\n          bypassStart.ruleIndex = i;\n          atn.addState(bypassStart);\n          let bypassStop = new BlockEndState_1.BlockEndState();\n          bypassStop.ruleIndex = i;\n          atn.addState(bypassStop);\n          bypassStart.endState = bypassStop;\n          atn.defineDecisionState(bypassStart);\n          bypassStop.startState = bypassStart;\n          let endState;\n          let excludeTransition;\n          if (atn.ruleToStartState[i].isPrecedenceRule) {\n            endState = void 0;\n            for (let state of atn.states) {\n              if (state.ruleIndex !== i) {\n                continue;\n              }\n              if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {\n                continue;\n              }\n              let maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;\n              if (!(maybeLoopEndState instanceof LoopEndState_1.LoopEndState)) {\n                continue;\n              }\n              if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {\n                endState = state;\n                break;\n              }\n            }\n            if (!endState) {\n              throw new Error(\"Couldn't identify final state of the precedence rule prefix section.\");\n            }\n            excludeTransition = endState.loopBackState.transition(0);\n          } else {\n            endState = atn.ruleToStopState[i];\n          }\n          for (let state of atn.states) {\n            for (let i2 = 0; i2 < state.numberOfTransitions; i2++) {\n              let transition = state.transition(i2);\n              if (transition === excludeTransition) {\n                continue;\n              }\n              if (transition.target === endState) {\n                transition.target = bypassStop;\n              }\n            }\n          }\n          while (atn.ruleToStartState[i].numberOfTransitions > 0) {\n            let transition = atn.ruleToStartState[i].removeTransition(atn.ruleToStartState[i].numberOfTransitions - 1);\n            bypassStart.addTransition(transition);\n          }\n          atn.ruleToStartState[i].addTransition(new EpsilonTransition_1.EpsilonTransition(bypassStart));\n          bypassStop.addTransition(new EpsilonTransition_1.EpsilonTransition(endState));\n          let matchState = new BasicState_1.BasicState();\n          atn.addState(matchState);\n          matchState.addTransition(new AtomTransition_1.AtomTransition(bypassStop, atn.ruleToTokenType[i]));\n          bypassStart.addTransition(new EpsilonTransition_1.EpsilonTransition(matchState));\n        }\n        if (this.deserializationOptions.isVerifyATN) {\n          this.verifyATN(atn);\n        }\n      }\n      if (this.deserializationOptions.isOptimize) {\n        while (true) {\n          let optimizationCount = 0;\n          optimizationCount += ATNDeserializer3.inlineSetRules(atn);\n          optimizationCount += ATNDeserializer3.combineChainedEpsilons(atn);\n          let preserveOrder = atn.grammarType === 0;\n          optimizationCount += ATNDeserializer3.optimizeSets(atn, preserveOrder);\n          if (optimizationCount === 0) {\n            break;\n          }\n        }\n        if (this.deserializationOptions.isVerifyATN) {\n          this.verifyATN(atn);\n        }\n      }\n      ATNDeserializer3.identifyTailCalls(atn);\n      return atn;\n    }\n    deserializeSets(data, p, sets, unicodeDeserializer) {\n      let nsets = ATNDeserializer3.toInt(data[p++]);\n      for (let i = 0; i < nsets; i++) {\n        let nintervals = ATNDeserializer3.toInt(data[p]);\n        p++;\n        let set = new IntervalSet_1.IntervalSet();\n        sets.push(set);\n        let containsEof = ATNDeserializer3.toInt(data[p++]) !== 0;\n        if (containsEof) {\n          set.add(-1);\n        }\n        for (let j = 0; j < nintervals; j++) {\n          let a = unicodeDeserializer.readUnicode(data, p);\n          p += unicodeDeserializer.size;\n          let b = unicodeDeserializer.readUnicode(data, p);\n          p += unicodeDeserializer.size;\n          set.add(a, b);\n        }\n      }\n      return p;\n    }\n    markPrecedenceDecisions(atn) {\n      let rulePrecedenceDecisions = new Map();\n      for (let state of atn.states) {\n        if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {\n          continue;\n        }\n        if (atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {\n          let maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;\n          if (maybeLoopEndState instanceof LoopEndState_1.LoopEndState) {\n            if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {\n              rulePrecedenceDecisions.set(state.ruleIndex, state);\n              state.precedenceRuleDecision = true;\n              state.precedenceLoopbackStates = new BitSet_1.BitSet(atn.states.length);\n            }\n          }\n        }\n      }\n      for (let precedenceDecision of rulePrecedenceDecisions) {\n        for (let transition of atn.ruleToStopState[precedenceDecision[0]].getTransitions()) {\n          if (transition.serializationType !== 1) {\n            continue;\n          }\n          let epsilonTransition = transition;\n          if (epsilonTransition.outermostPrecedenceReturn !== -1) {\n            continue;\n          }\n          precedenceDecision[1].precedenceLoopbackStates.set(transition.target.stateNumber);\n        }\n      }\n    }\n    verifyATN(atn) {\n      for (let state of atn.states) {\n        this.checkCondition(state !== void 0, \"ATN states should not be undefined.\");\n        if (state.stateType === ATNStateType_1.ATNStateType.INVALID_TYPE) {\n          continue;\n        }\n        this.checkCondition(state.onlyHasEpsilonTransitions || state.numberOfTransitions <= 1);\n        if (state instanceof PlusBlockStartState_1.PlusBlockStartState) {\n          this.checkCondition(state.loopBackState !== void 0);\n        }\n        if (state instanceof StarLoopEntryState_1.StarLoopEntryState) {\n          let starLoopEntryState = state;\n          this.checkCondition(starLoopEntryState.loopBackState !== void 0);\n          this.checkCondition(starLoopEntryState.numberOfTransitions === 2);\n          if (starLoopEntryState.transition(0).target instanceof StarBlockStartState_1.StarBlockStartState) {\n            this.checkCondition(starLoopEntryState.transition(1).target instanceof LoopEndState_1.LoopEndState);\n            this.checkCondition(!starLoopEntryState.nonGreedy);\n          } else if (starLoopEntryState.transition(0).target instanceof LoopEndState_1.LoopEndState) {\n            this.checkCondition(starLoopEntryState.transition(1).target instanceof StarBlockStartState_1.StarBlockStartState);\n            this.checkCondition(starLoopEntryState.nonGreedy);\n          } else {\n            throw new Error(\"IllegalStateException\");\n          }\n        }\n        if (state instanceof StarLoopbackState_1.StarLoopbackState) {\n          this.checkCondition(state.numberOfTransitions === 1);\n          this.checkCondition(state.transition(0).target instanceof StarLoopEntryState_1.StarLoopEntryState);\n        }\n        if (state instanceof LoopEndState_1.LoopEndState) {\n          this.checkCondition(state.loopBackState !== void 0);\n        }\n        if (state instanceof RuleStartState_1.RuleStartState) {\n          this.checkCondition(state.stopState !== void 0);\n        }\n        if (state instanceof BlockStartState_1.BlockStartState) {\n          this.checkCondition(state.endState !== void 0);\n        }\n        if (state instanceof BlockEndState_1.BlockEndState) {\n          this.checkCondition(state.startState !== void 0);\n        }\n        if (state instanceof DecisionState_1.DecisionState) {\n          let decisionState = state;\n          this.checkCondition(decisionState.numberOfTransitions <= 1 || decisionState.decision >= 0);\n        } else {\n          this.checkCondition(state.numberOfTransitions <= 1 || state instanceof RuleStopState_1.RuleStopState);\n        }\n      }\n    }\n    checkCondition(condition, message) {\n      if (!condition) {\n        throw new Error(\"IllegalStateException: \" + message);\n      }\n    }\n    static inlineSetRules(atn) {\n      let inlinedCalls = 0;\n      let ruleToInlineTransition = new Array(atn.ruleToStartState.length);\n      for (let i = 0; i < atn.ruleToStartState.length; i++) {\n        let startState = atn.ruleToStartState[i];\n        let middleState = startState;\n        while (middleState.onlyHasEpsilonTransitions && middleState.numberOfOptimizedTransitions === 1 && middleState.getOptimizedTransition(0).serializationType === 1) {\n          middleState = middleState.getOptimizedTransition(0).target;\n        }\n        if (middleState.numberOfOptimizedTransitions !== 1) {\n          continue;\n        }\n        let matchTransition = middleState.getOptimizedTransition(0);\n        let matchTarget = matchTransition.target;\n        if (matchTransition.isEpsilon || !matchTarget.onlyHasEpsilonTransitions || matchTarget.numberOfOptimizedTransitions !== 1 || !(matchTarget.getOptimizedTransition(0).target instanceof RuleStopState_1.RuleStopState)) {\n          continue;\n        }\n        switch (matchTransition.serializationType) {\n          case 5:\n          case 2:\n          case 7:\n            ruleToInlineTransition[i] = matchTransition;\n            break;\n          case 8:\n          case 9:\n            continue;\n          default:\n            continue;\n        }\n      }\n      for (let state of atn.states) {\n        if (state.ruleIndex < 0) {\n          continue;\n        }\n        let optimizedTransitions;\n        for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {\n          let transition = state.getOptimizedTransition(i);\n          if (!(transition instanceof RuleTransition_1.RuleTransition)) {\n            if (optimizedTransitions !== void 0) {\n              optimizedTransitions.push(transition);\n            }\n            continue;\n          }\n          let ruleTransition = transition;\n          let effective = ruleToInlineTransition[ruleTransition.target.ruleIndex];\n          if (effective === void 0) {\n            if (optimizedTransitions !== void 0) {\n              optimizedTransitions.push(transition);\n            }\n            continue;\n          }\n          if (optimizedTransitions === void 0) {\n            optimizedTransitions = [];\n            for (let j = 0; j < i; j++) {\n              optimizedTransitions.push(state.getOptimizedTransition(i));\n            }\n          }\n          inlinedCalls++;\n          let target = ruleTransition.followState;\n          let intermediateState = new BasicState_1.BasicState();\n          intermediateState.setRuleIndex(target.ruleIndex);\n          atn.addState(intermediateState);\n          optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(intermediateState));\n          switch (effective.serializationType) {\n            case 5:\n              intermediateState.addTransition(new AtomTransition_1.AtomTransition(target, effective._label));\n              break;\n            case 2:\n              intermediateState.addTransition(new RangeTransition_1.RangeTransition(target, effective.from, effective.to));\n              break;\n            case 7:\n              intermediateState.addTransition(new SetTransition_1.SetTransition(target, effective.label));\n              break;\n            default:\n              throw new Error(\"UnsupportedOperationException\");\n          }\n        }\n        if (optimizedTransitions !== void 0) {\n          if (state.isOptimized) {\n            while (state.numberOfOptimizedTransitions > 0) {\n              state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);\n            }\n          }\n          for (let transition of optimizedTransitions) {\n            state.addOptimizedTransition(transition);\n          }\n        }\n      }\n      if (ParserATNSimulator_1.ParserATNSimulator.debug) {\n        console.log(\"ATN runtime optimizer removed \" + inlinedCalls + \" rule invocations by inlining sets.\");\n      }\n      return inlinedCalls;\n    }\n    static combineChainedEpsilons(atn) {\n      let removedEdges = 0;\n      for (let state of atn.states) {\n        if (!state.onlyHasEpsilonTransitions || state instanceof RuleStopState_1.RuleStopState) {\n          continue;\n        }\n        let optimizedTransitions;\n        nextTransition:\n          for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {\n            let transition = state.getOptimizedTransition(i);\n            let intermediate = transition.target;\n            if (transition.serializationType !== 1 || transition.outermostPrecedenceReturn !== -1 || intermediate.stateType !== ATNStateType_1.ATNStateType.BASIC || !intermediate.onlyHasEpsilonTransitions) {\n              if (optimizedTransitions !== void 0) {\n                optimizedTransitions.push(transition);\n              }\n              continue nextTransition;\n            }\n            for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {\n              if (intermediate.getOptimizedTransition(j).serializationType !== 1 || intermediate.getOptimizedTransition(j).outermostPrecedenceReturn !== -1) {\n                if (optimizedTransitions !== void 0) {\n                  optimizedTransitions.push(transition);\n                }\n                continue nextTransition;\n              }\n            }\n            removedEdges++;\n            if (optimizedTransitions === void 0) {\n              optimizedTransitions = [];\n              for (let j = 0; j < i; j++) {\n                optimizedTransitions.push(state.getOptimizedTransition(j));\n              }\n            }\n            for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {\n              let target = intermediate.getOptimizedTransition(j).target;\n              optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(target));\n            }\n          }\n        if (optimizedTransitions !== void 0) {\n          if (state.isOptimized) {\n            while (state.numberOfOptimizedTransitions > 0) {\n              state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);\n            }\n          }\n          for (let transition of optimizedTransitions) {\n            state.addOptimizedTransition(transition);\n          }\n        }\n      }\n      if (ParserATNSimulator_1.ParserATNSimulator.debug) {\n        console.log(\"ATN runtime optimizer removed \" + removedEdges + \" transitions by combining chained epsilon transitions.\");\n      }\n      return removedEdges;\n    }\n    static optimizeSets(atn, preserveOrder) {\n      if (preserveOrder) {\n        return 0;\n      }\n      let removedPaths = 0;\n      let decisions = atn.decisionToState;\n      for (let decision of decisions) {\n        let setTransitions = new IntervalSet_1.IntervalSet();\n        for (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {\n          let epsTransition = decision.getOptimizedTransition(i);\n          if (!(epsTransition instanceof EpsilonTransition_1.EpsilonTransition)) {\n            continue;\n          }\n          if (epsTransition.target.numberOfOptimizedTransitions !== 1) {\n            continue;\n          }\n          let transition = epsTransition.target.getOptimizedTransition(0);\n          if (!(transition.target instanceof BlockEndState_1.BlockEndState)) {\n            continue;\n          }\n          if (transition instanceof NotSetTransition_1.NotSetTransition) {\n            continue;\n          }\n          if (transition instanceof AtomTransition_1.AtomTransition || transition instanceof RangeTransition_1.RangeTransition || transition instanceof SetTransition_1.SetTransition) {\n            setTransitions.add(i);\n          }\n        }\n        if (setTransitions.size <= 1) {\n          continue;\n        }\n        let optimizedTransitions = [];\n        for (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {\n          if (!setTransitions.contains(i)) {\n            optimizedTransitions.push(decision.getOptimizedTransition(i));\n          }\n        }\n        let blockEndState = decision.getOptimizedTransition(setTransitions.minElement).target.getOptimizedTransition(0).target;\n        let matchSet = new IntervalSet_1.IntervalSet();\n        for (let interval of setTransitions.intervals) {\n          for (let j = interval.a; j <= interval.b; j++) {\n            let matchTransition = decision.getOptimizedTransition(j).target.getOptimizedTransition(0);\n            if (matchTransition instanceof NotSetTransition_1.NotSetTransition) {\n              throw new Error(\"Not yet implemented.\");\n            } else {\n              matchSet.addAll(matchTransition.label);\n            }\n          }\n        }\n        let newTransition;\n        if (matchSet.intervals.length === 1) {\n          if (matchSet.size === 1) {\n            newTransition = new AtomTransition_1.AtomTransition(blockEndState, matchSet.minElement);\n          } else {\n            let matchInterval = matchSet.intervals[0];\n            newTransition = new RangeTransition_1.RangeTransition(blockEndState, matchInterval.a, matchInterval.b);\n          }\n        } else {\n          newTransition = new SetTransition_1.SetTransition(blockEndState, matchSet);\n        }\n        let setOptimizedState = new BasicState_1.BasicState();\n        setOptimizedState.setRuleIndex(decision.ruleIndex);\n        atn.addState(setOptimizedState);\n        setOptimizedState.addTransition(newTransition);\n        optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(setOptimizedState));\n        removedPaths += decision.numberOfOptimizedTransitions - optimizedTransitions.length;\n        if (decision.isOptimized) {\n          while (decision.numberOfOptimizedTransitions > 0) {\n            decision.removeOptimizedTransition(decision.numberOfOptimizedTransitions - 1);\n          }\n        }\n        for (let transition of optimizedTransitions) {\n          decision.addOptimizedTransition(transition);\n        }\n      }\n      if (ParserATNSimulator_1.ParserATNSimulator.debug) {\n        console.log(\"ATN runtime optimizer removed \" + removedPaths + \" paths by collapsing sets.\");\n      }\n      return removedPaths;\n    }\n    static identifyTailCalls(atn) {\n      for (let state of atn.states) {\n        for (let i = 0; i < state.numberOfTransitions; i++) {\n          let transition = state.transition(i);\n          if (!(transition instanceof RuleTransition_1.RuleTransition)) {\n            continue;\n          }\n          transition.tailCall = this.testTailCall(atn, transition, false);\n          transition.optimizedTailCall = this.testTailCall(atn, transition, true);\n        }\n        if (!state.isOptimized) {\n          continue;\n        }\n        for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {\n          let transition = state.getOptimizedTransition(i);\n          if (!(transition instanceof RuleTransition_1.RuleTransition)) {\n            continue;\n          }\n          transition.tailCall = this.testTailCall(atn, transition, false);\n          transition.optimizedTailCall = this.testTailCall(atn, transition, true);\n        }\n      }\n    }\n    static testTailCall(atn, transition, optimizedPath) {\n      if (!optimizedPath && transition.tailCall) {\n        return true;\n      }\n      if (optimizedPath && transition.optimizedTailCall) {\n        return true;\n      }\n      let reachable = new BitSet_1.BitSet(atn.states.length);\n      let worklist = [];\n      worklist.push(transition.followState);\n      while (true) {\n        let state = worklist.pop();\n        if (!state) {\n          break;\n        }\n        if (reachable.get(state.stateNumber)) {\n          continue;\n        }\n        if (state instanceof RuleStopState_1.RuleStopState) {\n          continue;\n        }\n        if (!state.onlyHasEpsilonTransitions) {\n          return false;\n        }\n        let transitionCount = optimizedPath ? state.numberOfOptimizedTransitions : state.numberOfTransitions;\n        for (let i = 0; i < transitionCount; i++) {\n          let t = optimizedPath ? state.getOptimizedTransition(i) : state.transition(i);\n          if (t.serializationType !== 1) {\n            return false;\n          }\n          worklist.push(t.target);\n        }\n      }\n      return true;\n    }\n    static toInt(c) {\n      return c;\n    }\n    static toInt32(data, offset) {\n      return (data[offset] | data[offset + 1] << 16) >>> 0;\n    }\n    static toUUID(data, offset) {\n      let leastSigBits = ATNDeserializer3.toInt32(data, offset);\n      let lessSigBits = ATNDeserializer3.toInt32(data, offset + 2);\n      let moreSigBits = ATNDeserializer3.toInt32(data, offset + 4);\n      let mostSigBits = ATNDeserializer3.toInt32(data, offset + 6);\n      return new UUID_1.UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);\n    }\n    edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {\n      let target = atn.states[trg];\n      switch (type) {\n        case 1:\n          return new EpsilonTransition_1.EpsilonTransition(target);\n        case 2:\n          if (arg3 !== 0) {\n            return new RangeTransition_1.RangeTransition(target, Token_1.Token.EOF, arg2);\n          } else {\n            return new RangeTransition_1.RangeTransition(target, arg1, arg2);\n          }\n        case 3:\n          let rt = new RuleTransition_1.RuleTransition(atn.states[arg1], arg2, arg3, target);\n          return rt;\n        case 4:\n          let pt = new PredicateTransition_1.PredicateTransition(target, arg1, arg2, arg3 !== 0);\n          return pt;\n        case 10:\n          return new PrecedencePredicateTransition_1.PrecedencePredicateTransition(target, arg1);\n        case 5:\n          if (arg3 !== 0) {\n            return new AtomTransition_1.AtomTransition(target, Token_1.Token.EOF);\n          } else {\n            return new AtomTransition_1.AtomTransition(target, arg1);\n          }\n        case 6:\n          let a = new ActionTransition_1.ActionTransition(target, arg1, arg2, arg3 !== 0);\n          return a;\n        case 7:\n          return new SetTransition_1.SetTransition(target, sets[arg1]);\n        case 8:\n          return new NotSetTransition_1.NotSetTransition(target, sets[arg1]);\n        case 9:\n          return new WildcardTransition_1.WildcardTransition(target);\n      }\n      throw new Error(\"The specified transition type is not valid.\");\n    }\n    stateFactory(type, ruleIndex) {\n      let s;\n      switch (type) {\n        case ATNStateType_1.ATNStateType.INVALID_TYPE:\n          return new InvalidState_1.InvalidState();\n        case ATNStateType_1.ATNStateType.BASIC:\n          s = new BasicState_1.BasicState();\n          break;\n        case ATNStateType_1.ATNStateType.RULE_START:\n          s = new RuleStartState_1.RuleStartState();\n          break;\n        case ATNStateType_1.ATNStateType.BLOCK_START:\n          s = new BasicBlockStartState_1.BasicBlockStartState();\n          break;\n        case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:\n          s = new PlusBlockStartState_1.PlusBlockStartState();\n          break;\n        case ATNStateType_1.ATNStateType.STAR_BLOCK_START:\n          s = new StarBlockStartState_1.StarBlockStartState();\n          break;\n        case ATNStateType_1.ATNStateType.TOKEN_START:\n          s = new TokensStartState_1.TokensStartState();\n          break;\n        case ATNStateType_1.ATNStateType.RULE_STOP:\n          s = new RuleStopState_1.RuleStopState();\n          break;\n        case ATNStateType_1.ATNStateType.BLOCK_END:\n          s = new BlockEndState_1.BlockEndState();\n          break;\n        case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:\n          s = new StarLoopbackState_1.StarLoopbackState();\n          break;\n        case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:\n          s = new StarLoopEntryState_1.StarLoopEntryState();\n          break;\n        case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:\n          s = new PlusLoopbackState_1.PlusLoopbackState();\n          break;\n        case ATNStateType_1.ATNStateType.LOOP_END:\n          s = new LoopEndState_1.LoopEndState();\n          break;\n        default:\n          let message = `The specified state type ${type} is not valid.`;\n          throw new Error(message);\n      }\n      s.ruleIndex = ruleIndex;\n      return s;\n    }\n    lexerActionFactory(type, data1, data2) {\n      switch (type) {\n        case 0:\n          return new LexerChannelAction_1.LexerChannelAction(data1);\n        case 1:\n          return new LexerCustomAction_1.LexerCustomAction(data1, data2);\n        case 2:\n          return new LexerModeAction_1.LexerModeAction(data1);\n        case 3:\n          return LexerMoreAction_1.LexerMoreAction.INSTANCE;\n        case 4:\n          return LexerPopModeAction_1.LexerPopModeAction.INSTANCE;\n        case 5:\n          return new LexerPushModeAction_1.LexerPushModeAction(data1);\n        case 6:\n          return LexerSkipAction_1.LexerSkipAction.INSTANCE;\n        case 7:\n          return new LexerTypeAction_1.LexerTypeAction(data1);\n        default:\n          let message = `The specified lexer action type ${type} is not valid.`;\n          throw new Error(message);\n      }\n    }\n  };\n  ATNDeserializer3.BASE_SERIALIZED_UUID = UUID_1.UUID.fromString(\"E4178468-DF95-44D0-AD87-F22A5D5FB6D3\");\n  ATNDeserializer3.ADDED_LEXER_ACTIONS = UUID_1.UUID.fromString(\"AB35191A-1603-487E-B75A-479B831EAF6D\");\n  ATNDeserializer3.ADDED_UNICODE_SMP = UUID_1.UUID.fromString(\"C23FEA89-0605-4f51-AFB8-058BCAB8C91B\");\n  ATNDeserializer3.SUPPORTED_UUIDS = [\n    ATNDeserializer3.BASE_SERIALIZED_UUID,\n    ATNDeserializer3.ADDED_LEXER_ACTIONS,\n    ATNDeserializer3.ADDED_UNICODE_SMP\n  ];\n  ATNDeserializer3.SERIALIZED_UUID = ATNDeserializer3.ADDED_UNICODE_SMP;\n  __decorate([\n    Decorators_1.NotNull\n  ], ATNDeserializer3.prototype, \"deserializationOptions\", void 0);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], ATNDeserializer3.prototype, \"deserialize\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], ATNDeserializer3.prototype, \"markPrecedenceDecisions\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n  ], ATNDeserializer3.prototype, \"edgeFactory\", null);\n  exports.ATNDeserializer = ATNDeserializer3;\n});\n\n// node_modules/antlr4ts/atn/ParseInfo.js\nvar require_ParseInfo = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ParseInfo = void 0;\n  var Decorators_1 = require_Decorators();\n  var ParseInfo = class ParseInfo {\n    constructor(atnSimulator) {\n      this.atnSimulator = atnSimulator;\n    }\n    getDecisionInfo() {\n      return this.atnSimulator.getDecisionInfo();\n    }\n    getLLDecisions() {\n      let decisions = this.atnSimulator.getDecisionInfo();\n      let LL = [];\n      for (let i = 0; i < decisions.length; i++) {\n        let fallBack = decisions[i].LL_Fallback;\n        if (fallBack > 0) {\n          LL.push(i);\n        }\n      }\n      return LL;\n    }\n    getTotalTimeInPrediction() {\n      let decisions = this.atnSimulator.getDecisionInfo();\n      let t = 0;\n      for (let decision of decisions) {\n        t += decision.timeInPrediction;\n      }\n      return t;\n    }\n    getTotalSLLLookaheadOps() {\n      let decisions = this.atnSimulator.getDecisionInfo();\n      let k = 0;\n      for (let decision of decisions) {\n        k += decision.SLL_TotalLook;\n      }\n      return k;\n    }\n    getTotalLLLookaheadOps() {\n      let decisions = this.atnSimulator.getDecisionInfo();\n      let k = 0;\n      for (let decision of decisions) {\n        k += decision.LL_TotalLook;\n      }\n      return k;\n    }\n    getTotalSLLATNLookaheadOps() {\n      let decisions = this.atnSimulator.getDecisionInfo();\n      let k = 0;\n      for (let decision of decisions) {\n        k += decision.SLL_ATNTransitions;\n      }\n      return k;\n    }\n    getTotalLLATNLookaheadOps() {\n      let decisions = this.atnSimulator.getDecisionInfo();\n      let k = 0;\n      for (let decision of decisions) {\n        k += decision.LL_ATNTransitions;\n      }\n      return k;\n    }\n    getTotalATNLookaheadOps() {\n      let decisions = this.atnSimulator.getDecisionInfo();\n      let k = 0;\n      for (let decision of decisions) {\n        k += decision.SLL_ATNTransitions;\n        k += decision.LL_ATNTransitions;\n      }\n      return k;\n    }\n    getDFASize(decision) {\n      if (decision) {\n        let decisionToDFA = this.atnSimulator.atn.decisionToDFA[decision];\n        return decisionToDFA.states.size;\n      } else {\n        let n = 0;\n        let decisionToDFA = this.atnSimulator.atn.decisionToDFA;\n        for (let i = 0; i < decisionToDFA.length; i++) {\n          n += this.getDFASize(i);\n        }\n        return n;\n      }\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], ParseInfo.prototype, \"getDecisionInfo\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], ParseInfo.prototype, \"getLLDecisions\", null);\n  ParseInfo = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], ParseInfo);\n  exports.ParseInfo = ParseInfo;\n});\n\n// node_modules/antlr4ts/ProxyParserErrorListener.js\nvar require_ProxyParserErrorListener = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ProxyParserErrorListener = void 0;\n  var ProxyErrorListener_1 = require_ProxyErrorListener();\n  var Decorators_1 = require_Decorators();\n  var ProxyParserErrorListener = class extends ProxyErrorListener_1.ProxyErrorListener {\n    constructor(delegates) {\n      super(delegates);\n    }\n    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n      this.getDelegates().forEach((listener) => {\n        if (listener.reportAmbiguity) {\n          listener.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs);\n        }\n      });\n    }\n    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState) {\n      this.getDelegates().forEach((listener) => {\n        if (listener.reportAttemptingFullContext) {\n          listener.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState);\n        }\n      });\n    }\n    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState) {\n      this.getDelegates().forEach((listener) => {\n        if (listener.reportContextSensitivity) {\n          listener.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState);\n        }\n      });\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], ProxyParserErrorListener.prototype, \"reportAmbiguity\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ProxyParserErrorListener.prototype, \"reportAttemptingFullContext\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ProxyParserErrorListener.prototype, \"reportContextSensitivity\", null);\n  exports.ProxyParserErrorListener = ProxyParserErrorListener;\n});\n\n// node_modules/antlr4ts/misc/Character.js\nvar require_Character = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.isSupplementaryCodePoint = exports.isLowSurrogate = exports.isHighSurrogate = void 0;\n  function isHighSurrogate(ch) {\n    return ch >= 55296 && ch <= 56319;\n  }\n  exports.isHighSurrogate = isHighSurrogate;\n  function isLowSurrogate(ch) {\n    return ch >= 56320 && ch <= 57343;\n  }\n  exports.isLowSurrogate = isLowSurrogate;\n  function isSupplementaryCodePoint(ch) {\n    return ch >= 65536;\n  }\n  exports.isSupplementaryCodePoint = isSupplementaryCodePoint;\n});\n\n// node_modules/antlr4ts/CodePointBuffer.js\nvar require_CodePointBuffer = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.CodePointBuffer = void 0;\n  var assert = __webpack_require__(/*! assert */ \"assert\");\n  var Character = require_Character();\n  var CodePointBuffer = class {\n    constructor(buffer, size) {\n      this.buffer = buffer;\n      this._position = 0;\n      this._size = size;\n    }\n    static withArray(buffer) {\n      return new CodePointBuffer(buffer, buffer.length);\n    }\n    get position() {\n      return this._position;\n    }\n    set position(newPosition) {\n      if (newPosition < 0 || newPosition > this._size) {\n        throw new RangeError();\n      }\n      this._position = newPosition;\n    }\n    get remaining() {\n      return this._size - this.position;\n    }\n    get(offset) {\n      return this.buffer[offset];\n    }\n    array() {\n      return this.buffer.slice(0, this._size);\n    }\n    static builder(initialBufferSize) {\n      return new CodePointBuffer.Builder(initialBufferSize);\n    }\n  };\n  exports.CodePointBuffer = CodePointBuffer;\n  (function(CodePointBuffer2) {\n    let Type;\n    (function(Type2) {\n      Type2[Type2[\"BYTE\"] = 0] = \"BYTE\";\n      Type2[Type2[\"CHAR\"] = 1] = \"CHAR\";\n      Type2[Type2[\"INT\"] = 2] = \"INT\";\n    })(Type || (Type = {}));\n    class Builder {\n      constructor(initialBufferSize) {\n        this.type = 0;\n        this.buffer = new Uint8Array(initialBufferSize);\n        this.prevHighSurrogate = -1;\n        this.position = 0;\n      }\n      build() {\n        return new CodePointBuffer2(this.buffer, this.position);\n      }\n      static roundUpToNextPowerOfTwo(i) {\n        let nextPowerOfTwo = 32 - Math.clz32(i - 1);\n        return Math.pow(2, nextPowerOfTwo);\n      }\n      ensureRemaining(remainingNeeded) {\n        switch (this.type) {\n          case 0:\n            if (this.buffer.length - this.position < remainingNeeded) {\n              let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);\n              let newBuffer = new Uint8Array(newCapacity);\n              newBuffer.set(this.buffer.subarray(0, this.position), 0);\n              this.buffer = newBuffer;\n            }\n            break;\n          case 1:\n            if (this.buffer.length - this.position < remainingNeeded) {\n              let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);\n              let newBuffer = new Uint16Array(newCapacity);\n              newBuffer.set(this.buffer.subarray(0, this.position), 0);\n              this.buffer = newBuffer;\n            }\n            break;\n          case 2:\n            if (this.buffer.length - this.position < remainingNeeded) {\n              let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);\n              let newBuffer = new Int32Array(newCapacity);\n              newBuffer.set(this.buffer.subarray(0, this.position), 0);\n              this.buffer = newBuffer;\n            }\n            break;\n        }\n      }\n      append(utf16In) {\n        this.ensureRemaining(utf16In.length);\n        this.appendArray(utf16In);\n      }\n      appendArray(utf16In) {\n        switch (this.type) {\n          case 0:\n            this.appendArrayByte(utf16In);\n            break;\n          case 1:\n            this.appendArrayChar(utf16In);\n            break;\n          case 2:\n            this.appendArrayInt(utf16In);\n            break;\n        }\n      }\n      appendArrayByte(utf16In) {\n        assert(this.prevHighSurrogate === -1);\n        let input = utf16In;\n        let inOffset = 0;\n        let inLimit = utf16In.length;\n        let outByte = this.buffer;\n        let outOffset = this.position;\n        while (inOffset < inLimit) {\n          let c = input[inOffset];\n          if (c <= 255) {\n            outByte[outOffset] = c;\n          } else {\n            utf16In = utf16In.subarray(inOffset, inLimit);\n            this.position = outOffset;\n            if (!Character.isHighSurrogate(c)) {\n              this.byteToCharBuffer(utf16In.length);\n              this.appendArrayChar(utf16In);\n              return;\n            } else {\n              this.byteToIntBuffer(utf16In.length);\n              this.appendArrayInt(utf16In);\n              return;\n            }\n          }\n          inOffset++;\n          outOffset++;\n        }\n        this.position = outOffset;\n      }\n      appendArrayChar(utf16In) {\n        assert(this.prevHighSurrogate === -1);\n        let input = utf16In;\n        let inOffset = 0;\n        let inLimit = utf16In.length;\n        let outChar = this.buffer;\n        let outOffset = this.position;\n        while (inOffset < inLimit) {\n          let c = input[inOffset];\n          if (!Character.isHighSurrogate(c)) {\n            outChar[outOffset] = c;\n          } else {\n            utf16In = utf16In.subarray(inOffset, inLimit);\n            this.position = outOffset;\n            this.charToIntBuffer(utf16In.length);\n            this.appendArrayInt(utf16In);\n            return;\n          }\n          inOffset++;\n          outOffset++;\n        }\n        this.position = outOffset;\n      }\n      appendArrayInt(utf16In) {\n        let input = utf16In;\n        let inOffset = 0;\n        let inLimit = utf16In.length;\n        let outInt = this.buffer;\n        let outOffset = this.position;\n        while (inOffset < inLimit) {\n          let c = input[inOffset];\n          inOffset++;\n          if (this.prevHighSurrogate !== -1) {\n            if (Character.isLowSurrogate(c)) {\n              outInt[outOffset] = String.fromCharCode(this.prevHighSurrogate, c).codePointAt(0);\n              outOffset++;\n              this.prevHighSurrogate = -1;\n            } else {\n              outInt[outOffset] = this.prevHighSurrogate;\n              outOffset++;\n              if (Character.isHighSurrogate(c)) {\n                this.prevHighSurrogate = c;\n              } else {\n                outInt[outOffset] = c;\n                outOffset++;\n                this.prevHighSurrogate = -1;\n              }\n            }\n          } else if (Character.isHighSurrogate(c)) {\n            this.prevHighSurrogate = c;\n          } else {\n            outInt[outOffset] = c;\n            outOffset++;\n          }\n        }\n        if (this.prevHighSurrogate !== -1) {\n          outInt[outOffset] = this.prevHighSurrogate;\n          outOffset++;\n        }\n        this.position = outOffset;\n      }\n      byteToCharBuffer(toAppend) {\n        let newBuffer = new Uint16Array(Math.max(this.position + toAppend, this.buffer.length >> 1));\n        newBuffer.set(this.buffer.subarray(0, this.position), 0);\n        this.type = 1;\n        this.buffer = newBuffer;\n      }\n      byteToIntBuffer(toAppend) {\n        let newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 2));\n        newBuffer.set(this.buffer.subarray(0, this.position), 0);\n        this.type = 2;\n        this.buffer = newBuffer;\n      }\n      charToIntBuffer(toAppend) {\n        let newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 1));\n        newBuffer.set(this.buffer.subarray(0, this.position), 0);\n        this.type = 2;\n        this.buffer = newBuffer;\n      }\n    }\n    CodePointBuffer2.Builder = Builder;\n  })(CodePointBuffer = exports.CodePointBuffer || (exports.CodePointBuffer = {}));\n});\n\n// node_modules/antlr4ts/CodePointCharStream.js\nvar require_CodePointCharStream = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.CodePointCharStream = void 0;\n  var assert = __webpack_require__(/*! assert */ \"assert\");\n  var IntStream_1 = require_IntStream();\n  var Interval_1 = require_Interval();\n  var Decorators_1 = require_Decorators();\n  var CodePointCharStream = class {\n    constructor(array, position, remaining, name) {\n      assert(position === 0);\n      this._array = array;\n      this._size = remaining;\n      this._name = name;\n      this._position = 0;\n    }\n    get internalStorage() {\n      return this._array;\n    }\n    static fromBuffer(codePointBuffer, name) {\n      if (name === void 0 || name.length === 0) {\n        name = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;\n      }\n      return new CodePointCharStream(codePointBuffer.array(), codePointBuffer.position, codePointBuffer.remaining, name);\n    }\n    consume() {\n      if (this._size - this._position === 0) {\n        assert(this.LA(1) === IntStream_1.IntStream.EOF);\n        throw new RangeError(\"cannot consume EOF\");\n      }\n      this._position++;\n    }\n    get index() {\n      return this._position;\n    }\n    get size() {\n      return this._size;\n    }\n    mark() {\n      return -1;\n    }\n    release(marker) {\n    }\n    seek(index) {\n      this._position = index;\n    }\n    get sourceName() {\n      return this._name;\n    }\n    toString() {\n      return this.getText(Interval_1.Interval.of(0, this.size - 1));\n    }\n    LA(i) {\n      let offset;\n      switch (Math.sign(i)) {\n        case -1:\n          offset = this.index + i;\n          if (offset < 0) {\n            return IntStream_1.IntStream.EOF;\n          }\n          return this._array[offset];\n        case 0:\n          return 0;\n        case 1:\n          offset = this.index + i - 1;\n          if (offset >= this.size) {\n            return IntStream_1.IntStream.EOF;\n          }\n          return this._array[offset];\n      }\n      throw new RangeError(\"Not reached\");\n    }\n    getText(interval) {\n      const startIdx = Math.min(interval.a, this.size);\n      const len = Math.min(interval.b - interval.a + 1, this.size - startIdx);\n      if (this._array instanceof Int32Array) {\n        return String.fromCodePoint(...Array.from(this._array.subarray(startIdx, startIdx + len)));\n      } else {\n        return String.fromCharCode(...Array.from(this._array.subarray(startIdx, startIdx + len)));\n      }\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], CodePointCharStream.prototype, \"consume\", null);\n  __decorate([\n    Decorators_1.Override\n  ], CodePointCharStream.prototype, \"index\", null);\n  __decorate([\n    Decorators_1.Override\n  ], CodePointCharStream.prototype, \"size\", null);\n  __decorate([\n    Decorators_1.Override\n  ], CodePointCharStream.prototype, \"mark\", null);\n  __decorate([\n    Decorators_1.Override\n  ], CodePointCharStream.prototype, \"release\", null);\n  __decorate([\n    Decorators_1.Override\n  ], CodePointCharStream.prototype, \"seek\", null);\n  __decorate([\n    Decorators_1.Override\n  ], CodePointCharStream.prototype, \"sourceName\", null);\n  __decorate([\n    Decorators_1.Override\n  ], CodePointCharStream.prototype, \"toString\", null);\n  __decorate([\n    Decorators_1.Override\n  ], CodePointCharStream.prototype, \"LA\", null);\n  __decorate([\n    Decorators_1.Override\n  ], CodePointCharStream.prototype, \"getText\", null);\n  exports.CodePointCharStream = CodePointCharStream;\n});\n\n// node_modules/antlr4ts/CharStreams.js\nvar require_CharStreams = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.CharStreams = void 0;\n  var CodePointBuffer_1 = require_CodePointBuffer();\n  var CodePointCharStream_1 = require_CodePointCharStream();\n  var IntStream_1 = require_IntStream();\n  var CharStreams;\n  (function(CharStreams2) {\n    function fromString(s, sourceName) {\n      if (sourceName === void 0 || sourceName.length === 0) {\n        sourceName = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;\n      }\n      let codePointBufferBuilder = CodePointBuffer_1.CodePointBuffer.builder(s.length);\n      let cb = new Uint16Array(s.length);\n      for (let i = 0; i < s.length; i++) {\n        cb[i] = s.charCodeAt(i);\n      }\n      codePointBufferBuilder.append(cb);\n      return CodePointCharStream_1.CodePointCharStream.fromBuffer(codePointBufferBuilder.build(), sourceName);\n    }\n    CharStreams2.fromString = fromString;\n  })(CharStreams = exports.CharStreams || (exports.CharStreams = {}));\n});\n\n// node_modules/antlr4ts/BufferedTokenStream.js\nvar require_BufferedTokenStream = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.BufferedTokenStream = void 0;\n  var assert = __webpack_require__(/*! assert */ \"assert\");\n  var CommonToken_1 = require_CommonToken();\n  var Interval_1 = require_Interval();\n  var Lexer_1 = require_Lexer();\n  var Decorators_1 = require_Decorators();\n  var Token_1 = require_Token();\n  var BufferedTokenStream = class BufferedTokenStream {\n    constructor(tokenSource) {\n      this.tokens = [];\n      this.p = -1;\n      this.fetchedEOF = false;\n      if (tokenSource == null) {\n        throw new Error(\"tokenSource cannot be null\");\n      }\n      this._tokenSource = tokenSource;\n    }\n    get tokenSource() {\n      return this._tokenSource;\n    }\n    set tokenSource(tokenSource) {\n      this._tokenSource = tokenSource;\n      this.tokens.length = 0;\n      this.p = -1;\n      this.fetchedEOF = false;\n    }\n    get index() {\n      return this.p;\n    }\n    mark() {\n      return 0;\n    }\n    release(marker) {\n    }\n    seek(index) {\n      this.lazyInit();\n      this.p = this.adjustSeekIndex(index);\n    }\n    get size() {\n      return this.tokens.length;\n    }\n    consume() {\n      let skipEofCheck;\n      if (this.p >= 0) {\n        if (this.fetchedEOF) {\n          skipEofCheck = this.p < this.tokens.length - 1;\n        } else {\n          skipEofCheck = this.p < this.tokens.length;\n        }\n      } else {\n        skipEofCheck = false;\n      }\n      if (!skipEofCheck && this.LA(1) === Token_1.Token.EOF) {\n        throw new Error(\"cannot consume EOF\");\n      }\n      if (this.sync(this.p + 1)) {\n        this.p = this.adjustSeekIndex(this.p + 1);\n      }\n    }\n    sync(i) {\n      assert(i >= 0);\n      let n = i - this.tokens.length + 1;\n      if (n > 0) {\n        let fetched = this.fetch(n);\n        return fetched >= n;\n      }\n      return true;\n    }\n    fetch(n) {\n      if (this.fetchedEOF) {\n        return 0;\n      }\n      for (let i = 0; i < n; i++) {\n        let t = this.tokenSource.nextToken();\n        if (this.isWritableToken(t)) {\n          t.tokenIndex = this.tokens.length;\n        }\n        this.tokens.push(t);\n        if (t.type === Token_1.Token.EOF) {\n          this.fetchedEOF = true;\n          return i + 1;\n        }\n      }\n      return n;\n    }\n    get(i) {\n      if (i < 0 || i >= this.tokens.length) {\n        throw new RangeError(\"token index \" + i + \" out of range 0..\" + (this.tokens.length - 1));\n      }\n      return this.tokens[i];\n    }\n    getRange(start, stop) {\n      if (start < 0 || stop < 0) {\n        return [];\n      }\n      this.lazyInit();\n      let subset = new Array();\n      if (stop >= this.tokens.length) {\n        stop = this.tokens.length - 1;\n      }\n      for (let i = start; i <= stop; i++) {\n        let t = this.tokens[i];\n        if (t.type === Token_1.Token.EOF) {\n          break;\n        }\n        subset.push(t);\n      }\n      return subset;\n    }\n    LA(i) {\n      let token = this.LT(i);\n      if (!token) {\n        return Token_1.Token.INVALID_TYPE;\n      }\n      return token.type;\n    }\n    tryLB(k) {\n      if (this.p - k < 0) {\n        return void 0;\n      }\n      return this.tokens[this.p - k];\n    }\n    LT(k) {\n      let result = this.tryLT(k);\n      if (result === void 0) {\n        throw new RangeError(\"requested lookback index out of range\");\n      }\n      return result;\n    }\n    tryLT(k) {\n      this.lazyInit();\n      if (k === 0) {\n        throw new RangeError(\"0 is not a valid lookahead index\");\n      }\n      if (k < 0) {\n        return this.tryLB(-k);\n      }\n      let i = this.p + k - 1;\n      this.sync(i);\n      if (i >= this.tokens.length) {\n        return this.tokens[this.tokens.length - 1];\n      }\n      return this.tokens[i];\n    }\n    adjustSeekIndex(i) {\n      return i;\n    }\n    lazyInit() {\n      if (this.p === -1) {\n        this.setup();\n      }\n    }\n    setup() {\n      this.sync(0);\n      this.p = this.adjustSeekIndex(0);\n    }\n    getTokens(start, stop, types) {\n      this.lazyInit();\n      if (start === void 0) {\n        assert(stop === void 0 && types === void 0);\n        return this.tokens;\n      } else if (stop === void 0) {\n        stop = this.tokens.length - 1;\n      }\n      if (start < 0 || stop >= this.tokens.length || stop < 0 || start >= this.tokens.length) {\n        throw new RangeError(\"start \" + start + \" or stop \" + stop + \" not in 0..\" + (this.tokens.length - 1));\n      }\n      if (start > stop) {\n        return [];\n      }\n      if (types === void 0) {\n        return this.tokens.slice(start, stop + 1);\n      } else if (typeof types === \"number\") {\n        types = new Set().add(types);\n      }\n      let typesSet = types;\n      let filteredTokens = this.tokens.slice(start, stop + 1);\n      filteredTokens = filteredTokens.filter((value) => typesSet.has(value.type));\n      return filteredTokens;\n    }\n    nextTokenOnChannel(i, channel) {\n      this.sync(i);\n      if (i >= this.size) {\n        return this.size - 1;\n      }\n      let token = this.tokens[i];\n      while (token.channel !== channel) {\n        if (token.type === Token_1.Token.EOF) {\n          return i;\n        }\n        i++;\n        this.sync(i);\n        token = this.tokens[i];\n      }\n      return i;\n    }\n    previousTokenOnChannel(i, channel) {\n      this.sync(i);\n      if (i >= this.size) {\n        return this.size - 1;\n      }\n      while (i >= 0) {\n        let token = this.tokens[i];\n        if (token.type === Token_1.Token.EOF || token.channel === channel) {\n          return i;\n        }\n        i--;\n      }\n      return i;\n    }\n    getHiddenTokensToRight(tokenIndex, channel = -1) {\n      this.lazyInit();\n      if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {\n        throw new RangeError(tokenIndex + \" not in 0..\" + (this.tokens.length - 1));\n      }\n      let nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL);\n      let to;\n      let from = tokenIndex + 1;\n      if (nextOnChannel === -1) {\n        to = this.size - 1;\n      } else {\n        to = nextOnChannel;\n      }\n      return this.filterForChannel(from, to, channel);\n    }\n    getHiddenTokensToLeft(tokenIndex, channel = -1) {\n      this.lazyInit();\n      if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {\n        throw new RangeError(tokenIndex + \" not in 0..\" + (this.tokens.length - 1));\n      }\n      if (tokenIndex === 0) {\n        return [];\n      }\n      let prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL);\n      if (prevOnChannel === tokenIndex - 1) {\n        return [];\n      }\n      let from = prevOnChannel + 1;\n      let to = tokenIndex - 1;\n      return this.filterForChannel(from, to, channel);\n    }\n    filterForChannel(from, to, channel) {\n      let hidden = new Array();\n      for (let i = from; i <= to; i++) {\n        let t = this.tokens[i];\n        if (channel === -1) {\n          if (t.channel !== Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL) {\n            hidden.push(t);\n          }\n        } else {\n          if (t.channel === channel) {\n            hidden.push(t);\n          }\n        }\n      }\n      return hidden;\n    }\n    get sourceName() {\n      return this.tokenSource.sourceName;\n    }\n    getText(interval) {\n      if (interval === void 0) {\n        interval = Interval_1.Interval.of(0, this.size - 1);\n      } else if (!(interval instanceof Interval_1.Interval)) {\n        interval = interval.sourceInterval;\n      }\n      let start = interval.a;\n      let stop = interval.b;\n      if (start < 0 || stop < 0) {\n        return \"\";\n      }\n      this.fill();\n      if (stop >= this.tokens.length) {\n        stop = this.tokens.length - 1;\n      }\n      let buf = \"\";\n      for (let i = start; i <= stop; i++) {\n        let t = this.tokens[i];\n        if (t.type === Token_1.Token.EOF) {\n          break;\n        }\n        buf += t.text;\n      }\n      return buf.toString();\n    }\n    getTextFromRange(start, stop) {\n      if (this.isToken(start) && this.isToken(stop)) {\n        return this.getText(Interval_1.Interval.of(start.tokenIndex, stop.tokenIndex));\n      }\n      return \"\";\n    }\n    fill() {\n      this.lazyInit();\n      const blockSize = 1e3;\n      while (true) {\n        let fetched = this.fetch(blockSize);\n        if (fetched < blockSize) {\n          return;\n        }\n      }\n    }\n    isWritableToken(t) {\n      return t instanceof CommonToken_1.CommonToken;\n    }\n    isToken(t) {\n      return t instanceof CommonToken_1.CommonToken;\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], BufferedTokenStream.prototype, \"_tokenSource\", void 0);\n  __decorate([\n    Decorators_1.Override\n  ], BufferedTokenStream.prototype, \"tokenSource\", null);\n  __decorate([\n    Decorators_1.Override\n  ], BufferedTokenStream.prototype, \"index\", null);\n  __decorate([\n    Decorators_1.Override\n  ], BufferedTokenStream.prototype, \"mark\", null);\n  __decorate([\n    Decorators_1.Override\n  ], BufferedTokenStream.prototype, \"release\", null);\n  __decorate([\n    Decorators_1.Override\n  ], BufferedTokenStream.prototype, \"seek\", null);\n  __decorate([\n    Decorators_1.Override\n  ], BufferedTokenStream.prototype, \"size\", null);\n  __decorate([\n    Decorators_1.Override\n  ], BufferedTokenStream.prototype, \"consume\", null);\n  __decorate([\n    Decorators_1.Override\n  ], BufferedTokenStream.prototype, \"get\", null);\n  __decorate([\n    Decorators_1.Override\n  ], BufferedTokenStream.prototype, \"LA\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    Decorators_1.Override\n  ], BufferedTokenStream.prototype, \"LT\", null);\n  __decorate([\n    Decorators_1.Override\n  ], BufferedTokenStream.prototype, \"sourceName\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    Decorators_1.Override\n  ], BufferedTokenStream.prototype, \"getText\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    Decorators_1.Override\n  ], BufferedTokenStream.prototype, \"getTextFromRange\", null);\n  BufferedTokenStream = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], BufferedTokenStream);\n  exports.BufferedTokenStream = BufferedTokenStream;\n});\n\n// node_modules/antlr4ts/CommonTokenStream.js\nvar require_CommonTokenStream = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.CommonTokenStream = void 0;\n  var BufferedTokenStream_1 = require_BufferedTokenStream();\n  var Decorators_1 = require_Decorators();\n  var Token_1 = require_Token();\n  var CommonTokenStream2 = class CommonTokenStream extends BufferedTokenStream_1.BufferedTokenStream {\n    constructor(tokenSource, channel = Token_1.Token.DEFAULT_CHANNEL) {\n      super(tokenSource);\n      this.channel = channel;\n    }\n    adjustSeekIndex(i) {\n      return this.nextTokenOnChannel(i, this.channel);\n    }\n    tryLB(k) {\n      if (this.p - k < 0) {\n        return void 0;\n      }\n      let i = this.p;\n      let n = 1;\n      while (n <= k && i > 0) {\n        i = this.previousTokenOnChannel(i - 1, this.channel);\n        n++;\n      }\n      if (i < 0) {\n        return void 0;\n      }\n      return this.tokens[i];\n    }\n    tryLT(k) {\n      this.lazyInit();\n      if (k === 0) {\n        throw new RangeError(\"0 is not a valid lookahead index\");\n      }\n      if (k < 0) {\n        return this.tryLB(-k);\n      }\n      let i = this.p;\n      let n = 1;\n      while (n < k) {\n        if (this.sync(i + 1)) {\n          i = this.nextTokenOnChannel(i + 1, this.channel);\n        }\n        n++;\n      }\n      return this.tokens[i];\n    }\n    getNumberOfOnChannelTokens() {\n      let n = 0;\n      this.fill();\n      for (let t of this.tokens) {\n        if (t.channel === this.channel) {\n          n++;\n        }\n        if (t.type === Token_1.Token.EOF) {\n          break;\n        }\n      }\n      return n;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], CommonTokenStream2.prototype, \"adjustSeekIndex\", null);\n  __decorate([\n    Decorators_1.Override\n  ], CommonTokenStream2.prototype, \"tryLB\", null);\n  __decorate([\n    Decorators_1.Override\n  ], CommonTokenStream2.prototype, \"tryLT\", null);\n  CommonTokenStream2 = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], CommonTokenStream2);\n  exports.CommonTokenStream = CommonTokenStream2;\n});\n\n// node_modules/antlr4ts/ListTokenSource.js\nvar require_ListTokenSource = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ListTokenSource = void 0;\n  var CommonTokenFactory_1 = require_CommonTokenFactory();\n  var Decorators_1 = require_Decorators();\n  var Token_1 = require_Token();\n  var ListTokenSource = class ListTokenSource {\n    constructor(tokens2, sourceName) {\n      this.i = 0;\n      this._factory = CommonTokenFactory_1.CommonTokenFactory.DEFAULT;\n      if (tokens2 == null) {\n        throw new Error(\"tokens cannot be null\");\n      }\n      this.tokens = tokens2;\n      this._sourceName = sourceName;\n    }\n    get charPositionInLine() {\n      if (this.i < this.tokens.length) {\n        return this.tokens[this.i].charPositionInLine;\n      } else if (this.eofToken != null) {\n        return this.eofToken.charPositionInLine;\n      } else if (this.tokens.length > 0) {\n        let lastToken = this.tokens[this.tokens.length - 1];\n        let tokenText = lastToken.text;\n        if (tokenText != null) {\n          let lastNewLine = tokenText.lastIndexOf(\"\\n\");\n          if (lastNewLine >= 0) {\n            return tokenText.length - lastNewLine - 1;\n          }\n        }\n        return lastToken.charPositionInLine + lastToken.stopIndex - lastToken.startIndex + 1;\n      }\n      return 0;\n    }\n    nextToken() {\n      if (this.i >= this.tokens.length) {\n        if (this.eofToken == null) {\n          let start = -1;\n          if (this.tokens.length > 0) {\n            let previousStop = this.tokens[this.tokens.length - 1].stopIndex;\n            if (previousStop !== -1) {\n              start = previousStop + 1;\n            }\n          }\n          let stop = Math.max(-1, start - 1);\n          this.eofToken = this._factory.create({source: this, stream: this.inputStream}, Token_1.Token.EOF, \"EOF\", Token_1.Token.DEFAULT_CHANNEL, start, stop, this.line, this.charPositionInLine);\n        }\n        return this.eofToken;\n      }\n      let t = this.tokens[this.i];\n      if (this.i === this.tokens.length - 1 && t.type === Token_1.Token.EOF) {\n        this.eofToken = t;\n      }\n      this.i++;\n      return t;\n    }\n    get line() {\n      if (this.i < this.tokens.length) {\n        return this.tokens[this.i].line;\n      } else if (this.eofToken != null) {\n        return this.eofToken.line;\n      } else if (this.tokens.length > 0) {\n        let lastToken = this.tokens[this.tokens.length - 1];\n        let line = lastToken.line;\n        let tokenText = lastToken.text;\n        if (tokenText != null) {\n          for (let i = 0; i < tokenText.length; i++) {\n            if (tokenText.charAt(i) === \"\\n\") {\n              line++;\n            }\n          }\n        }\n        return line;\n      }\n      return 1;\n    }\n    get inputStream() {\n      if (this.i < this.tokens.length) {\n        return this.tokens[this.i].inputStream;\n      } else if (this.eofToken != null) {\n        return this.eofToken.inputStream;\n      } else if (this.tokens.length > 0) {\n        return this.tokens[this.tokens.length - 1].inputStream;\n      }\n      return void 0;\n    }\n    get sourceName() {\n      if (this._sourceName) {\n        return this._sourceName;\n      }\n      let inputStream = this.inputStream;\n      if (inputStream != null) {\n        return inputStream.sourceName;\n      }\n      return \"List\";\n    }\n    set tokenFactory(factory) {\n      this._factory = factory;\n    }\n    get tokenFactory() {\n      return this._factory;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], ListTokenSource.prototype, \"charPositionInLine\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ListTokenSource.prototype, \"nextToken\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ListTokenSource.prototype, \"line\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ListTokenSource.prototype, \"inputStream\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ListTokenSource.prototype, \"sourceName\", null);\n  __decorate([\n    Decorators_1.Override,\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n  ], ListTokenSource.prototype, \"tokenFactory\", null);\n  ListTokenSource = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], ListTokenSource);\n  exports.ListTokenSource = ListTokenSource;\n});\n\n// node_modules/antlr4ts/misc/MultiMap.js\nvar require_MultiMap = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.MultiMap = void 0;\n  var MultiMap = class extends Map {\n    constructor() {\n      super();\n    }\n    map(key, value) {\n      let elementsForKey = super.get(key);\n      if (!elementsForKey) {\n        elementsForKey = [];\n        super.set(key, elementsForKey);\n      }\n      elementsForKey.push(value);\n    }\n    getPairs() {\n      let pairs = [];\n      this.forEach((values, key) => {\n        values.forEach((v) => {\n          pairs.push([key, v]);\n        });\n      });\n      return pairs;\n    }\n  };\n  exports.MultiMap = MultiMap;\n});\n\n// node_modules/antlr4ts/misc/ParseCancellationException.js\nvar require_ParseCancellationException = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ParseCancellationException = void 0;\n  var ParseCancellationException = class extends Error {\n    constructor(cause) {\n      super(cause.message);\n      this.cause = cause;\n      this.stack = cause.stack;\n    }\n    getCause() {\n      return this.cause;\n    }\n  };\n  exports.ParseCancellationException = ParseCancellationException;\n});\n\n// node_modules/antlr4ts/InterpreterRuleContext.js\nvar require_InterpreterRuleContext = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.InterpreterRuleContext = void 0;\n  var Decorators_1 = require_Decorators();\n  var ParserRuleContext_1 = require_ParserRuleContext();\n  var InterpreterRuleContext = class extends ParserRuleContext_1.ParserRuleContext {\n    constructor(ruleIndex, parent, invokingStateNumber) {\n      if (invokingStateNumber !== void 0) {\n        super(parent, invokingStateNumber);\n      } else {\n        super();\n      }\n      this._ruleIndex = ruleIndex;\n    }\n    get ruleIndex() {\n      return this._ruleIndex;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], InterpreterRuleContext.prototype, \"ruleIndex\", null);\n  exports.InterpreterRuleContext = InterpreterRuleContext;\n});\n\n// node_modules/antlr4ts/ParserInterpreter.js\nvar require_ParserInterpreter = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ParserInterpreter = void 0;\n  var ATNState_1 = require_ATNState();\n  var ATNStateType_1 = require_ATNStateType();\n  var BitSet_1 = require_BitSet();\n  var FailedPredicateException_1 = require_FailedPredicateException();\n  var InputMismatchException_1 = require_InputMismatchException();\n  var InterpreterRuleContext_1 = require_InterpreterRuleContext();\n  var LoopEndState_1 = require_LoopEndState();\n  var Decorators_1 = require_Decorators();\n  var Decorators_2 = require_Decorators();\n  var Parser_1 = require_Parser();\n  var ParserATNSimulator_1 = require_ParserATNSimulator();\n  var RecognitionException_1 = require_RecognitionException();\n  var StarLoopEntryState_1 = require_StarLoopEntryState();\n  var Token_1 = require_Token();\n  var ParserInterpreter = class ParserInterpreter2 extends Parser_1.Parser {\n    constructor(grammarFileName, vocabulary, ruleNames, atn, input) {\n      super(grammarFileName instanceof ParserInterpreter2 ? grammarFileName.inputStream : input);\n      this._parentContextStack = [];\n      this.overrideDecision = -1;\n      this.overrideDecisionInputIndex = -1;\n      this.overrideDecisionAlt = -1;\n      this.overrideDecisionReached = false;\n      this._overrideDecisionRoot = void 0;\n      if (grammarFileName instanceof ParserInterpreter2) {\n        let old = grammarFileName;\n        this._grammarFileName = old._grammarFileName;\n        this._atn = old._atn;\n        this.pushRecursionContextStates = old.pushRecursionContextStates;\n        this._ruleNames = old._ruleNames;\n        this._vocabulary = old._vocabulary;\n        this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this._atn, this);\n      } else {\n        vocabulary = vocabulary;\n        ruleNames = ruleNames;\n        atn = atn;\n        this._grammarFileName = grammarFileName;\n        this._atn = atn;\n        this._ruleNames = ruleNames.slice(0);\n        this._vocabulary = vocabulary;\n        this.pushRecursionContextStates = new BitSet_1.BitSet(atn.states.length);\n        for (let state of atn.states) {\n          if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {\n            continue;\n          }\n          if (state.precedenceRuleDecision) {\n            this.pushRecursionContextStates.set(state.stateNumber);\n          }\n        }\n        this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(atn, this);\n      }\n    }\n    reset(resetInput) {\n      if (resetInput === void 0) {\n        super.reset();\n      } else {\n        super.reset(resetInput);\n      }\n      this.overrideDecisionReached = false;\n      this._overrideDecisionRoot = void 0;\n    }\n    get atn() {\n      return this._atn;\n    }\n    get vocabulary() {\n      return this._vocabulary;\n    }\n    get ruleNames() {\n      return this._ruleNames;\n    }\n    get grammarFileName() {\n      return this._grammarFileName;\n    }\n    parse(startRuleIndex) {\n      let startRuleStartState = this._atn.ruleToStartState[startRuleIndex];\n      this._rootContext = this.createInterpreterRuleContext(void 0, ATNState_1.ATNState.INVALID_STATE_NUMBER, startRuleIndex);\n      if (startRuleStartState.isPrecedenceRule) {\n        this.enterRecursionRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex, 0);\n      } else {\n        this.enterRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex);\n      }\n      while (true) {\n        let p = this.atnState;\n        switch (p.stateType) {\n          case ATNStateType_1.ATNStateType.RULE_STOP:\n            if (this._ctx.isEmpty) {\n              if (startRuleStartState.isPrecedenceRule) {\n                let result = this._ctx;\n                let parentContext = this._parentContextStack.pop();\n                this.unrollRecursionContexts(parentContext[0]);\n                return result;\n              } else {\n                this.exitRule();\n                return this._rootContext;\n              }\n            }\n            this.visitRuleStopState(p);\n            break;\n          default:\n            try {\n              this.visitState(p);\n            } catch (e) {\n              if (e instanceof RecognitionException_1.RecognitionException) {\n                this.state = this._atn.ruleToStopState[p.ruleIndex].stateNumber;\n                this.context.exception = e;\n                this.errorHandler.reportError(this, e);\n                this.recover(e);\n              } else {\n                throw e;\n              }\n            }\n            break;\n        }\n      }\n    }\n    enterRecursionRule(localctx, state, ruleIndex, precedence) {\n      this._parentContextStack.push([this._ctx, localctx.invokingState]);\n      super.enterRecursionRule(localctx, state, ruleIndex, precedence);\n    }\n    get atnState() {\n      return this._atn.states[this.state];\n    }\n    visitState(p) {\n      let predictedAlt = 1;\n      if (p.numberOfTransitions > 1) {\n        predictedAlt = this.visitDecisionState(p);\n      }\n      let transition = p.transition(predictedAlt - 1);\n      switch (transition.serializationType) {\n        case 1:\n          if (this.pushRecursionContextStates.get(p.stateNumber) && !(transition.target instanceof LoopEndState_1.LoopEndState)) {\n            let parentContext = this._parentContextStack[this._parentContextStack.length - 1];\n            let localctx = this.createInterpreterRuleContext(parentContext[0], parentContext[1], this._ctx.ruleIndex);\n            this.pushNewRecursionContext(localctx, this._atn.ruleToStartState[p.ruleIndex].stateNumber, this._ctx.ruleIndex);\n          }\n          break;\n        case 5:\n          this.match(transition._label);\n          break;\n        case 2:\n        case 7:\n        case 8:\n          if (!transition.matches(this._input.LA(1), Token_1.Token.MIN_USER_TOKEN_TYPE, 65535)) {\n            this.recoverInline();\n          }\n          this.matchWildcard();\n          break;\n        case 9:\n          this.matchWildcard();\n          break;\n        case 3:\n          let ruleStartState = transition.target;\n          let ruleIndex = ruleStartState.ruleIndex;\n          let newctx = this.createInterpreterRuleContext(this._ctx, p.stateNumber, ruleIndex);\n          if (ruleStartState.isPrecedenceRule) {\n            this.enterRecursionRule(newctx, ruleStartState.stateNumber, ruleIndex, transition.precedence);\n          } else {\n            this.enterRule(newctx, transition.target.stateNumber, ruleIndex);\n          }\n          break;\n        case 4:\n          let predicateTransition = transition;\n          if (!this.sempred(this._ctx, predicateTransition.ruleIndex, predicateTransition.predIndex)) {\n            throw new FailedPredicateException_1.FailedPredicateException(this);\n          }\n          break;\n        case 6:\n          let actionTransition = transition;\n          this.action(this._ctx, actionTransition.ruleIndex, actionTransition.actionIndex);\n          break;\n        case 10:\n          if (!this.precpred(this._ctx, transition.precedence)) {\n            let precedence = transition.precedence;\n            throw new FailedPredicateException_1.FailedPredicateException(this, `precpred(_ctx, ${precedence})`);\n          }\n          break;\n        default:\n          throw new Error(\"UnsupportedOperationException: Unrecognized ATN transition type.\");\n      }\n      this.state = transition.target.stateNumber;\n    }\n    visitDecisionState(p) {\n      let predictedAlt;\n      this.errorHandler.sync(this);\n      let decision = p.decision;\n      if (decision === this.overrideDecision && this._input.index === this.overrideDecisionInputIndex && !this.overrideDecisionReached) {\n        predictedAlt = this.overrideDecisionAlt;\n        this.overrideDecisionReached = true;\n      } else {\n        predictedAlt = this.interpreter.adaptivePredict(this._input, decision, this._ctx);\n      }\n      return predictedAlt;\n    }\n    createInterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {\n      return new InterpreterRuleContext_1.InterpreterRuleContext(ruleIndex, parent, invokingStateNumber);\n    }\n    visitRuleStopState(p) {\n      let ruleStartState = this._atn.ruleToStartState[p.ruleIndex];\n      if (ruleStartState.isPrecedenceRule) {\n        let parentContext = this._parentContextStack.pop();\n        this.unrollRecursionContexts(parentContext[0]);\n        this.state = parentContext[1];\n      } else {\n        this.exitRule();\n      }\n      let ruleTransition = this._atn.states[this.state].transition(0);\n      this.state = ruleTransition.followState.stateNumber;\n    }\n    addDecisionOverride(decision, tokenIndex, forcedAlt) {\n      this.overrideDecision = decision;\n      this.overrideDecisionInputIndex = tokenIndex;\n      this.overrideDecisionAlt = forcedAlt;\n    }\n    get overrideDecisionRoot() {\n      return this._overrideDecisionRoot;\n    }\n    recover(e) {\n      let i = this._input.index;\n      this.errorHandler.recover(this, e);\n      if (this._input.index === i) {\n        let tok = e.getOffendingToken();\n        if (!tok) {\n          throw new Error(\"Expected exception to have an offending token\");\n        }\n        let source = tok.tokenSource;\n        let stream = source !== void 0 ? source.inputStream : void 0;\n        let sourcePair = {source, stream};\n        if (e instanceof InputMismatchException_1.InputMismatchException) {\n          let expectedTokens = e.expectedTokens;\n          if (expectedTokens === void 0) {\n            throw new Error(\"Expected the exception to provide expected tokens\");\n          }\n          let expectedTokenType = Token_1.Token.INVALID_TYPE;\n          if (!expectedTokens.isNil) {\n            expectedTokenType = expectedTokens.minElement;\n          }\n          let errToken = this.tokenFactory.create(sourcePair, expectedTokenType, tok.text, Token_1.Token.DEFAULT_CHANNEL, -1, -1, tok.line, tok.charPositionInLine);\n          this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));\n        } else {\n          let source2 = tok.tokenSource;\n          let errToken = this.tokenFactory.create(sourcePair, Token_1.Token.INVALID_TYPE, tok.text, Token_1.Token.DEFAULT_CHANNEL, -1, -1, tok.line, tok.charPositionInLine);\n          this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));\n        }\n      }\n    }\n    recoverInline() {\n      return this._errHandler.recoverInline(this);\n    }\n    get rootContext() {\n      return this._rootContext;\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], ParserInterpreter.prototype, \"_vocabulary\", void 0);\n  __decorate([\n    Decorators_2.Override\n  ], ParserInterpreter.prototype, \"reset\", null);\n  __decorate([\n    Decorators_2.Override\n  ], ParserInterpreter.prototype, \"atn\", null);\n  __decorate([\n    Decorators_2.Override\n  ], ParserInterpreter.prototype, \"vocabulary\", null);\n  __decorate([\n    Decorators_2.Override\n  ], ParserInterpreter.prototype, \"ruleNames\", null);\n  __decorate([\n    Decorators_2.Override\n  ], ParserInterpreter.prototype, \"grammarFileName\", null);\n  __decorate([\n    Decorators_2.Override\n  ], ParserInterpreter.prototype, \"enterRecursionRule\", null);\n  ParserInterpreter = __decorate([\n    __param(1, Decorators_1.NotNull)\n  ], ParserInterpreter);\n  exports.ParserInterpreter = ParserInterpreter;\n});\n\n// node_modules/antlr4ts/tree/pattern/ParseTreeMatch.js\nvar require_ParseTreeMatch = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ParseTreeMatch = void 0;\n  var Decorators_1 = require_Decorators();\n  var ParseTreeMatch = class ParseTreeMatch {\n    constructor(tree, pattern, labels, mismatchedNode) {\n      if (!tree) {\n        throw new Error(\"tree cannot be null\");\n      }\n      if (!pattern) {\n        throw new Error(\"pattern cannot be null\");\n      }\n      if (!labels) {\n        throw new Error(\"labels cannot be null\");\n      }\n      this._tree = tree;\n      this._pattern = pattern;\n      this._labels = labels;\n      this._mismatchedNode = mismatchedNode;\n    }\n    get(label) {\n      let parseTrees = this._labels.get(label);\n      if (!parseTrees || parseTrees.length === 0) {\n        return void 0;\n      }\n      return parseTrees[parseTrees.length - 1];\n    }\n    getAll(label) {\n      const nodes = this._labels.get(label);\n      if (!nodes) {\n        return [];\n      }\n      return nodes;\n    }\n    get labels() {\n      return this._labels;\n    }\n    get mismatchedNode() {\n      return this._mismatchedNode;\n    }\n    get succeeded() {\n      return !this._mismatchedNode;\n    }\n    get pattern() {\n      return this._pattern;\n    }\n    get tree() {\n      return this._tree;\n    }\n    toString() {\n      return `Match ${this.succeeded ? \"succeeded\" : \"failed\"}; found ${this.labels.size} labels`;\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n  ], ParseTreeMatch.prototype, \"getAll\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], ParseTreeMatch.prototype, \"labels\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], ParseTreeMatch.prototype, \"pattern\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], ParseTreeMatch.prototype, \"tree\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ParseTreeMatch.prototype, \"toString\", null);\n  ParseTreeMatch = __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n  ], ParseTreeMatch);\n  exports.ParseTreeMatch = ParseTreeMatch;\n});\n\n// node_modules/antlr4ts/tree/xpath/XPathLexer.js\nvar require_XPathLexer = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.XPathLexer = void 0;\n  var ATNDeserializer_1 = require_ATNDeserializer();\n  var Lexer_1 = require_Lexer();\n  var LexerATNSimulator_1 = require_LexerATNSimulator();\n  var VocabularyImpl_1 = require_VocabularyImpl();\n  var Utils3 = require_Utils();\n  var XPathLexer = class extends Lexer_1.Lexer {\n    constructor(input) {\n      super(input);\n      this._interp = new LexerATNSimulator_1.LexerATNSimulator(XPathLexer._ATN, this);\n    }\n    get vocabulary() {\n      return XPathLexer.VOCABULARY;\n    }\n    get grammarFileName() {\n      return \"XPathLexer.g4\";\n    }\n    get ruleNames() {\n      return XPathLexer.ruleNames;\n    }\n    get serializedATN() {\n      return XPathLexer._serializedATN;\n    }\n    get channelNames() {\n      return XPathLexer.channelNames;\n    }\n    get modeNames() {\n      return XPathLexer.modeNames;\n    }\n    action(_localctx, ruleIndex, actionIndex) {\n      switch (ruleIndex) {\n        case 4:\n          this.ID_action(_localctx, actionIndex);\n          break;\n      }\n    }\n    ID_action(_localctx, actionIndex) {\n      switch (actionIndex) {\n        case 0:\n          let text = this.text;\n          if (text.charAt(0) === text.charAt(0).toUpperCase()) {\n            this.type = XPathLexer.TOKEN_REF;\n          } else {\n            this.type = XPathLexer.RULE_REF;\n          }\n          break;\n      }\n    }\n    static get _ATN() {\n      if (!XPathLexer.__ATN) {\n        XPathLexer.__ATN = new ATNDeserializer_1.ATNDeserializer().deserialize(Utils3.toCharArray(XPathLexer._serializedATN));\n      }\n      return XPathLexer.__ATN;\n    }\n  };\n  exports.XPathLexer = XPathLexer;\n  XPathLexer.TOKEN_REF = 1;\n  XPathLexer.RULE_REF = 2;\n  XPathLexer.ANYWHERE = 3;\n  XPathLexer.ROOT = 4;\n  XPathLexer.WILDCARD = 5;\n  XPathLexer.BANG = 6;\n  XPathLexer.ID = 7;\n  XPathLexer.STRING = 8;\n  XPathLexer.channelNames = [\n    \"DEFAULT_TOKEN_CHANNEL\",\n    \"HIDDEN\"\n  ];\n  XPathLexer.modeNames = [\n    \"DEFAULT_MODE\"\n  ];\n  XPathLexer.ruleNames = [\n    \"ANYWHERE\",\n    \"ROOT\",\n    \"WILDCARD\",\n    \"BANG\",\n    \"ID\",\n    \"NameChar\",\n    \"NameStartChar\",\n    \"STRING\"\n  ];\n  XPathLexer._LITERAL_NAMES = [\n    void 0,\n    void 0,\n    void 0,\n    \"'//'\",\n    \"'/'\",\n    \"'*'\",\n    \"'!'\"\n  ];\n  XPathLexer._SYMBOLIC_NAMES = [\n    void 0,\n    \"TOKEN_REF\",\n    \"RULE_REF\",\n    \"ANYWHERE\",\n    \"ROOT\",\n    \"WILDCARD\",\n    \"BANG\",\n    \"ID\",\n    \"STRING\"\n  ];\n  XPathLexer.VOCABULARY = new VocabularyImpl_1.VocabularyImpl(XPathLexer._LITERAL_NAMES, XPathLexer._SYMBOLIC_NAMES, []);\n  XPathLexer._serializedATNSegments = 2;\n  XPathLexer._serializedATNSegment0 = '\u0003\\uC91D\\uCABA\\u058D\\uAFBA\\u4F53\\u0607\\uEA8B\\uC241\u0002\\n2\\b\u0001\u0004\u0002\t\u0002\u0004\u0003\t\u0003\u0004\u0004\t\u0004\u0004\u0005\t\u0005\u0004\u0006\t\u0006\u0004\\x07\t\\x07\u0004\\b\t\\b\u0004\t\t\t\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0003\u0003\u0003\u0003\u0004\u0003\u0004\u0003\u0005\u0003\u0005\u0003\u0006\u0003\u0006\\x07\u0006\u001f\\n\u0006\\f\u0006\u000e\u0006\"\\v\u0006\u0003\u0006\u0003\u0006\u0003\\x07\u0003\\x07\u0003\\b\u0003\\b\u0003\t\u0003\t\\x07\t,\\n\t\\f\t\u000e\t/\\v\t\u0003\t\u0003\t\u0003-\u0002\u0002\\n\u0003\u0002\u0005\u0005\u0002\u0006\\x07\u0002\\x07\t\u0002\\b\\v\u0002\t\\r\u0002\u0002\u000f\u0002\u0002\u0011\u0002\\n\u0003\u0002\u0002\u0004\\u02B6\u0002\u0002\u0002\\n\u0002\u0010\u0002\u001d\u00022\u0002;\u0002C\u0002\\\\\u0002a\u0002a\u0002c\u0002|\u0002\\x81\u0002\\xA1\u0002\\xAC\u0002\\xAC\u0002\\xAF\u0002\\xAF\u0002\\xB7\u0002\\xB7\u0002\\xBC\u0002\\xBC\u0002\\xC2\u0002\\xD8\u0002\\xDA\u0002\\xF8\u0002\\xFA\u0002\\u02C3\u0002\\u02C8\u0002\\u02D3\u0002\\u02E2\u0002\\u02E6\u0002\\u02EE\u0002\\u02EE\u0002\\u02F0\u0002\\u02F0\u0002\\u0302\u0002\\u0376\u0002\\u0378\u0002\\u0379\u0002\\u037C\u0002\\u037F\u0002\\u0381\u0002\\u0381\u0002\\u0388\u0002\\u0388\u0002\\u038A\u0002\\u038C\u0002\\u038E\u0002\\u038E\u0002\\u0390\u0002\\u03A3\u0002\\u03A5\u0002\\u03F7\u0002\\u03F9\u0002\\u0483\u0002\\u0485\u0002\\u0489\u0002\\u048C\u0002\\u0531\u0002\\u0533\u0002\\u0558\u0002\\u055B\u0002\\u055B\u0002\\u0563\u0002\\u0589\u0002\\u0593\u0002\\u05BF\u0002\\u05C1\u0002\\u05C1\u0002\\u05C3\u0002\\u05C4\u0002\\u05C6\u0002\\u05C7\u0002\\u05C9\u0002\\u05C9\u0002\\u05D2\u0002\\u05EC\u0002\\u05F2\u0002\\u05F4\u0002\\u0602\u0002\\u0607\u0002\\u0612\u0002\\u061C\u0002\\u061E\u0002\\u061E\u0002\\u0622\u0002\\u066B\u0002\\u0670\u0002\\u06D5\u0002\\u06D7\u0002\\u06DF\u0002\\u06E1\u0002\\u06EA\u0002\\u06EC\u0002\\u06FE\u0002\\u0701\u0002\\u0701\u0002\\u0711\u0002\\u074C\u0002\\u074F\u0002\\u07B3\u0002\\u07C2\u0002\\u07F7\u0002\\u07FC\u0002\\u07FC\u0002\\u0802\u0002\\u082F\u0002\\u0842\u0002\\u085D\u0002\\u08A2\u0002\\u08B6\u0002\\u08B8\u0002\\u08BF\u0002\\u08D6\u0002\\u0965\u0002\\u0968\u0002\\u0971\u0002\\u0973\u0002\\u0985\u0002\\u0987\u0002\\u098E\u0002\\u0991\u0002\\u0992\u0002\\u0995\u0002\\u09AA\u0002\\u09AC\u0002\\u09B2\u0002\\u09B4\u0002\\u09B4\u0002\\u09B8\u0002\\u09BB\u0002\\u09BE\u0002\\u09C6\u0002\\u09C9\u0002\\u09CA\u0002\\u09CD\u0002\\u09D0\u0002\\u09D9\u0002\\u09D9\u0002\\u09DE\u0002\\u09DF\u0002\\u09E1\u0002\\u09E5\u0002\\u09E8\u0002\\u09F3\u0002\\u0A03\u0002\\u0A05\u0002\\u0A07\u0002\\u0A0C\u0002\\u0A11\u0002\\u0A12\u0002\\u0A15\u0002\\u0A2A\u0002\\u0A2C\u0002\\u0A32\u0002\\u0A34\u0002\\u0A35\u0002\\u0A37\u0002\\u0A38\u0002\\u0A3A\u0002\\u0A3B\u0002\\u0A3E\u0002\\u0A3E\u0002\\u0A40\u0002\\u0A44\u0002\\u0A49\u0002\\u0A4A\u0002\\u0A4D\u0002\\u0A4F\u0002\\u0A53\u0002\\u0A53\u0002\\u0A5B\u0002\\u0A5E\u0002\\u0A60\u0002\\u0A60\u0002\\u0A68\u0002\\u0A77\u0002\\u0A83\u0002\\u0A85\u0002\\u0A87\u0002\\u0A8F\u0002\\u0A91\u0002\\u0A93\u0002\\u0A95\u0002\\u0AAA\u0002\\u0AAC\u0002\\u0AB2\u0002\\u0AB4\u0002\\u0AB5\u0002\\u0AB7\u0002\\u0ABB\u0002\\u0ABE\u0002\\u0AC7\u0002\\u0AC9\u0002\\u0ACB\u0002\\u0ACD\u0002\\u0ACF\u0002\\u0AD2\u0002\\u0AD2\u0002\\u0AE2\u0002\\u0AE5\u0002\\u0AE8\u0002\\u0AF1\u0002\\u0AFB\u0002\\u0AFB\u0002\\u0B03\u0002\\u0B05\u0002\\u0B07\u0002\\u0B0E\u0002\\u0B11\u0002\\u0B12\u0002\\u0B15\u0002\\u0B2A\u0002\\u0B2C\u0002\\u0B32\u0002\\u0B34\u0002\\u0B35\u0002\\u0B37\u0002\\u0B3B\u0002\\u0B3E\u0002\\u0B46\u0002\\u0B49\u0002\\u0B4A\u0002\\u0B4D\u0002\\u0B4F\u0002\\u0B58\u0002\\u0B59\u0002\\u0B5E\u0002\\u0B5F\u0002\\u0B61\u0002\\u0B65\u0002\\u0B68\u0002\\u0B71\u0002\\u0B73\u0002\\u0B73\u0002\\u0B84\u0002\\u0B85\u0002\\u0B87\u0002\\u0B8C\u0002\\u0B90\u0002\\u0B92\u0002\\u0B94\u0002\\u0B97\u0002\\u0B9B\u0002\\u0B9C\u0002\\u0B9E\u0002\\u0B9E\u0002\\u0BA0\u0002\\u0BA1\u0002\\u0BA5\u0002\\u0BA6\u0002\\u0BAA\u0002\\u0BAC\u0002\\u0BB0\u0002\\u0BBB\u0002\\u0BC0\u0002\\u0BC4\u0002\\u0BC8\u0002\\u0BCA\u0002\\u0BCC\u0002\\u0BCF\u0002\\u0BD2\u0002\\u0BD2\u0002\\u0BD9\u0002\\u0BD9\u0002\\u0BE8\u0002\\u0BF1\u0002\\u0C02\u0002\\u0C05\u0002\\u0C07\u0002\\u0C0E\u0002\\u0C10\u0002\\u0C12\u0002\\u0C14\u0002\\u0C2A\u0002\\u0C2C\u0002\\u0C3B\u0002\\u0C3F\u0002\\u0C46\u0002\\u0C48\u0002\\u0C4A\u0002\\u0C4C\u0002\\u0C4F\u0002\\u0C57\u0002\\u0C58\u0002\\u0C5A\u0002\\u0C5C\u0002\\u0C62\u0002\\u0C65\u0002\\u0C68\u0002\\u0C71\u0002\\u0C82\u0002\\u0C85\u0002\\u0C87\u0002\\u0C8E\u0002\\u0C90\u0002\\u0C92\u0002\\u0C94\u0002\\u0CAA\u0002\\u0CAC\u0002\\u0CB5\u0002\\u0CB7\u0002\\u0CBB\u0002\\u0CBE\u0002\\u0CC6\u0002\\u0CC8\u0002\\u0CCA\u0002\\u0CCC\u0002\\u0CCF\u0002\\u0CD7\u0002\\u0CD8\u0002\\u0CE0\u0002\\u0CE0\u0002\\u0CE2\u0002\\u0CE5\u0002\\u0CE8\u0002\\u0CF1\u0002\\u0CF3\u0002\\u0CF4\u0002\\u0D03\u0002\\u0D05\u0002\\u0D07\u0002\\u0D0E\u0002\\u0D10\u0002\\u0D12\u0002\\u0D14\u0002\\u0D3C\u0002\\u0D3F\u0002\\u0D46\u0002\\u0D48\u0002\\u0D4A\u0002\\u0D4C\u0002\\u0D50\u0002\\u0D56\u0002\\u0D59\u0002\\u0D61\u0002\\u0D65\u0002\\u0D68\u0002\\u0D71\u0002\\u0D7C\u0002\\u0D81\u0002\\u0D84\u0002\\u0D85\u0002\\u0D87\u0002\\u0D98\u0002\\u0D9C\u0002\\u0DB3\u0002\\u0DB5\u0002\\u0DBD\u0002\\u0DBF\u0002\\u0DBF\u0002\\u0DC2\u0002\\u0DC8\u0002\\u0DCC\u0002\\u0DCC\u0002\\u0DD1\u0002\\u0DD6\u0002\\u0DD8\u0002\\u0DD8\u0002\\u0DDA\u0002\\u0DE1\u0002\\u0DE8\u0002\\u0DF1\u0002\\u0DF4\u0002\\u0DF5\u0002\\u0E03\u0002\\u0E3C\u0002\\u0E42\u0002\\u0E50\u0002\\u0E52\u0002\\u0E5B\u0002\\u0E83\u0002\\u0E84\u0002\\u0E86\u0002\\u0E86\u0002\\u0E89\u0002\\u0E8A\u0002\\u0E8C\u0002\\u0E8C\u0002\\u0E8F\u0002\\u0E8F\u0002\\u0E96\u0002\\u0E99\u0002\\u0E9B\u0002\\u0EA1\u0002\\u0EA3\u0002\\u0EA5\u0002\\u0EA7\u0002\\u0EA7\u0002\\u0EA9\u0002\\u0EA9\u0002\\u0EAC\u0002\\u0EAD\u0002\\u0EAF\u0002\\u0EBB\u0002\\u0EBD\u0002\\u0EBF\u0002\\u0EC2\u0002\\u0EC6\u0002\\u0EC8\u0002\\u0EC8\u0002\\u0ECA\u0002\\u0ECF\u0002\\u0ED2\u0002\\u0EDB\u0002\\u0EDE\u0002\\u0EE1\u0002\\u0F02\u0002\\u0F02\u0002\\u0F1A\u0002\\u0F1B\u0002\\u0F22\u0002\\u0F2B\u0002\\u0F37\u0002\\u0F37\u0002\\u0F39\u0002\\u0F39\u0002\\u0F3B\u0002\\u0F3B\u0002\\u0F40\u0002\\u0F49\u0002\\u0F4B\u0002\\u0F6E\u0002\\u0F73\u0002\\u0F86\u0002\\u0F88\u0002\\u0F99\u0002\\u0F9B\u0002\\u0FBE\u0002\\u0FC8\u0002\\u0FC8\u0002\\u1002\u0002\\u104B\u0002\\u1052\u0002\\u109F\u0002\\u10A2\u0002\\u10C7\u0002\\u10C9\u0002\\u10C9\u0002\\u10CF\u0002\\u10CF\u0002\\u10D2\u0002\\u10FC\u0002\\u10FE\u0002\\u124A\u0002\\u124C\u0002\\u124F\u0002\\u1252\u0002\\u1258\u0002\\u125A\u0002\\u125A\u0002\\u125C\u0002\\u125F\u0002\\u1262\u0002\\u128A\u0002\\u128C\u0002\\u128F\u0002\\u1292\u0002\\u12B2\u0002\\u12B4\u0002\\u12B7\u0002\\u12BA\u0002\\u12C0\u0002\\u12C2\u0002\\u12C2\u0002\\u12C4\u0002\\u12C7\u0002\\u12CA\u0002\\u12D8\u0002\\u12DA\u0002\\u1312\u0002\\u1314\u0002\\u1317\u0002\\u131A\u0002\\u135C\u0002\\u135F\u0002\\u1361\u0002\\u1382\u0002\\u1391\u0002\\u13A2\u0002\\u13F7\u0002\\u13FA\u0002\\u13FF\u0002\\u1403\u0002\\u166E\u0002\\u1671\u0002\\u1681\u0002\\u1683\u0002\\u169C\u0002\\u16A2\u0002\\u16EC\u0002\\u16F0\u0002\\u16FA\u0002\\u1702\u0002\\u170E\u0002\\u1710\u0002\\u1716\u0002\\u1722\u0002\\u1736\u0002\\u1742\u0002\\u1755\u0002\\u1762\u0002\\u176E\u0002\\u1770\u0002\\u1772\u0002\\u1774\u0002\\u1775\u0002\\u1782\u0002\\u17D5\u0002\\u17D9\u0002\\u17D9\u0002\\u17DE\u0002\\u17DF\u0002\\u17E2\u0002\\u17EB\u0002\\u180D\u0002\\u1810\u0002\\u1812\u0002\\u181B\u0002\\u1822\u0002\\u1879\u0002\\u1882\u0002\\u18AC\u0002\\u18B2\u0002\\u18F7\u0002\\u1902\u0002\\u1920\u0002\\u1922\u0002\\u192D\u0002\\u1932\u0002\\u193D\u0002\\u1948\u0002\\u196F\u0002\\u1972\u0002\\u1976\u0002\\u1982\u0002\\u19AD\u0002\\u19B2\u0002\\u19CB\u0002\\u19D2\u0002\\u19DB\u0002\\u1A02\u0002\\u1A1D\u0002\\u1A22\u0002\\u1A60\u0002\\u1A62\u0002\\u1A7E\u0002\\u1A81\u0002\\u1A8B\u0002\\u1A92\u0002\\u1A9B\u0002\\u1AA9\u0002\\u1AA9\u0002\\u1AB2\u0002\\u1ABF\u0002\\u1B02\u0002\\u1B4D\u0002\\u1B52\u0002\\u1B5B\u0002\\u1B6D\u0002\\u1B75\u0002\\u1B82\u0002\\u1BF5\u0002\\u1C02\u0002\\u1C39\u0002\\u1C42\u0002\\u1C4B\u0002\\u1C4F\u0002\\u1C7F\u0002\\u1C82\u0002\\u1C8A\u0002\\u1CD2\u0002\\u1CD4\u0002\\u1CD6\u0002\\u1CF8\u0002\\u1CFA\u0002\\u1CFB\u0002\\u1D02\u0002\\u1DF7\u0002\\u1DFD\u0002\\u1F17\u0002\\u1F1A\u0002\\u1F1F\u0002\\u1F22\u0002\\u1F47\u0002\\u1F4A\u0002\\u1F4F\u0002\\u1F52\u0002\\u1F59\u0002\\u1F5B\u0002\\u1F5B\u0002\\u1F5D\u0002\\u1F5D\u0002\\u1F5F\u0002\\u1F5F\u0002\\u1F61\u0002\\u1F7F\u0002\\u1F82\u0002\\u1FB6\u0002\\u1FB8\u0002\\u1FBE\u0002\\u1FC0\u0002\\u1FC0\u0002\\u1FC4\u0002\\u1FC6\u0002\\u1FC8\u0002\\u1FCE\u0002\\u1FD2\u0002\\u1FD5\u0002\\u1FD8\u0002\\u1FDD\u0002\\u1FE2\u0002\\u1FEE\u0002\\u1FF4\u0002\\u1FF6\u0002\\u1FF8\u0002\\u1FFE\u0002\\u200D\u0002\\u2011\u0002\\u202C\u0002\\u2030\u0002\\u2041\u0002\\u2042\u0002\\u2056\u0002\\u2056\u0002\\u2062\u0002\\u2066\u0002\\u2068\u0002\\u2071\u0002\\u2073\u0002\\u2073\u0002\\u2081\u0002\\u2081\u0002\\u2092\u0002\\u209E\u0002\\u20D2\u0002\\u20DE\u0002\\u20E3\u0002\\u20E3\u0002\\u20E7\u0002\\u20F2\u0002\\u2104\u0002\\u2104\u0002\\u2109\u0002\\u2109\u0002\\u210C\u0002\\u2115\u0002\\u2117\u0002\\u2117\u0002\\u211B\u0002\\u211F\u0002\\u2126\u0002\\u2126\u0002\\u2128\u0002\\u2128\u0002\\u212A\u0002\\u212A\u0002\\u212C\u0002\\u212F\u0002\\u2131\u0002\\u213B\u0002\\u213E\u0002\\u2141\u0002\\u2147\u0002\\u214B\u0002\\u2150\u0002\\u2150\u0002\\u2162\u0002\\u218A\u0002\\u2C02\u0002\\u2C30\u0002\\u2C32\u0002\\u2C60\u0002\\u2C62\u0002\\u2CE6\u0002\\u2CED\u0002\\u2CF5\u0002\\u2D02\u0002\\u2D27\u0002\\u2D29\u0002\\u2D29\u0002\\u2D2F\u0002\\u2D2F\u0002\\u2D32\u0002\\u2D69\u0002\\u2D71\u0002\\u2D71\u0002\\u2D81\u0002\\u2D98\u0002\\u2DA2\u0002\\u2DA8\u0002\\u2DAA\u0002\\u2DB0\u0002\\u2DB2\u0002\\u2DB8\u0002\\u2DBA\u0002\\u2DC0\u0002\\u2DC2\u0002\\u2DC8\u0002\\u2DCA\u0002\\u2DD0\u0002\\u2DD2\u0002\\u2DD8\u0002\\u2DDA\u0002\\u2DE0\u0002\\u2DE2\u0002\\u2E01\u0002\\u2E31\u0002\\u2E31\u0002\\u3007\u0002\\u3009\u0002\\u3023\u0002\\u3031\u0002\\u3033\u0002\\u3037\u0002\\u303A\u0002\\u303E\u0002\\u3043\u0002\\u3098\u0002\\u309B\u0002\\u309C\u0002\\u309F\u0002\\u30A1\u0002\\u30A3\u0002\\u30FC\u0002\\u30FE\u0002\\u3101\u0002\\u3107\u0002\\u312F\u0002\\u3133\u0002\\u3190\u0002\\u31A2\u0002\\u31BC\u0002\\u31F2\u0002\\u3201\u0002\\u3402\u0002\\u4DB7\u0002\\u4E02\u0002\\u9FD7\u0002\\uA002\u0002\\uA48E\u0002\\uA4D2\u0002\\uA4FF\u0002\\uA502\u0002\\uA60E\u0002\\uA612\u0002\\uA62D\u0002\\uA642\u0002\\uA671\u0002\\uA676\u0002\\uA67F\u0002\\uA681\u0002\\uA6F3\u0002\\uA719\u0002\\uA721\u0002\\uA724\u0002\\uA78A\u0002\\uA78D\u0002\\uA7B0\u0002\\uA7B2\u0002\\uA7B9\u0002\\uA7F9\u0002\\uA829\u0002\\uA842\u0002\\uA875\u0002\\uA882\u0002\\uA8C7\u0002\\uA8D2\u0002\\uA8DB\u0002\\uA8E2\u0002\\uA8F9\u0002\\uA8FD\u0002\\uA8FD\u0002\\uA8FF\u0002\\uA8FF\u0002\\uA902\u0002\\uA92F\u0002\\uA932\u0002\\uA955\u0002\\uA962\u0002\\uA97E\u0002\\uA982\u0002\\uA9C2\u0002\\uA9D1\u0002\\uA9DB\u0002\\uA9E2\u0002\\uAA00\u0002\\uAA02\u0002\\uAA38\u0002\\uAA42\u0002\\uAA4F\u0002\\uAA52\u0002\\uAA5B\u0002\\uAA62\u0002\\uAA78\u0002\\uAA7C\u0002\\uAAC4\u0002\\uAADD\u0002\\uAADF\u0002\\uAAE2\u0002\\uAAF1\u0002\\uAAF4\u0002\\uAAF8\u0002\\uAB03\u0002\\uAB08\u0002\\uAB0B\u0002\\uAB10\u0002\\uAB13\u0002\\uAB18\u0002\\uAB22\u0002\\uAB28\u0002\\uAB2A\u0002\\uAB30\u0002\\uAB32\u0002\\uAB5C\u0002\\uAB5E\u0002\\uAB67\u0002\\uAB72\u0002\\uABEC\u0002\\uABEE\u0002\\uABEF\u0002\\uABF2\u0002\\uABFB\u0002\\uAC02\u0002\\uD7A5\u0002\\uD7B2\u0002\\uD7C8\u0002\\uD7CD\u0002\\uD7FD\u0002\\uF902\u0002\\uFA6F\u0002\\uFA72\u0002\\uFADB\u0002\\uFB02\u0002\\uFB08\u0002\\uFB15\u0002\\uFB19\u0002\\uFB1F\u0002\\uFB2A\u0002\\uFB2C\u0002\\uFB38\u0002\\uFB3A\u0002\\uFB3E\u0002\\uFB40\u0002\\uFB40\u0002\\uFB42\u0002\\uFB43\u0002\\uFB45\u0002\\uFB46\u0002\\uFB48\u0002\\uFBB3\u0002\\uFBD5\u0002\\uFD3F\u0002\\uFD52\u0002\\uFD91\u0002\\uFD94\u0002\\uFDC9\u0002\\uFDF2\u0002\\uFDFD\u0002\\uFE02\u0002\\uFE11\u0002\\uFE22\u0002\\uFE31\u0002\\uFE35\u0002\\uFE36\u0002\\uFE4F\u0002\\uFE51\u0002\\uFE72\u0002\\uFE76\u0002\\uFE78\u0002\\uFEFE\u0002\\uFF01\u0002\\uFF01\u0002\\uFF12\u0002\\uFF1B\u0002\\uFF23\u0002\\uFF3C\u0002\\uFF41\u0002\\uFF41\u0002\\uFF43\u0002\\uFF5C\u0002\\uFF68\u0002\\uFFC0\u0002\\uFFC4\u0002\\uFFC9\u0002\\uFFCC\u0002\\uFFD1\u0002\\uFFD4\u0002\\uFFD9\u0002\\uFFDC\u0002\\uFFDE\u0002\\uFFFB\u0002\\uFFFD\u0002\u0002\u0003\\r\u0003\u000f\u0003(\u0003*\u0003<\u0003>\u0003?\u0003A\u0003O\u0003R\u0003_\u0003\\x82\u0003\\xFC\u0003\\u0142\u0003\\u0176\u0003\\u01FF\u0003\\u01FF\u0003\\u0282\u0003\\u029E\u0003\\u02A2\u0003\\u02D2\u0003\\u02E2\u0003\\u02E2\u0003\\u0302\u0003\\u0321\u0003\\u0332\u0003\\u034C\u0003\\u0352\u0003\\u037C\u0003\\u0382\u0003\\u039F\u0003\\u03A2\u0003\\u03C5\u0003\\u03CA\u0003\\u03D1\u0003\\u03D3\u0003\\u03D7\u0003\\u0402\u0003\\u049F\u0003\\u04A2\u0003\\u04AB\u0003\\u04B2\u0003\\u04D5\u0003\\u04DA\u0003\\u04FD\u0003\\u0502\u0003\\u0529\u0003\\u0532\u0003\\u0565\u0003\\u0602\u0003\\u0738\u0003\\u0742\u0003\\u0757\u0003\\u0762\u0003\\u0769\u0003\\u0802\u0003\\u0807\u0003\\u080A\u0003\\u080A\u0003\\u080C\u0003\\u0837\u0003\\u0839\u0003\\u083A\u0003\\u083E\u0003\\u083E\u0003\\u0841\u0003\\u0857\u0003\\u0862\u0003\\u0878\u0003\\u0882\u0003\\u08A0\u0003\\u08E2\u0003\\u08F4\u0003\\u08F6\u0003\\u08F7\u0003\\u0902\u0003\\u0917\u0003\\u0922\u0003\\u093B\u0003\\u0982\u0003\\u09B9\u0003\\u09C0\u0003\\u09C1\u0003\\u0A02\u0003\\u0A05\u0003\\u0A07\u0003\\u0A08\u0003\\u0A0E\u0003\\u0A15\u0003\\u0A17\u0003\\u0A19\u0003\\u0A1B\u0003\\u0A35\u0003\\u0A3A\u0003\\u0A3C\u0003\\u0A41\u0003\\u0A41\u0003\\u0A62\u0003\\u0A7E\u0003\\u0A82\u0003\\u0A9E\u0003\\u0AC2\u0003\\u0AC9\u0003\\u0ACB\u0003\\u0AE8\u0003\\u0B02\u0003\\u0B37\u0003\\u0B42\u0003\\u0B57\u0003\\u0B62\u0003\\u0B74\u0003\\u0B82\u0003\\u0B93\u0003\\u0C02\u0003\\u0C4A\u0003\\u0C82\u0003\\u0CB4\u0003\\u0CC2\u0003\\u0CF4\u0003\\u1002\u0003\\u1048\u0003\\u1068\u0003\\u1071\u0003\\u1081\u0003\\u10BC\u0003\\u10BF\u0003\\u10BF\u0003\\u10D2\u0003\\u10EA\u0003\\u10F2\u0003\\u10FB\u0003\\u1102\u0003\\u1136\u0003\\u1138\u0003\\u1141\u0003\\u1152\u0003\\u1175\u0003\\u1178\u0003\\u1178\u0003\\u1182\u0003\\u11C6\u0003\\u11CC\u0003\\u11CE\u0003\\u11D2\u0003\\u11DC\u0003\\u11DE\u0003\\u11DE\u0003\\u1202\u0003\\u1213\u0003\\u1215\u0003\\u1239\u0003\\u1240\u0003\\u1240\u0003\\u1282\u0003\\u1288\u0003\\u128A\u0003\\u128A\u0003\\u128C\u0003\\u128F\u0003\\u1291\u0003\\u129F\u0003\\u12A1\u0003\\u12AA\u0003\\u12B2\u0003\\u12EC\u0003\\u12F2\u0003\\u12FB\u0003\\u1302\u0003\\u1305\u0003\\u1307\u0003\\u130E\u0003\\u1311\u0003\\u1312\u0003\\u1315\u0003\\u132A\u0003\\u132C\u0003\\u1332\u0003\\u1334\u0003\\u1335\u0003\\u1337\u0003\\u133B\u0003\\u133E\u0003\\u1346\u0003\\u1349\u0003\\u134A\u0003\\u134D\u0003\\u134F\u0003\\u1352\u0003\\u1352\u0003\\u1359\u0003\\u1359\u0003\\u135F\u0003\\u1365\u0003\\u1368\u0003\\u136E\u0003\\u1372\u0003\\u1376\u0003\\u1402\u0003\\u144C\u0003\\u1452\u0003\\u145B\u0003\\u1482\u0003\\u14C7\u0003\\u14C9\u0003\\u14C9\u0003\\u14D2\u0003\\u14DB\u0003\\u1582\u0003\\u15B7\u0003\\u15BA\u0003\\u15C2\u0003\\u15DA\u0003\\u15DF\u0003\\u1602\u0003\\u1642\u0003\\u1646\u0003\\u1646\u0003\\u1652\u0003\\u165B\u0003\\u1682\u0003\\u16B9\u0003\\u16C2\u0003\\u16CB\u0003\\u1702\u0003\\u171B\u0003\\u171F\u0003\\u172D\u0003\\u1732\u0003\\u173B\u0003\\u18A2\u0003\\u18EB\u0003\\u1901\u0003\\u1901\u0003\\u1AC2\u0003\\u1AFA\u0003\\u1C02\u0003\\u1C0A\u0003\\u1C0C\u0003\\u1C38\u0003\\u1C3A\u0003\\u1C42\u0003\\u1C52\u0003\\u1C5B\u0003\\u1C74\u0003\\u1C91\u0003\\u1C94\u0003\\u1CA9\u0003\\u1CAB\u0003\\u1CB8\u0003\\u2002\u0003\\u239B\u0003\\u2402\u0003\\u2470\u0003\\u2482\u0003\\u2545\u0003\\u3002\u0003\\u3430\u0003\\u4402\u0003\\u4648\u0003\\u6802\u0003\\u6A3A\u0003\\u6A42\u0003\\u6A60\u0003\\u6A62\u0003\\u6A6B\u0003\\u6AD2\u0003\\u6AEF\u0003\\u6AF2\u0003\\u6AF6\u0003\\u6B02\u0003\\u6B38\u0003\\u6B42\u0003\\u6B45\u0003\\u6B52\u0003\\u6B5B\u0003\\u6B65\u0003\\u6B79\u0003\\u6B7F\u0003\\u6B91\u0003\\u6F02\u0003\\u6F46\u0003\\u6F52\u0003\\u6F80\u0003\\u6F91\u0003\\u6FA1\u0003\\u6FE2\u0003\\u6FE2\u0003\\u7002\u0003\\u87EE\u0003\\u8802\u0003\\u8AF4\u0003\\uB002\u0003\\uB003\u0003\\uBC02\u0003\\uBC6C\u0003\\uBC72\u0003\\uBC7E\u0003\\uBC82\u0003\\uBC8A\u0003\\uBC92\u0003\\uBC9B\u0003\\uBC9F\u0003\\uBCA0\u0003\\uBCA2\u0003\\uBCA5\u0003\\uD167\u0003\\uD16B\u0003\\uD16F\u0003\\uD184\u0003\\uD187\u0003\\uD18D\u0003\\uD1AC\u0003\\uD1AF\u0003\\uD244\u0003\\uD246\u0003\\uD402\u0003\\uD456\u0003\\uD458\u0003\\uD49E\u0003\\uD4A0\u0003\\uD4A1\u0003\\uD4A4\u0003\\uD4A4\u0003\\uD4A7\u0003\\uD4A8\u0003\\uD4AB\u0003\\uD4AE\u0003\\uD4B0\u0003\\uD4BB\u0003\\uD4BD\u0003\\uD4BD\u0003\\uD4BF\u0003\\uD4C5\u0003\\uD4C7\u0003\\uD507\u0003\\uD509\u0003\\uD50C\u0003\\uD50F\u0003\\uD516\u0003\\uD518\u0003\\uD51E\u0003\\uD520\u0003\\uD53B\u0003\\uD53D\u0003\\uD540\u0003\\uD542\u0003\\uD546\u0003\\uD548\u0003\\uD548\u0003\\uD54C\u0003\\uD552\u0003\\uD554\u0003\\uD6A7\u0003\\uD6AA\u0003\\uD6C2\u0003\\uD6C4\u0003\\uD6DC\u0003\\uD6DE\u0003\\uD6FC\u0003\\uD6FE\u0003\\uD716\u0003\\uD718\u0003\\uD736\u0003\\uD738\u0003\\uD750\u0003\\uD752\u0003\\uD770\u0003\\uD772\u0003\\uD78A\u0003\\uD78C\u0003\\uD7AA\u0003\\uD7AC\u0003\\uD7C4\u0003\\uD7C6\u0003\\uD7CD\u0003\\uD7D0\u0003\\uD801\u0003\\uDA02\u0003\\uDA38\u0003\\uDA3D\u0003\\uDA6E\u0003\\uDA77\u0003\\uDA77\u0003\\uDA86\u0003\\uDA86\u0003\\uDA9D\u0003\\uDAA1\u0003\\uDAA3\u0003\\uDAB1\u0003\\uE002\u0003\\uE008\u0003\\uE00A\u0003\\uE01A\u0003\\uE01D\u0003\\uE023\u0003\\uE025\u0003\\uE026\u0003\\uE028\u0003\\uE02C\u0003\\uE802\u0003\\uE8C6\u0003\\uE8D2\u0003\\uE8D8\u0003\\uE902\u0003\\uE94C\u0003\\uE952\u0003\\uE95B\u0003\\uEE02\u0003\\uEE05\u0003\\uEE07\u0003\\uEE21\u0003\\uEE23\u0003\\uEE24\u0003\\uEE26\u0003\\uEE26\u0003\\uEE29\u0003\\uEE29\u0003\\uEE2B\u0003\\uEE34\u0003\\uEE36\u0003\\uEE39\u0003\\uEE3B\u0003\\uEE3B\u0003\\uEE3D\u0003\\uEE3D\u0003\\uEE44\u0003\\uEE44\u0003\\uEE49\u0003\\uEE49\u0003\\uEE4B\u0003\\uEE4B\u0003\\uEE4D\u0003\\uEE4D\u0003\\uEE4F\u0003\\uEE51\u0003\\uEE53\u0003\\uEE54\u0003\\uEE56\u0003\\uEE56\u0003\\uEE59\u0003\\uEE59\u0003\\uEE5B\u0003\\uEE5B\u0003\\uEE5D\u0003\\uEE5D\u0003\\uEE5F\u0003\\uEE5F\u0003\\uEE61\u0003\\uEE61\u0003\\uEE63\u0003\\uEE64\u0003\\uEE66\u0003\\uEE66\u0003\\uEE69\u0003\\uEE6C\u0003\\uEE6E\u0003\\uEE74\u0003\\uEE76\u0003\\uEE79\u0003\\uEE7B\u0003\\uEE7E\u0003\\uEE80\u0003\\uEE80\u0003\\uEE82\u0003\\uEE8B\u0003\\uEE8D\u0003\\uEE9D\u0003\\uEEA3\u0003\\uEEA5\u0003\\uEEA7\u0003\\uEEAB\u0003\\uEEAD\u0003\\uEEBD\u0003\u0002\u0004\\uA6D8\u0004\\uA702\u0004\\uB736\u0004\\uB742\u0004\\uB81F\u0004\\uB822\u0004\\uCEA3\u0004\\uF802\u0004\\uFA1F\u0004\u0003\u0010\u0003\u0010\"\u0010\\x81\u0010\\u0102\u0010\\u01F1\u0010\\u0240\u0002C\u0002\\\\\u0002c\u0002|\u0002\\xAC\u0002\\xAC\u0002\\xB7\u0002\\xB7\u0002\\xBC\u0002\\xBC\u0002\\xC2\u0002\\xD8\u0002\\xDA\u0002\\xF8\u0002\\xFA\u0002\\u02C3\u0002\\u02C8\u0002\\u02D3\u0002\\u02E2\u0002\\u02E6\u0002\\u02EE\u0002\\u02EE\u0002\\u02F0\u0002\\u02F0\u0002\\u0372\u0002\\u0376\u0002\\u0378\u0002\\u0379\u0002\\u037C\u0002\\u037F\u0002\\u0381\u0002\\u0381\u0002\\u0388\u0002\\u0388\u0002\\u038A\u0002\\u038C\u0002\\u038E\u0002\\u038E\u0002\\u0390\u0002\\u03A3\u0002\\u03A5\u0002\\u03F7\u0002\\u03F9\u0002\\u0483\u0002\\u048C\u0002\\u0531\u0002\\u0533\u0002\\u0558\u0002\\u055B\u0002\\u055B\u0002\\u0563\u0002\\u0589\u0002\\u05D2\u0002\\u05EC\u0002\\u05F2\u0002\\u05F4\u0002\\u0622\u0002\\u064C\u0002\\u0670\u0002\\u0671\u0002\\u0673\u0002\\u06D5\u0002\\u06D7\u0002\\u06D7\u0002\\u06E7\u0002\\u06E8\u0002\\u06F0\u0002\\u06F1\u0002\\u06FC\u0002\\u06FE\u0002\\u0701\u0002\\u0701\u0002\\u0712\u0002\\u0712\u0002\\u0714\u0002\\u0731\u0002\\u074F\u0002\\u07A7\u0002\\u07B3\u0002\\u07B3\u0002\\u07CC\u0002\\u07EC\u0002\\u07F6\u0002\\u07F7\u0002\\u07FC\u0002\\u07FC\u0002\\u0802\u0002\\u0817\u0002\\u081C\u0002\\u081C\u0002\\u0826\u0002\\u0826\u0002\\u082A\u0002\\u082A\u0002\\u0842\u0002\\u085A\u0002\\u08A2\u0002\\u08B6\u0002\\u08B8\u0002\\u08BF\u0002\\u0906\u0002\\u093B\u0002\\u093F\u0002\\u093F\u0002\\u0952\u0002\\u0952\u0002\\u095A\u0002\\u0963\u0002\\u0973\u0002\\u0982\u0002\\u0987\u0002\\u098E\u0002\\u0991\u0002\\u0992\u0002\\u0995\u0002\\u09AA\u0002\\u09AC\u0002\\u09B2\u0002\\u09B4\u0002\\u09B4\u0002\\u09B8\u0002\\u09BB\u0002\\u09BF\u0002\\u09BF\u0002\\u09D0\u0002\\u09D0\u0002\\u09DE\u0002\\u09DF\u0002\\u09E1\u0002\\u09E3\u0002\\u09F2\u0002\\u09F3\u0002\\u0A07\u0002\\u0A0C\u0002\\u0A11\u0002\\u0A12\u0002\\u0A15\u0002\\u0A2A\u0002\\u0A2C\u0002\\u0A32\u0002\\u0A34\u0002\\u0A35\u0002\\u0A37\u0002\\u0A38\u0002\\u0A3A\u0002\\u0A3B\u0002\\u0A5B\u0002\\u0A5E\u0002\\u0A60\u0002\\u0A60\u0002\\u0A74\u0002\\u0A76\u0002\\u0A87\u0002\\u0A8F\u0002\\u0A91\u0002\\u0A93\u0002\\u0A95\u0002\\u0AAA\u0002\\u0AAC\u0002\\u0AB2\u0002\\u0AB4\u0002\\u0AB5\u0002\\u0AB7\u0002\\u0ABB\u0002\\u0ABF\u0002\\u0ABF\u0002\\u0AD2\u0002\\u0AD2\u0002\\u0AE2\u0002\\u0AE3\u0002\\u0AFB\u0002\\u0AFB\u0002\\u0B07\u0002\\u0B0E\u0002\\u0B11\u0002\\u0B12\u0002\\u0B15\u0002\\u0B2A\u0002\\u0B2C\u0002\\u0B32\u0002\\u0B34\u0002\\u0B35\u0002\\u0B37\u0002\\u0B3B\u0002\\u0B3F\u0002\\u0B3F\u0002\\u0B5E\u0002\\u0B5F\u0002\\u0B61\u0002\\u0B63\u0002\\u0B73\u0002\\u0B73\u0002\\u0B85\u0002\\u0B85\u0002\\u0B87\u0002\\u0B8C\u0002\\u0B90\u0002\\u0B92\u0002\\u0B94\u0002\\u0B97\u0002\\u0B9B\u0002\\u0B9C\u0002\\u0B9E\u0002\\u0B9E\u0002\\u0BA0\u0002\\u0BA1\u0002\\u0BA5\u0002\\u0BA6\u0002\\u0BAA\u0002\\u0BAC\u0002\\u0BB0\u0002\\u0BBB\u0002\\u0BD2\u0002\\u0BD2\u0002\\u0C07\u0002\\u0C0E\u0002\\u0C10\u0002\\u0C12\u0002\\u0C14\u0002\\u0C2A\u0002\\u0C2C\u0002\\u0C3B\u0002\\u0C3F\u0002\\u0C3F\u0002\\u0C5A\u0002\\u0C5C\u0002\\u0C62\u0002\\u0C63\u0002\\u0C82\u0002\\u0C82\u0002\\u0C87\u0002\\u0C8E\u0002\\u0C90\u0002\\u0C92\u0002\\u0C94\u0002\\u0CAA\u0002\\u0CAC\u0002\\u0CB5\u0002\\u0CB7\u0002\\u0CBB\u0002\\u0CBF\u0002\\u0CBF\u0002\\u0CE0\u0002\\u0CE0\u0002\\u0CE2\u0002\\u0CE3\u0002\\u0CF3\u0002\\u0CF4\u0002\\u0D07\u0002\\u0D0E\u0002\\u0D10\u0002\\u0D12\u0002\\u0D14\u0002\\u0D3C\u0002\\u0D3F\u0002\\u0D3F\u0002\\u0D50\u0002\\u0D50\u0002\\u0D56\u0002\\u0D58\u0002\\u0D61\u0002\\u0D63\u0002\\u0D7C\u0002\\u0D81\u0002\\u0D87\u0002\\u0D98\u0002\\u0D9C\u0002\\u0DB3\u0002\\u0DB5\u0002\\u0DBD\u0002\\u0DBF\u0002\\u0DBF\u0002\\u0DC2\u0002\\u0DC8\u0002\\u0E03\u0002\\u0E32\u0002\\u0E34\u0002\\u0E35\u0002\\u0E42\u0002\\u0E48\u0002\\u0E83\u0002\\u0E84\u0002\\u0E86\u0002\\u0E86\u0002\\u0E89\u0002\\u0E8A\u0002\\u0E8C\u0002\\u0E8C\u0002\\u0E8F\u0002\\u0E8F\u0002\\u0E96\u0002\\u0E99\u0002\\u0E9B\u0002\\u0EA1\u0002\\u0EA3\u0002\\u0EA5\u0002\\u0EA7\u0002\\u0EA7\u0002\\u0EA9\u0002\\u0EA9\u0002\\u0EAC\u0002\\u0EAD\u0002\\u0EAF\u0002\\u0EB2\u0002\\u0EB4\u0002\\u0EB5\u0002\\u0EBF\u0002\\u0EBF\u0002\\u0EC2\u0002\\u0EC6\u0002\\u0EC8\u0002\\u0EC8\u0002\\u0EDE\u0002\\u0EE1\u0002\\u0F02\u0002\\u0F02\u0002\\u0F42\u0002\\u0F49\u0002\\u0F4B\u0002\\u0F6E\u0002\\u0F8A\u0002\\u0F8E\u0002\\u1002\u0002\\u102C\u0002\\u1041\u0002\\u1041\u0002\\u1052\u0002\\u1057\u0002\\u105C\u0002\\u105F\u0002\\u1063\u0002\\u1063\u0002\\u1067\u0002\\u1068\u0002\\u1070\u0002\\u1072\u0002\\u1077\u0002\\u1083\u0002\\u1090\u0002\\u1090\u0002\\u10A2\u0002\\u10C7\u0002\\u10C9\u0002\\u10C9\u0002\\u10CF\u0002\\u10CF\u0002\\u10D2\u0002\\u10FC\u0002\\u10FE\u0002\\u124A\u0002\\u124C\u0002\\u124F\u0002\\u1252\u0002\\u1258\u0002\\u125A\u0002\\u125A\u0002\\u125C\u0002\\u125F\u0002\\u1262\u0002\\u128A\u0002\\u128C\u0002\\u128F\u0002\\u1292\u0002\\u12B2\u0002\\u12B4\u0002\\u12B7\u0002\\u12BA\u0002\\u12C0\u0002\\u12C2\u0002\\u12C2\u0002\\u12C4\u0002\\u12C7\u0002\\u12CA\u0002\\u12D8\u0002\\u12DA\u0002\\u1312\u0002\\u1314\u0002\\u1317\u0002\\u131A\u0002\\u135C\u0002\\u1382\u0002\\u1391\u0002\\u13A2\u0002\\u13F7\u0002\\u13FA\u0002\\u13FF\u0002\\u1403\u0002\\u166E\u0002\\u1671\u0002\\u1681\u0002\\u1683\u0002\\u169C\u0002\\u16A2\u0002\\u16EC\u0002\\u16F0\u0002\\u16FA\u0002\\u1702\u0002\\u170E\u0002\\u1710\u0002\\u1713\u0002\\u1722\u0002\\u1733\u0002\\u1742\u0002\\u1753\u0002\\u1762\u0002\\u176E\u0002\\u1770\u0002\\u1772\u0002\\u1782\u0002\\u17B5\u0002\\u17D9\u0002\\u17D9\u0002\\u17DE\u0002\\u17DE\u0002\\u1822\u0002\\u1879\u0002\\u1882\u0002\\u1886\u0002\\u1889\u0002\\u18AA\u0002\\u18AC\u0002\\u18AC\u0002\\u18B2\u0002\\u18F7\u0002\\u1902\u0002\\u1920\u0002\\u1952\u0002\\u196F\u0002\\u1972\u0002\\u1976\u0002\\u1982\u0002\\u19AD\u0002\\u19B2\u0002\\u19CB\u0002\\u1A02\u0002\\u1A18\u0002\\u1A22\u0002\\u1A56\u0002\\u1AA9\u0002\\u1AA9\u0002\\u1B07\u0002\\u1B35\u0002\\u1B47\u0002\\u1B4D\u0002\\u1B85\u0002\\u1BA2\u0002\\u1BB0\u0002\\u1BB1\u0002\\u1BBC\u0002\\u1BE7\u0002\\u1C02\u0002\\u1C25\u0002\\u1C4F\u0002\\u1C51\u0002\\u1C5C\u0002\\u1C7F\u0002\\u1C82\u0002\\u1C8A\u0002\\u1CEB\u0002\\u1CEE\u0002\\u1CF0\u0002\\u1CF3\u0002\\u1CF7\u0002\\u1CF8\u0002\\u1D02\u0002\\u1DC1\u0002\\u1E02\u0002\\u1F17\u0002\\u1F1A\u0002\\u1F1F\u0002\\u1F22\u0002\\u1F47\u0002\\u1F4A\u0002\\u1F4F\u0002\\u1F52\u0002\\u1F59\u0002\\u1F5B\u0002\\u1F5B\u0002\\u1F5D\u0002\\u1F5D\u0002\\u1F5F\u0002\\u1F5F\u0002\\u1F61\u0002\\u1F7F\u0002\\u1F82\u0002\\u1FB6\u0002\\u1FB8\u0002\\u1FBE\u0002\\u1FC0\u0002\\u1FC0\u0002\\u1FC4\u0002\\u1FC6\u0002\\u1FC8\u0002\\u1FCE\u0002\\u1FD2\u0002\\u1FD5\u0002\\u1FD8\u0002\\u1FDD\u0002\\u1FE2\u0002\\u1FEE\u0002\\u1FF4\u0002\\u1FF6\u0002\\u1FF8\u0002\\u1FFE\u0002\\u2073\u0002\\u2073\u0002\\u2081\u0002\\u2081\u0002\\u2092\u0002\\u209E\u0002\\u2104\u0002\\u2104\u0002\\u2109\u0002\\u2109\u0002\\u210C\u0002\\u2115\u0002\\u2117\u0002\\u2117\u0002\\u211B\u0002\\u211F\u0002\\u2126\u0002\\u2126\u0002\\u2128\u0002\\u2128\u0002\\u212A\u0002\\u212A\u0002\\u212C\u0002\\u212F\u0002\\u2131\u0002\\u213B\u0002\\u213E\u0002\\u2141\u0002\\u2147\u0002\\u214B\u0002\\u2150\u0002\\u2150\u0002\\u2162\u0002\\u218A\u0002\\u2C02\u0002\\u2C30\u0002\\u2C32\u0002\\u2C60\u0002\\u2C62\u0002\\u2CE6\u0002\\u2CED\u0002\\u2CF0\u0002\\u2CF4\u0002\\u2CF5\u0002\\u2D02\u0002\\u2D27\u0002\\u2D29\u0002\\u2D29\u0002\\u2D2F\u0002\\u2D2F\u0002\\u2D32\u0002\\u2D69\u0002\\u2D71\u0002\\u2D71\u0002\\u2D82\u0002\\u2D98\u0002\\u2DA2\u0002\\u2DA8\u0002\\u2DAA\u0002\\u2DB0\u0002\\u2DB2\u0002\\u2DB8\u0002\\u2DBA\u0002\\u2DC0\u0002\\u2DC2\u0002\\u2DC8\u0002\\u2DCA\u0002\\u2DD0\u0002\\u2DD2\u0002\\u2DD8\u0002\\u2DDA\u0002\\u2DE0\u0002\\u2E31\u0002\\u2E31\u0002\\u3007\u0002\\u3009\u0002\\u3023\u0002\\u302B\u0002\\u3033\u0002\\u3037\u0002\\u303A\u0002\\u303E\u0002\\u3043\u0002\\u3098\u0002\\u309F\u0002\\u30A1\u0002\\u30A3\u0002\\u30FC\u0002\\u30FE\u0002\\u3101\u0002\\u3107\u0002\\u312F\u0002\\u3133\u0002\\u3190\u0002\\u31A2\u0002\\u31BC\u0002\\u31F2\u0002\\u3201\u0002\\u3402\u0002\\u4DB7\u0002\\u4E02\u0002\\u9FD7\u0002\\uA002\u0002\\uA48E\u0002\\uA4D2\u0002\\uA4FF\u0002\\uA502\u0002\\uA60E\u0002\\uA612\u0002\\uA621\u0002\\uA62C\u0002\\uA62D\u0002\\uA642\u0002\\uA670\u0002\\uA681\u0002\\uA69F\u0002\\uA6A2\u0002\\uA6F1\u0002\\uA719\u0002\\uA721\u0002\\uA724\u0002\\uA78A\u0002\\uA78D\u0002\\uA7B0\u0002\\uA7B2\u0002\\uA7B9\u0002\\uA7F9\u0002\\uA803\u0002\\uA805\u0002\\uA807\u0002\\uA809\u0002\\uA80C\u0002\\uA80E\u0002\\uA824\u0002\\uA842\u0002\\uA875\u0002\\uA884\u0002\\uA8B5\u0002\\uA8F4\u0002\\uA8F9\u0002\\uA8FD\u0002\\uA8FD\u0002\\uA8FF\u0002\\uA8FF\u0002\\uA90C\u0002\\uA927\u0002\\uA932\u0002\\uA948\u0002\\uA962\u0002\\uA97E\u0002\\uA986\u0002\\uA9B4\u0002\\uA9D1\u0002\\uA9D1\u0002\\uA9E2\u0002\\uA9E6\u0002\\uA9E8\u0002\\uA9F1\u0002\\uA9FC\u0002\\uAA00\u0002\\uAA02\u0002\\uAA2A\u0002\\uAA42\u0002\\uAA44\u0002\\uAA46\u0002\\uAA4D\u0002\\uAA62\u0002\\uAA78\u0002\\uAA7C\u0002\\uAA7C\u0002\\uAA80\u0002\\uAAB1\u0002\\uAAB3\u0002\\uAAB3\u0002\\uAAB7\u0002\\uAAB8\u0002\\uAABB\u0002\\uAABF\u0002\\uAAC2\u0002\\uAAC2\u0002\\uAAC4\u0002\\uAAC4\u0002\\uAADD\u0002\\uAADF\u0002\\uAAE2\u0002\\uAAEC\u0002\\uAAF4\u0002\\uAAF6\u0002\\uAB03\u0002\\uAB08\u0002\\uAB0B\u0002\\uAB10\u0002\\uAB13\u0002\\uAB18\u0002\\uAB22\u0002\\uAB28\u0002\\uAB2A\u0002\\uAB30\u0002\\uAB32\u0002\\uAB5C\u0002\\uAB5E\u0002\\uAB67\u0002\\uAB72\u0002\\uABE4\u0002\\uAC02\u0002\\uD7A5\u0002\\uD7B2\u0002\\uD7C8\u0002\\uD7CD\u0002\\uD7FD\u0002\\uF902\u0002\\uFA6F\u0002\\uFA72\u0002\\uFADB\u0002\\uFB02\u0002\\uFB08\u0002\\uFB15\u0002\\uFB19\u0002\\uFB1F\u0002\\uFB1F\u0002\\uFB21\u0002\\uFB2A\u0002\\uFB2C\u0002\\uFB38\u0002\\uFB3A\u0002\\uFB3E\u0002\\uFB40\u0002\\uFB40\u0002\\uFB42\u0002\\uFB43\u0002\\uFB45\u0002\\uFB46\u0002\\uFB48\u0002\\uFBB3\u0002\\uFBD5\u0002\\uFD3F\u0002\\uFD52\u0002\\uFD91\u0002\\uFD94\u0002\\uFDC9\u0002\\uFDF2\u0002\\uFDFD\u0002\\uFE72\u0002\\uFE76\u0002\\uFE78\u0002\\uFEFE\u0002\\uFF23\u0002\\uFF3C\u0002\\uFF43\u0002\\uFF5C\u0002\\uFF68\u0002\\uFFC0\u0002\\uFFC4\u0002\\uFFC9\u0002\\uFFCC\u0002\\uFFD1\u0002\\uFFD4\u0002\\uFFD9\u0002\\uFFDC\u0002\\uFFDE\u0002\u0002\u0003\\r\u0003\u000f\u0003(\u0003*\u0003<\u0003>\u0003?\u0003A\u0003O\u0003R\u0003_\u0003\\x82\u0003\\xFC\u0003\\u0142\u0003\\u0176\u0003\\u0282\u0003\\u029E\u0003\\u02A2\u0003\\u02D2\u0003\\u0302\u0003\\u0321\u0003\\u0332\u0003\\u034C\u0003\\u0352\u0003\\u0377\u0003\\u0382\u0003\\u039F\u0003\\u03A2\u0003\\u03C5\u0003\\u03CA\u0003\\u03D1\u0003\\u03D3\u0003\\u03D7\u0003\\u0402\u0003\\u049F\u0003\\u04B2\u0003\\u04D5\u0003\\u04DA\u0003\\u04FD\u0003\\u0502\u0003\\u0529\u0003\\u0532\u0003\\u0565\u0003\\u0602\u0003\\u0738\u0003\\u0742\u0003\\u0757\u0003\\u0762\u0003\\u0769\u0003\\u0802\u0003\\u0807\u0003\\u080A\u0003\\u080A\u0003\\u080C\u0003\\u0837\u0003\\u0839\u0003\\u083A\u0003\\u083E\u0003\\u083E\u0003\\u0841\u0003\\u0857\u0003\\u0862\u0003\\u0878\u0003\\u0882\u0003\\u08A0\u0003\\u08E2\u0003\\u08F4\u0003\\u08F6\u0003\\u08F7\u0003\\u0902\u0003\\u0917\u0003\\u0922\u0003\\u093B\u0003\\u0982\u0003\\u09B9\u0003\\u09C0\u0003\\u09C1\u0003\\u0A02\u0003\\u0A02\u0003\\u0A12\u0003\\u0A15\u0003\\u0A17\u0003\\u0A19\u0003\\u0A1B\u0003\\u0A35\u0003\\u0A62\u0003\\u0A7E\u0003\\u0A82\u0003\\u0A9E\u0003\\u0AC2\u0003\\u0AC9\u0003\\u0ACB\u0003\\u0AE6\u0003\\u0B02\u0003\\u0B37\u0003\\u0B42\u0003\\u0B57\u0003\\u0B62\u0003\\u0B74\u0003\\u0B82\u0003\\u0B93\u0003\\u0C02\u0003\\u0C4A\u0003\\u0C82\u0003\\u0CB4\u0003\\u0CC2\u0003\\u0CF4\u0003\\u1005\u0003\\u1039\u0003\\u1085\u0003\\u10B1\u0003\\u10D2\u0003\\u10EA\u0003\\u1105\u0003\\u1128\u0003\\u1152\u0003\\u1174\u0003\\u1178\u0003\\u1178\u0003\\u1185\u0003\\u11B4\u0003\\u11C3\u0003\\u11C6\u0003\\u11DC\u0003\\u11DC\u0003\\u11DE\u0003\\u11DE\u0003\\u1202\u0003\\u1213\u0003\\u1215\u0003\\u122D\u0003\\u1282\u0003\\u1288\u0003\\u128A\u0003\\u128A\u0003\\u128C\u0003\\u128F\u0003\\u1291\u0003\\u129F\u0003\\u12A1\u0003\\u12AA\u0003\\u12B2\u0003\\u12E0\u0003\\u1307\u0003\\u130E\u0003\\u1311\u0003\\u1312\u0003\\u1315\u0003\\u132A\u0003\\u132C\u0003\\u1332\u0003\\u1334\u0003\\u1335\u0003\\u1337\u0003\\u133B\u0003\\u133F\u0003\\u133F\u0003\\u1352\u0003\\u1352\u0003\\u135F\u0003\\u1363\u0003\\u1402\u0003\\u1436\u0003\\u1449\u0003\\u144C\u0003\\u1482\u0003\\u14B1\u0003\\u14C6\u0003\\u14C7\u0003\\u14C9\u0003\\u14C9\u0003\\u1582\u0003\\u15B0\u0003\\u15DA\u0003\\u15DD\u0003\\u1602\u0003\\u1631\u0003\\u1646\u0003\\u1646\u0003\\u1682\u0003\\u16AC\u0003\\u1702\u0003\\u171B\u0003\\u18A2\u0003\\u18E1\u0003\\u1901\u0003\\u1901\u0003\\u1AC2\u0003\\u1AFA\u0003\\u1C02\u0003\\u1C0A\u0003\\u1C0C\u0003\\u1C30\u0003\\u1C42\u0003\\u1C42\u0003\\u1C74\u0003\\u1C91\u0003\\u2002\u0003\\u239B\u0003\\u2402\u0003\\u2470\u0003\\u2482\u0003\\u2545\u0003\\u3002\u0003\\u3430\u0003\\u4402\u0003\\u4648\u0003\\u6802\u0003\\u6A3A\u0003\\u6A42\u0003\\u6A60\u0003\\u6AD2\u0003\\u6AEF\u0003\\u6B02\u0003\\u6B31\u0003\\u6B42\u0003\\u6B45\u0003\\u6B65\u0003\\u6B79\u0003\\u6B7F\u0003\\u6B91\u0003\\u6F02\u0003\\u6F46\u0003\\u6F52\u0003\\u6F52\u0003\\u6F95\u0003\\u6FA1\u0003\\u6FE2\u0003\\u6FE2\u0003\\u7002\u0003\\u87EE\u0003\\u8802\u0003\\u8AF4\u0003\\uB002\u0003\\uB003\u0003\\uBC02\u0003\\uBC6C\u0003\\uBC72\u0003\\uBC7E\u0003\\uBC82\u0003\\uBC8A\u0003\\uBC92\u0003\\uBC9B\u0003\\uD402\u0003\\uD456\u0003\\uD458\u0003\\uD49E\u0003\\uD4A0\u0003\\uD4A1\u0003\\uD4A4\u0003\\uD4A4\u0003\\uD4A7\u0003\\uD4A8\u0003\\uD4AB\u0003\\uD4AE\u0003\\uD4B0\u0003\\uD4BB\u0003\\uD4BD\u0003\\uD4BD\u0003\\uD4BF\u0003\\uD4C5\u0003\\uD4C7\u0003\\uD507\u0003\\uD509\u0003\\uD50C\u0003\\uD50F\u0003\\uD516\u0003\\uD518\u0003\\uD51E\u0003\\uD520\u0003\\uD53B\u0003\\uD53D\u0003\\uD540\u0003\\uD542\u0003\\uD546\u0003\\uD548\u0003\\uD548';\n  XPathLexer._serializedATNSegment1 = `\u0003\\uD54C\u0003\\uD552\u0003\\uD554\u0003\\uD6A7\u0003\\uD6AA\u0003\\uD6C2\u0003\\uD6C4\u0003\\uD6DC\u0003\\uD6DE\u0003\\uD6FC\u0003\\uD6FE\u0003\\uD716\u0003\\uD718\u0003\\uD736\u0003\\uD738\u0003\\uD750\u0003\\uD752\u0003\\uD770\u0003\\uD772\u0003\\uD78A\u0003\\uD78C\u0003\\uD7AA\u0003\\uD7AC\u0003\\uD7C4\u0003\\uD7C6\u0003\\uD7CD\u0003\\uE802\u0003\\uE8C6\u0003\\uE902\u0003\\uE945\u0003\\uEE02\u0003\\uEE05\u0003\\uEE07\u0003\\uEE21\u0003\\uEE23\u0003\\uEE24\u0003\\uEE26\u0003\\uEE26\u0003\\uEE29\u0003\\uEE29\u0003\\uEE2B\u0003\\uEE34\u0003\\uEE36\u0003\\uEE39\u0003\\uEE3B\u0003\\uEE3B\u0003\\uEE3D\u0003\\uEE3D\u0003\\uEE44\u0003\\uEE44\u0003\\uEE49\u0003\\uEE49\u0003\\uEE4B\u0003\\uEE4B\u0003\\uEE4D\u0003\\uEE4D\u0003\\uEE4F\u0003\\uEE51\u0003\\uEE53\u0003\\uEE54\u0003\\uEE56\u0003\\uEE56\u0003\\uEE59\u0003\\uEE59\u0003\\uEE5B\u0003\\uEE5B\u0003\\uEE5D\u0003\\uEE5D\u0003\\uEE5F\u0003\\uEE5F\u0003\\uEE61\u0003\\uEE61\u0003\\uEE63\u0003\\uEE64\u0003\\uEE66\u0003\\uEE66\u0003\\uEE69\u0003\\uEE6C\u0003\\uEE6E\u0003\\uEE74\u0003\\uEE76\u0003\\uEE79\u0003\\uEE7B\u0003\\uEE7E\u0003\\uEE80\u0003\\uEE80\u0003\\uEE82\u0003\\uEE8B\u0003\\uEE8D\u0003\\uEE9D\u0003\\uEEA3\u0003\\uEEA5\u0003\\uEEA7\u0003\\uEEAB\u0003\\uEEAD\u0003\\uEEBD\u0003\u0002\u0004\\uA6D8\u0004\\uA702\u0004\\uB736\u0004\\uB742\u0004\\uB81F\u0004\\uB822\u0004\\uCEA3\u0004\\uF802\u0004\\uFA1F\u00041\u0002\u0003\u0003\u0002\u0002\u0002\u0002\u0005\u0003\u0002\u0002\u0002\u0002\\x07\u0003\u0002\u0002\u0002\u0002\t\u0003\u0002\u0002\u0002\u0002\\v\u0003\u0002\u0002\u0002\u0002\u0011\u0003\u0002\u0002\u0002\u0003\u0013\u0003\u0002\u0002\u0002\u0005\u0016\u0003\u0002\u0002\u0002\\x07\u0018\u0003\u0002\u0002\u0002\t\u001a\u0003\u0002\u0002\u0002\\v\u001c\u0003\u0002\u0002\u0002\\r%\u0003\u0002\u0002\u0002\u000f'\u0003\u0002\u0002\u0002\u0011)\u0003\u0002\u0002\u0002\u0013\u0014\\x071\u0002\u0002\u0014\u0015\\x071\u0002\u0002\u0015\u0004\u0003\u0002\u0002\u0002\u0016\u0017\\x071\u0002\u0002\u0017\u0006\u0003\u0002\u0002\u0002\u0018\u0019\\x07,\u0002\u0002\u0019\\b\u0003\u0002\u0002\u0002\u001a\u001b\\x07#\u0002\u0002\u001b\n\u0003\u0002\u0002\u0002\u001c \u0005\u000f\\b\u0002\u001d\u001f\u0005\\r\\x07\u0002\u001e\u001d\u0003\u0002\u0002\u0002\u001f\"\u0003\u0002\u0002\u0002 \u001e\u0003\u0002\u0002\u0002 !\u0003\u0002\u0002\u0002!#\u0003\u0002\u0002\u0002\" \u0003\u0002\u0002\u0002#$\\b\u0006\u0002\u0002$\\f\u0003\u0002\u0002\u0002%&\t\u0002\u0002\u0002&\u000e\u0003\u0002\u0002\u0002'(\t\u0003\u0002\u0002(\u0010\u0003\u0002\u0002\u0002)-\\x07)\u0002\u0002*,\\v\u0002\u0002\u0002+*\u0003\u0002\u0002\u0002,/\u0003\u0002\u0002\u0002-.\u0003\u0002\u0002\u0002-+\u0003\u0002\u0002\u0002.0\u0003\u0002\u0002\u0002/-\u0003\u0002\u0002\u000201\\x07)\u0002\u00021\u0012\u0003\u0002\u0002\u0002\u0005\u0002 -\u0003\u0003\u0006\u0002`;\n  XPathLexer._serializedATN = Utils3.join([\n    XPathLexer._serializedATNSegment0,\n    XPathLexer._serializedATNSegment1\n  ], \"\");\n});\n\n// node_modules/antlr4ts/tree/xpath/XPathLexerErrorListener.js\nvar require_XPathLexerErrorListener = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.XPathLexerErrorListener = void 0;\n  var Decorators_1 = require_Decorators();\n  var XPathLexerErrorListener = class {\n    syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], XPathLexerErrorListener.prototype, \"syntaxError\", null);\n  exports.XPathLexerErrorListener = XPathLexerErrorListener;\n});\n\n// node_modules/antlr4ts/tree/xpath/XPathElement.js\nvar require_XPathElement = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.XPathElement = void 0;\n  var Decorators_1 = require_Decorators();\n  var XPathElement = class {\n    constructor(nodeName) {\n      this.nodeName = nodeName;\n      this.invert = false;\n    }\n    toString() {\n      let inv = this.invert ? \"!\" : \"\";\n      let className = Object.constructor.name;\n      return className + \"[\" + inv + this.nodeName + \"]\";\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], XPathElement.prototype, \"toString\", null);\n  exports.XPathElement = XPathElement;\n});\n\n// node_modules/antlr4ts/tree/xpath/XPathRuleAnywhereElement.js\nvar require_XPathRuleAnywhereElement = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.XPathRuleAnywhereElement = void 0;\n  var Decorators_1 = require_Decorators();\n  var Trees_1 = require_Trees();\n  var XPathElement_1 = require_XPathElement();\n  var XPathRuleAnywhereElement = class extends XPathElement_1.XPathElement {\n    constructor(ruleName, ruleIndex) {\n      super(ruleName);\n      this.ruleIndex = ruleIndex;\n    }\n    evaluate(t) {\n      return Trees_1.Trees.findAllRuleNodes(t, this.ruleIndex);\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], XPathRuleAnywhereElement.prototype, \"evaluate\", null);\n  exports.XPathRuleAnywhereElement = XPathRuleAnywhereElement;\n});\n\n// node_modules/antlr4ts/tree/xpath/XPathRuleElement.js\nvar require_XPathRuleElement = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.XPathRuleElement = void 0;\n  var ParserRuleContext_1 = require_ParserRuleContext();\n  var Decorators_1 = require_Decorators();\n  var Trees_1 = require_Trees();\n  var XPathElement_1 = require_XPathElement();\n  var XPathRuleElement = class extends XPathElement_1.XPathElement {\n    constructor(ruleName, ruleIndex) {\n      super(ruleName);\n      this.ruleIndex = ruleIndex;\n    }\n    evaluate(t) {\n      let nodes = [];\n      for (let c of Trees_1.Trees.getChildren(t)) {\n        if (c instanceof ParserRuleContext_1.ParserRuleContext) {\n          if (c.ruleIndex === this.ruleIndex && !this.invert || c.ruleIndex !== this.ruleIndex && this.invert) {\n            nodes.push(c);\n          }\n        }\n      }\n      return nodes;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], XPathRuleElement.prototype, \"evaluate\", null);\n  exports.XPathRuleElement = XPathRuleElement;\n});\n\n// node_modules/antlr4ts/tree/xpath/XPathTokenAnywhereElement.js\nvar require_XPathTokenAnywhereElement = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.XPathTokenAnywhereElement = void 0;\n  var Decorators_1 = require_Decorators();\n  var Trees_1 = require_Trees();\n  var XPathElement_1 = require_XPathElement();\n  var XPathTokenAnywhereElement = class extends XPathElement_1.XPathElement {\n    constructor(tokenName, tokenType) {\n      super(tokenName);\n      this.tokenType = tokenType;\n    }\n    evaluate(t) {\n      return Trees_1.Trees.findAllTokenNodes(t, this.tokenType);\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], XPathTokenAnywhereElement.prototype, \"evaluate\", null);\n  exports.XPathTokenAnywhereElement = XPathTokenAnywhereElement;\n});\n\n// node_modules/antlr4ts/tree/xpath/XPathTokenElement.js\nvar require_XPathTokenElement = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.XPathTokenElement = void 0;\n  var Decorators_1 = require_Decorators();\n  var TerminalNode_1 = require_TerminalNode();\n  var Trees_1 = require_Trees();\n  var XPathElement_1 = require_XPathElement();\n  var XPathTokenElement = class extends XPathElement_1.XPathElement {\n    constructor(tokenName, tokenType) {\n      super(tokenName);\n      this.tokenType = tokenType;\n    }\n    evaluate(t) {\n      let nodes = [];\n      for (let c of Trees_1.Trees.getChildren(t)) {\n        if (c instanceof TerminalNode_1.TerminalNode) {\n          if (c.symbol.type === this.tokenType && !this.invert || c.symbol.type !== this.tokenType && this.invert) {\n            nodes.push(c);\n          }\n        }\n      }\n      return nodes;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], XPathTokenElement.prototype, \"evaluate\", null);\n  exports.XPathTokenElement = XPathTokenElement;\n});\n\n// node_modules/antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js\nvar require_XPathWildcardAnywhereElement = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.XPathWildcardAnywhereElement = void 0;\n  var Decorators_1 = require_Decorators();\n  var Trees_1 = require_Trees();\n  var XPath_1 = require_XPath();\n  var XPathElement_1 = require_XPathElement();\n  var XPathWildcardAnywhereElement = class extends XPathElement_1.XPathElement {\n    constructor() {\n      super(XPath_1.XPath.WILDCARD);\n    }\n    evaluate(t) {\n      if (this.invert) {\n        return [];\n      }\n      return Trees_1.Trees.getDescendants(t);\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], XPathWildcardAnywhereElement.prototype, \"evaluate\", null);\n  exports.XPathWildcardAnywhereElement = XPathWildcardAnywhereElement;\n});\n\n// node_modules/antlr4ts/tree/xpath/XPathWildcardElement.js\nvar require_XPathWildcardElement = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.XPathWildcardElement = void 0;\n  var Decorators_1 = require_Decorators();\n  var Trees_1 = require_Trees();\n  var XPath_1 = require_XPath();\n  var XPathElement_1 = require_XPathElement();\n  var XPathWildcardElement = class extends XPathElement_1.XPathElement {\n    constructor() {\n      super(XPath_1.XPath.WILDCARD);\n    }\n    evaluate(t) {\n      let kids = [];\n      if (this.invert) {\n        return kids;\n      }\n      for (let c of Trees_1.Trees.getChildren(t)) {\n        kids.push(c);\n      }\n      return kids;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], XPathWildcardElement.prototype, \"evaluate\", null);\n  exports.XPathWildcardElement = XPathWildcardElement;\n});\n\n// node_modules/antlr4ts/tree/xpath/XPath.js\nvar require_XPath = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.XPath = void 0;\n  var CharStreams_1 = require_CharStreams();\n  var CommonTokenStream_1 = require_CommonTokenStream();\n  var LexerNoViableAltException_1 = require_LexerNoViableAltException();\n  var ParserRuleContext_1 = require_ParserRuleContext();\n  var Token_1 = require_Token();\n  var XPathLexer_1 = require_XPathLexer();\n  var XPathLexerErrorListener_1 = require_XPathLexerErrorListener();\n  var XPathRuleAnywhereElement_1 = require_XPathRuleAnywhereElement();\n  var XPathRuleElement_1 = require_XPathRuleElement();\n  var XPathTokenAnywhereElement_1 = require_XPathTokenAnywhereElement();\n  var XPathTokenElement_1 = require_XPathTokenElement();\n  var XPathWildcardAnywhereElement_1 = require_XPathWildcardAnywhereElement();\n  var XPathWildcardElement_1 = require_XPathWildcardElement();\n  var XPath = class {\n    constructor(parser, path) {\n      this.parser = parser;\n      this.path = path;\n      this.elements = this.split(path);\n    }\n    split(path) {\n      let lexer = new XPathLexer_1.XPathLexer(CharStreams_1.CharStreams.fromString(path));\n      lexer.recover = (e) => {\n        throw e;\n      };\n      lexer.removeErrorListeners();\n      lexer.addErrorListener(new XPathLexerErrorListener_1.XPathLexerErrorListener());\n      let tokenStream = new CommonTokenStream_1.CommonTokenStream(lexer);\n      try {\n        tokenStream.fill();\n      } catch (e) {\n        if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {\n          let pos = lexer.charPositionInLine;\n          let msg = \"Invalid tokens or characters at index \" + pos + \" in path '\" + path + \"' -- \" + e.message;\n          throw new RangeError(msg);\n        }\n        throw e;\n      }\n      let tokens2 = tokenStream.getTokens();\n      let elements = [];\n      let n = tokens2.length;\n      let i = 0;\n      loop:\n        while (i < n) {\n          let el = tokens2[i];\n          let next;\n          switch (el.type) {\n            case XPathLexer_1.XPathLexer.ROOT:\n            case XPathLexer_1.XPathLexer.ANYWHERE:\n              let anywhere = el.type === XPathLexer_1.XPathLexer.ANYWHERE;\n              i++;\n              next = tokens2[i];\n              let invert = next.type === XPathLexer_1.XPathLexer.BANG;\n              if (invert) {\n                i++;\n                next = tokens2[i];\n              }\n              let pathElement = this.getXPathElement(next, anywhere);\n              pathElement.invert = invert;\n              elements.push(pathElement);\n              i++;\n              break;\n            case XPathLexer_1.XPathLexer.TOKEN_REF:\n            case XPathLexer_1.XPathLexer.RULE_REF:\n            case XPathLexer_1.XPathLexer.WILDCARD:\n              elements.push(this.getXPathElement(el, false));\n              i++;\n              break;\n            case Token_1.Token.EOF:\n              break loop;\n            default:\n              throw new Error(\"Unknowth path element \" + el);\n          }\n        }\n      return elements;\n    }\n    getXPathElement(wordToken, anywhere) {\n      if (wordToken.type === Token_1.Token.EOF) {\n        throw new Error(\"Missing path element at end of path\");\n      }\n      let word = wordToken.text;\n      if (word == null) {\n        throw new Error(\"Expected wordToken to have text content.\");\n      }\n      let ttype = this.parser.getTokenType(word);\n      let ruleIndex = this.parser.getRuleIndex(word);\n      switch (wordToken.type) {\n        case XPathLexer_1.XPathLexer.WILDCARD:\n          return anywhere ? new XPathWildcardAnywhereElement_1.XPathWildcardAnywhereElement() : new XPathWildcardElement_1.XPathWildcardElement();\n        case XPathLexer_1.XPathLexer.TOKEN_REF:\n        case XPathLexer_1.XPathLexer.STRING:\n          if (ttype === Token_1.Token.INVALID_TYPE) {\n            throw new Error(word + \" at index \" + wordToken.startIndex + \" isn't a valid token name\");\n          }\n          return anywhere ? new XPathTokenAnywhereElement_1.XPathTokenAnywhereElement(word, ttype) : new XPathTokenElement_1.XPathTokenElement(word, ttype);\n        default:\n          if (ruleIndex === -1) {\n            throw new Error(word + \" at index \" + wordToken.startIndex + \" isn't a valid rule name\");\n          }\n          return anywhere ? new XPathRuleAnywhereElement_1.XPathRuleAnywhereElement(word, ruleIndex) : new XPathRuleElement_1.XPathRuleElement(word, ruleIndex);\n      }\n    }\n    static findAll(tree, xpath, parser) {\n      let p = new XPath(parser, xpath);\n      return p.evaluate(tree);\n    }\n    evaluate(t) {\n      let dummyRoot = new ParserRuleContext_1.ParserRuleContext();\n      dummyRoot.addChild(t);\n      let work = new Set([dummyRoot]);\n      let i = 0;\n      while (i < this.elements.length) {\n        let next = new Set();\n        for (let node of work) {\n          if (node.childCount > 0) {\n            let matching = this.elements[i].evaluate(node);\n            matching.forEach(next.add, next);\n          }\n        }\n        i++;\n        work = next;\n      }\n      return work;\n    }\n  };\n  exports.XPath = XPath;\n  XPath.WILDCARD = \"*\";\n  XPath.NOT = \"!\";\n});\n\n// node_modules/antlr4ts/tree/pattern/ParseTreePattern.js\nvar require_ParseTreePattern = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ParseTreePattern = void 0;\n  var Decorators_1 = require_Decorators();\n  var XPath_1 = require_XPath();\n  var ParseTreePattern = class ParseTreePattern {\n    constructor(matcher, pattern, patternRuleIndex, patternTree) {\n      this._matcher = matcher;\n      this._patternRuleIndex = patternRuleIndex;\n      this._pattern = pattern;\n      this._patternTree = patternTree;\n    }\n    match(tree) {\n      return this._matcher.match(tree, this);\n    }\n    matches(tree) {\n      return this._matcher.match(tree, this).succeeded;\n    }\n    findAll(tree, xpath) {\n      let subtrees = XPath_1.XPath.findAll(tree, xpath, this._matcher.parser);\n      let matches = [];\n      for (let t of subtrees) {\n        let match = this.match(t);\n        if (match.succeeded) {\n          matches.push(match);\n        }\n      }\n      return matches;\n    }\n    get matcher() {\n      return this._matcher;\n    }\n    get pattern() {\n      return this._pattern;\n    }\n    get patternRuleIndex() {\n      return this._patternRuleIndex;\n    }\n    get patternTree() {\n      return this._patternTree;\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], ParseTreePattern.prototype, \"_pattern\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], ParseTreePattern.prototype, \"_patternTree\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], ParseTreePattern.prototype, \"_matcher\", void 0);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n  ], ParseTreePattern.prototype, \"match\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], ParseTreePattern.prototype, \"matches\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n  ], ParseTreePattern.prototype, \"findAll\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], ParseTreePattern.prototype, \"matcher\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], ParseTreePattern.prototype, \"pattern\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], ParseTreePattern.prototype, \"patternTree\", null);\n  ParseTreePattern = __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(3, Decorators_1.NotNull)\n  ], ParseTreePattern);\n  exports.ParseTreePattern = ParseTreePattern;\n});\n\n// node_modules/antlr4ts/tree/pattern/RuleTagToken.js\nvar require_RuleTagToken = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.RuleTagToken = void 0;\n  var Decorators_1 = require_Decorators();\n  var Token_1 = require_Token();\n  var RuleTagToken = class RuleTagToken {\n    constructor(ruleName, bypassTokenType, label) {\n      if (ruleName == null || ruleName.length === 0) {\n        throw new Error(\"ruleName cannot be null or empty.\");\n      }\n      this._ruleName = ruleName;\n      this.bypassTokenType = bypassTokenType;\n      this._label = label;\n    }\n    get ruleName() {\n      return this._ruleName;\n    }\n    get label() {\n      return this._label;\n    }\n    get channel() {\n      return Token_1.Token.DEFAULT_CHANNEL;\n    }\n    get text() {\n      if (this._label != null) {\n        return \"<\" + this._label + \":\" + this._ruleName + \">\";\n      }\n      return \"<\" + this._ruleName + \">\";\n    }\n    get type() {\n      return this.bypassTokenType;\n    }\n    get line() {\n      return 0;\n    }\n    get charPositionInLine() {\n      return -1;\n    }\n    get tokenIndex() {\n      return -1;\n    }\n    get startIndex() {\n      return -1;\n    }\n    get stopIndex() {\n      return -1;\n    }\n    get tokenSource() {\n      return void 0;\n    }\n    get inputStream() {\n      return void 0;\n    }\n    toString() {\n      return this._ruleName + \":\" + this.bypassTokenType;\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], RuleTagToken.prototype, \"ruleName\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleTagToken.prototype, \"channel\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleTagToken.prototype, \"text\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleTagToken.prototype, \"type\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleTagToken.prototype, \"line\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleTagToken.prototype, \"charPositionInLine\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleTagToken.prototype, \"tokenIndex\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleTagToken.prototype, \"startIndex\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleTagToken.prototype, \"stopIndex\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleTagToken.prototype, \"tokenSource\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleTagToken.prototype, \"inputStream\", null);\n  __decorate([\n    Decorators_1.Override\n  ], RuleTagToken.prototype, \"toString\", null);\n  RuleTagToken = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], RuleTagToken);\n  exports.RuleTagToken = RuleTagToken;\n});\n\n// node_modules/antlr4ts/tree/pattern/Chunk.js\nvar require_Chunk = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.Chunk = void 0;\n  var Chunk = class {\n  };\n  exports.Chunk = Chunk;\n});\n\n// node_modules/antlr4ts/tree/pattern/TagChunk.js\nvar require_TagChunk = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.TagChunk = void 0;\n  var Chunk_1 = require_Chunk();\n  var Decorators_1 = require_Decorators();\n  var TagChunk = class extends Chunk_1.Chunk {\n    constructor(tag, label) {\n      super();\n      if (tag == null || tag.length === 0) {\n        throw new Error(\"tag cannot be null or empty\");\n      }\n      this._tag = tag;\n      this._label = label;\n    }\n    get tag() {\n      return this._tag;\n    }\n    get label() {\n      return this._label;\n    }\n    toString() {\n      if (this._label != null) {\n        return this._label + \":\" + this._tag;\n      }\n      return this._tag;\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], TagChunk.prototype, \"tag\", null);\n  __decorate([\n    Decorators_1.Override\n  ], TagChunk.prototype, \"toString\", null);\n  exports.TagChunk = TagChunk;\n});\n\n// node_modules/antlr4ts/tree/pattern/TextChunk.js\nvar require_TextChunk = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.TextChunk = void 0;\n  var Chunk_1 = require_Chunk();\n  var Decorators_1 = require_Decorators();\n  var TextChunk = class TextChunk extends Chunk_1.Chunk {\n    constructor(text) {\n      super();\n      if (text == null) {\n        throw new Error(\"text cannot be null\");\n      }\n      this._text = text;\n    }\n    get text() {\n      return this._text;\n    }\n    toString() {\n      return \"'\" + this._text + \"'\";\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], TextChunk.prototype, \"_text\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], TextChunk.prototype, \"text\", null);\n  __decorate([\n    Decorators_1.Override\n  ], TextChunk.prototype, \"toString\", null);\n  TextChunk = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], TextChunk);\n  exports.TextChunk = TextChunk;\n});\n\n// node_modules/antlr4ts/tree/pattern/TokenTagToken.js\nvar require_TokenTagToken = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.TokenTagToken = void 0;\n  var CommonToken_1 = require_CommonToken();\n  var Decorators_1 = require_Decorators();\n  var TokenTagToken = class TokenTagToken extends CommonToken_1.CommonToken {\n    constructor(tokenName, type, label) {\n      super(type);\n      this._tokenName = tokenName;\n      this._label = label;\n    }\n    get tokenName() {\n      return this._tokenName;\n    }\n    get label() {\n      return this._label;\n    }\n    get text() {\n      if (this._label != null) {\n        return \"<\" + this._label + \":\" + this._tokenName + \">\";\n      }\n      return \"<\" + this._tokenName + \">\";\n    }\n    toString() {\n      return this._tokenName + \":\" + this.type;\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], TokenTagToken.prototype, \"_tokenName\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], TokenTagToken.prototype, \"tokenName\", null);\n  __decorate([\n    Decorators_1.Override\n  ], TokenTagToken.prototype, \"text\", null);\n  __decorate([\n    Decorators_1.Override\n  ], TokenTagToken.prototype, \"toString\", null);\n  TokenTagToken = __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], TokenTagToken);\n  exports.TokenTagToken = TokenTagToken;\n});\n\n// node_modules/antlr4ts/tree/pattern/ParseTreePatternMatcher.js\nvar require_ParseTreePatternMatcher = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ParseTreePatternMatcher = void 0;\n  var BailErrorStrategy_1 = require_BailErrorStrategy();\n  var CharStreams_1 = require_CharStreams();\n  var CommonTokenStream_1 = require_CommonTokenStream();\n  var ListTokenSource_1 = require_ListTokenSource();\n  var MultiMap_1 = require_MultiMap();\n  var Decorators_1 = require_Decorators();\n  var ParseCancellationException_1 = require_ParseCancellationException();\n  var ParserInterpreter_1 = require_ParserInterpreter();\n  var ParserRuleContext_1 = require_ParserRuleContext();\n  var ParseTreeMatch_1 = require_ParseTreeMatch();\n  var ParseTreePattern_1 = require_ParseTreePattern();\n  var RecognitionException_1 = require_RecognitionException();\n  var RuleNode_1 = require_RuleNode();\n  var RuleTagToken_1 = require_RuleTagToken();\n  var TagChunk_1 = require_TagChunk();\n  var TerminalNode_1 = require_TerminalNode();\n  var TextChunk_1 = require_TextChunk();\n  var Token_1 = require_Token();\n  var TokenTagToken_1 = require_TokenTagToken();\n  var ParseTreePatternMatcher2 = class {\n    constructor(lexer, parser) {\n      this.start = \"<\";\n      this.stop = \">\";\n      this.escape = \"\\\\\";\n      this.escapeRE = /\\\\/g;\n      this._lexer = lexer;\n      this._parser = parser;\n    }\n    setDelimiters(start, stop, escapeLeft) {\n      if (!start) {\n        throw new Error(\"start cannot be null or empty\");\n      }\n      if (!stop) {\n        throw new Error(\"stop cannot be null or empty\");\n      }\n      this.start = start;\n      this.stop = stop;\n      this.escape = escapeLeft;\n      this.escapeRE = new RegExp(escapeLeft.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"), \"g\");\n    }\n    matches(tree, pattern, patternRuleIndex = 0) {\n      if (typeof pattern === \"string\") {\n        let p = this.compile(pattern, patternRuleIndex);\n        return this.matches(tree, p);\n      } else {\n        let labels = new MultiMap_1.MultiMap();\n        let mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);\n        return !mismatchedNode;\n      }\n    }\n    match(tree, pattern, patternRuleIndex = 0) {\n      if (typeof pattern === \"string\") {\n        let p = this.compile(pattern, patternRuleIndex);\n        return this.match(tree, p);\n      } else {\n        let labels = new MultiMap_1.MultiMap();\n        let mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);\n        return new ParseTreeMatch_1.ParseTreeMatch(tree, pattern, labels, mismatchedNode);\n      }\n    }\n    compile(pattern, patternRuleIndex) {\n      let tokenList = this.tokenize(pattern);\n      let tokenSrc = new ListTokenSource_1.ListTokenSource(tokenList);\n      let tokens2 = new CommonTokenStream_1.CommonTokenStream(tokenSrc);\n      const parser = this._parser;\n      let parserInterp = new ParserInterpreter_1.ParserInterpreter(parser.grammarFileName, parser.vocabulary, parser.ruleNames, parser.getATNWithBypassAlts(), tokens2);\n      let tree;\n      try {\n        parserInterp.errorHandler = new BailErrorStrategy_1.BailErrorStrategy();\n        tree = parserInterp.parse(patternRuleIndex);\n      } catch (e) {\n        if (e instanceof ParseCancellationException_1.ParseCancellationException) {\n          throw e.getCause();\n        } else if (e instanceof RecognitionException_1.RecognitionException) {\n          throw e;\n        } else if (e instanceof Error) {\n          throw new ParseTreePatternMatcher2.CannotInvokeStartRule(e);\n        } else {\n          throw e;\n        }\n      }\n      if (tokens2.LA(1) !== Token_1.Token.EOF) {\n        throw new ParseTreePatternMatcher2.StartRuleDoesNotConsumeFullPattern();\n      }\n      return new ParseTreePattern_1.ParseTreePattern(this, pattern, patternRuleIndex, tree);\n    }\n    get lexer() {\n      return this._lexer;\n    }\n    get parser() {\n      return this._parser;\n    }\n    matchImpl(tree, patternTree, labels) {\n      if (!tree) {\n        throw new TypeError(\"tree cannot be null\");\n      }\n      if (!patternTree) {\n        throw new TypeError(\"patternTree cannot be null\");\n      }\n      if (tree instanceof TerminalNode_1.TerminalNode && patternTree instanceof TerminalNode_1.TerminalNode) {\n        let mismatchedNode;\n        if (tree.symbol.type === patternTree.symbol.type) {\n          if (patternTree.symbol instanceof TokenTagToken_1.TokenTagToken) {\n            let tokenTagToken = patternTree.symbol;\n            labels.map(tokenTagToken.tokenName, tree);\n            const l = tokenTagToken.label;\n            if (l) {\n              labels.map(l, tree);\n            }\n          } else if (tree.text === patternTree.text) {\n          } else {\n            if (!mismatchedNode) {\n              mismatchedNode = tree;\n            }\n          }\n        } else {\n          if (!mismatchedNode) {\n            mismatchedNode = tree;\n          }\n        }\n        return mismatchedNode;\n      }\n      if (tree instanceof ParserRuleContext_1.ParserRuleContext && patternTree instanceof ParserRuleContext_1.ParserRuleContext) {\n        let mismatchedNode;\n        let ruleTagToken = this.getRuleTagToken(patternTree);\n        if (ruleTagToken) {\n          let m;\n          if (tree.ruleContext.ruleIndex === patternTree.ruleContext.ruleIndex) {\n            labels.map(ruleTagToken.ruleName, tree);\n            const l = ruleTagToken.label;\n            if (l) {\n              labels.map(l, tree);\n            }\n          } else {\n            if (!mismatchedNode) {\n              mismatchedNode = tree;\n            }\n          }\n          return mismatchedNode;\n        }\n        if (tree.childCount !== patternTree.childCount) {\n          if (!mismatchedNode) {\n            mismatchedNode = tree;\n          }\n          return mismatchedNode;\n        }\n        let n = tree.childCount;\n        for (let i = 0; i < n; i++) {\n          let childMatch = this.matchImpl(tree.getChild(i), patternTree.getChild(i), labels);\n          if (childMatch) {\n            return childMatch;\n          }\n        }\n        return mismatchedNode;\n      }\n      return tree;\n    }\n    getRuleTagToken(t) {\n      if (t instanceof RuleNode_1.RuleNode) {\n        if (t.childCount === 1 && t.getChild(0) instanceof TerminalNode_1.TerminalNode) {\n          let c = t.getChild(0);\n          if (c.symbol instanceof RuleTagToken_1.RuleTagToken) {\n            return c.symbol;\n          }\n        }\n      }\n      return void 0;\n    }\n    tokenize(pattern) {\n      let chunks = this.split(pattern);\n      let tokens2 = [];\n      for (let chunk of chunks) {\n        if (chunk instanceof TagChunk_1.TagChunk) {\n          let tagChunk = chunk;\n          const firstChar = tagChunk.tag.substr(0, 1);\n          if (firstChar === firstChar.toUpperCase()) {\n            let ttype = this._parser.getTokenType(tagChunk.tag);\n            if (ttype === Token_1.Token.INVALID_TYPE) {\n              throw new Error(\"Unknown token \" + tagChunk.tag + \" in pattern: \" + pattern);\n            }\n            let t = new TokenTagToken_1.TokenTagToken(tagChunk.tag, ttype, tagChunk.label);\n            tokens2.push(t);\n          } else if (firstChar === firstChar.toLowerCase()) {\n            let ruleIndex = this._parser.getRuleIndex(tagChunk.tag);\n            if (ruleIndex === -1) {\n              throw new Error(\"Unknown rule \" + tagChunk.tag + \" in pattern: \" + pattern);\n            }\n            let ruleImaginaryTokenType = this._parser.getATNWithBypassAlts().ruleToTokenType[ruleIndex];\n            tokens2.push(new RuleTagToken_1.RuleTagToken(tagChunk.tag, ruleImaginaryTokenType, tagChunk.label));\n          } else {\n            throw new Error(\"invalid tag: \" + tagChunk.tag + \" in pattern: \" + pattern);\n          }\n        } else {\n          let textChunk = chunk;\n          this._lexer.inputStream = CharStreams_1.CharStreams.fromString(textChunk.text);\n          let t = this._lexer.nextToken();\n          while (t.type !== Token_1.Token.EOF) {\n            tokens2.push(t);\n            t = this._lexer.nextToken();\n          }\n        }\n      }\n      return tokens2;\n    }\n    split(pattern) {\n      let p = 0;\n      let n = pattern.length;\n      let chunks = [];\n      let buf;\n      let starts = [];\n      let stops = [];\n      while (p < n) {\n        if (p === pattern.indexOf(this.escape + this.start, p)) {\n          p += this.escape.length + this.start.length;\n        } else if (p === pattern.indexOf(this.escape + this.stop, p)) {\n          p += this.escape.length + this.stop.length;\n        } else if (p === pattern.indexOf(this.start, p)) {\n          starts.push(p);\n          p += this.start.length;\n        } else if (p === pattern.indexOf(this.stop, p)) {\n          stops.push(p);\n          p += this.stop.length;\n        } else {\n          p++;\n        }\n      }\n      if (starts.length > stops.length) {\n        throw new Error(\"unterminated tag in pattern: \" + pattern);\n      }\n      if (starts.length < stops.length) {\n        throw new Error(\"missing start tag in pattern: \" + pattern);\n      }\n      let ntags = starts.length;\n      for (let i = 0; i < ntags; i++) {\n        if (starts[i] >= stops[i]) {\n          throw new Error(\"tag delimiters out of order in pattern: \" + pattern);\n        }\n      }\n      if (ntags === 0) {\n        let text = pattern.substring(0, n);\n        chunks.push(new TextChunk_1.TextChunk(text));\n      }\n      if (ntags > 0 && starts[0] > 0) {\n        let text = pattern.substring(0, starts[0]);\n        chunks.push(new TextChunk_1.TextChunk(text));\n      }\n      for (let i = 0; i < ntags; i++) {\n        let tag = pattern.substring(starts[i] + this.start.length, stops[i]);\n        let ruleOrToken = tag;\n        let label;\n        let colon = tag.indexOf(\":\");\n        if (colon >= 0) {\n          label = tag.substring(0, colon);\n          ruleOrToken = tag.substring(colon + 1, tag.length);\n        }\n        chunks.push(new TagChunk_1.TagChunk(ruleOrToken, label));\n        if (i + 1 < ntags) {\n          let text = pattern.substring(stops[i] + this.stop.length, starts[i + 1]);\n          chunks.push(new TextChunk_1.TextChunk(text));\n        }\n      }\n      if (ntags > 0) {\n        let afterLastTag = stops[ntags - 1] + this.stop.length;\n        if (afterLastTag < n) {\n          let text = pattern.substring(afterLastTag, n);\n          chunks.push(new TextChunk_1.TextChunk(text));\n        }\n      }\n      for (let i = 0; i < chunks.length; i++) {\n        let c = chunks[i];\n        if (c instanceof TextChunk_1.TextChunk) {\n          let unescaped = c.text.replace(this.escapeRE, \"\");\n          if (unescaped.length < c.text.length) {\n            chunks[i] = new TextChunk_1.TextChunk(unescaped);\n          }\n        }\n      }\n      return chunks;\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull,\n    __param(1, Decorators_1.NotNull)\n  ], ParseTreePatternMatcher2.prototype, \"match\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], ParseTreePatternMatcher2.prototype, \"lexer\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], ParseTreePatternMatcher2.prototype, \"parser\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n  ], ParseTreePatternMatcher2.prototype, \"matchImpl\", null);\n  exports.ParseTreePatternMatcher = ParseTreePatternMatcher2;\n  (function(ParseTreePatternMatcher3) {\n    class CannotInvokeStartRule extends Error {\n      constructor(error) {\n        super(`CannotInvokeStartRule: ${error}`);\n        this.error = error;\n      }\n    }\n    ParseTreePatternMatcher3.CannotInvokeStartRule = CannotInvokeStartRule;\n    class StartRuleDoesNotConsumeFullPattern extends Error {\n      constructor() {\n        super(\"StartRuleDoesNotConsumeFullPattern\");\n      }\n    }\n    ParseTreePatternMatcher3.StartRuleDoesNotConsumeFullPattern = StartRuleDoesNotConsumeFullPattern;\n  })(ParseTreePatternMatcher2 = exports.ParseTreePatternMatcher || (exports.ParseTreePatternMatcher = {}));\n});\n\n// node_modules/antlr4ts/atn/DecisionEventInfo.js\nvar require_DecisionEventInfo = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.DecisionEventInfo = void 0;\n  var Decorators_1 = require_Decorators();\n  var DecisionEventInfo = class DecisionEventInfo {\n    constructor(decision, state, input, startIndex, stopIndex, fullCtx) {\n      this.decision = decision;\n      this.fullCtx = fullCtx;\n      this.stopIndex = stopIndex;\n      this.input = input;\n      this.startIndex = startIndex;\n      this.state = state;\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], DecisionEventInfo.prototype, \"input\", void 0);\n  DecisionEventInfo = __decorate([\n    __param(2, Decorators_1.NotNull)\n  ], DecisionEventInfo);\n  exports.DecisionEventInfo = DecisionEventInfo;\n});\n\n// node_modules/antlr4ts/atn/AmbiguityInfo.js\nvar require_AmbiguityInfo = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.AmbiguityInfo = void 0;\n  var DecisionEventInfo_1 = require_DecisionEventInfo();\n  var Decorators_1 = require_Decorators();\n  var AmbiguityInfo = class AmbiguityInfo extends DecisionEventInfo_1.DecisionEventInfo {\n    constructor(decision, state, ambigAlts, input, startIndex, stopIndex) {\n      super(decision, state, input, startIndex, stopIndex, state.useContext);\n      this.ambigAlts = ambigAlts;\n    }\n    get ambiguousAlternatives() {\n      return this.ambigAlts;\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], AmbiguityInfo.prototype, \"ambigAlts\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], AmbiguityInfo.prototype, \"ambiguousAlternatives\", null);\n  AmbiguityInfo = __decorate([\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull),\n    __param(3, Decorators_1.NotNull)\n  ], AmbiguityInfo);\n  exports.AmbiguityInfo = AmbiguityInfo;\n});\n\n// node_modules/antlr4ts/atn/ContextSensitivityInfo.js\nvar require_ContextSensitivityInfo = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ContextSensitivityInfo = void 0;\n  var DecisionEventInfo_1 = require_DecisionEventInfo();\n  var Decorators_1 = require_Decorators();\n  var ContextSensitivityInfo = class ContextSensitivityInfo extends DecisionEventInfo_1.DecisionEventInfo {\n    constructor(decision, state, input, startIndex, stopIndex) {\n      super(decision, state, input, startIndex, stopIndex, true);\n    }\n  };\n  ContextSensitivityInfo = __decorate([\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n  ], ContextSensitivityInfo);\n  exports.ContextSensitivityInfo = ContextSensitivityInfo;\n});\n\n// node_modules/antlr4ts/atn/DecisionInfo.js\nvar require_DecisionInfo = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.DecisionInfo = void 0;\n  var Decorators_1 = require_Decorators();\n  var DecisionInfo = class {\n    constructor(decision) {\n      this.invocations = 0;\n      this.timeInPrediction = 0;\n      this.SLL_TotalLook = 0;\n      this.SLL_MinLook = 0;\n      this.SLL_MaxLook = 0;\n      this.LL_TotalLook = 0;\n      this.LL_MinLook = 0;\n      this.LL_MaxLook = 0;\n      this.contextSensitivities = [];\n      this.errors = [];\n      this.ambiguities = [];\n      this.predicateEvals = [];\n      this.SLL_ATNTransitions = 0;\n      this.SLL_DFATransitions = 0;\n      this.LL_Fallback = 0;\n      this.LL_ATNTransitions = 0;\n      this.LL_DFATransitions = 0;\n      this.decision = decision;\n    }\n    toString() {\n      return \"{decision=\" + this.decision + \", contextSensitivities=\" + this.contextSensitivities.length + \", errors=\" + this.errors.length + \", ambiguities=\" + this.ambiguities.length + \", SLL_lookahead=\" + this.SLL_TotalLook + \", SLL_ATNTransitions=\" + this.SLL_ATNTransitions + \", SLL_DFATransitions=\" + this.SLL_DFATransitions + \", LL_Fallback=\" + this.LL_Fallback + \", LL_lookahead=\" + this.LL_TotalLook + \", LL_ATNTransitions=\" + this.LL_ATNTransitions + \"}\";\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], DecisionInfo.prototype, \"toString\", null);\n  exports.DecisionInfo = DecisionInfo;\n});\n\n// node_modules/antlr4ts/atn/ErrorInfo.js\nvar require_ErrorInfo = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ErrorInfo = void 0;\n  var DecisionEventInfo_1 = require_DecisionEventInfo();\n  var Decorators_1 = require_Decorators();\n  var ErrorInfo = class ErrorInfo extends DecisionEventInfo_1.DecisionEventInfo {\n    constructor(decision, state, input, startIndex, stopIndex) {\n      super(decision, state, input, startIndex, stopIndex, state.useContext);\n    }\n  };\n  ErrorInfo = __decorate([\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n  ], ErrorInfo);\n  exports.ErrorInfo = ErrorInfo;\n});\n\n// node_modules/antlr4ts/atn/LookaheadEventInfo.js\nvar require_LookaheadEventInfo = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.LookaheadEventInfo = void 0;\n  var DecisionEventInfo_1 = require_DecisionEventInfo();\n  var Decorators_1 = require_Decorators();\n  var LookaheadEventInfo = class LookaheadEventInfo extends DecisionEventInfo_1.DecisionEventInfo {\n    constructor(decision, state, predictedAlt, input, startIndex, stopIndex, fullCtx) {\n      super(decision, state, input, startIndex, stopIndex, fullCtx);\n      this.predictedAlt = predictedAlt;\n    }\n  };\n  LookaheadEventInfo = __decorate([\n    __param(3, Decorators_1.NotNull)\n  ], LookaheadEventInfo);\n  exports.LookaheadEventInfo = LookaheadEventInfo;\n});\n\n// node_modules/antlr4ts/atn/PredicateEvalInfo.js\nvar require_PredicateEvalInfo = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.PredicateEvalInfo = void 0;\n  var DecisionEventInfo_1 = require_DecisionEventInfo();\n  var Decorators_1 = require_Decorators();\n  var PredicateEvalInfo = class PredicateEvalInfo extends DecisionEventInfo_1.DecisionEventInfo {\n    constructor(state, decision, input, startIndex, stopIndex, semctx, evalResult, predictedAlt) {\n      super(decision, state, input, startIndex, stopIndex, state.useContext);\n      this.semctx = semctx;\n      this.evalResult = evalResult;\n      this.predictedAlt = predictedAlt;\n    }\n  };\n  PredicateEvalInfo = __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull),\n    __param(5, Decorators_1.NotNull)\n  ], PredicateEvalInfo);\n  exports.PredicateEvalInfo = PredicateEvalInfo;\n});\n\n// node_modules/antlr4ts/atn/ProfilingATNSimulator.js\nvar require_ProfilingATNSimulator = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.ProfilingATNSimulator = void 0;\n  var AmbiguityInfo_1 = require_AmbiguityInfo();\n  var ATN_1 = require_ATN();\n  var ATNSimulator_1 = require_ATNSimulator();\n  var ContextSensitivityInfo_1 = require_ContextSensitivityInfo();\n  var DecisionInfo_1 = require_DecisionInfo();\n  var ErrorInfo_1 = require_ErrorInfo();\n  var Decorators_1 = require_Decorators();\n  var LookaheadEventInfo_1 = require_LookaheadEventInfo();\n  var ParserATNSimulator_1 = require_ParserATNSimulator();\n  var PredicateEvalInfo_1 = require_PredicateEvalInfo();\n  var SemanticContext_1 = require_SemanticContext();\n  var SimulatorState_1 = require_SimulatorState();\n  var ProfilingATNSimulator = class extends ParserATNSimulator_1.ParserATNSimulator {\n    constructor(parser) {\n      super(parser.interpreter.atn, parser);\n      this._startIndex = 0;\n      this._sllStopIndex = 0;\n      this._llStopIndex = 0;\n      this.currentDecision = 0;\n      this.conflictingAltResolvedBySLL = 0;\n      this.optimize_ll1 = false;\n      this.reportAmbiguities = true;\n      this.numDecisions = this.atn.decisionToState.length;\n      this.decisions = [];\n      for (let i = 0; i < this.numDecisions; i++) {\n        this.decisions.push(new DecisionInfo_1.DecisionInfo(i));\n      }\n    }\n    adaptivePredict(input, decision, outerContext, useContext) {\n      if (useContext !== void 0) {\n        return super.adaptivePredict(input, decision, outerContext, useContext);\n      }\n      try {\n        this._input = input;\n        this._startIndex = input.index;\n        this._sllStopIndex = this._startIndex - 1;\n        this._llStopIndex = -1;\n        this.currentDecision = decision;\n        this.currentState = void 0;\n        this.conflictingAltResolvedBySLL = ATN_1.ATN.INVALID_ALT_NUMBER;\n        let start = process.hrtime();\n        let alt = super.adaptivePredict(input, decision, outerContext);\n        let stop = process.hrtime();\n        let nanoseconds = (stop[0] - start[0]) * 1e9;\n        if (nanoseconds === 0) {\n          nanoseconds = stop[1] - start[1];\n        } else {\n          nanoseconds += 1e9 - start[1] + stop[1];\n        }\n        this.decisions[decision].timeInPrediction += nanoseconds;\n        this.decisions[decision].invocations++;\n        let SLL_k = this._sllStopIndex - this._startIndex + 1;\n        this.decisions[decision].SLL_TotalLook += SLL_k;\n        this.decisions[decision].SLL_MinLook = this.decisions[decision].SLL_MinLook === 0 ? SLL_k : Math.min(this.decisions[decision].SLL_MinLook, SLL_k);\n        if (SLL_k > this.decisions[decision].SLL_MaxLook) {\n          this.decisions[decision].SLL_MaxLook = SLL_k;\n          this.decisions[decision].SLL_MaxLookEvent = new LookaheadEventInfo_1.LookaheadEventInfo(decision, void 0, alt, input, this._startIndex, this._sllStopIndex, false);\n        }\n        if (this._llStopIndex >= 0) {\n          let LL_k = this._llStopIndex - this._startIndex + 1;\n          this.decisions[decision].LL_TotalLook += LL_k;\n          this.decisions[decision].LL_MinLook = this.decisions[decision].LL_MinLook === 0 ? LL_k : Math.min(this.decisions[decision].LL_MinLook, LL_k);\n          if (LL_k > this.decisions[decision].LL_MaxLook) {\n            this.decisions[decision].LL_MaxLook = LL_k;\n            this.decisions[decision].LL_MaxLookEvent = new LookaheadEventInfo_1.LookaheadEventInfo(decision, void 0, alt, input, this._startIndex, this._llStopIndex, true);\n          }\n        }\n        return alt;\n      } finally {\n        this._input = void 0;\n        this.currentDecision = -1;\n      }\n    }\n    getStartState(dfa, input, outerContext, useContext) {\n      let state = super.getStartState(dfa, input, outerContext, useContext);\n      this.currentState = state;\n      return state;\n    }\n    computeStartState(dfa, globalContext, useContext) {\n      let state = super.computeStartState(dfa, globalContext, useContext);\n      this.currentState = state;\n      return state;\n    }\n    computeReachSet(dfa, previous, t, contextCache) {\n      if (this._input === void 0) {\n        throw new Error(\"Invalid state\");\n      }\n      let reachState = super.computeReachSet(dfa, previous, t, contextCache);\n      if (reachState == null) {\n        this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, previous, this._input, this._startIndex, this._input.index));\n      }\n      this.currentState = reachState;\n      return reachState;\n    }\n    getExistingTargetState(previousD, t) {\n      if (this.currentState === void 0 || this._input === void 0) {\n        throw new Error(\"Invalid state\");\n      }\n      if (this.currentState.useContext) {\n        this._llStopIndex = this._input.index;\n      } else {\n        this._sllStopIndex = this._input.index;\n      }\n      let existingTargetState = super.getExistingTargetState(previousD, t);\n      if (existingTargetState != null) {\n        this.currentState = new SimulatorState_1.SimulatorState(this.currentState.outerContext, existingTargetState, this.currentState.useContext, this.currentState.remainingOuterContext);\n        if (this.currentState.useContext) {\n          this.decisions[this.currentDecision].LL_DFATransitions++;\n        } else {\n          this.decisions[this.currentDecision].SLL_DFATransitions++;\n        }\n        if (existingTargetState === ATNSimulator_1.ATNSimulator.ERROR) {\n          let state = new SimulatorState_1.SimulatorState(this.currentState.outerContext, previousD, this.currentState.useContext, this.currentState.remainingOuterContext);\n          this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, state, this._input, this._startIndex, this._input.index));\n        }\n      }\n      return existingTargetState;\n    }\n    computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {\n      let targetState = super.computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache);\n      if (useContext) {\n        this.decisions[this.currentDecision].LL_ATNTransitions++;\n      } else {\n        this.decisions[this.currentDecision].SLL_ATNTransitions++;\n      }\n      return targetState;\n    }\n    evalSemanticContextImpl(pred, parserCallStack, alt) {\n      if (this.currentState === void 0 || this._input === void 0) {\n        throw new Error(\"Invalid state\");\n      }\n      let result = super.evalSemanticContextImpl(pred, parserCallStack, alt);\n      if (!(pred instanceof SemanticContext_1.SemanticContext.PrecedencePredicate)) {\n        let fullContext = this._llStopIndex >= 0;\n        let stopIndex = fullContext ? this._llStopIndex : this._sllStopIndex;\n        this.decisions[this.currentDecision].predicateEvals.push(new PredicateEvalInfo_1.PredicateEvalInfo(this.currentState, this.currentDecision, this._input, this._startIndex, stopIndex, pred, result, alt));\n      }\n      return result;\n    }\n    reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {\n      if (this._input === void 0) {\n        throw new Error(\"Invalid state\");\n      }\n      if (prediction !== this.conflictingAltResolvedBySLL) {\n        this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, acceptState, this._input, startIndex, stopIndex));\n      }\n      super.reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex);\n    }\n    reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {\n      if (conflictingAlts != null) {\n        this.conflictingAltResolvedBySLL = conflictingAlts.nextSetBit(0);\n      } else {\n        this.conflictingAltResolvedBySLL = conflictState.s0.configs.getRepresentedAlternatives().nextSetBit(0);\n      }\n      this.decisions[this.currentDecision].LL_Fallback++;\n      super.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex);\n    }\n    reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {\n      if (this.currentState === void 0 || this._input === void 0) {\n        throw new Error(\"Invalid state\");\n      }\n      let prediction;\n      if (ambigAlts != null) {\n        prediction = ambigAlts.nextSetBit(0);\n      } else {\n        prediction = configs.getRepresentedAlternatives().nextSetBit(0);\n      }\n      if (this.conflictingAltResolvedBySLL !== ATN_1.ATN.INVALID_ALT_NUMBER && prediction !== this.conflictingAltResolvedBySLL) {\n        this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, this.currentState, this._input, startIndex, stopIndex));\n      }\n      this.decisions[this.currentDecision].ambiguities.push(new AmbiguityInfo_1.AmbiguityInfo(this.currentDecision, this.currentState, ambigAlts, this._input, startIndex, stopIndex));\n      super.reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs);\n    }\n    getDecisionInfo() {\n      return this.decisions;\n    }\n    getCurrentState() {\n      return this.currentState;\n    }\n  };\n  __decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull)\n  ], ProfilingATNSimulator.prototype, \"adaptivePredict\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ProfilingATNSimulator.prototype, \"getStartState\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ProfilingATNSimulator.prototype, \"computeStartState\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ProfilingATNSimulator.prototype, \"computeReachSet\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ProfilingATNSimulator.prototype, \"getExistingTargetState\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ProfilingATNSimulator.prototype, \"computeTargetState\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ProfilingATNSimulator.prototype, \"evalSemanticContextImpl\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ProfilingATNSimulator.prototype, \"reportContextSensitivity\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ProfilingATNSimulator.prototype, \"reportAttemptingFullContext\", null);\n  __decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull),\n    __param(5, Decorators_1.NotNull),\n    __param(6, Decorators_1.NotNull)\n  ], ProfilingATNSimulator.prototype, \"reportAmbiguity\", null);\n  exports.ProfilingATNSimulator = ProfilingATNSimulator;\n});\n\n// node_modules/antlr4ts/Parser.js\nvar require_Parser = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n      return value instanceof P ? value : new P(function(resolve) {\n        resolve(value);\n      });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function step(result) {\n        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n      }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.Parser = void 0;\n  var Utils3 = require_Utils();\n  var ATNDeserializationOptions_1 = require_ATNDeserializationOptions();\n  var ATNDeserializer_1 = require_ATNDeserializer();\n  var DefaultErrorStrategy_1 = require_DefaultErrorStrategy();\n  var ErrorNode_1 = require_ErrorNode();\n  var IntegerStack_1 = require_IntegerStack();\n  var Lexer_1 = require_Lexer();\n  var Decorators_1 = require_Decorators();\n  var ParseInfo_1 = require_ParseInfo();\n  var ParserATNSimulator_1 = require_ParserATNSimulator();\n  var ProxyParserErrorListener_1 = require_ProxyParserErrorListener();\n  var Recognizer_1 = require_Recognizer();\n  var TerminalNode_1 = require_TerminalNode();\n  var Token_1 = require_Token();\n  var TraceListener = class {\n    constructor(ruleNames, tokenStream) {\n      this.ruleNames = ruleNames;\n      this.tokenStream = tokenStream;\n    }\n    enterEveryRule(ctx) {\n      console.log(\"enter   \" + this.ruleNames[ctx.ruleIndex] + \", LT(1)=\" + this.tokenStream.LT(1).text);\n    }\n    exitEveryRule(ctx) {\n      console.log(\"exit    \" + this.ruleNames[ctx.ruleIndex] + \", LT(1)=\" + this.tokenStream.LT(1).text);\n    }\n    visitErrorNode(node) {\n    }\n    visitTerminal(node) {\n      let parent = node.parent.ruleContext;\n      let token = node.symbol;\n      console.log(\"consume \" + token + \" rule \" + this.ruleNames[parent.ruleIndex]);\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], TraceListener.prototype, \"enterEveryRule\", null);\n  __decorate([\n    Decorators_1.Override\n  ], TraceListener.prototype, \"exitEveryRule\", null);\n  __decorate([\n    Decorators_1.Override\n  ], TraceListener.prototype, \"visitErrorNode\", null);\n  __decorate([\n    Decorators_1.Override\n  ], TraceListener.prototype, \"visitTerminal\", null);\n  var Parser2 = class extends Recognizer_1.Recognizer {\n    constructor(input) {\n      super();\n      this._errHandler = new DefaultErrorStrategy_1.DefaultErrorStrategy();\n      this._precedenceStack = new IntegerStack_1.IntegerStack();\n      this._buildParseTrees = true;\n      this._parseListeners = [];\n      this._syntaxErrors = 0;\n      this.matchedEOF = false;\n      this._precedenceStack.push(0);\n      this.inputStream = input;\n    }\n    reset(resetInput) {\n      if (resetInput === void 0 || resetInput) {\n        this.inputStream.seek(0);\n      }\n      this._errHandler.reset(this);\n      this._ctx = void 0;\n      this._syntaxErrors = 0;\n      this.matchedEOF = false;\n      this.isTrace = false;\n      this._precedenceStack.clear();\n      this._precedenceStack.push(0);\n      let interpreter = this.interpreter;\n      if (interpreter != null) {\n        interpreter.reset();\n      }\n    }\n    match(ttype) {\n      let t = this.currentToken;\n      if (t.type === ttype) {\n        if (ttype === Token_1.Token.EOF) {\n          this.matchedEOF = true;\n        }\n        this._errHandler.reportMatch(this);\n        this.consume();\n      } else {\n        t = this._errHandler.recoverInline(this);\n        if (this._buildParseTrees && t.tokenIndex === -1) {\n          this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));\n        }\n      }\n      return t;\n    }\n    matchWildcard() {\n      let t = this.currentToken;\n      if (t.type > 0) {\n        this._errHandler.reportMatch(this);\n        this.consume();\n      } else {\n        t = this._errHandler.recoverInline(this);\n        if (this._buildParseTrees && t.tokenIndex === -1) {\n          this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));\n        }\n      }\n      return t;\n    }\n    set buildParseTree(buildParseTrees) {\n      this._buildParseTrees = buildParseTrees;\n    }\n    get buildParseTree() {\n      return this._buildParseTrees;\n    }\n    getParseListeners() {\n      return this._parseListeners;\n    }\n    addParseListener(listener) {\n      if (listener == null) {\n        throw new TypeError(\"listener cannot be null\");\n      }\n      this._parseListeners.push(listener);\n    }\n    removeParseListener(listener) {\n      let index = this._parseListeners.findIndex((l) => l === listener);\n      if (index !== -1) {\n        this._parseListeners.splice(index, 1);\n      }\n    }\n    removeParseListeners() {\n      this._parseListeners.length = 0;\n    }\n    triggerEnterRuleEvent() {\n      for (let listener of this._parseListeners) {\n        if (listener.enterEveryRule) {\n          listener.enterEveryRule(this._ctx);\n        }\n        this._ctx.enterRule(listener);\n      }\n    }\n    triggerExitRuleEvent() {\n      for (let i = this._parseListeners.length - 1; i >= 0; i--) {\n        let listener = this._parseListeners[i];\n        this._ctx.exitRule(listener);\n        if (listener.exitEveryRule) {\n          listener.exitEveryRule(this._ctx);\n        }\n      }\n    }\n    get numberOfSyntaxErrors() {\n      return this._syntaxErrors;\n    }\n    get tokenFactory() {\n      return this._input.tokenSource.tokenFactory;\n    }\n    getATNWithBypassAlts() {\n      let serializedAtn = this.serializedATN;\n      if (serializedAtn == null) {\n        throw new Error(\"The current parser does not support an ATN with bypass alternatives.\");\n      }\n      let result = Parser2.bypassAltsAtnCache.get(serializedAtn);\n      if (result == null) {\n        let deserializationOptions = new ATNDeserializationOptions_1.ATNDeserializationOptions();\n        deserializationOptions.isGenerateRuleBypassTransitions = true;\n        result = new ATNDeserializer_1.ATNDeserializer(deserializationOptions).deserialize(Utils3.toCharArray(serializedAtn));\n        Parser2.bypassAltsAtnCache.set(serializedAtn, result);\n      }\n      return result;\n    }\n    compileParseTreePattern(pattern, patternRuleIndex, lexer) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!lexer) {\n          if (this.inputStream) {\n            let tokenSource = this.inputStream.tokenSource;\n            if (tokenSource instanceof Lexer_1.Lexer) {\n              lexer = tokenSource;\n            }\n          }\n          if (!lexer) {\n            throw new Error(\"Parser can't discover a lexer to use\");\n          }\n        }\n        let currentLexer = lexer;\n        let m = yield Promise.resolve().then(() => require_ParseTreePatternMatcher());\n        let matcher = new m.ParseTreePatternMatcher(currentLexer, this);\n        return matcher.compile(pattern, patternRuleIndex);\n      });\n    }\n    get errorHandler() {\n      return this._errHandler;\n    }\n    set errorHandler(handler) {\n      this._errHandler = handler;\n    }\n    get inputStream() {\n      return this._input;\n    }\n    set inputStream(input) {\n      this.reset(false);\n      this._input = input;\n    }\n    get currentToken() {\n      return this._input.LT(1);\n    }\n    notifyErrorListeners(msg, offendingToken, e) {\n      if (offendingToken === void 0) {\n        offendingToken = this.currentToken;\n      } else if (offendingToken === null) {\n        offendingToken = void 0;\n      }\n      this._syntaxErrors++;\n      let line = -1;\n      let charPositionInLine = -1;\n      if (offendingToken != null) {\n        line = offendingToken.line;\n        charPositionInLine = offendingToken.charPositionInLine;\n      }\n      let listener = this.getErrorListenerDispatch();\n      if (listener.syntaxError) {\n        listener.syntaxError(this, offendingToken, line, charPositionInLine, msg, e);\n      }\n    }\n    consume() {\n      let o = this.currentToken;\n      if (o.type !== Parser2.EOF) {\n        this.inputStream.consume();\n      }\n      let hasListener = this._parseListeners.length !== 0;\n      if (this._buildParseTrees || hasListener) {\n        if (this._errHandler.inErrorRecoveryMode(this)) {\n          let node = this._ctx.addErrorNode(this.createErrorNode(this._ctx, o));\n          if (hasListener) {\n            for (let listener of this._parseListeners) {\n              if (listener.visitErrorNode) {\n                listener.visitErrorNode(node);\n              }\n            }\n          }\n        } else {\n          let node = this.createTerminalNode(this._ctx, o);\n          this._ctx.addChild(node);\n          if (hasListener) {\n            for (let listener of this._parseListeners) {\n              if (listener.visitTerminal) {\n                listener.visitTerminal(node);\n              }\n            }\n          }\n        }\n      }\n      return o;\n    }\n    createTerminalNode(parent, t) {\n      return new TerminalNode_1.TerminalNode(t);\n    }\n    createErrorNode(parent, t) {\n      return new ErrorNode_1.ErrorNode(t);\n    }\n    addContextToParseTree() {\n      let parent = this._ctx._parent;\n      if (parent != null) {\n        parent.addChild(this._ctx);\n      }\n    }\n    enterRule(localctx, state, ruleIndex) {\n      this.state = state;\n      this._ctx = localctx;\n      this._ctx._start = this._input.LT(1);\n      if (this._buildParseTrees) {\n        this.addContextToParseTree();\n      }\n      this.triggerEnterRuleEvent();\n    }\n    enterLeftFactoredRule(localctx, state, ruleIndex) {\n      this.state = state;\n      if (this._buildParseTrees) {\n        let factoredContext = this._ctx.getChild(this._ctx.childCount - 1);\n        this._ctx.removeLastChild();\n        factoredContext._parent = localctx;\n        localctx.addChild(factoredContext);\n      }\n      this._ctx = localctx;\n      this._ctx._start = this._input.LT(1);\n      if (this._buildParseTrees) {\n        this.addContextToParseTree();\n      }\n      this.triggerEnterRuleEvent();\n    }\n    exitRule() {\n      if (this.matchedEOF) {\n        this._ctx._stop = this._input.LT(1);\n      } else {\n        this._ctx._stop = this._input.tryLT(-1);\n      }\n      this.triggerExitRuleEvent();\n      this.state = this._ctx.invokingState;\n      this._ctx = this._ctx._parent;\n    }\n    enterOuterAlt(localctx, altNum) {\n      localctx.altNumber = altNum;\n      if (this._buildParseTrees && this._ctx !== localctx) {\n        let parent = this._ctx._parent;\n        if (parent != null) {\n          parent.removeLastChild();\n          parent.addChild(localctx);\n        }\n      }\n      this._ctx = localctx;\n    }\n    get precedence() {\n      if (this._precedenceStack.isEmpty) {\n        return -1;\n      }\n      return this._precedenceStack.peek();\n    }\n    enterRecursionRule(localctx, state, ruleIndex, precedence) {\n      this.state = state;\n      this._precedenceStack.push(precedence);\n      this._ctx = localctx;\n      this._ctx._start = this._input.LT(1);\n      this.triggerEnterRuleEvent();\n    }\n    pushNewRecursionContext(localctx, state, ruleIndex) {\n      let previous = this._ctx;\n      previous._parent = localctx;\n      previous.invokingState = state;\n      previous._stop = this._input.tryLT(-1);\n      this._ctx = localctx;\n      this._ctx._start = previous._start;\n      if (this._buildParseTrees) {\n        this._ctx.addChild(previous);\n      }\n      this.triggerEnterRuleEvent();\n    }\n    unrollRecursionContexts(_parentctx) {\n      this._precedenceStack.pop();\n      this._ctx._stop = this._input.tryLT(-1);\n      let retctx = this._ctx;\n      if (this._parseListeners.length > 0) {\n        while (this._ctx !== _parentctx) {\n          this.triggerExitRuleEvent();\n          this._ctx = this._ctx._parent;\n        }\n      } else {\n        this._ctx = _parentctx;\n      }\n      retctx._parent = _parentctx;\n      if (this._buildParseTrees && _parentctx != null) {\n        _parentctx.addChild(retctx);\n      }\n    }\n    getInvokingContext(ruleIndex) {\n      let p = this._ctx;\n      while (p && p.ruleIndex !== ruleIndex) {\n        p = p._parent;\n      }\n      return p;\n    }\n    get context() {\n      return this._ctx;\n    }\n    set context(ctx) {\n      this._ctx = ctx;\n    }\n    precpred(localctx, precedence) {\n      return precedence >= this._precedenceStack.peek();\n    }\n    getErrorListenerDispatch() {\n      return new ProxyParserErrorListener_1.ProxyParserErrorListener(this.getErrorListeners());\n    }\n    inContext(context) {\n      return false;\n    }\n    isExpectedToken(symbol) {\n      let atn = this.interpreter.atn;\n      let ctx = this._ctx;\n      let s = atn.states[this.state];\n      let following = atn.nextTokens(s);\n      if (following.contains(symbol)) {\n        return true;\n      }\n      if (!following.contains(Token_1.Token.EPSILON)) {\n        return false;\n      }\n      while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {\n        let invokingState = atn.states[ctx.invokingState];\n        let rt = invokingState.transition(0);\n        following = atn.nextTokens(rt.followState);\n        if (following.contains(symbol)) {\n          return true;\n        }\n        ctx = ctx._parent;\n      }\n      if (following.contains(Token_1.Token.EPSILON) && symbol === Token_1.Token.EOF) {\n        return true;\n      }\n      return false;\n    }\n    get isMatchedEOF() {\n      return this.matchedEOF;\n    }\n    getExpectedTokens() {\n      return this.atn.getExpectedTokens(this.state, this.context);\n    }\n    getExpectedTokensWithinCurrentRule() {\n      let atn = this.interpreter.atn;\n      let s = atn.states[this.state];\n      return atn.nextTokens(s);\n    }\n    getRuleIndex(ruleName) {\n      let ruleIndex = this.getRuleIndexMap().get(ruleName);\n      if (ruleIndex != null) {\n        return ruleIndex;\n      }\n      return -1;\n    }\n    get ruleContext() {\n      return this._ctx;\n    }\n    getRuleInvocationStack(ctx = this._ctx) {\n      let p = ctx;\n      let ruleNames = this.ruleNames;\n      let stack = [];\n      while (p != null) {\n        let ruleIndex = p.ruleIndex;\n        if (ruleIndex < 0) {\n          stack.push(\"n/a\");\n        } else {\n          stack.push(ruleNames[ruleIndex]);\n        }\n        p = p._parent;\n      }\n      return stack;\n    }\n    getDFAStrings() {\n      let s = [];\n      for (let dfa of this._interp.atn.decisionToDFA) {\n        s.push(dfa.toString(this.vocabulary, this.ruleNames));\n      }\n      return s;\n    }\n    dumpDFA() {\n      let seenOne = false;\n      for (let dfa of this._interp.atn.decisionToDFA) {\n        if (!dfa.isEmpty) {\n          if (seenOne) {\n            console.log();\n          }\n          console.log(\"Decision \" + dfa.decision + \":\");\n          process.stdout.write(dfa.toString(this.vocabulary, this.ruleNames));\n          seenOne = true;\n        }\n      }\n    }\n    get sourceName() {\n      return this._input.sourceName;\n    }\n    get parseInfo() {\n      return Promise.resolve().then(() => require_ProfilingATNSimulator()).then((m) => {\n        let interp = this.interpreter;\n        if (interp instanceof m.ProfilingATNSimulator) {\n          return new ParseInfo_1.ParseInfo(interp);\n        }\n        return void 0;\n      });\n    }\n    setProfile(profile) {\n      return __awaiter(this, void 0, void 0, function* () {\n        let m = yield Promise.resolve().then(() => require_ProfilingATNSimulator());\n        let interp = this.interpreter;\n        if (profile) {\n          if (!(interp instanceof m.ProfilingATNSimulator)) {\n            this.interpreter = new m.ProfilingATNSimulator(this);\n          }\n        } else if (interp instanceof m.ProfilingATNSimulator) {\n          this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this.atn, this);\n        }\n        this.interpreter.setPredictionMode(interp.getPredictionMode());\n      });\n    }\n    set isTrace(trace) {\n      if (!trace) {\n        if (this._tracer) {\n          this.removeParseListener(this._tracer);\n          this._tracer = void 0;\n        }\n      } else {\n        if (this._tracer) {\n          this.removeParseListener(this._tracer);\n        } else {\n          this._tracer = new TraceListener(this.ruleNames, this._input);\n        }\n        this.addParseListener(this._tracer);\n      }\n    }\n    get isTrace() {\n      return this._tracer != null;\n    }\n  };\n  Parser2.bypassAltsAtnCache = new Map();\n  __decorate([\n    Decorators_1.NotNull\n  ], Parser2.prototype, \"_errHandler\", void 0);\n  __decorate([\n    Decorators_1.NotNull\n  ], Parser2.prototype, \"match\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], Parser2.prototype, \"matchWildcard\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], Parser2.prototype, \"getParseListeners\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], Parser2.prototype, \"addParseListener\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], Parser2.prototype, \"getATNWithBypassAlts\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n  ], Parser2.prototype, \"errorHandler\", null);\n  __decorate([\n    Decorators_1.Override\n  ], Parser2.prototype, \"inputStream\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], Parser2.prototype, \"currentToken\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], Parser2.prototype, \"enterRule\", null);\n  __decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.Nullable)\n  ], Parser2.prototype, \"precpred\", null);\n  __decorate([\n    Decorators_1.Override\n  ], Parser2.prototype, \"getErrorListenerDispatch\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], Parser2.prototype, \"getExpectedTokens\", null);\n  __decorate([\n    Decorators_1.NotNull\n  ], Parser2.prototype, \"getExpectedTokensWithinCurrentRule\", null);\n  __decorate([\n    Decorators_1.Override\n  ], Parser2.prototype, \"parseInfo\", null);\n  exports.Parser = Parser2;\n});\n\n// node_modules/antlr4ts/NoViableAltException.js\nvar require_NoViableAltException = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.NoViableAltException = void 0;\n  var Parser_1 = require_Parser();\n  var RecognitionException_1 = require_RecognitionException();\n  var Decorators_1 = require_Decorators();\n  var NoViableAltException2 = class extends RecognitionException_1.RecognitionException {\n    constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {\n      if (recognizer instanceof Parser_1.Parser) {\n        if (input === void 0) {\n          input = recognizer.inputStream;\n        }\n        if (startToken === void 0) {\n          startToken = recognizer.currentToken;\n        }\n        if (offendingToken === void 0) {\n          offendingToken = recognizer.currentToken;\n        }\n        if (ctx === void 0) {\n          ctx = recognizer.context;\n        }\n      }\n      super(recognizer, input, ctx);\n      this._deadEndConfigs = deadEndConfigs;\n      this._startToken = startToken;\n      this.setOffendingToken(recognizer, offendingToken);\n    }\n    get startToken() {\n      return this._startToken;\n    }\n    get deadEndConfigs() {\n      return this._deadEndConfigs;\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], NoViableAltException2.prototype, \"_startToken\", void 0);\n  exports.NoViableAltException = NoViableAltException2;\n});\n\n// node_modules/antlr4ts/DefaultErrorStrategy.js\nvar require_DefaultErrorStrategy = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.DefaultErrorStrategy = void 0;\n  var ATNState_1 = require_ATNState();\n  var ATNStateType_1 = require_ATNStateType();\n  var FailedPredicateException_1 = require_FailedPredicateException();\n  var InputMismatchException_1 = require_InputMismatchException();\n  var IntervalSet_1 = require_IntervalSet();\n  var NoViableAltException_1 = require_NoViableAltException();\n  var PredictionContext_1 = require_PredictionContext();\n  var Token_1 = require_Token();\n  var Decorators_1 = require_Decorators();\n  var DefaultErrorStrategy = class {\n    constructor() {\n      this.errorRecoveryMode = false;\n      this.lastErrorIndex = -1;\n      this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;\n    }\n    reset(recognizer) {\n      this.endErrorCondition(recognizer);\n    }\n    beginErrorCondition(recognizer) {\n      this.errorRecoveryMode = true;\n    }\n    inErrorRecoveryMode(recognizer) {\n      return this.errorRecoveryMode;\n    }\n    endErrorCondition(recognizer) {\n      this.errorRecoveryMode = false;\n      this.lastErrorStates = void 0;\n      this.lastErrorIndex = -1;\n    }\n    reportMatch(recognizer) {\n      this.endErrorCondition(recognizer);\n    }\n    reportError(recognizer, e) {\n      if (this.inErrorRecoveryMode(recognizer)) {\n        return;\n      }\n      this.beginErrorCondition(recognizer);\n      if (e instanceof NoViableAltException_1.NoViableAltException) {\n        this.reportNoViableAlternative(recognizer, e);\n      } else if (e instanceof InputMismatchException_1.InputMismatchException) {\n        this.reportInputMismatch(recognizer, e);\n      } else if (e instanceof FailedPredicateException_1.FailedPredicateException) {\n        this.reportFailedPredicate(recognizer, e);\n      } else {\n        console.error(`unknown recognition error type: ${e}`);\n        this.notifyErrorListeners(recognizer, e.toString(), e);\n      }\n    }\n    notifyErrorListeners(recognizer, message, e) {\n      let offendingToken = e.getOffendingToken(recognizer);\n      if (offendingToken === void 0) {\n        offendingToken = null;\n      }\n      recognizer.notifyErrorListeners(message, offendingToken, e);\n    }\n    recover(recognizer, e) {\n      if (this.lastErrorIndex === recognizer.inputStream.index && this.lastErrorStates && this.lastErrorStates.contains(recognizer.state)) {\n        recognizer.consume();\n      }\n      this.lastErrorIndex = recognizer.inputStream.index;\n      if (!this.lastErrorStates) {\n        this.lastErrorStates = new IntervalSet_1.IntervalSet();\n      }\n      this.lastErrorStates.add(recognizer.state);\n      let followSet = this.getErrorRecoverySet(recognizer);\n      this.consumeUntil(recognizer, followSet);\n    }\n    sync(recognizer) {\n      let s = recognizer.interpreter.atn.states[recognizer.state];\n      if (this.inErrorRecoveryMode(recognizer)) {\n        return;\n      }\n      let tokens2 = recognizer.inputStream;\n      let la = tokens2.LA(1);\n      let nextTokens = recognizer.atn.nextTokens(s);\n      if (nextTokens.contains(la)) {\n        this.nextTokensContext = void 0;\n        this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;\n        return;\n      }\n      if (nextTokens.contains(Token_1.Token.EPSILON)) {\n        if (this.nextTokensContext === void 0) {\n          this.nextTokensContext = recognizer.context;\n          this.nextTokensState = recognizer.state;\n        }\n        return;\n      }\n      switch (s.stateType) {\n        case ATNStateType_1.ATNStateType.BLOCK_START:\n        case ATNStateType_1.ATNStateType.STAR_BLOCK_START:\n        case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:\n        case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:\n          if (this.singleTokenDeletion(recognizer)) {\n            return;\n          }\n          throw new InputMismatchException_1.InputMismatchException(recognizer);\n        case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:\n        case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:\n          this.reportUnwantedToken(recognizer);\n          let expecting = recognizer.getExpectedTokens();\n          let whatFollowsLoopIterationOrRule = expecting.or(this.getErrorRecoverySet(recognizer));\n          this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);\n          break;\n        default:\n          break;\n      }\n    }\n    reportNoViableAlternative(recognizer, e) {\n      let tokens2 = recognizer.inputStream;\n      let input;\n      if (tokens2) {\n        if (e.startToken.type === Token_1.Token.EOF) {\n          input = \"<EOF>\";\n        } else {\n          input = tokens2.getTextFromRange(e.startToken, e.getOffendingToken());\n        }\n      } else {\n        input = \"<unknown input>\";\n      }\n      let msg = \"no viable alternative at input \" + this.escapeWSAndQuote(input);\n      this.notifyErrorListeners(recognizer, msg, e);\n    }\n    reportInputMismatch(recognizer, e) {\n      let expected = e.expectedTokens;\n      let expectedString = expected ? expected.toStringVocabulary(recognizer.vocabulary) : \"\";\n      let msg = \"mismatched input \" + this.getTokenErrorDisplay(e.getOffendingToken(recognizer)) + \" expecting \" + expectedString;\n      this.notifyErrorListeners(recognizer, msg, e);\n    }\n    reportFailedPredicate(recognizer, e) {\n      let ruleName = recognizer.ruleNames[recognizer.context.ruleIndex];\n      let msg = \"rule \" + ruleName + \" \" + e.message;\n      this.notifyErrorListeners(recognizer, msg, e);\n    }\n    reportUnwantedToken(recognizer) {\n      if (this.inErrorRecoveryMode(recognizer)) {\n        return;\n      }\n      this.beginErrorCondition(recognizer);\n      let t = recognizer.currentToken;\n      let tokenName = this.getTokenErrorDisplay(t);\n      let expecting = this.getExpectedTokens(recognizer);\n      let msg = \"extraneous input \" + tokenName + \" expecting \" + expecting.toStringVocabulary(recognizer.vocabulary);\n      recognizer.notifyErrorListeners(msg, t, void 0);\n    }\n    reportMissingToken(recognizer) {\n      if (this.inErrorRecoveryMode(recognizer)) {\n        return;\n      }\n      this.beginErrorCondition(recognizer);\n      let t = recognizer.currentToken;\n      let expecting = this.getExpectedTokens(recognizer);\n      let msg = \"missing \" + expecting.toStringVocabulary(recognizer.vocabulary) + \" at \" + this.getTokenErrorDisplay(t);\n      recognizer.notifyErrorListeners(msg, t, void 0);\n    }\n    recoverInline(recognizer) {\n      let matchedSymbol = this.singleTokenDeletion(recognizer);\n      if (matchedSymbol) {\n        recognizer.consume();\n        return matchedSymbol;\n      }\n      if (this.singleTokenInsertion(recognizer)) {\n        return this.getMissingSymbol(recognizer);\n      }\n      if (this.nextTokensContext === void 0) {\n        throw new InputMismatchException_1.InputMismatchException(recognizer);\n      } else {\n        throw new InputMismatchException_1.InputMismatchException(recognizer, this.nextTokensState, this.nextTokensContext);\n      }\n    }\n    singleTokenInsertion(recognizer) {\n      let currentSymbolType = recognizer.inputStream.LA(1);\n      let currentState = recognizer.interpreter.atn.states[recognizer.state];\n      let next = currentState.transition(0).target;\n      let atn = recognizer.interpreter.atn;\n      let expectingAtLL2 = atn.nextTokens(next, PredictionContext_1.PredictionContext.fromRuleContext(atn, recognizer.context));\n      if (expectingAtLL2.contains(currentSymbolType)) {\n        this.reportMissingToken(recognizer);\n        return true;\n      }\n      return false;\n    }\n    singleTokenDeletion(recognizer) {\n      let nextTokenType = recognizer.inputStream.LA(2);\n      let expecting = this.getExpectedTokens(recognizer);\n      if (expecting.contains(nextTokenType)) {\n        this.reportUnwantedToken(recognizer);\n        recognizer.consume();\n        let matchedSymbol = recognizer.currentToken;\n        this.reportMatch(recognizer);\n        return matchedSymbol;\n      }\n      return void 0;\n    }\n    getMissingSymbol(recognizer) {\n      let currentSymbol = recognizer.currentToken;\n      let expecting = this.getExpectedTokens(recognizer);\n      let expectedTokenType = Token_1.Token.INVALID_TYPE;\n      if (!expecting.isNil) {\n        expectedTokenType = expecting.minElement;\n      }\n      let tokenText;\n      if (expectedTokenType === Token_1.Token.EOF) {\n        tokenText = \"<missing EOF>\";\n      } else {\n        tokenText = \"<missing \" + recognizer.vocabulary.getDisplayName(expectedTokenType) + \">\";\n      }\n      let current = currentSymbol;\n      let lookback = recognizer.inputStream.tryLT(-1);\n      if (current.type === Token_1.Token.EOF && lookback != null) {\n        current = lookback;\n      }\n      return this.constructToken(recognizer.inputStream.tokenSource, expectedTokenType, tokenText, current);\n    }\n    constructToken(tokenSource, expectedTokenType, tokenText, current) {\n      let factory = tokenSource.tokenFactory;\n      let x = current.tokenSource;\n      let stream = x ? x.inputStream : void 0;\n      return factory.create({source: tokenSource, stream}, expectedTokenType, tokenText, Token_1.Token.DEFAULT_CHANNEL, -1, -1, current.line, current.charPositionInLine);\n    }\n    getExpectedTokens(recognizer) {\n      return recognizer.getExpectedTokens();\n    }\n    getTokenErrorDisplay(t) {\n      if (!t) {\n        return \"<no token>\";\n      }\n      let s = this.getSymbolText(t);\n      if (!s) {\n        if (this.getSymbolType(t) === Token_1.Token.EOF) {\n          s = \"<EOF>\";\n        } else {\n          s = `<${this.getSymbolType(t)}>`;\n        }\n      }\n      return this.escapeWSAndQuote(s);\n    }\n    getSymbolText(symbol) {\n      return symbol.text;\n    }\n    getSymbolType(symbol) {\n      return symbol.type;\n    }\n    escapeWSAndQuote(s) {\n      s = s.replace(\"\\n\", \"\\\\n\");\n      s = s.replace(\"\\r\", \"\\\\r\");\n      s = s.replace(\"\t\", \"\\\\t\");\n      return \"'\" + s + \"'\";\n    }\n    getErrorRecoverySet(recognizer) {\n      let atn = recognizer.interpreter.atn;\n      let ctx = recognizer.context;\n      let recoverSet = new IntervalSet_1.IntervalSet();\n      while (ctx && ctx.invokingState >= 0) {\n        let invokingState = atn.states[ctx.invokingState];\n        let rt = invokingState.transition(0);\n        let follow = atn.nextTokens(rt.followState);\n        recoverSet.addAll(follow);\n        ctx = ctx._parent;\n      }\n      recoverSet.remove(Token_1.Token.EPSILON);\n      return recoverSet;\n    }\n    consumeUntil(recognizer, set) {\n      let ttype = recognizer.inputStream.LA(1);\n      while (ttype !== Token_1.Token.EOF && !set.contains(ttype)) {\n        recognizer.consume();\n        ttype = recognizer.inputStream.LA(1);\n      }\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], DefaultErrorStrategy.prototype, \"reset\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], DefaultErrorStrategy.prototype, \"beginErrorCondition\", null);\n  __decorate([\n    Decorators_1.Override\n  ], DefaultErrorStrategy.prototype, \"inErrorRecoveryMode\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], DefaultErrorStrategy.prototype, \"endErrorCondition\", null);\n  __decorate([\n    Decorators_1.Override\n  ], DefaultErrorStrategy.prototype, \"reportMatch\", null);\n  __decorate([\n    Decorators_1.Override\n  ], DefaultErrorStrategy.prototype, \"reportError\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], DefaultErrorStrategy.prototype, \"notifyErrorListeners\", null);\n  __decorate([\n    Decorators_1.Override\n  ], DefaultErrorStrategy.prototype, \"recover\", null);\n  __decorate([\n    Decorators_1.Override\n  ], DefaultErrorStrategy.prototype, \"sync\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n  ], DefaultErrorStrategy.prototype, \"reportNoViableAlternative\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n  ], DefaultErrorStrategy.prototype, \"reportInputMismatch\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n  ], DefaultErrorStrategy.prototype, \"reportFailedPredicate\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], DefaultErrorStrategy.prototype, \"reportUnwantedToken\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], DefaultErrorStrategy.prototype, \"reportMissingToken\", null);\n  __decorate([\n    Decorators_1.Override\n  ], DefaultErrorStrategy.prototype, \"recoverInline\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], DefaultErrorStrategy.prototype, \"singleTokenInsertion\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], DefaultErrorStrategy.prototype, \"singleTokenDeletion\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n  ], DefaultErrorStrategy.prototype, \"getMissingSymbol\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n  ], DefaultErrorStrategy.prototype, \"getExpectedTokens\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], DefaultErrorStrategy.prototype, \"getSymbolText\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], DefaultErrorStrategy.prototype, \"getSymbolType\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n  ], DefaultErrorStrategy.prototype, \"escapeWSAndQuote\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n  ], DefaultErrorStrategy.prototype, \"getErrorRecoverySet\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n  ], DefaultErrorStrategy.prototype, \"consumeUntil\", null);\n  exports.DefaultErrorStrategy = DefaultErrorStrategy;\n});\n\n// node_modules/antlr4ts/BailErrorStrategy.js\nvar require_BailErrorStrategy = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.BailErrorStrategy = void 0;\n  var DefaultErrorStrategy_1 = require_DefaultErrorStrategy();\n  var InputMismatchException_1 = require_InputMismatchException();\n  var Decorators_1 = require_Decorators();\n  var ParseCancellationException_1 = require_ParseCancellationException();\n  var BailErrorStrategy = class extends DefaultErrorStrategy_1.DefaultErrorStrategy {\n    recover(recognizer, e) {\n      for (let context = recognizer.context; context; context = context.parent) {\n        context.exception = e;\n      }\n      throw new ParseCancellationException_1.ParseCancellationException(e);\n    }\n    recoverInline(recognizer) {\n      let e = new InputMismatchException_1.InputMismatchException(recognizer);\n      for (let context = recognizer.context; context; context = context.parent) {\n        context.exception = e;\n      }\n      throw new ParseCancellationException_1.ParseCancellationException(e);\n    }\n    sync(recognizer) {\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], BailErrorStrategy.prototype, \"recover\", null);\n  __decorate([\n    Decorators_1.Override\n  ], BailErrorStrategy.prototype, \"recoverInline\", null);\n  __decorate([\n    Decorators_1.Override\n  ], BailErrorStrategy.prototype, \"sync\", null);\n  exports.BailErrorStrategy = BailErrorStrategy;\n});\n\n// node_modules/antlr4ts/CharStream.js\nvar require_CharStream = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n});\n\n// node_modules/antlr4ts/Dependents.js\nvar require_Dependents = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.Dependents = void 0;\n  var Dependents;\n  (function(Dependents2) {\n    Dependents2[Dependents2[\"SELF\"] = 0] = \"SELF\";\n    Dependents2[Dependents2[\"PARENTS\"] = 1] = \"PARENTS\";\n    Dependents2[Dependents2[\"CHILDREN\"] = 2] = \"CHILDREN\";\n    Dependents2[Dependents2[\"ANCESTORS\"] = 3] = \"ANCESTORS\";\n    Dependents2[Dependents2[\"DESCENDANTS\"] = 4] = \"DESCENDANTS\";\n    Dependents2[Dependents2[\"SIBLINGS\"] = 5] = \"SIBLINGS\";\n    Dependents2[Dependents2[\"PRECEEDING_SIBLINGS\"] = 6] = \"PRECEEDING_SIBLINGS\";\n    Dependents2[Dependents2[\"FOLLOWING_SIBLINGS\"] = 7] = \"FOLLOWING_SIBLINGS\";\n    Dependents2[Dependents2[\"PRECEEDING\"] = 8] = \"PRECEEDING\";\n    Dependents2[Dependents2[\"FOLLOWING\"] = 9] = \"FOLLOWING\";\n  })(Dependents = exports.Dependents || (exports.Dependents = {}));\n});\n\n// node_modules/antlr4ts/DiagnosticErrorListener.js\nvar require_DiagnosticErrorListener = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.DiagnosticErrorListener = void 0;\n  var BitSet_1 = require_BitSet();\n  var Decorators_1 = require_Decorators();\n  var Interval_1 = require_Interval();\n  var DiagnosticErrorListener = class {\n    constructor(exactOnly = true) {\n      this.exactOnly = exactOnly;\n      this.exactOnly = exactOnly;\n    }\n    syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {\n    }\n    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n      if (this.exactOnly && !exact) {\n        return;\n      }\n      let decision = this.getDecisionDescription(recognizer, dfa);\n      let conflictingAlts = this.getConflictingAlts(ambigAlts, configs);\n      let text = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));\n      let message = `reportAmbiguity d=${decision}: ambigAlts=${conflictingAlts}, input='${text}'`;\n      recognizer.notifyErrorListeners(message);\n    }\n    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState) {\n      let format = \"reportAttemptingFullContext d=%s, input='%s'\";\n      let decision = this.getDecisionDescription(recognizer, dfa);\n      let text = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));\n      let message = `reportAttemptingFullContext d=${decision}, input='${text}'`;\n      recognizer.notifyErrorListeners(message);\n    }\n    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState) {\n      let format = \"reportContextSensitivity d=%s, input='%s'\";\n      let decision = this.getDecisionDescription(recognizer, dfa);\n      let text = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));\n      let message = `reportContextSensitivity d=${decision}, input='${text}'`;\n      recognizer.notifyErrorListeners(message);\n    }\n    getDecisionDescription(recognizer, dfa) {\n      let decision = dfa.decision;\n      let ruleIndex = dfa.atnStartState.ruleIndex;\n      let ruleNames = recognizer.ruleNames;\n      if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {\n        return decision.toString();\n      }\n      let ruleName = ruleNames[ruleIndex];\n      if (!ruleName) {\n        return decision.toString();\n      }\n      return `${decision} (${ruleName})`;\n    }\n    getConflictingAlts(reportedAlts, configs) {\n      if (reportedAlts != null) {\n        return reportedAlts;\n      }\n      let result = new BitSet_1.BitSet();\n      for (let config of configs) {\n        result.set(config.alt);\n      }\n      return result;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], DiagnosticErrorListener.prototype, \"syntaxError\", null);\n  __decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(6, Decorators_1.NotNull)\n  ], DiagnosticErrorListener.prototype, \"reportAmbiguity\", null);\n  __decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(5, Decorators_1.NotNull)\n  ], DiagnosticErrorListener.prototype, \"reportAttemptingFullContext\", null);\n  __decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(5, Decorators_1.NotNull)\n  ], DiagnosticErrorListener.prototype, \"reportContextSensitivity\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n  ], DiagnosticErrorListener.prototype, \"getDecisionDescription\", null);\n  __decorate([\n    Decorators_1.NotNull,\n    __param(1, Decorators_1.NotNull)\n  ], DiagnosticErrorListener.prototype, \"getConflictingAlts\", null);\n  exports.DiagnosticErrorListener = DiagnosticErrorListener;\n});\n\n// node_modules/antlr4ts/LexerInterpreter.js\nvar require_LexerInterpreter = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.LexerInterpreter = void 0;\n  var Lexer_1 = require_Lexer();\n  var LexerATNSimulator_1 = require_LexerATNSimulator();\n  var Decorators_1 = require_Decorators();\n  var Decorators_2 = require_Decorators();\n  var LexerInterpreter = class LexerInterpreter extends Lexer_1.Lexer {\n    constructor(grammarFileName, vocabulary, ruleNames, channelNames, modeNames, atn, input) {\n      super(input);\n      if (atn.grammarType !== 0) {\n        throw new Error(\"IllegalArgumentException: The ATN must be a lexer ATN.\");\n      }\n      this._grammarFileName = grammarFileName;\n      this._atn = atn;\n      this._ruleNames = ruleNames.slice(0);\n      this._channelNames = channelNames.slice(0);\n      this._modeNames = modeNames.slice(0);\n      this._vocabulary = vocabulary;\n      this._interp = new LexerATNSimulator_1.LexerATNSimulator(atn, this);\n    }\n    get atn() {\n      return this._atn;\n    }\n    get grammarFileName() {\n      return this._grammarFileName;\n    }\n    get ruleNames() {\n      return this._ruleNames;\n    }\n    get channelNames() {\n      return this._channelNames;\n    }\n    get modeNames() {\n      return this._modeNames;\n    }\n    get vocabulary() {\n      return this._vocabulary;\n    }\n  };\n  __decorate([\n    Decorators_1.NotNull\n  ], LexerInterpreter.prototype, \"_vocabulary\", void 0);\n  __decorate([\n    Decorators_2.Override\n  ], LexerInterpreter.prototype, \"atn\", null);\n  __decorate([\n    Decorators_2.Override\n  ], LexerInterpreter.prototype, \"grammarFileName\", null);\n  __decorate([\n    Decorators_2.Override\n  ], LexerInterpreter.prototype, \"ruleNames\", null);\n  __decorate([\n    Decorators_2.Override\n  ], LexerInterpreter.prototype, \"channelNames\", null);\n  __decorate([\n    Decorators_2.Override\n  ], LexerInterpreter.prototype, \"modeNames\", null);\n  __decorate([\n    Decorators_2.Override\n  ], LexerInterpreter.prototype, \"vocabulary\", null);\n  LexerInterpreter = __decorate([\n    __param(1, Decorators_1.NotNull)\n  ], LexerInterpreter);\n  exports.LexerInterpreter = LexerInterpreter;\n});\n\n// node_modules/antlr4ts/ParserErrorListener.js\nvar require_ParserErrorListener = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n});\n\n// node_modules/antlr4ts/RuleContextWithAltNum.js\nvar require_RuleContextWithAltNum = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.RuleContextWithAltNum = void 0;\n  var ATN_1 = require_ATN();\n  var Decorators_1 = require_Decorators();\n  var ParserRuleContext_1 = require_ParserRuleContext();\n  var RuleContextWithAltNum = class extends ParserRuleContext_1.ParserRuleContext {\n    constructor(parent, invokingStateNumber) {\n      if (invokingStateNumber !== void 0) {\n        super(parent, invokingStateNumber);\n      } else {\n        super();\n      }\n      this._altNumber = ATN_1.ATN.INVALID_ALT_NUMBER;\n    }\n    get altNumber() {\n      return this._altNumber;\n    }\n    set altNumber(altNum) {\n      this._altNumber = altNum;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], RuleContextWithAltNum.prototype, \"altNumber\", null);\n  exports.RuleContextWithAltNum = RuleContextWithAltNum;\n});\n\n// node_modules/antlr4ts/RuleDependency.js\nvar require_RuleDependency = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.RuleDependency = void 0;\n  function RuleDependency(dependency) {\n    return (target, propertyKey, propertyDescriptor) => {\n    };\n  }\n  exports.RuleDependency = RuleDependency;\n});\n\n// node_modules/antlr4ts/RuleVersion.js\nvar require_RuleVersion = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.RuleVersion = void 0;\n  function RuleVersion(version) {\n    return (target, propertyKey, propertyDescriptor) => {\n    };\n  }\n  exports.RuleVersion = RuleVersion;\n});\n\n// node_modules/antlr4ts/TokenFactory.js\nvar require_TokenFactory = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n});\n\n// node_modules/antlr4ts/TokenSource.js\nvar require_TokenSource = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n});\n\n// node_modules/antlr4ts/TokenStream.js\nvar require_TokenStream = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n});\n\n// node_modules/antlr4ts/TokenStreamRewriter.js\nvar require_TokenStreamRewriter = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.RewriteOperation = exports.TokenStreamRewriter = void 0;\n  var Interval_1 = require_Interval();\n  var Decorators_1 = require_Decorators();\n  var Token_1 = require_Token();\n  var TokenStreamRewriter = class {\n    constructor(tokens2) {\n      this.tokens = tokens2;\n      this.programs = new Map();\n      this.programs.set(TokenStreamRewriter.DEFAULT_PROGRAM_NAME, []);\n      this.lastRewriteTokenIndexes = new Map();\n    }\n    getTokenStream() {\n      return this.tokens;\n    }\n    rollback(instructionIndex, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n      let is = this.programs.get(programName);\n      if (is != null) {\n        this.programs.set(programName, is.slice(TokenStreamRewriter.MIN_TOKEN_INDEX, instructionIndex));\n      }\n    }\n    deleteProgram(programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n      this.rollback(TokenStreamRewriter.MIN_TOKEN_INDEX, programName);\n    }\n    insertAfter(tokenOrIndex, text, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n      let index;\n      if (typeof tokenOrIndex === \"number\") {\n        index = tokenOrIndex;\n      } else {\n        index = tokenOrIndex.tokenIndex;\n      }\n      let rewrites = this.getProgram(programName);\n      let op = new InsertAfterOp(this.tokens, index, rewrites.length, text);\n      rewrites.push(op);\n    }\n    insertBefore(tokenOrIndex, text, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n      let index;\n      if (typeof tokenOrIndex === \"number\") {\n        index = tokenOrIndex;\n      } else {\n        index = tokenOrIndex.tokenIndex;\n      }\n      let rewrites = this.getProgram(programName);\n      let op = new InsertBeforeOp(this.tokens, index, rewrites.length, text);\n      rewrites.push(op);\n    }\n    replaceSingle(index, text) {\n      if (typeof index === \"number\") {\n        this.replace(index, index, text);\n      } else {\n        this.replace(index, index, text);\n      }\n    }\n    replace(from, to, text, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n      if (typeof from !== \"number\") {\n        from = from.tokenIndex;\n      }\n      if (typeof to !== \"number\") {\n        to = to.tokenIndex;\n      }\n      if (from > to || from < 0 || to < 0 || to >= this.tokens.size) {\n        throw new RangeError(`replace: range invalid: ${from}..${to}(size=${this.tokens.size})`);\n      }\n      let rewrites = this.getProgram(programName);\n      let op = new ReplaceOp(this.tokens, from, to, rewrites.length, text);\n      rewrites.push(op);\n    }\n    delete(from, to, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n      if (to === void 0) {\n        to = from;\n      }\n      if (typeof from === \"number\") {\n        this.replace(from, to, \"\", programName);\n      } else {\n        this.replace(from, to, \"\", programName);\n      }\n    }\n    getLastRewriteTokenIndex(programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n      let I = this.lastRewriteTokenIndexes.get(programName);\n      if (I == null) {\n        return -1;\n      }\n      return I;\n    }\n    setLastRewriteTokenIndex(programName, i) {\n      this.lastRewriteTokenIndexes.set(programName, i);\n    }\n    getProgram(name) {\n      let is = this.programs.get(name);\n      if (is == null) {\n        is = this.initializeProgram(name);\n      }\n      return is;\n    }\n    initializeProgram(name) {\n      let is = [];\n      this.programs.set(name, is);\n      return is;\n    }\n    getText(intervalOrProgram, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n      let interval;\n      if (intervalOrProgram instanceof Interval_1.Interval) {\n        interval = intervalOrProgram;\n      } else {\n        interval = Interval_1.Interval.of(0, this.tokens.size - 1);\n      }\n      if (typeof intervalOrProgram === \"string\") {\n        programName = intervalOrProgram;\n      }\n      let rewrites = this.programs.get(programName);\n      let start = interval.a;\n      let stop = interval.b;\n      if (stop > this.tokens.size - 1) {\n        stop = this.tokens.size - 1;\n      }\n      if (start < 0) {\n        start = 0;\n      }\n      if (rewrites == null || rewrites.length === 0) {\n        return this.tokens.getText(interval);\n      }\n      let buf = [];\n      let indexToOp = this.reduceToSingleOperationPerIndex(rewrites);\n      let i = start;\n      while (i <= stop && i < this.tokens.size) {\n        let op = indexToOp.get(i);\n        indexToOp.delete(i);\n        let t = this.tokens.get(i);\n        if (op == null) {\n          if (t.type !== Token_1.Token.EOF) {\n            buf.push(String(t.text));\n          }\n          i++;\n        } else {\n          i = op.execute(buf);\n        }\n      }\n      if (stop === this.tokens.size - 1) {\n        for (let op of indexToOp.values()) {\n          if (op.index >= this.tokens.size - 1) {\n            buf.push(op.text.toString());\n          }\n        }\n      }\n      return buf.join(\"\");\n    }\n    reduceToSingleOperationPerIndex(rewrites) {\n      for (let i = 0; i < rewrites.length; i++) {\n        let op = rewrites[i];\n        if (op == null) {\n          continue;\n        }\n        if (!(op instanceof ReplaceOp)) {\n          continue;\n        }\n        let rop = op;\n        let inserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);\n        for (let iop of inserts) {\n          if (iop.index === rop.index) {\n            rewrites[iop.instructionIndex] = void 0;\n            rop.text = iop.text.toString() + (rop.text != null ? rop.text.toString() : \"\");\n          } else if (iop.index > rop.index && iop.index <= rop.lastIndex) {\n            rewrites[iop.instructionIndex] = void 0;\n          }\n        }\n        let prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);\n        for (let prevRop of prevReplaces) {\n          if (prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex) {\n            rewrites[prevRop.instructionIndex] = void 0;\n            continue;\n          }\n          let disjoint = prevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;\n          if (prevRop.text == null && rop.text == null && !disjoint) {\n            rewrites[prevRop.instructionIndex] = void 0;\n            rop.index = Math.min(prevRop.index, rop.index);\n            rop.lastIndex = Math.max(prevRop.lastIndex, rop.lastIndex);\n          } else if (!disjoint) {\n            throw new Error(`replace op boundaries of ${rop} overlap with previous ${prevRop}`);\n          }\n        }\n      }\n      for (let i = 0; i < rewrites.length; i++) {\n        let op = rewrites[i];\n        if (op == null) {\n          continue;\n        }\n        if (!(op instanceof InsertBeforeOp)) {\n          continue;\n        }\n        let iop = op;\n        let prevInserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);\n        for (let prevIop of prevInserts) {\n          if (prevIop.index === iop.index) {\n            if (prevIop instanceof InsertAfterOp) {\n              iop.text = this.catOpText(prevIop.text, iop.text);\n              rewrites[prevIop.instructionIndex] = void 0;\n            } else if (prevIop instanceof InsertBeforeOp) {\n              iop.text = this.catOpText(iop.text, prevIop.text);\n              rewrites[prevIop.instructionIndex] = void 0;\n            }\n          }\n        }\n        let prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);\n        for (let rop of prevReplaces) {\n          if (iop.index === rop.index) {\n            rop.text = this.catOpText(iop.text, rop.text);\n            rewrites[i] = void 0;\n            continue;\n          }\n          if (iop.index >= rop.index && iop.index <= rop.lastIndex) {\n            throw new Error(`insert op ${iop} within boundaries of previous ${rop}`);\n          }\n        }\n      }\n      let m = new Map();\n      for (let op of rewrites) {\n        if (op == null) {\n          continue;\n        }\n        if (m.get(op.index) != null) {\n          throw new Error(\"should only be one op per index\");\n        }\n        m.set(op.index, op);\n      }\n      return m;\n    }\n    catOpText(a, b) {\n      let x = \"\";\n      let y = \"\";\n      if (a != null) {\n        x = a.toString();\n      }\n      if (b != null) {\n        y = b.toString();\n      }\n      return x + y;\n    }\n    getKindOfOps(rewrites, kind, before) {\n      let ops = [];\n      for (let i = 0; i < before && i < rewrites.length; i++) {\n        let op = rewrites[i];\n        if (op == null) {\n          continue;\n        }\n        if (op instanceof kind) {\n          ops.push(op);\n        }\n      }\n      return ops;\n    }\n  };\n  exports.TokenStreamRewriter = TokenStreamRewriter;\n  TokenStreamRewriter.DEFAULT_PROGRAM_NAME = \"default\";\n  TokenStreamRewriter.PROGRAM_INIT_SIZE = 100;\n  TokenStreamRewriter.MIN_TOKEN_INDEX = 0;\n  var RewriteOperation = class {\n    constructor(tokens2, index, instructionIndex, text) {\n      this.tokens = tokens2;\n      this.instructionIndex = instructionIndex;\n      this.index = index;\n      this.text = text === void 0 ? \"\" : text;\n    }\n    execute(buf) {\n      return this.index;\n    }\n    toString() {\n      let opName = this.constructor.name;\n      let $index = opName.indexOf(\"$\");\n      opName = opName.substring($index + 1, opName.length);\n      return \"<\" + opName + \"@\" + this.tokens.get(this.index) + ':\"' + this.text + '\">';\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], RewriteOperation.prototype, \"toString\", null);\n  exports.RewriteOperation = RewriteOperation;\n  var InsertBeforeOp = class extends RewriteOperation {\n    constructor(tokens2, index, instructionIndex, text) {\n      super(tokens2, index, instructionIndex, text);\n    }\n    execute(buf) {\n      buf.push(this.text.toString());\n      if (this.tokens.get(this.index).type !== Token_1.Token.EOF) {\n        buf.push(String(this.tokens.get(this.index).text));\n      }\n      return this.index + 1;\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], InsertBeforeOp.prototype, \"execute\", null);\n  var InsertAfterOp = class extends InsertBeforeOp {\n    constructor(tokens2, index, instructionIndex, text) {\n      super(tokens2, index + 1, instructionIndex, text);\n    }\n  };\n  var ReplaceOp = class extends RewriteOperation {\n    constructor(tokens2, from, to, instructionIndex, text) {\n      super(tokens2, from, instructionIndex, text);\n      this.lastIndex = to;\n    }\n    execute(buf) {\n      if (this.text != null) {\n        buf.push(this.text.toString());\n      }\n      return this.lastIndex + 1;\n    }\n    toString() {\n      if (this.text == null) {\n        return \"<DeleteOp@\" + this.tokens.get(this.index) + \"..\" + this.tokens.get(this.lastIndex) + \">\";\n      }\n      return \"<ReplaceOp@\" + this.tokens.get(this.index) + \"..\" + this.tokens.get(this.lastIndex) + ':\"' + this.text + '\">';\n    }\n  };\n  __decorate([\n    Decorators_1.Override\n  ], ReplaceOp.prototype, \"execute\", null);\n  __decorate([\n    Decorators_1.Override\n  ], ReplaceOp.prototype, \"toString\", null);\n});\n\n// node_modules/antlr4ts/Vocabulary.js\nvar require_Vocabulary = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n});\n\n// node_modules/antlr4ts/WritableToken.js\nvar require_WritableToken = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n});\n\n// node_modules/antlr4ts/index.js\nvar require_antlr4ts = __commonJS((exports) => {\n  \"use strict\";\n  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === void 0)\n      k2 = k;\n    Object.defineProperty(o, k2, {enumerable: true, get: function() {\n      return m[k];\n    }});\n  } : function(o, m, k, k2) {\n    if (k2 === void 0)\n      k2 = k;\n    o[k2] = m[k];\n  });\n  var __exportStar = exports && exports.__exportStar || function(m, exports2) {\n    for (var p in m)\n      if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports2, p))\n        __createBinding(exports2, m, p);\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  __exportStar(require_ANTLRErrorListener(), exports);\n  __exportStar(require_ANTLRErrorStrategy(), exports);\n  __exportStar(require_ANTLRInputStream(), exports);\n  __exportStar(require_BailErrorStrategy(), exports);\n  __exportStar(require_BufferedTokenStream(), exports);\n  __exportStar(require_CharStream(), exports);\n  __exportStar(require_CharStreams(), exports);\n  __exportStar(require_CodePointBuffer(), exports);\n  __exportStar(require_CodePointCharStream(), exports);\n  __exportStar(require_CommonToken(), exports);\n  __exportStar(require_CommonTokenFactory(), exports);\n  __exportStar(require_CommonTokenStream(), exports);\n  __exportStar(require_ConsoleErrorListener(), exports);\n  __exportStar(require_DefaultErrorStrategy(), exports);\n  __exportStar(require_Dependents(), exports);\n  __exportStar(require_DiagnosticErrorListener(), exports);\n  __exportStar(require_FailedPredicateException(), exports);\n  __exportStar(require_InputMismatchException(), exports);\n  __exportStar(require_InterpreterRuleContext(), exports);\n  __exportStar(require_IntStream(), exports);\n  __exportStar(require_Lexer(), exports);\n  __exportStar(require_LexerInterpreter(), exports);\n  __exportStar(require_LexerNoViableAltException(), exports);\n  __exportStar(require_ListTokenSource(), exports);\n  __exportStar(require_NoViableAltException(), exports);\n  __exportStar(require_Parser(), exports);\n  __exportStar(require_ParserErrorListener(), exports);\n  __exportStar(require_ParserInterpreter(), exports);\n  __exportStar(require_ParserRuleContext(), exports);\n  __exportStar(require_ProxyErrorListener(), exports);\n  __exportStar(require_ProxyParserErrorListener(), exports);\n  __exportStar(require_RecognitionException(), exports);\n  __exportStar(require_Recognizer(), exports);\n  __exportStar(require_RuleContext(), exports);\n  __exportStar(require_RuleContextWithAltNum(), exports);\n  __exportStar(require_RuleDependency(), exports);\n  __exportStar(require_RuleVersion(), exports);\n  __exportStar(require_Token(), exports);\n  __exportStar(require_TokenFactory(), exports);\n  __exportStar(require_TokenSource(), exports);\n  __exportStar(require_TokenStream(), exports);\n  __exportStar(require_TokenStreamRewriter(), exports);\n  __exportStar(require_Vocabulary(), exports);\n  __exportStar(require_VocabularyImpl(), exports);\n  __exportStar(require_WritableToken(), exports);\n});\n\n// node_modules/antlr4ts/tree/AbstractParseTreeVisitor.js\nvar require_AbstractParseTreeVisitor = __commonJS((exports) => {\n  \"use strict\";\n  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n      r = Reflect.decorate(decorators, target, key, desc);\n    else\n      for (var i = decorators.length - 1; i >= 0; i--)\n        if (d = decorators[i])\n          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  };\n  var __param = exports && exports.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n      decorator(target, key, paramIndex);\n    };\n  };\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  exports.AbstractParseTreeVisitor = void 0;\n  var Decorators_1 = require_Decorators();\n  var AbstractParseTreeVisitor2 = class {\n    visit(tree) {\n      return tree.accept(this);\n    }\n    visitChildren(node) {\n      let result = this.defaultResult();\n      let n = node.childCount;\n      for (let i = 0; i < n; i++) {\n        if (!this.shouldVisitNextChild(node, result)) {\n          break;\n        }\n        let c = node.getChild(i);\n        let childResult = c.accept(this);\n        result = this.aggregateResult(result, childResult);\n      }\n      return result;\n    }\n    visitTerminal(node) {\n      return this.defaultResult();\n    }\n    visitErrorNode(node) {\n      return this.defaultResult();\n    }\n    aggregateResult(aggregate, nextResult) {\n      return nextResult;\n    }\n    shouldVisitNextChild(node, currentResult) {\n      return true;\n    }\n  };\n  __decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull)\n  ], AbstractParseTreeVisitor2.prototype, \"visit\", null);\n  __decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull)\n  ], AbstractParseTreeVisitor2.prototype, \"visitChildren\", null);\n  __decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull)\n  ], AbstractParseTreeVisitor2.prototype, \"visitTerminal\", null);\n  __decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull)\n  ], AbstractParseTreeVisitor2.prototype, \"visitErrorNode\", null);\n  __decorate([\n    __param(0, Decorators_1.NotNull)\n  ], AbstractParseTreeVisitor2.prototype, \"shouldVisitNextChild\", null);\n  exports.AbstractParseTreeVisitor = AbstractParseTreeVisitor2;\n});\n\n// node_modules/antlr4/src/antlr4/Utils.js\nvar require_Utils2 = __commonJS((exports, module2) => {\n  function arrayToString(a) {\n    return Array.isArray(a) ? \"[\" + a.join(\", \") + \"]\" : \"null\";\n  }\n  String.prototype.seed = String.prototype.seed || Math.round(Math.random() * Math.pow(2, 32));\n  String.prototype.hashCode = function() {\n    const key = this.toString();\n    let h1b, k1;\n    const remainder = key.length & 3;\n    const bytes = key.length - remainder;\n    let h1 = String.prototype.seed;\n    const c1 = 3432918353;\n    const c2 = 461845907;\n    let i = 0;\n    while (i < bytes) {\n      k1 = key.charCodeAt(i) & 255 | (key.charCodeAt(++i) & 255) << 8 | (key.charCodeAt(++i) & 255) << 16 | (key.charCodeAt(++i) & 255) << 24;\n      ++i;\n      k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;\n      k1 = k1 << 15 | k1 >>> 17;\n      k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;\n      h1 ^= k1;\n      h1 = h1 << 13 | h1 >>> 19;\n      h1b = (h1 & 65535) * 5 + (((h1 >>> 16) * 5 & 65535) << 16) & 4294967295;\n      h1 = (h1b & 65535) + 27492 + (((h1b >>> 16) + 58964 & 65535) << 16);\n    }\n    k1 = 0;\n    switch (remainder) {\n      case 3:\n        k1 ^= (key.charCodeAt(i + 2) & 255) << 16;\n      case 2:\n        k1 ^= (key.charCodeAt(i + 1) & 255) << 8;\n      case 1:\n        k1 ^= key.charCodeAt(i) & 255;\n        k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;\n        k1 = k1 << 15 | k1 >>> 17;\n        k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;\n        h1 ^= k1;\n    }\n    h1 ^= key.length;\n    h1 ^= h1 >>> 16;\n    h1 = (h1 & 65535) * 2246822507 + (((h1 >>> 16) * 2246822507 & 65535) << 16) & 4294967295;\n    h1 ^= h1 >>> 13;\n    h1 = (h1 & 65535) * 3266489909 + (((h1 >>> 16) * 3266489909 & 65535) << 16) & 4294967295;\n    h1 ^= h1 >>> 16;\n    return h1 >>> 0;\n  };\n  function standardEqualsFunction(a, b) {\n    return a ? a.equals(b) : a == b;\n  }\n  function standardHashCodeFunction(a) {\n    return a ? a.hashCode() : -1;\n  }\n  var Set2 = class {\n    constructor(hashFunction, equalsFunction) {\n      this.data = {};\n      this.hashFunction = hashFunction || standardHashCodeFunction;\n      this.equalsFunction = equalsFunction || standardEqualsFunction;\n    }\n    add(value) {\n      const hash = this.hashFunction(value);\n      const key = \"hash_\" + hash;\n      if (key in this.data) {\n        const values = this.data[key];\n        for (let i = 0; i < values.length; i++) {\n          if (this.equalsFunction(value, values[i])) {\n            return values[i];\n          }\n        }\n        values.push(value);\n        return value;\n      } else {\n        this.data[key] = [value];\n        return value;\n      }\n    }\n    contains(value) {\n      return this.get(value) != null;\n    }\n    get(value) {\n      const hash = this.hashFunction(value);\n      const key = \"hash_\" + hash;\n      if (key in this.data) {\n        const values = this.data[key];\n        for (let i = 0; i < values.length; i++) {\n          if (this.equalsFunction(value, values[i])) {\n            return values[i];\n          }\n        }\n      }\n      return null;\n    }\n    values() {\n      let l = [];\n      for (const key in this.data) {\n        if (key.indexOf(\"hash_\") === 0) {\n          l = l.concat(this.data[key]);\n        }\n      }\n      return l;\n    }\n    toString() {\n      return arrayToString(this.values());\n    }\n    get length() {\n      let l = 0;\n      for (const key in this.data) {\n        if (key.indexOf(\"hash_\") === 0) {\n          l = l + this.data[key].length;\n        }\n      }\n      return l;\n    }\n  };\n  var BitSet = class {\n    constructor() {\n      this.data = [];\n    }\n    add(value) {\n      this.data[value] = true;\n    }\n    or(set) {\n      const bits = this;\n      Object.keys(set.data).map(function(alt) {\n        bits.add(alt);\n      });\n    }\n    remove(value) {\n      delete this.data[value];\n    }\n    contains(value) {\n      return this.data[value] === true;\n    }\n    values() {\n      return Object.keys(this.data);\n    }\n    minValue() {\n      return Math.min.apply(null, this.values());\n    }\n    hashCode() {\n      const hash = new Hash2();\n      hash.update(this.values());\n      return hash.finish();\n    }\n    equals(other) {\n      if (!(other instanceof BitSet)) {\n        return false;\n      }\n      return this.hashCode() === other.hashCode();\n    }\n    toString() {\n      return \"{\" + this.values().join(\", \") + \"}\";\n    }\n    get length() {\n      return this.values().length;\n    }\n  };\n  var Map2 = class {\n    constructor(hashFunction, equalsFunction) {\n      this.data = {};\n      this.hashFunction = hashFunction || standardHashCodeFunction;\n      this.equalsFunction = equalsFunction || standardEqualsFunction;\n    }\n    put(key, value) {\n      const hashKey = \"hash_\" + this.hashFunction(key);\n      if (hashKey in this.data) {\n        const entries = this.data[hashKey];\n        for (let i = 0; i < entries.length; i++) {\n          const entry = entries[i];\n          if (this.equalsFunction(key, entry.key)) {\n            const oldValue = entry.value;\n            entry.value = value;\n            return oldValue;\n          }\n        }\n        entries.push({key, value});\n        return value;\n      } else {\n        this.data[hashKey] = [{key, value}];\n        return value;\n      }\n    }\n    containsKey(key) {\n      const hashKey = \"hash_\" + this.hashFunction(key);\n      if (hashKey in this.data) {\n        const entries = this.data[hashKey];\n        for (let i = 0; i < entries.length; i++) {\n          const entry = entries[i];\n          if (this.equalsFunction(key, entry.key))\n            return true;\n        }\n      }\n      return false;\n    }\n    get(key) {\n      const hashKey = \"hash_\" + this.hashFunction(key);\n      if (hashKey in this.data) {\n        const entries = this.data[hashKey];\n        for (let i = 0; i < entries.length; i++) {\n          const entry = entries[i];\n          if (this.equalsFunction(key, entry.key))\n            return entry.value;\n        }\n      }\n      return null;\n    }\n    entries() {\n      let l = [];\n      for (const key in this.data) {\n        if (key.indexOf(\"hash_\") === 0) {\n          l = l.concat(this.data[key]);\n        }\n      }\n      return l;\n    }\n    getKeys() {\n      return this.entries().map(function(e) {\n        return e.key;\n      });\n    }\n    getValues() {\n      return this.entries().map(function(e) {\n        return e.value;\n      });\n    }\n    toString() {\n      const ss = this.entries().map(function(entry) {\n        return \"{\" + entry.key + \":\" + entry.value + \"}\";\n      });\n      return \"[\" + ss.join(\", \") + \"]\";\n    }\n    get length() {\n      let l = 0;\n      for (const hashKey in this.data) {\n        if (hashKey.indexOf(\"hash_\") === 0) {\n          l = l + this.data[hashKey].length;\n        }\n      }\n      return l;\n    }\n  };\n  var AltDict = class {\n    constructor() {\n      this.data = {};\n    }\n    get(key) {\n      key = \"k-\" + key;\n      if (key in this.data) {\n        return this.data[key];\n      } else {\n        return null;\n      }\n    }\n    put(key, value) {\n      key = \"k-\" + key;\n      this.data[key] = value;\n    }\n    values() {\n      const data = this.data;\n      const keys = Object.keys(this.data);\n      return keys.map(function(key) {\n        return data[key];\n      });\n    }\n  };\n  var DoubleDict = class {\n    constructor(defaultMapCtor) {\n      this.defaultMapCtor = defaultMapCtor || Map2;\n      this.cacheMap = new this.defaultMapCtor();\n    }\n    get(a, b) {\n      const d = this.cacheMap.get(a) || null;\n      return d === null ? null : d.get(b) || null;\n    }\n    set(a, b, o) {\n      let d = this.cacheMap.get(a) || null;\n      if (d === null) {\n        d = new this.defaultMapCtor();\n        this.cacheMap.put(a, d);\n      }\n      d.put(b, o);\n    }\n  };\n  var Hash2 = class {\n    constructor() {\n      this.count = 0;\n      this.hash = 0;\n    }\n    update() {\n      for (let i = 0; i < arguments.length; i++) {\n        const value = arguments[i];\n        if (value == null)\n          continue;\n        if (Array.isArray(value))\n          this.update.apply(this, value);\n        else {\n          let k = 0;\n          switch (typeof value) {\n            case \"undefined\":\n            case \"function\":\n              continue;\n            case \"number\":\n            case \"boolean\":\n              k = value;\n              break;\n            case \"string\":\n              k = value.hashCode();\n              break;\n            default:\n              if (value.updateHashCode)\n                value.updateHashCode(this);\n              else\n                console.log(\"No updateHashCode for \" + value.toString());\n              continue;\n          }\n          k = k * 3432918353;\n          k = k << 15 | k >>> 32 - 15;\n          k = k * 461845907;\n          this.count = this.count + 1;\n          let hash = this.hash ^ k;\n          hash = hash << 13 | hash >>> 32 - 13;\n          hash = hash * 5 + 3864292196;\n          this.hash = hash;\n        }\n      }\n    }\n    finish() {\n      let hash = this.hash ^ this.count * 4;\n      hash = hash ^ hash >>> 16;\n      hash = hash * 2246822507;\n      hash = hash ^ hash >>> 13;\n      hash = hash * 3266489909;\n      hash = hash ^ hash >>> 16;\n      return hash;\n    }\n  };\n  function hashStuff() {\n    const hash = new Hash2();\n    hash.update.apply(hash, arguments);\n    return hash.finish();\n  }\n  function escapeWhitespace(s, escapeSpaces) {\n    s = s.replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\");\n    if (escapeSpaces) {\n      s = s.replace(/ /g, \"\\xB7\");\n    }\n    return s;\n  }\n  function titleCase(str) {\n    return str.replace(/\\w\\S*/g, function(txt) {\n      return txt.charAt(0).toUpperCase() + txt.substr(1);\n    });\n  }\n  function equalArrays(a, b) {\n    if (!Array.isArray(a) || !Array.isArray(b))\n      return false;\n    if (a === b)\n      return true;\n    if (a.length !== b.length)\n      return false;\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] === b[i])\n        continue;\n      if (!a[i].equals || !a[i].equals(b[i]))\n        return false;\n    }\n    return true;\n  }\n  module2.exports = {\n    Hash: Hash2,\n    Set: Set2,\n    Map: Map2,\n    BitSet,\n    AltDict,\n    DoubleDict,\n    hashStuff,\n    escapeWhitespace,\n    arrayToString,\n    titleCase,\n    equalArrays\n  };\n});\n\n// node_modules/antlr4/src/antlr4/Token.js\nvar require_Token2 = __commonJS((exports, module2) => {\n  var Token2 = class {\n    constructor() {\n      this.source = null;\n      this.type = null;\n      this.channel = null;\n      this.start = null;\n      this.stop = null;\n      this.tokenIndex = null;\n      this.line = null;\n      this.column = null;\n      this._text = null;\n    }\n    getTokenSource() {\n      return this.source[0];\n    }\n    getInputStream() {\n      return this.source[1];\n    }\n    get text() {\n      return this._text;\n    }\n    set text(text) {\n      this._text = text;\n    }\n  };\n  Token2.INVALID_TYPE = 0;\n  Token2.EPSILON = -2;\n  Token2.MIN_USER_TOKEN_TYPE = 1;\n  Token2.EOF = -1;\n  Token2.DEFAULT_CHANNEL = 0;\n  Token2.HIDDEN_CHANNEL = 1;\n  var CommonToken = class extends Token2 {\n    constructor(source, type, channel, start, stop) {\n      super();\n      this.source = source !== void 0 ? source : CommonToken.EMPTY_SOURCE;\n      this.type = type !== void 0 ? type : null;\n      this.channel = channel !== void 0 ? channel : Token2.DEFAULT_CHANNEL;\n      this.start = start !== void 0 ? start : -1;\n      this.stop = stop !== void 0 ? stop : -1;\n      this.tokenIndex = -1;\n      if (this.source[0] !== null) {\n        this.line = source[0].line;\n        this.column = source[0].column;\n      } else {\n        this.column = -1;\n      }\n    }\n    clone() {\n      const t = new CommonToken(this.source, this.type, this.channel, this.start, this.stop);\n      t.tokenIndex = this.tokenIndex;\n      t.line = this.line;\n      t.column = this.column;\n      t.text = this.text;\n      return t;\n    }\n    toString() {\n      let txt = this.text;\n      if (txt !== null) {\n        txt = txt.replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\");\n      } else {\n        txt = \"<no text>\";\n      }\n      return \"[@\" + this.tokenIndex + \",\" + this.start + \":\" + this.stop + \"='\" + txt + \"',<\" + this.type + \">\" + (this.channel > 0 ? \",channel=\" + this.channel : \"\") + \",\" + this.line + \":\" + this.column + \"]\";\n    }\n    get text() {\n      if (this._text !== null) {\n        return this._text;\n      }\n      const input = this.getInputStream();\n      if (input === null) {\n        return null;\n      }\n      const n = input.size;\n      if (this.start < n && this.stop < n) {\n        return input.getText(this.start, this.stop);\n      } else {\n        return \"<EOF>\";\n      }\n    }\n    set text(text) {\n      this._text = text;\n    }\n  };\n  CommonToken.EMPTY_SOURCE = [null, null];\n  module2.exports = {\n    Token: Token2,\n    CommonToken\n  };\n});\n\n// node_modules/antlr4/src/antlr4/atn/ATNState.js\nvar require_ATNState2 = __commonJS((exports, module2) => {\n  var ATNState = class {\n    constructor() {\n      this.atn = null;\n      this.stateNumber = ATNState.INVALID_STATE_NUMBER;\n      this.stateType = null;\n      this.ruleIndex = 0;\n      this.epsilonOnlyTransitions = false;\n      this.transitions = [];\n      this.nextTokenWithinRule = null;\n    }\n    toString() {\n      return this.stateNumber;\n    }\n    equals(other) {\n      if (other instanceof ATNState) {\n        return this.stateNumber === other.stateNumber;\n      } else {\n        return false;\n      }\n    }\n    isNonGreedyExitState() {\n      return false;\n    }\n    addTransition(trans, index) {\n      if (index === void 0) {\n        index = -1;\n      }\n      if (this.transitions.length === 0) {\n        this.epsilonOnlyTransitions = trans.isEpsilon;\n      } else if (this.epsilonOnlyTransitions !== trans.isEpsilon) {\n        this.epsilonOnlyTransitions = false;\n      }\n      if (index === -1) {\n        this.transitions.push(trans);\n      } else {\n        this.transitions.splice(index, 1, trans);\n      }\n    }\n  };\n  ATNState.INVALID_TYPE = 0;\n  ATNState.BASIC = 1;\n  ATNState.RULE_START = 2;\n  ATNState.BLOCK_START = 3;\n  ATNState.PLUS_BLOCK_START = 4;\n  ATNState.STAR_BLOCK_START = 5;\n  ATNState.TOKEN_START = 6;\n  ATNState.RULE_STOP = 7;\n  ATNState.BLOCK_END = 8;\n  ATNState.STAR_LOOP_BACK = 9;\n  ATNState.STAR_LOOP_ENTRY = 10;\n  ATNState.PLUS_LOOP_BACK = 11;\n  ATNState.LOOP_END = 12;\n  ATNState.serializationNames = [\n    \"INVALID\",\n    \"BASIC\",\n    \"RULE_START\",\n    \"BLOCK_START\",\n    \"PLUS_BLOCK_START\",\n    \"STAR_BLOCK_START\",\n    \"TOKEN_START\",\n    \"RULE_STOP\",\n    \"BLOCK_END\",\n    \"STAR_LOOP_BACK\",\n    \"STAR_LOOP_ENTRY\",\n    \"PLUS_LOOP_BACK\",\n    \"LOOP_END\"\n  ];\n  ATNState.INVALID_STATE_NUMBER = -1;\n  var BasicState = class extends ATNState {\n    constructor() {\n      super();\n      this.stateType = ATNState.BASIC;\n    }\n  };\n  var DecisionState = class extends ATNState {\n    constructor() {\n      super();\n      this.decision = -1;\n      this.nonGreedy = false;\n      return this;\n    }\n  };\n  var BlockStartState = class extends DecisionState {\n    constructor() {\n      super();\n      this.endState = null;\n      return this;\n    }\n  };\n  var BasicBlockStartState = class extends BlockStartState {\n    constructor() {\n      super();\n      this.stateType = ATNState.BLOCK_START;\n      return this;\n    }\n  };\n  var BlockEndState = class extends ATNState {\n    constructor() {\n      super();\n      this.stateType = ATNState.BLOCK_END;\n      this.startState = null;\n      return this;\n    }\n  };\n  var RuleStopState = class extends ATNState {\n    constructor() {\n      super();\n      this.stateType = ATNState.RULE_STOP;\n      return this;\n    }\n  };\n  var RuleStartState = class extends ATNState {\n    constructor() {\n      super();\n      this.stateType = ATNState.RULE_START;\n      this.stopState = null;\n      this.isPrecedenceRule = false;\n      return this;\n    }\n  };\n  var PlusLoopbackState = class extends DecisionState {\n    constructor() {\n      super();\n      this.stateType = ATNState.PLUS_LOOP_BACK;\n      return this;\n    }\n  };\n  var PlusBlockStartState = class extends BlockStartState {\n    constructor() {\n      super();\n      this.stateType = ATNState.PLUS_BLOCK_START;\n      this.loopBackState = null;\n      return this;\n    }\n  };\n  var StarBlockStartState = class extends BlockStartState {\n    constructor() {\n      super();\n      this.stateType = ATNState.STAR_BLOCK_START;\n      return this;\n    }\n  };\n  var StarLoopbackState = class extends ATNState {\n    constructor() {\n      super();\n      this.stateType = ATNState.STAR_LOOP_BACK;\n      return this;\n    }\n  };\n  var StarLoopEntryState = class extends DecisionState {\n    constructor() {\n      super();\n      this.stateType = ATNState.STAR_LOOP_ENTRY;\n      this.loopBackState = null;\n      this.isPrecedenceDecision = null;\n      return this;\n    }\n  };\n  var LoopEndState = class extends ATNState {\n    constructor() {\n      super();\n      this.stateType = ATNState.LOOP_END;\n      this.loopBackState = null;\n      return this;\n    }\n  };\n  var TokensStartState = class extends DecisionState {\n    constructor() {\n      super();\n      this.stateType = ATNState.TOKEN_START;\n      return this;\n    }\n  };\n  module2.exports = {\n    ATNState,\n    BasicState,\n    DecisionState,\n    BlockStartState,\n    BlockEndState,\n    LoopEndState,\n    RuleStartState,\n    RuleStopState,\n    TokensStartState,\n    PlusLoopbackState,\n    StarLoopbackState,\n    StarLoopEntryState,\n    PlusBlockStartState,\n    StarBlockStartState,\n    BasicBlockStartState\n  };\n});\n\n// node_modules/antlr4/src/antlr4/atn/SemanticContext.js\nvar require_SemanticContext2 = __commonJS((exports, module2) => {\n  var {Set: Set2, Hash: Hash2, equalArrays} = require_Utils2();\n  var SemanticContext = class {\n    hashCode() {\n      const hash = new Hash2();\n      this.updateHashCode(hash);\n      return hash.finish();\n    }\n    evaluate(parser, outerContext) {\n    }\n    evalPrecedence(parser, outerContext) {\n      return this;\n    }\n    static andContext(a, b) {\n      if (a === null || a === SemanticContext.NONE) {\n        return b;\n      }\n      if (b === null || b === SemanticContext.NONE) {\n        return a;\n      }\n      const result = new AND(a, b);\n      if (result.opnds.length === 1) {\n        return result.opnds[0];\n      } else {\n        return result;\n      }\n    }\n    static orContext(a, b) {\n      if (a === null) {\n        return b;\n      }\n      if (b === null) {\n        return a;\n      }\n      if (a === SemanticContext.NONE || b === SemanticContext.NONE) {\n        return SemanticContext.NONE;\n      }\n      const result = new OR(a, b);\n      if (result.opnds.length === 1) {\n        return result.opnds[0];\n      } else {\n        return result;\n      }\n    }\n  };\n  var Predicate = class extends SemanticContext {\n    constructor(ruleIndex, predIndex, isCtxDependent) {\n      super();\n      this.ruleIndex = ruleIndex === void 0 ? -1 : ruleIndex;\n      this.predIndex = predIndex === void 0 ? -1 : predIndex;\n      this.isCtxDependent = isCtxDependent === void 0 ? false : isCtxDependent;\n    }\n    evaluate(parser, outerContext) {\n      const localctx = this.isCtxDependent ? outerContext : null;\n      return parser.sempred(localctx, this.ruleIndex, this.predIndex);\n    }\n    updateHashCode(hash) {\n      hash.update(this.ruleIndex, this.predIndex, this.isCtxDependent);\n    }\n    equals(other) {\n      if (this === other) {\n        return true;\n      } else if (!(other instanceof Predicate)) {\n        return false;\n      } else {\n        return this.ruleIndex === other.ruleIndex && this.predIndex === other.predIndex && this.isCtxDependent === other.isCtxDependent;\n      }\n    }\n    toString() {\n      return \"{\" + this.ruleIndex + \":\" + this.predIndex + \"}?\";\n    }\n  };\n  SemanticContext.NONE = new Predicate();\n  var PrecedencePredicate = class extends SemanticContext {\n    constructor(precedence) {\n      super();\n      this.precedence = precedence === void 0 ? 0 : precedence;\n    }\n    evaluate(parser, outerContext) {\n      return parser.precpred(outerContext, this.precedence);\n    }\n    evalPrecedence(parser, outerContext) {\n      if (parser.precpred(outerContext, this.precedence)) {\n        return SemanticContext.NONE;\n      } else {\n        return null;\n      }\n    }\n    compareTo(other) {\n      return this.precedence - other.precedence;\n    }\n    updateHashCode(hash) {\n      hash.update(this.precedence);\n    }\n    equals(other) {\n      if (this === other) {\n        return true;\n      } else if (!(other instanceof PrecedencePredicate)) {\n        return false;\n      } else {\n        return this.precedence === other.precedence;\n      }\n    }\n    toString() {\n      return \"{\" + this.precedence + \">=prec}?\";\n    }\n    static filterPrecedencePredicates(set) {\n      const result = [];\n      set.values().map(function(context) {\n        if (context instanceof PrecedencePredicate) {\n          result.push(context);\n        }\n      });\n      return result;\n    }\n  };\n  var AND = class extends SemanticContext {\n    constructor(a, b) {\n      super();\n      const operands = new Set2();\n      if (a instanceof AND) {\n        a.opnds.map(function(o) {\n          operands.add(o);\n        });\n      } else {\n        operands.add(a);\n      }\n      if (b instanceof AND) {\n        b.opnds.map(function(o) {\n          operands.add(o);\n        });\n      } else {\n        operands.add(b);\n      }\n      const precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);\n      if (precedencePredicates.length > 0) {\n        let reduced = null;\n        precedencePredicates.map(function(p) {\n          if (reduced === null || p.precedence < reduced.precedence) {\n            reduced = p;\n          }\n        });\n        operands.add(reduced);\n      }\n      this.opnds = Array.from(operands.values());\n    }\n    equals(other) {\n      if (this === other) {\n        return true;\n      } else if (!(other instanceof AND)) {\n        return false;\n      } else {\n        return equalArrays(this.opnds, other.opnds);\n      }\n    }\n    updateHashCode(hash) {\n      hash.update(this.opnds, \"AND\");\n    }\n    evaluate(parser, outerContext) {\n      for (let i = 0; i < this.opnds.length; i++) {\n        if (!this.opnds[i].evaluate(parser, outerContext)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    evalPrecedence(parser, outerContext) {\n      let differs = false;\n      const operands = [];\n      for (let i = 0; i < this.opnds.length; i++) {\n        const context = this.opnds[i];\n        const evaluated = context.evalPrecedence(parser, outerContext);\n        differs |= evaluated !== context;\n        if (evaluated === null) {\n          return null;\n        } else if (evaluated !== SemanticContext.NONE) {\n          operands.push(evaluated);\n        }\n      }\n      if (!differs) {\n        return this;\n      }\n      if (operands.length === 0) {\n        return SemanticContext.NONE;\n      }\n      let result = null;\n      operands.map(function(o) {\n        result = result === null ? o : SemanticContext.andContext(result, o);\n      });\n      return result;\n    }\n    toString() {\n      const s = this.opnds.map((o) => o.toString());\n      return (s.length > 3 ? s.slice(3) : s).join(\"&&\");\n    }\n  };\n  var OR = class extends SemanticContext {\n    constructor(a, b) {\n      super();\n      const operands = new Set2();\n      if (a instanceof OR) {\n        a.opnds.map(function(o) {\n          operands.add(o);\n        });\n      } else {\n        operands.add(a);\n      }\n      if (b instanceof OR) {\n        b.opnds.map(function(o) {\n          operands.add(o);\n        });\n      } else {\n        operands.add(b);\n      }\n      const precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);\n      if (precedencePredicates.length > 0) {\n        const s = precedencePredicates.sort(function(a2, b2) {\n          return a2.compareTo(b2);\n        });\n        const reduced = s[s.length - 1];\n        operands.add(reduced);\n      }\n      this.opnds = Array.from(operands.values());\n    }\n    equals(other) {\n      if (this === other) {\n        return true;\n      } else if (!(other instanceof OR)) {\n        return false;\n      } else {\n        return equalArrays(this.opnds, other.opnds);\n      }\n    }\n    updateHashCode(hash) {\n      hash.update(this.opnds, \"OR\");\n    }\n    evaluate(parser, outerContext) {\n      for (let i = 0; i < this.opnds.length; i++) {\n        if (this.opnds[i].evaluate(parser, outerContext)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    evalPrecedence(parser, outerContext) {\n      let differs = false;\n      const operands = [];\n      for (let i = 0; i < this.opnds.length; i++) {\n        const context = this.opnds[i];\n        const evaluated = context.evalPrecedence(parser, outerContext);\n        differs |= evaluated !== context;\n        if (evaluated === SemanticContext.NONE) {\n          return SemanticContext.NONE;\n        } else if (evaluated !== null) {\n          operands.push(evaluated);\n        }\n      }\n      if (!differs) {\n        return this;\n      }\n      if (operands.length === 0) {\n        return null;\n      }\n      const result = null;\n      operands.map(function(o) {\n        return result === null ? o : SemanticContext.orContext(result, o);\n      });\n      return result;\n    }\n    toString() {\n      const s = this.opnds.map((o) => o.toString());\n      return (s.length > 3 ? s.slice(3) : s).join(\"||\");\n    }\n  };\n  module2.exports = {\n    SemanticContext,\n    PrecedencePredicate,\n    Predicate\n  };\n});\n\n// node_modules/antlr4/src/antlr4/atn/ATNConfig.js\nvar require_ATNConfig2 = __commonJS((exports, module2) => {\n  var {DecisionState} = require_ATNState2();\n  var {SemanticContext} = require_SemanticContext2();\n  var {Hash: Hash2} = require_Utils2();\n  function checkParams(params, isCfg) {\n    if (params === null) {\n      const result = {state: null, alt: null, context: null, semanticContext: null};\n      if (isCfg) {\n        result.reachesIntoOuterContext = 0;\n      }\n      return result;\n    } else {\n      const props = {};\n      props.state = params.state || null;\n      props.alt = params.alt === void 0 ? null : params.alt;\n      props.context = params.context || null;\n      props.semanticContext = params.semanticContext || null;\n      if (isCfg) {\n        props.reachesIntoOuterContext = params.reachesIntoOuterContext || 0;\n        props.precedenceFilterSuppressed = params.precedenceFilterSuppressed || false;\n      }\n      return props;\n    }\n  }\n  var ATNConfig = class {\n    constructor(params, config) {\n      this.checkContext(params, config);\n      params = checkParams(params);\n      config = checkParams(config, true);\n      this.state = params.state !== null ? params.state : config.state;\n      this.alt = params.alt !== null ? params.alt : config.alt;\n      this.context = params.context !== null ? params.context : config.context;\n      this.semanticContext = params.semanticContext !== null ? params.semanticContext : config.semanticContext !== null ? config.semanticContext : SemanticContext.NONE;\n      this.reachesIntoOuterContext = config.reachesIntoOuterContext;\n      this.precedenceFilterSuppressed = config.precedenceFilterSuppressed;\n    }\n    checkContext(params, config) {\n      if ((params.context === null || params.context === void 0) && (config === null || config.context === null || config.context === void 0)) {\n        this.context = null;\n      }\n    }\n    hashCode() {\n      const hash = new Hash2();\n      this.updateHashCode(hash);\n      return hash.finish();\n    }\n    updateHashCode(hash) {\n      hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);\n    }\n    equals(other) {\n      if (this === other) {\n        return true;\n      } else if (!(other instanceof ATNConfig)) {\n        return false;\n      } else {\n        return this.state.stateNumber === other.state.stateNumber && this.alt === other.alt && (this.context === null ? other.context === null : this.context.equals(other.context)) && this.semanticContext.equals(other.semanticContext) && this.precedenceFilterSuppressed === other.precedenceFilterSuppressed;\n      }\n    }\n    hashCodeForConfigSet() {\n      const hash = new Hash2();\n      hash.update(this.state.stateNumber, this.alt, this.semanticContext);\n      return hash.finish();\n    }\n    equalsForConfigSet(other) {\n      if (this === other) {\n        return true;\n      } else if (!(other instanceof ATNConfig)) {\n        return false;\n      } else {\n        return this.state.stateNumber === other.state.stateNumber && this.alt === other.alt && this.semanticContext.equals(other.semanticContext);\n      }\n    }\n    toString() {\n      return \"(\" + this.state + \",\" + this.alt + (this.context !== null ? \",[\" + this.context.toString() + \"]\" : \"\") + (this.semanticContext !== SemanticContext.NONE ? \",\" + this.semanticContext.toString() : \"\") + (this.reachesIntoOuterContext > 0 ? \",up=\" + this.reachesIntoOuterContext : \"\") + \")\";\n    }\n  };\n  var LexerATNConfig = class extends ATNConfig {\n    constructor(params, config) {\n      super(params, config);\n      const lexerActionExecutor = params.lexerActionExecutor || null;\n      this.lexerActionExecutor = lexerActionExecutor || (config !== null ? config.lexerActionExecutor : null);\n      this.passedThroughNonGreedyDecision = config !== null ? this.checkNonGreedyDecision(config, this.state) : false;\n      this.hashCodeForConfigSet = LexerATNConfig.prototype.hashCode;\n      this.equalsForConfigSet = LexerATNConfig.prototype.equals;\n      return this;\n    }\n    updateHashCode(hash) {\n      hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);\n    }\n    equals(other) {\n      return this === other || other instanceof LexerATNConfig && this.passedThroughNonGreedyDecision === other.passedThroughNonGreedyDecision && (this.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) && super.equals(other);\n    }\n    checkNonGreedyDecision(source, target) {\n      return source.passedThroughNonGreedyDecision || target instanceof DecisionState && target.nonGreedy;\n    }\n  };\n  module2.exports.ATNConfig = ATNConfig;\n  module2.exports.LexerATNConfig = LexerATNConfig;\n});\n\n// node_modules/antlr4/src/antlr4/IntervalSet.js\nvar require_IntervalSet2 = __commonJS((exports, module2) => {\n  var {Token: Token2} = require_Token2();\n  var Interval = class {\n    constructor(start, stop) {\n      this.start = start;\n      this.stop = stop;\n    }\n    contains(item) {\n      return item >= this.start && item < this.stop;\n    }\n    toString() {\n      if (this.start === this.stop - 1) {\n        return this.start.toString();\n      } else {\n        return this.start.toString() + \"..\" + (this.stop - 1).toString();\n      }\n    }\n    get length() {\n      return this.stop - this.start;\n    }\n  };\n  var IntervalSet = class {\n    constructor() {\n      this.intervals = null;\n      this.readOnly = false;\n    }\n    first(v) {\n      if (this.intervals === null || this.intervals.length === 0) {\n        return Token2.INVALID_TYPE;\n      } else {\n        return this.intervals[0].start;\n      }\n    }\n    addOne(v) {\n      this.addInterval(new Interval(v, v + 1));\n    }\n    addRange(l, h) {\n      this.addInterval(new Interval(l, h + 1));\n    }\n    addInterval(toAdd) {\n      if (this.intervals === null) {\n        this.intervals = [];\n        this.intervals.push(toAdd);\n      } else {\n        for (let pos = 0; pos < this.intervals.length; pos++) {\n          const existing = this.intervals[pos];\n          if (toAdd.stop < existing.start) {\n            this.intervals.splice(pos, 0, toAdd);\n            return;\n          } else if (toAdd.stop === existing.start) {\n            this.intervals[pos].start = toAdd.start;\n            return;\n          } else if (toAdd.start <= existing.stop) {\n            this.intervals[pos] = new Interval(Math.min(existing.start, toAdd.start), Math.max(existing.stop, toAdd.stop));\n            this.reduce(pos);\n            return;\n          }\n        }\n        this.intervals.push(toAdd);\n      }\n    }\n    addSet(other) {\n      if (other.intervals !== null) {\n        other.intervals.forEach((toAdd) => this.addInterval(toAdd), this);\n      }\n      return this;\n    }\n    reduce(pos) {\n      if (pos < this.intervals.length - 1) {\n        const current = this.intervals[pos];\n        const next = this.intervals[pos + 1];\n        if (current.stop >= next.stop) {\n          this.intervals.splice(pos + 1, 1);\n          this.reduce(pos);\n        } else if (current.stop >= next.start) {\n          this.intervals[pos] = new Interval(current.start, next.stop);\n          this.intervals.splice(pos + 1, 1);\n        }\n      }\n    }\n    complement(start, stop) {\n      const result = new IntervalSet();\n      result.addInterval(new Interval(start, stop + 1));\n      if (this.intervals !== null)\n        this.intervals.forEach((toRemove) => result.removeRange(toRemove));\n      return result;\n    }\n    contains(item) {\n      if (this.intervals === null) {\n        return false;\n      } else {\n        for (let k = 0; k < this.intervals.length; k++) {\n          if (this.intervals[k].contains(item)) {\n            return true;\n          }\n        }\n        return false;\n      }\n    }\n    removeRange(toRemove) {\n      if (toRemove.start === toRemove.stop - 1) {\n        this.removeOne(toRemove.start);\n      } else if (this.intervals !== null) {\n        let pos = 0;\n        for (let n = 0; n < this.intervals.length; n++) {\n          const existing = this.intervals[pos];\n          if (toRemove.stop <= existing.start) {\n            return;\n          } else if (toRemove.start > existing.start && toRemove.stop < existing.stop) {\n            this.intervals[pos] = new Interval(existing.start, toRemove.start);\n            const x = new Interval(toRemove.stop, existing.stop);\n            this.intervals.splice(pos, 0, x);\n            return;\n          } else if (toRemove.start <= existing.start && toRemove.stop >= existing.stop) {\n            this.intervals.splice(pos, 1);\n            pos = pos - 1;\n          } else if (toRemove.start < existing.stop) {\n            this.intervals[pos] = new Interval(existing.start, toRemove.start);\n          } else if (toRemove.stop < existing.stop) {\n            this.intervals[pos] = new Interval(toRemove.stop, existing.stop);\n          }\n          pos += 1;\n        }\n      }\n    }\n    removeOne(value) {\n      if (this.intervals !== null) {\n        for (let i = 0; i < this.intervals.length; i++) {\n          const existing = this.intervals[i];\n          if (value < existing.start) {\n            return;\n          } else if (value === existing.start && value === existing.stop - 1) {\n            this.intervals.splice(i, 1);\n            return;\n          } else if (value === existing.start) {\n            this.intervals[i] = new Interval(existing.start + 1, existing.stop);\n            return;\n          } else if (value === existing.stop - 1) {\n            this.intervals[i] = new Interval(existing.start, existing.stop - 1);\n            return;\n          } else if (value < existing.stop - 1) {\n            const replace = new Interval(existing.start, value);\n            existing.start = value + 1;\n            this.intervals.splice(i, 0, replace);\n            return;\n          }\n        }\n      }\n    }\n    toString(literalNames, symbolicNames, elemsAreChar) {\n      literalNames = literalNames || null;\n      symbolicNames = symbolicNames || null;\n      elemsAreChar = elemsAreChar || false;\n      if (this.intervals === null) {\n        return \"{}\";\n      } else if (literalNames !== null || symbolicNames !== null) {\n        return this.toTokenString(literalNames, symbolicNames);\n      } else if (elemsAreChar) {\n        return this.toCharString();\n      } else {\n        return this.toIndexString();\n      }\n    }\n    toCharString() {\n      const names = [];\n      for (let i = 0; i < this.intervals.length; i++) {\n        const existing = this.intervals[i];\n        if (existing.stop === existing.start + 1) {\n          if (existing.start === Token2.EOF) {\n            names.push(\"<EOF>\");\n          } else {\n            names.push(\"'\" + String.fromCharCode(existing.start) + \"'\");\n          }\n        } else {\n          names.push(\"'\" + String.fromCharCode(existing.start) + \"'..'\" + String.fromCharCode(existing.stop - 1) + \"'\");\n        }\n      }\n      if (names.length > 1) {\n        return \"{\" + names.join(\", \") + \"}\";\n      } else {\n        return names[0];\n      }\n    }\n    toIndexString() {\n      const names = [];\n      for (let i = 0; i < this.intervals.length; i++) {\n        const existing = this.intervals[i];\n        if (existing.stop === existing.start + 1) {\n          if (existing.start === Token2.EOF) {\n            names.push(\"<EOF>\");\n          } else {\n            names.push(existing.start.toString());\n          }\n        } else {\n          names.push(existing.start.toString() + \"..\" + (existing.stop - 1).toString());\n        }\n      }\n      if (names.length > 1) {\n        return \"{\" + names.join(\", \") + \"}\";\n      } else {\n        return names[0];\n      }\n    }\n    toTokenString(literalNames, symbolicNames) {\n      const names = [];\n      for (let i = 0; i < this.intervals.length; i++) {\n        const existing = this.intervals[i];\n        for (let j = existing.start; j < existing.stop; j++) {\n          names.push(this.elementName(literalNames, symbolicNames, j));\n        }\n      }\n      if (names.length > 1) {\n        return \"{\" + names.join(\", \") + \"}\";\n      } else {\n        return names[0];\n      }\n    }\n    elementName(literalNames, symbolicNames, token) {\n      if (token === Token2.EOF) {\n        return \"<EOF>\";\n      } else if (token === Token2.EPSILON) {\n        return \"<EPSILON>\";\n      } else {\n        return literalNames[token] || symbolicNames[token];\n      }\n    }\n    get length() {\n      return this.intervals.map((interval) => interval.length).reduce((acc, val) => acc + val);\n    }\n  };\n  module2.exports = {\n    Interval,\n    IntervalSet\n  };\n});\n\n// node_modules/antlr4/src/antlr4/atn/Transition.js\nvar require_Transition2 = __commonJS((exports, module2) => {\n  var {Token: Token2} = require_Token2();\n  var {IntervalSet} = require_IntervalSet2();\n  var {Predicate, PrecedencePredicate} = require_SemanticContext2();\n  var Transition = class {\n    constructor(target) {\n      if (target === void 0 || target === null) {\n        throw \"target cannot be null.\";\n      }\n      this.target = target;\n      this.isEpsilon = false;\n      this.label = null;\n    }\n  };\n  Transition.EPSILON = 1;\n  Transition.RANGE = 2;\n  Transition.RULE = 3;\n  Transition.PREDICATE = 4;\n  Transition.ATOM = 5;\n  Transition.ACTION = 6;\n  Transition.SET = 7;\n  Transition.NOT_SET = 8;\n  Transition.WILDCARD = 9;\n  Transition.PRECEDENCE = 10;\n  Transition.serializationNames = [\n    \"INVALID\",\n    \"EPSILON\",\n    \"RANGE\",\n    \"RULE\",\n    \"PREDICATE\",\n    \"ATOM\",\n    \"ACTION\",\n    \"SET\",\n    \"NOT_SET\",\n    \"WILDCARD\",\n    \"PRECEDENCE\"\n  ];\n  Transition.serializationTypes = {\n    EpsilonTransition: Transition.EPSILON,\n    RangeTransition: Transition.RANGE,\n    RuleTransition: Transition.RULE,\n    PredicateTransition: Transition.PREDICATE,\n    AtomTransition: Transition.ATOM,\n    ActionTransition: Transition.ACTION,\n    SetTransition: Transition.SET,\n    NotSetTransition: Transition.NOT_SET,\n    WildcardTransition: Transition.WILDCARD,\n    PrecedencePredicateTransition: Transition.PRECEDENCE\n  };\n  var AtomTransition2 = class extends Transition {\n    constructor(target, label) {\n      super(target);\n      this.label_ = label;\n      this.label = this.makeLabel();\n      this.serializationType = Transition.ATOM;\n    }\n    makeLabel() {\n      const s = new IntervalSet();\n      s.addOne(this.label_);\n      return s;\n    }\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n      return this.label_ === symbol;\n    }\n    toString() {\n      return this.label_;\n    }\n  };\n  var RuleTransition = class extends Transition {\n    constructor(ruleStart, ruleIndex, precedence, followState) {\n      super(ruleStart);\n      this.ruleIndex = ruleIndex;\n      this.precedence = precedence;\n      this.followState = followState;\n      this.serializationType = Transition.RULE;\n      this.isEpsilon = true;\n    }\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n      return false;\n    }\n  };\n  var EpsilonTransition = class extends Transition {\n    constructor(target, outermostPrecedenceReturn) {\n      super(target);\n      this.serializationType = Transition.EPSILON;\n      this.isEpsilon = true;\n      this.outermostPrecedenceReturn = outermostPrecedenceReturn;\n    }\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n      return false;\n    }\n    toString() {\n      return \"epsilon\";\n    }\n  };\n  var RangeTransition = class extends Transition {\n    constructor(target, start, stop) {\n      super(target);\n      this.serializationType = Transition.RANGE;\n      this.start = start;\n      this.stop = stop;\n      this.label = this.makeLabel();\n    }\n    makeLabel() {\n      const s = new IntervalSet();\n      s.addRange(this.start, this.stop);\n      return s;\n    }\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n      return symbol >= this.start && symbol <= this.stop;\n    }\n    toString() {\n      return \"'\" + String.fromCharCode(this.start) + \"'..'\" + String.fromCharCode(this.stop) + \"'\";\n    }\n  };\n  var AbstractPredicateTransition = class extends Transition {\n    constructor(target) {\n      super(target);\n    }\n  };\n  var PredicateTransition = class extends AbstractPredicateTransition {\n    constructor(target, ruleIndex, predIndex, isCtxDependent) {\n      super(target);\n      this.serializationType = Transition.PREDICATE;\n      this.ruleIndex = ruleIndex;\n      this.predIndex = predIndex;\n      this.isCtxDependent = isCtxDependent;\n      this.isEpsilon = true;\n    }\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n      return false;\n    }\n    getPredicate() {\n      return new Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);\n    }\n    toString() {\n      return \"pred_\" + this.ruleIndex + \":\" + this.predIndex;\n    }\n  };\n  var ActionTransition = class extends Transition {\n    constructor(target, ruleIndex, actionIndex, isCtxDependent) {\n      super(target);\n      this.serializationType = Transition.ACTION;\n      this.ruleIndex = ruleIndex;\n      this.actionIndex = actionIndex === void 0 ? -1 : actionIndex;\n      this.isCtxDependent = isCtxDependent === void 0 ? false : isCtxDependent;\n      this.isEpsilon = true;\n    }\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n      return false;\n    }\n    toString() {\n      return \"action_\" + this.ruleIndex + \":\" + this.actionIndex;\n    }\n  };\n  var SetTransition = class extends Transition {\n    constructor(target, set) {\n      super(target);\n      this.serializationType = Transition.SET;\n      if (set !== void 0 && set !== null) {\n        this.label = set;\n      } else {\n        this.label = new IntervalSet();\n        this.label.addOne(Token2.INVALID_TYPE);\n      }\n    }\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n      return this.label.contains(symbol);\n    }\n    toString() {\n      return this.label.toString();\n    }\n  };\n  var NotSetTransition = class extends SetTransition {\n    constructor(target, set) {\n      super(target, set);\n      this.serializationType = Transition.NOT_SET;\n    }\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n      return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !super.matches(symbol, minVocabSymbol, maxVocabSymbol);\n    }\n    toString() {\n      return \"~\" + super.toString();\n    }\n  };\n  var WildcardTransition = class extends Transition {\n    constructor(target) {\n      super(target);\n      this.serializationType = Transition.WILDCARD;\n    }\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n      return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;\n    }\n    toString() {\n      return \".\";\n    }\n  };\n  var PrecedencePredicateTransition = class extends AbstractPredicateTransition {\n    constructor(target, precedence) {\n      super(target);\n      this.serializationType = Transition.PRECEDENCE;\n      this.precedence = precedence;\n      this.isEpsilon = true;\n    }\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n      return false;\n    }\n    getPredicate() {\n      return new PrecedencePredicate(this.precedence);\n    }\n    toString() {\n      return this.precedence + \" >= _p\";\n    }\n  };\n  module2.exports = {\n    Transition,\n    AtomTransition: AtomTransition2,\n    SetTransition,\n    NotSetTransition,\n    RuleTransition,\n    ActionTransition,\n    EpsilonTransition,\n    RangeTransition,\n    WildcardTransition,\n    PredicateTransition,\n    PrecedencePredicateTransition,\n    AbstractPredicateTransition\n  };\n});\n\n// node_modules/antlr4/src/antlr4/tree/Tree.js\nvar require_Tree = __commonJS((exports, module2) => {\n  var {Token: Token2} = require_Token2();\n  var {Interval} = require_IntervalSet2();\n  var INVALID_INTERVAL = new Interval(-1, -2);\n  var Tree = class {\n  };\n  var SyntaxTree = class extends Tree {\n    constructor() {\n      super();\n    }\n  };\n  var ParseTree = class extends SyntaxTree {\n    constructor() {\n      super();\n    }\n  };\n  var RuleNode = class extends ParseTree {\n    constructor() {\n      super();\n    }\n    getRuleContext() {\n      throw new Error(\"missing interface implementation\");\n    }\n  };\n  var TerminalNode = class extends ParseTree {\n    constructor() {\n      super();\n    }\n  };\n  var ErrorNode2 = class extends TerminalNode {\n    constructor() {\n      super();\n    }\n  };\n  var ParseTreeVisitor = class {\n    visit(ctx) {\n      if (Array.isArray(ctx)) {\n        return ctx.map(function(child) {\n          return child.accept(this);\n        }, this);\n      } else {\n        return ctx.accept(this);\n      }\n    }\n    visitChildren(ctx) {\n      if (ctx.children) {\n        return this.visit(ctx.children);\n      } else {\n        return null;\n      }\n    }\n    visitTerminal(node) {\n    }\n    visitErrorNode(node) {\n    }\n  };\n  var ParseTreeListener = class {\n    visitTerminal(node) {\n    }\n    visitErrorNode(node) {\n    }\n    enterEveryRule(node) {\n    }\n    exitEveryRule(node) {\n    }\n  };\n  var TerminalNodeImpl = class extends TerminalNode {\n    constructor(symbol) {\n      super();\n      this.parentCtx = null;\n      this.symbol = symbol;\n    }\n    getChild(i) {\n      return null;\n    }\n    getSymbol() {\n      return this.symbol;\n    }\n    getParent() {\n      return this.parentCtx;\n    }\n    getPayload() {\n      return this.symbol;\n    }\n    getSourceInterval() {\n      if (this.symbol === null) {\n        return INVALID_INTERVAL;\n      }\n      const tokenIndex = this.symbol.tokenIndex;\n      return new Interval(tokenIndex, tokenIndex);\n    }\n    getChildCount() {\n      return 0;\n    }\n    accept(visitor) {\n      return visitor.visitTerminal(this);\n    }\n    getText() {\n      return this.symbol.text;\n    }\n    toString() {\n      if (this.symbol.type === Token2.EOF) {\n        return \"<EOF>\";\n      } else {\n        return this.symbol.text;\n      }\n    }\n  };\n  var ErrorNodeImpl = class extends TerminalNodeImpl {\n    constructor(token) {\n      super(token);\n    }\n    isErrorNode() {\n      return true;\n    }\n    accept(visitor) {\n      return visitor.visitErrorNode(this);\n    }\n  };\n  var ParseTreeWalker = class {\n    walk(listener, t) {\n      const errorNode = t instanceof ErrorNode2 || t.isErrorNode !== void 0 && t.isErrorNode();\n      if (errorNode) {\n        listener.visitErrorNode(t);\n      } else if (t instanceof TerminalNode) {\n        listener.visitTerminal(t);\n      } else {\n        this.enterRule(listener, t);\n        for (let i = 0; i < t.getChildCount(); i++) {\n          const child = t.getChild(i);\n          this.walk(listener, child);\n        }\n        this.exitRule(listener, t);\n      }\n    }\n    enterRule(listener, r) {\n      const ctx = r.getRuleContext();\n      listener.enterEveryRule(ctx);\n      ctx.enterRule(listener);\n    }\n    exitRule(listener, r) {\n      const ctx = r.getRuleContext();\n      ctx.exitRule(listener);\n      listener.exitEveryRule(ctx);\n    }\n  };\n  ParseTreeWalker.DEFAULT = new ParseTreeWalker();\n  module2.exports = {\n    RuleNode,\n    ErrorNode: ErrorNode2,\n    TerminalNode,\n    ErrorNodeImpl,\n    TerminalNodeImpl,\n    ParseTreeListener,\n    ParseTreeVisitor,\n    ParseTreeWalker,\n    INVALID_INTERVAL\n  };\n});\n\n// node_modules/antlr4/src/antlr4/tree/Trees.js\nvar require_Trees2 = __commonJS((exports, module2) => {\n  var Utils3 = require_Utils2();\n  var {Token: Token2} = require_Token2();\n  var {ErrorNode: ErrorNode2, TerminalNode, RuleNode} = require_Tree();\n  var Trees = {\n    toStringTree: function(tree, ruleNames, recog) {\n      ruleNames = ruleNames || null;\n      recog = recog || null;\n      if (recog !== null) {\n        ruleNames = recog.ruleNames;\n      }\n      let s = Trees.getNodeText(tree, ruleNames);\n      s = Utils3.escapeWhitespace(s, false);\n      const c = tree.getChildCount();\n      if (c === 0) {\n        return s;\n      }\n      let res = \"(\" + s + \" \";\n      if (c > 0) {\n        s = Trees.toStringTree(tree.getChild(0), ruleNames);\n        res = res.concat(s);\n      }\n      for (let i = 1; i < c; i++) {\n        s = Trees.toStringTree(tree.getChild(i), ruleNames);\n        res = res.concat(\" \" + s);\n      }\n      res = res.concat(\")\");\n      return res;\n    },\n    getNodeText: function(t, ruleNames, recog) {\n      ruleNames = ruleNames || null;\n      recog = recog || null;\n      if (recog !== null) {\n        ruleNames = recog.ruleNames;\n      }\n      if (ruleNames !== null) {\n        if (t instanceof RuleNode) {\n          const context = t.getRuleContext();\n          const altNumber = context.getAltNumber();\n          if (altNumber != 0) {\n            return ruleNames[t.ruleIndex] + \":\" + altNumber;\n          }\n          return ruleNames[t.ruleIndex];\n        } else if (t instanceof ErrorNode2) {\n          return t.toString();\n        } else if (t instanceof TerminalNode) {\n          if (t.symbol !== null) {\n            return t.symbol.text;\n          }\n        }\n      }\n      const payload = t.getPayload();\n      if (payload instanceof Token2) {\n        return payload.text;\n      }\n      return t.getPayload().toString();\n    },\n    getChildren: function(t) {\n      const list = [];\n      for (let i = 0; i < t.getChildCount(); i++) {\n        list.push(t.getChild(i));\n      }\n      return list;\n    },\n    getAncestors: function(t) {\n      let ancestors = [];\n      t = t.getParent();\n      while (t !== null) {\n        ancestors = [t].concat(ancestors);\n        t = t.getParent();\n      }\n      return ancestors;\n    },\n    findAllTokenNodes: function(t, ttype) {\n      return Trees.findAllNodes(t, ttype, true);\n    },\n    findAllRuleNodes: function(t, ruleIndex) {\n      return Trees.findAllNodes(t, ruleIndex, false);\n    },\n    findAllNodes: function(t, index, findTokens) {\n      const nodes = [];\n      Trees._findAllNodes(t, index, findTokens, nodes);\n      return nodes;\n    },\n    _findAllNodes: function(t, index, findTokens, nodes) {\n      if (findTokens && t instanceof TerminalNode) {\n        if (t.symbol.type === index) {\n          nodes.push(t);\n        }\n      } else if (!findTokens && t instanceof RuleNode) {\n        if (t.ruleIndex === index) {\n          nodes.push(t);\n        }\n      }\n      for (let i = 0; i < t.getChildCount(); i++) {\n        Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);\n      }\n    },\n    descendants: function(t) {\n      let nodes = [t];\n      for (let i = 0; i < t.getChildCount(); i++) {\n        nodes = nodes.concat(Trees.descendants(t.getChild(i)));\n      }\n      return nodes;\n    }\n  };\n  module2.exports = Trees;\n});\n\n// node_modules/antlr4/src/antlr4/RuleContext.js\nvar require_RuleContext2 = __commonJS((exports, module2) => {\n  var {RuleNode} = require_Tree();\n  var {INVALID_INTERVAL} = require_Tree();\n  var Trees = require_Trees2();\n  var RuleContext = class extends RuleNode {\n    constructor(parent, invokingState) {\n      super();\n      this.parentCtx = parent || null;\n      this.invokingState = invokingState || -1;\n    }\n    depth() {\n      let n = 0;\n      let p = this;\n      while (p !== null) {\n        p = p.parentCtx;\n        n += 1;\n      }\n      return n;\n    }\n    isEmpty() {\n      return this.invokingState === -1;\n    }\n    getSourceInterval() {\n      return INVALID_INTERVAL;\n    }\n    getRuleContext() {\n      return this;\n    }\n    getPayload() {\n      return this;\n    }\n    getText() {\n      if (this.getChildCount() === 0) {\n        return \"\";\n      } else {\n        return this.children.map(function(child) {\n          return child.getText();\n        }).join(\"\");\n      }\n    }\n    getAltNumber() {\n      return 0;\n    }\n    setAltNumber(altNumber) {\n    }\n    getChild(i) {\n      return null;\n    }\n    getChildCount() {\n      return 0;\n    }\n    accept(visitor) {\n      return visitor.visitChildren(this);\n    }\n    toStringTree(ruleNames, recog) {\n      return Trees.toStringTree(this, ruleNames, recog);\n    }\n    toString(ruleNames, stop) {\n      ruleNames = ruleNames || null;\n      stop = stop || null;\n      let p = this;\n      let s = \"[\";\n      while (p !== null && p !== stop) {\n        if (ruleNames === null) {\n          if (!p.isEmpty()) {\n            s += p.invokingState;\n          }\n        } else {\n          const ri = p.ruleIndex;\n          const ruleName = ri >= 0 && ri < ruleNames.length ? ruleNames[ri] : \"\" + ri;\n          s += ruleName;\n        }\n        if (p.parentCtx !== null && (ruleNames !== null || !p.parentCtx.isEmpty())) {\n          s += \" \";\n        }\n        p = p.parentCtx;\n      }\n      s += \"]\";\n      return s;\n    }\n  };\n  module2.exports = RuleContext;\n});\n\n// node_modules/antlr4/src/antlr4/PredictionContext.js\nvar require_PredictionContext2 = __commonJS((exports, module2) => {\n  var RuleContext = require_RuleContext2();\n  var {Hash: Hash2, Map: Map2, equalArrays} = require_Utils2();\n  var PredictionContext = class {\n    constructor(cachedHashCode) {\n      this.cachedHashCode = cachedHashCode;\n    }\n    isEmpty() {\n      return this === PredictionContext.EMPTY;\n    }\n    hasEmptyPath() {\n      return this.getReturnState(this.length - 1) === PredictionContext.EMPTY_RETURN_STATE;\n    }\n    hashCode() {\n      return this.cachedHashCode;\n    }\n    updateHashCode(hash) {\n      hash.update(this.cachedHashCode);\n    }\n  };\n  PredictionContext.EMPTY = null;\n  PredictionContext.EMPTY_RETURN_STATE = 2147483647;\n  PredictionContext.globalNodeCount = 1;\n  PredictionContext.id = PredictionContext.globalNodeCount;\n  var PredictionContextCache = class {\n    constructor() {\n      this.cache = new Map2();\n    }\n    add(ctx) {\n      if (ctx === PredictionContext.EMPTY) {\n        return PredictionContext.EMPTY;\n      }\n      const existing = this.cache.get(ctx) || null;\n      if (existing !== null) {\n        return existing;\n      }\n      this.cache.put(ctx, ctx);\n      return ctx;\n    }\n    get(ctx) {\n      return this.cache.get(ctx) || null;\n    }\n    get length() {\n      return this.cache.length;\n    }\n  };\n  var SingletonPredictionContext = class extends PredictionContext {\n    constructor(parent, returnState) {\n      let hashCode = 0;\n      const hash = new Hash2();\n      if (parent !== null) {\n        hash.update(parent, returnState);\n      } else {\n        hash.update(1);\n      }\n      hashCode = hash.finish();\n      super(hashCode);\n      this.parentCtx = parent;\n      this.returnState = returnState;\n    }\n    getParent(index) {\n      return this.parentCtx;\n    }\n    getReturnState(index) {\n      return this.returnState;\n    }\n    equals(other) {\n      if (this === other) {\n        return true;\n      } else if (!(other instanceof SingletonPredictionContext)) {\n        return false;\n      } else if (this.hashCode() !== other.hashCode()) {\n        return false;\n      } else {\n        if (this.returnState !== other.returnState)\n          return false;\n        else if (this.parentCtx == null)\n          return other.parentCtx == null;\n        else\n          return this.parentCtx.equals(other.parentCtx);\n      }\n    }\n    toString() {\n      const up = this.parentCtx === null ? \"\" : this.parentCtx.toString();\n      if (up.length === 0) {\n        if (this.returnState === PredictionContext.EMPTY_RETURN_STATE) {\n          return \"$\";\n        } else {\n          return \"\" + this.returnState;\n        }\n      } else {\n        return \"\" + this.returnState + \" \" + up;\n      }\n    }\n    get length() {\n      return 1;\n    }\n    static create(parent, returnState) {\n      if (returnState === PredictionContext.EMPTY_RETURN_STATE && parent === null) {\n        return PredictionContext.EMPTY;\n      } else {\n        return new SingletonPredictionContext(parent, returnState);\n      }\n    }\n  };\n  var EmptyPredictionContext = class extends SingletonPredictionContext {\n    constructor() {\n      super(null, PredictionContext.EMPTY_RETURN_STATE);\n    }\n    isEmpty() {\n      return true;\n    }\n    getParent(index) {\n      return null;\n    }\n    getReturnState(index) {\n      return this.returnState;\n    }\n    equals(other) {\n      return this === other;\n    }\n    toString() {\n      return \"$\";\n    }\n  };\n  PredictionContext.EMPTY = new EmptyPredictionContext();\n  var ArrayPredictionContext = class extends PredictionContext {\n    constructor(parents, returnStates) {\n      const h = new Hash2();\n      h.update(parents, returnStates);\n      const hashCode = h.finish();\n      super(hashCode);\n      this.parents = parents;\n      this.returnStates = returnStates;\n      return this;\n    }\n    isEmpty() {\n      return this.returnStates[0] === PredictionContext.EMPTY_RETURN_STATE;\n    }\n    getParent(index) {\n      return this.parents[index];\n    }\n    getReturnState(index) {\n      return this.returnStates[index];\n    }\n    equals(other) {\n      if (this === other) {\n        return true;\n      } else if (!(other instanceof ArrayPredictionContext)) {\n        return false;\n      } else if (this.hashCode() !== other.hashCode()) {\n        return false;\n      } else {\n        return equalArrays(this.returnStates, other.returnStates) && equalArrays(this.parents, other.parents);\n      }\n    }\n    toString() {\n      if (this.isEmpty()) {\n        return \"[]\";\n      } else {\n        let s = \"[\";\n        for (let i = 0; i < this.returnStates.length; i++) {\n          if (i > 0) {\n            s = s + \", \";\n          }\n          if (this.returnStates[i] === PredictionContext.EMPTY_RETURN_STATE) {\n            s = s + \"$\";\n            continue;\n          }\n          s = s + this.returnStates[i];\n          if (this.parents[i] !== null) {\n            s = s + \" \" + this.parents[i];\n          } else {\n            s = s + \"null\";\n          }\n        }\n        return s + \"]\";\n      }\n    }\n    get length() {\n      return this.returnStates.length;\n    }\n  };\n  function predictionContextFromRuleContext(atn, outerContext) {\n    if (outerContext === void 0 || outerContext === null) {\n      outerContext = RuleContext.EMPTY;\n    }\n    if (outerContext.parentCtx === null || outerContext === RuleContext.EMPTY) {\n      return PredictionContext.EMPTY;\n    }\n    const parent = predictionContextFromRuleContext(atn, outerContext.parentCtx);\n    const state = atn.states[outerContext.invokingState];\n    const transition = state.transitions[0];\n    return SingletonPredictionContext.create(parent, transition.followState.stateNumber);\n  }\n  function merge(a, b, rootIsWildcard, mergeCache) {\n    if (a === b) {\n      return a;\n    }\n    if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n      return mergeSingletons(a, b, rootIsWildcard, mergeCache);\n    }\n    if (rootIsWildcard) {\n      if (a instanceof EmptyPredictionContext) {\n        return a;\n      }\n      if (b instanceof EmptyPredictionContext) {\n        return b;\n      }\n    }\n    if (a instanceof SingletonPredictionContext) {\n      a = new ArrayPredictionContext([a.getParent()], [a.returnState]);\n    }\n    if (b instanceof SingletonPredictionContext) {\n      b = new ArrayPredictionContext([b.getParent()], [b.returnState]);\n    }\n    return mergeArrays(a, b, rootIsWildcard, mergeCache);\n  }\n  function mergeSingletons(a, b, rootIsWildcard, mergeCache) {\n    if (mergeCache !== null) {\n      let previous = mergeCache.get(a, b);\n      if (previous !== null) {\n        return previous;\n      }\n      previous = mergeCache.get(b, a);\n      if (previous !== null) {\n        return previous;\n      }\n    }\n    const rootMerge = mergeRoot(a, b, rootIsWildcard);\n    if (rootMerge !== null) {\n      if (mergeCache !== null) {\n        mergeCache.set(a, b, rootMerge);\n      }\n      return rootMerge;\n    }\n    if (a.returnState === b.returnState) {\n      const parent = merge(a.parentCtx, b.parentCtx, rootIsWildcard, mergeCache);\n      if (parent === a.parentCtx) {\n        return a;\n      }\n      if (parent === b.parentCtx) {\n        return b;\n      }\n      const spc = SingletonPredictionContext.create(parent, a.returnState);\n      if (mergeCache !== null) {\n        mergeCache.set(a, b, spc);\n      }\n      return spc;\n    } else {\n      let singleParent = null;\n      if (a === b || a.parentCtx !== null && a.parentCtx === b.parentCtx) {\n        singleParent = a.parentCtx;\n      }\n      if (singleParent !== null) {\n        const payloads2 = [a.returnState, b.returnState];\n        if (a.returnState > b.returnState) {\n          payloads2[0] = b.returnState;\n          payloads2[1] = a.returnState;\n        }\n        const parents2 = [singleParent, singleParent];\n        const apc = new ArrayPredictionContext(parents2, payloads2);\n        if (mergeCache !== null) {\n          mergeCache.set(a, b, apc);\n        }\n        return apc;\n      }\n      const payloads = [a.returnState, b.returnState];\n      let parents = [a.parentCtx, b.parentCtx];\n      if (a.returnState > b.returnState) {\n        payloads[0] = b.returnState;\n        payloads[1] = a.returnState;\n        parents = [b.parentCtx, a.parentCtx];\n      }\n      const a_ = new ArrayPredictionContext(parents, payloads);\n      if (mergeCache !== null) {\n        mergeCache.set(a, b, a_);\n      }\n      return a_;\n    }\n  }\n  function mergeRoot(a, b, rootIsWildcard) {\n    if (rootIsWildcard) {\n      if (a === PredictionContext.EMPTY) {\n        return PredictionContext.EMPTY;\n      }\n      if (b === PredictionContext.EMPTY) {\n        return PredictionContext.EMPTY;\n      }\n    } else {\n      if (a === PredictionContext.EMPTY && b === PredictionContext.EMPTY) {\n        return PredictionContext.EMPTY;\n      } else if (a === PredictionContext.EMPTY) {\n        const payloads = [\n          b.returnState,\n          PredictionContext.EMPTY_RETURN_STATE\n        ];\n        const parents = [b.parentCtx, null];\n        return new ArrayPredictionContext(parents, payloads);\n      } else if (b === PredictionContext.EMPTY) {\n        const payloads = [a.returnState, PredictionContext.EMPTY_RETURN_STATE];\n        const parents = [a.parentCtx, null];\n        return new ArrayPredictionContext(parents, payloads);\n      }\n    }\n    return null;\n  }\n  function mergeArrays(a, b, rootIsWildcard, mergeCache) {\n    if (mergeCache !== null) {\n      let previous = mergeCache.get(a, b);\n      if (previous !== null) {\n        return previous;\n      }\n      previous = mergeCache.get(b, a);\n      if (previous !== null) {\n        return previous;\n      }\n    }\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    let mergedReturnStates = [];\n    let mergedParents = [];\n    while (i < a.returnStates.length && j < b.returnStates.length) {\n      const a_parent = a.parents[i];\n      const b_parent = b.parents[j];\n      if (a.returnStates[i] === b.returnStates[j]) {\n        const payload = a.returnStates[i];\n        const bothDollars = payload === PredictionContext.EMPTY_RETURN_STATE && a_parent === null && b_parent === null;\n        const ax_ax = a_parent !== null && b_parent !== null && a_parent === b_parent;\n        if (bothDollars || ax_ax) {\n          mergedParents[k] = a_parent;\n          mergedReturnStates[k] = payload;\n        } else {\n          mergedParents[k] = merge(a_parent, b_parent, rootIsWildcard, mergeCache);\n          mergedReturnStates[k] = payload;\n        }\n        i += 1;\n        j += 1;\n      } else if (a.returnStates[i] < b.returnStates[j]) {\n        mergedParents[k] = a_parent;\n        mergedReturnStates[k] = a.returnStates[i];\n        i += 1;\n      } else {\n        mergedParents[k] = b_parent;\n        mergedReturnStates[k] = b.returnStates[j];\n        j += 1;\n      }\n      k += 1;\n    }\n    if (i < a.returnStates.length) {\n      for (let p = i; p < a.returnStates.length; p++) {\n        mergedParents[k] = a.parents[p];\n        mergedReturnStates[k] = a.returnStates[p];\n        k += 1;\n      }\n    } else {\n      for (let p = j; p < b.returnStates.length; p++) {\n        mergedParents[k] = b.parents[p];\n        mergedReturnStates[k] = b.returnStates[p];\n        k += 1;\n      }\n    }\n    if (k < mergedParents.length) {\n      if (k === 1) {\n        const a_ = SingletonPredictionContext.create(mergedParents[0], mergedReturnStates[0]);\n        if (mergeCache !== null) {\n          mergeCache.set(a, b, a_);\n        }\n        return a_;\n      }\n      mergedParents = mergedParents.slice(0, k);\n      mergedReturnStates = mergedReturnStates.slice(0, k);\n    }\n    const M = new ArrayPredictionContext(mergedParents, mergedReturnStates);\n    if (M === a) {\n      if (mergeCache !== null) {\n        mergeCache.set(a, b, a);\n      }\n      return a;\n    }\n    if (M === b) {\n      if (mergeCache !== null) {\n        mergeCache.set(a, b, b);\n      }\n      return b;\n    }\n    combineCommonParents(mergedParents);\n    if (mergeCache !== null) {\n      mergeCache.set(a, b, M);\n    }\n    return M;\n  }\n  function combineCommonParents(parents) {\n    const uniqueParents = new Map2();\n    for (let p = 0; p < parents.length; p++) {\n      const parent = parents[p];\n      if (!uniqueParents.containsKey(parent)) {\n        uniqueParents.put(parent, parent);\n      }\n    }\n    for (let q = 0; q < parents.length; q++) {\n      parents[q] = uniqueParents.get(parents[q]);\n    }\n  }\n  function getCachedPredictionContext(context, contextCache, visited) {\n    if (context.isEmpty()) {\n      return context;\n    }\n    let existing = visited.get(context) || null;\n    if (existing !== null) {\n      return existing;\n    }\n    existing = contextCache.get(context);\n    if (existing !== null) {\n      visited.put(context, existing);\n      return existing;\n    }\n    let changed = false;\n    let parents = [];\n    for (let i = 0; i < parents.length; i++) {\n      const parent = getCachedPredictionContext(context.getParent(i), contextCache, visited);\n      if (changed || parent !== context.getParent(i)) {\n        if (!changed) {\n          parents = [];\n          for (let j = 0; j < context.length; j++) {\n            parents[j] = context.getParent(j);\n          }\n          changed = true;\n        }\n        parents[i] = parent;\n      }\n    }\n    if (!changed) {\n      contextCache.add(context);\n      visited.put(context, context);\n      return context;\n    }\n    let updated = null;\n    if (parents.length === 0) {\n      updated = PredictionContext.EMPTY;\n    } else if (parents.length === 1) {\n      updated = SingletonPredictionContext.create(parents[0], context.getReturnState(0));\n    } else {\n      updated = new ArrayPredictionContext(parents, context.returnStates);\n    }\n    contextCache.add(updated);\n    visited.put(updated, updated);\n    visited.put(context, updated);\n    return updated;\n  }\n  module2.exports = {\n    merge,\n    PredictionContext,\n    PredictionContextCache,\n    SingletonPredictionContext,\n    predictionContextFromRuleContext,\n    getCachedPredictionContext\n  };\n});\n\n// node_modules/antlr4/src/antlr4/LL1Analyzer.js\nvar require_LL1Analyzer2 = __commonJS((exports, module2) => {\n  var {Set: Set2, BitSet} = require_Utils2();\n  var {Token: Token2} = require_Token2();\n  var {ATNConfig} = require_ATNConfig2();\n  var {IntervalSet} = require_IntervalSet2();\n  var {RuleStopState} = require_ATNState2();\n  var {RuleTransition, NotSetTransition, WildcardTransition, AbstractPredicateTransition} = require_Transition2();\n  var {predictionContextFromRuleContext, PredictionContext, SingletonPredictionContext} = require_PredictionContext2();\n  var LL1Analyzer = class {\n    constructor(atn) {\n      this.atn = atn;\n    }\n    getDecisionLookahead(s) {\n      if (s === null) {\n        return null;\n      }\n      const count = s.transitions.length;\n      const look = [];\n      for (let alt = 0; alt < count; alt++) {\n        look[alt] = new IntervalSet();\n        const lookBusy = new Set2();\n        const seeThruPreds = false;\n        this._LOOK(s.transition(alt).target, null, PredictionContext.EMPTY, look[alt], lookBusy, new BitSet(), seeThruPreds, false);\n        if (look[alt].length === 0 || look[alt].contains(LL1Analyzer.HIT_PRED)) {\n          look[alt] = null;\n        }\n      }\n      return look;\n    }\n    LOOK(s, stopState, ctx) {\n      const r = new IntervalSet();\n      const seeThruPreds = true;\n      ctx = ctx || null;\n      const lookContext = ctx !== null ? predictionContextFromRuleContext(s.atn, ctx) : null;\n      this._LOOK(s, stopState, lookContext, r, new Set2(), new BitSet(), seeThruPreds, true);\n      return r;\n    }\n    _LOOK(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {\n      const c = new ATNConfig({state: s, alt: 0, context: ctx}, null);\n      if (lookBusy.contains(c)) {\n        return;\n      }\n      lookBusy.add(c);\n      if (s === stopState) {\n        if (ctx === null) {\n          look.addOne(Token2.EPSILON);\n          return;\n        } else if (ctx.isEmpty() && addEOF) {\n          look.addOne(Token2.EOF);\n          return;\n        }\n      }\n      if (s instanceof RuleStopState) {\n        if (ctx === null) {\n          look.addOne(Token2.EPSILON);\n          return;\n        } else if (ctx.isEmpty() && addEOF) {\n          look.addOne(Token2.EOF);\n          return;\n        }\n        if (ctx !== PredictionContext.EMPTY) {\n          const removed = calledRuleStack.contains(s.ruleIndex);\n          try {\n            calledRuleStack.remove(s.ruleIndex);\n            for (let i = 0; i < ctx.length; i++) {\n              const returnState = this.atn.states[ctx.getReturnState(i)];\n              this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            }\n          } finally {\n            if (removed) {\n              calledRuleStack.add(s.ruleIndex);\n            }\n          }\n          return;\n        }\n      }\n      for (let j = 0; j < s.transitions.length; j++) {\n        const t = s.transitions[j];\n        if (t.constructor === RuleTransition) {\n          if (calledRuleStack.contains(t.target.ruleIndex)) {\n            continue;\n          }\n          const newContext = SingletonPredictionContext.create(ctx, t.followState.stateNumber);\n          try {\n            calledRuleStack.add(t.target.ruleIndex);\n            this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n          } finally {\n            calledRuleStack.remove(t.target.ruleIndex);\n          }\n        } else if (t instanceof AbstractPredicateTransition) {\n          if (seeThruPreds) {\n            this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n          } else {\n            look.addOne(LL1Analyzer.HIT_PRED);\n          }\n        } else if (t.isEpsilon) {\n          this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t.constructor === WildcardTransition) {\n          look.addRange(Token2.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);\n        } else {\n          let set = t.label;\n          if (set !== null) {\n            if (t instanceof NotSetTransition) {\n              set = set.complement(Token2.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);\n            }\n            look.addSet(set);\n          }\n        }\n      }\n    }\n  };\n  LL1Analyzer.HIT_PRED = Token2.INVALID_TYPE;\n  module2.exports = LL1Analyzer;\n});\n\n// node_modules/antlr4/src/antlr4/atn/ATN.js\nvar require_ATN2 = __commonJS((exports, module2) => {\n  var LL1Analyzer = require_LL1Analyzer2();\n  var {IntervalSet} = require_IntervalSet2();\n  var {Token: Token2} = require_Token2();\n  var ATN2 = class {\n    constructor(grammarType, maxTokenType) {\n      this.grammarType = grammarType;\n      this.maxTokenType = maxTokenType;\n      this.states = [];\n      this.decisionToState = [];\n      this.ruleToStartState = [];\n      this.ruleToStopState = null;\n      this.modeNameToStartState = {};\n      this.ruleToTokenType = null;\n      this.lexerActions = null;\n      this.modeToStartState = [];\n    }\n    nextTokensInContext(s, ctx) {\n      const anal = new LL1Analyzer(this);\n      return anal.LOOK(s, null, ctx);\n    }\n    nextTokensNoContext(s) {\n      if (s.nextTokenWithinRule !== null) {\n        return s.nextTokenWithinRule;\n      }\n      s.nextTokenWithinRule = this.nextTokensInContext(s, null);\n      s.nextTokenWithinRule.readOnly = true;\n      return s.nextTokenWithinRule;\n    }\n    nextTokens(s, ctx) {\n      if (ctx === void 0) {\n        return this.nextTokensNoContext(s);\n      } else {\n        return this.nextTokensInContext(s, ctx);\n      }\n    }\n    addState(state) {\n      if (state !== null) {\n        state.atn = this;\n        state.stateNumber = this.states.length;\n      }\n      this.states.push(state);\n    }\n    removeState(state) {\n      this.states[state.stateNumber] = null;\n    }\n    defineDecisionState(s) {\n      this.decisionToState.push(s);\n      s.decision = this.decisionToState.length - 1;\n      return s.decision;\n    }\n    getDecisionState(decision) {\n      if (this.decisionToState.length === 0) {\n        return null;\n      } else {\n        return this.decisionToState[decision];\n      }\n    }\n    getExpectedTokens(stateNumber, ctx) {\n      if (stateNumber < 0 || stateNumber >= this.states.length) {\n        throw \"Invalid state number.\";\n      }\n      const s = this.states[stateNumber];\n      let following = this.nextTokens(s);\n      if (!following.contains(Token2.EPSILON)) {\n        return following;\n      }\n      const expected = new IntervalSet();\n      expected.addSet(following);\n      expected.removeOne(Token2.EPSILON);\n      while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token2.EPSILON)) {\n        const invokingState = this.states[ctx.invokingState];\n        const rt = invokingState.transitions[0];\n        following = this.nextTokens(rt.followState);\n        expected.addSet(following);\n        expected.removeOne(Token2.EPSILON);\n        ctx = ctx.parentCtx;\n      }\n      if (following.contains(Token2.EPSILON)) {\n        expected.addOne(Token2.EOF);\n      }\n      return expected;\n    }\n  };\n  ATN2.INVALID_ALT_NUMBER = 0;\n  module2.exports = ATN2;\n});\n\n// node_modules/antlr4/src/antlr4/atn/ATNType.js\nvar require_ATNType = __commonJS((exports, module2) => {\n  module2.exports = {\n    LEXER: 0,\n    PARSER: 1\n  };\n});\n\n// node_modules/antlr4/src/antlr4/atn/ATNDeserializationOptions.js\nvar require_ATNDeserializationOptions2 = __commonJS((exports, module2) => {\n  var ATNDeserializationOptions = class {\n    constructor(copyFrom) {\n      if (copyFrom === void 0) {\n        copyFrom = null;\n      }\n      this.readOnly = false;\n      this.verifyATN = copyFrom === null ? true : copyFrom.verifyATN;\n      this.generateRuleBypassTransitions = copyFrom === null ? false : copyFrom.generateRuleBypassTransitions;\n    }\n  };\n  ATNDeserializationOptions.defaultOptions = new ATNDeserializationOptions();\n  ATNDeserializationOptions.defaultOptions.readOnly = true;\n  module2.exports = ATNDeserializationOptions;\n});\n\n// node_modules/antlr4/src/antlr4/atn/LexerAction.js\nvar require_LexerAction = __commonJS((exports, module2) => {\n  var LexerActionType = {\n    CHANNEL: 0,\n    CUSTOM: 1,\n    MODE: 2,\n    MORE: 3,\n    POP_MODE: 4,\n    PUSH_MODE: 5,\n    SKIP: 6,\n    TYPE: 7\n  };\n  var LexerAction = class {\n    constructor(action) {\n      this.actionType = action;\n      this.isPositionDependent = false;\n    }\n    hashCode() {\n      const hash = new Hash();\n      this.updateHashCode(hash);\n      return hash.finish();\n    }\n    updateHashCode(hash) {\n      hash.update(this.actionType);\n    }\n    equals(other) {\n      return this === other;\n    }\n  };\n  var LexerSkipAction = class extends LexerAction {\n    constructor() {\n      super(LexerActionType.SKIP);\n    }\n    execute(lexer) {\n      lexer.skip();\n    }\n    toString() {\n      return \"skip\";\n    }\n  };\n  LexerSkipAction.INSTANCE = new LexerSkipAction();\n  var LexerTypeAction = class extends LexerAction {\n    constructor(type) {\n      super(LexerActionType.TYPE);\n      this.type = type;\n    }\n    execute(lexer) {\n      lexer.type = this.type;\n    }\n    updateHashCode(hash) {\n      hash.update(this.actionType, this.type);\n    }\n    equals(other) {\n      if (this === other) {\n        return true;\n      } else if (!(other instanceof LexerTypeAction)) {\n        return false;\n      } else {\n        return this.type === other.type;\n      }\n    }\n    toString() {\n      return \"type(\" + this.type + \")\";\n    }\n  };\n  var LexerPushModeAction = class extends LexerAction {\n    constructor(mode) {\n      super(LexerActionType.PUSH_MODE);\n      this.mode = mode;\n    }\n    execute(lexer) {\n      lexer.pushMode(this.mode);\n    }\n    updateHashCode(hash) {\n      hash.update(this.actionType, this.mode);\n    }\n    equals(other) {\n      if (this === other) {\n        return true;\n      } else if (!(other instanceof LexerPushModeAction)) {\n        return false;\n      } else {\n        return this.mode === other.mode;\n      }\n    }\n    toString() {\n      return \"pushMode(\" + this.mode + \")\";\n    }\n  };\n  var LexerPopModeAction = class extends LexerAction {\n    constructor() {\n      super(LexerActionType.POP_MODE);\n    }\n    execute(lexer) {\n      lexer.popMode();\n    }\n    toString() {\n      return \"popMode\";\n    }\n  };\n  LexerPopModeAction.INSTANCE = new LexerPopModeAction();\n  var LexerMoreAction = class extends LexerAction {\n    constructor() {\n      super(LexerActionType.MORE);\n    }\n    execute(lexer) {\n      lexer.more();\n    }\n    toString() {\n      return \"more\";\n    }\n  };\n  LexerMoreAction.INSTANCE = new LexerMoreAction();\n  var LexerModeAction = class extends LexerAction {\n    constructor(mode) {\n      super(LexerActionType.MODE);\n      this.mode = mode;\n    }\n    execute(lexer) {\n      lexer.mode(this.mode);\n    }\n    updateHashCode(hash) {\n      hash.update(this.actionType, this.mode);\n    }\n    equals(other) {\n      if (this === other) {\n        return true;\n      } else if (!(other instanceof LexerModeAction)) {\n        return false;\n      } else {\n        return this.mode === other.mode;\n      }\n    }\n    toString() {\n      return \"mode(\" + this.mode + \")\";\n    }\n  };\n  var LexerCustomAction = class extends LexerAction {\n    constructor(ruleIndex, actionIndex) {\n      super(LexerActionType.CUSTOM);\n      this.ruleIndex = ruleIndex;\n      this.actionIndex = actionIndex;\n      this.isPositionDependent = true;\n    }\n    execute(lexer) {\n      lexer.action(null, this.ruleIndex, this.actionIndex);\n    }\n    updateHashCode(hash) {\n      hash.update(this.actionType, this.ruleIndex, this.actionIndex);\n    }\n    equals(other) {\n      if (this === other) {\n        return true;\n      } else if (!(other instanceof LexerCustomAction)) {\n        return false;\n      } else {\n        return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;\n      }\n    }\n  };\n  var LexerChannelAction = class extends LexerAction {\n    constructor(channel) {\n      super(LexerActionType.CHANNEL);\n      this.channel = channel;\n    }\n    execute(lexer) {\n      lexer._channel = this.channel;\n    }\n    updateHashCode(hash) {\n      hash.update(this.actionType, this.channel);\n    }\n    equals(other) {\n      if (this === other) {\n        return true;\n      } else if (!(other instanceof LexerChannelAction)) {\n        return false;\n      } else {\n        return this.channel === other.channel;\n      }\n    }\n    toString() {\n      return \"channel(\" + this.channel + \")\";\n    }\n  };\n  var LexerIndexedCustomAction = class extends LexerAction {\n    constructor(offset, action) {\n      super(action.actionType);\n      this.offset = offset;\n      this.action = action;\n      this.isPositionDependent = true;\n    }\n    execute(lexer) {\n      this.action.execute(lexer);\n    }\n    updateHashCode(hash) {\n      hash.update(this.actionType, this.offset, this.action);\n    }\n    equals(other) {\n      if (this === other) {\n        return true;\n      } else if (!(other instanceof LexerIndexedCustomAction)) {\n        return false;\n      } else {\n        return this.offset === other.offset && this.action === other.action;\n      }\n    }\n  };\n  module2.exports = {\n    LexerActionType,\n    LexerSkipAction,\n    LexerChannelAction,\n    LexerCustomAction,\n    LexerIndexedCustomAction,\n    LexerMoreAction,\n    LexerTypeAction,\n    LexerPushModeAction,\n    LexerPopModeAction,\n    LexerModeAction\n  };\n});\n\n// node_modules/antlr4/src/antlr4/atn/ATNDeserializer.js\nvar require_ATNDeserializer2 = __commonJS((exports, module2) => {\n  var {Token: Token2} = require_Token2();\n  var ATN2 = require_ATN2();\n  var ATNType = require_ATNType();\n  var {\n    ATNState,\n    BasicState,\n    DecisionState,\n    BlockStartState,\n    BlockEndState,\n    LoopEndState,\n    RuleStartState,\n    RuleStopState,\n    TokensStartState,\n    PlusLoopbackState,\n    StarLoopbackState,\n    StarLoopEntryState,\n    PlusBlockStartState,\n    StarBlockStartState,\n    BasicBlockStartState\n  } = require_ATNState2();\n  var {\n    Transition,\n    AtomTransition: AtomTransition2,\n    SetTransition,\n    NotSetTransition,\n    RuleTransition,\n    RangeTransition,\n    ActionTransition,\n    EpsilonTransition,\n    WildcardTransition,\n    PredicateTransition,\n    PrecedencePredicateTransition\n  } = require_Transition2();\n  var {IntervalSet} = require_IntervalSet2();\n  var ATNDeserializationOptions = require_ATNDeserializationOptions2();\n  var {\n    LexerActionType,\n    LexerSkipAction,\n    LexerChannelAction,\n    LexerCustomAction,\n    LexerMoreAction,\n    LexerTypeAction,\n    LexerPushModeAction,\n    LexerPopModeAction,\n    LexerModeAction\n  } = require_LexerAction();\n  var BASE_SERIALIZED_UUID = \"AADB8D7E-AEEF-4415-AD2B-8204D6CF042E\";\n  var ADDED_UNICODE_SMP = \"59627784-3BE5-417A-B9EB-8131A7286089\";\n  var SUPPORTED_UUIDS = [BASE_SERIALIZED_UUID, ADDED_UNICODE_SMP];\n  var SERIALIZED_VERSION = 3;\n  var SERIALIZED_UUID = ADDED_UNICODE_SMP;\n  function initArray(length, value) {\n    const tmp = [];\n    tmp[length - 1] = value;\n    return tmp.map(function(i) {\n      return value;\n    });\n  }\n  var ATNDeserializer3 = class {\n    constructor(options) {\n      if (options === void 0 || options === null) {\n        options = ATNDeserializationOptions.defaultOptions;\n      }\n      this.deserializationOptions = options;\n      this.stateFactories = null;\n      this.actionFactories = null;\n    }\n    isFeatureSupported(feature, actualUuid) {\n      const idx1 = SUPPORTED_UUIDS.indexOf(feature);\n      if (idx1 < 0) {\n        return false;\n      }\n      const idx2 = SUPPORTED_UUIDS.indexOf(actualUuid);\n      return idx2 >= idx1;\n    }\n    deserialize(data) {\n      this.reset(data);\n      this.checkVersion();\n      this.checkUUID();\n      const atn = this.readATN();\n      this.readStates(atn);\n      this.readRules(atn);\n      this.readModes(atn);\n      const sets = [];\n      this.readSets(atn, sets, this.readInt.bind(this));\n      if (this.isFeatureSupported(ADDED_UNICODE_SMP, this.uuid)) {\n        this.readSets(atn, sets, this.readInt32.bind(this));\n      }\n      this.readEdges(atn, sets);\n      this.readDecisions(atn);\n      this.readLexerActions(atn);\n      this.markPrecedenceDecisions(atn);\n      this.verifyATN(atn);\n      if (this.deserializationOptions.generateRuleBypassTransitions && atn.grammarType === ATNType.PARSER) {\n        this.generateRuleBypassTransitions(atn);\n        this.verifyATN(atn);\n      }\n      return atn;\n    }\n    reset(data) {\n      const adjust = function(c) {\n        const v = c.charCodeAt(0);\n        return v > 1 ? v - 2 : v + 65534;\n      };\n      const temp = data.split(\"\").map(adjust);\n      temp[0] = data.charCodeAt(0);\n      this.data = temp;\n      this.pos = 0;\n    }\n    checkVersion() {\n      const version = this.readInt();\n      if (version !== SERIALIZED_VERSION) {\n        throw \"Could not deserialize ATN with version \" + version + \" (expected \" + SERIALIZED_VERSION + \").\";\n      }\n    }\n    checkUUID() {\n      const uuid = this.readUUID();\n      if (SUPPORTED_UUIDS.indexOf(uuid) < 0) {\n        throw \"Could not deserialize ATN with UUID: \" + uuid + \" (expected \" + SERIALIZED_UUID + \" or a legacy UUID).\", uuid, SERIALIZED_UUID;\n      }\n      this.uuid = uuid;\n    }\n    readATN() {\n      const grammarType = this.readInt();\n      const maxTokenType = this.readInt();\n      return new ATN2(grammarType, maxTokenType);\n    }\n    readStates(atn) {\n      let j, pair, stateNumber;\n      const loopBackStateNumbers = [];\n      const endStateNumbers = [];\n      const nstates = this.readInt();\n      for (let i = 0; i < nstates; i++) {\n        const stype = this.readInt();\n        if (stype === ATNState.INVALID_TYPE) {\n          atn.addState(null);\n          continue;\n        }\n        let ruleIndex = this.readInt();\n        if (ruleIndex === 65535) {\n          ruleIndex = -1;\n        }\n        const s = this.stateFactory(stype, ruleIndex);\n        if (stype === ATNState.LOOP_END) {\n          const loopBackStateNumber = this.readInt();\n          loopBackStateNumbers.push([s, loopBackStateNumber]);\n        } else if (s instanceof BlockStartState) {\n          const endStateNumber = this.readInt();\n          endStateNumbers.push([s, endStateNumber]);\n        }\n        atn.addState(s);\n      }\n      for (j = 0; j < loopBackStateNumbers.length; j++) {\n        pair = loopBackStateNumbers[j];\n        pair[0].loopBackState = atn.states[pair[1]];\n      }\n      for (j = 0; j < endStateNumbers.length; j++) {\n        pair = endStateNumbers[j];\n        pair[0].endState = atn.states[pair[1]];\n      }\n      let numNonGreedyStates = this.readInt();\n      for (j = 0; j < numNonGreedyStates; j++) {\n        stateNumber = this.readInt();\n        atn.states[stateNumber].nonGreedy = true;\n      }\n      let numPrecedenceStates = this.readInt();\n      for (j = 0; j < numPrecedenceStates; j++) {\n        stateNumber = this.readInt();\n        atn.states[stateNumber].isPrecedenceRule = true;\n      }\n    }\n    readRules(atn) {\n      let i;\n      const nrules = this.readInt();\n      if (atn.grammarType === ATNType.LEXER) {\n        atn.ruleToTokenType = initArray(nrules, 0);\n      }\n      atn.ruleToStartState = initArray(nrules, 0);\n      for (i = 0; i < nrules; i++) {\n        const s = this.readInt();\n        atn.ruleToStartState[i] = atn.states[s];\n        if (atn.grammarType === ATNType.LEXER) {\n          let tokenType = this.readInt();\n          if (tokenType === 65535) {\n            tokenType = Token2.EOF;\n          }\n          atn.ruleToTokenType[i] = tokenType;\n        }\n      }\n      atn.ruleToStopState = initArray(nrules, 0);\n      for (i = 0; i < atn.states.length; i++) {\n        const state = atn.states[i];\n        if (!(state instanceof RuleStopState)) {\n          continue;\n        }\n        atn.ruleToStopState[state.ruleIndex] = state;\n        atn.ruleToStartState[state.ruleIndex].stopState = state;\n      }\n    }\n    readModes(atn) {\n      const nmodes = this.readInt();\n      for (let i = 0; i < nmodes; i++) {\n        let s = this.readInt();\n        atn.modeToStartState.push(atn.states[s]);\n      }\n    }\n    readSets(atn, sets, readUnicode) {\n      const m = this.readInt();\n      for (let i = 0; i < m; i++) {\n        const iset = new IntervalSet();\n        sets.push(iset);\n        const n = this.readInt();\n        const containsEof = this.readInt();\n        if (containsEof !== 0) {\n          iset.addOne(-1);\n        }\n        for (let j = 0; j < n; j++) {\n          const i1 = readUnicode();\n          const i2 = readUnicode();\n          iset.addRange(i1, i2);\n        }\n      }\n    }\n    readEdges(atn, sets) {\n      let i, j, state, trans, target;\n      const nedges = this.readInt();\n      for (i = 0; i < nedges; i++) {\n        const src = this.readInt();\n        const trg = this.readInt();\n        const ttype = this.readInt();\n        const arg1 = this.readInt();\n        const arg2 = this.readInt();\n        const arg3 = this.readInt();\n        trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);\n        const srcState = atn.states[src];\n        srcState.addTransition(trans);\n      }\n      for (i = 0; i < atn.states.length; i++) {\n        state = atn.states[i];\n        for (j = 0; j < state.transitions.length; j++) {\n          const t = state.transitions[j];\n          if (!(t instanceof RuleTransition)) {\n            continue;\n          }\n          let outermostPrecedenceReturn = -1;\n          if (atn.ruleToStartState[t.target.ruleIndex].isPrecedenceRule) {\n            if (t.precedence === 0) {\n              outermostPrecedenceReturn = t.target.ruleIndex;\n            }\n          }\n          trans = new EpsilonTransition(t.followState, outermostPrecedenceReturn);\n          atn.ruleToStopState[t.target.ruleIndex].addTransition(trans);\n        }\n      }\n      for (i = 0; i < atn.states.length; i++) {\n        state = atn.states[i];\n        if (state instanceof BlockStartState) {\n          if (state.endState === null) {\n            throw \"IllegalState\";\n          }\n          if (state.endState.startState !== null) {\n            throw \"IllegalState\";\n          }\n          state.endState.startState = state;\n        }\n        if (state instanceof PlusLoopbackState) {\n          for (j = 0; j < state.transitions.length; j++) {\n            target = state.transitions[j].target;\n            if (target instanceof PlusBlockStartState) {\n              target.loopBackState = state;\n            }\n          }\n        } else if (state instanceof StarLoopbackState) {\n          for (j = 0; j < state.transitions.length; j++) {\n            target = state.transitions[j].target;\n            if (target instanceof StarLoopEntryState) {\n              target.loopBackState = state;\n            }\n          }\n        }\n      }\n    }\n    readDecisions(atn) {\n      const ndecisions = this.readInt();\n      for (let i = 0; i < ndecisions; i++) {\n        const s = this.readInt();\n        const decState = atn.states[s];\n        atn.decisionToState.push(decState);\n        decState.decision = i;\n      }\n    }\n    readLexerActions(atn) {\n      if (atn.grammarType === ATNType.LEXER) {\n        const count = this.readInt();\n        atn.lexerActions = initArray(count, null);\n        for (let i = 0; i < count; i++) {\n          const actionType = this.readInt();\n          let data1 = this.readInt();\n          if (data1 === 65535) {\n            data1 = -1;\n          }\n          let data2 = this.readInt();\n          if (data2 === 65535) {\n            data2 = -1;\n          }\n          atn.lexerActions[i] = this.lexerActionFactory(actionType, data1, data2);\n        }\n      }\n    }\n    generateRuleBypassTransitions(atn) {\n      let i;\n      const count = atn.ruleToStartState.length;\n      for (i = 0; i < count; i++) {\n        atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;\n      }\n      for (i = 0; i < count; i++) {\n        this.generateRuleBypassTransition(atn, i);\n      }\n    }\n    generateRuleBypassTransition(atn, idx) {\n      let i, state;\n      const bypassStart = new BasicBlockStartState();\n      bypassStart.ruleIndex = idx;\n      atn.addState(bypassStart);\n      const bypassStop = new BlockEndState();\n      bypassStop.ruleIndex = idx;\n      atn.addState(bypassStop);\n      bypassStart.endState = bypassStop;\n      atn.defineDecisionState(bypassStart);\n      bypassStop.startState = bypassStart;\n      let excludeTransition = null;\n      let endState = null;\n      if (atn.ruleToStartState[idx].isPrecedenceRule) {\n        endState = null;\n        for (i = 0; i < atn.states.length; i++) {\n          state = atn.states[i];\n          if (this.stateIsEndStateFor(state, idx)) {\n            endState = state;\n            excludeTransition = state.loopBackState.transitions[0];\n            break;\n          }\n        }\n        if (excludeTransition === null) {\n          throw \"Couldn't identify final state of the precedence rule prefix section.\";\n        }\n      } else {\n        endState = atn.ruleToStopState[idx];\n      }\n      for (i = 0; i < atn.states.length; i++) {\n        state = atn.states[i];\n        for (let j = 0; j < state.transitions.length; j++) {\n          const transition = state.transitions[j];\n          if (transition === excludeTransition) {\n            continue;\n          }\n          if (transition.target === endState) {\n            transition.target = bypassStop;\n          }\n        }\n      }\n      const ruleToStartState = atn.ruleToStartState[idx];\n      const count = ruleToStartState.transitions.length;\n      while (count > 0) {\n        bypassStart.addTransition(ruleToStartState.transitions[count - 1]);\n        ruleToStartState.transitions = ruleToStartState.transitions.slice(-1);\n      }\n      atn.ruleToStartState[idx].addTransition(new EpsilonTransition(bypassStart));\n      bypassStop.addTransition(new EpsilonTransition(endState));\n      const matchState = new BasicState();\n      atn.addState(matchState);\n      matchState.addTransition(new AtomTransition2(bypassStop, atn.ruleToTokenType[idx]));\n      bypassStart.addTransition(new EpsilonTransition(matchState));\n    }\n    stateIsEndStateFor(state, idx) {\n      if (state.ruleIndex !== idx) {\n        return null;\n      }\n      if (!(state instanceof StarLoopEntryState)) {\n        return null;\n      }\n      const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;\n      if (!(maybeLoopEndState instanceof LoopEndState)) {\n        return null;\n      }\n      if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof RuleStopState) {\n        return state;\n      } else {\n        return null;\n      }\n    }\n    markPrecedenceDecisions(atn) {\n      for (let i = 0; i < atn.states.length; i++) {\n        const state = atn.states[i];\n        if (!(state instanceof StarLoopEntryState)) {\n          continue;\n        }\n        if (atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {\n          const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;\n          if (maybeLoopEndState instanceof LoopEndState) {\n            if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof RuleStopState) {\n              state.isPrecedenceDecision = true;\n            }\n          }\n        }\n      }\n    }\n    verifyATN(atn) {\n      if (!this.deserializationOptions.verifyATN) {\n        return;\n      }\n      for (let i = 0; i < atn.states.length; i++) {\n        const state = atn.states[i];\n        if (state === null) {\n          continue;\n        }\n        this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);\n        if (state instanceof PlusBlockStartState) {\n          this.checkCondition(state.loopBackState !== null);\n        } else if (state instanceof StarLoopEntryState) {\n          this.checkCondition(state.loopBackState !== null);\n          this.checkCondition(state.transitions.length === 2);\n          if (state.transitions[0].target instanceof StarBlockStartState) {\n            this.checkCondition(state.transitions[1].target instanceof LoopEndState);\n            this.checkCondition(!state.nonGreedy);\n          } else if (state.transitions[0].target instanceof LoopEndState) {\n            this.checkCondition(state.transitions[1].target instanceof StarBlockStartState);\n            this.checkCondition(state.nonGreedy);\n          } else {\n            throw \"IllegalState\";\n          }\n        } else if (state instanceof StarLoopbackState) {\n          this.checkCondition(state.transitions.length === 1);\n          this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState);\n        } else if (state instanceof LoopEndState) {\n          this.checkCondition(state.loopBackState !== null);\n        } else if (state instanceof RuleStartState) {\n          this.checkCondition(state.stopState !== null);\n        } else if (state instanceof BlockStartState) {\n          this.checkCondition(state.endState !== null);\n        } else if (state instanceof BlockEndState) {\n          this.checkCondition(state.startState !== null);\n        } else if (state instanceof DecisionState) {\n          this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);\n        } else {\n          this.checkCondition(state.transitions.length <= 1 || state instanceof RuleStopState);\n        }\n      }\n    }\n    checkCondition(condition, message) {\n      if (!condition) {\n        if (message === void 0 || message === null) {\n          message = \"IllegalState\";\n        }\n        throw message;\n      }\n    }\n    readInt() {\n      return this.data[this.pos++];\n    }\n    readInt32() {\n      const low = this.readInt();\n      const high = this.readInt();\n      return low | high << 16;\n    }\n    readLong() {\n      const low = this.readInt32();\n      const high = this.readInt32();\n      return low & 4294967295 | high << 32;\n    }\n    readUUID() {\n      const bb = [];\n      for (let i = 7; i >= 0; i--) {\n        const int = this.readInt();\n        bb[2 * i + 1] = int & 255;\n        bb[2 * i] = int >> 8 & 255;\n      }\n      return byteToHex[bb[0]] + byteToHex[bb[1]] + byteToHex[bb[2]] + byteToHex[bb[3]] + \"-\" + byteToHex[bb[4]] + byteToHex[bb[5]] + \"-\" + byteToHex[bb[6]] + byteToHex[bb[7]] + \"-\" + byteToHex[bb[8]] + byteToHex[bb[9]] + \"-\" + byteToHex[bb[10]] + byteToHex[bb[11]] + byteToHex[bb[12]] + byteToHex[bb[13]] + byteToHex[bb[14]] + byteToHex[bb[15]];\n    }\n    edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {\n      const target = atn.states[trg];\n      switch (type) {\n        case Transition.EPSILON:\n          return new EpsilonTransition(target);\n        case Transition.RANGE:\n          return arg3 !== 0 ? new RangeTransition(target, Token2.EOF, arg2) : new RangeTransition(target, arg1, arg2);\n        case Transition.RULE:\n          return new RuleTransition(atn.states[arg1], arg2, arg3, target);\n        case Transition.PREDICATE:\n          return new PredicateTransition(target, arg1, arg2, arg3 !== 0);\n        case Transition.PRECEDENCE:\n          return new PrecedencePredicateTransition(target, arg1);\n        case Transition.ATOM:\n          return arg3 !== 0 ? new AtomTransition2(target, Token2.EOF) : new AtomTransition2(target, arg1);\n        case Transition.ACTION:\n          return new ActionTransition(target, arg1, arg2, arg3 !== 0);\n        case Transition.SET:\n          return new SetTransition(target, sets[arg1]);\n        case Transition.NOT_SET:\n          return new NotSetTransition(target, sets[arg1]);\n        case Transition.WILDCARD:\n          return new WildcardTransition(target);\n        default:\n          throw \"The specified transition type: \" + type + \" is not valid.\";\n      }\n    }\n    stateFactory(type, ruleIndex) {\n      if (this.stateFactories === null) {\n        const sf = [];\n        sf[ATNState.INVALID_TYPE] = null;\n        sf[ATNState.BASIC] = () => new BasicState();\n        sf[ATNState.RULE_START] = () => new RuleStartState();\n        sf[ATNState.BLOCK_START] = () => new BasicBlockStartState();\n        sf[ATNState.PLUS_BLOCK_START] = () => new PlusBlockStartState();\n        sf[ATNState.STAR_BLOCK_START] = () => new StarBlockStartState();\n        sf[ATNState.TOKEN_START] = () => new TokensStartState();\n        sf[ATNState.RULE_STOP] = () => new RuleStopState();\n        sf[ATNState.BLOCK_END] = () => new BlockEndState();\n        sf[ATNState.STAR_LOOP_BACK] = () => new StarLoopbackState();\n        sf[ATNState.STAR_LOOP_ENTRY] = () => new StarLoopEntryState();\n        sf[ATNState.PLUS_LOOP_BACK] = () => new PlusLoopbackState();\n        sf[ATNState.LOOP_END] = () => new LoopEndState();\n        this.stateFactories = sf;\n      }\n      if (type > this.stateFactories.length || this.stateFactories[type] === null) {\n        throw \"The specified state type \" + type + \" is not valid.\";\n      } else {\n        const s = this.stateFactories[type]();\n        if (s !== null) {\n          s.ruleIndex = ruleIndex;\n          return s;\n        }\n      }\n    }\n    lexerActionFactory(type, data1, data2) {\n      if (this.actionFactories === null) {\n        const af = [];\n        af[LexerActionType.CHANNEL] = (data12, data22) => new LexerChannelAction(data12);\n        af[LexerActionType.CUSTOM] = (data12, data22) => new LexerCustomAction(data12, data22);\n        af[LexerActionType.MODE] = (data12, data22) => new LexerModeAction(data12);\n        af[LexerActionType.MORE] = (data12, data22) => LexerMoreAction.INSTANCE;\n        af[LexerActionType.POP_MODE] = (data12, data22) => LexerPopModeAction.INSTANCE;\n        af[LexerActionType.PUSH_MODE] = (data12, data22) => new LexerPushModeAction(data12);\n        af[LexerActionType.SKIP] = (data12, data22) => LexerSkipAction.INSTANCE;\n        af[LexerActionType.TYPE] = (data12, data22) => new LexerTypeAction(data12);\n        this.actionFactories = af;\n      }\n      if (type > this.actionFactories.length || this.actionFactories[type] === null) {\n        throw \"The specified lexer action type \" + type + \" is not valid.\";\n      } else {\n        return this.actionFactories[type](data1, data2);\n      }\n    }\n  };\n  function createByteToHex() {\n    const bth = [];\n    for (let i = 0; i < 256; i++) {\n      bth[i] = (i + 256).toString(16).substr(1).toUpperCase();\n    }\n    return bth;\n  }\n  var byteToHex = createByteToHex();\n  module2.exports = ATNDeserializer3;\n});\n\n// node_modules/antlr4/src/antlr4/error/ErrorListener.js\nvar require_ErrorListener = __commonJS((exports, module2) => {\n  var ErrorListener2 = class {\n    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {\n    }\n    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n    }\n    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n    }\n    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n    }\n  };\n  var ConsoleErrorListener = class extends ErrorListener2 {\n    constructor() {\n      super();\n    }\n    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {\n      console.error(\"line \" + line + \":\" + column + \" \" + msg);\n    }\n  };\n  ConsoleErrorListener.INSTANCE = new ConsoleErrorListener();\n  var ProxyErrorListener = class extends ErrorListener2 {\n    constructor(delegates) {\n      super();\n      if (delegates === null) {\n        throw \"delegates\";\n      }\n      this.delegates = delegates;\n      return this;\n    }\n    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {\n      this.delegates.map((d) => d.syntaxError(recognizer, offendingSymbol, line, column, msg, e));\n    }\n    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n      this.delegates.map((d) => d.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs));\n    }\n    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n      this.delegates.map((d) => d.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs));\n    }\n    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n      this.delegates.map((d) => d.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs));\n    }\n  };\n  module2.exports = {ErrorListener: ErrorListener2, ConsoleErrorListener, ProxyErrorListener};\n});\n\n// node_modules/antlr4/src/antlr4/Recognizer.js\nvar require_Recognizer2 = __commonJS((exports, module2) => {\n  var {Token: Token2} = require_Token2();\n  var {ConsoleErrorListener} = require_ErrorListener();\n  var {ProxyErrorListener} = require_ErrorListener();\n  var Recognizer = class {\n    constructor() {\n      this._listeners = [ConsoleErrorListener.INSTANCE];\n      this._interp = null;\n      this._stateNumber = -1;\n    }\n    checkVersion(toolVersion) {\n      const runtimeVersion = \"4.9.2\";\n      if (runtimeVersion !== toolVersion) {\n        console.log(\"ANTLR runtime and generated code versions disagree: \" + runtimeVersion + \"!=\" + toolVersion);\n      }\n    }\n    addErrorListener(listener) {\n      this._listeners.push(listener);\n    }\n    removeErrorListeners() {\n      this._listeners = [];\n    }\n    getTokenTypeMap() {\n      const tokenNames = this.getTokenNames();\n      if (tokenNames === null) {\n        throw \"The current recognizer does not provide a list of token names.\";\n      }\n      let result = this.tokenTypeMapCache[tokenNames];\n      if (result === void 0) {\n        result = tokenNames.reduce(function(o, k, i) {\n          o[k] = i;\n        });\n        result.EOF = Token2.EOF;\n        this.tokenTypeMapCache[tokenNames] = result;\n      }\n      return result;\n    }\n    getRuleIndexMap() {\n      const ruleNames = this.ruleNames;\n      if (ruleNames === null) {\n        throw \"The current recognizer does not provide a list of rule names.\";\n      }\n      let result = this.ruleIndexMapCache[ruleNames];\n      if (result === void 0) {\n        result = ruleNames.reduce(function(o, k, i) {\n          o[k] = i;\n        });\n        this.ruleIndexMapCache[ruleNames] = result;\n      }\n      return result;\n    }\n    getTokenType(tokenName) {\n      const ttype = this.getTokenTypeMap()[tokenName];\n      if (ttype !== void 0) {\n        return ttype;\n      } else {\n        return Token2.INVALID_TYPE;\n      }\n    }\n    getErrorHeader(e) {\n      const line = e.getOffendingToken().line;\n      const column = e.getOffendingToken().column;\n      return \"line \" + line + \":\" + column;\n    }\n    getTokenErrorDisplay(t) {\n      if (t === null) {\n        return \"<no token>\";\n      }\n      let s = t.text;\n      if (s === null) {\n        if (t.type === Token2.EOF) {\n          s = \"<EOF>\";\n        } else {\n          s = \"<\" + t.type + \">\";\n        }\n      }\n      s = s.replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\").replace(\"\t\", \"\\\\t\");\n      return \"'\" + s + \"'\";\n    }\n    getErrorListenerDispatch() {\n      return new ProxyErrorListener(this._listeners);\n    }\n    sempred(localctx, ruleIndex, actionIndex) {\n      return true;\n    }\n    precpred(localctx, precedence) {\n      return true;\n    }\n    get state() {\n      return this._stateNumber;\n    }\n    set state(state) {\n      this._stateNumber = state;\n    }\n  };\n  Recognizer.tokenTypeMapCache = {};\n  Recognizer.ruleIndexMapCache = {};\n  module2.exports = Recognizer;\n});\n\n// node_modules/antlr4/src/antlr4/CommonTokenFactory.js\nvar require_CommonTokenFactory2 = __commonJS((exports, module2) => {\n  var CommonToken = require_Token2().CommonToken;\n  var TokenFactory = class {\n  };\n  var CommonTokenFactory = class extends TokenFactory {\n    constructor(copyText) {\n      super();\n      this.copyText = copyText === void 0 ? false : copyText;\n    }\n    create(source, type, text, channel, start, stop, line, column) {\n      const t = new CommonToken(source, type, channel, start, stop);\n      t.line = line;\n      t.column = column;\n      if (text !== null) {\n        t.text = text;\n      } else if (this.copyText && source[1] !== null) {\n        t.text = source[1].getText(start, stop);\n      }\n      return t;\n    }\n    createThin(type, text) {\n      const t = new CommonToken(null, type);\n      t.text = text;\n      return t;\n    }\n  };\n  CommonTokenFactory.DEFAULT = new CommonTokenFactory();\n  module2.exports = CommonTokenFactory;\n});\n\n// node_modules/antlr4/src/antlr4/error/Errors.js\nvar require_Errors = __commonJS((exports, module2) => {\n  var {PredicateTransition} = require_Transition2();\n  var {Interval} = require_IntervalSet2().Interval;\n  var RecognitionException2 = class extends Error {\n    constructor(params) {\n      super(params.message);\n      if (!!Error.captureStackTrace) {\n        Error.captureStackTrace(this, RecognitionException2);\n      } else {\n        var stack = new Error().stack;\n      }\n      this.message = params.message;\n      this.recognizer = params.recognizer;\n      this.input = params.input;\n      this.ctx = params.ctx;\n      this.offendingToken = null;\n      this.offendingState = -1;\n      if (this.recognizer !== null) {\n        this.offendingState = this.recognizer.state;\n      }\n    }\n    getExpectedTokens() {\n      if (this.recognizer !== null) {\n        return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);\n      } else {\n        return null;\n      }\n    }\n    toString() {\n      return this.message;\n    }\n  };\n  var LexerNoViableAltException = class extends RecognitionException2 {\n    constructor(lexer, input, startIndex, deadEndConfigs) {\n      super({message: \"\", recognizer: lexer, input, ctx: null});\n      this.startIndex = startIndex;\n      this.deadEndConfigs = deadEndConfigs;\n    }\n    toString() {\n      let symbol = \"\";\n      if (this.startIndex >= 0 && this.startIndex < this.input.size) {\n        symbol = this.input.getText(new Interval(this.startIndex, this.startIndex));\n      }\n      return \"LexerNoViableAltException\" + symbol;\n    }\n  };\n  var NoViableAltException2 = class extends RecognitionException2 {\n    constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {\n      ctx = ctx || recognizer._ctx;\n      offendingToken = offendingToken || recognizer.getCurrentToken();\n      startToken = startToken || recognizer.getCurrentToken();\n      input = input || recognizer.getInputStream();\n      super({message: \"\", recognizer, input, ctx});\n      this.deadEndConfigs = deadEndConfigs;\n      this.startToken = startToken;\n      this.offendingToken = offendingToken;\n    }\n  };\n  var InputMismatchException = class extends RecognitionException2 {\n    constructor(recognizer) {\n      super({message: \"\", recognizer, input: recognizer.getInputStream(), ctx: recognizer._ctx});\n      this.offendingToken = recognizer.getCurrentToken();\n    }\n  };\n  function formatMessage(predicate, message) {\n    if (message !== null) {\n      return message;\n    } else {\n      return \"failed predicate: {\" + predicate + \"}?\";\n    }\n  }\n  var FailedPredicateException2 = class extends RecognitionException2 {\n    constructor(recognizer, predicate, message) {\n      super({\n        message: formatMessage(predicate, message || null),\n        recognizer,\n        input: recognizer.getInputStream(),\n        ctx: recognizer._ctx\n      });\n      const s = recognizer._interp.atn.states[recognizer.state];\n      const trans = s.transitions[0];\n      if (trans instanceof PredicateTransition) {\n        this.ruleIndex = trans.ruleIndex;\n        this.predicateIndex = trans.predIndex;\n      } else {\n        this.ruleIndex = 0;\n        this.predicateIndex = 0;\n      }\n      this.predicate = predicate;\n      this.offendingToken = recognizer.getCurrentToken();\n    }\n  };\n  var ParseCancellationException = class extends Error {\n    constructor() {\n      super();\n      Error.captureStackTrace(this, ParseCancellationException);\n    }\n  };\n  module2.exports = {\n    RecognitionException: RecognitionException2,\n    NoViableAltException: NoViableAltException2,\n    LexerNoViableAltException,\n    InputMismatchException,\n    FailedPredicateException: FailedPredicateException2,\n    ParseCancellationException\n  };\n});\n\n// node_modules/antlr4/src/antlr4/Lexer.js\nvar require_Lexer2 = __commonJS((exports, module2) => {\n  var {Token: Token2} = require_Token2();\n  var Recognizer = require_Recognizer2();\n  var CommonTokenFactory = require_CommonTokenFactory2();\n  var {RecognitionException: RecognitionException2} = require_Errors();\n  var {LexerNoViableAltException} = require_Errors();\n  var Lexer2 = class extends Recognizer {\n    constructor(input) {\n      super();\n      this._input = input;\n      this._factory = CommonTokenFactory.DEFAULT;\n      this._tokenFactorySourcePair = [this, input];\n      this._interp = null;\n      this._token = null;\n      this._tokenStartCharIndex = -1;\n      this._tokenStartLine = -1;\n      this._tokenStartColumn = -1;\n      this._hitEOF = false;\n      this._channel = Token2.DEFAULT_CHANNEL;\n      this._type = Token2.INVALID_TYPE;\n      this._modeStack = [];\n      this._mode = Lexer2.DEFAULT_MODE;\n      this._text = null;\n    }\n    reset() {\n      if (this._input !== null) {\n        this._input.seek(0);\n      }\n      this._token = null;\n      this._type = Token2.INVALID_TYPE;\n      this._channel = Token2.DEFAULT_CHANNEL;\n      this._tokenStartCharIndex = -1;\n      this._tokenStartColumn = -1;\n      this._tokenStartLine = -1;\n      this._text = null;\n      this._hitEOF = false;\n      this._mode = Lexer2.DEFAULT_MODE;\n      this._modeStack = [];\n      this._interp.reset();\n    }\n    nextToken() {\n      if (this._input === null) {\n        throw \"nextToken requires a non-null input stream.\";\n      }\n      const tokenStartMarker = this._input.mark();\n      try {\n        while (true) {\n          if (this._hitEOF) {\n            this.emitEOF();\n            return this._token;\n          }\n          this._token = null;\n          this._channel = Token2.DEFAULT_CHANNEL;\n          this._tokenStartCharIndex = this._input.index;\n          this._tokenStartColumn = this._interp.column;\n          this._tokenStartLine = this._interp.line;\n          this._text = null;\n          let continueOuter = false;\n          while (true) {\n            this._type = Token2.INVALID_TYPE;\n            let ttype = Lexer2.SKIP;\n            try {\n              ttype = this._interp.match(this._input, this._mode);\n            } catch (e) {\n              if (e instanceof RecognitionException2) {\n                this.notifyListeners(e);\n                this.recover(e);\n              } else {\n                console.log(e.stack);\n                throw e;\n              }\n            }\n            if (this._input.LA(1) === Token2.EOF) {\n              this._hitEOF = true;\n            }\n            if (this._type === Token2.INVALID_TYPE) {\n              this._type = ttype;\n            }\n            if (this._type === Lexer2.SKIP) {\n              continueOuter = true;\n              break;\n            }\n            if (this._type !== Lexer2.MORE) {\n              break;\n            }\n          }\n          if (continueOuter) {\n            continue;\n          }\n          if (this._token === null) {\n            this.emit();\n          }\n          return this._token;\n        }\n      } finally {\n        this._input.release(tokenStartMarker);\n      }\n    }\n    skip() {\n      this._type = Lexer2.SKIP;\n    }\n    more() {\n      this._type = Lexer2.MORE;\n    }\n    mode(m) {\n      this._mode = m;\n    }\n    pushMode(m) {\n      if (this._interp.debug) {\n        console.log(\"pushMode \" + m);\n      }\n      this._modeStack.push(this._mode);\n      this.mode(m);\n    }\n    popMode() {\n      if (this._modeStack.length === 0) {\n        throw \"Empty Stack\";\n      }\n      if (this._interp.debug) {\n        console.log(\"popMode back to \" + this._modeStack.slice(0, -1));\n      }\n      this.mode(this._modeStack.pop());\n      return this._mode;\n    }\n    emitToken(token) {\n      this._token = token;\n    }\n    emit() {\n      const t = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.getCharIndex() - 1, this._tokenStartLine, this._tokenStartColumn);\n      this.emitToken(t);\n      return t;\n    }\n    emitEOF() {\n      const cpos = this.column;\n      const lpos = this.line;\n      const eof = this._factory.create(this._tokenFactorySourcePair, Token2.EOF, null, Token2.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, lpos, cpos);\n      this.emitToken(eof);\n      return eof;\n    }\n    getCharIndex() {\n      return this._input.index;\n    }\n    getAllTokens() {\n      const tokens2 = [];\n      let t = this.nextToken();\n      while (t.type !== Token2.EOF) {\n        tokens2.push(t);\n        t = this.nextToken();\n      }\n      return tokens2;\n    }\n    notifyListeners(e) {\n      const start = this._tokenStartCharIndex;\n      const stop = this._input.index;\n      const text = this._input.getText(start, stop);\n      const msg = \"token recognition error at: '\" + this.getErrorDisplay(text) + \"'\";\n      const listener = this.getErrorListenerDispatch();\n      listener.syntaxError(this, null, this._tokenStartLine, this._tokenStartColumn, msg, e);\n    }\n    getErrorDisplay(s) {\n      const d = [];\n      for (let i = 0; i < s.length; i++) {\n        d.push(s[i]);\n      }\n      return d.join(\"\");\n    }\n    getErrorDisplayForChar(c) {\n      if (c.charCodeAt(0) === Token2.EOF) {\n        return \"<EOF>\";\n      } else if (c === \"\\n\") {\n        return \"\\\\n\";\n      } else if (c === \"\t\") {\n        return \"\\\\t\";\n      } else if (c === \"\\r\") {\n        return \"\\\\r\";\n      } else {\n        return c;\n      }\n    }\n    getCharErrorDisplay(c) {\n      return \"'\" + this.getErrorDisplayForChar(c) + \"'\";\n    }\n    recover(re) {\n      if (this._input.LA(1) !== Token2.EOF) {\n        if (re instanceof LexerNoViableAltException) {\n          this._interp.consume(this._input);\n        } else {\n          this._input.consume();\n        }\n      }\n    }\n    get inputStream() {\n      return this._input;\n    }\n    set inputStream(input) {\n      this._input = null;\n      this._tokenFactorySourcePair = [this, this._input];\n      this.reset();\n      this._input = input;\n      this._tokenFactorySourcePair = [this, this._input];\n    }\n    get sourceName() {\n      return this._input.sourceName;\n    }\n    get type() {\n      return this.type;\n    }\n    set type(type) {\n      this._type = type;\n    }\n    get line() {\n      return this._interp.line;\n    }\n    set line(line) {\n      this._interp.line = line;\n    }\n    get column() {\n      return this._interp.column;\n    }\n    set column(column) {\n      this._interp.column = column;\n    }\n    get text() {\n      if (this._text !== null) {\n        return this._text;\n      } else {\n        return this._interp.getText(this._input);\n      }\n    }\n    set text(text) {\n      this._text = text;\n    }\n  };\n  Lexer2.DEFAULT_MODE = 0;\n  Lexer2.MORE = -2;\n  Lexer2.SKIP = -3;\n  Lexer2.DEFAULT_TOKEN_CHANNEL = Token2.DEFAULT_CHANNEL;\n  Lexer2.HIDDEN = Token2.HIDDEN_CHANNEL;\n  Lexer2.MIN_CHAR_VALUE = 0;\n  Lexer2.MAX_CHAR_VALUE = 1114111;\n  module2.exports = Lexer2;\n});\n\n// node_modules/antlr4/src/antlr4/atn/ATNConfigSet.js\nvar require_ATNConfigSet2 = __commonJS((exports, module2) => {\n  var ATN2 = require_ATN2();\n  var Utils3 = require_Utils2();\n  var {SemanticContext} = require_SemanticContext2();\n  var {merge} = require_PredictionContext2();\n  function hashATNConfig(c) {\n    return c.hashCodeForConfigSet();\n  }\n  function equalATNConfigs(a, b) {\n    if (a === b) {\n      return true;\n    } else if (a === null || b === null) {\n      return false;\n    } else\n      return a.equalsForConfigSet(b);\n  }\n  var ATNConfigSet = class {\n    constructor(fullCtx) {\n      this.configLookup = new Utils3.Set(hashATNConfig, equalATNConfigs);\n      this.fullCtx = fullCtx === void 0 ? true : fullCtx;\n      this.readOnly = false;\n      this.configs = [];\n      this.uniqueAlt = 0;\n      this.conflictingAlts = null;\n      this.hasSemanticContext = false;\n      this.dipsIntoOuterContext = false;\n      this.cachedHashCode = -1;\n    }\n    add(config, mergeCache) {\n      if (mergeCache === void 0) {\n        mergeCache = null;\n      }\n      if (this.readOnly) {\n        throw \"This set is readonly\";\n      }\n      if (config.semanticContext !== SemanticContext.NONE) {\n        this.hasSemanticContext = true;\n      }\n      if (config.reachesIntoOuterContext > 0) {\n        this.dipsIntoOuterContext = true;\n      }\n      const existing = this.configLookup.add(config);\n      if (existing === config) {\n        this.cachedHashCode = -1;\n        this.configs.push(config);\n        return true;\n      }\n      const rootIsWildcard = !this.fullCtx;\n      const merged = merge(existing.context, config.context, rootIsWildcard, mergeCache);\n      existing.reachesIntoOuterContext = Math.max(existing.reachesIntoOuterContext, config.reachesIntoOuterContext);\n      if (config.precedenceFilterSuppressed) {\n        existing.precedenceFilterSuppressed = true;\n      }\n      existing.context = merged;\n      return true;\n    }\n    getStates() {\n      const states = new Utils3.Set();\n      for (let i = 0; i < this.configs.length; i++) {\n        states.add(this.configs[i].state);\n      }\n      return states;\n    }\n    getPredicates() {\n      const preds = [];\n      for (let i = 0; i < this.configs.length; i++) {\n        const c = this.configs[i].semanticContext;\n        if (c !== SemanticContext.NONE) {\n          preds.push(c.semanticContext);\n        }\n      }\n      return preds;\n    }\n    optimizeConfigs(interpreter) {\n      if (this.readOnly) {\n        throw \"This set is readonly\";\n      }\n      if (this.configLookup.length === 0) {\n        return;\n      }\n      for (let i = 0; i < this.configs.length; i++) {\n        const config = this.configs[i];\n        config.context = interpreter.getCachedContext(config.context);\n      }\n    }\n    addAll(coll) {\n      for (let i = 0; i < coll.length; i++) {\n        this.add(coll[i]);\n      }\n      return false;\n    }\n    equals(other) {\n      return this === other || other instanceof ATNConfigSet && Utils3.equalArrays(this.configs, other.configs) && this.fullCtx === other.fullCtx && this.uniqueAlt === other.uniqueAlt && this.conflictingAlts === other.conflictingAlts && this.hasSemanticContext === other.hasSemanticContext && this.dipsIntoOuterContext === other.dipsIntoOuterContext;\n    }\n    hashCode() {\n      const hash = new Utils3.Hash();\n      hash.update(this.configs);\n      return hash.finish();\n    }\n    updateHashCode(hash) {\n      if (this.readOnly) {\n        if (this.cachedHashCode === -1) {\n          this.cachedHashCode = this.hashCode();\n        }\n        hash.update(this.cachedHashCode);\n      } else {\n        hash.update(this.hashCode());\n      }\n    }\n    isEmpty() {\n      return this.configs.length === 0;\n    }\n    contains(item) {\n      if (this.configLookup === null) {\n        throw \"This method is not implemented for readonly sets.\";\n      }\n      return this.configLookup.contains(item);\n    }\n    containsFast(item) {\n      if (this.configLookup === null) {\n        throw \"This method is not implemented for readonly sets.\";\n      }\n      return this.configLookup.containsFast(item);\n    }\n    clear() {\n      if (this.readOnly) {\n        throw \"This set is readonly\";\n      }\n      this.configs = [];\n      this.cachedHashCode = -1;\n      this.configLookup = new Utils3.Set();\n    }\n    setReadonly(readOnly) {\n      this.readOnly = readOnly;\n      if (readOnly) {\n        this.configLookup = null;\n      }\n    }\n    toString() {\n      return Utils3.arrayToString(this.configs) + (this.hasSemanticContext ? \",hasSemanticContext=\" + this.hasSemanticContext : \"\") + (this.uniqueAlt !== ATN2.INVALID_ALT_NUMBER ? \",uniqueAlt=\" + this.uniqueAlt : \"\") + (this.conflictingAlts !== null ? \",conflictingAlts=\" + this.conflictingAlts : \"\") + (this.dipsIntoOuterContext ? \",dipsIntoOuterContext\" : \"\");\n    }\n    get items() {\n      return this.configs;\n    }\n    get length() {\n      return this.configs.length;\n    }\n  };\n  var OrderedATNConfigSet = class extends ATNConfigSet {\n    constructor() {\n      super();\n      this.configLookup = new Utils3.Set();\n    }\n  };\n  module2.exports = {\n    ATNConfigSet,\n    OrderedATNConfigSet\n  };\n});\n\n// node_modules/antlr4/src/antlr4/dfa/DFAState.js\nvar require_DFAState2 = __commonJS((exports, module2) => {\n  var {ATNConfigSet} = require_ATNConfigSet2();\n  var {Hash: Hash2, Set: Set2} = require_Utils2();\n  var PredPrediction = class {\n    constructor(pred, alt) {\n      this.alt = alt;\n      this.pred = pred;\n    }\n    toString() {\n      return \"(\" + this.pred + \", \" + this.alt + \")\";\n    }\n  };\n  var DFAState = class {\n    constructor(stateNumber, configs) {\n      if (stateNumber === null) {\n        stateNumber = -1;\n      }\n      if (configs === null) {\n        configs = new ATNConfigSet();\n      }\n      this.stateNumber = stateNumber;\n      this.configs = configs;\n      this.edges = null;\n      this.isAcceptState = false;\n      this.prediction = 0;\n      this.lexerActionExecutor = null;\n      this.requiresFullContext = false;\n      this.predicates = null;\n      return this;\n    }\n    getAltSet() {\n      const alts = new Set2();\n      if (this.configs !== null) {\n        for (let i = 0; i < this.configs.length; i++) {\n          const c = this.configs[i];\n          alts.add(c.alt);\n        }\n      }\n      if (alts.length === 0) {\n        return null;\n      } else {\n        return alts;\n      }\n    }\n    equals(other) {\n      return this === other || other instanceof DFAState && this.configs.equals(other.configs);\n    }\n    toString() {\n      let s = \"\" + this.stateNumber + \":\" + this.configs;\n      if (this.isAcceptState) {\n        s = s + \"=>\";\n        if (this.predicates !== null)\n          s = s + this.predicates;\n        else\n          s = s + this.prediction;\n      }\n      return s;\n    }\n    hashCode() {\n      const hash = new Hash2();\n      hash.update(this.configs);\n      return hash.finish();\n    }\n  };\n  module2.exports = {DFAState, PredPrediction};\n});\n\n// node_modules/antlr4/src/antlr4/atn/ATNSimulator.js\nvar require_ATNSimulator2 = __commonJS((exports, module2) => {\n  var {DFAState} = require_DFAState2();\n  var {ATNConfigSet} = require_ATNConfigSet2();\n  var {getCachedPredictionContext} = require_PredictionContext2();\n  var {Map: Map2} = require_Utils2();\n  var ATNSimulator = class {\n    constructor(atn, sharedContextCache) {\n      this.atn = atn;\n      this.sharedContextCache = sharedContextCache;\n      return this;\n    }\n    getCachedContext(context) {\n      if (this.sharedContextCache === null) {\n        return context;\n      }\n      const visited = new Map2();\n      return getCachedPredictionContext(context, this.sharedContextCache, visited);\n    }\n  };\n  ATNSimulator.ERROR = new DFAState(2147483647, new ATNConfigSet());\n  module2.exports = ATNSimulator;\n});\n\n// node_modules/antlr4/src/antlr4/atn/LexerActionExecutor.js\nvar require_LexerActionExecutor2 = __commonJS((exports, module2) => {\n  var {hashStuff} = require_Utils2();\n  var {LexerIndexedCustomAction} = require_LexerAction();\n  var LexerActionExecutor = class {\n    constructor(lexerActions) {\n      this.lexerActions = lexerActions === null ? [] : lexerActions;\n      this.cachedHashCode = hashStuff(lexerActions);\n      return this;\n    }\n    fixOffsetBeforeMatch(offset) {\n      let updatedLexerActions = null;\n      for (let i = 0; i < this.lexerActions.length; i++) {\n        if (this.lexerActions[i].isPositionDependent && !(this.lexerActions[i] instanceof LexerIndexedCustomAction)) {\n          if (updatedLexerActions === null) {\n            updatedLexerActions = this.lexerActions.concat([]);\n          }\n          updatedLexerActions[i] = new LexerIndexedCustomAction(offset, this.lexerActions[i]);\n        }\n      }\n      if (updatedLexerActions === null) {\n        return this;\n      } else {\n        return new LexerActionExecutor(updatedLexerActions);\n      }\n    }\n    execute(lexer, input, startIndex) {\n      let requiresSeek = false;\n      const stopIndex = input.index;\n      try {\n        for (let i = 0; i < this.lexerActions.length; i++) {\n          let lexerAction = this.lexerActions[i];\n          if (lexerAction instanceof LexerIndexedCustomAction) {\n            const offset = lexerAction.offset;\n            input.seek(startIndex + offset);\n            lexerAction = lexerAction.action;\n            requiresSeek = startIndex + offset !== stopIndex;\n          } else if (lexerAction.isPositionDependent) {\n            input.seek(stopIndex);\n            requiresSeek = false;\n          }\n          lexerAction.execute(lexer);\n        }\n      } finally {\n        if (requiresSeek) {\n          input.seek(stopIndex);\n        }\n      }\n    }\n    hashCode() {\n      return this.cachedHashCode;\n    }\n    updateHashCode(hash) {\n      hash.update(this.cachedHashCode);\n    }\n    equals(other) {\n      if (this === other) {\n        return true;\n      } else if (!(other instanceof LexerActionExecutor)) {\n        return false;\n      } else if (this.cachedHashCode != other.cachedHashCode) {\n        return false;\n      } else if (this.lexerActions.length != other.lexerActions.length) {\n        return false;\n      } else {\n        const numActions = this.lexerActions.length;\n        for (let idx = 0; idx < numActions; ++idx) {\n          if (!this.lexerActions[idx].equals(other.lexerActions[idx])) {\n            return false;\n          }\n        }\n        return true;\n      }\n    }\n    static append(lexerActionExecutor, lexerAction) {\n      if (lexerActionExecutor === null) {\n        return new LexerActionExecutor([lexerAction]);\n      }\n      const lexerActions = lexerActionExecutor.lexerActions.concat([lexerAction]);\n      return new LexerActionExecutor(lexerActions);\n    }\n  };\n  module2.exports = LexerActionExecutor;\n});\n\n// node_modules/antlr4/src/antlr4/atn/LexerATNSimulator.js\nvar require_LexerATNSimulator2 = __commonJS((exports, module2) => {\n  var {Token: Token2} = require_Token2();\n  var Lexer2 = require_Lexer2();\n  var ATN2 = require_ATN2();\n  var ATNSimulator = require_ATNSimulator2();\n  var {DFAState} = require_DFAState2();\n  var {OrderedATNConfigSet} = require_ATNConfigSet2();\n  var {PredictionContext} = require_PredictionContext2();\n  var {SingletonPredictionContext} = require_PredictionContext2();\n  var {RuleStopState} = require_ATNState2();\n  var {LexerATNConfig} = require_ATNConfig2();\n  var {Transition} = require_Transition2();\n  var LexerActionExecutor = require_LexerActionExecutor2();\n  var {LexerNoViableAltException} = require_Errors();\n  function resetSimState(sim) {\n    sim.index = -1;\n    sim.line = 0;\n    sim.column = -1;\n    sim.dfaState = null;\n  }\n  var SimState = class {\n    constructor() {\n      resetSimState(this);\n    }\n    reset() {\n      resetSimState(this);\n    }\n  };\n  var LexerATNSimulator2 = class extends ATNSimulator {\n    constructor(recog, atn, decisionToDFA, sharedContextCache) {\n      super(atn, sharedContextCache);\n      this.decisionToDFA = decisionToDFA;\n      this.recog = recog;\n      this.startIndex = -1;\n      this.line = 1;\n      this.column = 0;\n      this.mode = Lexer2.DEFAULT_MODE;\n      this.prevAccept = new SimState();\n    }\n    copyState(simulator) {\n      this.column = simulator.column;\n      this.line = simulator.line;\n      this.mode = simulator.mode;\n      this.startIndex = simulator.startIndex;\n    }\n    match(input, mode) {\n      this.match_calls += 1;\n      this.mode = mode;\n      const mark = input.mark();\n      try {\n        this.startIndex = input.index;\n        this.prevAccept.reset();\n        const dfa = this.decisionToDFA[mode];\n        if (dfa.s0 === null) {\n          return this.matchATN(input);\n        } else {\n          return this.execATN(input, dfa.s0);\n        }\n      } finally {\n        input.release(mark);\n      }\n    }\n    reset() {\n      this.prevAccept.reset();\n      this.startIndex = -1;\n      this.line = 1;\n      this.column = 0;\n      this.mode = Lexer2.DEFAULT_MODE;\n    }\n    matchATN(input) {\n      const startState = this.atn.modeToStartState[this.mode];\n      if (LexerATNSimulator2.debug) {\n        console.log(\"matchATN mode \" + this.mode + \" start: \" + startState);\n      }\n      const old_mode = this.mode;\n      const s0_closure = this.computeStartState(input, startState);\n      const suppressEdge = s0_closure.hasSemanticContext;\n      s0_closure.hasSemanticContext = false;\n      const next = this.addDFAState(s0_closure);\n      if (!suppressEdge) {\n        this.decisionToDFA[this.mode].s0 = next;\n      }\n      const predict = this.execATN(input, next);\n      if (LexerATNSimulator2.debug) {\n        console.log(\"DFA after matchATN: \" + this.decisionToDFA[old_mode].toLexerString());\n      }\n      return predict;\n    }\n    execATN(input, ds0) {\n      if (LexerATNSimulator2.debug) {\n        console.log(\"start state closure=\" + ds0.configs);\n      }\n      if (ds0.isAcceptState) {\n        this.captureSimState(this.prevAccept, input, ds0);\n      }\n      let t = input.LA(1);\n      let s = ds0;\n      while (true) {\n        if (LexerATNSimulator2.debug) {\n          console.log(\"execATN loop starting closure: \" + s.configs);\n        }\n        let target = this.getExistingTargetState(s, t);\n        if (target === null) {\n          target = this.computeTargetState(input, s, t);\n        }\n        if (target === ATNSimulator.ERROR) {\n          break;\n        }\n        if (t !== Token2.EOF) {\n          this.consume(input);\n        }\n        if (target.isAcceptState) {\n          this.captureSimState(this.prevAccept, input, target);\n          if (t === Token2.EOF) {\n            break;\n          }\n        }\n        t = input.LA(1);\n        s = target;\n      }\n      return this.failOrAccept(this.prevAccept, input, s.configs, t);\n    }\n    getExistingTargetState(s, t) {\n      if (s.edges === null || t < LexerATNSimulator2.MIN_DFA_EDGE || t > LexerATNSimulator2.MAX_DFA_EDGE) {\n        return null;\n      }\n      let target = s.edges[t - LexerATNSimulator2.MIN_DFA_EDGE];\n      if (target === void 0) {\n        target = null;\n      }\n      if (LexerATNSimulator2.debug && target !== null) {\n        console.log(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n      }\n      return target;\n    }\n    computeTargetState(input, s, t) {\n      const reach = new OrderedATNConfigSet();\n      this.getReachableConfigSet(input, s.configs, reach, t);\n      if (reach.items.length === 0) {\n        if (!reach.hasSemanticContext) {\n          this.addDFAEdge(s, t, ATNSimulator.ERROR);\n        }\n        return ATNSimulator.ERROR;\n      }\n      return this.addDFAEdge(s, t, null, reach);\n    }\n    failOrAccept(prevAccept, input, reach, t) {\n      if (this.prevAccept.dfaState !== null) {\n        const lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;\n        this.accept(input, lexerActionExecutor, this.startIndex, prevAccept.index, prevAccept.line, prevAccept.column);\n        return prevAccept.dfaState.prediction;\n      } else {\n        if (t === Token2.EOF && input.index === this.startIndex) {\n          return Token2.EOF;\n        }\n        throw new LexerNoViableAltException(this.recog, input, this.startIndex, reach);\n      }\n    }\n    getReachableConfigSet(input, closure, reach, t) {\n      let skipAlt = ATN2.INVALID_ALT_NUMBER;\n      for (let i = 0; i < closure.items.length; i++) {\n        const cfg = closure.items[i];\n        const currentAltReachedAcceptState = cfg.alt === skipAlt;\n        if (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {\n          continue;\n        }\n        if (LexerATNSimulator2.debug) {\n          console.log(\"testing %s at %s\\n\", this.getTokenName(t), cfg.toString(this.recog, true));\n        }\n        for (let j = 0; j < cfg.state.transitions.length; j++) {\n          const trans = cfg.state.transitions[j];\n          const target = this.getReachableTarget(trans, t);\n          if (target !== null) {\n            let lexerActionExecutor = cfg.lexerActionExecutor;\n            if (lexerActionExecutor !== null) {\n              lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);\n            }\n            const treatEofAsEpsilon = t === Token2.EOF;\n            const config = new LexerATNConfig({state: target, lexerActionExecutor}, cfg);\n            if (this.closure(input, config, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {\n              skipAlt = cfg.alt;\n            }\n          }\n        }\n      }\n    }\n    accept(input, lexerActionExecutor, startIndex, index, line, charPos) {\n      if (LexerATNSimulator2.debug) {\n        console.log(\"ACTION %s\\n\", lexerActionExecutor);\n      }\n      input.seek(index);\n      this.line = line;\n      this.column = charPos;\n      if (lexerActionExecutor !== null && this.recog !== null) {\n        lexerActionExecutor.execute(this.recog, input, startIndex);\n      }\n    }\n    getReachableTarget(trans, t) {\n      if (trans.matches(t, 0, Lexer2.MAX_CHAR_VALUE)) {\n        return trans.target;\n      } else {\n        return null;\n      }\n    }\n    computeStartState(input, p) {\n      const initialContext = PredictionContext.EMPTY;\n      const configs = new OrderedATNConfigSet();\n      for (let i = 0; i < p.transitions.length; i++) {\n        const target = p.transitions[i].target;\n        const cfg = new LexerATNConfig({state: target, alt: i + 1, context: initialContext}, null);\n        this.closure(input, cfg, configs, false, false, false);\n      }\n      return configs;\n    }\n    closure(input, config, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {\n      let cfg = null;\n      if (LexerATNSimulator2.debug) {\n        console.log(\"closure(\" + config.toString(this.recog, true) + \")\");\n      }\n      if (config.state instanceof RuleStopState) {\n        if (LexerATNSimulator2.debug) {\n          if (this.recog !== null) {\n            console.log(\"closure at %s rule stop %s\\n\", this.recog.ruleNames[config.state.ruleIndex], config);\n          } else {\n            console.log(\"closure at rule stop %s\\n\", config);\n          }\n        }\n        if (config.context === null || config.context.hasEmptyPath()) {\n          if (config.context === null || config.context.isEmpty()) {\n            configs.add(config);\n            return true;\n          } else {\n            configs.add(new LexerATNConfig({state: config.state, context: PredictionContext.EMPTY}, config));\n            currentAltReachedAcceptState = true;\n          }\n        }\n        if (config.context !== null && !config.context.isEmpty()) {\n          for (let i = 0; i < config.context.length; i++) {\n            if (config.context.getReturnState(i) !== PredictionContext.EMPTY_RETURN_STATE) {\n              const newContext = config.context.getParent(i);\n              const returnState = this.atn.states[config.context.getReturnState(i)];\n              cfg = new LexerATNConfig({state: returnState, context: newContext}, config);\n              currentAltReachedAcceptState = this.closure(input, cfg, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);\n            }\n          }\n        }\n        return currentAltReachedAcceptState;\n      }\n      if (!config.state.epsilonOnlyTransitions) {\n        if (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) {\n          configs.add(config);\n        }\n      }\n      for (let j = 0; j < config.state.transitions.length; j++) {\n        const trans = config.state.transitions[j];\n        cfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);\n        if (cfg !== null) {\n          currentAltReachedAcceptState = this.closure(input, cfg, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);\n        }\n      }\n      return currentAltReachedAcceptState;\n    }\n    getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon) {\n      let cfg = null;\n      if (trans.serializationType === Transition.RULE) {\n        const newContext = SingletonPredictionContext.create(config.context, trans.followState.stateNumber);\n        cfg = new LexerATNConfig({state: trans.target, context: newContext}, config);\n      } else if (trans.serializationType === Transition.PRECEDENCE) {\n        throw \"Precedence predicates are not supported in lexers.\";\n      } else if (trans.serializationType === Transition.PREDICATE) {\n        if (LexerATNSimulator2.debug) {\n          console.log(\"EVAL rule \" + trans.ruleIndex + \":\" + trans.predIndex);\n        }\n        configs.hasSemanticContext = true;\n        if (this.evaluatePredicate(input, trans.ruleIndex, trans.predIndex, speculative)) {\n          cfg = new LexerATNConfig({state: trans.target}, config);\n        }\n      } else if (trans.serializationType === Transition.ACTION) {\n        if (config.context === null || config.context.hasEmptyPath()) {\n          const lexerActionExecutor = LexerActionExecutor.append(config.lexerActionExecutor, this.atn.lexerActions[trans.actionIndex]);\n          cfg = new LexerATNConfig({state: trans.target, lexerActionExecutor}, config);\n        } else {\n          cfg = new LexerATNConfig({state: trans.target}, config);\n        }\n      } else if (trans.serializationType === Transition.EPSILON) {\n        cfg = new LexerATNConfig({state: trans.target}, config);\n      } else if (trans.serializationType === Transition.ATOM || trans.serializationType === Transition.RANGE || trans.serializationType === Transition.SET) {\n        if (treatEofAsEpsilon) {\n          if (trans.matches(Token2.EOF, 0, Lexer2.MAX_CHAR_VALUE)) {\n            cfg = new LexerATNConfig({state: trans.target}, config);\n          }\n        }\n      }\n      return cfg;\n    }\n    evaluatePredicate(input, ruleIndex, predIndex, speculative) {\n      if (this.recog === null) {\n        return true;\n      }\n      if (!speculative) {\n        return this.recog.sempred(null, ruleIndex, predIndex);\n      }\n      const savedcolumn = this.column;\n      const savedLine = this.line;\n      const index = input.index;\n      const marker = input.mark();\n      try {\n        this.consume(input);\n        return this.recog.sempred(null, ruleIndex, predIndex);\n      } finally {\n        this.column = savedcolumn;\n        this.line = savedLine;\n        input.seek(index);\n        input.release(marker);\n      }\n    }\n    captureSimState(settings, input, dfaState) {\n      settings.index = input.index;\n      settings.line = this.line;\n      settings.column = this.column;\n      settings.dfaState = dfaState;\n    }\n    addDFAEdge(from_, tk, to, cfgs) {\n      if (to === void 0) {\n        to = null;\n      }\n      if (cfgs === void 0) {\n        cfgs = null;\n      }\n      if (to === null && cfgs !== null) {\n        const suppressEdge = cfgs.hasSemanticContext;\n        cfgs.hasSemanticContext = false;\n        to = this.addDFAState(cfgs);\n        if (suppressEdge) {\n          return to;\n        }\n      }\n      if (tk < LexerATNSimulator2.MIN_DFA_EDGE || tk > LexerATNSimulator2.MAX_DFA_EDGE) {\n        return to;\n      }\n      if (LexerATNSimulator2.debug) {\n        console.log(\"EDGE \" + from_ + \" -> \" + to + \" upon \" + tk);\n      }\n      if (from_.edges === null) {\n        from_.edges = [];\n      }\n      from_.edges[tk - LexerATNSimulator2.MIN_DFA_EDGE] = to;\n      return to;\n    }\n    addDFAState(configs) {\n      const proposed = new DFAState(null, configs);\n      let firstConfigWithRuleStopState = null;\n      for (let i = 0; i < configs.items.length; i++) {\n        const cfg = configs.items[i];\n        if (cfg.state instanceof RuleStopState) {\n          firstConfigWithRuleStopState = cfg;\n          break;\n        }\n      }\n      if (firstConfigWithRuleStopState !== null) {\n        proposed.isAcceptState = true;\n        proposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;\n        proposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];\n      }\n      const dfa = this.decisionToDFA[this.mode];\n      const existing = dfa.states.get(proposed);\n      if (existing !== null) {\n        return existing;\n      }\n      const newState = proposed;\n      newState.stateNumber = dfa.states.length;\n      configs.setReadonly(true);\n      newState.configs = configs;\n      dfa.states.add(newState);\n      return newState;\n    }\n    getDFA(mode) {\n      return this.decisionToDFA[mode];\n    }\n    getText(input) {\n      return input.getText(this.startIndex, input.index - 1);\n    }\n    consume(input) {\n      const curChar = input.LA(1);\n      if (curChar === \"\\n\".charCodeAt(0)) {\n        this.line += 1;\n        this.column = 0;\n      } else {\n        this.column += 1;\n      }\n      input.consume();\n    }\n    getTokenName(tt) {\n      if (tt === -1) {\n        return \"EOF\";\n      } else {\n        return \"'\" + String.fromCharCode(tt) + \"'\";\n      }\n    }\n  };\n  LexerATNSimulator2.debug = false;\n  LexerATNSimulator2.dfa_debug = false;\n  LexerATNSimulator2.MIN_DFA_EDGE = 0;\n  LexerATNSimulator2.MAX_DFA_EDGE = 127;\n  LexerATNSimulator2.match_calls = 0;\n  module2.exports = LexerATNSimulator2;\n});\n\n// node_modules/antlr4/src/antlr4/atn/PredictionMode.js\nvar require_PredictionMode2 = __commonJS((exports, module2) => {\n  var {Map: Map2, BitSet, AltDict, hashStuff} = require_Utils2();\n  var ATN2 = require_ATN2();\n  var {RuleStopState} = require_ATNState2();\n  var {ATNConfigSet} = require_ATNConfigSet2();\n  var {ATNConfig} = require_ATNConfig2();\n  var {SemanticContext} = require_SemanticContext2();\n  var PredictionMode = {\n    SLL: 0,\n    LL: 1,\n    LL_EXACT_AMBIG_DETECTION: 2,\n    hasSLLConflictTerminatingPrediction: function(mode, configs) {\n      if (PredictionMode.allConfigsInRuleStopStates(configs)) {\n        return true;\n      }\n      if (mode === PredictionMode.SLL) {\n        if (configs.hasSemanticContext) {\n          const dup = new ATNConfigSet();\n          for (let i = 0; i < configs.items.length; i++) {\n            let c = configs.items[i];\n            c = new ATNConfig({semanticContext: SemanticContext.NONE}, c);\n            dup.add(c);\n          }\n          configs = dup;\n        }\n      }\n      const altsets = PredictionMode.getConflictingAltSubsets(configs);\n      return PredictionMode.hasConflictingAltSet(altsets) && !PredictionMode.hasStateAssociatedWithOneAlt(configs);\n    },\n    hasConfigInRuleStopState: function(configs) {\n      for (let i = 0; i < configs.items.length; i++) {\n        const c = configs.items[i];\n        if (c.state instanceof RuleStopState) {\n          return true;\n        }\n      }\n      return false;\n    },\n    allConfigsInRuleStopStates: function(configs) {\n      for (let i = 0; i < configs.items.length; i++) {\n        const c = configs.items[i];\n        if (!(c.state instanceof RuleStopState)) {\n          return false;\n        }\n      }\n      return true;\n    },\n    resolvesToJustOneViableAlt: function(altsets) {\n      return PredictionMode.getSingleViableAlt(altsets);\n    },\n    allSubsetsConflict: function(altsets) {\n      return !PredictionMode.hasNonConflictingAltSet(altsets);\n    },\n    hasNonConflictingAltSet: function(altsets) {\n      for (let i = 0; i < altsets.length; i++) {\n        const alts = altsets[i];\n        if (alts.length === 1) {\n          return true;\n        }\n      }\n      return false;\n    },\n    hasConflictingAltSet: function(altsets) {\n      for (let i = 0; i < altsets.length; i++) {\n        const alts = altsets[i];\n        if (alts.length > 1) {\n          return true;\n        }\n      }\n      return false;\n    },\n    allSubsetsEqual: function(altsets) {\n      let first = null;\n      for (let i = 0; i < altsets.length; i++) {\n        const alts = altsets[i];\n        if (first === null) {\n          first = alts;\n        } else if (alts !== first) {\n          return false;\n        }\n      }\n      return true;\n    },\n    getUniqueAlt: function(altsets) {\n      const all = PredictionMode.getAlts(altsets);\n      if (all.length === 1) {\n        return all.minValue();\n      } else {\n        return ATN2.INVALID_ALT_NUMBER;\n      }\n    },\n    getAlts: function(altsets) {\n      const all = new BitSet();\n      altsets.map(function(alts) {\n        all.or(alts);\n      });\n      return all;\n    },\n    getConflictingAltSubsets: function(configs) {\n      const configToAlts = new Map2();\n      configToAlts.hashFunction = function(cfg) {\n        hashStuff(cfg.state.stateNumber, cfg.context);\n      };\n      configToAlts.equalsFunction = function(c1, c2) {\n        return c1.state.stateNumber === c2.state.stateNumber && c1.context.equals(c2.context);\n      };\n      configs.items.map(function(cfg) {\n        let alts = configToAlts.get(cfg);\n        if (alts === null) {\n          alts = new BitSet();\n          configToAlts.put(cfg, alts);\n        }\n        alts.add(cfg.alt);\n      });\n      return configToAlts.getValues();\n    },\n    getStateToAltMap: function(configs) {\n      const m = new AltDict();\n      configs.items.map(function(c) {\n        let alts = m.get(c.state);\n        if (alts === null) {\n          alts = new BitSet();\n          m.put(c.state, alts);\n        }\n        alts.add(c.alt);\n      });\n      return m;\n    },\n    hasStateAssociatedWithOneAlt: function(configs) {\n      const values = PredictionMode.getStateToAltMap(configs).values();\n      for (let i = 0; i < values.length; i++) {\n        if (values[i].length === 1) {\n          return true;\n        }\n      }\n      return false;\n    },\n    getSingleViableAlt: function(altsets) {\n      let result = null;\n      for (let i = 0; i < altsets.length; i++) {\n        const alts = altsets[i];\n        const minAlt = alts.minValue();\n        if (result === null) {\n          result = minAlt;\n        } else if (result !== minAlt) {\n          return ATN2.INVALID_ALT_NUMBER;\n        }\n      }\n      return result;\n    }\n  };\n  module2.exports = PredictionMode;\n});\n\n// node_modules/antlr4/src/antlr4/ParserRuleContext.js\nvar require_ParserRuleContext2 = __commonJS((exports, module2) => {\n  var RuleContext = require_RuleContext2();\n  var Tree = require_Tree();\n  var INVALID_INTERVAL = Tree.INVALID_INTERVAL;\n  var TerminalNode = Tree.TerminalNode;\n  var TerminalNodeImpl = Tree.TerminalNodeImpl;\n  var ErrorNodeImpl = Tree.ErrorNodeImpl;\n  var Interval = require_IntervalSet2().Interval;\n  var ParserRuleContext2 = class extends RuleContext {\n    constructor(parent, invokingStateNumber) {\n      parent = parent || null;\n      invokingStateNumber = invokingStateNumber || null;\n      super(parent, invokingStateNumber);\n      this.ruleIndex = -1;\n      this.children = null;\n      this.start = null;\n      this.stop = null;\n      this.exception = null;\n    }\n    copyFrom(ctx) {\n      this.parentCtx = ctx.parentCtx;\n      this.invokingState = ctx.invokingState;\n      this.children = null;\n      this.start = ctx.start;\n      this.stop = ctx.stop;\n      if (ctx.children) {\n        this.children = [];\n        ctx.children.map(function(child) {\n          if (child instanceof ErrorNodeImpl) {\n            this.children.push(child);\n            child.parentCtx = this;\n          }\n        }, this);\n      }\n    }\n    enterRule(listener) {\n    }\n    exitRule(listener) {\n    }\n    addChild(child) {\n      if (this.children === null) {\n        this.children = [];\n      }\n      this.children.push(child);\n      return child;\n    }\n    removeLastChild() {\n      if (this.children !== null) {\n        this.children.pop();\n      }\n    }\n    addTokenNode(token) {\n      const node = new TerminalNodeImpl(token);\n      this.addChild(node);\n      node.parentCtx = this;\n      return node;\n    }\n    addErrorNode(badToken) {\n      const node = new ErrorNodeImpl(badToken);\n      this.addChild(node);\n      node.parentCtx = this;\n      return node;\n    }\n    getChild(i, type) {\n      type = type || null;\n      if (this.children === null || i < 0 || i >= this.children.length) {\n        return null;\n      }\n      if (type === null) {\n        return this.children[i];\n      } else {\n        for (let j = 0; j < this.children.length; j++) {\n          const child = this.children[j];\n          if (child instanceof type) {\n            if (i === 0) {\n              return child;\n            } else {\n              i -= 1;\n            }\n          }\n        }\n        return null;\n      }\n    }\n    getToken(ttype, i) {\n      if (this.children === null || i < 0 || i >= this.children.length) {\n        return null;\n      }\n      for (let j = 0; j < this.children.length; j++) {\n        const child = this.children[j];\n        if (child instanceof TerminalNode) {\n          if (child.symbol.type === ttype) {\n            if (i === 0) {\n              return child;\n            } else {\n              i -= 1;\n            }\n          }\n        }\n      }\n      return null;\n    }\n    getTokens(ttype) {\n      if (this.children === null) {\n        return [];\n      } else {\n        const tokens2 = [];\n        for (let j = 0; j < this.children.length; j++) {\n          const child = this.children[j];\n          if (child instanceof TerminalNode) {\n            if (child.symbol.type === ttype) {\n              tokens2.push(child);\n            }\n          }\n        }\n        return tokens2;\n      }\n    }\n    getTypedRuleContext(ctxType, i) {\n      return this.getChild(i, ctxType);\n    }\n    getTypedRuleContexts(ctxType) {\n      if (this.children === null) {\n        return [];\n      } else {\n        const contexts = [];\n        for (let j = 0; j < this.children.length; j++) {\n          const child = this.children[j];\n          if (child instanceof ctxType) {\n            contexts.push(child);\n          }\n        }\n        return contexts;\n      }\n    }\n    getChildCount() {\n      if (this.children === null) {\n        return 0;\n      } else {\n        return this.children.length;\n      }\n    }\n    getSourceInterval() {\n      if (this.start === null || this.stop === null) {\n        return INVALID_INTERVAL;\n      } else {\n        return new Interval(this.start.tokenIndex, this.stop.tokenIndex);\n      }\n    }\n  };\n  RuleContext.EMPTY = new ParserRuleContext2();\n  module2.exports = ParserRuleContext2;\n});\n\n// node_modules/antlr4/src/antlr4/atn/ParserATNSimulator.js\nvar require_ParserATNSimulator2 = __commonJS((exports, module2) => {\n  var Utils3 = require_Utils2();\n  var {Set: Set2, BitSet, DoubleDict} = Utils3;\n  var ATN2 = require_ATN2();\n  var {ATNState, RuleStopState} = require_ATNState2();\n  var {ATNConfig} = require_ATNConfig2();\n  var {ATNConfigSet} = require_ATNConfigSet2();\n  var {Token: Token2} = require_Token2();\n  var {DFAState, PredPrediction} = require_DFAState2();\n  var ATNSimulator = require_ATNSimulator2();\n  var PredictionMode = require_PredictionMode2();\n  var RuleContext = require_RuleContext2();\n  var ParserRuleContext2 = require_ParserRuleContext2();\n  var {SemanticContext} = require_SemanticContext2();\n  var {PredictionContext} = require_PredictionContext2();\n  var {Interval} = require_IntervalSet2();\n  var {Transition, SetTransition, NotSetTransition, RuleTransition, ActionTransition} = require_Transition2();\n  var {NoViableAltException: NoViableAltException2} = require_Errors();\n  var {SingletonPredictionContext, predictionContextFromRuleContext} = require_PredictionContext2();\n  var ParserATNSimulator2 = class extends ATNSimulator {\n    constructor(parser, atn, decisionToDFA, sharedContextCache) {\n      super(atn, sharedContextCache);\n      this.parser = parser;\n      this.decisionToDFA = decisionToDFA;\n      this.predictionMode = PredictionMode.LL;\n      this._input = null;\n      this._startIndex = 0;\n      this._outerContext = null;\n      this._dfa = null;\n      this.mergeCache = null;\n      this.debug = false;\n      this.debug_closure = false;\n      this.debug_add = false;\n      this.debug_list_atn_decisions = false;\n      this.dfa_debug = false;\n      this.retry_debug = false;\n    }\n    reset() {\n    }\n    adaptivePredict(input, decision, outerContext) {\n      if (this.debug || this.debug_list_atn_decisions) {\n        console.log(\"adaptivePredict decision \" + decision + \" exec LA(1)==\" + this.getLookaheadName(input) + \" line \" + input.LT(1).line + \":\" + input.LT(1).column);\n      }\n      this._input = input;\n      this._startIndex = input.index;\n      this._outerContext = outerContext;\n      const dfa = this.decisionToDFA[decision];\n      this._dfa = dfa;\n      const m = input.mark();\n      const index = input.index;\n      try {\n        let s0;\n        if (dfa.precedenceDfa) {\n          s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());\n        } else {\n          s0 = dfa.s0;\n        }\n        if (s0 === null) {\n          if (outerContext === null) {\n            outerContext = RuleContext.EMPTY;\n          }\n          if (this.debug || this.debug_list_atn_decisions) {\n            console.log(\"predictATN decision \" + dfa.decision + \" exec LA(1)==\" + this.getLookaheadName(input) + \", outerContext=\" + outerContext.toString(this.parser.ruleNames));\n          }\n          const fullCtx = false;\n          let s0_closure = this.computeStartState(dfa.atnStartState, RuleContext.EMPTY, fullCtx);\n          if (dfa.precedenceDfa) {\n            dfa.s0.configs = s0_closure;\n            s0_closure = this.applyPrecedenceFilter(s0_closure);\n            s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));\n            dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);\n          } else {\n            s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));\n            dfa.s0 = s0;\n          }\n        }\n        const alt = this.execATN(dfa, s0, input, index, outerContext);\n        if (this.debug) {\n          console.log(\"DFA after predictATN: \" + dfa.toString(this.parser.literalNames));\n        }\n        return alt;\n      } finally {\n        this._dfa = null;\n        this.mergeCache = null;\n        input.seek(index);\n        input.release(m);\n      }\n    }\n    execATN(dfa, s0, input, startIndex, outerContext) {\n      if (this.debug || this.debug_list_atn_decisions) {\n        console.log(\"execATN decision \" + dfa.decision + \" exec LA(1)==\" + this.getLookaheadName(input) + \" line \" + input.LT(1).line + \":\" + input.LT(1).column);\n      }\n      let alt;\n      let previousD = s0;\n      if (this.debug) {\n        console.log(\"s0 = \" + s0);\n      }\n      let t = input.LA(1);\n      while (true) {\n        let D = this.getExistingTargetState(previousD, t);\n        if (D === null) {\n          D = this.computeTargetState(dfa, previousD, t);\n        }\n        if (D === ATNSimulator.ERROR) {\n          const e = this.noViableAlt(input, outerContext, previousD.configs, startIndex);\n          input.seek(startIndex);\n          alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousD.configs, outerContext);\n          if (alt !== ATN2.INVALID_ALT_NUMBER) {\n            return alt;\n          } else {\n            throw e;\n          }\n        }\n        if (D.requiresFullContext && this.predictionMode !== PredictionMode.SLL) {\n          let conflictingAlts = null;\n          if (D.predicates !== null) {\n            if (this.debug) {\n              console.log(\"DFA state has preds in DFA sim LL failover\");\n            }\n            const conflictIndex = input.index;\n            if (conflictIndex !== startIndex) {\n              input.seek(startIndex);\n            }\n            conflictingAlts = this.evalSemanticContext(D.predicates, outerContext, true);\n            if (conflictingAlts.length === 1) {\n              if (this.debug) {\n                console.log(\"Full LL avoided\");\n              }\n              return conflictingAlts.minValue();\n            }\n            if (conflictIndex !== startIndex) {\n              input.seek(conflictIndex);\n            }\n          }\n          if (this.dfa_debug) {\n            console.log(\"ctx sensitive state \" + outerContext + \" in \" + D);\n          }\n          const fullCtx = true;\n          const s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);\n          this.reportAttemptingFullContext(dfa, conflictingAlts, D.configs, startIndex, input.index);\n          alt = this.execATNWithFullContext(dfa, D, s0_closure, input, startIndex, outerContext);\n          return alt;\n        }\n        if (D.isAcceptState) {\n          if (D.predicates === null) {\n            return D.prediction;\n          }\n          const stopIndex = input.index;\n          input.seek(startIndex);\n          const alts = this.evalSemanticContext(D.predicates, outerContext, true);\n          if (alts.length === 0) {\n            throw this.noViableAlt(input, outerContext, D.configs, startIndex);\n          } else if (alts.length === 1) {\n            return alts.minValue();\n          } else {\n            this.reportAmbiguity(dfa, D, startIndex, stopIndex, false, alts, D.configs);\n            return alts.minValue();\n          }\n        }\n        previousD = D;\n        if (t !== Token2.EOF) {\n          input.consume();\n          t = input.LA(1);\n        }\n      }\n    }\n    getExistingTargetState(previousD, t) {\n      const edges = previousD.edges;\n      if (edges === null) {\n        return null;\n      } else {\n        return edges[t + 1] || null;\n      }\n    }\n    computeTargetState(dfa, previousD, t) {\n      const reach = this.computeReachSet(previousD.configs, t, false);\n      if (reach === null) {\n        this.addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);\n        return ATNSimulator.ERROR;\n      }\n      let D = new DFAState(null, reach);\n      const predictedAlt = this.getUniqueAlt(reach);\n      if (this.debug) {\n        const altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        console.log(\"SLL altSubSets=\" + Utils3.arrayToString(altSubSets) + \", previous=\" + previousD.configs + \", configs=\" + reach + \", predict=\" + predictedAlt + \", allSubsetsConflict=\" + PredictionMode.allSubsetsConflict(altSubSets) + \", conflictingAlts=\" + this.getConflictingAlts(reach));\n      }\n      if (predictedAlt !== ATN2.INVALID_ALT_NUMBER) {\n        D.isAcceptState = true;\n        D.configs.uniqueAlt = predictedAlt;\n        D.prediction = predictedAlt;\n      } else if (PredictionMode.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {\n        D.configs.conflictingAlts = this.getConflictingAlts(reach);\n        D.requiresFullContext = true;\n        D.isAcceptState = true;\n        D.prediction = D.configs.conflictingAlts.minValue();\n      }\n      if (D.isAcceptState && D.configs.hasSemanticContext) {\n        this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));\n        if (D.predicates !== null) {\n          D.prediction = ATN2.INVALID_ALT_NUMBER;\n        }\n      }\n      D = this.addDFAEdge(dfa, previousD, t, D);\n      return D;\n    }\n    predicateDFAState(dfaState, decisionState) {\n      const nalts = decisionState.transitions.length;\n      const altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);\n      const altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, nalts);\n      if (altToPred !== null) {\n        dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);\n        dfaState.prediction = ATN2.INVALID_ALT_NUMBER;\n      } else {\n        dfaState.prediction = altsToCollectPredsFrom.minValue();\n      }\n    }\n    execATNWithFullContext(dfa, D, s0, input, startIndex, outerContext) {\n      if (this.debug || this.debug_list_atn_decisions) {\n        console.log(\"execATNWithFullContext \" + s0);\n      }\n      const fullCtx = true;\n      let foundExactAmbig = false;\n      let reach;\n      let previous = s0;\n      input.seek(startIndex);\n      let t = input.LA(1);\n      let predictedAlt = -1;\n      while (true) {\n        reach = this.computeReachSet(previous, t, fullCtx);\n        if (reach === null) {\n          const e = this.noViableAlt(input, outerContext, previous, startIndex);\n          input.seek(startIndex);\n          const alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);\n          if (alt !== ATN2.INVALID_ALT_NUMBER) {\n            return alt;\n          } else {\n            throw e;\n          }\n        }\n        const altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        if (this.debug) {\n          console.log(\"LL altSubSets=\" + altSubSets + \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) + \", resolvesToJustOneViableAlt=\" + PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n        }\n        reach.uniqueAlt = this.getUniqueAlt(reach);\n        if (reach.uniqueAlt !== ATN2.INVALID_ALT_NUMBER) {\n          predictedAlt = reach.uniqueAlt;\n          break;\n        } else if (this.predictionMode !== PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n          predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n          if (predictedAlt !== ATN2.INVALID_ALT_NUMBER) {\n            break;\n          }\n        } else {\n          if (PredictionMode.allSubsetsConflict(altSubSets) && PredictionMode.allSubsetsEqual(altSubSets)) {\n            foundExactAmbig = true;\n            predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n            break;\n          }\n        }\n        previous = reach;\n        if (t !== Token2.EOF) {\n          input.consume();\n          t = input.LA(1);\n        }\n      }\n      if (reach.uniqueAlt !== ATN2.INVALID_ALT_NUMBER) {\n        this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);\n        return predictedAlt;\n      }\n      this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, null, reach);\n      return predictedAlt;\n    }\n    computeReachSet(closure, t, fullCtx) {\n      if (this.debug) {\n        console.log(\"in computeReachSet, starting closure: \" + closure);\n      }\n      if (this.mergeCache === null) {\n        this.mergeCache = new DoubleDict();\n      }\n      const intermediate = new ATNConfigSet(fullCtx);\n      let skippedStopStates = null;\n      for (let i = 0; i < closure.items.length; i++) {\n        const c = closure.items[i];\n        if (this.debug) {\n          console.log(\"testing \" + this.getTokenName(t) + \" at \" + c);\n        }\n        if (c.state instanceof RuleStopState) {\n          if (fullCtx || t === Token2.EOF) {\n            if (skippedStopStates === null) {\n              skippedStopStates = [];\n            }\n            skippedStopStates.push(c);\n            if (this.debug_add) {\n              console.log(\"added \" + c + \" to skippedStopStates\");\n            }\n          }\n          continue;\n        }\n        for (let j = 0; j < c.state.transitions.length; j++) {\n          const trans = c.state.transitions[j];\n          const target = this.getReachableTarget(trans, t);\n          if (target !== null) {\n            const cfg = new ATNConfig({state: target}, c);\n            intermediate.add(cfg, this.mergeCache);\n            if (this.debug_add) {\n              console.log(\"added \" + cfg + \" to intermediate\");\n            }\n          }\n        }\n      }\n      let reach = null;\n      if (skippedStopStates === null && t !== Token2.EOF) {\n        if (intermediate.items.length === 1) {\n          reach = intermediate;\n        } else if (this.getUniqueAlt(intermediate) !== ATN2.INVALID_ALT_NUMBER) {\n          reach = intermediate;\n        }\n      }\n      if (reach === null) {\n        reach = new ATNConfigSet(fullCtx);\n        const closureBusy = new Set2();\n        const treatEofAsEpsilon = t === Token2.EOF;\n        for (let k = 0; k < intermediate.items.length; k++) {\n          this.closure(intermediate.items[k], reach, closureBusy, false, fullCtx, treatEofAsEpsilon);\n        }\n      }\n      if (t === Token2.EOF) {\n        reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);\n      }\n      if (skippedStopStates !== null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n        for (let l = 0; l < skippedStopStates.length; l++) {\n          reach.add(skippedStopStates[l], this.mergeCache);\n        }\n      }\n      if (reach.items.length === 0) {\n        return null;\n      } else {\n        return reach;\n      }\n    }\n    removeAllConfigsNotInRuleStopState(configs, lookToEndOfRule) {\n      if (PredictionMode.allConfigsInRuleStopStates(configs)) {\n        return configs;\n      }\n      const result = new ATNConfigSet(configs.fullCtx);\n      for (let i = 0; i < configs.items.length; i++) {\n        const config = configs.items[i];\n        if (config.state instanceof RuleStopState) {\n          result.add(config, this.mergeCache);\n          continue;\n        }\n        if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {\n          const nextTokens = this.atn.nextTokens(config.state);\n          if (nextTokens.contains(Token2.EPSILON)) {\n            const endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];\n            result.add(new ATNConfig({state: endOfRuleState}, config), this.mergeCache);\n          }\n        }\n      }\n      return result;\n    }\n    computeStartState(p, ctx, fullCtx) {\n      const initialContext = predictionContextFromRuleContext(this.atn, ctx);\n      const configs = new ATNConfigSet(fullCtx);\n      for (let i = 0; i < p.transitions.length; i++) {\n        const target = p.transitions[i].target;\n        const c = new ATNConfig({state: target, alt: i + 1, context: initialContext}, null);\n        const closureBusy = new Set2();\n        this.closure(c, configs, closureBusy, true, fullCtx, false);\n      }\n      return configs;\n    }\n    applyPrecedenceFilter(configs) {\n      let config;\n      const statesFromAlt1 = [];\n      const configSet = new ATNConfigSet(configs.fullCtx);\n      for (let i = 0; i < configs.items.length; i++) {\n        config = configs.items[i];\n        if (config.alt !== 1) {\n          continue;\n        }\n        const updatedContext = config.semanticContext.evalPrecedence(this.parser, this._outerContext);\n        if (updatedContext === null) {\n          continue;\n        }\n        statesFromAlt1[config.state.stateNumber] = config.context;\n        if (updatedContext !== config.semanticContext) {\n          configSet.add(new ATNConfig({semanticContext: updatedContext}, config), this.mergeCache);\n        } else {\n          configSet.add(config, this.mergeCache);\n        }\n      }\n      for (let i = 0; i < configs.items.length; i++) {\n        config = configs.items[i];\n        if (config.alt === 1) {\n          continue;\n        }\n        if (!config.precedenceFilterSuppressed) {\n          const context = statesFromAlt1[config.state.stateNumber] || null;\n          if (context !== null && context.equals(config.context)) {\n            continue;\n          }\n        }\n        configSet.add(config, this.mergeCache);\n      }\n      return configSet;\n    }\n    getReachableTarget(trans, ttype) {\n      if (trans.matches(ttype, 0, this.atn.maxTokenType)) {\n        return trans.target;\n      } else {\n        return null;\n      }\n    }\n    getPredsForAmbigAlts(ambigAlts, configs, nalts) {\n      let altToPred = [];\n      for (let i = 0; i < configs.items.length; i++) {\n        const c = configs.items[i];\n        if (ambigAlts.contains(c.alt)) {\n          altToPred[c.alt] = SemanticContext.orContext(altToPred[c.alt] || null, c.semanticContext);\n        }\n      }\n      let nPredAlts = 0;\n      for (let i = 1; i < nalts + 1; i++) {\n        const pred = altToPred[i] || null;\n        if (pred === null) {\n          altToPred[i] = SemanticContext.NONE;\n        } else if (pred !== SemanticContext.NONE) {\n          nPredAlts += 1;\n        }\n      }\n      if (nPredAlts === 0) {\n        altToPred = null;\n      }\n      if (this.debug) {\n        console.log(\"getPredsForAmbigAlts result \" + Utils3.arrayToString(altToPred));\n      }\n      return altToPred;\n    }\n    getPredicatePredictions(ambigAlts, altToPred) {\n      const pairs = [];\n      let containsPredicate = false;\n      for (let i = 1; i < altToPred.length; i++) {\n        const pred = altToPred[i];\n        if (ambigAlts !== null && ambigAlts.contains(i)) {\n          pairs.push(new PredPrediction(pred, i));\n        }\n        if (pred !== SemanticContext.NONE) {\n          containsPredicate = true;\n        }\n      }\n      if (!containsPredicate) {\n        return null;\n      }\n      return pairs;\n    }\n    getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(configs, outerContext) {\n      const cfgs = this.splitAccordingToSemanticValidity(configs, outerContext);\n      const semValidConfigs = cfgs[0];\n      const semInvalidConfigs = cfgs[1];\n      let alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);\n      if (alt !== ATN2.INVALID_ALT_NUMBER) {\n        return alt;\n      }\n      if (semInvalidConfigs.items.length > 0) {\n        alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);\n        if (alt !== ATN2.INVALID_ALT_NUMBER) {\n          return alt;\n        }\n      }\n      return ATN2.INVALID_ALT_NUMBER;\n    }\n    getAltThatFinishedDecisionEntryRule(configs) {\n      const alts = [];\n      for (let i = 0; i < configs.items.length; i++) {\n        const c = configs.items[i];\n        if (c.reachesIntoOuterContext > 0 || c.state instanceof RuleStopState && c.context.hasEmptyPath()) {\n          if (alts.indexOf(c.alt) < 0) {\n            alts.push(c.alt);\n          }\n        }\n      }\n      if (alts.length === 0) {\n        return ATN2.INVALID_ALT_NUMBER;\n      } else {\n        return Math.min.apply(null, alts);\n      }\n    }\n    splitAccordingToSemanticValidity(configs, outerContext) {\n      const succeeded = new ATNConfigSet(configs.fullCtx);\n      const failed = new ATNConfigSet(configs.fullCtx);\n      for (let i = 0; i < configs.items.length; i++) {\n        const c = configs.items[i];\n        if (c.semanticContext !== SemanticContext.NONE) {\n          const predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);\n          if (predicateEvaluationResult) {\n            succeeded.add(c);\n          } else {\n            failed.add(c);\n          }\n        } else {\n          succeeded.add(c);\n        }\n      }\n      return [succeeded, failed];\n    }\n    evalSemanticContext(predPredictions, outerContext, complete) {\n      const predictions = new BitSet();\n      for (let i = 0; i < predPredictions.length; i++) {\n        const pair = predPredictions[i];\n        if (pair.pred === SemanticContext.NONE) {\n          predictions.add(pair.alt);\n          if (!complete) {\n            break;\n          }\n          continue;\n        }\n        const predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);\n        if (this.debug || this.dfa_debug) {\n          console.log(\"eval pred \" + pair + \"=\" + predicateEvaluationResult);\n        }\n        if (predicateEvaluationResult) {\n          if (this.debug || this.dfa_debug) {\n            console.log(\"PREDICT \" + pair.alt);\n          }\n          predictions.add(pair.alt);\n          if (!complete) {\n            break;\n          }\n        }\n      }\n      return predictions;\n    }\n    closure(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {\n      const initialDepth = 0;\n      this.closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, initialDepth, treatEofAsEpsilon);\n    }\n    closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {\n      if (this.debug || this.debug_closure) {\n        console.log(\"closure(\" + config.toString(this.parser, true) + \")\");\n        if (config.reachesIntoOuterContext > 50) {\n          throw \"problem\";\n        }\n      }\n      if (config.state instanceof RuleStopState) {\n        if (!config.context.isEmpty()) {\n          for (let i = 0; i < config.context.length; i++) {\n            if (config.context.getReturnState(i) === PredictionContext.EMPTY_RETURN_STATE) {\n              if (fullCtx) {\n                configs.add(new ATNConfig({state: config.state, context: PredictionContext.EMPTY}, config), this.mergeCache);\n                continue;\n              } else {\n                if (this.debug) {\n                  console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n                }\n                this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);\n              }\n              continue;\n            }\n            const returnState = this.atn.states[config.context.getReturnState(i)];\n            const newContext = config.context.getParent(i);\n            const parms = {state: returnState, alt: config.alt, context: newContext, semanticContext: config.semanticContext};\n            const c = new ATNConfig(parms, null);\n            c.reachesIntoOuterContext = config.reachesIntoOuterContext;\n            this.closureCheckingStopState(c, configs, closureBusy, collectPredicates, fullCtx, depth - 1, treatEofAsEpsilon);\n          }\n          return;\n        } else if (fullCtx) {\n          configs.add(config, this.mergeCache);\n          return;\n        } else {\n          if (this.debug) {\n            console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n          }\n        }\n      }\n      this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);\n    }\n    closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {\n      const p = config.state;\n      if (!p.epsilonOnlyTransitions) {\n        configs.add(config, this.mergeCache);\n      }\n      for (let i = 0; i < p.transitions.length; i++) {\n        if (i === 0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config))\n          continue;\n        const t = p.transitions[i];\n        const continueCollecting = collectPredicates && !(t instanceof ActionTransition);\n        const c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);\n        if (c !== null) {\n          let newDepth = depth;\n          if (config.state instanceof RuleStopState) {\n            if (this._dfa !== null && this._dfa.precedenceDfa) {\n              if (t.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex) {\n                c.precedenceFilterSuppressed = true;\n              }\n            }\n            c.reachesIntoOuterContext += 1;\n            if (closureBusy.add(c) !== c) {\n              continue;\n            }\n            configs.dipsIntoOuterContext = true;\n            newDepth -= 1;\n            if (this.debug) {\n              console.log(\"dips into outer ctx: \" + c);\n            }\n          } else {\n            if (!t.isEpsilon && closureBusy.add(c) !== c) {\n              continue;\n            }\n            if (t instanceof RuleTransition) {\n              if (newDepth >= 0) {\n                newDepth += 1;\n              }\n            }\n          }\n          this.closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);\n        }\n      }\n    }\n    canDropLoopEntryEdgeInLeftRecursiveRule(config) {\n      const p = config.state;\n      if (p.stateType !== ATNState.STAR_LOOP_ENTRY)\n        return false;\n      if (p.stateType !== ATNState.STAR_LOOP_ENTRY || !p.isPrecedenceDecision || config.context.isEmpty() || config.context.hasEmptyPath())\n        return false;\n      const numCtxs = config.context.length;\n      for (let i = 0; i < numCtxs; i++) {\n        const returnState = this.atn.states[config.context.getReturnState(i)];\n        if (returnState.ruleIndex !== p.ruleIndex)\n          return false;\n      }\n      const decisionStartState = p.transitions[0].target;\n      const blockEndStateNum = decisionStartState.endState.stateNumber;\n      const blockEndState = this.atn.states[blockEndStateNum];\n      for (let i = 0; i < numCtxs; i++) {\n        const returnStateNumber = config.context.getReturnState(i);\n        const returnState = this.atn.states[returnStateNumber];\n        if (returnState.transitions.length !== 1 || !returnState.transitions[0].isEpsilon)\n          return false;\n        const returnStateTarget = returnState.transitions[0].target;\n        if (returnState.stateType === ATNState.BLOCK_END && returnStateTarget === p)\n          continue;\n        if (returnState === blockEndState)\n          continue;\n        if (returnStateTarget === blockEndState)\n          continue;\n        if (returnStateTarget.stateType === ATNState.BLOCK_END && returnStateTarget.transitions.length === 1 && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target === p)\n          continue;\n        return false;\n      }\n      return true;\n    }\n    getRuleName(index) {\n      if (this.parser !== null && index >= 0) {\n        return this.parser.ruleNames[index];\n      } else {\n        return \"<rule \" + index + \">\";\n      }\n    }\n    getEpsilonTarget(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {\n      switch (t.serializationType) {\n        case Transition.RULE:\n          return this.ruleTransition(config, t);\n        case Transition.PRECEDENCE:\n          return this.precedenceTransition(config, t, collectPredicates, inContext, fullCtx);\n        case Transition.PREDICATE:\n          return this.predTransition(config, t, collectPredicates, inContext, fullCtx);\n        case Transition.ACTION:\n          return this.actionTransition(config, t);\n        case Transition.EPSILON:\n          return new ATNConfig({state: t.target}, config);\n        case Transition.ATOM:\n        case Transition.RANGE:\n        case Transition.SET:\n          if (treatEofAsEpsilon) {\n            if (t.matches(Token2.EOF, 0, 1)) {\n              return new ATNConfig({state: t.target}, config);\n            }\n          }\n          return null;\n        default:\n          return null;\n      }\n    }\n    actionTransition(config, t) {\n      if (this.debug) {\n        const index = t.actionIndex === -1 ? 65535 : t.actionIndex;\n        console.log(\"ACTION edge \" + t.ruleIndex + \":\" + index);\n      }\n      return new ATNConfig({state: t.target}, config);\n    }\n    precedenceTransition(config, pt, collectPredicates, inContext, fullCtx) {\n      if (this.debug) {\n        console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" + pt.precedence + \">=_p, ctx dependent=true\");\n        if (this.parser !== null) {\n          console.log(\"context surrounding pred is \" + Utils3.arrayToString(this.parser.getRuleInvocationStack()));\n        }\n      }\n      let c = null;\n      if (collectPredicates && inContext) {\n        if (fullCtx) {\n          const currentPosition = this._input.index;\n          this._input.seek(this._startIndex);\n          const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);\n          this._input.seek(currentPosition);\n          if (predSucceeds) {\n            c = new ATNConfig({state: pt.target}, config);\n          }\n        } else {\n          const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());\n          c = new ATNConfig({state: pt.target, semanticContext: newSemCtx}, config);\n        }\n      } else {\n        c = new ATNConfig({state: pt.target}, config);\n      }\n      if (this.debug) {\n        console.log(\"config from pred transition=\" + c);\n      }\n      return c;\n    }\n    predTransition(config, pt, collectPredicates, inContext, fullCtx) {\n      if (this.debug) {\n        console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" + pt.ruleIndex + \":\" + pt.predIndex + \", ctx dependent=\" + pt.isCtxDependent);\n        if (this.parser !== null) {\n          console.log(\"context surrounding pred is \" + Utils3.arrayToString(this.parser.getRuleInvocationStack()));\n        }\n      }\n      let c = null;\n      if (collectPredicates && (pt.isCtxDependent && inContext || !pt.isCtxDependent)) {\n        if (fullCtx) {\n          const currentPosition = this._input.index;\n          this._input.seek(this._startIndex);\n          const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);\n          this._input.seek(currentPosition);\n          if (predSucceeds) {\n            c = new ATNConfig({state: pt.target}, config);\n          }\n        } else {\n          const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());\n          c = new ATNConfig({state: pt.target, semanticContext: newSemCtx}, config);\n        }\n      } else {\n        c = new ATNConfig({state: pt.target}, config);\n      }\n      if (this.debug) {\n        console.log(\"config from pred transition=\" + c);\n      }\n      return c;\n    }\n    ruleTransition(config, t) {\n      if (this.debug) {\n        console.log(\"CALL rule \" + this.getRuleName(t.target.ruleIndex) + \", ctx=\" + config.context);\n      }\n      const returnState = t.followState;\n      const newContext = SingletonPredictionContext.create(config.context, returnState.stateNumber);\n      return new ATNConfig({state: t.target, context: newContext}, config);\n    }\n    getConflictingAlts(configs) {\n      const altsets = PredictionMode.getConflictingAltSubsets(configs);\n      return PredictionMode.getAlts(altsets);\n    }\n    getConflictingAltsOrUniqueAlt(configs) {\n      let conflictingAlts = null;\n      if (configs.uniqueAlt !== ATN2.INVALID_ALT_NUMBER) {\n        conflictingAlts = new BitSet();\n        conflictingAlts.add(configs.uniqueAlt);\n      } else {\n        conflictingAlts = configs.conflictingAlts;\n      }\n      return conflictingAlts;\n    }\n    getTokenName(t) {\n      if (t === Token2.EOF) {\n        return \"EOF\";\n      }\n      if (this.parser !== null && this.parser.literalNames !== null) {\n        if (t >= this.parser.literalNames.length && t >= this.parser.symbolicNames.length) {\n          console.log(\"\" + t + \" ttype out of range: \" + this.parser.literalNames);\n          console.log(\"\" + this.parser.getInputStream().getTokens());\n        } else {\n          const name = this.parser.literalNames[t] || this.parser.symbolicNames[t];\n          return name + \"<\" + t + \">\";\n        }\n      }\n      return \"\" + t;\n    }\n    getLookaheadName(input) {\n      return this.getTokenName(input.LA(1));\n    }\n    dumpDeadEndConfigs(nvae) {\n      console.log(\"dead end configs: \");\n      const decs = nvae.getDeadEndConfigs();\n      for (let i = 0; i < decs.length; i++) {\n        const c = decs[i];\n        let trans = \"no edges\";\n        if (c.state.transitions.length > 0) {\n          const t = c.state.transitions[0];\n          if (t instanceof AtomTransition) {\n            trans = \"Atom \" + this.getTokenName(t.label);\n          } else if (t instanceof SetTransition) {\n            const neg = t instanceof NotSetTransition;\n            trans = (neg ? \"~\" : \"\") + \"Set \" + t.set;\n          }\n        }\n        console.error(c.toString(this.parser, true) + \":\" + trans);\n      }\n    }\n    noViableAlt(input, outerContext, configs, startIndex) {\n      return new NoViableAltException2(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);\n    }\n    getUniqueAlt(configs) {\n      let alt = ATN2.INVALID_ALT_NUMBER;\n      for (let i = 0; i < configs.items.length; i++) {\n        const c = configs.items[i];\n        if (alt === ATN2.INVALID_ALT_NUMBER) {\n          alt = c.alt;\n        } else if (c.alt !== alt) {\n          return ATN2.INVALID_ALT_NUMBER;\n        }\n      }\n      return alt;\n    }\n    addDFAEdge(dfa, from_, t, to) {\n      if (this.debug) {\n        console.log(\"EDGE \" + from_ + \" -> \" + to + \" upon \" + this.getTokenName(t));\n      }\n      if (to === null) {\n        return null;\n      }\n      to = this.addDFAState(dfa, to);\n      if (from_ === null || t < -1 || t > this.atn.maxTokenType) {\n        return to;\n      }\n      if (from_.edges === null) {\n        from_.edges = [];\n      }\n      from_.edges[t + 1] = to;\n      if (this.debug) {\n        const literalNames = this.parser === null ? null : this.parser.literalNames;\n        const symbolicNames = this.parser === null ? null : this.parser.symbolicNames;\n        console.log(\"DFA=\\n\" + dfa.toString(literalNames, symbolicNames));\n      }\n      return to;\n    }\n    addDFAState(dfa, D) {\n      if (D === ATNSimulator.ERROR) {\n        return D;\n      }\n      const existing = dfa.states.get(D);\n      if (existing !== null) {\n        return existing;\n      }\n      D.stateNumber = dfa.states.length;\n      if (!D.configs.readOnly) {\n        D.configs.optimizeConfigs(this);\n        D.configs.setReadonly(true);\n      }\n      dfa.states.add(D);\n      if (this.debug) {\n        console.log(\"adding new DFA state: \" + D);\n      }\n      return D;\n    }\n    reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {\n      if (this.debug || this.retry_debug) {\n        const interval = new Interval(startIndex, stopIndex + 1);\n        console.log(\"reportAttemptingFullContext decision=\" + dfa.decision + \":\" + configs + \", input=\" + this.parser.getTokenStream().getText(interval));\n      }\n      if (this.parser !== null) {\n        this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, dfa, startIndex, stopIndex, conflictingAlts, configs);\n      }\n    }\n    reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {\n      if (this.debug || this.retry_debug) {\n        const interval = new Interval(startIndex, stopIndex + 1);\n        console.log(\"reportContextSensitivity decision=\" + dfa.decision + \":\" + configs + \", input=\" + this.parser.getTokenStream().getText(interval));\n      }\n      if (this.parser !== null) {\n        this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, dfa, startIndex, stopIndex, prediction, configs);\n      }\n    }\n    reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {\n      if (this.debug || this.retry_debug) {\n        const interval = new Interval(startIndex, stopIndex + 1);\n        console.log(\"reportAmbiguity \" + ambigAlts + \":\" + configs + \", input=\" + this.parser.getTokenStream().getText(interval));\n      }\n      if (this.parser !== null) {\n        this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);\n      }\n    }\n  };\n  module2.exports = ParserATNSimulator2;\n});\n\n// node_modules/antlr4/src/antlr4/atn/index.js\nvar require_atn = __commonJS((exports) => {\n  exports.ATN = require_ATN2();\n  exports.ATNDeserializer = require_ATNDeserializer2();\n  exports.LexerATNSimulator = require_LexerATNSimulator2();\n  exports.ParserATNSimulator = require_ParserATNSimulator2();\n  exports.PredictionMode = require_PredictionMode2();\n});\n\n// node_modules/antlr4/src/antlr4/polyfills/codepointat.js\nvar require_codepointat = __commonJS(() => {\n  if (!String.prototype.codePointAt) {\n    (function() {\n      \"use strict\";\n      var defineProperty = function() {\n        let result;\n        try {\n          const object = {};\n          const $defineProperty = Object.defineProperty;\n          result = $defineProperty(object, object, object) && $defineProperty;\n        } catch (error) {\n        }\n        return result;\n      }();\n      const codePointAt = function(position) {\n        if (this == null) {\n          throw TypeError();\n        }\n        const string = String(this);\n        const size = string.length;\n        let index = position ? Number(position) : 0;\n        if (index !== index) {\n          index = 0;\n        }\n        if (index < 0 || index >= size) {\n          return void 0;\n        }\n        const first = string.charCodeAt(index);\n        let second;\n        if (first >= 55296 && first <= 56319 && size > index + 1) {\n          second = string.charCodeAt(index + 1);\n          if (second >= 56320 && second <= 57343) {\n            return (first - 55296) * 1024 + second - 56320 + 65536;\n          }\n        }\n        return first;\n      };\n      if (defineProperty) {\n        defineProperty(String.prototype, \"codePointAt\", {\n          value: codePointAt,\n          configurable: true,\n          writable: true\n        });\n      } else {\n        String.prototype.codePointAt = codePointAt;\n      }\n    })();\n  }\n});\n\n// node_modules/antlr4/src/antlr4/dfa/DFASerializer.js\nvar require_DFASerializer2 = __commonJS((exports, module2) => {\n  var DFASerializer = class {\n    constructor(dfa, literalNames, symbolicNames) {\n      this.dfa = dfa;\n      this.literalNames = literalNames || [];\n      this.symbolicNames = symbolicNames || [];\n    }\n    toString() {\n      if (this.dfa.s0 === null) {\n        return null;\n      }\n      let buf = \"\";\n      const states = this.dfa.sortedStates();\n      for (let i = 0; i < states.length; i++) {\n        const s = states[i];\n        if (s.edges !== null) {\n          const n = s.edges.length;\n          for (let j = 0; j < n; j++) {\n            const t = s.edges[j] || null;\n            if (t !== null && t.stateNumber !== 2147483647) {\n              buf = buf.concat(this.getStateString(s));\n              buf = buf.concat(\"-\");\n              buf = buf.concat(this.getEdgeLabel(j));\n              buf = buf.concat(\"->\");\n              buf = buf.concat(this.getStateString(t));\n              buf = buf.concat(\"\\n\");\n            }\n          }\n        }\n      }\n      return buf.length === 0 ? null : buf;\n    }\n    getEdgeLabel(i) {\n      if (i === 0) {\n        return \"EOF\";\n      } else if (this.literalNames !== null || this.symbolicNames !== null) {\n        return this.literalNames[i - 1] || this.symbolicNames[i - 1];\n      } else {\n        return String.fromCharCode(i - 1);\n      }\n    }\n    getStateString(s) {\n      const baseStateStr = (s.isAcceptState ? \":\" : \"\") + \"s\" + s.stateNumber + (s.requiresFullContext ? \"^\" : \"\");\n      if (s.isAcceptState) {\n        if (s.predicates !== null) {\n          return baseStateStr + \"=>\" + s.predicates.toString();\n        } else {\n          return baseStateStr + \"=>\" + s.prediction.toString();\n        }\n      } else {\n        return baseStateStr;\n      }\n    }\n  };\n  var LexerDFASerializer = class extends DFASerializer {\n    constructor(dfa) {\n      super(dfa, null);\n    }\n    getEdgeLabel(i) {\n      return \"'\" + String.fromCharCode(i) + \"'\";\n    }\n  };\n  module2.exports = {DFASerializer, LexerDFASerializer};\n});\n\n// node_modules/antlr4/src/antlr4/dfa/DFA.js\nvar require_DFA2 = __commonJS((exports, module2) => {\n  var {Set: Set2} = require_Utils2();\n  var {DFAState} = require_DFAState2();\n  var {StarLoopEntryState} = require_ATNState2();\n  var {ATNConfigSet} = require_ATNConfigSet2();\n  var {DFASerializer} = require_DFASerializer2();\n  var {LexerDFASerializer} = require_DFASerializer2();\n  var DFA = class {\n    constructor(atnStartState, decision) {\n      if (decision === void 0) {\n        decision = 0;\n      }\n      this.atnStartState = atnStartState;\n      this.decision = decision;\n      this._states = new Set2();\n      this.s0 = null;\n      this.precedenceDfa = false;\n      if (atnStartState instanceof StarLoopEntryState) {\n        if (atnStartState.isPrecedenceDecision) {\n          this.precedenceDfa = true;\n          const precedenceState = new DFAState(null, new ATNConfigSet());\n          precedenceState.edges = [];\n          precedenceState.isAcceptState = false;\n          precedenceState.requiresFullContext = false;\n          this.s0 = precedenceState;\n        }\n      }\n    }\n    getPrecedenceStartState(precedence) {\n      if (!this.precedenceDfa) {\n        throw \"Only precedence DFAs may contain a precedence start state.\";\n      }\n      if (precedence < 0 || precedence >= this.s0.edges.length) {\n        return null;\n      }\n      return this.s0.edges[precedence] || null;\n    }\n    setPrecedenceStartState(precedence, startState) {\n      if (!this.precedenceDfa) {\n        throw \"Only precedence DFAs may contain a precedence start state.\";\n      }\n      if (precedence < 0) {\n        return;\n      }\n      this.s0.edges[precedence] = startState;\n    }\n    setPrecedenceDfa(precedenceDfa) {\n      if (this.precedenceDfa !== precedenceDfa) {\n        this._states = new Set2();\n        if (precedenceDfa) {\n          const precedenceState = new DFAState(null, new ATNConfigSet());\n          precedenceState.edges = [];\n          precedenceState.isAcceptState = false;\n          precedenceState.requiresFullContext = false;\n          this.s0 = precedenceState;\n        } else {\n          this.s0 = null;\n        }\n        this.precedenceDfa = precedenceDfa;\n      }\n    }\n    sortedStates() {\n      const list = this._states.values();\n      return list.sort(function(a, b) {\n        return a.stateNumber - b.stateNumber;\n      });\n    }\n    toString(literalNames, symbolicNames) {\n      literalNames = literalNames || null;\n      symbolicNames = symbolicNames || null;\n      if (this.s0 === null) {\n        return \"\";\n      }\n      const serializer = new DFASerializer(this, literalNames, symbolicNames);\n      return serializer.toString();\n    }\n    toLexerString() {\n      if (this.s0 === null) {\n        return \"\";\n      }\n      const serializer = new LexerDFASerializer(this);\n      return serializer.toString();\n    }\n    get states() {\n      return this._states;\n    }\n  };\n  module2.exports = DFA;\n});\n\n// node_modules/antlr4/src/antlr4/dfa/index.js\nvar require_dfa = __commonJS((exports) => {\n  exports.DFA = require_DFA2();\n  exports.DFASerializer = require_DFASerializer2().DFASerializer;\n  exports.LexerDFASerializer = require_DFASerializer2().LexerDFASerializer;\n  exports.PredPrediction = require_DFAState2().PredPrediction;\n});\n\n// node_modules/antlr4/src/antlr4/polyfills/fromcodepoint.js\nvar require_fromcodepoint = __commonJS(() => {\n  if (!String.fromCodePoint) {\n    (function() {\n      const defineProperty = function() {\n        let result;\n        try {\n          const object = {};\n          const $defineProperty = Object.defineProperty;\n          result = $defineProperty(object, object, object) && $defineProperty;\n        } catch (error) {\n        }\n        return result;\n      }();\n      const stringFromCharCode = String.fromCharCode;\n      const floor = Math.floor;\n      const fromCodePoint = function(_) {\n        const MAX_SIZE = 16384;\n        const codeUnits = [];\n        let highSurrogate;\n        let lowSurrogate;\n        let index = -1;\n        const length = arguments.length;\n        if (!length) {\n          return \"\";\n        }\n        let result = \"\";\n        while (++index < length) {\n          let codePoint = Number(arguments[index]);\n          if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) {\n            throw RangeError(\"Invalid code point: \" + codePoint);\n          }\n          if (codePoint <= 65535) {\n            codeUnits.push(codePoint);\n          } else {\n            codePoint -= 65536;\n            highSurrogate = (codePoint >> 10) + 55296;\n            lowSurrogate = codePoint % 1024 + 56320;\n            codeUnits.push(highSurrogate, lowSurrogate);\n          }\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits);\n            codeUnits.length = 0;\n          }\n        }\n        return result;\n      };\n      if (defineProperty) {\n        defineProperty(String, \"fromCodePoint\", {\n          value: fromCodePoint,\n          configurable: true,\n          writable: true\n        });\n      } else {\n        String.fromCodePoint = fromCodePoint;\n      }\n    })();\n  }\n});\n\n// node_modules/antlr4/src/antlr4/tree/index.js\nvar require_tree = __commonJS((exports, module2) => {\n  var Tree = require_Tree();\n  var Trees = require_Trees2();\n  module2.exports = __objSpread(__objSpread({}, Tree), {Trees});\n});\n\n// node_modules/antlr4/src/antlr4/error/DiagnosticErrorListener.js\nvar require_DiagnosticErrorListener2 = __commonJS((exports, module2) => {\n  var {BitSet} = require_Utils2();\n  var {ErrorListener: ErrorListener2} = require_ErrorListener();\n  var {Interval} = require_IntervalSet2();\n  var DiagnosticErrorListener = class extends ErrorListener2 {\n    constructor(exactOnly) {\n      super();\n      exactOnly = exactOnly || true;\n      this.exactOnly = exactOnly;\n    }\n    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n      if (this.exactOnly && !exact) {\n        return;\n      }\n      const msg = \"reportAmbiguity d=\" + this.getDecisionDescription(recognizer, dfa) + \": ambigAlts=\" + this.getConflictingAlts(ambigAlts, configs) + \", input='\" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\";\n      recognizer.notifyErrorListeners(msg);\n    }\n    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n      const msg = \"reportAttemptingFullContext d=\" + this.getDecisionDescription(recognizer, dfa) + \", input='\" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\";\n      recognizer.notifyErrorListeners(msg);\n    }\n    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n      const msg = \"reportContextSensitivity d=\" + this.getDecisionDescription(recognizer, dfa) + \", input='\" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\";\n      recognizer.notifyErrorListeners(msg);\n    }\n    getDecisionDescription(recognizer, dfa) {\n      const decision = dfa.decision;\n      const ruleIndex = dfa.atnStartState.ruleIndex;\n      const ruleNames = recognizer.ruleNames;\n      if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {\n        return \"\" + decision;\n      }\n      const ruleName = ruleNames[ruleIndex] || null;\n      if (ruleName === null || ruleName.length === 0) {\n        return \"\" + decision;\n      }\n      return `${decision} (${ruleName})`;\n    }\n    getConflictingAlts(reportedAlts, configs) {\n      if (reportedAlts !== null) {\n        return reportedAlts;\n      }\n      const result = new BitSet();\n      for (let i = 0; i < configs.items.length; i++) {\n        result.add(configs.items[i].alt);\n      }\n      return `{${result.values().join(\", \")}}`;\n    }\n  };\n  module2.exports = DiagnosticErrorListener;\n});\n\n// node_modules/antlr4/src/antlr4/error/ErrorStrategy.js\nvar require_ErrorStrategy = __commonJS((exports, module2) => {\n  var {Token: Token2} = require_Token2();\n  var {NoViableAltException: NoViableAltException2, InputMismatchException, FailedPredicateException: FailedPredicateException2, ParseCancellationException} = require_Errors();\n  var {ATNState} = require_ATNState2();\n  var {Interval, IntervalSet} = require_IntervalSet2();\n  var ErrorStrategy = class {\n    reset(recognizer) {\n    }\n    recoverInline(recognizer) {\n    }\n    recover(recognizer, e) {\n    }\n    sync(recognizer) {\n    }\n    inErrorRecoveryMode(recognizer) {\n    }\n    reportError(recognizer) {\n    }\n  };\n  var DefaultErrorStrategy = class extends ErrorStrategy {\n    constructor() {\n      super();\n      this.errorRecoveryMode = false;\n      this.lastErrorIndex = -1;\n      this.lastErrorStates = null;\n      this.nextTokensContext = null;\n      this.nextTokenState = 0;\n    }\n    reset(recognizer) {\n      this.endErrorCondition(recognizer);\n    }\n    beginErrorCondition(recognizer) {\n      this.errorRecoveryMode = true;\n    }\n    inErrorRecoveryMode(recognizer) {\n      return this.errorRecoveryMode;\n    }\n    endErrorCondition(recognizer) {\n      this.errorRecoveryMode = false;\n      this.lastErrorStates = null;\n      this.lastErrorIndex = -1;\n    }\n    reportMatch(recognizer) {\n      this.endErrorCondition(recognizer);\n    }\n    reportError(recognizer, e) {\n      if (this.inErrorRecoveryMode(recognizer)) {\n        return;\n      }\n      this.beginErrorCondition(recognizer);\n      if (e instanceof NoViableAltException2) {\n        this.reportNoViableAlternative(recognizer, e);\n      } else if (e instanceof InputMismatchException) {\n        this.reportInputMismatch(recognizer, e);\n      } else if (e instanceof FailedPredicateException2) {\n        this.reportFailedPredicate(recognizer, e);\n      } else {\n        console.log(\"unknown recognition error type: \" + e.constructor.name);\n        console.log(e.stack);\n        recognizer.notifyErrorListeners(e.getOffendingToken(), e.getMessage(), e);\n      }\n    }\n    recover(recognizer, e) {\n      if (this.lastErrorIndex === recognizer.getInputStream().index && this.lastErrorStates !== null && this.lastErrorStates.indexOf(recognizer.state) >= 0) {\n        recognizer.consume();\n      }\n      this.lastErrorIndex = recognizer._input.index;\n      if (this.lastErrorStates === null) {\n        this.lastErrorStates = [];\n      }\n      this.lastErrorStates.push(recognizer.state);\n      const followSet = this.getErrorRecoverySet(recognizer);\n      this.consumeUntil(recognizer, followSet);\n    }\n    sync(recognizer) {\n      if (this.inErrorRecoveryMode(recognizer)) {\n        return;\n      }\n      const s = recognizer._interp.atn.states[recognizer.state];\n      const la = recognizer.getTokenStream().LA(1);\n      const nextTokens = recognizer.atn.nextTokens(s);\n      if (nextTokens.contains(la)) {\n        this.nextTokensContext = null;\n        this.nextTokenState = ATNState.INVALID_STATE_NUMBER;\n        return;\n      } else if (nextTokens.contains(Token2.EPSILON)) {\n        if (this.nextTokensContext === null) {\n          this.nextTokensContext = recognizer._ctx;\n          this.nextTokensState = recognizer._stateNumber;\n        }\n        return;\n      }\n      switch (s.stateType) {\n        case ATNState.BLOCK_START:\n        case ATNState.STAR_BLOCK_START:\n        case ATNState.PLUS_BLOCK_START:\n        case ATNState.STAR_LOOP_ENTRY:\n          if (this.singleTokenDeletion(recognizer) !== null) {\n            return;\n          } else {\n            throw new InputMismatchException(recognizer);\n          }\n        case ATNState.PLUS_LOOP_BACK:\n        case ATNState.STAR_LOOP_BACK:\n          this.reportUnwantedToken(recognizer);\n          const expecting = new IntervalSet();\n          expecting.addSet(recognizer.getExpectedTokens());\n          const whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer));\n          this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);\n          break;\n        default:\n      }\n    }\n    reportNoViableAlternative(recognizer, e) {\n      const tokens2 = recognizer.getTokenStream();\n      let input;\n      if (tokens2 !== null) {\n        if (e.startToken.type === Token2.EOF) {\n          input = \"<EOF>\";\n        } else {\n          input = tokens2.getText(new Interval(e.startToken.tokenIndex, e.offendingToken.tokenIndex));\n        }\n      } else {\n        input = \"<unknown input>\";\n      }\n      const msg = \"no viable alternative at input \" + this.escapeWSAndQuote(input);\n      recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n    }\n    reportInputMismatch(recognizer, e) {\n      const msg = \"mismatched input \" + this.getTokenErrorDisplay(e.offendingToken) + \" expecting \" + e.getExpectedTokens().toString(recognizer.literalNames, recognizer.symbolicNames);\n      recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n    }\n    reportFailedPredicate(recognizer, e) {\n      const ruleName = recognizer.ruleNames[recognizer._ctx.ruleIndex];\n      const msg = \"rule \" + ruleName + \" \" + e.message;\n      recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n    }\n    reportUnwantedToken(recognizer) {\n      if (this.inErrorRecoveryMode(recognizer)) {\n        return;\n      }\n      this.beginErrorCondition(recognizer);\n      const t = recognizer.getCurrentToken();\n      const tokenName = this.getTokenErrorDisplay(t);\n      const expecting = this.getExpectedTokens(recognizer);\n      const msg = \"extraneous input \" + tokenName + \" expecting \" + expecting.toString(recognizer.literalNames, recognizer.symbolicNames);\n      recognizer.notifyErrorListeners(msg, t, null);\n    }\n    reportMissingToken(recognizer) {\n      if (this.inErrorRecoveryMode(recognizer)) {\n        return;\n      }\n      this.beginErrorCondition(recognizer);\n      const t = recognizer.getCurrentToken();\n      const expecting = this.getExpectedTokens(recognizer);\n      const msg = \"missing \" + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) + \" at \" + this.getTokenErrorDisplay(t);\n      recognizer.notifyErrorListeners(msg, t, null);\n    }\n    recoverInline(recognizer) {\n      const matchedSymbol = this.singleTokenDeletion(recognizer);\n      if (matchedSymbol !== null) {\n        recognizer.consume();\n        return matchedSymbol;\n      }\n      if (this.singleTokenInsertion(recognizer)) {\n        return this.getMissingSymbol(recognizer);\n      }\n      throw new InputMismatchException(recognizer);\n    }\n    singleTokenInsertion(recognizer) {\n      const currentSymbolType = recognizer.getTokenStream().LA(1);\n      const atn = recognizer._interp.atn;\n      const currentState = atn.states[recognizer.state];\n      const next = currentState.transitions[0].target;\n      const expectingAtLL2 = atn.nextTokens(next, recognizer._ctx);\n      if (expectingAtLL2.contains(currentSymbolType)) {\n        this.reportMissingToken(recognizer);\n        return true;\n      } else {\n        return false;\n      }\n    }\n    singleTokenDeletion(recognizer) {\n      const nextTokenType = recognizer.getTokenStream().LA(2);\n      const expecting = this.getExpectedTokens(recognizer);\n      if (expecting.contains(nextTokenType)) {\n        this.reportUnwantedToken(recognizer);\n        recognizer.consume();\n        const matchedSymbol = recognizer.getCurrentToken();\n        this.reportMatch(recognizer);\n        return matchedSymbol;\n      } else {\n        return null;\n      }\n    }\n    getMissingSymbol(recognizer) {\n      const currentSymbol = recognizer.getCurrentToken();\n      const expecting = this.getExpectedTokens(recognizer);\n      const expectedTokenType = expecting.first();\n      let tokenText;\n      if (expectedTokenType === Token2.EOF) {\n        tokenText = \"<missing EOF>\";\n      } else {\n        tokenText = \"<missing \" + recognizer.literalNames[expectedTokenType] + \">\";\n      }\n      let current = currentSymbol;\n      const lookback = recognizer.getTokenStream().LT(-1);\n      if (current.type === Token2.EOF && lookback !== null) {\n        current = lookback;\n      }\n      return recognizer.getTokenFactory().create(current.source, expectedTokenType, tokenText, Token2.DEFAULT_CHANNEL, -1, -1, current.line, current.column);\n    }\n    getExpectedTokens(recognizer) {\n      return recognizer.getExpectedTokens();\n    }\n    getTokenErrorDisplay(t) {\n      if (t === null) {\n        return \"<no token>\";\n      }\n      let s = t.text;\n      if (s === null) {\n        if (t.type === Token2.EOF) {\n          s = \"<EOF>\";\n        } else {\n          s = \"<\" + t.type + \">\";\n        }\n      }\n      return this.escapeWSAndQuote(s);\n    }\n    escapeWSAndQuote(s) {\n      s = s.replace(/\\n/g, \"\\\\n\");\n      s = s.replace(/\\r/g, \"\\\\r\");\n      s = s.replace(/\\t/g, \"\\\\t\");\n      return \"'\" + s + \"'\";\n    }\n    getErrorRecoverySet(recognizer) {\n      const atn = recognizer._interp.atn;\n      let ctx = recognizer._ctx;\n      const recoverSet = new IntervalSet();\n      while (ctx !== null && ctx.invokingState >= 0) {\n        const invokingState = atn.states[ctx.invokingState];\n        const rt = invokingState.transitions[0];\n        const follow = atn.nextTokens(rt.followState);\n        recoverSet.addSet(follow);\n        ctx = ctx.parentCtx;\n      }\n      recoverSet.removeOne(Token2.EPSILON);\n      return recoverSet;\n    }\n    consumeUntil(recognizer, set) {\n      let ttype = recognizer.getTokenStream().LA(1);\n      while (ttype !== Token2.EOF && !set.contains(ttype)) {\n        recognizer.consume();\n        ttype = recognizer.getTokenStream().LA(1);\n      }\n    }\n  };\n  var BailErrorStrategy = class extends DefaultErrorStrategy {\n    constructor() {\n      super();\n    }\n    recover(recognizer, e) {\n      let context = recognizer._ctx;\n      while (context !== null) {\n        context.exception = e;\n        context = context.parentCtx;\n      }\n      throw new ParseCancellationException(e);\n    }\n    recoverInline(recognizer) {\n      this.recover(recognizer, new InputMismatchException(recognizer));\n    }\n    sync(recognizer) {\n    }\n  };\n  module2.exports = {BailErrorStrategy, DefaultErrorStrategy};\n});\n\n// node_modules/antlr4/src/antlr4/error/index.js\nvar require_error = __commonJS((exports, module2) => {\n  module2.exports.RecognitionException = require_Errors().RecognitionException;\n  module2.exports.NoViableAltException = require_Errors().NoViableAltException;\n  module2.exports.LexerNoViableAltException = require_Errors().LexerNoViableAltException;\n  module2.exports.InputMismatchException = require_Errors().InputMismatchException;\n  module2.exports.FailedPredicateException = require_Errors().FailedPredicateException;\n  module2.exports.DiagnosticErrorListener = require_DiagnosticErrorListener2();\n  module2.exports.BailErrorStrategy = require_ErrorStrategy().BailErrorStrategy;\n  module2.exports.DefaultErrorStrategy = require_ErrorStrategy().DefaultErrorStrategy;\n  module2.exports.ErrorListener = require_ErrorListener().ErrorListener;\n});\n\n// node_modules/antlr4/src/antlr4/InputStream.js\nvar require_InputStream = __commonJS((exports, module2) => {\n  var {Token: Token2} = require_Token2();\n  require_codepointat();\n  require_fromcodepoint();\n  var InputStream = class {\n    constructor(data, decodeToUnicodeCodePoints) {\n      this.name = \"<empty>\";\n      this.strdata = data;\n      this.decodeToUnicodeCodePoints = decodeToUnicodeCodePoints || false;\n      this._index = 0;\n      this.data = [];\n      if (this.decodeToUnicodeCodePoints) {\n        for (let i = 0; i < this.strdata.length; ) {\n          const codePoint = this.strdata.codePointAt(i);\n          this.data.push(codePoint);\n          i += codePoint <= 65535 ? 1 : 2;\n        }\n      } else {\n        for (let i = 0; i < this.strdata.length; i++) {\n          const codeUnit = this.strdata.charCodeAt(i);\n          this.data.push(codeUnit);\n        }\n      }\n      this._size = this.data.length;\n    }\n    reset() {\n      this._index = 0;\n    }\n    consume() {\n      if (this._index >= this._size) {\n        throw \"cannot consume EOF\";\n      }\n      this._index += 1;\n    }\n    LA(offset) {\n      if (offset === 0) {\n        return 0;\n      }\n      if (offset < 0) {\n        offset += 1;\n      }\n      const pos = this._index + offset - 1;\n      if (pos < 0 || pos >= this._size) {\n        return Token2.EOF;\n      }\n      return this.data[pos];\n    }\n    LT(offset) {\n      return this.LA(offset);\n    }\n    mark() {\n      return -1;\n    }\n    release(marker) {\n    }\n    seek(_index) {\n      if (_index <= this._index) {\n        this._index = _index;\n        return;\n      }\n      this._index = Math.min(_index, this._size);\n    }\n    getText(start, stop) {\n      if (stop >= this._size) {\n        stop = this._size - 1;\n      }\n      if (start >= this._size) {\n        return \"\";\n      } else {\n        if (this.decodeToUnicodeCodePoints) {\n          let result = \"\";\n          for (let i = start; i <= stop; i++) {\n            result += String.fromCodePoint(this.data[i]);\n          }\n          return result;\n        } else {\n          return this.strdata.slice(start, stop + 1);\n        }\n      }\n    }\n    toString() {\n      return this.strdata;\n    }\n    get index() {\n      return this._index;\n    }\n    get size() {\n      return this._size;\n    }\n  };\n  module2.exports = InputStream;\n});\n\n// node_modules/antlr4/src/antlr4/CharStreams.js\nvar require_CharStreams2 = __commonJS((exports, module2) => {\n  var InputStream = require_InputStream();\n  var fs = __webpack_require__(/*! fs */ \"fs\");\n  var CharStreams = {\n    fromString: function(str) {\n      return new InputStream(str, true);\n    },\n    fromBlob: function(blob, encoding, onLoad, onError) {\n      const reader = new window.FileReader();\n      reader.onload = function(e) {\n        const is = new InputStream(e.target.result, true);\n        onLoad(is);\n      };\n      reader.onerror = onError;\n      reader.readAsText(blob, encoding);\n    },\n    fromBuffer: function(buffer, encoding) {\n      return new InputStream(buffer.toString(encoding), true);\n    },\n    fromPath: function(path, encoding, callback) {\n      fs.readFile(path, encoding, function(err, data) {\n        let is = null;\n        if (data !== null) {\n          is = new InputStream(data, true);\n        }\n        callback(err, is);\n      });\n    },\n    fromPathSync: function(path, encoding) {\n      const data = fs.readFileSync(path, encoding);\n      return new InputStream(data, true);\n    }\n  };\n  module2.exports = CharStreams;\n});\n\n// node_modules/antlr4/src/antlr4/FileStream.js\nvar require_FileStream = __commonJS((exports, module2) => {\n  var InputStream = require_InputStream();\n  var fs = __webpack_require__(/*! fs */ \"fs\");\n  var FileStream = class extends InputStream {\n    constructor(fileName, decodeToUnicodeCodePoints) {\n      const data = fs.readFileSync(fileName, \"utf8\");\n      super(data, decodeToUnicodeCodePoints);\n      this.fileName = fileName;\n    }\n  };\n  module2.exports = FileStream;\n});\n\n// node_modules/antlr4/src/antlr4/BufferedTokenStream.js\nvar require_BufferedTokenStream2 = __commonJS((exports, module2) => {\n  var {Token: Token2} = require_Token2();\n  var Lexer2 = require_Lexer2();\n  var {Interval} = require_IntervalSet2();\n  var TokenStream = class {\n  };\n  var BufferedTokenStream = class extends TokenStream {\n    constructor(tokenSource) {\n      super();\n      this.tokenSource = tokenSource;\n      this.tokens = [];\n      this.index = -1;\n      this.fetchedEOF = false;\n    }\n    mark() {\n      return 0;\n    }\n    release(marker) {\n    }\n    reset() {\n      this.seek(0);\n    }\n    seek(index) {\n      this.lazyInit();\n      this.index = this.adjustSeekIndex(index);\n    }\n    get(index) {\n      this.lazyInit();\n      return this.tokens[index];\n    }\n    consume() {\n      let skipEofCheck = false;\n      if (this.index >= 0) {\n        if (this.fetchedEOF) {\n          skipEofCheck = this.index < this.tokens.length - 1;\n        } else {\n          skipEofCheck = this.index < this.tokens.length;\n        }\n      } else {\n        skipEofCheck = false;\n      }\n      if (!skipEofCheck && this.LA(1) === Token2.EOF) {\n        throw \"cannot consume EOF\";\n      }\n      if (this.sync(this.index + 1)) {\n        this.index = this.adjustSeekIndex(this.index + 1);\n      }\n    }\n    sync(i) {\n      const n = i - this.tokens.length + 1;\n      if (n > 0) {\n        const fetched = this.fetch(n);\n        return fetched >= n;\n      }\n      return true;\n    }\n    fetch(n) {\n      if (this.fetchedEOF) {\n        return 0;\n      }\n      for (let i = 0; i < n; i++) {\n        const t = this.tokenSource.nextToken();\n        t.tokenIndex = this.tokens.length;\n        this.tokens.push(t);\n        if (t.type === Token2.EOF) {\n          this.fetchedEOF = true;\n          return i + 1;\n        }\n      }\n      return n;\n    }\n    getTokens(start, stop, types) {\n      if (types === void 0) {\n        types = null;\n      }\n      if (start < 0 || stop < 0) {\n        return null;\n      }\n      this.lazyInit();\n      const subset = [];\n      if (stop >= this.tokens.length) {\n        stop = this.tokens.length - 1;\n      }\n      for (let i = start; i < stop; i++) {\n        const t = this.tokens[i];\n        if (t.type === Token2.EOF) {\n          break;\n        }\n        if (types === null || types.contains(t.type)) {\n          subset.push(t);\n        }\n      }\n      return subset;\n    }\n    LA(i) {\n      return this.LT(i).type;\n    }\n    LB(k) {\n      if (this.index - k < 0) {\n        return null;\n      }\n      return this.tokens[this.index - k];\n    }\n    LT(k) {\n      this.lazyInit();\n      if (k === 0) {\n        return null;\n      }\n      if (k < 0) {\n        return this.LB(-k);\n      }\n      const i = this.index + k - 1;\n      this.sync(i);\n      if (i >= this.tokens.length) {\n        return this.tokens[this.tokens.length - 1];\n      }\n      return this.tokens[i];\n    }\n    adjustSeekIndex(i) {\n      return i;\n    }\n    lazyInit() {\n      if (this.index === -1) {\n        this.setup();\n      }\n    }\n    setup() {\n      this.sync(0);\n      this.index = this.adjustSeekIndex(0);\n    }\n    setTokenSource(tokenSource) {\n      this.tokenSource = tokenSource;\n      this.tokens = [];\n      this.index = -1;\n      this.fetchedEOF = false;\n    }\n    nextTokenOnChannel(i, channel) {\n      this.sync(i);\n      if (i >= this.tokens.length) {\n        return -1;\n      }\n      let token = this.tokens[i];\n      while (token.channel !== this.channel) {\n        if (token.type === Token2.EOF) {\n          return -1;\n        }\n        i += 1;\n        this.sync(i);\n        token = this.tokens[i];\n      }\n      return i;\n    }\n    previousTokenOnChannel(i, channel) {\n      while (i >= 0 && this.tokens[i].channel !== channel) {\n        i -= 1;\n      }\n      return i;\n    }\n    getHiddenTokensToRight(tokenIndex, channel) {\n      if (channel === void 0) {\n        channel = -1;\n      }\n      this.lazyInit();\n      if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {\n        throw \"\" + tokenIndex + \" not in 0..\" + this.tokens.length - 1;\n      }\n      const nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer2.DEFAULT_TOKEN_CHANNEL);\n      const from_ = tokenIndex + 1;\n      const to = nextOnChannel === -1 ? this.tokens.length - 1 : nextOnChannel;\n      return this.filterForChannel(from_, to, channel);\n    }\n    getHiddenTokensToLeft(tokenIndex, channel) {\n      if (channel === void 0) {\n        channel = -1;\n      }\n      this.lazyInit();\n      if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {\n        throw \"\" + tokenIndex + \" not in 0..\" + this.tokens.length - 1;\n      }\n      const prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer2.DEFAULT_TOKEN_CHANNEL);\n      if (prevOnChannel === tokenIndex - 1) {\n        return null;\n      }\n      const from_ = prevOnChannel + 1;\n      const to = tokenIndex - 1;\n      return this.filterForChannel(from_, to, channel);\n    }\n    filterForChannel(left, right, channel) {\n      const hidden = [];\n      for (let i = left; i < right + 1; i++) {\n        const t = this.tokens[i];\n        if (channel === -1) {\n          if (t.channel !== Lexer2.DEFAULT_TOKEN_CHANNEL) {\n            hidden.push(t);\n          }\n        } else if (t.channel === channel) {\n          hidden.push(t);\n        }\n      }\n      if (hidden.length === 0) {\n        return null;\n      }\n      return hidden;\n    }\n    getSourceName() {\n      return this.tokenSource.getSourceName();\n    }\n    getText(interval) {\n      this.lazyInit();\n      this.fill();\n      if (interval === void 0 || interval === null) {\n        interval = new Interval(0, this.tokens.length - 1);\n      }\n      let start = interval.start;\n      if (start instanceof Token2) {\n        start = start.tokenIndex;\n      }\n      let stop = interval.stop;\n      if (stop instanceof Token2) {\n        stop = stop.tokenIndex;\n      }\n      if (start === null || stop === null || start < 0 || stop < 0) {\n        return \"\";\n      }\n      if (stop >= this.tokens.length) {\n        stop = this.tokens.length - 1;\n      }\n      let s = \"\";\n      for (let i = start; i < stop + 1; i++) {\n        const t = this.tokens[i];\n        if (t.type === Token2.EOF) {\n          break;\n        }\n        s = s + t.text;\n      }\n      return s;\n    }\n    fill() {\n      this.lazyInit();\n      while (this.fetch(1e3) === 1e3) {\n        continue;\n      }\n    }\n  };\n  module2.exports = BufferedTokenStream;\n});\n\n// node_modules/antlr4/src/antlr4/CommonTokenStream.js\nvar require_CommonTokenStream2 = __commonJS((exports, module2) => {\n  var Token2 = require_Token2().Token;\n  var BufferedTokenStream = require_BufferedTokenStream2();\n  var CommonTokenStream2 = class extends BufferedTokenStream {\n    constructor(lexer, channel) {\n      super(lexer);\n      this.channel = channel === void 0 ? Token2.DEFAULT_CHANNEL : channel;\n    }\n    adjustSeekIndex(i) {\n      return this.nextTokenOnChannel(i, this.channel);\n    }\n    LB(k) {\n      if (k === 0 || this.index - k < 0) {\n        return null;\n      }\n      let i = this.index;\n      let n = 1;\n      while (n <= k) {\n        i = this.previousTokenOnChannel(i - 1, this.channel);\n        n += 1;\n      }\n      if (i < 0) {\n        return null;\n      }\n      return this.tokens[i];\n    }\n    LT(k) {\n      this.lazyInit();\n      if (k === 0) {\n        return null;\n      }\n      if (k < 0) {\n        return this.LB(-k);\n      }\n      let i = this.index;\n      let n = 1;\n      while (n < k) {\n        if (this.sync(i + 1)) {\n          i = this.nextTokenOnChannel(i + 1, this.channel);\n        }\n        n += 1;\n      }\n      return this.tokens[i];\n    }\n    getNumberOfOnChannelTokens() {\n      let n = 0;\n      this.fill();\n      for (let i = 0; i < this.tokens.length; i++) {\n        const t = this.tokens[i];\n        if (t.channel === this.channel) {\n          n += 1;\n        }\n        if (t.type === Token2.EOF) {\n          break;\n        }\n      }\n      return n;\n    }\n  };\n  module2.exports = CommonTokenStream2;\n});\n\n// node_modules/antlr4/src/antlr4/Parser.js\nvar require_Parser2 = __commonJS((exports, module2) => {\n  var {Token: Token2} = require_Token2();\n  var {ParseTreeListener, TerminalNode, ErrorNode: ErrorNode2} = require_Tree();\n  var Recognizer = require_Recognizer2();\n  var {DefaultErrorStrategy} = require_ErrorStrategy();\n  var ATNDeserializer3 = require_ATNDeserializer2();\n  var ATNDeserializationOptions = require_ATNDeserializationOptions2();\n  var Lexer2 = require_Lexer2();\n  var TraceListener = class extends ParseTreeListener {\n    constructor(parser) {\n      super();\n      this.parser = parser;\n    }\n    enterEveryRule(ctx) {\n      console.log(\"enter   \" + this.parser.ruleNames[ctx.ruleIndex] + \", LT(1)=\" + this.parser._input.LT(1).text);\n    }\n    visitTerminal(node) {\n      console.log(\"consume \" + node.symbol + \" rule \" + this.parser.ruleNames[this.parser._ctx.ruleIndex]);\n    }\n    exitEveryRule(ctx) {\n      console.log(\"exit    \" + this.parser.ruleNames[ctx.ruleIndex] + \", LT(1)=\" + this.parser._input.LT(1).text);\n    }\n  };\n  var Parser2 = class extends Recognizer {\n    constructor(input) {\n      super();\n      this._input = null;\n      this._errHandler = new DefaultErrorStrategy();\n      this._precedenceStack = [];\n      this._precedenceStack.push(0);\n      this._ctx = null;\n      this.buildParseTrees = true;\n      this._tracer = null;\n      this._parseListeners = null;\n      this._syntaxErrors = 0;\n      this.setInputStream(input);\n    }\n    reset() {\n      if (this._input !== null) {\n        this._input.seek(0);\n      }\n      this._errHandler.reset(this);\n      this._ctx = null;\n      this._syntaxErrors = 0;\n      this.setTrace(false);\n      this._precedenceStack = [];\n      this._precedenceStack.push(0);\n      if (this._interp !== null) {\n        this._interp.reset();\n      }\n    }\n    match(ttype) {\n      let t = this.getCurrentToken();\n      if (t.type === ttype) {\n        this._errHandler.reportMatch(this);\n        this.consume();\n      } else {\n        t = this._errHandler.recoverInline(this);\n        if (this.buildParseTrees && t.tokenIndex === -1) {\n          this._ctx.addErrorNode(t);\n        }\n      }\n      return t;\n    }\n    matchWildcard() {\n      let t = this.getCurrentToken();\n      if (t.type > 0) {\n        this._errHandler.reportMatch(this);\n        this.consume();\n      } else {\n        t = this._errHandler.recoverInline(this);\n        if (this._buildParseTrees && t.tokenIndex === -1) {\n          this._ctx.addErrorNode(t);\n        }\n      }\n      return t;\n    }\n    getParseListeners() {\n      return this._parseListeners || [];\n    }\n    addParseListener(listener) {\n      if (listener === null) {\n        throw \"listener\";\n      }\n      if (this._parseListeners === null) {\n        this._parseListeners = [];\n      }\n      this._parseListeners.push(listener);\n    }\n    removeParseListener(listener) {\n      if (this._parseListeners !== null) {\n        const idx = this._parseListeners.indexOf(listener);\n        if (idx >= 0) {\n          this._parseListeners.splice(idx, 1);\n        }\n        if (this._parseListeners.length === 0) {\n          this._parseListeners = null;\n        }\n      }\n    }\n    removeParseListeners() {\n      this._parseListeners = null;\n    }\n    triggerEnterRuleEvent() {\n      if (this._parseListeners !== null) {\n        const ctx = this._ctx;\n        this._parseListeners.map(function(listener) {\n          listener.enterEveryRule(ctx);\n          ctx.enterRule(listener);\n        });\n      }\n    }\n    triggerExitRuleEvent() {\n      if (this._parseListeners !== null) {\n        const ctx = this._ctx;\n        this._parseListeners.slice(0).reverse().map(function(listener) {\n          ctx.exitRule(listener);\n          listener.exitEveryRule(ctx);\n        });\n      }\n    }\n    getTokenFactory() {\n      return this._input.tokenSource._factory;\n    }\n    setTokenFactory(factory) {\n      this._input.tokenSource._factory = factory;\n    }\n    getATNWithBypassAlts() {\n      const serializedAtn = this.getSerializedATN();\n      if (serializedAtn === null) {\n        throw \"The current parser does not support an ATN with bypass alternatives.\";\n      }\n      let result = this.bypassAltsAtnCache[serializedAtn];\n      if (result === null) {\n        const deserializationOptions = new ATNDeserializationOptions();\n        deserializationOptions.generateRuleBypassTransitions = true;\n        result = new ATNDeserializer3(deserializationOptions).deserialize(serializedAtn);\n        this.bypassAltsAtnCache[serializedAtn] = result;\n      }\n      return result;\n    }\n    compileParseTreePattern(pattern, patternRuleIndex, lexer) {\n      lexer = lexer || null;\n      if (lexer === null) {\n        if (this.getTokenStream() !== null) {\n          const tokenSource = this.getTokenStream().tokenSource;\n          if (tokenSource instanceof Lexer2) {\n            lexer = tokenSource;\n          }\n        }\n      }\n      if (lexer === null) {\n        throw \"Parser can't discover a lexer to use\";\n      }\n      const m = new ParseTreePatternMatcher(lexer, this);\n      return m.compile(pattern, patternRuleIndex);\n    }\n    getInputStream() {\n      return this.getTokenStream();\n    }\n    setInputStream(input) {\n      this.setTokenStream(input);\n    }\n    getTokenStream() {\n      return this._input;\n    }\n    setTokenStream(input) {\n      this._input = null;\n      this.reset();\n      this._input = input;\n    }\n    getCurrentToken() {\n      return this._input.LT(1);\n    }\n    notifyErrorListeners(msg, offendingToken, err) {\n      offendingToken = offendingToken || null;\n      err = err || null;\n      if (offendingToken === null) {\n        offendingToken = this.getCurrentToken();\n      }\n      this._syntaxErrors += 1;\n      const line = offendingToken.line;\n      const column = offendingToken.column;\n      const listener = this.getErrorListenerDispatch();\n      listener.syntaxError(this, offendingToken, line, column, msg, err);\n    }\n    consume() {\n      const o = this.getCurrentToken();\n      if (o.type !== Token2.EOF) {\n        this.getInputStream().consume();\n      }\n      const hasListener = this._parseListeners !== null && this._parseListeners.length > 0;\n      if (this.buildParseTrees || hasListener) {\n        let node;\n        if (this._errHandler.inErrorRecoveryMode(this)) {\n          node = this._ctx.addErrorNode(o);\n        } else {\n          node = this._ctx.addTokenNode(o);\n        }\n        node.invokingState = this.state;\n        if (hasListener) {\n          this._parseListeners.map(function(listener) {\n            if (node instanceof ErrorNode2 || node.isErrorNode !== void 0 && node.isErrorNode()) {\n              listener.visitErrorNode(node);\n            } else if (node instanceof TerminalNode) {\n              listener.visitTerminal(node);\n            }\n          });\n        }\n      }\n      return o;\n    }\n    addContextToParseTree() {\n      if (this._ctx.parentCtx !== null) {\n        this._ctx.parentCtx.addChild(this._ctx);\n      }\n    }\n    enterRule(localctx, state, ruleIndex) {\n      this.state = state;\n      this._ctx = localctx;\n      this._ctx.start = this._input.LT(1);\n      if (this.buildParseTrees) {\n        this.addContextToParseTree();\n      }\n      if (this._parseListeners !== null) {\n        this.triggerEnterRuleEvent();\n      }\n    }\n    exitRule() {\n      this._ctx.stop = this._input.LT(-1);\n      if (this._parseListeners !== null) {\n        this.triggerExitRuleEvent();\n      }\n      this.state = this._ctx.invokingState;\n      this._ctx = this._ctx.parentCtx;\n    }\n    enterOuterAlt(localctx, altNum) {\n      localctx.setAltNumber(altNum);\n      if (this.buildParseTrees && this._ctx !== localctx) {\n        if (this._ctx.parentCtx !== null) {\n          this._ctx.parentCtx.removeLastChild();\n          this._ctx.parentCtx.addChild(localctx);\n        }\n      }\n      this._ctx = localctx;\n    }\n    getPrecedence() {\n      if (this._precedenceStack.length === 0) {\n        return -1;\n      } else {\n        return this._precedenceStack[this._precedenceStack.length - 1];\n      }\n    }\n    enterRecursionRule(localctx, state, ruleIndex, precedence) {\n      this.state = state;\n      this._precedenceStack.push(precedence);\n      this._ctx = localctx;\n      this._ctx.start = this._input.LT(1);\n      if (this._parseListeners !== null) {\n        this.triggerEnterRuleEvent();\n      }\n    }\n    pushNewRecursionContext(localctx, state, ruleIndex) {\n      const previous = this._ctx;\n      previous.parentCtx = localctx;\n      previous.invokingState = state;\n      previous.stop = this._input.LT(-1);\n      this._ctx = localctx;\n      this._ctx.start = previous.start;\n      if (this.buildParseTrees) {\n        this._ctx.addChild(previous);\n      }\n      if (this._parseListeners !== null) {\n        this.triggerEnterRuleEvent();\n      }\n    }\n    unrollRecursionContexts(parentCtx) {\n      this._precedenceStack.pop();\n      this._ctx.stop = this._input.LT(-1);\n      const retCtx = this._ctx;\n      if (this._parseListeners !== null) {\n        while (this._ctx !== parentCtx) {\n          this.triggerExitRuleEvent();\n          this._ctx = this._ctx.parentCtx;\n        }\n      } else {\n        this._ctx = parentCtx;\n      }\n      retCtx.parentCtx = parentCtx;\n      if (this.buildParseTrees && parentCtx !== null) {\n        parentCtx.addChild(retCtx);\n      }\n    }\n    getInvokingContext(ruleIndex) {\n      let ctx = this._ctx;\n      while (ctx !== null) {\n        if (ctx.ruleIndex === ruleIndex) {\n          return ctx;\n        }\n        ctx = ctx.parentCtx;\n      }\n      return null;\n    }\n    precpred(localctx, precedence) {\n      return precedence >= this._precedenceStack[this._precedenceStack.length - 1];\n    }\n    inContext(context) {\n      return false;\n    }\n    isExpectedToken(symbol) {\n      const atn = this._interp.atn;\n      let ctx = this._ctx;\n      const s = atn.states[this.state];\n      let following = atn.nextTokens(s);\n      if (following.contains(symbol)) {\n        return true;\n      }\n      if (!following.contains(Token2.EPSILON)) {\n        return false;\n      }\n      while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token2.EPSILON)) {\n        const invokingState = atn.states[ctx.invokingState];\n        const rt = invokingState.transitions[0];\n        following = atn.nextTokens(rt.followState);\n        if (following.contains(symbol)) {\n          return true;\n        }\n        ctx = ctx.parentCtx;\n      }\n      if (following.contains(Token2.EPSILON) && symbol === Token2.EOF) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n    getExpectedTokens() {\n      return this._interp.atn.getExpectedTokens(this.state, this._ctx);\n    }\n    getExpectedTokensWithinCurrentRule() {\n      const atn = this._interp.atn;\n      const s = atn.states[this.state];\n      return atn.nextTokens(s);\n    }\n    getRuleIndex(ruleName) {\n      const ruleIndex = this.getRuleIndexMap()[ruleName];\n      if (ruleIndex !== null) {\n        return ruleIndex;\n      } else {\n        return -1;\n      }\n    }\n    getRuleInvocationStack(p) {\n      p = p || null;\n      if (p === null) {\n        p = this._ctx;\n      }\n      const stack = [];\n      while (p !== null) {\n        const ruleIndex = p.ruleIndex;\n        if (ruleIndex < 0) {\n          stack.push(\"n/a\");\n        } else {\n          stack.push(this.ruleNames[ruleIndex]);\n        }\n        p = p.parentCtx;\n      }\n      return stack;\n    }\n    getDFAStrings() {\n      return this._interp.decisionToDFA.toString();\n    }\n    dumpDFA() {\n      let seenOne = false;\n      for (let i = 0; i < this._interp.decisionToDFA.length; i++) {\n        const dfa = this._interp.decisionToDFA[i];\n        if (dfa.states.length > 0) {\n          if (seenOne) {\n            console.log();\n          }\n          this.printer.println(\"Decision \" + dfa.decision + \":\");\n          this.printer.print(dfa.toString(this.literalNames, this.symbolicNames));\n          seenOne = true;\n        }\n      }\n    }\n    getSourceName() {\n      return this._input.sourceName;\n    }\n    setTrace(trace) {\n      if (!trace) {\n        this.removeParseListener(this._tracer);\n        this._tracer = null;\n      } else {\n        if (this._tracer !== null) {\n          this.removeParseListener(this._tracer);\n        }\n        this._tracer = new TraceListener(this);\n        this.addParseListener(this._tracer);\n      }\n    }\n  };\n  Parser2.bypassAltsAtnCache = {};\n  module2.exports = Parser2;\n});\n\n// node_modules/antlr4/src/antlr4/index.js\nvar require_antlr4 = __commonJS((exports) => {\n  exports.atn = require_atn();\n  exports.codepointat = require_codepointat();\n  exports.dfa = require_dfa();\n  exports.fromcodepoint = require_fromcodepoint();\n  exports.tree = require_tree();\n  exports.error = require_error();\n  exports.Token = require_Token2().Token;\n  exports.CharStreams = require_CharStreams2();\n  exports.CommonToken = require_Token2().CommonToken;\n  exports.InputStream = require_InputStream();\n  exports.FileStream = require_FileStream();\n  exports.CommonTokenStream = require_CommonTokenStream2();\n  exports.Lexer = require_Lexer2();\n  exports.Parser = require_Parser2();\n  var pc = require_PredictionContext2();\n  exports.PredictionContextCache = pc.PredictionContextCache;\n  exports.ParserRuleContext = require_ParserRuleContext2();\n  exports.Interval = require_IntervalSet2().Interval;\n  exports.IntervalSet = require_IntervalSet2().IntervalSet;\n  exports.Utils = require_Utils2();\n  exports.LL1Analyzer = require_LL1Analyzer2().LL1Analyzer;\n});\n\n// src/antlr/Solidity.tokens\nvar require_Solidity = __commonJS((exports, module2) => {\n  module2.exports = \"./Solidity-EZVQ6AE4.tokens\";\n});\n\n// src/tokens-string.js\nvar require_tokens_string = __commonJS((exports, module2) => {\n  if (typeof BROWSER !== \"undefined\") {\n    module2.exports = require_Solidity();\n  } else {\n    module2.exports = (__webpack_require__(/*! fs */ \"fs\").readFileSync)((__webpack_require__(/*! path */ \"path\").join)(__dirname, \"./antlr/Solidity.tokens\")).toString();\n  }\n});\n\n// src/index.ts\n__markAsModule(exports);\n__export(exports, {\n  ParserError: () => ParserError,\n  parse: () => parse,\n  tokenize: () => tokenize,\n  visit: () => visit\n});\n\n// src/parser.ts\nvar import_antlr4ts = __toModule(require_antlr4ts());\n\n// src/antlr/SolidityLexer.ts\nvar import_ATNDeserializer = __toModule(require_ATNDeserializer());\nvar import_Lexer = __toModule(require_Lexer());\nvar import_LexerATNSimulator = __toModule(require_LexerATNSimulator());\nvar import_VocabularyImpl = __toModule(require_VocabularyImpl());\nvar Utils = __toModule(require_Utils());\nvar _SolidityLexer = class extends import_Lexer.Lexer {\n  get vocabulary() {\n    return _SolidityLexer.VOCABULARY;\n  }\n  constructor(input) {\n    super(input);\n    this._interp = new import_LexerATNSimulator.LexerATNSimulator(_SolidityLexer._ATN, this);\n  }\n  get grammarFileName() {\n    return \"Solidity.g4\";\n  }\n  get ruleNames() {\n    return _SolidityLexer.ruleNames;\n  }\n  get serializedATN() {\n    return _SolidityLexer._serializedATN;\n  }\n  get channelNames() {\n    return _SolidityLexer.channelNames;\n  }\n  get modeNames() {\n    return _SolidityLexer.modeNames;\n  }\n  static get _ATN() {\n    if (!_SolidityLexer.__ATN) {\n      _SolidityLexer.__ATN = new import_ATNDeserializer.ATNDeserializer().deserialize(Utils.toCharArray(_SolidityLexer._serializedATN));\n    }\n    return _SolidityLexer.__ATN;\n  }\n};\nvar SolidityLexer = _SolidityLexer;\nSolidityLexer.T__0 = 1;\nSolidityLexer.T__1 = 2;\nSolidityLexer.T__2 = 3;\nSolidityLexer.T__3 = 4;\nSolidityLexer.T__4 = 5;\nSolidityLexer.T__5 = 6;\nSolidityLexer.T__6 = 7;\nSolidityLexer.T__7 = 8;\nSolidityLexer.T__8 = 9;\nSolidityLexer.T__9 = 10;\nSolidityLexer.T__10 = 11;\nSolidityLexer.T__11 = 12;\nSolidityLexer.T__12 = 13;\nSolidityLexer.T__13 = 14;\nSolidityLexer.T__14 = 15;\nSolidityLexer.T__15 = 16;\nSolidityLexer.T__16 = 17;\nSolidityLexer.T__17 = 18;\nSolidityLexer.T__18 = 19;\nSolidityLexer.T__19 = 20;\nSolidityLexer.T__20 = 21;\nSolidityLexer.T__21 = 22;\nSolidityLexer.T__22 = 23;\nSolidityLexer.T__23 = 24;\nSolidityLexer.T__24 = 25;\nSolidityLexer.T__25 = 26;\nSolidityLexer.T__26 = 27;\nSolidityLexer.T__27 = 28;\nSolidityLexer.T__28 = 29;\nSolidityLexer.T__29 = 30;\nSolidityLexer.T__30 = 31;\nSolidityLexer.T__31 = 32;\nSolidityLexer.T__32 = 33;\nSolidityLexer.T__33 = 34;\nSolidityLexer.T__34 = 35;\nSolidityLexer.T__35 = 36;\nSolidityLexer.T__36 = 37;\nSolidityLexer.T__37 = 38;\nSolidityLexer.T__38 = 39;\nSolidityLexer.T__39 = 40;\nSolidityLexer.T__40 = 41;\nSolidityLexer.T__41 = 42;\nSolidityLexer.T__42 = 43;\nSolidityLexer.T__43 = 44;\nSolidityLexer.T__44 = 45;\nSolidityLexer.T__45 = 46;\nSolidityLexer.T__46 = 47;\nSolidityLexer.T__47 = 48;\nSolidityLexer.T__48 = 49;\nSolidityLexer.T__49 = 50;\nSolidityLexer.T__50 = 51;\nSolidityLexer.T__51 = 52;\nSolidityLexer.T__52 = 53;\nSolidityLexer.T__53 = 54;\nSolidityLexer.T__54 = 55;\nSolidityLexer.T__55 = 56;\nSolidityLexer.T__56 = 57;\nSolidityLexer.T__57 = 58;\nSolidityLexer.T__58 = 59;\nSolidityLexer.T__59 = 60;\nSolidityLexer.T__60 = 61;\nSolidityLexer.T__61 = 62;\nSolidityLexer.T__62 = 63;\nSolidityLexer.T__63 = 64;\nSolidityLexer.T__64 = 65;\nSolidityLexer.T__65 = 66;\nSolidityLexer.T__66 = 67;\nSolidityLexer.T__67 = 68;\nSolidityLexer.T__68 = 69;\nSolidityLexer.T__69 = 70;\nSolidityLexer.T__70 = 71;\nSolidityLexer.T__71 = 72;\nSolidityLexer.T__72 = 73;\nSolidityLexer.T__73 = 74;\nSolidityLexer.T__74 = 75;\nSolidityLexer.T__75 = 76;\nSolidityLexer.T__76 = 77;\nSolidityLexer.T__77 = 78;\nSolidityLexer.T__78 = 79;\nSolidityLexer.T__79 = 80;\nSolidityLexer.T__80 = 81;\nSolidityLexer.T__81 = 82;\nSolidityLexer.T__82 = 83;\nSolidityLexer.T__83 = 84;\nSolidityLexer.T__84 = 85;\nSolidityLexer.T__85 = 86;\nSolidityLexer.T__86 = 87;\nSolidityLexer.T__87 = 88;\nSolidityLexer.T__88 = 89;\nSolidityLexer.T__89 = 90;\nSolidityLexer.T__90 = 91;\nSolidityLexer.T__91 = 92;\nSolidityLexer.T__92 = 93;\nSolidityLexer.T__93 = 94;\nSolidityLexer.T__94 = 95;\nSolidityLexer.T__95 = 96;\nSolidityLexer.T__96 = 97;\nSolidityLexer.Int = 98;\nSolidityLexer.Uint = 99;\nSolidityLexer.Byte = 100;\nSolidityLexer.Fixed = 101;\nSolidityLexer.Ufixed = 102;\nSolidityLexer.BooleanLiteral = 103;\nSolidityLexer.DecimalNumber = 104;\nSolidityLexer.HexNumber = 105;\nSolidityLexer.NumberUnit = 106;\nSolidityLexer.HexLiteralFragment = 107;\nSolidityLexer.ReservedKeyword = 108;\nSolidityLexer.AnonymousKeyword = 109;\nSolidityLexer.BreakKeyword = 110;\nSolidityLexer.ConstantKeyword = 111;\nSolidityLexer.ImmutableKeyword = 112;\nSolidityLexer.ContinueKeyword = 113;\nSolidityLexer.LeaveKeyword = 114;\nSolidityLexer.ExternalKeyword = 115;\nSolidityLexer.IndexedKeyword = 116;\nSolidityLexer.InternalKeyword = 117;\nSolidityLexer.PayableKeyword = 118;\nSolidityLexer.PrivateKeyword = 119;\nSolidityLexer.PublicKeyword = 120;\nSolidityLexer.VirtualKeyword = 121;\nSolidityLexer.PureKeyword = 122;\nSolidityLexer.TypeKeyword = 123;\nSolidityLexer.ViewKeyword = 124;\nSolidityLexer.GlobalKeyword = 125;\nSolidityLexer.ConstructorKeyword = 126;\nSolidityLexer.FallbackKeyword = 127;\nSolidityLexer.ReceiveKeyword = 128;\nSolidityLexer.Identifier = 129;\nSolidityLexer.StringLiteralFragment = 130;\nSolidityLexer.VersionLiteral = 131;\nSolidityLexer.WS = 132;\nSolidityLexer.COMMENT = 133;\nSolidityLexer.LINE_COMMENT = 134;\nSolidityLexer.channelNames = [\n  \"DEFAULT_TOKEN_CHANNEL\",\n  \"HIDDEN\"\n];\nSolidityLexer.modeNames = [\n  \"DEFAULT_MODE\"\n];\nSolidityLexer.ruleNames = [\n  \"T__0\",\n  \"T__1\",\n  \"T__2\",\n  \"T__3\",\n  \"T__4\",\n  \"T__5\",\n  \"T__6\",\n  \"T__7\",\n  \"T__8\",\n  \"T__9\",\n  \"T__10\",\n  \"T__11\",\n  \"T__12\",\n  \"T__13\",\n  \"T__14\",\n  \"T__15\",\n  \"T__16\",\n  \"T__17\",\n  \"T__18\",\n  \"T__19\",\n  \"T__20\",\n  \"T__21\",\n  \"T__22\",\n  \"T__23\",\n  \"T__24\",\n  \"T__25\",\n  \"T__26\",\n  \"T__27\",\n  \"T__28\",\n  \"T__29\",\n  \"T__30\",\n  \"T__31\",\n  \"T__32\",\n  \"T__33\",\n  \"T__34\",\n  \"T__35\",\n  \"T__36\",\n  \"T__37\",\n  \"T__38\",\n  \"T__39\",\n  \"T__40\",\n  \"T__41\",\n  \"T__42\",\n  \"T__43\",\n  \"T__44\",\n  \"T__45\",\n  \"T__46\",\n  \"T__47\",\n  \"T__48\",\n  \"T__49\",\n  \"T__50\",\n  \"T__51\",\n  \"T__52\",\n  \"T__53\",\n  \"T__54\",\n  \"T__55\",\n  \"T__56\",\n  \"T__57\",\n  \"T__58\",\n  \"T__59\",\n  \"T__60\",\n  \"T__61\",\n  \"T__62\",\n  \"T__63\",\n  \"T__64\",\n  \"T__65\",\n  \"T__66\",\n  \"T__67\",\n  \"T__68\",\n  \"T__69\",\n  \"T__70\",\n  \"T__71\",\n  \"T__72\",\n  \"T__73\",\n  \"T__74\",\n  \"T__75\",\n  \"T__76\",\n  \"T__77\",\n  \"T__78\",\n  \"T__79\",\n  \"T__80\",\n  \"T__81\",\n  \"T__82\",\n  \"T__83\",\n  \"T__84\",\n  \"T__85\",\n  \"T__86\",\n  \"T__87\",\n  \"T__88\",\n  \"T__89\",\n  \"T__90\",\n  \"T__91\",\n  \"T__92\",\n  \"T__93\",\n  \"T__94\",\n  \"T__95\",\n  \"T__96\",\n  \"Int\",\n  \"Uint\",\n  \"Byte\",\n  \"Fixed\",\n  \"Ufixed\",\n  \"BooleanLiteral\",\n  \"DecimalNumber\",\n  \"DecimalDigits\",\n  \"HexNumber\",\n  \"HexDigits\",\n  \"NumberUnit\",\n  \"HexLiteralFragment\",\n  \"HexPair\",\n  \"HexCharacter\",\n  \"ReservedKeyword\",\n  \"AnonymousKeyword\",\n  \"BreakKeyword\",\n  \"ConstantKeyword\",\n  \"ImmutableKeyword\",\n  \"ContinueKeyword\",\n  \"LeaveKeyword\",\n  \"ExternalKeyword\",\n  \"IndexedKeyword\",\n  \"InternalKeyword\",\n  \"PayableKeyword\",\n  \"PrivateKeyword\",\n  \"PublicKeyword\",\n  \"VirtualKeyword\",\n  \"PureKeyword\",\n  \"TypeKeyword\",\n  \"ViewKeyword\",\n  \"GlobalKeyword\",\n  \"ConstructorKeyword\",\n  \"FallbackKeyword\",\n  \"ReceiveKeyword\",\n  \"Identifier\",\n  \"IdentifierStart\",\n  \"IdentifierPart\",\n  \"StringLiteralFragment\",\n  \"DoubleQuotedStringCharacter\",\n  \"SingleQuotedStringCharacter\",\n  \"VersionLiteral\",\n  \"WS\",\n  \"COMMENT\",\n  \"LINE_COMMENT\"\n];\nSolidityLexer._LITERAL_NAMES = [\n  void 0,\n  \"'pragma'\",\n  \"';'\",\n  \"'*'\",\n  \"'||'\",\n  \"'^'\",\n  \"'~'\",\n  \"'>='\",\n  \"'>'\",\n  \"'<'\",\n  \"'<='\",\n  \"'='\",\n  \"'as'\",\n  \"'import'\",\n  \"'from'\",\n  \"'{'\",\n  \"','\",\n  \"'}'\",\n  \"'abstract'\",\n  \"'contract'\",\n  \"'interface'\",\n  \"'library'\",\n  \"'is'\",\n  \"'('\",\n  \"')'\",\n  \"'error'\",\n  \"'using'\",\n  \"'for'\",\n  \"'struct'\",\n  \"'modifier'\",\n  \"'function'\",\n  \"'returns'\",\n  \"'event'\",\n  \"'enum'\",\n  \"'['\",\n  \"']'\",\n  \"'address'\",\n  \"'.'\",\n  \"'mapping'\",\n  \"'=>'\",\n  \"'memory'\",\n  \"'storage'\",\n  \"'calldata'\",\n  \"'if'\",\n  \"'else'\",\n  \"'try'\",\n  \"'catch'\",\n  \"'while'\",\n  \"'unchecked'\",\n  \"'assembly'\",\n  \"'do'\",\n  \"'return'\",\n  \"'throw'\",\n  \"'emit'\",\n  \"'revert'\",\n  \"'var'\",\n  \"'bool'\",\n  \"'string'\",\n  \"'byte'\",\n  \"'++'\",\n  \"'--'\",\n  \"'new'\",\n  \"':'\",\n  \"'+'\",\n  \"'-'\",\n  \"'after'\",\n  \"'delete'\",\n  \"'!'\",\n  \"'**'\",\n  \"'/'\",\n  \"'%'\",\n  \"'<<'\",\n  \"'>>'\",\n  \"'&'\",\n  \"'|'\",\n  \"'=='\",\n  \"'!='\",\n  \"'&&'\",\n  \"'?'\",\n  \"'|='\",\n  \"'^='\",\n  \"'&='\",\n  \"'<<='\",\n  \"'>>='\",\n  \"'+='\",\n  \"'-='\",\n  \"'*='\",\n  \"'/='\",\n  \"'%='\",\n  \"'let'\",\n  \"':='\",\n  \"'=:'\",\n  \"'switch'\",\n  \"'case'\",\n  \"'default'\",\n  \"'->'\",\n  \"'callback'\",\n  \"'override'\",\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  \"'anonymous'\",\n  \"'break'\",\n  \"'constant'\",\n  \"'immutable'\",\n  \"'continue'\",\n  \"'leave'\",\n  \"'external'\",\n  \"'indexed'\",\n  \"'internal'\",\n  \"'payable'\",\n  \"'private'\",\n  \"'public'\",\n  \"'virtual'\",\n  \"'pure'\",\n  \"'type'\",\n  \"'view'\",\n  \"'global'\",\n  \"'constructor'\",\n  \"'fallback'\",\n  \"'receive'\"\n];\nSolidityLexer._SYMBOLIC_NAMES = [\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  \"Int\",\n  \"Uint\",\n  \"Byte\",\n  \"Fixed\",\n  \"Ufixed\",\n  \"BooleanLiteral\",\n  \"DecimalNumber\",\n  \"HexNumber\",\n  \"NumberUnit\",\n  \"HexLiteralFragment\",\n  \"ReservedKeyword\",\n  \"AnonymousKeyword\",\n  \"BreakKeyword\",\n  \"ConstantKeyword\",\n  \"ImmutableKeyword\",\n  \"ContinueKeyword\",\n  \"LeaveKeyword\",\n  \"ExternalKeyword\",\n  \"IndexedKeyword\",\n  \"InternalKeyword\",\n  \"PayableKeyword\",\n  \"PrivateKeyword\",\n  \"PublicKeyword\",\n  \"VirtualKeyword\",\n  \"PureKeyword\",\n  \"TypeKeyword\",\n  \"ViewKeyword\",\n  \"GlobalKeyword\",\n  \"ConstructorKeyword\",\n  \"FallbackKeyword\",\n  \"ReceiveKeyword\",\n  \"Identifier\",\n  \"StringLiteralFragment\",\n  \"VersionLiteral\",\n  \"WS\",\n  \"COMMENT\",\n  \"LINE_COMMENT\"\n];\nSolidityLexer.VOCABULARY = new import_VocabularyImpl.VocabularyImpl(_SolidityLexer._LITERAL_NAMES, _SolidityLexer._SYMBOLIC_NAMES, []);\nSolidityLexer._serializedATNSegments = 4;\nSolidityLexer._serializedATNSegment0 = `\u0003\\uC91D\\uCABA\\u058D\\uAFBA\\u4F53\\u0607\\uEA8B\\uC241\u0002\\x88\\u0757\\b\u0001\u0004\u0002\t\u0002\u0004\u0003\t\u0003\u0004\u0004\t\u0004\u0004\u0005\t\u0005\u0004\u0006\t\u0006\u0004\\x07\t\\x07\u0004\\b\t\\b\u0004\t\t\t\u0004\n\t\n\u0004\\v\t\\v\u0004\\f\t\\f\u0004\\r\t\\r\u0004\u000e\t\u000e\u0004\u000f\t\u000f\u0004\u0010\t\u0010\u0004\u0011\t\u0011\u0004\u0012\t\u0012\u0004\u0013\t\u0013\u0004\u0014\t\u0014\u0004\u0015\t\u0015\u0004\u0016\t\u0016\u0004\u0017\t\u0017\u0004\u0018\t\u0018\u0004\u0019\t\u0019\u0004\u001a\t\u001a\u0004\u001b\t\u001b\u0004\u001c\t\u001c\u0004\u001d\t\u001d\u0004\u001e\t\u001e\u0004\u001f\t\u001f\u0004 \t \u0004!\t!\u0004\"\t\"\u0004#\t#\u0004$\t$\u0004%\t%\u0004&\t&\u0004'\t'\u0004(\t(\u0004)\t)\u0004*\t*\u0004+\t+\u0004,\t,\u0004-\t-\u0004.\t.\u0004/\t/\u00040\t0\u00041\t1\u00042\t2\u00043\t3\u00044\t4\u00045\t5\u00046\t6\u00047\t7\u00048\t8\u00049\t9\u0004:\t:\u0004;\t;\u0004<\t<\u0004=\t=\u0004>\t>\u0004?\t?\u0004@\t@\u0004A\tA\u0004B\tB\u0004C\tC\u0004D\tD\u0004E\tE\u0004F\tF\u0004G\tG\u0004H\tH\u0004I\tI\u0004J\tJ\u0004K\tK\u0004L\tL\u0004M\tM\u0004N\tN\u0004O\tO\u0004P\tP\u0004Q\tQ\u0004R\tR\u0004S\tS\u0004T\tT\u0004U\tU\u0004V\tV\u0004W\tW\u0004X\tX\u0004Y\tY\u0004Z\tZ\u0004[\t[\u0004\\\\\t\\\\\u0004]\t]\u0004^\t^\u0004_\t_\u0004\\`\t\\`\u0004a\ta\u0004b\tb\u0004c\tc\u0004d\td\u0004e\te\u0004f\tf\u0004g\tg\u0004h\th\u0004i\ti\u0004j\tj\u0004k\tk\u0004l\tl\u0004m\tm\u0004n\tn\u0004o\to\u0004p\tp\u0004q\tq\u0004r\tr\u0004s\ts\u0004t\tt\u0004u\tu\u0004v\tv\u0004w\tw\u0004x\tx\u0004y\ty\u0004z\tz\u0004{\t{\u0004|\t|\u0004}\t}\u0004~\t~\u0004\\x7F\t\\x7F\u0004\\x80\t\\x80\u0004\\x81\t\\x81\u0004\\x82\t\\x82\u0004\\x83\t\\x83\u0004\\x84\t\\x84\u0004\\x85\t\\x85\u0004\\x86\t\\x86\u0004\\x87\t\\x87\u0004\\x88\t\\x88\u0004\\x89\t\\x89\u0004\\x8A\t\\x8A\u0004\\x8B\t\\x8B\u0004\\x8C\t\\x8C\u0004\\x8D\t\\x8D\u0004\\x8E\t\\x8E\u0004\\x8F\t\\x8F\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0003\u0003\u0003\u0003\u0004\u0003\u0004\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0006\u0003\u0006\u0003\\x07\u0003\\x07\u0003\\b\u0003\\b\u0003\\b\u0003\t\u0003\t\u0003\n\u0003\n\u0003\\v\u0003\\v\u0003\\v\u0003\\f\u0003\\f\u0003\\r\u0003\\r\u0003\\r\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000f\u0003\u000f\u0003\u000f\u0003\u000f\u0003\u000f\u0003\u0010\u0003\u0010\u0003\u0011\u0003\u0011\u0003\u0012\u0003\u0012\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0014\u0003\u0014\u0003\u0014\u0003\u0014\u0003\u0014\u0003\u0014\u0003\u0014\u0003\u0014\u0003\u0014\u0003\u0015\u0003\u0015\u0003\u0015\u0003\u0015\u0003\u0015\u0003\u0015\u0003\u0015\u0003\u0015\u0003\u0015\u0003\u0015\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0018\u0003\u0018\u0003\u0019\u0003\u0019\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001d\u0003\u001d\u0003\u001d\u0003\u001d\u0003\u001d\u0003\u001d\u0003\u001d\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001f\u0003\u001f\u0003\u001f\u0003\u001f\u0003\u001f\u0003\u001f\u0003\u001f\u0003\u001f\u0003\u001f\u0003 \u0003 \u0003 \u0003 \u0003 \u0003 \u0003 \u0003 \u0003!\u0003!\u0003!\u0003!\u0003!\u0003!\u0003\"\u0003\"\u0003\"\u0003\"\u0003\"\u0003#\u0003#\u0003$\u0003$\u0003%\u0003%\u0003%\u0003%\u0003%\u0003%\u0003%\u0003%\u0003&\u0003&\u0003'\u0003'\u0003'\u0003'\u0003'\u0003'\u0003'\u0003'\u0003(\u0003(\u0003(\u0003)\u0003)\u0003)\u0003)\u0003)\u0003)\u0003)\u0003*\u0003*\u0003*\u0003*\u0003*\u0003*\u0003*\u0003*\u0003+\u0003+\u0003+\u0003+\u0003+\u0003+\u0003+\u0003+\u0003+\u0003,\u0003,\u0003,\u0003-\u0003-\u0003-\u0003-\u0003-\u0003.\u0003.\u0003.\u0003.\u0003/\u0003/\u0003/\u0003/\u0003/\u0003/\u00030\u00030\u00030\u00030\u00030\u00030\u00031\u00031\u00031\u00031\u00031\u00031\u00031\u00031\u00031\u00031\u00032\u00032\u00032\u00032\u00032\u00032\u00032\u00032\u00032\u00033\u00033\u00033\u00034\u00034\u00034\u00034\u00034\u00034\u00034\u00035\u00035\u00035\u00035\u00035\u00035\u00036\u00036\u00036\u00036\u00036\u00037\u00037\u00037\u00037\u00037\u00037\u00037\u00038\u00038\u00038\u00038\u00039\u00039\u00039\u00039\u00039\u0003:\u0003:\u0003:\u0003:\u0003:\u0003:\u0003:\u0003;\u0003;\u0003;\u0003;\u0003;\u0003<\u0003<\u0003<\u0003=\u0003=\u0003=\u0003>\u0003>\u0003>\u0003>\u0003?\u0003?\u0003@\u0003@\u0003A\u0003A\u0003B\u0003B\u0003B\u0003B\u0003B\u0003B\u0003C\u0003C\u0003C\u0003C\u0003C\u0003C\u0003C\u0003D\u0003D\u0003E\u0003E\u0003E\u0003F\u0003F\u0003G\u0003G\u0003H\u0003H\u0003H\u0003I\u0003I\u0003I\u0003J\u0003J\u0003K\u0003K\u0003L\u0003L\u0003L\u0003M\u0003M\u0003M\u0003N\u0003N\u0003N\u0003O\u0003O\u0003P\u0003P\u0003P\u0003Q\u0003Q\u0003Q\u0003R\u0003R\u0003R\u0003S\u0003S\u0003S\u0003S\u0003T\u0003T\u0003T\u0003T\u0003U\u0003U\u0003U\u0003V\u0003V\u0003V\u0003W\u0003W\u0003W\u0003X\u0003X\u0003X\u0003Y\u0003Y\u0003Y\u0003Z\u0003Z\u0003Z\u0003Z\u0003[\u0003[\u0003[\u0003\\\\\u0003\\\\\u0003\\\\\u0003]\u0003]\u0003]\u0003]\u0003]\u0003]\u0003]\u0003^\u0003^\u0003^\u0003^\u0003^\u0003_\u0003_\u0003_\u0003_\u0003_\u0003_\u0003_\u0003_\u0003\\`\u0003\\`\u0003\\`\u0003a\u0003a\u0003a\u0003a\u0003a\u0003a\u0003a\u0003a\u0003a\u0003b\u0003b\u0003b\u0003b\u0003b\u0003b\u0003b\u0003b\u0003b\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0005c\\u038B\nc\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0005d\\u0464\nd\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0003e\u0005e\\u0542\ne\u0003f\u0003f\u0003f\u0003f\u0003f\u0003f\u0003f\u0003f\u0003f\u0003f\u0003f\u0003f\u0006f\\u0550\nf\\rf\u000ef\\u0551\u0003f\u0003f\u0006f\\u0556\nf\\rf\u000ef\\u0557\u0005f\\u055A\nf\u0003g\u0003g\u0003g\u0003g\u0003g\u0003g\u0003g\u0003g\u0003g\u0003g\u0003g\u0003g\u0003g\u0003g\u0006g\\u056A\ng\\rg\u000eg\\u056B\u0003g\u0003g\u0006g\\u0570\ng\\rg\u000eg\\u0571\u0005g\\u0574\ng\u0003h\u0003h\u0003h\u0003h\u0003h\u0003h\u0003h\u0003h\u0003h\u0005h\\u057F\nh\u0003i\u0003i\u0005i\\u0583\ni\u0003i\u0003i\u0005i\\u0587\ni\u0003i\u0003i\u0005i\\u058B\ni\u0003j\u0003j\u0005j\\u058F\nj\u0003j\\x07j\\u0592\nj\\fj\u000ej\\u0595\\vj\u0003k\u0003k\u0003k\u0003k\u0003l\u0003l\u0005l\\u059D\nl\u0003l\\x07l\\u05A0\nl\\fl\u000el\\u05A3\\vl\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0005m\\u05DD\nm\u0003n\u0003n\u0003n\u0003n\u0003n\u0003n\u0005n\\u05E5\nn\u0003n\u0003n\u0003n\u0005n\\u05EA\nn\u0003n\u0005n\\u05ED\nn\u0003o\u0003o\u0003o\u0003p\u0003p\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0003q\u0005q\\u064C\nq\u0003r\u0003r\u0003r\u0003r\u0003r\u0003r\u0003r\u0003r\u0003r\u0003r\u0003s\u0003s\u0003s\u0003s\u0003s\u0003s\u0003t\u0003t\u0003t\u0003t\u0003t\u0003t\u0003t\u0003t\u0003t\u0003u\u0003u\u0003u\u0003u\u0003u\u0003u\u0003u\u0003u\u0003u\u0003u\u0003v\u0003v\u0003v\u0003v\u0003v\u0003v\u0003v\u0003v\u0003v\u0003w\u0003w\u0003w\u0003w\u0003w\u0003w\u0003x\u0003x\u0003x\u0003x\u0003x\u0003x\u0003x\u0003x\u0003x\u0003y\u0003y\u0003y\u0003y\u0003y\u0003y\u0003y\u0003y\u0003z\u0003z\u0003z\u0003z\u0003z\u0003z\u0003z\u0003z\u0003z\u0003{\u0003{\u0003{\u0003{\u0003{\u0003{\u0003{\u0003{\u0003|\u0003|\u0003|\u0003|\u0003|\u0003|\u0003|\u0003|\u0003}\u0003}\u0003}\u0003}\u0003}\u0003}\u0003}\u0003~\u0003~\u0003~\u0003~\u0003~\u0003~\u0003~\u0003~\u0003\\x7F\u0003\\x7F\u0003\\x7F\u0003\\x7F\u0003\\x7F\u0003\\x80\u0003\\x80\u0003\\x80\u0003\\x80\u0003\\x80\u0003\\x81\u0003\\x81\u0003\\x81\u0003\\x81\u0003\\x81\u0003\\x82\u0003\\x82\u0003\\x82\u0003\\x82\u0003\\x82\u0003\\x82\u0003\\x82\u0003\\x83\u0003\\x83\u0003\\x83\u0003\\x83\u0003\\x83\u0003\\x83\u0003\\x83\u0003\\x83\u0003\\x83\u0003\\x83\u0003\\x83\u0003\\x83\u0003\\x84\u0003\\x84\u0003\\x84\u0003\\x84\u0003\\x84\u0003\\x84\u0003\\x84\u0003\\x84\u0003\\x84\u0003\\x85\u0003\\x85\u0003\\x85\u0003\\x85\u0003\\x85\u0003\\x85\u0003\\x85\u0003\\x85\u0003\\x86\u0003\\x86\\x07\\x86\\u06EE\n\\x86\\f\\x86\u000e\\x86\\u06F1\\v\\x86\u0003\\x87\u0003\\x87\u0003\\x88\u0003\\x88\u0003\\x89\u0003\\x89\u0003\\x89\u0003\\x89\u0003\\x89\u0003\\x89\u0003\\x89\u0005\\x89\\u06FE\n\\x89\u0003\\x89\u0003\\x89\\x07\\x89\\u0702\n\\x89\\f\\x89\u000e\\x89\\u0705\\v\\x89\u0003\\x89\u0003\\x89\u0003\\x89\u0003\\x89\u0003\\x89\u0003\\x89\u0003\\x89\u0003\\x89\u0005\\x89\\u070F\n\\x89\u0003\\x89\u0003\\x89\\x07\\x89\\u0713\n\\x89\\f\\x89\u000e\\x89\\u0716\\v\\x89\u0003\\x89\u0005\\x89\\u0719\n\\x89\u0003\\x8A\u0003\\x8A\u0003\\x8A\u0005\\x8A\\u071E\n\\x8A\u0003\\x8B\u0003\\x8B\u0003\\x8B\u0005\\x8B\\u0723\n\\x8B\u0003\\x8C\u0006\\x8C\\u0726\n\\x8C\\r\\x8C\u000e\\x8C\\u0727\u0003\\x8C\u0003\\x8C\u0006\\x8C\\u072C\n\\x8C\\r\\x8C\u000e\\x8C\\u072D\u0003\\x8C\u0003\\x8C\u0006\\x8C\\u0732\n\\x8C\\r\\x8C\u000e\\x8C\\u0733\u0005\\x8C\\u0736\n\\x8C\u0003\\x8D\u0006\\x8D\\u0739\n\\x8D\\r\\x8D\u000e\\x8D\\u073A\u0003\\x8D\u0003\\x8D\u0003\\x8E\u0003\\x8E\u0003\\x8E\u0003\\x8E\\x07\\x8E\\u0743\n\\x8E\\f\\x8E\u000e\\x8E\\u0746\\v\\x8E\u0003\\x8E\u0003\\x8E\u0003\\x8E\u0003\\x8E\u0003\\x8E\u0003\\x8F\u0003\\x8F\u0003\\x8F\u0003\\x8F\\x07\\x8F\\u0751\n\\x8F\\f\\x8F\u000e\\x8F\\u0754\\v\\x8F\u0003\\x8F\u0003\\x8F\u0003\\u0744\u0002\u0002\\x90\u0003\u0002\u0003\u0005\u0002\u0004\\x07\u0002\u0005\t\u0002\u0006\\v\u0002\\x07\\r\u0002\\b\u000f\u0002\t\u0011\u0002\n\u0013\u0002\\v\u0015\u0002\\f\u0017\u0002\\r\u0019\u0002\u000e\u001b\u0002\u000f\u001d\u0002\u0010\u001f\u0002\u0011!\u0002\u0012#\u0002\u0013%\u0002\u0014'\u0002\u0015)\u0002\u0016+\u0002\u0017-\u0002\u0018/\u0002\u00191\u0002\u001a3\u0002\u001b5\u0002\u001c7\u0002\u001d9\u0002\u001e;\u0002\u001f=\u0002 ?\u0002!A\u0002\"C\u0002#E\u0002$G\u0002%I\u0002&K\u0002'M\u0002(O\u0002)Q\u0002*S\u0002+U\u0002,W\u0002-Y\u0002.[\u0002/]\u00020_\u00021a\u00022c\u00023e\u00024g\u00025i\u00026k\u00027m\u00028o\u00029q\u0002:s\u0002;u\u0002<w\u0002=y\u0002>{\u0002?}\u0002@\\x7F\u0002A\\x81\u0002B\\x83\u0002C\\x85\u0002D\\x87\u0002E\\x89\u0002F\\x8B\u0002G\\x8D\u0002H\\x8F\u0002I\\x91\u0002J\\x93\u0002K\\x95\u0002L\\x97\u0002M\\x99\u0002N\\x9B\u0002O\\x9D\u0002P\\x9F\u0002Q\\xA1\u0002R\\xA3\u0002S\\xA5\u0002T\\xA7\u0002U\\xA9\u0002V\\xAB\u0002W\\xAD\u0002X\\xAF\u0002Y\\xB1\u0002Z\\xB3\u0002[\\xB5\u0002\\\\\\xB7\u0002]\\xB9\u0002^\\xBB\u0002_\\xBD\u0002\\`\\xBF\u0002a\\xC1\u0002b\\xC3\u0002c\\xC5\u0002d\\xC7\u0002e\\xC9\u0002f\\xCB\u0002g\\xCD\u0002h\\xCF\u0002i\\xD1\u0002j\\xD3\u0002\u0002\\xD5\u0002k\\xD7\u0002\u0002\\xD9\u0002l\\xDB\u0002m\\xDD\u0002\u0002\\xDF\u0002\u0002\\xE1\u0002n\\xE3\u0002o\\xE5\u0002p\\xE7\u0002q\\xE9\u0002r\\xEB\u0002s\\xED\u0002t\\xEF\u0002u\\xF1\u0002v\\xF3\u0002w\\xF5\u0002x\\xF7\u0002y\\xF9\u0002z\\xFB\u0002{\\xFD\u0002|\\xFF\u0002}\\u0101\u0002~\\u0103\u0002\\x7F\\u0105\u0002\\x80\\u0107\u0002\\x81\\u0109\u0002\\x82\\u010B\u0002\\x83\\u010D\u0002\u0002\\u010F\u0002\u0002\\u0111\u0002\\x84\\u0113\u0002\u0002\\u0115\u0002\u0002\\u0117\u0002\\x85\\u0119\u0002\\x86\\u011B\u0002\\x87\\u011D\u0002\\x88\u0003\u0002\\f\u0003\u00022;\u0004\u0002GGgg\u0004\u0002ZZzz\u0005\u00022;CHch\u0006\u0002&&C\\\\aac|\\x07\u0002&&2;C\\\\aac|\u0006\u0002\\f\\f\u000f\u000f$$^^\u0006\u0002\\f\\f\u000f\u000f))^^\u0005\u0002\\v\\f\u000e\u000f\"\"\u0004\u0002\\f\\f\u000f\u000f\u0002\\u07E8\u0002\u0003\u0003\u0002\u0002\u0002\u0002\u0005\u0003\u0002\u0002\u0002\u0002\\x07\u0003\u0002\u0002\u0002\u0002\t\u0003\u0002\u0002\u0002\u0002\\v\u0003\u0002\u0002\u0002\u0002\\r\u0003\u0002\u0002\u0002\u0002\u000f\u0003\u0002\u0002\u0002\u0002\u0011\u0003\u0002\u0002\u0002\u0002\u0013\u0003\u0002\u0002\u0002\u0002\u0015\u0003\u0002\u0002\u0002\u0002\u0017\u0003\u0002\u0002\u0002\u0002\u0019\u0003\u0002\u0002\u0002\u0002\u001b\u0003\u0002\u0002\u0002\u0002\u001d\u0003\u0002\u0002\u0002\u0002\u001f\u0003\u0002\u0002\u0002\u0002!\u0003\u0002\u0002\u0002\u0002#\u0003\u0002\u0002\u0002\u0002%\u0003\u0002\u0002\u0002\u0002'\u0003\u0002\u0002\u0002\u0002)\u0003\u0002\u0002\u0002\u0002+\u0003\u0002\u0002\u0002\u0002-\u0003\u0002\u0002\u0002\u0002/\u0003\u0002\u0002\u0002\u00021\u0003\u0002\u0002\u0002\u00023\u0003\u0002\u0002\u0002\u00025\u0003\u0002\u0002\u0002\u00027\u0003\u0002\u0002\u0002\u00029\u0003\u0002\u0002\u0002\u0002;\u0003\u0002\u0002\u0002\u0002=\u0003\u0002\u0002\u0002\u0002?\u0003\u0002\u0002\u0002\u0002A\u0003\u0002\u0002\u0002\u0002C\u0003\u0002\u0002\u0002\u0002E\u0003\u0002\u0002\u0002\u0002G\u0003\u0002\u0002\u0002\u0002I\u0003\u0002\u0002\u0002\u0002K\u0003\u0002\u0002\u0002\u0002M\u0003\u0002\u0002\u0002\u0002O\u0003\u0002\u0002\u0002\u0002Q\u0003\u0002\u0002\u0002\u0002S\u0003\u0002\u0002\u0002\u0002U\u0003\u0002\u0002\u0002\u0002W\u0003\u0002\u0002\u0002\u0002Y\u0003\u0002\u0002\u0002\u0002[\u0003\u0002\u0002\u0002\u0002]\u0003\u0002\u0002\u0002\u0002_\u0003\u0002\u0002\u0002\u0002a\u0003\u0002\u0002\u0002\u0002c\u0003\u0002\u0002\u0002\u0002e\u0003\u0002\u0002\u0002\u0002g\u0003\u0002\u0002\u0002\u0002i\u0003\u0002\u0002\u0002\u0002k\u0003\u0002\u0002\u0002\u0002m\u0003\u0002\u0002\u0002\u0002o\u0003\u0002\u0002\u0002\u0002q\u0003\u0002\u0002\u0002\u0002s\u0003\u0002\u0002\u0002\u0002u\u0003\u0002\u0002\u0002\u0002w\u0003\u0002\u0002\u0002\u0002y\u0003\u0002\u0002\u0002\u0002{\u0003\u0002\u0002\u0002\u0002}\u0003\u0002\u0002\u0002\u0002\\x7F\u0003\u0002\u0002\u0002\u0002\\x81\u0003\u0002\u0002\u0002\u0002\\x83\u0003\u0002\u0002\u0002\u0002\\x85\u0003\u0002\u0002\u0002\u0002\\x87\u0003\u0002\u0002\u0002\u0002\\x89\u0003\u0002\u0002\u0002\u0002\\x8B\u0003\u0002\u0002\u0002\u0002\\x8D\u0003\u0002\u0002\u0002\u0002\\x8F\u0003\u0002\u0002\u0002\u0002\\x91\u0003\u0002\u0002\u0002\u0002\\x93\u0003\u0002\u0002\u0002\u0002\\x95\u0003\u0002\u0002\u0002\u0002\\x97\u0003\u0002\u0002\u0002\u0002\\x99\u0003\u0002\u0002\u0002\u0002\\x9B\u0003\u0002\u0002\u0002\u0002\\x9D\u0003\u0002\u0002\u0002\u0002\\x9F\u0003\u0002\u0002\u0002\u0002\\xA1\u0003\u0002\u0002\u0002\u0002\\xA3\u0003\u0002\u0002\u0002\u0002\\xA5\u0003\u0002\u0002\u0002\u0002\\xA7\u0003\u0002\u0002\u0002\u0002\\xA9\u0003\u0002\u0002\u0002\u0002\\xAB\u0003\u0002\u0002\u0002\u0002\\xAD\u0003\u0002\u0002\u0002\u0002\\xAF\u0003\u0002\u0002\u0002\u0002\\xB1\u0003\u0002\u0002\u0002\u0002\\xB3\u0003\u0002\u0002\u0002\u0002\\xB5\u0003\u0002\u0002\u0002\u0002\\xB7\u0003\u0002\u0002\u0002\u0002\\xB9\u0003\u0002\u0002\u0002\u0002\\xBB\u0003\u0002\u0002\u0002\u0002\\xBD\u0003\u0002\u0002\u0002\u0002\\xBF\u0003\u0002\u0002\u0002\u0002\\xC1\u0003\u0002\u0002\u0002\u0002\\xC3\u0003\u0002\u0002\u0002\u0002\\xC5\u0003\u0002\u0002\u0002\u0002\\xC7\u0003\u0002\u0002\u0002\u0002\\xC9\u0003\u0002\u0002\u0002\u0002\\xCB\u0003\u0002\u0002\u0002\u0002\\xCD\u0003\u0002\u0002\u0002\u0002\\xCF\u0003\u0002\u0002\u0002\u0002\\xD1\u0003\u0002\u0002\u0002\u0002\\xD5\u0003\u0002\u0002\u0002\u0002\\xD9\u0003\u0002\u0002\u0002\u0002\\xDB\u0003\u0002\u0002\u0002\u0002\\xE1\u0003\u0002\u0002\u0002\u0002\\xE3\u0003\u0002\u0002\u0002\u0002\\xE5\u0003\u0002\u0002\u0002\u0002\\xE7\u0003\u0002\u0002\u0002`;\nSolidityLexer._serializedATNSegment1 = \"\u0002\\xE9\u0003\u0002\u0002\u0002\u0002\\xEB\u0003\u0002\u0002\u0002\u0002\\xED\u0003\u0002\u0002\u0002\u0002\\xEF\u0003\u0002\u0002\u0002\u0002\\xF1\u0003\u0002\u0002\u0002\u0002\\xF3\u0003\u0002\u0002\u0002\u0002\\xF5\u0003\u0002\u0002\u0002\u0002\\xF7\u0003\u0002\u0002\u0002\u0002\\xF9\u0003\u0002\u0002\u0002\u0002\\xFB\u0003\u0002\u0002\u0002\u0002\\xFD\u0003\u0002\u0002\u0002\u0002\\xFF\u0003\u0002\u0002\u0002\u0002\\u0101\u0003\u0002\u0002\u0002\u0002\\u0103\u0003\u0002\u0002\u0002\u0002\\u0105\u0003\u0002\u0002\u0002\u0002\\u0107\u0003\u0002\u0002\u0002\u0002\\u0109\u0003\u0002\u0002\u0002\u0002\\u010B\u0003\u0002\u0002\u0002\u0002\\u0111\u0003\u0002\u0002\u0002\u0002\\u0117\u0003\u0002\u0002\u0002\u0002\\u0119\u0003\u0002\u0002\u0002\u0002\\u011B\u0003\u0002\u0002\u0002\u0002\\u011D\u0003\u0002\u0002\u0002\u0003\\u011F\u0003\u0002\u0002\u0002\u0005\\u0126\u0003\u0002\u0002\u0002\\x07\\u0128\u0003\u0002\u0002\u0002\t\\u012A\u0003\u0002\u0002\u0002\\v\\u012D\u0003\u0002\u0002\u0002\\r\\u012F\u0003\u0002\u0002\u0002\u000f\\u0131\u0003\u0002\u0002\u0002\u0011\\u0134\u0003\u0002\u0002\u0002\u0013\\u0136\u0003\u0002\u0002\u0002\u0015\\u0138\u0003\u0002\u0002\u0002\u0017\\u013B\u0003\u0002\u0002\u0002\u0019\\u013D\u0003\u0002\u0002\u0002\u001b\\u0140\u0003\u0002\u0002\u0002\u001d\\u0147\u0003\u0002\u0002\u0002\u001f\\u014C\u0003\u0002\u0002\u0002!\\u014E\u0003\u0002\u0002\u0002#\\u0150\u0003\u0002\u0002\u0002%\\u0152\u0003\u0002\u0002\u0002'\\u015B\u0003\u0002\u0002\u0002)\\u0164\u0003\u0002\u0002\u0002+\\u016E\u0003\u0002\u0002\u0002-\\u0176\u0003\u0002\u0002\u0002/\\u0179\u0003\u0002\u0002\u00021\\u017B\u0003\u0002\u0002\u00023\\u017D\u0003\u0002\u0002\u00025\\u0183\u0003\u0002\u0002\u00027\\u0189\u0003\u0002\u0002\u00029\\u018D\u0003\u0002\u0002\u0002;\\u0194\u0003\u0002\u0002\u0002=\\u019D\u0003\u0002\u0002\u0002?\\u01A6\u0003\u0002\u0002\u0002A\\u01AE\u0003\u0002\u0002\u0002C\\u01B4\u0003\u0002\u0002\u0002E\\u01B9\u0003\u0002\u0002\u0002G\\u01BB\u0003\u0002\u0002\u0002I\\u01BD\u0003\u0002\u0002\u0002K\\u01C5\u0003\u0002\u0002\u0002M\\u01C7\u0003\u0002\u0002\u0002O\\u01CF\u0003\u0002\u0002\u0002Q\\u01D2\u0003\u0002\u0002\u0002S\\u01D9\u0003\u0002\u0002\u0002U\\u01E1\u0003\u0002\u0002\u0002W\\u01EA\u0003\u0002\u0002\u0002Y\\u01ED\u0003\u0002\u0002\u0002[\\u01F2\u0003\u0002\u0002\u0002]\\u01F6\u0003\u0002\u0002\u0002_\\u01FC\u0003\u0002\u0002\u0002a\\u0202\u0003\u0002\u0002\u0002c\\u020C\u0003\u0002\u0002\u0002e\\u0215\u0003\u0002\u0002\u0002g\\u0218\u0003\u0002\u0002\u0002i\\u021F\u0003\u0002\u0002\u0002k\\u0225\u0003\u0002\u0002\u0002m\\u022A\u0003\u0002\u0002\u0002o\\u0231\u0003\u0002\u0002\u0002q\\u0235\u0003\u0002\u0002\u0002s\\u023A\u0003\u0002\u0002\u0002u\\u0241\u0003\u0002\u0002\u0002w\\u0246\u0003\u0002\u0002\u0002y\\u0249\u0003\u0002\u0002\u0002{\\u024C\u0003\u0002\u0002\u0002}\\u0250\u0003\u0002\u0002\u0002\\x7F\\u0252\u0003\u0002\u0002\u0002\\x81\\u0254\u0003\u0002\u0002\u0002\\x83\\u0256\u0003\u0002\u0002\u0002\\x85\\u025C\u0003\u0002\u0002\u0002\\x87\\u0263\u0003\u0002\u0002\u0002\\x89\\u0265\u0003\u0002\u0002\u0002\\x8B\\u0268\u0003\u0002\u0002\u0002\\x8D\\u026A\u0003\u0002\u0002\u0002\\x8F\\u026C\u0003\u0002\u0002\u0002\\x91\\u026F\u0003\u0002\u0002\u0002\\x93\\u0272\u0003\u0002\u0002\u0002\\x95\\u0274\u0003\u0002\u0002\u0002\\x97\\u0276\u0003\u0002\u0002\u0002\\x99\\u0279\u0003\u0002\u0002\u0002\\x9B\\u027C\u0003\u0002\u0002\u0002\\x9D\\u027F\u0003\u0002\u0002\u0002\\x9F\\u0281\u0003\u0002\u0002\u0002\\xA1\\u0284\u0003\u0002\u0002\u0002\\xA3\\u0287\u0003\u0002\u0002\u0002\\xA5\\u028A\u0003\u0002\u0002\u0002\\xA7\\u028E\u0003\u0002\u0002\u0002\\xA9\\u0292\u0003\u0002\u0002\u0002\\xAB\\u0295\u0003\u0002\u0002\u0002\\xAD\\u0298\u0003\u0002\u0002\u0002\\xAF\\u029B\u0003\u0002\u0002\u0002\\xB1\\u029E\u0003\u0002\u0002\u0002\\xB3\\u02A1\u0003\u0002\u0002\u0002\\xB5\\u02A5\u0003\u0002\u0002\u0002\\xB7\\u02A8\u0003\u0002\u0002\u0002\\xB9\\u02AB\u0003\u0002\u0002\u0002\\xBB\\u02B2\u0003\u0002\u0002\u0002\\xBD\\u02B7\u0003\u0002\u0002\u0002\\xBF\\u02BF\u0003\u0002\u0002\u0002\\xC1\\u02C2\u0003\u0002\u0002\u0002\\xC3\\u02CB\u0003\u0002\u0002\u0002\\xC5\\u038A\u0003\u0002\u0002\u0002\\xC7\\u0463\u0003\u0002\u0002\u0002\\xC9\\u0541\u0003\u0002\u0002\u0002\\xCB\\u0559\u0003\u0002\u0002\u0002\\xCD\\u0573\u0003\u0002\u0002\u0002\\xCF\\u057E\u0003\u0002\u0002\u0002\\xD1\\u0586\u0003\u0002\u0002\u0002\\xD3\\u058C\u0003\u0002\u0002\u0002\\xD5\\u0596\u0003\u0002\u0002\u0002\\xD7\\u059A\u0003\u0002\u0002\u0002\\xD9\\u05DC\u0003\u0002\u0002\u0002\\xDB\\u05DE\u0003\u0002\u0002\u0002\\xDD\\u05EE\u0003\u0002\u0002\u0002\\xDF\\u05F1\u0003\u0002\u0002\u0002\\xE1\\u064B\u0003\u0002\u0002\u0002\\xE3\\u064D\u0003\u0002\u0002\u0002\\xE5\\u0657\u0003\u0002\u0002\u0002\\xE7\\u065D\u0003\u0002\u0002\u0002\\xE9\\u0666\u0003\u0002\u0002\u0002\\xEB\\u0670\u0003\u0002\u0002\u0002\\xED\\u0679\u0003\u0002\u0002\u0002\\xEF\\u067F\u0003\u0002\u0002\u0002\\xF1\\u0688\u0003\u0002\u0002\u0002\\xF3\\u0690\u0003\u0002\u0002\u0002\\xF5\\u0699\u0003\u0002\u0002\u0002\\xF7\\u06A1\u0003\u0002\u0002\u0002\\xF9\\u06A9\u0003\u0002\u0002\u0002\\xFB\\u06B0\u0003\u0002\u0002\u0002\\xFD\\u06B8\u0003\u0002\u0002\u0002\\xFF\\u06BD\u0003\u0002\u0002\u0002\\u0101\\u06C2\u0003\u0002\u0002\u0002\\u0103\\u06C7\u0003\u0002\u0002\u0002\\u0105\\u06CE\u0003\u0002\u0002\u0002\\u0107\\u06DA\u0003\u0002\u0002\u0002\\u0109\\u06E3\u0003\u0002\u0002\u0002\\u010B\\u06EB\u0003\u0002\u0002\u0002\\u010D\\u06F2\u0003\u0002\u0002\u0002\\u010F\\u06F4\u0003\u0002\u0002\u0002\\u0111\\u0718\u0003\u0002\u0002\u0002\\u0113\\u071D\u0003\u0002\u0002\u0002\\u0115\\u0722\u0003\u0002\u0002\u0002\\u0117\\u0725\u0003\u0002\u0002\u0002\\u0119\\u0738\u0003\u0002\u0002\u0002\\u011B\\u073E\u0003\u0002\u0002\u0002\\u011D\\u074C\u0003\u0002\u0002\u0002\\u011F\\u0120\\x07r\u0002\u0002\\u0120\\u0121\\x07t\u0002\u0002\\u0121\\u0122\\x07c\u0002\u0002\\u0122\\u0123\\x07i\u0002\u0002\\u0123\\u0124\\x07o\u0002\u0002\\u0124\\u0125\\x07c\u0002\u0002\\u0125\u0004\u0003\u0002\u0002\u0002\\u0126\\u0127\\x07=\u0002\u0002\\u0127\u0006\u0003\u0002\u0002\u0002\\u0128\\u0129\\x07,\u0002\u0002\\u0129\\b\u0003\u0002\u0002\u0002\\u012A\\u012B\\x07~\u0002\u0002\\u012B\\u012C\\x07~\u0002\u0002\\u012C\\n\u0003\u0002\u0002\u0002\\u012D\\u012E\\x07`\u0002\u0002\\u012E\\f\u0003\u0002\u0002\u0002\\u012F\\u0130\\x07\\x80\u0002\u0002\\u0130\u000e\u0003\u0002\u0002\u0002\\u0131\\u0132\\x07@\u0002\u0002\\u0132\\u0133\\x07?\u0002\u0002\\u0133\u0010\u0003\u0002\u0002\u0002\\u0134\\u0135\\x07@\u0002\u0002\\u0135\u0012\u0003\u0002\u0002\u0002\\u0136\\u0137\\x07>\u0002\u0002\\u0137\u0014\u0003\u0002\u0002\u0002\\u0138\\u0139\\x07>\u0002\u0002\\u0139\\u013A\\x07?\u0002\u0002\\u013A\u0016\u0003\u0002\u0002\u0002\\u013B\\u013C\\x07?\u0002\u0002\\u013C\u0018\u0003\u0002\u0002\u0002\\u013D\\u013E\\x07c\u0002\u0002\\u013E\\u013F\\x07u\u0002\u0002\\u013F\u001a\u0003\u0002\u0002\u0002\\u0140\\u0141\\x07k\u0002\u0002\\u0141\\u0142\\x07o\u0002\u0002\\u0142\\u0143\\x07r\u0002\u0002\\u0143\\u0144\\x07q\u0002\u0002\\u0144\\u0145\\x07t\u0002\u0002\\u0145\\u0146\\x07v\u0002\u0002\\u0146\u001c\u0003\u0002\u0002\u0002\\u0147\\u0148\\x07h\u0002\u0002\\u0148\\u0149\\x07t\u0002\u0002\\u0149\\u014A\\x07q\u0002\u0002\\u014A\\u014B\\x07o\u0002\u0002\\u014B\u001e\u0003\u0002\u0002\u0002\\u014C\\u014D\\x07}\u0002\u0002\\u014D \u0003\u0002\u0002\u0002\\u014E\\u014F\\x07.\u0002\u0002\\u014F\\\"\u0003\u0002\u0002\u0002\\u0150\\u0151\\x07\\x7F\u0002\u0002\\u0151$\u0003\u0002\u0002\u0002\\u0152\\u0153\\x07c\u0002\u0002\\u0153\\u0154\\x07d\u0002\u0002\\u0154\\u0155\\x07u\u0002\u0002\\u0155\\u0156\\x07v\u0002\u0002\\u0156\\u0157\\x07t\u0002\u0002\\u0157\\u0158\\x07c\u0002\u0002\\u0158\\u0159\\x07e\u0002\u0002\\u0159\\u015A\\x07v\u0002\u0002\\u015A&\u0003\u0002\u0002\u0002\\u015B\\u015C\\x07e\u0002\u0002\\u015C\\u015D\\x07q\u0002\u0002\\u015D\\u015E\\x07p\u0002\u0002\\u015E\\u015F\\x07v\u0002\u0002\\u015F\\u0160\\x07t\u0002\u0002\\u0160\\u0161\\x07c\u0002\u0002\\u0161\\u0162\\x07e\u0002\u0002\\u0162\\u0163\\x07v\u0002\u0002\\u0163(\u0003\u0002\u0002\u0002\\u0164\\u0165\\x07k\u0002\u0002\\u0165\\u0166\\x07p\u0002\u0002\\u0166\\u0167\\x07v\u0002\u0002\\u0167\\u0168\\x07g\u0002\u0002\\u0168\\u0169\\x07t\u0002\u0002\\u0169\\u016A\\x07h\u0002\u0002\\u016A\\u016B\\x07c\u0002\u0002\\u016B\\u016C\\x07e\u0002\u0002\\u016C\\u016D\\x07g\u0002\u0002\\u016D*\u0003\u0002\u0002\u0002\\u016E\\u016F\\x07n\u0002\u0002\\u016F\\u0170\\x07k\u0002\u0002\\u0170\\u0171\\x07d\u0002\u0002\\u0171\\u0172\\x07t\u0002\u0002\\u0172\\u0173\\x07c\u0002\u0002\\u0173\\u0174\\x07t\u0002\u0002\\u0174\\u0175\\x07{\u0002\u0002\\u0175,\u0003\u0002\u0002\u0002\\u0176\\u0177\\x07k\u0002\u0002\\u0177\\u0178\\x07u\u0002\u0002\\u0178.\u0003\u0002\u0002\u0002\\u0179\\u017A\\x07*\u0002\u0002\\u017A0\u0003\u0002\u0002\u0002\\u017B\\u017C\\x07+\u0002\u0002\\u017C2\u0003\u0002\u0002\u0002\\u017D\\u017E\\x07g\u0002\u0002\\u017E\\u017F\\x07t\u0002\u0002\\u017F\\u0180\\x07t\u0002\u0002\\u0180\\u0181\\x07q\u0002\u0002\\u0181\\u0182\\x07t\u0002\u0002\\u01824\u0003\u0002\u0002\u0002\\u0183\\u0184\\x07w\u0002\u0002\\u0184\\u0185\\x07u\u0002\u0002\\u0185\\u0186\\x07k\u0002\u0002\\u0186\\u0187\\x07p\u0002\u0002\\u0187\\u0188\\x07i\u0002\u0002\\u01886\u0003\u0002\u0002\u0002\\u0189\\u018A\\x07h\u0002\u0002\\u018A\\u018B\\x07q\u0002\u0002\\u018B\\u018C\\x07t\u0002\u0002\\u018C8\u0003\u0002\u0002\u0002\\u018D\\u018E\\x07u\u0002\u0002\\u018E\\u018F\\x07v\u0002\u0002\\u018F\\u0190\\x07t\u0002\u0002\\u0190\\u0191\\x07w\u0002\u0002\\u0191\\u0192\\x07e\u0002\u0002\\u0192\\u0193\\x07v\u0002\u0002\\u0193:\u0003\u0002\u0002\u0002\\u0194\\u0195\\x07o\u0002\u0002\\u0195\\u0196\\x07q\u0002\u0002\\u0196\\u0197\\x07f\u0002\u0002\\u0197\\u0198\\x07k\u0002\u0002\\u0198\\u0199\\x07h\u0002\u0002\\u0199\\u019A\\x07k\u0002\u0002\\u019A\\u019B\\x07g\u0002\u0002\\u019B\\u019C\\x07t\u0002\u0002\\u019C<\u0003\u0002\u0002\u0002\\u019D\\u019E\\x07h\u0002\u0002\\u019E\\u019F\\x07w\u0002\u0002\\u019F\\u01A0\\x07p\u0002\u0002\\u01A0\\u01A1\\x07e\u0002\u0002\\u01A1\\u01A2\\x07v\u0002\u0002\\u01A2\\u01A3\\x07k\u0002\u0002\\u01A3\\u01A4\\x07q\u0002\u0002\\u01A4\\u01A5\\x07p\u0002\u0002\\u01A5>\u0003\u0002\u0002\u0002\\u01A6\\u01A7\\x07t\u0002\u0002\\u01A7\\u01A8\\x07g\u0002\u0002\\u01A8\\u01A9\\x07v\u0002\u0002\\u01A9\\u01AA\\x07w\u0002\u0002\\u01AA\\u01AB\\x07t\u0002\u0002\\u01AB\\u01AC\\x07p\u0002\u0002\\u01AC\\u01AD\\x07u\u0002\u0002\\u01AD@\u0003\u0002\u0002\u0002\\u01AE\\u01AF\\x07g\u0002\u0002\\u01AF\\u01B0\\x07x\u0002\u0002\\u01B0\\u01B1\\x07g\u0002\u0002\\u01B1\\u01B2\\x07p\u0002\u0002\\u01B2\\u01B3\\x07v\u0002\u0002\\u01B3B\u0003\u0002\u0002\u0002\\u01B4\\u01B5\\x07g\u0002\u0002\\u01B5\\u01B6\\x07p\u0002\u0002\\u01B6\\u01B7\\x07w\u0002\u0002\\u01B7\\u01B8\\x07o\u0002\u0002\\u01B8D\u0003\u0002\u0002\u0002\\u01B9\\u01BA\\x07]\u0002\u0002\\u01BAF\u0003\u0002\u0002\u0002\\u01BB\\u01BC\\x07_\u0002\u0002\\u01BCH\u0003\u0002\u0002\u0002\\u01BD\\u01BE\\x07c\u0002\u0002\\u01BE\\u01BF\\x07f\u0002\u0002\\u01BF\\u01C0\\x07f\u0002\u0002\\u01C0\\u01C1\\x07t\u0002\u0002\\u01C1\\u01C2\\x07g\u0002\u0002\\u01C2\\u01C3\\x07u\u0002\u0002\\u01C3\\u01C4\\x07u\u0002\u0002\\u01C4J\u0003\u0002\u0002\u0002\\u01C5\\u01C6\\x070\u0002\u0002\\u01C6L\u0003\u0002\u0002\u0002\\u01C7\\u01C8\\x07o\u0002\u0002\\u01C8\\u01C9\\x07c\u0002\u0002\\u01C9\\u01CA\\x07r\u0002\u0002\\u01CA\\u01CB\\x07r\u0002\u0002\\u01CB\\u01CC\\x07k\u0002\u0002\\u01CC\\u01CD\\x07p\u0002\u0002\\u01CD\\u01CE\\x07i\u0002\u0002\\u01CEN\u0003\u0002\u0002\u0002\\u01CF\\u01D0\\x07?\u0002\u0002\\u01D0\\u01D1\\x07@\u0002\u0002\\u01D1P\u0003\u0002\u0002\u0002\\u01D2\\u01D3\\x07o\u0002\u0002\\u01D3\\u01D4\\x07g\u0002\u0002\\u01D4\\u01D5\\x07o\u0002\u0002\\u01D5\\u01D6\\x07q\u0002\u0002\\u01D6\\u01D7\\x07t\u0002\u0002\\u01D7\\u01D8\\x07{\u0002\u0002\\u01D8R\u0003\u0002\u0002\u0002\\u01D9\\u01DA\\x07u\u0002\u0002\\u01DA\\u01DB\\x07v\u0002\u0002\\u01DB\\u01DC\\x07q\u0002\u0002\\u01DC\\u01DD\\x07t\u0002\u0002\\u01DD\\u01DE\\x07c\u0002\u0002\\u01DE\\u01DF\\x07i\u0002\u0002\\u01DF\\u01E0\\x07g\u0002\u0002\\u01E0T\u0003\u0002\u0002\u0002\\u01E1\\u01E2\\x07e\u0002\u0002\\u01E2\\u01E3\\x07c\u0002\u0002\\u01E3\\u01E4\\x07n\u0002\u0002\\u01E4\\u01E5\\x07n\u0002\u0002\\u01E5\\u01E6\\x07f\u0002\u0002\\u01E6\\u01E7\\x07c\u0002\u0002\\u01E7\\u01E8\\x07v\u0002\u0002\\u01E8\\u01E9\\x07c\u0002\u0002\\u01E9V\u0003\u0002\u0002\u0002\\u01EA\\u01EB\\x07k\u0002\u0002\\u01EB\\u01EC\\x07h\u0002\u0002\\u01ECX\u0003\u0002\u0002\u0002\\u01ED\\u01EE\\x07g\u0002\u0002\\u01EE\\u01EF\\x07n\u0002\u0002\\u01EF\\u01F0\\x07u\u0002\u0002\\u01F0\\u01F1\\x07g\u0002\u0002\\u01F1Z\u0003\u0002\u0002\u0002\\u01F2\\u01F3\\x07v\u0002\u0002\\u01F3\\u01F4\\x07t\u0002\u0002\\u01F4\\u01F5\\x07{\u0002\u0002\\u01F5\\\\\u0003\u0002\u0002\u0002\\u01F6\\u01F7\\x07e\u0002\u0002\\u01F7\\u01F8\\x07c\u0002\u0002\\u01F8\\u01F9\\x07v\u0002\u0002\\u01F9\\u01FA\\x07e\u0002\u0002\\u01FA\\u01FB\\x07j\u0002\u0002\\u01FB^\u0003\u0002\u0002\u0002\\u01FC\\u01FD\\x07y\u0002\u0002\\u01FD\\u01FE\\x07j\u0002\u0002\\u01FE\\u01FF\\x07k\u0002\u0002\\u01FF\\u0200\\x07n\u0002\u0002\\u0200\\u0201\\x07g\u0002\u0002\\u0201`\u0003\u0002\u0002\u0002\\u0202\\u0203\\x07w\u0002\u0002\\u0203\\u0204\\x07p\u0002\u0002\\u0204\\u0205\\x07e\u0002\u0002\\u0205\\u0206\\x07j\u0002\u0002\\u0206\\u0207\\x07g\u0002\u0002\\u0207\\u0208\\x07e\u0002\u0002\\u0208\\u0209\\x07m\u0002\u0002\\u0209\\u020A\\x07g\u0002\u0002\\u020A\\u020B\\x07f\u0002\u0002\\u020Bb\u0003\u0002\u0002\u0002\\u020C\\u020D\\x07c\u0002\u0002\\u020D\\u020E\\x07u\u0002\u0002\\u020E\\u020F\\x07u\u0002\u0002\\u020F\\u0210\\x07g\u0002\u0002\\u0210\\u0211\\x07o\u0002\u0002\\u0211\\u0212\\x07d\u0002\u0002\\u0212\\u0213\\x07n\u0002\u0002\\u0213\\u0214\\x07{\u0002\u0002\\u0214d\u0003\u0002\u0002\u0002\\u0215\\u0216\\x07f\u0002\u0002\\u0216\\u0217\\x07q\u0002\u0002\\u0217f\u0003\u0002\u0002\u0002\\u0218\\u0219\\x07t\u0002\u0002\\u0219\\u021A\\x07g\u0002\u0002\\u021A\\u021B\\x07v\u0002\u0002\\u021B\\u021C\\x07w\u0002\u0002\\u021C\\u021D\\x07t\u0002\u0002\\u021D\\u021E\\x07p\u0002\u0002\\u021Eh\u0003\u0002\u0002\u0002\\u021F\\u0220\\x07v\u0002\u0002\\u0220\\u0221\\x07j\u0002\u0002\\u0221\\u0222\\x07t\u0002\u0002\\u0222\\u0223\\x07q\u0002\u0002\\u0223\\u0224\\x07y\u0002\u0002\\u0224j\u0003\u0002\u0002\u0002\\u0225\\u0226\\x07g\u0002\u0002\\u0226\\u0227\\x07o\u0002\u0002\\u0227\\u0228\\x07k\u0002\u0002\\u0228\\u0229\\x07v\u0002\u0002\\u0229l\u0003\u0002\u0002\u0002\\u022A\\u022B\\x07t\u0002\u0002\\u022B\\u022C\\x07g\u0002\u0002\\u022C\\u022D\\x07x\u0002\u0002\\u022D\\u022E\\x07g\u0002\u0002\\u022E\\u022F\\x07t\u0002\u0002\\u022F\\u0230\\x07v\u0002\u0002\\u0230n\u0003\u0002\u0002\u0002\\u0231\\u0232\\x07x\u0002\u0002\\u0232\\u0233\\x07c\u0002\u0002\\u0233\\u0234\\x07t\u0002\u0002\\u0234p\u0003\u0002\u0002\u0002\\u0235\\u0236\\x07d\u0002\u0002\\u0236\\u0237\\x07q\u0002\u0002\\u0237\\u0238\\x07q\u0002\u0002\\u0238\\u0239\\x07n\u0002\u0002\\u0239r\u0003\u0002\u0002\u0002\\u023A\\u023B\\x07u\u0002\u0002\\u023B\\u023C\\x07v\u0002\u0002\\u023C\\u023D\\x07t\u0002\u0002\\u023D\\u023E\\x07k\u0002\u0002\\u023E\\u023F\\x07p\u0002\u0002\\u023F\\u0240\\x07i\u0002\u0002\\u0240t\u0003\u0002\u0002\u0002\\u0241\\u0242\\x07d\u0002\u0002\\u0242\\u0243\\x07{\u0002\u0002\\u0243\\u0244\\x07v\u0002\u0002\\u0244\\u0245\\x07g\u0002\u0002\\u0245v\u0003\u0002\u0002\u0002\\u0246\\u0247\\x07-\u0002\u0002\\u0247\\u0248\\x07-\u0002\u0002\\u0248x\u0003\u0002\u0002\u0002\\u0249\\u024A\\x07/\u0002\u0002\\u024A\\u024B\\x07/\u0002\u0002\\u024Bz\u0003\u0002\u0002\u0002\\u024C\\u024D\\x07p\u0002\u0002\\u024D\\u024E\\x07g\u0002\u0002\\u024E\\u024F\\x07y\u0002\u0002\\u024F|\u0003\u0002\u0002\u0002\\u0250\\u0251\\x07<\u0002\u0002\\u0251~\u0003\u0002\u0002\u0002\\u0252\\u0253\\x07-\u0002\u0002\\u0253\\x80\u0003\u0002\u0002\u0002\\u0254\\u0255\\x07/\u0002\u0002\\u0255\\x82\u0003\u0002\u0002\u0002\\u0256\\u0257\\x07c\u0002\u0002\\u0257\\u0258\\x07h\u0002\u0002\\u0258\\u0259\\x07v\u0002\u0002\\u0259\\u025A\\x07g\u0002\u0002\\u025A\\u025B\\x07t\u0002\u0002\\u025B\\x84\u0003\u0002\u0002\u0002\\u025C\\u025D\\x07f\u0002\u0002\\u025D\\u025E\\x07g\u0002\u0002\\u025E\\u025F\\x07n\u0002\u0002\\u025F\\u0260\\x07g\u0002\u0002\\u0260\\u0261\\x07v\u0002\u0002\\u0261\\u0262\\x07g\u0002\u0002\\u0262\\x86\u0003\u0002\u0002\u0002\\u0263\\u0264\\x07#\u0002\u0002\\u0264\\x88\u0003\u0002\u0002\u0002\\u0265\\u0266\\x07,\u0002\u0002\\u0266\\u0267\\x07,\u0002\u0002\\u0267\\x8A\u0003\u0002\u0002\u0002\\u0268\\u0269\\x071\u0002\u0002\\u0269\\x8C\u0003\u0002\u0002\u0002\\u026A\\u026B\\x07'\u0002\u0002\\u026B\\x8E\u0003\u0002\u0002\u0002\\u026C\\u026D\\x07>\u0002\u0002\\u026D\\u026E\\x07>\u0002\u0002\\u026E\\x90\u0003\u0002\u0002\u0002\\u026F\\u0270\\x07@\u0002\u0002\\u0270\\u0271\\x07@\u0002\u0002\\u0271\\x92\u0003\u0002\u0002\u0002\\u0272\\u0273\\x07(\u0002\u0002\\u0273\\x94\u0003\u0002\u0002\u0002\\u0274\\u0275\\x07~\u0002\u0002\\u0275\\x96\u0003\u0002\u0002\u0002\\u0276\\u0277\\x07?\u0002\u0002\\u0277\\u0278\\x07?\u0002\u0002\\u0278\\x98\u0003\u0002\u0002\u0002\\u0279\\u027A\\x07#\u0002\u0002\\u027A\\u027B\\x07?\u0002\u0002\\u027B\\x9A\u0003\u0002\u0002\u0002\\u027C\\u027D\\x07(\u0002\u0002\\u027D\\u027E\\x07(\u0002\u0002\\u027E\\x9C\u0003\u0002\u0002\u0002\\u027F\\u0280\\x07A\u0002\u0002\\u0280\\x9E\u0003\u0002\u0002\u0002\\u0281\\u0282\\x07~\u0002\u0002\\u0282\\u0283\\x07?\u0002\u0002\\u0283\\xA0\u0003\u0002\u0002\u0002\\u0284\\u0285\\x07`\u0002\u0002\\u0285\\u0286\\x07?\u0002\u0002\\u0286\\xA2\u0003\u0002\u0002\u0002\\u0287\\u0288\\x07(\u0002\u0002\\u0288\\u0289\\x07?\u0002\u0002\\u0289\\xA4\u0003\u0002\u0002\u0002\\u028A\\u028B\\x07>\u0002\u0002\\u028B\\u028C\\x07>\u0002\u0002\\u028C\\u028D\\x07?\u0002\u0002\\u028D\\xA6\u0003\u0002\u0002\u0002\\u028E\\u028F\\x07@\u0002\u0002\\u028F\\u0290\\x07@\u0002\u0002\\u0290\\u0291\\x07?\u0002\u0002\\u0291\\xA8\u0003\u0002\u0002\u0002\\u0292\\u0293\\x07-\u0002\u0002\\u0293\\u0294\\x07?\u0002\u0002\\u0294\\xAA\u0003\u0002\u0002\u0002\\u0295\\u0296\\x07/\u0002\u0002\\u0296\\u0297\\x07?\u0002\u0002\\u0297\\xAC\u0003\u0002\u0002\u0002\\u0298\\u0299\\x07,\u0002\u0002\\u0299\\u029A\\x07?\u0002\u0002\\u029A\\xAE\u0003\u0002\u0002\u0002\\u029B\\u029C\\x071\u0002\u0002\\u029C\\u029D\\x07?\u0002\u0002\\u029D\\xB0\u0003\u0002\u0002\u0002\\u029E\\u029F\\x07'\u0002\u0002\\u029F\\u02A0\\x07?\u0002\u0002\\u02A0\\xB2\u0003\u0002\u0002\u0002\\u02A1\\u02A2\\x07n\u0002\u0002\\u02A2\\u02A3\\x07g\u0002\u0002\\u02A3\\u02A4\\x07v\u0002\u0002\\u02A4\\xB4\u0003\u0002\u0002\u0002\\u02A5\\u02A6\\x07<\u0002\u0002\\u02A6\\u02A7\\x07?\u0002\u0002\\u02A7\\xB6\u0003\u0002\u0002\u0002\\u02A8\\u02A9\\x07?\u0002\u0002\\u02A9\\u02AA\\x07<\u0002\u0002\\u02AA\\xB8\u0003\u0002\u0002\u0002\\u02AB\\u02AC\\x07u\u0002\u0002\\u02AC\\u02AD\\x07y\u0002\u0002\\u02AD\\u02AE\\x07k\u0002\u0002\\u02AE\\u02AF\\x07v\u0002\u0002\\u02AF\\u02B0\\x07e\u0002\u0002\\u02B0\\u02B1\\x07j\u0002\u0002\\u02B1\\xBA\u0003\u0002\u0002\u0002\\u02B2\\u02B3\\x07e\u0002\u0002\\u02B3\\u02B4\\x07c\u0002\u0002\\u02B4\\u02B5\\x07u\u0002\u0002\\u02B5\\u02B6\\x07g\u0002\u0002\\u02B6\\xBC\u0003\u0002\u0002\u0002\\u02B7\\u02B8\\x07f\u0002\u0002\\u02B8\\u02B9\\x07g\u0002\u0002\\u02B9\\u02BA\\x07h\u0002\u0002\\u02BA\\u02BB\\x07c\u0002\u0002\\u02BB\\u02BC\\x07w\u0002\u0002\\u02BC\\u02BD\\x07n\u0002\u0002\\u02BD\\u02BE\\x07v\u0002\u0002\\u02BE\\xBE\u0003\u0002\u0002\u0002\\u02BF\\u02C0\\x07/\u0002\u0002\\u02C0\\u02C1\\x07@\u0002\u0002\\u02C1\\xC0\u0003\u0002\u0002\u0002\\u02C2\\u02C3\\x07e\u0002\u0002\\u02C3\\u02C4\\x07c\u0002\u0002\\u02C4\\u02C5\\x07n\u0002\u0002\\u02C5\\u02C6\\x07n\u0002\u0002\\u02C6\\u02C7\\x07d\u0002\u0002\\u02C7\\u02C8\\x07c\u0002\u0002\\u02C8\\u02C9\\x07e\u0002\u0002\\u02C9\\u02CA\\x07m\u0002\u0002\\u02CA\\xC2\u0003\u0002\u0002\u0002\\u02CB\\u02CC\\x07q\u0002\u0002\\u02CC\\u02CD\\x07x\u0002\u0002\\u02CD\\u02CE\\x07g\u0002\u0002\\u02CE\\u02CF\\x07t\u0002\u0002\\u02CF\\u02D0\\x07t\u0002\u0002\\u02D0\\u02D1\\x07k\u0002\u0002\\u02D1\\u02D2\\x07f\u0002\u0002\\u02D2\\u02D3\\x07g\u0002\u0002\\u02D3\\xC4\u0003\u0002\u0002\u0002\\u02D4\\u02D5\\x07k\u0002\u0002\\u02D5\\u02D6\\x07p\u0002\u0002\\u02D6\\u038B\\x07v\u0002\u0002\\u02D7\\u02D8\\x07k\u0002\u0002\\u02D8\\u02D9\\x07p\u0002\u0002\\u02D9\\u02DA\\x07v\u0002\u0002\\u02DA\\u038B\\x07:\u0002\u0002\\u02DB\\u02DC\\x07k\u0002\u0002\\u02DC\\u02DD\\x07p\u0002\u0002\\u02DD\\u02DE\\x07v\u0002\u0002\\u02DE\\u02DF\\x073\u0002\u0002\\u02DF\\u038B\\x078\u0002\u0002\\u02E0\\u02E1\\x07k\u0002\u0002\\u02E1\\u02E2\\x07p\u0002\u0002\\u02E2\\u02E3\\x07v\u0002\u0002\\u02E3\\u02E4\\x074\u0002\u0002\\u02E4\\u038B\\x076\u0002\u0002\\u02E5\\u02E6\\x07k\u0002\u0002\\u02E6\\u02E7\\x07p\u0002\u0002\\u02E7\\u02E8\\x07v\u0002\u0002\\u02E8\\u02E9\\x075\u0002\u0002\\u02E9\\u038B\\x074\u0002\u0002\\u02EA\\u02EB\\x07k\u0002\u0002\\u02EB\\u02EC\\x07p\u0002\u0002\\u02EC\\u02ED\\x07v\u0002\u0002\\u02ED\\u02EE\\x076\u0002\u0002\\u02EE\\u038B\\x072\u0002\u0002\\u02EF\\u02F0\\x07k\u0002\u0002\\u02F0\\u02F1\\x07p\u0002\u0002\\u02F1\\u02F2\\x07v\u0002\u0002\\u02F2\\u02F3\\x076\u0002\u0002\\u02F3\\u038B\\x07:\u0002\u0002\\u02F4\\u02F5\\x07k\u0002\u0002\\u02F5\\u02F6\\x07p\u0002\u0002\\u02F6\\u02F7\\x07v\u0002\u0002\\u02F7\\u02F8\\x077\u0002\u0002\\u02F8\\u038B\\x078\u0002\u0002\\u02F9\\u02FA\\x07k\u0002\u0002\\u02FA\\u02FB\\x07p\u0002\u0002\\u02FB\\u02FC\\x07v\u0002\u0002\\u02FC\\u02FD\\x078\u0002\u0002\\u02FD\\u038B\\x076\u0002\u0002\\u02FE\\u02FF\\x07k\u0002\u0002\\u02FF\\u0300\\x07p\u0002\u0002\\u0300\\u0301\\x07v\u0002\u0002\\u0301\\u0302\\x079\u0002\u0002\\u0302\\u038B\\x074\u0002\u0002\\u0303\\u0304\\x07k\u0002\u0002\\u0304\\u0305\\x07p\u0002\u0002\\u0305\\u0306\\x07v\u0002\u0002\\u0306\\u0307\\x07:\u0002\u0002\\u0307\\u038B\\x072\u0002\u0002\\u0308\\u0309\\x07k\u0002\u0002\\u0309\\u030A\\x07p\u0002\u0002\\u030A\\u030B\\x07v\u0002\u0002\\u030B\\u030C\\x07:\u0002\u0002\\u030C\\u038B\\x07:\u0002\u0002\\u030D\\u030E\\x07k\u0002\u0002\\u030E\\u030F\\x07p\u0002\u0002\\u030F\\u0310\\x07v\u0002\u0002\\u0310\\u0311\\x07;\u0002\u0002\\u0311\\u038B\\x078\u0002\u0002\\u0312\\u0313\\x07k\u0002\u0002\\u0313\\u0314\\x07p\u0002\u0002\\u0314\\u0315\\x07v\u0002\u0002\\u0315\\u0316\\x073\u0002\u0002\\u0316\\u0317\\x072\u0002\u0002\\u0317\\u038B\\x076\u0002\u0002\\u0318\\u0319\\x07k\u0002\u0002\\u0319\\u031A\\x07p\u0002\u0002\\u031A\\u031B\\x07v\u0002\u0002\\u031B\\u031C\\x073\u0002\u0002\\u031C\\u031D\\x073\u0002\u0002\\u031D\\u038B\\x074\u0002\u0002\\u031E\\u031F\\x07k\u0002\u0002\\u031F\\u0320\\x07p\u0002\u0002\\u0320\\u0321\\x07v\u0002\u0002\\u0321\\u0322\\x073\u0002\u0002\\u0322\\u0323\\x074\u0002\u0002\\u0323\\u038B\\x072\u0002\u0002\\u0324\\u0325\\x07k\u0002\u0002\\u0325\\u0326\\x07p\u0002\u0002\\u0326\\u0327\\x07v\u0002\u0002\\u0327\\u0328\\x073\u0002\u0002\\u0328\\u0329\\x074\u0002\u0002\\u0329\\u038B\\x07:\u0002\u0002\\u032A\\u032B\\x07k\u0002\u0002\\u032B\\u032C\\x07p\u0002\u0002\\u032C\\u032D\\x07v\u0002\u0002\\u032D\\u032E\\x073\u0002\u0002\\u032E\\u032F\\x075\u0002\u0002\\u032F\\u038B\\x078\u0002\u0002\\u0330\\u0331\\x07k\u0002\u0002\\u0331\\u0332\\x07p\u0002\u0002\\u0332\\u0333\\x07v\u0002\u0002\\u0333\\u0334\\x073\u0002\u0002\\u0334\\u0335\\x076\u0002\u0002\\u0335\\u038B\\x076\u0002\u0002\\u0336\\u0337\\x07k\u0002\u0002\\u0337\\u0338\\x07p\u0002\u0002\\u0338\\u0339\\x07v\u0002\u0002\\u0339\\u033A\\x073\u0002\u0002\\u033A\\u033B\\x077\u0002\u0002\\u033B\\u038B\\x074\u0002\u0002\\u033C\\u033D\\x07k\u0002\u0002\\u033D\\u033E\\x07p\u0002\u0002\\u033E\\u033F\\x07v\u0002\u0002\\u033F\\u0340\\x073\u0002\u0002\\u0340\\u0341\\x078\u0002\u0002\\u0341\\u038B\\x072\u0002\u0002\\u0342\\u0343\\x07k\u0002\u0002\\u0343\\u0344\\x07p\u0002\u0002\\u0344\\u0345\\x07v\u0002\u0002\\u0345\\u0346\\x073\u0002\u0002\\u0346\\u0347\\x078\u0002\u0002\\u0347\\u038B\\x07:\u0002\u0002\\u0348\\u0349\\x07k\u0002\u0002\\u0349\\u034A\\x07p\u0002\u0002\\u034A\\u034B\\x07v\u0002\u0002\\u034B\\u034C\\x073\u0002\u0002\\u034C\\u034D\\x079\u0002\u0002\\u034D\\u038B\\x078\u0002\u0002\\u034E\\u034F\\x07k\u0002\u0002\\u034F\\u0350\\x07p\u0002\u0002\\u0350\\u0351\\x07v\u0002\u0002\\u0351\\u0352\\x073\u0002\u0002\\u0352\\u0353\\x07:\u0002\u0002\\u0353\\u038B\\x076\u0002\u0002\\u0354\\u0355\\x07k\u0002\u0002\\u0355\\u0356\\x07p\u0002\u0002\\u0356\\u0357\\x07v\u0002\u0002\\u0357\\u0358\\x073\u0002\u0002\\u0358\\u0359\\x07;\u0002\u0002\\u0359\\u038B\\x074\u0002\u0002\\u035A\\u035B\\x07k\u0002\u0002\\u035B\\u035C\\x07p\u0002\u0002\\u035C\\u035D\\x07v\u0002\u0002\\u035D\\u035E\\x074\u0002\u0002\\u035E\\u035F\\x072\u0002\u0002\\u035F\\u038B\\x072\u0002\u0002\\u0360\\u0361\\x07k\u0002\u0002\\u0361\\u0362\\x07p\u0002\u0002\\u0362\\u0363\\x07v\u0002\u0002\\u0363\\u0364\\x074\u0002\u0002\\u0364\\u0365\\x072\u0002\u0002\\u0365\\u038B\\x07:\u0002\u0002\\u0366\\u0367\\x07k\u0002\u0002\\u0367\\u0368\\x07p\u0002\u0002\\u0368\\u0369\\x07v\u0002\u0002\\u0369\\u036A\\x074\u0002\u0002\\u036A\\u036B\\x073\u0002\u0002\\u036B\\u038B\\x078\u0002\u0002\\u036C\\u036D\\x07k\u0002\u0002\\u036D\\u036E\\x07p\u0002\u0002\\u036E\\u036F\\x07v\u0002\u0002\\u036F\\u0370\\x074\u0002\u0002\\u0370\\u0371\\x074\u0002\u0002\\u0371\\u038B\\x076\u0002\u0002\\u0372\\u0373\\x07k\u0002\u0002\\u0373\\u0374\\x07p\u0002\u0002\\u0374\\u0375\\x07v\u0002\u0002\\u0375\\u0376\\x074\u0002\u0002\\u0376\\u0377\\x075\u0002\u0002\\u0377\\u038B\\x074\u0002\u0002\\u0378\\u0379\\x07k\u0002\u0002\\u0379\\u037A\\x07p\u0002\u0002\\u037A\\u037B\\x07v\u0002\u0002\\u037B\\u037C\\x074\u0002\u0002\\u037C\\u037D\\x076\u0002\u0002\\u037D\\u038B\\x072\u0002\u0002\\u037E\\u037F\\x07k\u0002\u0002\\u037F\\u0380\\x07p\u0002\u0002\\u0380\\u0381\\x07v\u0002\u0002\\u0381\\u0382\\x074\u0002\u0002\\u0382\\u0383\\x076\u0002\u0002\\u0383\\u038B\\x07:\u0002\u0002\\u0384\\u0385\\x07k\u0002\u0002\\u0385\\u0386\\x07p\u0002\u0002\\u0386\\u0387\\x07v\u0002\u0002\\u0387\\u0388\\x074\u0002\u0002\\u0388\\u0389\\x077\u0002\u0002\\u0389\\u038B\\x078\u0002\u0002\\u038A\\u02D4\u0003\u0002\u0002\u0002\\u038A\\u02D7\u0003\u0002\u0002\u0002\\u038A\\u02DB\u0003\u0002\u0002\u0002\\u038A\\u02E0\u0003\u0002\u0002\u0002\\u038A\\u02E5\u0003\u0002\u0002\u0002\\u038A\\u02EA\u0003\u0002\u0002\u0002\\u038A\\u02EF\u0003\u0002\u0002\u0002\\u038A\\u02F4\u0003\u0002\u0002\u0002\\u038A\\u02F9\u0003\u0002\u0002\u0002\\u038A\\u02FE\u0003\u0002\u0002\u0002\\u038A\\u0303\u0003\u0002\u0002\u0002\\u038A\\u0308\u0003\u0002\u0002\u0002\\u038A\\u030D\u0003\u0002\u0002\u0002\\u038A\\u0312\u0003\u0002\u0002\u0002\\u038A\\u0318\u0003\u0002\u0002\u0002\\u038A\\u031E\u0003\u0002\u0002\u0002\\u038A\\u0324\u0003\u0002\u0002\u0002\\u038A\\u032A\u0003\u0002\u0002\u0002\\u038A\\u0330\u0003\u0002\u0002\u0002\\u038A\\u0336\u0003\u0002\u0002\u0002\\u038A\\u033C\u0003\u0002\u0002\u0002\\u038A\\u0342\u0003\u0002\u0002\u0002\\u038A\\u0348\u0003\u0002\u0002\u0002\\u038A\\u034E\u0003\u0002\u0002\u0002\\u038A\\u0354\u0003\u0002\u0002\u0002\\u038A\\u035A\u0003\u0002\u0002\u0002\\u038A\\u0360\u0003\u0002\u0002\u0002\\u038A\\u0366\u0003\u0002\u0002\u0002\\u038A\\u036C\u0003\u0002\u0002\u0002\\u038A\\u0372\u0003\u0002\u0002\u0002\\u038A\\u0378\u0003\u0002\u0002\u0002\\u038A\\u037E\u0003\u0002\u0002\u0002\\u038A\\u0384\u0003\u0002\u0002\u0002\\u038B\\xC6\u0003\u0002\u0002\u0002\\u038C\\u038D\\x07w\u0002\u0002\\u038D\\u038E\\x07k\u0002\u0002\\u038E\\u038F\\x07p\u0002\u0002\\u038F\\u0464\\x07v\u0002\u0002\\u0390\\u0391\\x07w\u0002\u0002\\u0391\\u0392\\x07k\u0002\u0002\\u0392\\u0393\\x07p\u0002\u0002\\u0393\\u0394\\x07v\u0002\u0002\\u0394\\u0464\\x07:\u0002\u0002\\u0395\\u0396\\x07w\u0002\u0002\\u0396\\u0397\\x07k\u0002\u0002\\u0397\\u0398\\x07p\u0002\u0002\\u0398\\u0399\\x07v\u0002\u0002\\u0399\\u039A\\x073\u0002\u0002\\u039A\\u0464\\x078\u0002\u0002\\u039B\\u039C\";\nSolidityLexer._serializedATNSegment2 = \"\\x07w\u0002\u0002\\u039C\\u039D\\x07k\u0002\u0002\\u039D\\u039E\\x07p\u0002\u0002\\u039E\\u039F\\x07v\u0002\u0002\\u039F\\u03A0\\x074\u0002\u0002\\u03A0\\u0464\\x076\u0002\u0002\\u03A1\\u03A2\\x07w\u0002\u0002\\u03A2\\u03A3\\x07k\u0002\u0002\\u03A3\\u03A4\\x07p\u0002\u0002\\u03A4\\u03A5\\x07v\u0002\u0002\\u03A5\\u03A6\\x075\u0002\u0002\\u03A6\\u0464\\x074\u0002\u0002\\u03A7\\u03A8\\x07w\u0002\u0002\\u03A8\\u03A9\\x07k\u0002\u0002\\u03A9\\u03AA\\x07p\u0002\u0002\\u03AA\\u03AB\\x07v\u0002\u0002\\u03AB\\u03AC\\x076\u0002\u0002\\u03AC\\u0464\\x072\u0002\u0002\\u03AD\\u03AE\\x07w\u0002\u0002\\u03AE\\u03AF\\x07k\u0002\u0002\\u03AF\\u03B0\\x07p\u0002\u0002\\u03B0\\u03B1\\x07v\u0002\u0002\\u03B1\\u03B2\\x076\u0002\u0002\\u03B2\\u0464\\x07:\u0002\u0002\\u03B3\\u03B4\\x07w\u0002\u0002\\u03B4\\u03B5\\x07k\u0002\u0002\\u03B5\\u03B6\\x07p\u0002\u0002\\u03B6\\u03B7\\x07v\u0002\u0002\\u03B7\\u03B8\\x077\u0002\u0002\\u03B8\\u0464\\x078\u0002\u0002\\u03B9\\u03BA\\x07w\u0002\u0002\\u03BA\\u03BB\\x07k\u0002\u0002\\u03BB\\u03BC\\x07p\u0002\u0002\\u03BC\\u03BD\\x07v\u0002\u0002\\u03BD\\u03BE\\x078\u0002\u0002\\u03BE\\u0464\\x076\u0002\u0002\\u03BF\\u03C0\\x07w\u0002\u0002\\u03C0\\u03C1\\x07k\u0002\u0002\\u03C1\\u03C2\\x07p\u0002\u0002\\u03C2\\u03C3\\x07v\u0002\u0002\\u03C3\\u03C4\\x079\u0002\u0002\\u03C4\\u0464\\x074\u0002\u0002\\u03C5\\u03C6\\x07w\u0002\u0002\\u03C6\\u03C7\\x07k\u0002\u0002\\u03C7\\u03C8\\x07p\u0002\u0002\\u03C8\\u03C9\\x07v\u0002\u0002\\u03C9\\u03CA\\x07:\u0002\u0002\\u03CA\\u0464\\x072\u0002\u0002\\u03CB\\u03CC\\x07w\u0002\u0002\\u03CC\\u03CD\\x07k\u0002\u0002\\u03CD\\u03CE\\x07p\u0002\u0002\\u03CE\\u03CF\\x07v\u0002\u0002\\u03CF\\u03D0\\x07:\u0002\u0002\\u03D0\\u0464\\x07:\u0002\u0002\\u03D1\\u03D2\\x07w\u0002\u0002\\u03D2\\u03D3\\x07k\u0002\u0002\\u03D3\\u03D4\\x07p\u0002\u0002\\u03D4\\u03D5\\x07v\u0002\u0002\\u03D5\\u03D6\\x07;\u0002\u0002\\u03D6\\u0464\\x078\u0002\u0002\\u03D7\\u03D8\\x07w\u0002\u0002\\u03D8\\u03D9\\x07k\u0002\u0002\\u03D9\\u03DA\\x07p\u0002\u0002\\u03DA\\u03DB\\x07v\u0002\u0002\\u03DB\\u03DC\\x073\u0002\u0002\\u03DC\\u03DD\\x072\u0002\u0002\\u03DD\\u0464\\x076\u0002\u0002\\u03DE\\u03DF\\x07w\u0002\u0002\\u03DF\\u03E0\\x07k\u0002\u0002\\u03E0\\u03E1\\x07p\u0002\u0002\\u03E1\\u03E2\\x07v\u0002\u0002\\u03E2\\u03E3\\x073\u0002\u0002\\u03E3\\u03E4\\x073\u0002\u0002\\u03E4\\u0464\\x074\u0002\u0002\\u03E5\\u03E6\\x07w\u0002\u0002\\u03E6\\u03E7\\x07k\u0002\u0002\\u03E7\\u03E8\\x07p\u0002\u0002\\u03E8\\u03E9\\x07v\u0002\u0002\\u03E9\\u03EA\\x073\u0002\u0002\\u03EA\\u03EB\\x074\u0002\u0002\\u03EB\\u0464\\x072\u0002\u0002\\u03EC\\u03ED\\x07w\u0002\u0002\\u03ED\\u03EE\\x07k\u0002\u0002\\u03EE\\u03EF\\x07p\u0002\u0002\\u03EF\\u03F0\\x07v\u0002\u0002\\u03F0\\u03F1\\x073\u0002\u0002\\u03F1\\u03F2\\x074\u0002\u0002\\u03F2\\u0464\\x07:\u0002\u0002\\u03F3\\u03F4\\x07w\u0002\u0002\\u03F4\\u03F5\\x07k\u0002\u0002\\u03F5\\u03F6\\x07p\u0002\u0002\\u03F6\\u03F7\\x07v\u0002\u0002\\u03F7\\u03F8\\x073\u0002\u0002\\u03F8\\u03F9\\x075\u0002\u0002\\u03F9\\u0464\\x078\u0002\u0002\\u03FA\\u03FB\\x07w\u0002\u0002\\u03FB\\u03FC\\x07k\u0002\u0002\\u03FC\\u03FD\\x07p\u0002\u0002\\u03FD\\u03FE\\x07v\u0002\u0002\\u03FE\\u03FF\\x073\u0002\u0002\\u03FF\\u0400\\x076\u0002\u0002\\u0400\\u0464\\x076\u0002\u0002\\u0401\\u0402\\x07w\u0002\u0002\\u0402\\u0403\\x07k\u0002\u0002\\u0403\\u0404\\x07p\u0002\u0002\\u0404\\u0405\\x07v\u0002\u0002\\u0405\\u0406\\x073\u0002\u0002\\u0406\\u0407\\x077\u0002\u0002\\u0407\\u0464\\x074\u0002\u0002\\u0408\\u0409\\x07w\u0002\u0002\\u0409\\u040A\\x07k\u0002\u0002\\u040A\\u040B\\x07p\u0002\u0002\\u040B\\u040C\\x07v\u0002\u0002\\u040C\\u040D\\x073\u0002\u0002\\u040D\\u040E\\x078\u0002\u0002\\u040E\\u0464\\x072\u0002\u0002\\u040F\\u0410\\x07w\u0002\u0002\\u0410\\u0411\\x07k\u0002\u0002\\u0411\\u0412\\x07p\u0002\u0002\\u0412\\u0413\\x07v\u0002\u0002\\u0413\\u0414\\x073\u0002\u0002\\u0414\\u0415\\x078\u0002\u0002\\u0415\\u0464\\x07:\u0002\u0002\\u0416\\u0417\\x07w\u0002\u0002\\u0417\\u0418\\x07k\u0002\u0002\\u0418\\u0419\\x07p\u0002\u0002\\u0419\\u041A\\x07v\u0002\u0002\\u041A\\u041B\\x073\u0002\u0002\\u041B\\u041C\\x079\u0002\u0002\\u041C\\u0464\\x078\u0002\u0002\\u041D\\u041E\\x07w\u0002\u0002\\u041E\\u041F\\x07k\u0002\u0002\\u041F\\u0420\\x07p\u0002\u0002\\u0420\\u0421\\x07v\u0002\u0002\\u0421\\u0422\\x073\u0002\u0002\\u0422\\u0423\\x07:\u0002\u0002\\u0423\\u0464\\x076\u0002\u0002\\u0424\\u0425\\x07w\u0002\u0002\\u0425\\u0426\\x07k\u0002\u0002\\u0426\\u0427\\x07p\u0002\u0002\\u0427\\u0428\\x07v\u0002\u0002\\u0428\\u0429\\x073\u0002\u0002\\u0429\\u042A\\x07;\u0002\u0002\\u042A\\u0464\\x074\u0002\u0002\\u042B\\u042C\\x07w\u0002\u0002\\u042C\\u042D\\x07k\u0002\u0002\\u042D\\u042E\\x07p\u0002\u0002\\u042E\\u042F\\x07v\u0002\u0002\\u042F\\u0430\\x074\u0002\u0002\\u0430\\u0431\\x072\u0002\u0002\\u0431\\u0464\\x072\u0002\u0002\\u0432\\u0433\\x07w\u0002\u0002\\u0433\\u0434\\x07k\u0002\u0002\\u0434\\u0435\\x07p\u0002\u0002\\u0435\\u0436\\x07v\u0002\u0002\\u0436\\u0437\\x074\u0002\u0002\\u0437\\u0438\\x072\u0002\u0002\\u0438\\u0464\\x07:\u0002\u0002\\u0439\\u043A\\x07w\u0002\u0002\\u043A\\u043B\\x07k\u0002\u0002\\u043B\\u043C\\x07p\u0002\u0002\\u043C\\u043D\\x07v\u0002\u0002\\u043D\\u043E\\x074\u0002\u0002\\u043E\\u043F\\x073\u0002\u0002\\u043F\\u0464\\x078\u0002\u0002\\u0440\\u0441\\x07w\u0002\u0002\\u0441\\u0442\\x07k\u0002\u0002\\u0442\\u0443\\x07p\u0002\u0002\\u0443\\u0444\\x07v\u0002\u0002\\u0444\\u0445\\x074\u0002\u0002\\u0445\\u0446\\x074\u0002\u0002\\u0446\\u0464\\x076\u0002\u0002\\u0447\\u0448\\x07w\u0002\u0002\\u0448\\u0449\\x07k\u0002\u0002\\u0449\\u044A\\x07p\u0002\u0002\\u044A\\u044B\\x07v\u0002\u0002\\u044B\\u044C\\x074\u0002\u0002\\u044C\\u044D\\x075\u0002\u0002\\u044D\\u0464\\x074\u0002\u0002\\u044E\\u044F\\x07w\u0002\u0002\\u044F\\u0450\\x07k\u0002\u0002\\u0450\\u0451\\x07p\u0002\u0002\\u0451\\u0452\\x07v\u0002\u0002\\u0452\\u0453\\x074\u0002\u0002\\u0453\\u0454\\x076\u0002\u0002\\u0454\\u0464\\x072\u0002\u0002\\u0455\\u0456\\x07w\u0002\u0002\\u0456\\u0457\\x07k\u0002\u0002\\u0457\\u0458\\x07p\u0002\u0002\\u0458\\u0459\\x07v\u0002\u0002\\u0459\\u045A\\x074\u0002\u0002\\u045A\\u045B\\x076\u0002\u0002\\u045B\\u0464\\x07:\u0002\u0002\\u045C\\u045D\\x07w\u0002\u0002\\u045D\\u045E\\x07k\u0002\u0002\\u045E\\u045F\\x07p\u0002\u0002\\u045F\\u0460\\x07v\u0002\u0002\\u0460\\u0461\\x074\u0002\u0002\\u0461\\u0462\\x077\u0002\u0002\\u0462\\u0464\\x078\u0002\u0002\\u0463\\u038C\u0003\u0002\u0002\u0002\\u0463\\u0390\u0003\u0002\u0002\u0002\\u0463\\u0395\u0003\u0002\u0002\u0002\\u0463\\u039B\u0003\u0002\u0002\u0002\\u0463\\u03A1\u0003\u0002\u0002\u0002\\u0463\\u03A7\u0003\u0002\u0002\u0002\\u0463\\u03AD\u0003\u0002\u0002\u0002\\u0463\\u03B3\u0003\u0002\u0002\u0002\\u0463\\u03B9\u0003\u0002\u0002\u0002\\u0463\\u03BF\u0003\u0002\u0002\u0002\\u0463\\u03C5\u0003\u0002\u0002\u0002\\u0463\\u03CB\u0003\u0002\u0002\u0002\\u0463\\u03D1\u0003\u0002\u0002\u0002\\u0463\\u03D7\u0003\u0002\u0002\u0002\\u0463\\u03DE\u0003\u0002\u0002\u0002\\u0463\\u03E5\u0003\u0002\u0002\u0002\\u0463\\u03EC\u0003\u0002\u0002\u0002\\u0463\\u03F3\u0003\u0002\u0002\u0002\\u0463\\u03FA\u0003\u0002\u0002\u0002\\u0463\\u0401\u0003\u0002\u0002\u0002\\u0463\\u0408\u0003\u0002\u0002\u0002\\u0463\\u040F\u0003\u0002\u0002\u0002\\u0463\\u0416\u0003\u0002\u0002\u0002\\u0463\\u041D\u0003\u0002\u0002\u0002\\u0463\\u0424\u0003\u0002\u0002\u0002\\u0463\\u042B\u0003\u0002\u0002\u0002\\u0463\\u0432\u0003\u0002\u0002\u0002\\u0463\\u0439\u0003\u0002\u0002\u0002\\u0463\\u0440\u0003\u0002\u0002\u0002\\u0463\\u0447\u0003\u0002\u0002\u0002\\u0463\\u044E\u0003\u0002\u0002\u0002\\u0463\\u0455\u0003\u0002\u0002\u0002\\u0463\\u045C\u0003\u0002\u0002\u0002\\u0464\\xC8\u0003\u0002\u0002\u0002\\u0465\\u0466\\x07d\u0002\u0002\\u0466\\u0467\\x07{\u0002\u0002\\u0467\\u0468\\x07v\u0002\u0002\\u0468\\u0469\\x07g\u0002\u0002\\u0469\\u0542\\x07u\u0002\u0002\\u046A\\u046B\\x07d\u0002\u0002\\u046B\\u046C\\x07{\u0002\u0002\\u046C\\u046D\\x07v\u0002\u0002\\u046D\\u046E\\x07g\u0002\u0002\\u046E\\u046F\\x07u\u0002\u0002\\u046F\\u0542\\x073\u0002\u0002\\u0470\\u0471\\x07d\u0002\u0002\\u0471\\u0472\\x07{\u0002\u0002\\u0472\\u0473\\x07v\u0002\u0002\\u0473\\u0474\\x07g\u0002\u0002\\u0474\\u0475\\x07u\u0002\u0002\\u0475\\u0542\\x074\u0002\u0002\\u0476\\u0477\\x07d\u0002\u0002\\u0477\\u0478\\x07{\u0002\u0002\\u0478\\u0479\\x07v\u0002\u0002\\u0479\\u047A\\x07g\u0002\u0002\\u047A\\u047B\\x07u\u0002\u0002\\u047B\\u0542\\x075\u0002\u0002\\u047C\\u047D\\x07d\u0002\u0002\\u047D\\u047E\\x07{\u0002\u0002\\u047E\\u047F\\x07v\u0002\u0002\\u047F\\u0480\\x07g\u0002\u0002\\u0480\\u0481\\x07u\u0002\u0002\\u0481\\u0542\\x076\u0002\u0002\\u0482\\u0483\\x07d\u0002\u0002\\u0483\\u0484\\x07{\u0002\u0002\\u0484\\u0485\\x07v\u0002\u0002\\u0485\\u0486\\x07g\u0002\u0002\\u0486\\u0487\\x07u\u0002\u0002\\u0487\\u0542\\x077\u0002\u0002\\u0488\\u0489\\x07d\u0002\u0002\\u0489\\u048A\\x07{\u0002\u0002\\u048A\\u048B\\x07v\u0002\u0002\\u048B\\u048C\\x07g\u0002\u0002\\u048C\\u048D\\x07u\u0002\u0002\\u048D\\u0542\\x078\u0002\u0002\\u048E\\u048F\\x07d\u0002\u0002\\u048F\\u0490\\x07{\u0002\u0002\\u0490\\u0491\\x07v\u0002\u0002\\u0491\\u0492\\x07g\u0002\u0002\\u0492\\u0493\\x07u\u0002\u0002\\u0493\\u0542\\x079\u0002\u0002\\u0494\\u0495\\x07d\u0002\u0002\\u0495\\u0496\\x07{\u0002\u0002\\u0496\\u0497\\x07v\u0002\u0002\\u0497\\u0498\\x07g\u0002\u0002\\u0498\\u0499\\x07u\u0002\u0002\\u0499\\u0542\\x07:\u0002\u0002\\u049A\\u049B\\x07d\u0002\u0002\\u049B\\u049C\\x07{\u0002\u0002\\u049C\\u049D\\x07v\u0002\u0002\\u049D\\u049E\\x07g\u0002\u0002\\u049E\\u049F\\x07u\u0002\u0002\\u049F\\u0542\\x07;\u0002\u0002\\u04A0\\u04A1\\x07d\u0002\u0002\\u04A1\\u04A2\\x07{\u0002\u0002\\u04A2\\u04A3\\x07v\u0002\u0002\\u04A3\\u04A4\\x07g\u0002\u0002\\u04A4\\u04A5\\x07u\u0002\u0002\\u04A5\\u04A6\\x073\u0002\u0002\\u04A6\\u0542\\x072\u0002\u0002\\u04A7\\u04A8\\x07d\u0002\u0002\\u04A8\\u04A9\\x07{\u0002\u0002\\u04A9\\u04AA\\x07v\u0002\u0002\\u04AA\\u04AB\\x07g\u0002\u0002\\u04AB\\u04AC\\x07u\u0002\u0002\\u04AC\\u04AD\\x073\u0002\u0002\\u04AD\\u0542\\x073\u0002\u0002\\u04AE\\u04AF\\x07d\u0002\u0002\\u04AF\\u04B0\\x07{\u0002\u0002\\u04B0\\u04B1\\x07v\u0002\u0002\\u04B1\\u04B2\\x07g\u0002\u0002\\u04B2\\u04B3\\x07u\u0002\u0002\\u04B3\\u04B4\\x073\u0002\u0002\\u04B4\\u0542\\x074\u0002\u0002\\u04B5\\u04B6\\x07d\u0002\u0002\\u04B6\\u04B7\\x07{\u0002\u0002\\u04B7\\u04B8\\x07v\u0002\u0002\\u04B8\\u04B9\\x07g\u0002\u0002\\u04B9\\u04BA\\x07u\u0002\u0002\\u04BA\\u04BB\\x073\u0002\u0002\\u04BB\\u0542\\x075\u0002\u0002\\u04BC\\u04BD\\x07d\u0002\u0002\\u04BD\\u04BE\\x07{\u0002\u0002\\u04BE\\u04BF\\x07v\u0002\u0002\\u04BF\\u04C0\\x07g\u0002\u0002\\u04C0\\u04C1\\x07u\u0002\u0002\\u04C1\\u04C2\\x073\u0002\u0002\\u04C2\\u0542\\x076\u0002\u0002\\u04C3\\u04C4\\x07d\u0002\u0002\\u04C4\\u04C5\\x07{\u0002\u0002\\u04C5\\u04C6\\x07v\u0002\u0002\\u04C6\\u04C7\\x07g\u0002\u0002\\u04C7\\u04C8\\x07u\u0002\u0002\\u04C8\\u04C9\\x073\u0002\u0002\\u04C9\\u0542\\x077\u0002\u0002\\u04CA\\u04CB\\x07d\u0002\u0002\\u04CB\\u04CC\\x07{\u0002\u0002\\u04CC\\u04CD\\x07v\u0002\u0002\\u04CD\\u04CE\\x07g\u0002\u0002\\u04CE\\u04CF\\x07u\u0002\u0002\\u04CF\\u04D0\\x073\u0002\u0002\\u04D0\\u0542\\x078\u0002\u0002\\u04D1\\u04D2\\x07d\u0002\u0002\\u04D2\\u04D3\\x07{\u0002\u0002\\u04D3\\u04D4\\x07v\u0002\u0002\\u04D4\\u04D5\\x07g\u0002\u0002\\u04D5\\u04D6\\x07u\u0002\u0002\\u04D6\\u04D7\\x073\u0002\u0002\\u04D7\\u0542\\x079\u0002\u0002\\u04D8\\u04D9\\x07d\u0002\u0002\\u04D9\\u04DA\\x07{\u0002\u0002\\u04DA\\u04DB\\x07v\u0002\u0002\\u04DB\\u04DC\\x07g\u0002\u0002\\u04DC\\u04DD\\x07u\u0002\u0002\\u04DD\\u04DE\\x073\u0002\u0002\\u04DE\\u0542\\x07:\u0002\u0002\\u04DF\\u04E0\\x07d\u0002\u0002\\u04E0\\u04E1\\x07{\u0002\u0002\\u04E1\\u04E2\\x07v\u0002\u0002\\u04E2\\u04E3\\x07g\u0002\u0002\\u04E3\\u04E4\\x07u\u0002\u0002\\u04E4\\u04E5\\x073\u0002\u0002\\u04E5\\u0542\\x07;\u0002\u0002\\u04E6\\u04E7\\x07d\u0002\u0002\\u04E7\\u04E8\\x07{\u0002\u0002\\u04E8\\u04E9\\x07v\u0002\u0002\\u04E9\\u04EA\\x07g\u0002\u0002\\u04EA\\u04EB\\x07u\u0002\u0002\\u04EB\\u04EC\\x074\u0002\u0002\\u04EC\\u0542\\x072\u0002\u0002\\u04ED\\u04EE\\x07d\u0002\u0002\\u04EE\\u04EF\\x07{\u0002\u0002\\u04EF\\u04F0\\x07v\u0002\u0002\\u04F0\\u04F1\\x07g\u0002\u0002\\u04F1\\u04F2\\x07u\u0002\u0002\\u04F2\\u04F3\\x074\u0002\u0002\\u04F3\\u0542\\x073\u0002\u0002\\u04F4\\u04F5\\x07d\u0002\u0002\\u04F5\\u04F6\\x07{\u0002\u0002\\u04F6\\u04F7\\x07v\u0002\u0002\\u04F7\\u04F8\\x07g\u0002\u0002\\u04F8\\u04F9\\x07u\u0002\u0002\\u04F9\\u04FA\\x074\u0002\u0002\\u04FA\\u0542\\x074\u0002\u0002\\u04FB\\u04FC\\x07d\u0002\u0002\\u04FC\\u04FD\\x07{\u0002\u0002\\u04FD\\u04FE\\x07v\u0002\u0002\\u04FE\\u04FF\\x07g\u0002\u0002\\u04FF\\u0500\\x07u\u0002\u0002\\u0500\\u0501\\x074\u0002\u0002\\u0501\\u0542\\x075\u0002\u0002\\u0502\\u0503\\x07d\u0002\u0002\\u0503\\u0504\\x07{\u0002\u0002\\u0504\\u0505\\x07v\u0002\u0002\\u0505\\u0506\\x07g\u0002\u0002\\u0506\\u0507\\x07u\u0002\u0002\\u0507\\u0508\\x074\u0002\u0002\\u0508\\u0542\\x076\u0002\u0002\\u0509\\u050A\\x07d\u0002\u0002\\u050A\\u050B\\x07{\u0002\u0002\\u050B\\u050C\\x07v\u0002\u0002\\u050C\\u050D\\x07g\u0002\u0002\\u050D\\u050E\\x07u\u0002\u0002\\u050E\\u050F\\x074\u0002\u0002\\u050F\\u0542\\x077\u0002\u0002\\u0510\\u0511\\x07d\u0002\u0002\\u0511\\u0512\\x07{\u0002\u0002\\u0512\\u0513\\x07v\u0002\u0002\\u0513\\u0514\\x07g\u0002\u0002\\u0514\\u0515\\x07u\u0002\u0002\\u0515\\u0516\\x074\u0002\u0002\\u0516\\u0542\\x078\u0002\u0002\\u0517\\u0518\\x07d\u0002\u0002\\u0518\\u0519\\x07{\u0002\u0002\\u0519\\u051A\\x07v\u0002\u0002\\u051A\\u051B\\x07g\u0002\u0002\\u051B\\u051C\\x07u\u0002\u0002\\u051C\\u051D\\x074\u0002\u0002\\u051D\\u0542\\x079\u0002\u0002\\u051E\\u051F\\x07d\u0002\u0002\\u051F\\u0520\\x07{\u0002\u0002\\u0520\\u0521\\x07v\u0002\u0002\\u0521\\u0522\\x07g\u0002\u0002\\u0522\\u0523\\x07u\u0002\u0002\\u0523\\u0524\\x074\u0002\u0002\\u0524\\u0542\\x07:\u0002\u0002\\u0525\\u0526\\x07d\u0002\u0002\\u0526\\u0527\\x07{\u0002\u0002\\u0527\\u0528\\x07v\u0002\u0002\\u0528\\u0529\\x07g\u0002\u0002\\u0529\\u052A\\x07u\u0002\u0002\\u052A\\u052B\\x074\u0002\u0002\\u052B\\u0542\\x07;\u0002\u0002\\u052C\\u052D\\x07d\u0002\u0002\\u052D\\u052E\\x07{\u0002\u0002\\u052E\\u052F\\x07v\u0002\u0002\\u052F\\u0530\\x07g\u0002\u0002\\u0530\\u0531\\x07u\u0002\u0002\\u0531\\u0532\\x075\u0002\u0002\\u0532\\u0542\\x072\u0002\u0002\\u0533\\u0534\\x07d\u0002\u0002\\u0534\\u0535\\x07{\u0002\u0002\\u0535\\u0536\\x07v\u0002\u0002\\u0536\\u0537\\x07g\u0002\u0002\\u0537\\u0538\\x07u\u0002\u0002\\u0538\\u0539\\x075\u0002\u0002\\u0539\\u0542\\x073\u0002\u0002\\u053A\\u053B\\x07d\u0002\u0002\\u053B\\u053C\\x07{\u0002\u0002\\u053C\\u053D\\x07v\u0002\u0002\\u053D\\u053E\\x07g\u0002\u0002\\u053E\\u053F\\x07u\u0002\u0002\\u053F\\u0540\\x075\u0002\u0002\\u0540\\u0542\\x074\u0002\u0002\\u0541\\u0465\u0003\u0002\u0002\u0002\\u0541\\u046A\u0003\u0002\u0002\u0002\\u0541\\u0470\u0003\u0002\u0002\u0002\\u0541\\u0476\u0003\u0002\u0002\u0002\\u0541\\u047C\u0003\u0002\u0002\u0002\\u0541\\u0482\u0003\u0002\u0002\u0002\\u0541\\u0488\u0003\u0002\u0002\u0002\\u0541\\u048E\u0003\u0002\u0002\u0002\\u0541\\u0494\u0003\u0002\u0002\u0002\\u0541\\u049A\u0003\u0002\u0002\u0002\\u0541\\u04A0\u0003\u0002\u0002\u0002\\u0541\\u04A7\u0003\u0002\u0002\u0002\\u0541\\u04AE\u0003\u0002\u0002\u0002\\u0541\\u04B5\u0003\u0002\u0002\u0002\\u0541\\u04BC\u0003\u0002\u0002\u0002\\u0541\\u04C3\u0003\u0002\u0002\u0002\\u0541\\u04CA\u0003\u0002\u0002\u0002\\u0541\\u04D1\u0003\u0002\u0002\u0002\\u0541\\u04D8\u0003\u0002\u0002\u0002\\u0541\\u04DF\u0003\u0002\u0002\u0002\\u0541\\u04E6\u0003\u0002\u0002\u0002\\u0541\\u04ED\u0003\u0002\u0002\u0002\\u0541\\u04F4\u0003\u0002\u0002\u0002\\u0541\\u04FB\u0003\u0002\u0002\u0002\\u0541\\u0502\u0003\u0002\u0002\u0002\\u0541\\u0509\u0003\u0002\u0002\u0002\\u0541\\u0510\u0003\u0002\u0002\u0002\\u0541\\u0517\u0003\u0002\u0002\u0002\\u0541\\u051E\u0003\u0002\u0002\u0002\\u0541\\u0525\u0003\u0002\u0002\u0002\\u0541\\u052C\u0003\u0002\u0002\u0002\\u0541\\u0533\u0003\u0002\u0002\u0002\\u0541\\u053A\u0003\u0002\u0002\u0002\\u0542\\xCA\u0003\u0002\u0002\u0002\\u0543\\u0544\\x07h\u0002\u0002\\u0544\\u0545\\x07k\u0002\u0002\\u0545\\u0546\\x07z\u0002\u0002\\u0546\\u0547\\x07g\u0002\u0002\\u0547\\u055A\\x07f\u0002\u0002\\u0548\\u0549\\x07h\u0002\u0002\\u0549\\u054A\\x07k\u0002\u0002\\u054A\\u054B\\x07z\u0002\u0002\\u054B\\u054C\\x07g\u0002\u0002\\u054C\\u054D\\x07f\u0002\u0002\\u054D\\u054F\u0003\u0002\u0002\u0002\\u054E\\u0550\t\u0002\u0002\u0002\\u054F\\u054E\u0003\u0002\u0002\u0002\\u0550\\u0551\u0003\u0002\u0002\u0002\\u0551\\u054F\u0003\u0002\u0002\u0002\\u0551\\u0552\u0003\u0002\u0002\u0002\\u0552\\u0553\u0003\u0002\u0002\u0002\\u0553\\u0555\\x07z\u0002\u0002\\u0554\\u0556\t\u0002\u0002\u0002\\u0555\\u0554\u0003\u0002\u0002\u0002\\u0556\\u0557\u0003\u0002\u0002\u0002\\u0557\\u0555\u0003\u0002\u0002\u0002\\u0557\\u0558\u0003\u0002\u0002\u0002\\u0558\\u055A\u0003\u0002\u0002\u0002\\u0559\\u0543\u0003\u0002\u0002\u0002\\u0559\\u0548\u0003\u0002\u0002\u0002\\u055A\\xCC\u0003\u0002\u0002\u0002\\u055B\\u055C\\x07w\u0002\u0002\\u055C\\u055D\\x07h\u0002\u0002\\u055D\\u055E\\x07k\u0002\u0002\\u055E\\u055F\\x07z\u0002\u0002\\u055F\\u0560\\x07g\u0002\u0002\\u0560\\u0574\\x07f\u0002\u0002\\u0561\\u0562\\x07w\u0002\u0002\\u0562\\u0563\\x07h\u0002\u0002\\u0563\\u0564\\x07k\u0002\u0002\\u0564\\u0565\\x07z\u0002\u0002\\u0565\\u0566\\x07g\u0002\u0002\\u0566\\u0567\\x07f\u0002\u0002\\u0567\\u0569\u0003\u0002\u0002\u0002\\u0568\\u056A\t\u0002\u0002\u0002\\u0569\\u0568\u0003\u0002\u0002\u0002\\u056A\\u056B\u0003\u0002\u0002\u0002\\u056B\\u0569\u0003\u0002\u0002\u0002\\u056B\\u056C\u0003\u0002\u0002\u0002\\u056C\\u056D\u0003\u0002\u0002\u0002\\u056D\\u056F\\x07z\u0002\u0002\\u056E\\u0570\t\u0002\u0002\u0002\\u056F\\u056E\u0003\u0002\u0002\u0002\\u0570\\u0571\u0003\u0002\u0002\u0002\\u0571\\u056F\u0003\u0002\u0002\u0002\\u0571\\u0572\u0003\u0002\u0002\u0002\\u0572\\u0574\u0003\u0002\u0002\u0002\\u0573\\u055B\u0003\u0002\u0002\u0002\\u0573\\u0561\u0003\u0002\u0002\u0002\\u0574\\xCE\u0003\u0002\u0002\u0002\\u0575\\u0576\\x07v\u0002\u0002\\u0576\\u0577\\x07t\u0002\u0002\\u0577\\u0578\\x07w\u0002\u0002\\u0578\\u057F\\x07g\u0002\u0002\\u0579\\u057A\\x07h\u0002\u0002\\u057A\\u057B\\x07c\u0002\u0002\\u057B\\u057C\\x07n\u0002\u0002\\u057C\\u057D\\x07u\u0002\u0002\\u057D\\u057F\\x07g\u0002\u0002\\u057E\\u0575\u0003\u0002\u0002\u0002\\u057E\\u0579\u0003\u0002\u0002\u0002\\u057F\\xD0\u0003\u0002\u0002\u0002\\u0580\\u0587\u0005\\xD3j\u0002\\u0581\\u0583\u0005\\xD3j\u0002\\u0582\\u0581\u0003\u0002\u0002\u0002\\u0582\\u0583\u0003\u0002\u0002\u0002\\u0583\\u0584\u0003\u0002\u0002\u0002\\u0584\\u0585\\x070\u0002\u0002\\u0585\\u0587\u0005\\xD3j\u0002\\u0586\\u0580\u0003\u0002\u0002\u0002\\u0586\\u0582\u0003\u0002\u0002\u0002\\u0587\\u058A\u0003\u0002\u0002\u0002\\u0588\\u0589\t\u0003\u0002\u0002\\u0589\\u058B\u0005\\xD3j\u0002\\u058A\\u0588\u0003\u0002\u0002\u0002\\u058A\\u058B\u0003\u0002\u0002\u0002\\u058B\\xD2\u0003\u0002\u0002\u0002\\u058C\\u0593\t\u0002\u0002\u0002\\u058D\\u058F\\x07a\u0002\u0002\\u058E\\u058D\u0003\u0002\u0002\u0002\\u058E\\u058F\u0003\u0002\u0002\u0002\\u058F\\u0590\u0003\u0002\u0002\u0002\\u0590\\u0592\t\u0002\u0002\u0002\\u0591\\u058E\u0003\u0002\u0002\u0002\\u0592\\u0595\u0003\u0002\u0002\u0002\\u0593\\u0591\u0003\u0002\u0002\u0002\\u0593\\u0594\u0003\u0002\u0002\u0002\\u0594\\xD4\u0003\u0002\u0002\u0002\\u0595\\u0593\u0003\u0002\u0002\u0002\\u0596\\u0597\\x072\u0002\u0002\\u0597\\u0598\t\u0004\u0002\u0002\\u0598\\u0599\u0005\\xD7l\u0002\\u0599\\xD6\u0003\u0002\u0002\u0002\\u059A\\u05A1\u0005\\xDFp\u0002\\u059B\\u059D\\x07a\u0002\u0002\\u059C\\u059B\u0003\u0002\u0002\u0002\\u059C\\u059D\u0003\u0002\u0002\u0002\\u059D\\u059E\u0003\u0002\u0002\u0002\\u059E\\u05A0\u0005\\xDFp\u0002\\u059F\\u059C\u0003\u0002\u0002\u0002\\u05A0\\u05A3\u0003\u0002\u0002\u0002\\u05A1\\u059F\u0003\u0002\u0002\u0002\\u05A1\\u05A2\u0003\u0002\u0002\u0002\\u05A2\\xD8\u0003\u0002\u0002\u0002\\u05A3\\u05A1\u0003\u0002\u0002\u0002\\u05A4\\u05A5\\x07y\u0002\u0002\\u05A5\\u05A6\\x07g\u0002\u0002\\u05A6\\u05DD\\x07k\u0002\u0002\\u05A7\\u05A8\\x07i\u0002\u0002\\u05A8\\u05A9\\x07y\u0002\u0002\\u05A9\\u05AA\\x07g\u0002\u0002\\u05AA\\u05DD\\x07k\u0002\u0002\\u05AB\\u05AC\\x07u\u0002\u0002\\u05AC\\u05AD\\x07|\u0002\u0002\\u05AD\\u05AE\\x07c\u0002\u0002\\u05AE\\u05AF\\x07d\u0002\u0002\\u05AF\\u05DD\\x07q\u0002\u0002\\u05B0\\u05B1\\x07h\u0002\u0002\\u05B1\\u05B2\\x07k\u0002\u0002\\u05B2\\u05B3\\x07p\u0002\u0002\\u05B3\\u05B4\\x07p\u0002\u0002\\u05B4\\u05B5\\x07g\u0002\u0002\\u05B5\\u05DD\\x07{\u0002\u0002\\u05B6\\u05B7\\x07g\u0002\u0002\\u05B7\\u05B8\\x07v\u0002\u0002\\u05B8\\u05B9\\x07j\u0002\u0002\\u05B9\\u05BA\\x07g\u0002\u0002\\u05BA\\u05DD\\x07t\u0002\u0002\\u05BB\\u05BC\\x07u\u0002\u0002\\u05BC\\u05BD\\x07g\u0002\u0002\\u05BD\\u05BE\\x07e\u0002\u0002\\u05BE\\u05BF\\x07q\u0002\u0002\\u05BF\\u05C0\\x07p\u0002\u0002\\u05C0\\u05C1\\x07f\u0002\u0002\\u05C1\\u05DD\\x07u\u0002\u0002\\u05C2\\u05C3\\x07o\u0002\u0002\\u05C3\\u05C4\\x07k\u0002\u0002\\u05C4\\u05C5\\x07p\u0002\u0002\\u05C5\\u05C6\\x07w\u0002\u0002\\u05C6\\u05C7\\x07v\u0002\u0002\\u05C7\\u05C8\\x07g\u0002\u0002\\u05C8\\u05DD\\x07u\u0002\u0002\\u05C9\\u05CA\\x07j\u0002\u0002\\u05CA\\u05CB\\x07q\u0002\u0002\\u05CB\\u05CC\\x07w\u0002\u0002\\u05CC\\u05CD\\x07t\u0002\u0002\\u05CD\\u05DD\\x07u\u0002\u0002\\u05CE\\u05CF\\x07f\u0002\u0002\\u05CF\\u05D0\\x07c\u0002\u0002\\u05D0\\u05D1\\x07{\u0002\u0002\\u05D1\\u05DD\\x07u\u0002\u0002\\u05D2\\u05D3\\x07y\u0002\u0002\\u05D3\\u05D4\\x07g\u0002\u0002\\u05D4\\u05D5\\x07g\u0002\u0002\\u05D5\\u05D6\\x07m\u0002\u0002\\u05D6\\u05DD\\x07u\u0002\u0002\\u05D7\\u05D8\\x07{\u0002\u0002\\u05D8\\u05D9\\x07g\u0002\u0002\\u05D9\\u05DA\\x07c\u0002\u0002\\u05DA\\u05DB\\x07t\u0002\u0002\\u05DB\\u05DD\\x07u\u0002\u0002\\u05DC\\u05A4\u0003\u0002\u0002\u0002\\u05DC\\u05A7\u0003\u0002\u0002\u0002\\u05DC\\u05AB\u0003\u0002\u0002\u0002\\u05DC\\u05B0\u0003\u0002\u0002\u0002\\u05DC\\u05B6\u0003\u0002\u0002\u0002\\u05DC\\u05BB\u0003\u0002\u0002\u0002\\u05DC\\u05C2\u0003\u0002\u0002\u0002\\u05DC\\u05C9\u0003\u0002\u0002\u0002\\u05DC\\u05CE\u0003\u0002\u0002\u0002\\u05DC\\u05D2\u0003\u0002\u0002\u0002\\u05DC\\u05D7\u0003\u0002\u0002\u0002\\u05DD\\xDA\u0003\u0002\u0002\u0002\\u05DE\\u05DF\\x07j\u0002\u0002\\u05DF\\u05E0\\x07g\u0002\u0002\\u05E0\\u05E1\\x07z\u0002\u0002\\u05E1\\u05EC\u0003\u0002\u0002\u0002\\u05E2\\u05E4\\x07$\u0002\u0002\\u05E3\\u05E5\u0005\\xD7l\u0002\\u05E4\\u05E3\u0003\u0002\u0002\u0002\\u05E4\\u05E5\u0003\u0002\u0002\u0002\\u05E5\\u05E6\u0003\u0002\u0002\u0002\\u05E6\\u05ED\\x07$\u0002\u0002\\u05E7\\u05E9\\x07)\u0002\u0002\\u05E8\\u05EA\u0005\\xD7l\u0002\\u05E9\\u05E8\u0003\u0002\u0002\u0002\\u05E9\\u05EA\u0003\u0002\u0002\u0002\\u05EA\\u05EB\u0003\u0002\u0002\u0002\\u05EB\\u05ED\\x07)\u0002\u0002\\u05EC\\u05E2\u0003\u0002\u0002\u0002\\u05EC\\u05E7\u0003\u0002\u0002\u0002\\u05ED\\xDC\u0003\u0002\u0002\u0002\\u05EE\\u05EF\u0005\\xDFp\u0002\\u05EF\\u05F0\u0005\\xDFp\u0002\\u05F0\\xDE\u0003\u0002\u0002\u0002\\u05F1\\u05F2\t\u0005\u0002\u0002\\u05F2\\xE0\u0003\u0002\u0002\u0002\\u05F3\\u05F4\\x07c\u0002\u0002\\u05F4\\u05F5\\x07d\u0002\u0002\\u05F5\\u05F6\\x07u\u0002\u0002\\u05F6\\u05F7\\x07v\u0002\u0002\\u05F7\\u05F8\\x07t\u0002\u0002\\u05F8\\u05F9\\x07c\u0002\u0002\\u05F9\\u05FA\\x07e\u0002\u0002\\u05FA\\u064C\\x07v\u0002\u0002\\u05FB\\u05FC\\x07c\u0002\u0002\\u05FC\\u05FD\\x07h\u0002\u0002\\u05FD\\u05FE\\x07v\u0002\u0002\\u05FE\\u05FF\\x07g\u0002\u0002\\u05FF\\u064C\\x07t\u0002\u0002\\u0600\\u0601\\x07e\u0002\u0002\\u0601\\u0602\\x07c\u0002\u0002\\u0602\\u0603\\x07u\u0002\u0002\\u0603\\u064C\\x07g\u0002\u0002\\u0604\\u0605\\x07e\u0002\u0002\\u0605\\u0606\\x07c\u0002\u0002\\u0606\\u0607\\x07v\u0002\u0002\\u0607\\u0608\\x07e\u0002\u0002\\u0608\\u064C\\x07j\u0002\u0002\\u0609\\u060A\\x07f\u0002\u0002\\u060A\\u060B\\x07g\u0002\u0002\\u060B\\u060C\\x07h\u0002\u0002\\u060C\\u060D\\x07c\u0002\u0002\\u060D\\u060E\\x07w\u0002\u0002\\u060E\\u060F\\x07n\u0002\u0002\\u060F\\u064C\\x07v\u0002\u0002\\u0610\\u0611\\x07h\u0002\u0002\\u0611\\u0612\\x07k\u0002\u0002\\u0612\\u0613\\x07p\u0002\u0002\\u0613\\u0614\\x07c\u0002\u0002\\u0614\\u064C\\x07n\u0002\u0002\\u0615\\u0616\\x07k\u0002\u0002\\u0616\\u064C\\x07p\u0002\u0002\\u0617\\u0618\\x07k\u0002\u0002\\u0618\\u0619\\x07p\u0002\u0002\\u0619\\u061A\\x07n\u0002\u0002\\u061A\\u061B\\x07k\u0002\u0002\\u061B\\u061C\\x07p\u0002\u0002\\u061C\\u064C\\x07g\u0002\u0002\\u061D\\u061E\\x07n\u0002\u0002\\u061E\\u061F\\x07g\u0002\u0002\\u061F\\u064C\\x07v\u0002\u0002\\u0620\\u0621\\x07o\u0002\u0002\\u0621\\u0622\\x07c\u0002\u0002\\u0622\\u0623\\x07v\u0002\u0002\\u0623\\u0624\\x07e\u0002\u0002\\u0624\\u064C\\x07j\u0002\u0002\\u0625\\u0626\\x07p\u0002\u0002\\u0626\\u0627\\x07w\u0002\u0002\\u0627\\u0628\\x07n\u0002\u0002\\u0628\\u064C\\x07n\u0002\u0002\\u0629\\u062A\\x07q\u0002\u0002\\u062A\\u064C\\x07h\u0002\u0002\\u062B\\u062C\\x07t\u0002\u0002\\u062C\\u062D\\x07g\u0002\u0002\\u062D\\u062E\\x07n\u0002\u0002\\u062E\\u062F\\x07q\u0002\u0002\\u062F\\u0630\\x07e\u0002\u0002\\u0630\\u0631\\x07c\u0002\u0002\\u0631\\u0632\\x07v\u0002\u0002\\u0632\\u0633\\x07c\u0002\u0002\\u0633\\u0634\\x07d\u0002\u0002\\u0634\\u0635\\x07n\u0002\u0002\\u0635\\u064C\\x07g\u0002\u0002\\u0636\\u0637\\x07u\u0002\u0002\\u0637\\u0638\\x07v\u0002\u0002\\u0638\\u0639\\x07c\u0002\u0002\\u0639\\u063A\\x07v\u0002\u0002\\u063A\\u063B\\x07k\u0002\u0002\\u063B\\u064C\\x07e\u0002\u0002\\u063C\\u063D\\x07u\u0002\u0002\\u063D\\u063E\\x07y\u0002\u0002\\u063E\\u063F\\x07k\u0002\u0002\\u063F\\u0640\\x07v\u0002\u0002\\u0640\\u0641\\x07e\u0002\u0002\\u0641\\u064C\\x07j\u0002\u0002\\u0642\\u0643\\x07v\u0002\u0002\\u0643\\u0644\\x07t\u0002\u0002\\u0644\\u064C\\x07{\u0002\u0002\\u0645\\u0646\\x07v\u0002\u0002\\u0646\\u0647\\x07{\u0002\u0002\\u0647\\u0648\\x07r\u0002\u0002\\u0648\\u0649\\x07g\u0002\u0002\\u0649\\u064A\\x07q\u0002\u0002\\u064A\\u064C\\x07h\u0002\u0002\\u064B\\u05F3\u0003\u0002\u0002\u0002\\u064B\\u05FB\u0003\u0002\u0002\u0002\\u064B\\u0600\u0003\u0002\u0002\u0002\\u064B\\u0604\u0003\u0002\u0002\u0002\\u064B\\u0609\u0003\u0002\u0002\u0002\\u064B\\u0610\u0003\u0002\u0002\u0002\\u064B\\u0615\u0003\u0002\u0002\u0002\\u064B\\u0617\u0003\u0002\u0002\u0002\\u064B\\u061D\u0003\u0002\u0002\u0002\\u064B\\u0620\u0003\u0002\u0002\u0002\\u064B\\u0625\u0003\u0002\u0002\u0002\\u064B\\u0629\u0003\u0002\u0002\u0002\\u064B\\u062B\u0003\u0002\u0002\u0002\\u064B\\u0636\u0003\u0002\u0002\u0002\\u064B\\u063C\u0003\u0002\u0002\u0002\\u064B\\u0642\u0003\u0002\u0002\u0002\\u064B\\u0645\u0003\u0002\u0002\u0002\\u064C\\xE2\u0003\u0002\u0002\u0002\\u064D\\u064E\\x07c\u0002\u0002\\u064E\\u064F\\x07p\u0002\u0002\\u064F\\u0650\\x07q\u0002\u0002\\u0650\\u0651\\x07p\u0002\u0002\\u0651\\u0652\\x07{\u0002\u0002\\u0652\\u0653\\x07o\u0002\u0002\\u0653\\u0654\\x07q\u0002\u0002\\u0654\\u0655\\x07w\u0002\u0002\\u0655\\u0656\\x07u\u0002\u0002\\u0656\\xE4\u0003\u0002\u0002\u0002\\u0657\\u0658\\x07d\u0002\u0002\\u0658\\u0659\\x07t\u0002\u0002\\u0659\\u065A\\x07g\u0002\u0002\\u065A\\u065B\\x07c\u0002\u0002\\u065B\\u065C\\x07m\u0002\u0002\\u065C\\xE6\u0003\u0002\u0002\u0002\\u065D\\u065E\\x07e\u0002\u0002\\u065E\\u065F\\x07q\u0002\u0002\\u065F\\u0660\\x07p\u0002\u0002\\u0660\\u0661\\x07u\u0002\u0002\\u0661\\u0662\\x07v\u0002\u0002\\u0662\\u0663\\x07c\u0002\u0002\\u0663\\u0664\\x07p\u0002\u0002\\u0664\\u0665\\x07v\u0002\u0002\\u0665\\xE8\u0003\u0002\u0002\u0002\\u0666\\u0667\\x07k\u0002\u0002\\u0667\\u0668\\x07o\u0002\u0002\\u0668\\u0669\\x07o\u0002\u0002\\u0669\\u066A\\x07w\u0002\u0002\\u066A\\u066B\\x07v\u0002\u0002\\u066B\\u066C\\x07c\u0002\u0002\\u066C\\u066D\\x07d\u0002\u0002\\u066D\\u066E\\x07n\u0002\u0002\\u066E\\u066F\\x07g\u0002\u0002\\u066F\\xEA\u0003\u0002\u0002\u0002\\u0670\\u0671\\x07e\u0002\u0002\\u0671\\u0672\\x07q\";\nSolidityLexer._serializedATNSegment3 = \"\u0002\u0002\\u0672\\u0673\\x07p\u0002\u0002\\u0673\\u0674\\x07v\u0002\u0002\\u0674\\u0675\\x07k\u0002\u0002\\u0675\\u0676\\x07p\u0002\u0002\\u0676\\u0677\\x07w\u0002\u0002\\u0677\\u0678\\x07g\u0002\u0002\\u0678\\xEC\u0003\u0002\u0002\u0002\\u0679\\u067A\\x07n\u0002\u0002\\u067A\\u067B\\x07g\u0002\u0002\\u067B\\u067C\\x07c\u0002\u0002\\u067C\\u067D\\x07x\u0002\u0002\\u067D\\u067E\\x07g\u0002\u0002\\u067E\\xEE\u0003\u0002\u0002\u0002\\u067F\\u0680\\x07g\u0002\u0002\\u0680\\u0681\\x07z\u0002\u0002\\u0681\\u0682\\x07v\u0002\u0002\\u0682\\u0683\\x07g\u0002\u0002\\u0683\\u0684\\x07t\u0002\u0002\\u0684\\u0685\\x07p\u0002\u0002\\u0685\\u0686\\x07c\u0002\u0002\\u0686\\u0687\\x07n\u0002\u0002\\u0687\\xF0\u0003\u0002\u0002\u0002\\u0688\\u0689\\x07k\u0002\u0002\\u0689\\u068A\\x07p\u0002\u0002\\u068A\\u068B\\x07f\u0002\u0002\\u068B\\u068C\\x07g\u0002\u0002\\u068C\\u068D\\x07z\u0002\u0002\\u068D\\u068E\\x07g\u0002\u0002\\u068E\\u068F\\x07f\u0002\u0002\\u068F\\xF2\u0003\u0002\u0002\u0002\\u0690\\u0691\\x07k\u0002\u0002\\u0691\\u0692\\x07p\u0002\u0002\\u0692\\u0693\\x07v\u0002\u0002\\u0693\\u0694\\x07g\u0002\u0002\\u0694\\u0695\\x07t\u0002\u0002\\u0695\\u0696\\x07p\u0002\u0002\\u0696\\u0697\\x07c\u0002\u0002\\u0697\\u0698\\x07n\u0002\u0002\\u0698\\xF4\u0003\u0002\u0002\u0002\\u0699\\u069A\\x07r\u0002\u0002\\u069A\\u069B\\x07c\u0002\u0002\\u069B\\u069C\\x07{\u0002\u0002\\u069C\\u069D\\x07c\u0002\u0002\\u069D\\u069E\\x07d\u0002\u0002\\u069E\\u069F\\x07n\u0002\u0002\\u069F\\u06A0\\x07g\u0002\u0002\\u06A0\\xF6\u0003\u0002\u0002\u0002\\u06A1\\u06A2\\x07r\u0002\u0002\\u06A2\\u06A3\\x07t\u0002\u0002\\u06A3\\u06A4\\x07k\u0002\u0002\\u06A4\\u06A5\\x07x\u0002\u0002\\u06A5\\u06A6\\x07c\u0002\u0002\\u06A6\\u06A7\\x07v\u0002\u0002\\u06A7\\u06A8\\x07g\u0002\u0002\\u06A8\\xF8\u0003\u0002\u0002\u0002\\u06A9\\u06AA\\x07r\u0002\u0002\\u06AA\\u06AB\\x07w\u0002\u0002\\u06AB\\u06AC\\x07d\u0002\u0002\\u06AC\\u06AD\\x07n\u0002\u0002\\u06AD\\u06AE\\x07k\u0002\u0002\\u06AE\\u06AF\\x07e\u0002\u0002\\u06AF\\xFA\u0003\u0002\u0002\u0002\\u06B0\\u06B1\\x07x\u0002\u0002\\u06B1\\u06B2\\x07k\u0002\u0002\\u06B2\\u06B3\\x07t\u0002\u0002\\u06B3\\u06B4\\x07v\u0002\u0002\\u06B4\\u06B5\\x07w\u0002\u0002\\u06B5\\u06B6\\x07c\u0002\u0002\\u06B6\\u06B7\\x07n\u0002\u0002\\u06B7\\xFC\u0003\u0002\u0002\u0002\\u06B8\\u06B9\\x07r\u0002\u0002\\u06B9\\u06BA\\x07w\u0002\u0002\\u06BA\\u06BB\\x07t\u0002\u0002\\u06BB\\u06BC\\x07g\u0002\u0002\\u06BC\\xFE\u0003\u0002\u0002\u0002\\u06BD\\u06BE\\x07v\u0002\u0002\\u06BE\\u06BF\\x07{\u0002\u0002\\u06BF\\u06C0\\x07r\u0002\u0002\\u06C0\\u06C1\\x07g\u0002\u0002\\u06C1\\u0100\u0003\u0002\u0002\u0002\\u06C2\\u06C3\\x07x\u0002\u0002\\u06C3\\u06C4\\x07k\u0002\u0002\\u06C4\\u06C5\\x07g\u0002\u0002\\u06C5\\u06C6\\x07y\u0002\u0002\\u06C6\\u0102\u0003\u0002\u0002\u0002\\u06C7\\u06C8\\x07i\u0002\u0002\\u06C8\\u06C9\\x07n\u0002\u0002\\u06C9\\u06CA\\x07q\u0002\u0002\\u06CA\\u06CB\\x07d\u0002\u0002\\u06CB\\u06CC\\x07c\u0002\u0002\\u06CC\\u06CD\\x07n\u0002\u0002\\u06CD\\u0104\u0003\u0002\u0002\u0002\\u06CE\\u06CF\\x07e\u0002\u0002\\u06CF\\u06D0\\x07q\u0002\u0002\\u06D0\\u06D1\\x07p\u0002\u0002\\u06D1\\u06D2\\x07u\u0002\u0002\\u06D2\\u06D3\\x07v\u0002\u0002\\u06D3\\u06D4\\x07t\u0002\u0002\\u06D4\\u06D5\\x07w\u0002\u0002\\u06D5\\u06D6\\x07e\u0002\u0002\\u06D6\\u06D7\\x07v\u0002\u0002\\u06D7\\u06D8\\x07q\u0002\u0002\\u06D8\\u06D9\\x07t\u0002\u0002\\u06D9\\u0106\u0003\u0002\u0002\u0002\\u06DA\\u06DB\\x07h\u0002\u0002\\u06DB\\u06DC\\x07c\u0002\u0002\\u06DC\\u06DD\\x07n\u0002\u0002\\u06DD\\u06DE\\x07n\u0002\u0002\\u06DE\\u06DF\\x07d\u0002\u0002\\u06DF\\u06E0\\x07c\u0002\u0002\\u06E0\\u06E1\\x07e\u0002\u0002\\u06E1\\u06E2\\x07m\u0002\u0002\\u06E2\\u0108\u0003\u0002\u0002\u0002\\u06E3\\u06E4\\x07t\u0002\u0002\\u06E4\\u06E5\\x07g\u0002\u0002\\u06E5\\u06E6\\x07e\u0002\u0002\\u06E6\\u06E7\\x07g\u0002\u0002\\u06E7\\u06E8\\x07k\u0002\u0002\\u06E8\\u06E9\\x07x\u0002\u0002\\u06E9\\u06EA\\x07g\u0002\u0002\\u06EA\\u010A\u0003\u0002\u0002\u0002\\u06EB\\u06EF\u0005\\u010D\\x87\u0002\\u06EC\\u06EE\u0005\\u010F\\x88\u0002\\u06ED\\u06EC\u0003\u0002\u0002\u0002\\u06EE\\u06F1\u0003\u0002\u0002\u0002\\u06EF\\u06ED\u0003\u0002\u0002\u0002\\u06EF\\u06F0\u0003\u0002\u0002\u0002\\u06F0\\u010C\u0003\u0002\u0002\u0002\\u06F1\\u06EF\u0003\u0002\u0002\u0002\\u06F2\\u06F3\t\u0006\u0002\u0002\\u06F3\\u010E\u0003\u0002\u0002\u0002\\u06F4\\u06F5\t\\x07\u0002\u0002\\u06F5\\u0110\u0003\u0002\u0002\u0002\\u06F6\\u06F7\\x07w\u0002\u0002\\u06F7\\u06F8\\x07p\u0002\u0002\\u06F8\\u06F9\\x07k\u0002\u0002\\u06F9\\u06FA\\x07e\u0002\u0002\\u06FA\\u06FB\\x07q\u0002\u0002\\u06FB\\u06FC\\x07f\u0002\u0002\\u06FC\\u06FE\\x07g\u0002\u0002\\u06FD\\u06F6\u0003\u0002\u0002\u0002\\u06FD\\u06FE\u0003\u0002\u0002\u0002\\u06FE\\u06FF\u0003\u0002\u0002\u0002\\u06FF\\u0703\\x07$\u0002\u0002\\u0700\\u0702\u0005\\u0113\\x8A\u0002\\u0701\\u0700\u0003\u0002\u0002\u0002\\u0702\\u0705\u0003\u0002\u0002\u0002\\u0703\\u0701\u0003\u0002\u0002\u0002\\u0703\\u0704\u0003\u0002\u0002\u0002\\u0704\\u0706\u0003\u0002\u0002\u0002\\u0705\\u0703\u0003\u0002\u0002\u0002\\u0706\\u0719\\x07$\u0002\u0002\\u0707\\u0708\\x07w\u0002\u0002\\u0708\\u0709\\x07p\u0002\u0002\\u0709\\u070A\\x07k\u0002\u0002\\u070A\\u070B\\x07e\u0002\u0002\\u070B\\u070C\\x07q\u0002\u0002\\u070C\\u070D\\x07f\u0002\u0002\\u070D\\u070F\\x07g\u0002\u0002\\u070E\\u0707\u0003\u0002\u0002\u0002\\u070E\\u070F\u0003\u0002\u0002\u0002\\u070F\\u0710\u0003\u0002\u0002\u0002\\u0710\\u0714\\x07)\u0002\u0002\\u0711\\u0713\u0005\\u0115\\x8B\u0002\\u0712\\u0711\u0003\u0002\u0002\u0002\\u0713\\u0716\u0003\u0002\u0002\u0002\\u0714\\u0712\u0003\u0002\u0002\u0002\\u0714\\u0715\u0003\u0002\u0002\u0002\\u0715\\u0717\u0003\u0002\u0002\u0002\\u0716\\u0714\u0003\u0002\u0002\u0002\\u0717\\u0719\\x07)\u0002\u0002\\u0718\\u06FD\u0003\u0002\u0002\u0002\\u0718\\u070E\u0003\u0002\u0002\u0002\\u0719\\u0112\u0003\u0002\u0002\u0002\\u071A\\u071E\\n\\b\u0002\u0002\\u071B\\u071C\\x07^\u0002\u0002\\u071C\\u071E\\v\u0002\u0002\u0002\\u071D\\u071A\u0003\u0002\u0002\u0002\\u071D\\u071B\u0003\u0002\u0002\u0002\\u071E\\u0114\u0003\u0002\u0002\u0002\\u071F\\u0723\\n\t\u0002\u0002\\u0720\\u0721\\x07^\u0002\u0002\\u0721\\u0723\\v\u0002\u0002\u0002\\u0722\\u071F\u0003\u0002\u0002\u0002\\u0722\\u0720\u0003\u0002\u0002\u0002\\u0723\\u0116\u0003\u0002\u0002\u0002\\u0724\\u0726\t\u0002\u0002\u0002\\u0725\\u0724\u0003\u0002\u0002\u0002\\u0726\\u0727\u0003\u0002\u0002\u0002\\u0727\\u0725\u0003\u0002\u0002\u0002\\u0727\\u0728\u0003\u0002\u0002\u0002\\u0728\\u0729\u0003\u0002\u0002\u0002\\u0729\\u072B\\x070\u0002\u0002\\u072A\\u072C\t\u0002\u0002\u0002\\u072B\\u072A\u0003\u0002\u0002\u0002\\u072C\\u072D\u0003\u0002\u0002\u0002\\u072D\\u072B\u0003\u0002\u0002\u0002\\u072D\\u072E\u0003\u0002\u0002\u0002\\u072E\\u0735\u0003\u0002\u0002\u0002\\u072F\\u0731\\x070\u0002\u0002\\u0730\\u0732\t\u0002\u0002\u0002\\u0731\\u0730\u0003\u0002\u0002\u0002\\u0732\\u0733\u0003\u0002\u0002\u0002\\u0733\\u0731\u0003\u0002\u0002\u0002\\u0733\\u0734\u0003\u0002\u0002\u0002\\u0734\\u0736\u0003\u0002\u0002\u0002\\u0735\\u072F\u0003\u0002\u0002\u0002\\u0735\\u0736\u0003\u0002\u0002\u0002\\u0736\\u0118\u0003\u0002\u0002\u0002\\u0737\\u0739\t\\n\u0002\u0002\\u0738\\u0737\u0003\u0002\u0002\u0002\\u0739\\u073A\u0003\u0002\u0002\u0002\\u073A\\u0738\u0003\u0002\u0002\u0002\\u073A\\u073B\u0003\u0002\u0002\u0002\\u073B\\u073C\u0003\u0002\u0002\u0002\\u073C\\u073D\\b\\x8D\u0002\u0002\\u073D\\u011A\u0003\u0002\u0002\u0002\\u073E\\u073F\\x071\u0002\u0002\\u073F\\u0740\\x07,\u0002\u0002\\u0740\\u0744\u0003\u0002\u0002\u0002\\u0741\\u0743\\v\u0002\u0002\u0002\\u0742\\u0741\u0003\u0002\u0002\u0002\\u0743\\u0746\u0003\u0002\u0002\u0002\\u0744\\u0745\u0003\u0002\u0002\u0002\\u0744\\u0742\u0003\u0002\u0002\u0002\\u0745\\u0747\u0003\u0002\u0002\u0002\\u0746\\u0744\u0003\u0002\u0002\u0002\\u0747\\u0748\\x07,\u0002\u0002\\u0748\\u0749\\x071\u0002\u0002\\u0749\\u074A\u0003\u0002\u0002\u0002\\u074A\\u074B\\b\\x8E\u0003\u0002\\u074B\\u011C\u0003\u0002\u0002\u0002\\u074C\\u074D\\x071\u0002\u0002\\u074D\\u074E\\x071\u0002\u0002\\u074E\\u0752\u0003\u0002\u0002\u0002\\u074F\\u0751\\n\\v\u0002\u0002\\u0750\\u074F\u0003\u0002\u0002\u0002\\u0751\\u0754\u0003\u0002\u0002\u0002\\u0752\\u0750\u0003\u0002\u0002\u0002\\u0752\\u0753\u0003\u0002\u0002\u0002\\u0753\\u0755\u0003\u0002\u0002\u0002\\u0754\\u0752\u0003\u0002\u0002\u0002\\u0755\\u0756\\b\\x8F\u0003\u0002\\u0756\\u011E\u0003\u0002\u0002\u0002(\u0002\\u038A\\u0463\\u0541\\u0551\\u0557\\u0559\\u056B\\u0571\\u0573\\u057E\\u0582\\u0586\\u058A\\u058E\\u0593\\u059C\\u05A1\\u05DC\\u05E4\\u05E9\\u05EC\\u064B\\u06EF\\u06FD\\u0703\\u070E\\u0714\\u0718\\u071D\\u0722\\u0727\\u072D\\u0733\\u0735\\u073A\\u0744\\u0752\u0004\\b\u0002\u0002\u0002\u0003\u0002\";\nSolidityLexer._serializedATN = Utils.join([\n  _SolidityLexer._serializedATNSegment0,\n  _SolidityLexer._serializedATNSegment1,\n  _SolidityLexer._serializedATNSegment2,\n  _SolidityLexer._serializedATNSegment3\n], \"\");\n\n// src/antlr/SolidityParser.ts\nvar import_ATN = __toModule(require_ATN());\nvar import_ATNDeserializer2 = __toModule(require_ATNDeserializer());\nvar import_FailedPredicateException = __toModule(require_FailedPredicateException());\nvar import_NoViableAltException = __toModule(require_NoViableAltException());\nvar import_Parser = __toModule(require_Parser());\nvar import_ParserRuleContext = __toModule(require_ParserRuleContext());\nvar import_ParserATNSimulator = __toModule(require_ParserATNSimulator());\nvar import_RecognitionException = __toModule(require_RecognitionException());\nvar import_Token = __toModule(require_Token());\nvar import_VocabularyImpl2 = __toModule(require_VocabularyImpl());\nvar Utils2 = __toModule(require_Utils());\nvar _SolidityParser = class extends import_Parser.Parser {\n  get vocabulary() {\n    return _SolidityParser.VOCABULARY;\n  }\n  get grammarFileName() {\n    return \"Solidity.g4\";\n  }\n  get ruleNames() {\n    return _SolidityParser.ruleNames;\n  }\n  get serializedATN() {\n    return _SolidityParser._serializedATN;\n  }\n  createFailedPredicateException(predicate, message) {\n    return new import_FailedPredicateException.FailedPredicateException(this, predicate, message);\n  }\n  constructor(input) {\n    super(input);\n    this._interp = new import_ParserATNSimulator.ParserATNSimulator(_SolidityParser._ATN, this);\n  }\n  sourceUnit() {\n    let _localctx = new SourceUnitContext(this._ctx, this.state);\n    this.enterRule(_localctx, 0, _SolidityParser.RULE_sourceUnit);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 208;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        while ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__0 | 1 << _SolidityParser.T__12 | 1 << _SolidityParser.T__13 | 1 << _SolidityParser.T__17 | 1 << _SolidityParser.T__18 | 1 << _SolidityParser.T__19 | 1 << _SolidityParser.T__20 | 1 << _SolidityParser.T__24 | 1 << _SolidityParser.T__25 | 1 << _SolidityParser.T__27 | 1 << _SolidityParser.T__29)) !== 0 || (_la - 33 & ~31) === 0 && (1 << _la - 33 & (1 << _SolidityParser.T__32 - 33 | 1 << _SolidityParser.T__35 - 33 | 1 << _SolidityParser.T__37 - 33 | 1 << _SolidityParser.T__41 - 33 | 1 << _SolidityParser.T__53 - 33 | 1 << _SolidityParser.T__54 - 33 | 1 << _SolidityParser.T__55 - 33 | 1 << _SolidityParser.T__56 - 33 | 1 << _SolidityParser.T__57 - 33)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96 | 1 << _SolidityParser.FallbackKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {\n          {\n            this.state = 206;\n            this._errHandler.sync(this);\n            switch (this.interpreter.adaptivePredict(this._input, 0, this._ctx)) {\n              case 1:\n                {\n                  this.state = 196;\n                  this.pragmaDirective();\n                }\n                break;\n              case 2:\n                {\n                  this.state = 197;\n                  this.importDirective();\n                }\n                break;\n              case 3:\n                {\n                  this.state = 198;\n                  this.contractDefinition();\n                }\n                break;\n              case 4:\n                {\n                  this.state = 199;\n                  this.enumDefinition();\n                }\n                break;\n              case 5:\n                {\n                  this.state = 200;\n                  this.structDefinition();\n                }\n                break;\n              case 6:\n                {\n                  this.state = 201;\n                  this.functionDefinition();\n                }\n                break;\n              case 7:\n                {\n                  this.state = 202;\n                  this.fileLevelConstant();\n                }\n                break;\n              case 8:\n                {\n                  this.state = 203;\n                  this.customErrorDefinition();\n                }\n                break;\n              case 9:\n                {\n                  this.state = 204;\n                  this.typeDefinition();\n                }\n                break;\n              case 10:\n                {\n                  this.state = 205;\n                  this.usingForDeclaration();\n                }\n                break;\n            }\n          }\n          this.state = 210;\n          this._errHandler.sync(this);\n          _la = this._input.LA(1);\n        }\n        this.state = 211;\n        this.match(_SolidityParser.EOF);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  pragmaDirective() {\n    let _localctx = new PragmaDirectiveContext(this._ctx, this.state);\n    this.enterRule(_localctx, 2, _SolidityParser.RULE_pragmaDirective);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 213;\n        this.match(_SolidityParser.T__0);\n        this.state = 214;\n        this.pragmaName();\n        this.state = 215;\n        this.pragmaValue();\n        this.state = 216;\n        this.match(_SolidityParser.T__1);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  pragmaName() {\n    let _localctx = new PragmaNameContext(this._ctx, this.state);\n    this.enterRule(_localctx, 4, _SolidityParser.RULE_pragmaName);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 218;\n        this.identifier();\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  pragmaValue() {\n    let _localctx = new PragmaValueContext(this._ctx, this.state);\n    this.enterRule(_localctx, 6, _SolidityParser.RULE_pragmaValue);\n    try {\n      this.state = 223;\n      this._errHandler.sync(this);\n      switch (this.interpreter.adaptivePredict(this._input, 2, this._ctx)) {\n        case 1:\n          this.enterOuterAlt(_localctx, 1);\n          {\n            this.state = 220;\n            this.match(_SolidityParser.T__2);\n          }\n          break;\n        case 2:\n          this.enterOuterAlt(_localctx, 2);\n          {\n            this.state = 221;\n            this.version();\n          }\n          break;\n        case 3:\n          this.enterOuterAlt(_localctx, 3);\n          {\n            this.state = 222;\n            this.expression(0);\n          }\n          break;\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  version() {\n    let _localctx = new VersionContext(this._ctx, this.state);\n    this.enterRule(_localctx, 8, _SolidityParser.RULE_version);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 225;\n        this.versionConstraint();\n        this.state = 232;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        while ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__3 | 1 << _SolidityParser.T__4 | 1 << _SolidityParser.T__5 | 1 << _SolidityParser.T__6 | 1 << _SolidityParser.T__7 | 1 << _SolidityParser.T__8 | 1 << _SolidityParser.T__9 | 1 << _SolidityParser.T__10)) !== 0 || _la === _SolidityParser.DecimalNumber || _la === _SolidityParser.VersionLiteral) {\n          {\n            {\n              this.state = 227;\n              this._errHandler.sync(this);\n              _la = this._input.LA(1);\n              if (_la === _SolidityParser.T__3) {\n                {\n                  this.state = 226;\n                  this.match(_SolidityParser.T__3);\n                }\n              }\n              this.state = 229;\n              this.versionConstraint();\n            }\n          }\n          this.state = 234;\n          this._errHandler.sync(this);\n          _la = this._input.LA(1);\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  versionOperator() {\n    let _localctx = new VersionOperatorContext(this._ctx, this.state);\n    this.enterRule(_localctx, 10, _SolidityParser.RULE_versionOperator);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 235;\n        _la = this._input.LA(1);\n        if (!((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__4 | 1 << _SolidityParser.T__5 | 1 << _SolidityParser.T__6 | 1 << _SolidityParser.T__7 | 1 << _SolidityParser.T__8 | 1 << _SolidityParser.T__9 | 1 << _SolidityParser.T__10)) !== 0)) {\n          this._errHandler.recoverInline(this);\n        } else {\n          if (this._input.LA(1) === import_Token.Token.EOF) {\n            this.matchedEOF = true;\n          }\n          this._errHandler.reportMatch(this);\n          this.consume();\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  versionConstraint() {\n    let _localctx = new VersionConstraintContext(this._ctx, this.state);\n    this.enterRule(_localctx, 12, _SolidityParser.RULE_versionConstraint);\n    let _la;\n    try {\n      this.state = 245;\n      this._errHandler.sync(this);\n      switch (this.interpreter.adaptivePredict(this._input, 7, this._ctx)) {\n        case 1:\n          this.enterOuterAlt(_localctx, 1);\n          {\n            this.state = 238;\n            this._errHandler.sync(this);\n            _la = this._input.LA(1);\n            if ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__4 | 1 << _SolidityParser.T__5 | 1 << _SolidityParser.T__6 | 1 << _SolidityParser.T__7 | 1 << _SolidityParser.T__8 | 1 << _SolidityParser.T__9 | 1 << _SolidityParser.T__10)) !== 0) {\n              {\n                this.state = 237;\n                this.versionOperator();\n              }\n            }\n            this.state = 240;\n            this.match(_SolidityParser.VersionLiteral);\n          }\n          break;\n        case 2:\n          this.enterOuterAlt(_localctx, 2);\n          {\n            this.state = 242;\n            this._errHandler.sync(this);\n            _la = this._input.LA(1);\n            if ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__4 | 1 << _SolidityParser.T__5 | 1 << _SolidityParser.T__6 | 1 << _SolidityParser.T__7 | 1 << _SolidityParser.T__8 | 1 << _SolidityParser.T__9 | 1 << _SolidityParser.T__10)) !== 0) {\n              {\n                this.state = 241;\n                this.versionOperator();\n              }\n            }\n            this.state = 244;\n            this.match(_SolidityParser.DecimalNumber);\n          }\n          break;\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  importDeclaration() {\n    let _localctx = new ImportDeclarationContext(this._ctx, this.state);\n    this.enterRule(_localctx, 14, _SolidityParser.RULE_importDeclaration);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 247;\n        this.identifier();\n        this.state = 250;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.T__11) {\n          {\n            this.state = 248;\n            this.match(_SolidityParser.T__11);\n            this.state = 249;\n            this.identifier();\n          }\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  importDirective() {\n    let _localctx = new ImportDirectiveContext(this._ctx, this.state);\n    this.enterRule(_localctx, 16, _SolidityParser.RULE_importDirective);\n    let _la;\n    try {\n      this.state = 288;\n      this._errHandler.sync(this);\n      switch (this.interpreter.adaptivePredict(this._input, 13, this._ctx)) {\n        case 1:\n          this.enterOuterAlt(_localctx, 1);\n          {\n            this.state = 252;\n            this.match(_SolidityParser.T__12);\n            this.state = 253;\n            this.importPath();\n            this.state = 256;\n            this._errHandler.sync(this);\n            _la = this._input.LA(1);\n            if (_la === _SolidityParser.T__11) {\n              {\n                this.state = 254;\n                this.match(_SolidityParser.T__11);\n                this.state = 255;\n                this.identifier();\n              }\n            }\n            this.state = 258;\n            this.match(_SolidityParser.T__1);\n          }\n          break;\n        case 2:\n          this.enterOuterAlt(_localctx, 2);\n          {\n            this.state = 260;\n            this.match(_SolidityParser.T__12);\n            this.state = 263;\n            this._errHandler.sync(this);\n            switch (this._input.LA(1)) {\n              case _SolidityParser.T__2:\n                {\n                  this.state = 261;\n                  this.match(_SolidityParser.T__2);\n                }\n                break;\n              case _SolidityParser.T__13:\n              case _SolidityParser.T__24:\n              case _SolidityParser.T__35:\n              case _SolidityParser.T__41:\n              case _SolidityParser.T__53:\n              case _SolidityParser.T__95:\n              case _SolidityParser.LeaveKeyword:\n              case _SolidityParser.PayableKeyword:\n              case _SolidityParser.ConstructorKeyword:\n              case _SolidityParser.ReceiveKeyword:\n              case _SolidityParser.Identifier:\n                {\n                  this.state = 262;\n                  this.identifier();\n                }\n                break;\n              default:\n                throw new import_NoViableAltException.NoViableAltException(this);\n            }\n            this.state = 267;\n            this._errHandler.sync(this);\n            _la = this._input.LA(1);\n            if (_la === _SolidityParser.T__11) {\n              {\n                this.state = 265;\n                this.match(_SolidityParser.T__11);\n                this.state = 266;\n                this.identifier();\n              }\n            }\n            this.state = 269;\n            this.match(_SolidityParser.T__13);\n            this.state = 270;\n            this.importPath();\n            this.state = 271;\n            this.match(_SolidityParser.T__1);\n          }\n          break;\n        case 3:\n          this.enterOuterAlt(_localctx, 3);\n          {\n            this.state = 273;\n            this.match(_SolidityParser.T__12);\n            this.state = 274;\n            this.match(_SolidityParser.T__14);\n            this.state = 275;\n            this.importDeclaration();\n            this.state = 280;\n            this._errHandler.sync(this);\n            _la = this._input.LA(1);\n            while (_la === _SolidityParser.T__15) {\n              {\n                {\n                  this.state = 276;\n                  this.match(_SolidityParser.T__15);\n                  this.state = 277;\n                  this.importDeclaration();\n                }\n              }\n              this.state = 282;\n              this._errHandler.sync(this);\n              _la = this._input.LA(1);\n            }\n            this.state = 283;\n            this.match(_SolidityParser.T__16);\n            this.state = 284;\n            this.match(_SolidityParser.T__13);\n            this.state = 285;\n            this.importPath();\n            this.state = 286;\n            this.match(_SolidityParser.T__1);\n          }\n          break;\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  importPath() {\n    let _localctx = new ImportPathContext(this._ctx, this.state);\n    this.enterRule(_localctx, 18, _SolidityParser.RULE_importPath);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 290;\n        this.match(_SolidityParser.StringLiteralFragment);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  contractDefinition() {\n    let _localctx = new ContractDefinitionContext(this._ctx, this.state);\n    this.enterRule(_localctx, 20, _SolidityParser.RULE_contractDefinition);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 293;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.T__17) {\n          {\n            this.state = 292;\n            this.match(_SolidityParser.T__17);\n          }\n        }\n        this.state = 295;\n        _la = this._input.LA(1);\n        if (!((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__18 | 1 << _SolidityParser.T__19 | 1 << _SolidityParser.T__20)) !== 0)) {\n          this._errHandler.recoverInline(this);\n        } else {\n          if (this._input.LA(1) === import_Token.Token.EOF) {\n            this.matchedEOF = true;\n          }\n          this._errHandler.reportMatch(this);\n          this.consume();\n        }\n        this.state = 296;\n        this.identifier();\n        this.state = 306;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.T__21) {\n          {\n            this.state = 297;\n            this.match(_SolidityParser.T__21);\n            this.state = 298;\n            this.inheritanceSpecifier();\n            this.state = 303;\n            this._errHandler.sync(this);\n            _la = this._input.LA(1);\n            while (_la === _SolidityParser.T__15) {\n              {\n                {\n                  this.state = 299;\n                  this.match(_SolidityParser.T__15);\n                  this.state = 300;\n                  this.inheritanceSpecifier();\n                }\n              }\n              this.state = 305;\n              this._errHandler.sync(this);\n              _la = this._input.LA(1);\n            }\n          }\n        }\n        this.state = 308;\n        this.match(_SolidityParser.T__14);\n        this.state = 312;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        while ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__13 | 1 << _SolidityParser.T__24 | 1 << _SolidityParser.T__25 | 1 << _SolidityParser.T__27 | 1 << _SolidityParser.T__28 | 1 << _SolidityParser.T__29)) !== 0 || (_la - 32 & ~31) === 0 && (1 << _la - 32 & (1 << _SolidityParser.T__31 - 32 | 1 << _SolidityParser.T__32 - 32 | 1 << _SolidityParser.T__35 - 32 | 1 << _SolidityParser.T__37 - 32 | 1 << _SolidityParser.T__41 - 32 | 1 << _SolidityParser.T__53 - 32 | 1 << _SolidityParser.T__54 - 32 | 1 << _SolidityParser.T__55 - 32 | 1 << _SolidityParser.T__56 - 32 | 1 << _SolidityParser.T__57 - 32)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96 | 1 << _SolidityParser.FallbackKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {\n          {\n            {\n              this.state = 309;\n              this.contractPart();\n            }\n          }\n          this.state = 314;\n          this._errHandler.sync(this);\n          _la = this._input.LA(1);\n        }\n        this.state = 315;\n        this.match(_SolidityParser.T__16);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  inheritanceSpecifier() {\n    let _localctx = new InheritanceSpecifierContext(this._ctx, this.state);\n    this.enterRule(_localctx, 22, _SolidityParser.RULE_inheritanceSpecifier);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 317;\n        this.userDefinedTypeName();\n        this.state = 323;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.T__22) {\n          {\n            this.state = 318;\n            this.match(_SolidityParser.T__22);\n            this.state = 320;\n            this._errHandler.sync(this);\n            _la = this._input.LA(1);\n            if ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {\n              {\n                this.state = 319;\n                this.expressionList();\n              }\n            }\n            this.state = 322;\n            this.match(_SolidityParser.T__23);\n          }\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  contractPart() {\n    let _localctx = new ContractPartContext(this._ctx, this.state);\n    this.enterRule(_localctx, 24, _SolidityParser.RULE_contractPart);\n    try {\n      this.state = 334;\n      this._errHandler.sync(this);\n      switch (this.interpreter.adaptivePredict(this._input, 20, this._ctx)) {\n        case 1:\n          this.enterOuterAlt(_localctx, 1);\n          {\n            this.state = 325;\n            this.stateVariableDeclaration();\n          }\n          break;\n        case 2:\n          this.enterOuterAlt(_localctx, 2);\n          {\n            this.state = 326;\n            this.usingForDeclaration();\n          }\n          break;\n        case 3:\n          this.enterOuterAlt(_localctx, 3);\n          {\n            this.state = 327;\n            this.structDefinition();\n          }\n          break;\n        case 4:\n          this.enterOuterAlt(_localctx, 4);\n          {\n            this.state = 328;\n            this.modifierDefinition();\n          }\n          break;\n        case 5:\n          this.enterOuterAlt(_localctx, 5);\n          {\n            this.state = 329;\n            this.functionDefinition();\n          }\n          break;\n        case 6:\n          this.enterOuterAlt(_localctx, 6);\n          {\n            this.state = 330;\n            this.eventDefinition();\n          }\n          break;\n        case 7:\n          this.enterOuterAlt(_localctx, 7);\n          {\n            this.state = 331;\n            this.enumDefinition();\n          }\n          break;\n        case 8:\n          this.enterOuterAlt(_localctx, 8);\n          {\n            this.state = 332;\n            this.customErrorDefinition();\n          }\n          break;\n        case 9:\n          this.enterOuterAlt(_localctx, 9);\n          {\n            this.state = 333;\n            this.typeDefinition();\n          }\n          break;\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  stateVariableDeclaration() {\n    let _localctx = new StateVariableDeclarationContext(this._ctx, this.state);\n    this.enterRule(_localctx, 26, _SolidityParser.RULE_stateVariableDeclaration);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 336;\n        this.typeName(0);\n        this.state = 345;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        while ((_la - 97 & ~31) === 0 && (1 << _la - 97 & (1 << _SolidityParser.T__96 - 97 | 1 << _SolidityParser.ConstantKeyword - 97 | 1 << _SolidityParser.ImmutableKeyword - 97 | 1 << _SolidityParser.InternalKeyword - 97 | 1 << _SolidityParser.PrivateKeyword - 97 | 1 << _SolidityParser.PublicKeyword - 97)) !== 0) {\n          {\n            this.state = 343;\n            this._errHandler.sync(this);\n            switch (this._input.LA(1)) {\n              case _SolidityParser.PublicKeyword:\n                {\n                  this.state = 337;\n                  this.match(_SolidityParser.PublicKeyword);\n                }\n                break;\n              case _SolidityParser.InternalKeyword:\n                {\n                  this.state = 338;\n                  this.match(_SolidityParser.InternalKeyword);\n                }\n                break;\n              case _SolidityParser.PrivateKeyword:\n                {\n                  this.state = 339;\n                  this.match(_SolidityParser.PrivateKeyword);\n                }\n                break;\n              case _SolidityParser.ConstantKeyword:\n                {\n                  this.state = 340;\n                  this.match(_SolidityParser.ConstantKeyword);\n                }\n                break;\n              case _SolidityParser.ImmutableKeyword:\n                {\n                  this.state = 341;\n                  this.match(_SolidityParser.ImmutableKeyword);\n                }\n                break;\n              case _SolidityParser.T__96:\n                {\n                  this.state = 342;\n                  this.overrideSpecifier();\n                }\n                break;\n              default:\n                throw new import_NoViableAltException.NoViableAltException(this);\n            }\n          }\n          this.state = 347;\n          this._errHandler.sync(this);\n          _la = this._input.LA(1);\n        }\n        this.state = 348;\n        this.identifier();\n        this.state = 351;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.T__10) {\n          {\n            this.state = 349;\n            this.match(_SolidityParser.T__10);\n            this.state = 350;\n            this.expression(0);\n          }\n        }\n        this.state = 353;\n        this.match(_SolidityParser.T__1);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  fileLevelConstant() {\n    let _localctx = new FileLevelConstantContext(this._ctx, this.state);\n    this.enterRule(_localctx, 28, _SolidityParser.RULE_fileLevelConstant);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 355;\n        this.typeName(0);\n        this.state = 356;\n        this.match(_SolidityParser.ConstantKeyword);\n        this.state = 357;\n        this.identifier();\n        this.state = 358;\n        this.match(_SolidityParser.T__10);\n        this.state = 359;\n        this.expression(0);\n        this.state = 360;\n        this.match(_SolidityParser.T__1);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  customErrorDefinition() {\n    let _localctx = new CustomErrorDefinitionContext(this._ctx, this.state);\n    this.enterRule(_localctx, 30, _SolidityParser.RULE_customErrorDefinition);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 362;\n        this.match(_SolidityParser.T__24);\n        this.state = 363;\n        this.identifier();\n        this.state = 364;\n        this.parameterList();\n        this.state = 365;\n        this.match(_SolidityParser.T__1);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  typeDefinition() {\n    let _localctx = new TypeDefinitionContext(this._ctx, this.state);\n    this.enterRule(_localctx, 32, _SolidityParser.RULE_typeDefinition);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 367;\n        this.match(_SolidityParser.TypeKeyword);\n        this.state = 368;\n        this.identifier();\n        this.state = 369;\n        this.match(_SolidityParser.T__21);\n        this.state = 370;\n        this.elementaryTypeName();\n        this.state = 371;\n        this.match(_SolidityParser.T__1);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  usingForDeclaration() {\n    let _localctx = new UsingForDeclarationContext(this._ctx, this.state);\n    this.enterRule(_localctx, 34, _SolidityParser.RULE_usingForDeclaration);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 373;\n        this.match(_SolidityParser.T__25);\n        this.state = 374;\n        this.usingForObject();\n        this.state = 375;\n        this.match(_SolidityParser.T__26);\n        this.state = 378;\n        this._errHandler.sync(this);\n        switch (this._input.LA(1)) {\n          case _SolidityParser.T__2:\n            {\n              this.state = 376;\n              this.match(_SolidityParser.T__2);\n            }\n            break;\n          case _SolidityParser.T__13:\n          case _SolidityParser.T__24:\n          case _SolidityParser.T__29:\n          case _SolidityParser.T__35:\n          case _SolidityParser.T__37:\n          case _SolidityParser.T__41:\n          case _SolidityParser.T__53:\n          case _SolidityParser.T__54:\n          case _SolidityParser.T__55:\n          case _SolidityParser.T__56:\n          case _SolidityParser.T__57:\n          case _SolidityParser.T__95:\n          case _SolidityParser.Int:\n          case _SolidityParser.Uint:\n          case _SolidityParser.Byte:\n          case _SolidityParser.Fixed:\n          case _SolidityParser.Ufixed:\n          case _SolidityParser.LeaveKeyword:\n          case _SolidityParser.PayableKeyword:\n          case _SolidityParser.ConstructorKeyword:\n          case _SolidityParser.ReceiveKeyword:\n          case _SolidityParser.Identifier:\n            {\n              this.state = 377;\n              this.typeName(0);\n            }\n            break;\n          default:\n            throw new import_NoViableAltException.NoViableAltException(this);\n        }\n        this.state = 381;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.GlobalKeyword) {\n          {\n            this.state = 380;\n            this.match(_SolidityParser.GlobalKeyword);\n          }\n        }\n        this.state = 383;\n        this.match(_SolidityParser.T__1);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  usingForObject() {\n    let _localctx = new UsingForObjectContext(this._ctx, this.state);\n    this.enterRule(_localctx, 36, _SolidityParser.RULE_usingForObject);\n    let _la;\n    try {\n      this.state = 397;\n      this._errHandler.sync(this);\n      switch (this._input.LA(1)) {\n        case _SolidityParser.T__13:\n        case _SolidityParser.T__24:\n        case _SolidityParser.T__35:\n        case _SolidityParser.T__41:\n        case _SolidityParser.T__53:\n        case _SolidityParser.T__95:\n        case _SolidityParser.LeaveKeyword:\n        case _SolidityParser.PayableKeyword:\n        case _SolidityParser.ConstructorKeyword:\n        case _SolidityParser.ReceiveKeyword:\n        case _SolidityParser.Identifier:\n          this.enterOuterAlt(_localctx, 1);\n          {\n            this.state = 385;\n            this.userDefinedTypeName();\n          }\n          break;\n        case _SolidityParser.T__14:\n          this.enterOuterAlt(_localctx, 2);\n          {\n            this.state = 386;\n            this.match(_SolidityParser.T__14);\n            this.state = 387;\n            this.userDefinedTypeName();\n            this.state = 392;\n            this._errHandler.sync(this);\n            _la = this._input.LA(1);\n            while (_la === _SolidityParser.T__15) {\n              {\n                {\n                  this.state = 388;\n                  this.match(_SolidityParser.T__15);\n                  this.state = 389;\n                  this.userDefinedTypeName();\n                }\n              }\n              this.state = 394;\n              this._errHandler.sync(this);\n              _la = this._input.LA(1);\n            }\n            this.state = 395;\n            this.match(_SolidityParser.T__16);\n          }\n          break;\n        default:\n          throw new import_NoViableAltException.NoViableAltException(this);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  structDefinition() {\n    let _localctx = new StructDefinitionContext(this._ctx, this.state);\n    this.enterRule(_localctx, 38, _SolidityParser.RULE_structDefinition);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 399;\n        this.match(_SolidityParser.T__27);\n        this.state = 400;\n        this.identifier();\n        this.state = 401;\n        this.match(_SolidityParser.T__14);\n        this.state = 412;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__13 | 1 << _SolidityParser.T__24 | 1 << _SolidityParser.T__29)) !== 0 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__37 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36 | 1 << _SolidityParser.T__54 - 36 | 1 << _SolidityParser.T__55 - 36 | 1 << _SolidityParser.T__56 - 36 | 1 << _SolidityParser.T__57 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {\n          {\n            this.state = 402;\n            this.variableDeclaration();\n            this.state = 403;\n            this.match(_SolidityParser.T__1);\n            this.state = 409;\n            this._errHandler.sync(this);\n            _la = this._input.LA(1);\n            while ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__13 | 1 << _SolidityParser.T__24 | 1 << _SolidityParser.T__29)) !== 0 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__37 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36 | 1 << _SolidityParser.T__54 - 36 | 1 << _SolidityParser.T__55 - 36 | 1 << _SolidityParser.T__56 - 36 | 1 << _SolidityParser.T__57 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {\n              {\n                {\n                  this.state = 404;\n                  this.variableDeclaration();\n                  this.state = 405;\n                  this.match(_SolidityParser.T__1);\n                }\n              }\n              this.state = 411;\n              this._errHandler.sync(this);\n              _la = this._input.LA(1);\n            }\n          }\n        }\n        this.state = 414;\n        this.match(_SolidityParser.T__16);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  modifierDefinition() {\n    let _localctx = new ModifierDefinitionContext(this._ctx, this.state);\n    this.enterRule(_localctx, 40, _SolidityParser.RULE_modifierDefinition);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 416;\n        this.match(_SolidityParser.T__28);\n        this.state = 417;\n        this.identifier();\n        this.state = 419;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.T__22) {\n          {\n            this.state = 418;\n            this.parameterList();\n          }\n        }\n        this.state = 425;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        while (_la === _SolidityParser.T__96 || _la === _SolidityParser.VirtualKeyword) {\n          {\n            this.state = 423;\n            this._errHandler.sync(this);\n            switch (this._input.LA(1)) {\n              case _SolidityParser.VirtualKeyword:\n                {\n                  this.state = 421;\n                  this.match(_SolidityParser.VirtualKeyword);\n                }\n                break;\n              case _SolidityParser.T__96:\n                {\n                  this.state = 422;\n                  this.overrideSpecifier();\n                }\n                break;\n              default:\n                throw new import_NoViableAltException.NoViableAltException(this);\n            }\n          }\n          this.state = 427;\n          this._errHandler.sync(this);\n          _la = this._input.LA(1);\n        }\n        this.state = 430;\n        this._errHandler.sync(this);\n        switch (this._input.LA(1)) {\n          case _SolidityParser.T__1:\n            {\n              this.state = 428;\n              this.match(_SolidityParser.T__1);\n            }\n            break;\n          case _SolidityParser.T__14:\n            {\n              this.state = 429;\n              this.block();\n            }\n            break;\n          default:\n            throw new import_NoViableAltException.NoViableAltException(this);\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  modifierInvocation() {\n    let _localctx = new ModifierInvocationContext(this._ctx, this.state);\n    this.enterRule(_localctx, 42, _SolidityParser.RULE_modifierInvocation);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 432;\n        this.identifier();\n        this.state = 438;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.T__22) {\n          {\n            this.state = 433;\n            this.match(_SolidityParser.T__22);\n            this.state = 435;\n            this._errHandler.sync(this);\n            _la = this._input.LA(1);\n            if ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {\n              {\n                this.state = 434;\n                this.expressionList();\n              }\n            }\n            this.state = 437;\n            this.match(_SolidityParser.T__23);\n          }\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  functionDefinition() {\n    let _localctx = new FunctionDefinitionContext(this._ctx, this.state);\n    this.enterRule(_localctx, 44, _SolidityParser.RULE_functionDefinition);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 440;\n        this.functionDescriptor();\n        this.state = 441;\n        this.parameterList();\n        this.state = 442;\n        this.modifierList();\n        this.state = 444;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.T__30) {\n          {\n            this.state = 443;\n            this.returnParameters();\n          }\n        }\n        this.state = 448;\n        this._errHandler.sync(this);\n        switch (this._input.LA(1)) {\n          case _SolidityParser.T__1:\n            {\n              this.state = 446;\n              this.match(_SolidityParser.T__1);\n            }\n            break;\n          case _SolidityParser.T__14:\n            {\n              this.state = 447;\n              this.block();\n            }\n            break;\n          default:\n            throw new import_NoViableAltException.NoViableAltException(this);\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  functionDescriptor() {\n    let _localctx = new FunctionDescriptorContext(this._ctx, this.state);\n    this.enterRule(_localctx, 46, _SolidityParser.RULE_functionDescriptor);\n    let _la;\n    try {\n      this.state = 457;\n      this._errHandler.sync(this);\n      switch (this._input.LA(1)) {\n        case _SolidityParser.T__29:\n          this.enterOuterAlt(_localctx, 1);\n          {\n            this.state = 450;\n            this.match(_SolidityParser.T__29);\n            this.state = 452;\n            this._errHandler.sync(this);\n            _la = this._input.LA(1);\n            if (_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {\n              {\n                this.state = 451;\n                this.identifier();\n              }\n            }\n          }\n          break;\n        case _SolidityParser.ConstructorKeyword:\n          this.enterOuterAlt(_localctx, 2);\n          {\n            this.state = 454;\n            this.match(_SolidityParser.ConstructorKeyword);\n          }\n          break;\n        case _SolidityParser.FallbackKeyword:\n          this.enterOuterAlt(_localctx, 3);\n          {\n            this.state = 455;\n            this.match(_SolidityParser.FallbackKeyword);\n          }\n          break;\n        case _SolidityParser.ReceiveKeyword:\n          this.enterOuterAlt(_localctx, 4);\n          {\n            this.state = 456;\n            this.match(_SolidityParser.ReceiveKeyword);\n          }\n          break;\n        default:\n          throw new import_NoViableAltException.NoViableAltException(this);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  returnParameters() {\n    let _localctx = new ReturnParametersContext(this._ctx, this.state);\n    this.enterRule(_localctx, 48, _SolidityParser.RULE_returnParameters);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 459;\n        this.match(_SolidityParser.T__30);\n        this.state = 460;\n        this.parameterList();\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  modifierList() {\n    let _localctx = new ModifierListContext(this._ctx, this.state);\n    this.enterRule(_localctx, 50, _SolidityParser.RULE_modifierList);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 472;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        while (_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.T__96 - 96 | 1 << _SolidityParser.ConstantKeyword - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.ExternalKeyword - 96 | 1 << _SolidityParser.InternalKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.PrivateKeyword - 96 | 1 << _SolidityParser.PublicKeyword - 96 | 1 << _SolidityParser.VirtualKeyword - 96 | 1 << _SolidityParser.PureKeyword - 96 | 1 << _SolidityParser.ViewKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {\n          {\n            this.state = 470;\n            this._errHandler.sync(this);\n            switch (this.interpreter.adaptivePredict(this._input, 40, this._ctx)) {\n              case 1:\n                {\n                  this.state = 462;\n                  this.match(_SolidityParser.ExternalKeyword);\n                }\n                break;\n              case 2:\n                {\n                  this.state = 463;\n                  this.match(_SolidityParser.PublicKeyword);\n                }\n                break;\n              case 3:\n                {\n                  this.state = 464;\n                  this.match(_SolidityParser.InternalKeyword);\n                }\n                break;\n              case 4:\n                {\n                  this.state = 465;\n                  this.match(_SolidityParser.PrivateKeyword);\n                }\n                break;\n              case 5:\n                {\n                  this.state = 466;\n                  this.match(_SolidityParser.VirtualKeyword);\n                }\n                break;\n              case 6:\n                {\n                  this.state = 467;\n                  this.stateMutability();\n                }\n                break;\n              case 7:\n                {\n                  this.state = 468;\n                  this.modifierInvocation();\n                }\n                break;\n              case 8:\n                {\n                  this.state = 469;\n                  this.overrideSpecifier();\n                }\n                break;\n            }\n          }\n          this.state = 474;\n          this._errHandler.sync(this);\n          _la = this._input.LA(1);\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  eventDefinition() {\n    let _localctx = new EventDefinitionContext(this._ctx, this.state);\n    this.enterRule(_localctx, 52, _SolidityParser.RULE_eventDefinition);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 475;\n        this.match(_SolidityParser.T__31);\n        this.state = 476;\n        this.identifier();\n        this.state = 477;\n        this.eventParameterList();\n        this.state = 479;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.AnonymousKeyword) {\n          {\n            this.state = 478;\n            this.match(_SolidityParser.AnonymousKeyword);\n          }\n        }\n        this.state = 481;\n        this.match(_SolidityParser.T__1);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  enumValue() {\n    let _localctx = new EnumValueContext(this._ctx, this.state);\n    this.enterRule(_localctx, 54, _SolidityParser.RULE_enumValue);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 483;\n        this.identifier();\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  enumDefinition() {\n    let _localctx = new EnumDefinitionContext(this._ctx, this.state);\n    this.enterRule(_localctx, 56, _SolidityParser.RULE_enumDefinition);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 485;\n        this.match(_SolidityParser.T__32);\n        this.state = 486;\n        this.identifier();\n        this.state = 487;\n        this.match(_SolidityParser.T__14);\n        this.state = 489;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {\n          {\n            this.state = 488;\n            this.enumValue();\n          }\n        }\n        this.state = 495;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        while (_la === _SolidityParser.T__15) {\n          {\n            {\n              this.state = 491;\n              this.match(_SolidityParser.T__15);\n              this.state = 492;\n              this.enumValue();\n            }\n          }\n          this.state = 497;\n          this._errHandler.sync(this);\n          _la = this._input.LA(1);\n        }\n        this.state = 498;\n        this.match(_SolidityParser.T__16);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  parameterList() {\n    let _localctx = new ParameterListContext(this._ctx, this.state);\n    this.enterRule(_localctx, 58, _SolidityParser.RULE_parameterList);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 500;\n        this.match(_SolidityParser.T__22);\n        this.state = 509;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__13 | 1 << _SolidityParser.T__24 | 1 << _SolidityParser.T__29)) !== 0 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__37 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36 | 1 << _SolidityParser.T__54 - 36 | 1 << _SolidityParser.T__55 - 36 | 1 << _SolidityParser.T__56 - 36 | 1 << _SolidityParser.T__57 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {\n          {\n            this.state = 501;\n            this.parameter();\n            this.state = 506;\n            this._errHandler.sync(this);\n            _la = this._input.LA(1);\n            while (_la === _SolidityParser.T__15) {\n              {\n                {\n                  this.state = 502;\n                  this.match(_SolidityParser.T__15);\n                  this.state = 503;\n                  this.parameter();\n                }\n              }\n              this.state = 508;\n              this._errHandler.sync(this);\n              _la = this._input.LA(1);\n            }\n          }\n        }\n        this.state = 511;\n        this.match(_SolidityParser.T__23);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  parameter() {\n    let _localctx = new ParameterContext(this._ctx, this.state);\n    this.enterRule(_localctx, 60, _SolidityParser.RULE_parameter);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 513;\n        this.typeName(0);\n        this.state = 515;\n        this._errHandler.sync(this);\n        switch (this.interpreter.adaptivePredict(this._input, 47, this._ctx)) {\n          case 1:\n            {\n              this.state = 514;\n              this.storageLocation();\n            }\n            break;\n        }\n        this.state = 518;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {\n          {\n            this.state = 517;\n            this.identifier();\n          }\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  eventParameterList() {\n    let _localctx = new EventParameterListContext(this._ctx, this.state);\n    this.enterRule(_localctx, 62, _SolidityParser.RULE_eventParameterList);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 520;\n        this.match(_SolidityParser.T__22);\n        this.state = 529;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__13 | 1 << _SolidityParser.T__24 | 1 << _SolidityParser.T__29)) !== 0 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__37 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36 | 1 << _SolidityParser.T__54 - 36 | 1 << _SolidityParser.T__55 - 36 | 1 << _SolidityParser.T__56 - 36 | 1 << _SolidityParser.T__57 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {\n          {\n            this.state = 521;\n            this.eventParameter();\n            this.state = 526;\n            this._errHandler.sync(this);\n            _la = this._input.LA(1);\n            while (_la === _SolidityParser.T__15) {\n              {\n                {\n                  this.state = 522;\n                  this.match(_SolidityParser.T__15);\n                  this.state = 523;\n                  this.eventParameter();\n                }\n              }\n              this.state = 528;\n              this._errHandler.sync(this);\n              _la = this._input.LA(1);\n            }\n          }\n        }\n        this.state = 531;\n        this.match(_SolidityParser.T__23);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  eventParameter() {\n    let _localctx = new EventParameterContext(this._ctx, this.state);\n    this.enterRule(_localctx, 64, _SolidityParser.RULE_eventParameter);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 533;\n        this.typeName(0);\n        this.state = 535;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.IndexedKeyword) {\n          {\n            this.state = 534;\n            this.match(_SolidityParser.IndexedKeyword);\n          }\n        }\n        this.state = 538;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {\n          {\n            this.state = 537;\n            this.identifier();\n          }\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  functionTypeParameterList() {\n    let _localctx = new FunctionTypeParameterListContext(this._ctx, this.state);\n    this.enterRule(_localctx, 66, _SolidityParser.RULE_functionTypeParameterList);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 540;\n        this.match(_SolidityParser.T__22);\n        this.state = 549;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__13 | 1 << _SolidityParser.T__24 | 1 << _SolidityParser.T__29)) !== 0 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__37 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36 | 1 << _SolidityParser.T__54 - 36 | 1 << _SolidityParser.T__55 - 36 | 1 << _SolidityParser.T__56 - 36 | 1 << _SolidityParser.T__57 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {\n          {\n            this.state = 541;\n            this.functionTypeParameter();\n            this.state = 546;\n            this._errHandler.sync(this);\n            _la = this._input.LA(1);\n            while (_la === _SolidityParser.T__15) {\n              {\n                {\n                  this.state = 542;\n                  this.match(_SolidityParser.T__15);\n                  this.state = 543;\n                  this.functionTypeParameter();\n                }\n              }\n              this.state = 548;\n              this._errHandler.sync(this);\n              _la = this._input.LA(1);\n            }\n          }\n        }\n        this.state = 551;\n        this.match(_SolidityParser.T__23);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  functionTypeParameter() {\n    let _localctx = new FunctionTypeParameterContext(this._ctx, this.state);\n    this.enterRule(_localctx, 68, _SolidityParser.RULE_functionTypeParameter);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 553;\n        this.typeName(0);\n        this.state = 555;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if ((_la - 40 & ~31) === 0 && (1 << _la - 40 & (1 << _SolidityParser.T__39 - 40 | 1 << _SolidityParser.T__40 - 40 | 1 << _SolidityParser.T__41 - 40)) !== 0) {\n          {\n            this.state = 554;\n            this.storageLocation();\n          }\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  variableDeclaration() {\n    let _localctx = new VariableDeclarationContext(this._ctx, this.state);\n    this.enterRule(_localctx, 70, _SolidityParser.RULE_variableDeclaration);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 557;\n        this.typeName(0);\n        this.state = 559;\n        this._errHandler.sync(this);\n        switch (this.interpreter.adaptivePredict(this._input, 56, this._ctx)) {\n          case 1:\n            {\n              this.state = 558;\n              this.storageLocation();\n            }\n            break;\n        }\n        this.state = 561;\n        this.identifier();\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  typeName(_p) {\n    if (_p === void 0) {\n      _p = 0;\n    }\n    let _parentctx = this._ctx;\n    let _parentState = this.state;\n    let _localctx = new TypeNameContext(this._ctx, _parentState);\n    let _prevctx = _localctx;\n    let _startState = 72;\n    this.enterRecursionRule(_localctx, 72, _SolidityParser.RULE_typeName, _p);\n    let _la;\n    try {\n      let _alt;\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 570;\n        this._errHandler.sync(this);\n        switch (this.interpreter.adaptivePredict(this._input, 57, this._ctx)) {\n          case 1:\n            {\n              this.state = 564;\n              this.elementaryTypeName();\n            }\n            break;\n          case 2:\n            {\n              this.state = 565;\n              this.userDefinedTypeName();\n            }\n            break;\n          case 3:\n            {\n              this.state = 566;\n              this.mapping();\n            }\n            break;\n          case 4:\n            {\n              this.state = 567;\n              this.functionTypeName();\n            }\n            break;\n          case 5:\n            {\n              this.state = 568;\n              this.match(_SolidityParser.T__35);\n              this.state = 569;\n              this.match(_SolidityParser.PayableKeyword);\n            }\n            break;\n        }\n        this._ctx._stop = this._input.tryLT(-1);\n        this.state = 580;\n        this._errHandler.sync(this);\n        _alt = this.interpreter.adaptivePredict(this._input, 59, this._ctx);\n        while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {\n          if (_alt === 1) {\n            if (this._parseListeners != null) {\n              this.triggerExitRuleEvent();\n            }\n            _prevctx = _localctx;\n            {\n              {\n                _localctx = new TypeNameContext(_parentctx, _parentState);\n                this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_typeName);\n                this.state = 572;\n                if (!this.precpred(this._ctx, 3)) {\n                  throw this.createFailedPredicateException(\"this.precpred(this._ctx, 3)\");\n                }\n                this.state = 573;\n                this.match(_SolidityParser.T__33);\n                this.state = 575;\n                this._errHandler.sync(this);\n                _la = this._input.LA(1);\n                if ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {\n                  {\n                    this.state = 574;\n                    this.expression(0);\n                  }\n                }\n                this.state = 577;\n                this.match(_SolidityParser.T__34);\n              }\n            }\n          }\n          this.state = 582;\n          this._errHandler.sync(this);\n          _alt = this.interpreter.adaptivePredict(this._input, 59, this._ctx);\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.unrollRecursionContexts(_parentctx);\n    }\n    return _localctx;\n  }\n  userDefinedTypeName() {\n    let _localctx = new UserDefinedTypeNameContext(this._ctx, this.state);\n    this.enterRule(_localctx, 74, _SolidityParser.RULE_userDefinedTypeName);\n    try {\n      let _alt;\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 583;\n        this.identifier();\n        this.state = 588;\n        this._errHandler.sync(this);\n        _alt = this.interpreter.adaptivePredict(this._input, 60, this._ctx);\n        while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {\n          if (_alt === 1) {\n            {\n              {\n                this.state = 584;\n                this.match(_SolidityParser.T__36);\n                this.state = 585;\n                this.identifier();\n              }\n            }\n          }\n          this.state = 590;\n          this._errHandler.sync(this);\n          _alt = this.interpreter.adaptivePredict(this._input, 60, this._ctx);\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  mappingKey() {\n    let _localctx = new MappingKeyContext(this._ctx, this.state);\n    this.enterRule(_localctx, 76, _SolidityParser.RULE_mappingKey);\n    try {\n      this.state = 593;\n      this._errHandler.sync(this);\n      switch (this.interpreter.adaptivePredict(this._input, 61, this._ctx)) {\n        case 1:\n          this.enterOuterAlt(_localctx, 1);\n          {\n            this.state = 591;\n            this.elementaryTypeName();\n          }\n          break;\n        case 2:\n          this.enterOuterAlt(_localctx, 2);\n          {\n            this.state = 592;\n            this.userDefinedTypeName();\n          }\n          break;\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  mapping() {\n    let _localctx = new MappingContext(this._ctx, this.state);\n    this.enterRule(_localctx, 78, _SolidityParser.RULE_mapping);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 595;\n        this.match(_SolidityParser.T__37);\n        this.state = 596;\n        this.match(_SolidityParser.T__22);\n        this.state = 597;\n        this.mappingKey();\n        this.state = 598;\n        this.match(_SolidityParser.T__38);\n        this.state = 599;\n        this.typeName(0);\n        this.state = 600;\n        this.match(_SolidityParser.T__23);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  functionTypeName() {\n    let _localctx = new FunctionTypeNameContext(this._ctx, this.state);\n    this.enterRule(_localctx, 80, _SolidityParser.RULE_functionTypeName);\n    try {\n      let _alt;\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 602;\n        this.match(_SolidityParser.T__29);\n        this.state = 603;\n        this.functionTypeParameterList();\n        this.state = 609;\n        this._errHandler.sync(this);\n        _alt = this.interpreter.adaptivePredict(this._input, 63, this._ctx);\n        while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {\n          if (_alt === 1) {\n            {\n              this.state = 607;\n              this._errHandler.sync(this);\n              switch (this._input.LA(1)) {\n                case _SolidityParser.InternalKeyword:\n                  {\n                    this.state = 604;\n                    this.match(_SolidityParser.InternalKeyword);\n                  }\n                  break;\n                case _SolidityParser.ExternalKeyword:\n                  {\n                    this.state = 605;\n                    this.match(_SolidityParser.ExternalKeyword);\n                  }\n                  break;\n                case _SolidityParser.ConstantKeyword:\n                case _SolidityParser.PayableKeyword:\n                case _SolidityParser.PureKeyword:\n                case _SolidityParser.ViewKeyword:\n                  {\n                    this.state = 606;\n                    this.stateMutability();\n                  }\n                  break;\n                default:\n                  throw new import_NoViableAltException.NoViableAltException(this);\n              }\n            }\n          }\n          this.state = 611;\n          this._errHandler.sync(this);\n          _alt = this.interpreter.adaptivePredict(this._input, 63, this._ctx);\n        }\n        this.state = 614;\n        this._errHandler.sync(this);\n        switch (this.interpreter.adaptivePredict(this._input, 64, this._ctx)) {\n          case 1:\n            {\n              this.state = 612;\n              this.match(_SolidityParser.T__30);\n              this.state = 613;\n              this.functionTypeParameterList();\n            }\n            break;\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  storageLocation() {\n    let _localctx = new StorageLocationContext(this._ctx, this.state);\n    this.enterRule(_localctx, 82, _SolidityParser.RULE_storageLocation);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 616;\n        _la = this._input.LA(1);\n        if (!((_la - 40 & ~31) === 0 && (1 << _la - 40 & (1 << _SolidityParser.T__39 - 40 | 1 << _SolidityParser.T__40 - 40 | 1 << _SolidityParser.T__41 - 40)) !== 0)) {\n          this._errHandler.recoverInline(this);\n        } else {\n          if (this._input.LA(1) === import_Token.Token.EOF) {\n            this.matchedEOF = true;\n          }\n          this._errHandler.reportMatch(this);\n          this.consume();\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  stateMutability() {\n    let _localctx = new StateMutabilityContext(this._ctx, this.state);\n    this.enterRule(_localctx, 84, _SolidityParser.RULE_stateMutability);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 618;\n        _la = this._input.LA(1);\n        if (!((_la - 111 & ~31) === 0 && (1 << _la - 111 & (1 << _SolidityParser.ConstantKeyword - 111 | 1 << _SolidityParser.PayableKeyword - 111 | 1 << _SolidityParser.PureKeyword - 111 | 1 << _SolidityParser.ViewKeyword - 111)) !== 0)) {\n          this._errHandler.recoverInline(this);\n        } else {\n          if (this._input.LA(1) === import_Token.Token.EOF) {\n            this.matchedEOF = true;\n          }\n          this._errHandler.reportMatch(this);\n          this.consume();\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  block() {\n    let _localctx = new BlockContext(this._ctx, this.state);\n    this.enterRule(_localctx, 86, _SolidityParser.RULE_block);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 620;\n        this.match(_SolidityParser.T__14);\n        this.state = 624;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        while ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__14 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__26 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__42 - 38 | 1 << _SolidityParser.T__44 - 38 | 1 << _SolidityParser.T__46 - 38 | 1 << _SolidityParser.T__47 - 38 | 1 << _SolidityParser.T__48 - 38 | 1 << _SolidityParser.T__49 - 38 | 1 << _SolidityParser.T__50 - 38 | 1 << _SolidityParser.T__51 - 38 | 1 << _SolidityParser.T__52 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.BreakKeyword - 96 | 1 << _SolidityParser.ContinueKeyword - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {\n          {\n            {\n              this.state = 621;\n              this.statement();\n            }\n          }\n          this.state = 626;\n          this._errHandler.sync(this);\n          _la = this._input.LA(1);\n        }\n        this.state = 627;\n        this.match(_SolidityParser.T__16);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  statement() {\n    let _localctx = new StatementContext(this._ctx, this.state);\n    this.enterRule(_localctx, 88, _SolidityParser.RULE_statement);\n    try {\n      this.state = 644;\n      this._errHandler.sync(this);\n      switch (this.interpreter.adaptivePredict(this._input, 66, this._ctx)) {\n        case 1:\n          this.enterOuterAlt(_localctx, 1);\n          {\n            this.state = 629;\n            this.ifStatement();\n          }\n          break;\n        case 2:\n          this.enterOuterAlt(_localctx, 2);\n          {\n            this.state = 630;\n            this.tryStatement();\n          }\n          break;\n        case 3:\n          this.enterOuterAlt(_localctx, 3);\n          {\n            this.state = 631;\n            this.whileStatement();\n          }\n          break;\n        case 4:\n          this.enterOuterAlt(_localctx, 4);\n          {\n            this.state = 632;\n            this.forStatement();\n          }\n          break;\n        case 5:\n          this.enterOuterAlt(_localctx, 5);\n          {\n            this.state = 633;\n            this.block();\n          }\n          break;\n        case 6:\n          this.enterOuterAlt(_localctx, 6);\n          {\n            this.state = 634;\n            this.inlineAssemblyStatement();\n          }\n          break;\n        case 7:\n          this.enterOuterAlt(_localctx, 7);\n          {\n            this.state = 635;\n            this.doWhileStatement();\n          }\n          break;\n        case 8:\n          this.enterOuterAlt(_localctx, 8);\n          {\n            this.state = 636;\n            this.continueStatement();\n          }\n          break;\n        case 9:\n          this.enterOuterAlt(_localctx, 9);\n          {\n            this.state = 637;\n            this.breakStatement();\n          }\n          break;\n        case 10:\n          this.enterOuterAlt(_localctx, 10);\n          {\n            this.state = 638;\n            this.returnStatement();\n          }\n          break;\n        case 11:\n          this.enterOuterAlt(_localctx, 11);\n          {\n            this.state = 639;\n            this.throwStatement();\n          }\n          break;\n        case 12:\n          this.enterOuterAlt(_localctx, 12);\n          {\n            this.state = 640;\n            this.emitStatement();\n          }\n          break;\n        case 13:\n          this.enterOuterAlt(_localctx, 13);\n          {\n            this.state = 641;\n            this.simpleStatement();\n          }\n          break;\n        case 14:\n          this.enterOuterAlt(_localctx, 14);\n          {\n            this.state = 642;\n            this.uncheckedStatement();\n          }\n          break;\n        case 15:\n          this.enterOuterAlt(_localctx, 15);\n          {\n            this.state = 643;\n            this.revertStatement();\n          }\n          break;\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  expressionStatement() {\n    let _localctx = new ExpressionStatementContext(this._ctx, this.state);\n    this.enterRule(_localctx, 90, _SolidityParser.RULE_expressionStatement);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 646;\n        this.expression(0);\n        this.state = 647;\n        this.match(_SolidityParser.T__1);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  ifStatement() {\n    let _localctx = new IfStatementContext(this._ctx, this.state);\n    this.enterRule(_localctx, 92, _SolidityParser.RULE_ifStatement);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 649;\n        this.match(_SolidityParser.T__42);\n        this.state = 650;\n        this.match(_SolidityParser.T__22);\n        this.state = 651;\n        this.expression(0);\n        this.state = 652;\n        this.match(_SolidityParser.T__23);\n        this.state = 653;\n        this.statement();\n        this.state = 656;\n        this._errHandler.sync(this);\n        switch (this.interpreter.adaptivePredict(this._input, 67, this._ctx)) {\n          case 1:\n            {\n              this.state = 654;\n              this.match(_SolidityParser.T__43);\n              this.state = 655;\n              this.statement();\n            }\n            break;\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  tryStatement() {\n    let _localctx = new TryStatementContext(this._ctx, this.state);\n    this.enterRule(_localctx, 94, _SolidityParser.RULE_tryStatement);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 658;\n        this.match(_SolidityParser.T__44);\n        this.state = 659;\n        this.expression(0);\n        this.state = 661;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.T__30) {\n          {\n            this.state = 660;\n            this.returnParameters();\n          }\n        }\n        this.state = 663;\n        this.block();\n        this.state = 665;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        do {\n          {\n            {\n              this.state = 664;\n              this.catchClause();\n            }\n          }\n          this.state = 667;\n          this._errHandler.sync(this);\n          _la = this._input.LA(1);\n        } while (_la === _SolidityParser.T__45);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  catchClause() {\n    let _localctx = new CatchClauseContext(this._ctx, this.state);\n    this.enterRule(_localctx, 96, _SolidityParser.RULE_catchClause);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 669;\n        this.match(_SolidityParser.T__45);\n        this.state = 674;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__13 | 1 << _SolidityParser.T__22 | 1 << _SolidityParser.T__24)) !== 0 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {\n          {\n            this.state = 671;\n            this._errHandler.sync(this);\n            _la = this._input.LA(1);\n            if (_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {\n              {\n                this.state = 670;\n                this.identifier();\n              }\n            }\n            this.state = 673;\n            this.parameterList();\n          }\n        }\n        this.state = 676;\n        this.block();\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  whileStatement() {\n    let _localctx = new WhileStatementContext(this._ctx, this.state);\n    this.enterRule(_localctx, 98, _SolidityParser.RULE_whileStatement);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 678;\n        this.match(_SolidityParser.T__46);\n        this.state = 679;\n        this.match(_SolidityParser.T__22);\n        this.state = 680;\n        this.expression(0);\n        this.state = 681;\n        this.match(_SolidityParser.T__23);\n        this.state = 682;\n        this.statement();\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  simpleStatement() {\n    let _localctx = new SimpleStatementContext(this._ctx, this.state);\n    this.enterRule(_localctx, 100, _SolidityParser.RULE_simpleStatement);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 686;\n        this._errHandler.sync(this);\n        switch (this.interpreter.adaptivePredict(this._input, 72, this._ctx)) {\n          case 1:\n            {\n              this.state = 684;\n              this.variableDeclarationStatement();\n            }\n            break;\n          case 2:\n            {\n              this.state = 685;\n              this.expressionStatement();\n            }\n            break;\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  uncheckedStatement() {\n    let _localctx = new UncheckedStatementContext(this._ctx, this.state);\n    this.enterRule(_localctx, 102, _SolidityParser.RULE_uncheckedStatement);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 688;\n        this.match(_SolidityParser.T__47);\n        this.state = 689;\n        this.block();\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  forStatement() {\n    let _localctx = new ForStatementContext(this._ctx, this.state);\n    this.enterRule(_localctx, 104, _SolidityParser.RULE_forStatement);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 691;\n        this.match(_SolidityParser.T__26);\n        this.state = 692;\n        this.match(_SolidityParser.T__22);\n        this.state = 695;\n        this._errHandler.sync(this);\n        switch (this._input.LA(1)) {\n          case _SolidityParser.T__5:\n          case _SolidityParser.T__13:\n          case _SolidityParser.T__22:\n          case _SolidityParser.T__24:\n          case _SolidityParser.T__29:\n          case _SolidityParser.T__33:\n          case _SolidityParser.T__35:\n          case _SolidityParser.T__37:\n          case _SolidityParser.T__41:\n          case _SolidityParser.T__53:\n          case _SolidityParser.T__54:\n          case _SolidityParser.T__55:\n          case _SolidityParser.T__56:\n          case _SolidityParser.T__57:\n          case _SolidityParser.T__58:\n          case _SolidityParser.T__59:\n          case _SolidityParser.T__60:\n          case _SolidityParser.T__62:\n          case _SolidityParser.T__63:\n          case _SolidityParser.T__64:\n          case _SolidityParser.T__65:\n          case _SolidityParser.T__66:\n          case _SolidityParser.T__95:\n          case _SolidityParser.Int:\n          case _SolidityParser.Uint:\n          case _SolidityParser.Byte:\n          case _SolidityParser.Fixed:\n          case _SolidityParser.Ufixed:\n          case _SolidityParser.BooleanLiteral:\n          case _SolidityParser.DecimalNumber:\n          case _SolidityParser.HexNumber:\n          case _SolidityParser.HexLiteralFragment:\n          case _SolidityParser.LeaveKeyword:\n          case _SolidityParser.PayableKeyword:\n          case _SolidityParser.TypeKeyword:\n          case _SolidityParser.ConstructorKeyword:\n          case _SolidityParser.ReceiveKeyword:\n          case _SolidityParser.Identifier:\n          case _SolidityParser.StringLiteralFragment:\n            {\n              this.state = 693;\n              this.simpleStatement();\n            }\n            break;\n          case _SolidityParser.T__1:\n            {\n              this.state = 694;\n              this.match(_SolidityParser.T__1);\n            }\n            break;\n          default:\n            throw new import_NoViableAltException.NoViableAltException(this);\n        }\n        this.state = 699;\n        this._errHandler.sync(this);\n        switch (this._input.LA(1)) {\n          case _SolidityParser.T__5:\n          case _SolidityParser.T__13:\n          case _SolidityParser.T__22:\n          case _SolidityParser.T__24:\n          case _SolidityParser.T__29:\n          case _SolidityParser.T__33:\n          case _SolidityParser.T__35:\n          case _SolidityParser.T__37:\n          case _SolidityParser.T__41:\n          case _SolidityParser.T__53:\n          case _SolidityParser.T__54:\n          case _SolidityParser.T__55:\n          case _SolidityParser.T__56:\n          case _SolidityParser.T__57:\n          case _SolidityParser.T__58:\n          case _SolidityParser.T__59:\n          case _SolidityParser.T__60:\n          case _SolidityParser.T__62:\n          case _SolidityParser.T__63:\n          case _SolidityParser.T__64:\n          case _SolidityParser.T__65:\n          case _SolidityParser.T__66:\n          case _SolidityParser.T__95:\n          case _SolidityParser.Int:\n          case _SolidityParser.Uint:\n          case _SolidityParser.Byte:\n          case _SolidityParser.Fixed:\n          case _SolidityParser.Ufixed:\n          case _SolidityParser.BooleanLiteral:\n          case _SolidityParser.DecimalNumber:\n          case _SolidityParser.HexNumber:\n          case _SolidityParser.HexLiteralFragment:\n          case _SolidityParser.LeaveKeyword:\n          case _SolidityParser.PayableKeyword:\n          case _SolidityParser.TypeKeyword:\n          case _SolidityParser.ConstructorKeyword:\n          case _SolidityParser.ReceiveKeyword:\n          case _SolidityParser.Identifier:\n          case _SolidityParser.StringLiteralFragment:\n            {\n              this.state = 697;\n              this.expressionStatement();\n            }\n            break;\n          case _SolidityParser.T__1:\n            {\n              this.state = 698;\n              this.match(_SolidityParser.T__1);\n            }\n            break;\n          default:\n            throw new import_NoViableAltException.NoViableAltException(this);\n        }\n        this.state = 702;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {\n          {\n            this.state = 701;\n            this.expression(0);\n          }\n        }\n        this.state = 704;\n        this.match(_SolidityParser.T__23);\n        this.state = 705;\n        this.statement();\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  inlineAssemblyStatement() {\n    let _localctx = new InlineAssemblyStatementContext(this._ctx, this.state);\n    this.enterRule(_localctx, 106, _SolidityParser.RULE_inlineAssemblyStatement);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 707;\n        this.match(_SolidityParser.T__48);\n        this.state = 709;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.StringLiteralFragment) {\n          {\n            this.state = 708;\n            this.match(_SolidityParser.StringLiteralFragment);\n          }\n        }\n        this.state = 715;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.T__22) {\n          {\n            this.state = 711;\n            this.match(_SolidityParser.T__22);\n            this.state = 712;\n            this.inlineAssemblyStatementFlag();\n            this.state = 713;\n            this.match(_SolidityParser.T__23);\n          }\n        }\n        this.state = 717;\n        this.assemblyBlock();\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  inlineAssemblyStatementFlag() {\n    let _localctx = new InlineAssemblyStatementFlagContext(this._ctx, this.state);\n    this.enterRule(_localctx, 108, _SolidityParser.RULE_inlineAssemblyStatementFlag);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 719;\n        this.stringLiteral();\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  doWhileStatement() {\n    let _localctx = new DoWhileStatementContext(this._ctx, this.state);\n    this.enterRule(_localctx, 110, _SolidityParser.RULE_doWhileStatement);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 721;\n        this.match(_SolidityParser.T__49);\n        this.state = 722;\n        this.statement();\n        this.state = 723;\n        this.match(_SolidityParser.T__46);\n        this.state = 724;\n        this.match(_SolidityParser.T__22);\n        this.state = 725;\n        this.expression(0);\n        this.state = 726;\n        this.match(_SolidityParser.T__23);\n        this.state = 727;\n        this.match(_SolidityParser.T__1);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  continueStatement() {\n    let _localctx = new ContinueStatementContext(this._ctx, this.state);\n    this.enterRule(_localctx, 112, _SolidityParser.RULE_continueStatement);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 729;\n        this.match(_SolidityParser.ContinueKeyword);\n        this.state = 730;\n        this.match(_SolidityParser.T__1);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  breakStatement() {\n    let _localctx = new BreakStatementContext(this._ctx, this.state);\n    this.enterRule(_localctx, 114, _SolidityParser.RULE_breakStatement);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 732;\n        this.match(_SolidityParser.BreakKeyword);\n        this.state = 733;\n        this.match(_SolidityParser.T__1);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  returnStatement() {\n    let _localctx = new ReturnStatementContext(this._ctx, this.state);\n    this.enterRule(_localctx, 116, _SolidityParser.RULE_returnStatement);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 735;\n        this.match(_SolidityParser.T__50);\n        this.state = 737;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {\n          {\n            this.state = 736;\n            this.expression(0);\n          }\n        }\n        this.state = 739;\n        this.match(_SolidityParser.T__1);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  throwStatement() {\n    let _localctx = new ThrowStatementContext(this._ctx, this.state);\n    this.enterRule(_localctx, 118, _SolidityParser.RULE_throwStatement);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 741;\n        this.match(_SolidityParser.T__51);\n        this.state = 742;\n        this.match(_SolidityParser.T__1);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  emitStatement() {\n    let _localctx = new EmitStatementContext(this._ctx, this.state);\n    this.enterRule(_localctx, 120, _SolidityParser.RULE_emitStatement);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 744;\n        this.match(_SolidityParser.T__52);\n        this.state = 745;\n        this.functionCall();\n        this.state = 746;\n        this.match(_SolidityParser.T__1);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  revertStatement() {\n    let _localctx = new RevertStatementContext(this._ctx, this.state);\n    this.enterRule(_localctx, 122, _SolidityParser.RULE_revertStatement);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 748;\n        this.match(_SolidityParser.T__53);\n        this.state = 749;\n        this.functionCall();\n        this.state = 750;\n        this.match(_SolidityParser.T__1);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  variableDeclarationStatement() {\n    let _localctx = new VariableDeclarationStatementContext(this._ctx, this.state);\n    this.enterRule(_localctx, 124, _SolidityParser.RULE_variableDeclarationStatement);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 759;\n        this._errHandler.sync(this);\n        switch (this.interpreter.adaptivePredict(this._input, 79, this._ctx)) {\n          case 1:\n            {\n              this.state = 752;\n              this.match(_SolidityParser.T__54);\n              this.state = 753;\n              this.identifierList();\n            }\n            break;\n          case 2:\n            {\n              this.state = 754;\n              this.variableDeclaration();\n            }\n            break;\n          case 3:\n            {\n              this.state = 755;\n              this.match(_SolidityParser.T__22);\n              this.state = 756;\n              this.variableDeclarationList();\n              this.state = 757;\n              this.match(_SolidityParser.T__23);\n            }\n            break;\n        }\n        this.state = 763;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.T__10) {\n          {\n            this.state = 761;\n            this.match(_SolidityParser.T__10);\n            this.state = 762;\n            this.expression(0);\n          }\n        }\n        this.state = 765;\n        this.match(_SolidityParser.T__1);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  variableDeclarationList() {\n    let _localctx = new VariableDeclarationListContext(this._ctx, this.state);\n    this.enterRule(_localctx, 126, _SolidityParser.RULE_variableDeclarationList);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 768;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__13 | 1 << _SolidityParser.T__24 | 1 << _SolidityParser.T__29)) !== 0 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__37 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36 | 1 << _SolidityParser.T__54 - 36 | 1 << _SolidityParser.T__55 - 36 | 1 << _SolidityParser.T__56 - 36 | 1 << _SolidityParser.T__57 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {\n          {\n            this.state = 767;\n            this.variableDeclaration();\n          }\n        }\n        this.state = 776;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        while (_la === _SolidityParser.T__15) {\n          {\n            {\n              this.state = 770;\n              this.match(_SolidityParser.T__15);\n              this.state = 772;\n              this._errHandler.sync(this);\n              _la = this._input.LA(1);\n              if ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__13 | 1 << _SolidityParser.T__24 | 1 << _SolidityParser.T__29)) !== 0 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__37 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36 | 1 << _SolidityParser.T__54 - 36 | 1 << _SolidityParser.T__55 - 36 | 1 << _SolidityParser.T__56 - 36 | 1 << _SolidityParser.T__57 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {\n                {\n                  this.state = 771;\n                  this.variableDeclaration();\n                }\n              }\n            }\n          }\n          this.state = 778;\n          this._errHandler.sync(this);\n          _la = this._input.LA(1);\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  identifierList() {\n    let _localctx = new IdentifierListContext(this._ctx, this.state);\n    this.enterRule(_localctx, 128, _SolidityParser.RULE_identifierList);\n    let _la;\n    try {\n      let _alt;\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 779;\n        this.match(_SolidityParser.T__22);\n        this.state = 786;\n        this._errHandler.sync(this);\n        _alt = this.interpreter.adaptivePredict(this._input, 85, this._ctx);\n        while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {\n          if (_alt === 1) {\n            {\n              {\n                this.state = 781;\n                this._errHandler.sync(this);\n                _la = this._input.LA(1);\n                if (_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {\n                  {\n                    this.state = 780;\n                    this.identifier();\n                  }\n                }\n                this.state = 783;\n                this.match(_SolidityParser.T__15);\n              }\n            }\n          }\n          this.state = 788;\n          this._errHandler.sync(this);\n          _alt = this.interpreter.adaptivePredict(this._input, 85, this._ctx);\n        }\n        this.state = 790;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {\n          {\n            this.state = 789;\n            this.identifier();\n          }\n        }\n        this.state = 792;\n        this.match(_SolidityParser.T__23);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  elementaryTypeName() {\n    let _localctx = new ElementaryTypeNameContext(this._ctx, this.state);\n    this.enterRule(_localctx, 130, _SolidityParser.RULE_elementaryTypeName);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 794;\n        _la = this._input.LA(1);\n        if (!((_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__54 - 36 | 1 << _SolidityParser.T__55 - 36 | 1 << _SolidityParser.T__56 - 36 | 1 << _SolidityParser.T__57 - 36)) !== 0 || (_la - 98 & ~31) === 0 && (1 << _la - 98 & (1 << _SolidityParser.Int - 98 | 1 << _SolidityParser.Uint - 98 | 1 << _SolidityParser.Byte - 98 | 1 << _SolidityParser.Fixed - 98 | 1 << _SolidityParser.Ufixed - 98)) !== 0)) {\n          this._errHandler.recoverInline(this);\n        } else {\n          if (this._input.LA(1) === import_Token.Token.EOF) {\n            this.matchedEOF = true;\n          }\n          this._errHandler.reportMatch(this);\n          this.consume();\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  expression(_p) {\n    if (_p === void 0) {\n      _p = 0;\n    }\n    let _parentctx = this._ctx;\n    let _parentState = this.state;\n    let _localctx = new ExpressionContext(this._ctx, _parentState);\n    let _prevctx = _localctx;\n    let _startState = 132;\n    this.enterRecursionRule(_localctx, 132, _SolidityParser.RULE_expression, _p);\n    let _la;\n    try {\n      let _alt;\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 814;\n        this._errHandler.sync(this);\n        switch (this.interpreter.adaptivePredict(this._input, 87, this._ctx)) {\n          case 1:\n            {\n              this.state = 797;\n              this.match(_SolidityParser.T__60);\n              this.state = 798;\n              this.typeName(0);\n            }\n            break;\n          case 2:\n            {\n              this.state = 799;\n              this.match(_SolidityParser.T__22);\n              this.state = 800;\n              this.expression(0);\n              this.state = 801;\n              this.match(_SolidityParser.T__23);\n            }\n            break;\n          case 3:\n            {\n              this.state = 803;\n              _la = this._input.LA(1);\n              if (!(_la === _SolidityParser.T__58 || _la === _SolidityParser.T__59)) {\n                this._errHandler.recoverInline(this);\n              } else {\n                if (this._input.LA(1) === import_Token.Token.EOF) {\n                  this.matchedEOF = true;\n                }\n                this._errHandler.reportMatch(this);\n                this.consume();\n              }\n              this.state = 804;\n              this.expression(19);\n            }\n            break;\n          case 4:\n            {\n              this.state = 805;\n              _la = this._input.LA(1);\n              if (!(_la === _SolidityParser.T__62 || _la === _SolidityParser.T__63)) {\n                this._errHandler.recoverInline(this);\n              } else {\n                if (this._input.LA(1) === import_Token.Token.EOF) {\n                  this.matchedEOF = true;\n                }\n                this._errHandler.reportMatch(this);\n                this.consume();\n              }\n              this.state = 806;\n              this.expression(18);\n            }\n            break;\n          case 5:\n            {\n              this.state = 807;\n              _la = this._input.LA(1);\n              if (!(_la === _SolidityParser.T__64 || _la === _SolidityParser.T__65)) {\n                this._errHandler.recoverInline(this);\n              } else {\n                if (this._input.LA(1) === import_Token.Token.EOF) {\n                  this.matchedEOF = true;\n                }\n                this._errHandler.reportMatch(this);\n                this.consume();\n              }\n              this.state = 808;\n              this.expression(17);\n            }\n            break;\n          case 6:\n            {\n              this.state = 809;\n              this.match(_SolidityParser.T__66);\n              this.state = 810;\n              this.expression(16);\n            }\n            break;\n          case 7:\n            {\n              this.state = 811;\n              this.match(_SolidityParser.T__5);\n              this.state = 812;\n              this.expression(15);\n            }\n            break;\n          case 8:\n            {\n              this.state = 813;\n              this.primaryExpression();\n            }\n            break;\n        }\n        this._ctx._stop = this._input.tryLT(-1);\n        this.state = 890;\n        this._errHandler.sync(this);\n        _alt = this.interpreter.adaptivePredict(this._input, 91, this._ctx);\n        while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {\n          if (_alt === 1) {\n            if (this._parseListeners != null) {\n              this.triggerExitRuleEvent();\n            }\n            _prevctx = _localctx;\n            {\n              this.state = 888;\n              this._errHandler.sync(this);\n              switch (this.interpreter.adaptivePredict(this._input, 90, this._ctx)) {\n                case 1:\n                  {\n                    _localctx = new ExpressionContext(_parentctx, _parentState);\n                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);\n                    this.state = 816;\n                    if (!this.precpred(this._ctx, 14)) {\n                      throw this.createFailedPredicateException(\"this.precpred(this._ctx, 14)\");\n                    }\n                    this.state = 817;\n                    this.match(_SolidityParser.T__67);\n                    this.state = 818;\n                    this.expression(15);\n                  }\n                  break;\n                case 2:\n                  {\n                    _localctx = new ExpressionContext(_parentctx, _parentState);\n                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);\n                    this.state = 819;\n                    if (!this.precpred(this._ctx, 13)) {\n                      throw this.createFailedPredicateException(\"this.precpred(this._ctx, 13)\");\n                    }\n                    this.state = 820;\n                    _la = this._input.LA(1);\n                    if (!(_la === _SolidityParser.T__2 || _la === _SolidityParser.T__68 || _la === _SolidityParser.T__69)) {\n                      this._errHandler.recoverInline(this);\n                    } else {\n                      if (this._input.LA(1) === import_Token.Token.EOF) {\n                        this.matchedEOF = true;\n                      }\n                      this._errHandler.reportMatch(this);\n                      this.consume();\n                    }\n                    this.state = 821;\n                    this.expression(14);\n                  }\n                  break;\n                case 3:\n                  {\n                    _localctx = new ExpressionContext(_parentctx, _parentState);\n                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);\n                    this.state = 822;\n                    if (!this.precpred(this._ctx, 12)) {\n                      throw this.createFailedPredicateException(\"this.precpred(this._ctx, 12)\");\n                    }\n                    this.state = 823;\n                    _la = this._input.LA(1);\n                    if (!(_la === _SolidityParser.T__62 || _la === _SolidityParser.T__63)) {\n                      this._errHandler.recoverInline(this);\n                    } else {\n                      if (this._input.LA(1) === import_Token.Token.EOF) {\n                        this.matchedEOF = true;\n                      }\n                      this._errHandler.reportMatch(this);\n                      this.consume();\n                    }\n                    this.state = 824;\n                    this.expression(13);\n                  }\n                  break;\n                case 4:\n                  {\n                    _localctx = new ExpressionContext(_parentctx, _parentState);\n                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);\n                    this.state = 825;\n                    if (!this.precpred(this._ctx, 11)) {\n                      throw this.createFailedPredicateException(\"this.precpred(this._ctx, 11)\");\n                    }\n                    this.state = 826;\n                    _la = this._input.LA(1);\n                    if (!(_la === _SolidityParser.T__70 || _la === _SolidityParser.T__71)) {\n                      this._errHandler.recoverInline(this);\n                    } else {\n                      if (this._input.LA(1) === import_Token.Token.EOF) {\n                        this.matchedEOF = true;\n                      }\n                      this._errHandler.reportMatch(this);\n                      this.consume();\n                    }\n                    this.state = 827;\n                    this.expression(12);\n                  }\n                  break;\n                case 5:\n                  {\n                    _localctx = new ExpressionContext(_parentctx, _parentState);\n                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);\n                    this.state = 828;\n                    if (!this.precpred(this._ctx, 10)) {\n                      throw this.createFailedPredicateException(\"this.precpred(this._ctx, 10)\");\n                    }\n                    this.state = 829;\n                    this.match(_SolidityParser.T__72);\n                    this.state = 830;\n                    this.expression(11);\n                  }\n                  break;\n                case 6:\n                  {\n                    _localctx = new ExpressionContext(_parentctx, _parentState);\n                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);\n                    this.state = 831;\n                    if (!this.precpred(this._ctx, 9)) {\n                      throw this.createFailedPredicateException(\"this.precpred(this._ctx, 9)\");\n                    }\n                    this.state = 832;\n                    this.match(_SolidityParser.T__4);\n                    this.state = 833;\n                    this.expression(10);\n                  }\n                  break;\n                case 7:\n                  {\n                    _localctx = new ExpressionContext(_parentctx, _parentState);\n                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);\n                    this.state = 834;\n                    if (!this.precpred(this._ctx, 8)) {\n                      throw this.createFailedPredicateException(\"this.precpred(this._ctx, 8)\");\n                    }\n                    this.state = 835;\n                    this.match(_SolidityParser.T__73);\n                    this.state = 836;\n                    this.expression(9);\n                  }\n                  break;\n                case 8:\n                  {\n                    _localctx = new ExpressionContext(_parentctx, _parentState);\n                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);\n                    this.state = 837;\n                    if (!this.precpred(this._ctx, 7)) {\n                      throw this.createFailedPredicateException(\"this.precpred(this._ctx, 7)\");\n                    }\n                    this.state = 838;\n                    _la = this._input.LA(1);\n                    if (!((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__6 | 1 << _SolidityParser.T__7 | 1 << _SolidityParser.T__8 | 1 << _SolidityParser.T__9)) !== 0)) {\n                      this._errHandler.recoverInline(this);\n                    } else {\n                      if (this._input.LA(1) === import_Token.Token.EOF) {\n                        this.matchedEOF = true;\n                      }\n                      this._errHandler.reportMatch(this);\n                      this.consume();\n                    }\n                    this.state = 839;\n                    this.expression(8);\n                  }\n                  break;\n                case 9:\n                  {\n                    _localctx = new ExpressionContext(_parentctx, _parentState);\n                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);\n                    this.state = 840;\n                    if (!this.precpred(this._ctx, 6)) {\n                      throw this.createFailedPredicateException(\"this.precpred(this._ctx, 6)\");\n                    }\n                    this.state = 841;\n                    _la = this._input.LA(1);\n                    if (!(_la === _SolidityParser.T__74 || _la === _SolidityParser.T__75)) {\n                      this._errHandler.recoverInline(this);\n                    } else {\n                      if (this._input.LA(1) === import_Token.Token.EOF) {\n                        this.matchedEOF = true;\n                      }\n                      this._errHandler.reportMatch(this);\n                      this.consume();\n                    }\n                    this.state = 842;\n                    this.expression(7);\n                  }\n                  break;\n                case 10:\n                  {\n                    _localctx = new ExpressionContext(_parentctx, _parentState);\n                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);\n                    this.state = 843;\n                    if (!this.precpred(this._ctx, 5)) {\n                      throw this.createFailedPredicateException(\"this.precpred(this._ctx, 5)\");\n                    }\n                    this.state = 844;\n                    this.match(_SolidityParser.T__76);\n                    this.state = 845;\n                    this.expression(6);\n                  }\n                  break;\n                case 11:\n                  {\n                    _localctx = new ExpressionContext(_parentctx, _parentState);\n                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);\n                    this.state = 846;\n                    if (!this.precpred(this._ctx, 4)) {\n                      throw this.createFailedPredicateException(\"this.precpred(this._ctx, 4)\");\n                    }\n                    this.state = 847;\n                    this.match(_SolidityParser.T__3);\n                    this.state = 848;\n                    this.expression(5);\n                  }\n                  break;\n                case 12:\n                  {\n                    _localctx = new ExpressionContext(_parentctx, _parentState);\n                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);\n                    this.state = 849;\n                    if (!this.precpred(this._ctx, 3)) {\n                      throw this.createFailedPredicateException(\"this.precpred(this._ctx, 3)\");\n                    }\n                    this.state = 850;\n                    this.match(_SolidityParser.T__77);\n                    this.state = 851;\n                    this.expression(0);\n                    this.state = 852;\n                    this.match(_SolidityParser.T__61);\n                    this.state = 853;\n                    this.expression(4);\n                  }\n                  break;\n                case 13:\n                  {\n                    _localctx = new ExpressionContext(_parentctx, _parentState);\n                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);\n                    this.state = 855;\n                    if (!this.precpred(this._ctx, 2)) {\n                      throw this.createFailedPredicateException(\"this.precpred(this._ctx, 2)\");\n                    }\n                    this.state = 856;\n                    _la = this._input.LA(1);\n                    if (!(_la === _SolidityParser.T__10 || (_la - 79 & ~31) === 0 && (1 << _la - 79 & (1 << _SolidityParser.T__78 - 79 | 1 << _SolidityParser.T__79 - 79 | 1 << _SolidityParser.T__80 - 79 | 1 << _SolidityParser.T__81 - 79 | 1 << _SolidityParser.T__82 - 79 | 1 << _SolidityParser.T__83 - 79 | 1 << _SolidityParser.T__84 - 79 | 1 << _SolidityParser.T__85 - 79 | 1 << _SolidityParser.T__86 - 79 | 1 << _SolidityParser.T__87 - 79)) !== 0)) {\n                      this._errHandler.recoverInline(this);\n                    } else {\n                      if (this._input.LA(1) === import_Token.Token.EOF) {\n                        this.matchedEOF = true;\n                      }\n                      this._errHandler.reportMatch(this);\n                      this.consume();\n                    }\n                    this.state = 857;\n                    this.expression(3);\n                  }\n                  break;\n                case 14:\n                  {\n                    _localctx = new ExpressionContext(_parentctx, _parentState);\n                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);\n                    this.state = 858;\n                    if (!this.precpred(this._ctx, 27)) {\n                      throw this.createFailedPredicateException(\"this.precpred(this._ctx, 27)\");\n                    }\n                    this.state = 859;\n                    _la = this._input.LA(1);\n                    if (!(_la === _SolidityParser.T__58 || _la === _SolidityParser.T__59)) {\n                      this._errHandler.recoverInline(this);\n                    } else {\n                      if (this._input.LA(1) === import_Token.Token.EOF) {\n                        this.matchedEOF = true;\n                      }\n                      this._errHandler.reportMatch(this);\n                      this.consume();\n                    }\n                  }\n                  break;\n                case 15:\n                  {\n                    _localctx = new ExpressionContext(_parentctx, _parentState);\n                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);\n                    this.state = 860;\n                    if (!this.precpred(this._ctx, 25)) {\n                      throw this.createFailedPredicateException(\"this.precpred(this._ctx, 25)\");\n                    }\n                    this.state = 861;\n                    this.match(_SolidityParser.T__33);\n                    this.state = 862;\n                    this.expression(0);\n                    this.state = 863;\n                    this.match(_SolidityParser.T__34);\n                  }\n                  break;\n                case 16:\n                  {\n                    _localctx = new ExpressionContext(_parentctx, _parentState);\n                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);\n                    this.state = 865;\n                    if (!this.precpred(this._ctx, 24)) {\n                      throw this.createFailedPredicateException(\"this.precpred(this._ctx, 24)\");\n                    }\n                    this.state = 866;\n                    this.match(_SolidityParser.T__33);\n                    this.state = 868;\n                    this._errHandler.sync(this);\n                    _la = this._input.LA(1);\n                    if ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {\n                      {\n                        this.state = 867;\n                        this.expression(0);\n                      }\n                    }\n                    this.state = 870;\n                    this.match(_SolidityParser.T__61);\n                    this.state = 872;\n                    this._errHandler.sync(this);\n                    _la = this._input.LA(1);\n                    if ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {\n                      {\n                        this.state = 871;\n                        this.expression(0);\n                      }\n                    }\n                    this.state = 874;\n                    this.match(_SolidityParser.T__34);\n                  }\n                  break;\n                case 17:\n                  {\n                    _localctx = new ExpressionContext(_parentctx, _parentState);\n                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);\n                    this.state = 875;\n                    if (!this.precpred(this._ctx, 23)) {\n                      throw this.createFailedPredicateException(\"this.precpred(this._ctx, 23)\");\n                    }\n                    this.state = 876;\n                    this.match(_SolidityParser.T__36);\n                    this.state = 877;\n                    this.identifier();\n                  }\n                  break;\n                case 18:\n                  {\n                    _localctx = new ExpressionContext(_parentctx, _parentState);\n                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);\n                    this.state = 878;\n                    if (!this.precpred(this._ctx, 22)) {\n                      throw this.createFailedPredicateException(\"this.precpred(this._ctx, 22)\");\n                    }\n                    this.state = 879;\n                    this.match(_SolidityParser.T__14);\n                    this.state = 880;\n                    this.nameValueList();\n                    this.state = 881;\n                    this.match(_SolidityParser.T__16);\n                  }\n                  break;\n                case 19:\n                  {\n                    _localctx = new ExpressionContext(_parentctx, _parentState);\n                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);\n                    this.state = 883;\n                    if (!this.precpred(this._ctx, 21)) {\n                      throw this.createFailedPredicateException(\"this.precpred(this._ctx, 21)\");\n                    }\n                    this.state = 884;\n                    this.match(_SolidityParser.T__22);\n                    this.state = 885;\n                    this.functionCallArguments();\n                    this.state = 886;\n                    this.match(_SolidityParser.T__23);\n                  }\n                  break;\n              }\n            }\n          }\n          this.state = 892;\n          this._errHandler.sync(this);\n          _alt = this.interpreter.adaptivePredict(this._input, 91, this._ctx);\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.unrollRecursionContexts(_parentctx);\n    }\n    return _localctx;\n  }\n  primaryExpression() {\n    let _localctx = new PrimaryExpressionContext(this._ctx, this.state);\n    this.enterRule(_localctx, 134, _SolidityParser.RULE_primaryExpression);\n    try {\n      this.state = 902;\n      this._errHandler.sync(this);\n      switch (this.interpreter.adaptivePredict(this._input, 92, this._ctx)) {\n        case 1:\n          this.enterOuterAlt(_localctx, 1);\n          {\n            this.state = 893;\n            this.match(_SolidityParser.BooleanLiteral);\n          }\n          break;\n        case 2:\n          this.enterOuterAlt(_localctx, 2);\n          {\n            this.state = 894;\n            this.numberLiteral();\n          }\n          break;\n        case 3:\n          this.enterOuterAlt(_localctx, 3);\n          {\n            this.state = 895;\n            this.hexLiteral();\n          }\n          break;\n        case 4:\n          this.enterOuterAlt(_localctx, 4);\n          {\n            this.state = 896;\n            this.stringLiteral();\n          }\n          break;\n        case 5:\n          this.enterOuterAlt(_localctx, 5);\n          {\n            this.state = 897;\n            this.identifier();\n          }\n          break;\n        case 6:\n          this.enterOuterAlt(_localctx, 6);\n          {\n            this.state = 898;\n            this.match(_SolidityParser.TypeKeyword);\n          }\n          break;\n        case 7:\n          this.enterOuterAlt(_localctx, 7);\n          {\n            this.state = 899;\n            this.match(_SolidityParser.PayableKeyword);\n          }\n          break;\n        case 8:\n          this.enterOuterAlt(_localctx, 8);\n          {\n            this.state = 900;\n            this.tupleExpression();\n          }\n          break;\n        case 9:\n          this.enterOuterAlt(_localctx, 9);\n          {\n            this.state = 901;\n            this.typeName(0);\n          }\n          break;\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  expressionList() {\n    let _localctx = new ExpressionListContext(this._ctx, this.state);\n    this.enterRule(_localctx, 136, _SolidityParser.RULE_expressionList);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 904;\n        this.expression(0);\n        this.state = 909;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        while (_la === _SolidityParser.T__15) {\n          {\n            {\n              this.state = 905;\n              this.match(_SolidityParser.T__15);\n              this.state = 906;\n              this.expression(0);\n            }\n          }\n          this.state = 911;\n          this._errHandler.sync(this);\n          _la = this._input.LA(1);\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  nameValueList() {\n    let _localctx = new NameValueListContext(this._ctx, this.state);\n    this.enterRule(_localctx, 138, _SolidityParser.RULE_nameValueList);\n    let _la;\n    try {\n      let _alt;\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 912;\n        this.nameValue();\n        this.state = 917;\n        this._errHandler.sync(this);\n        _alt = this.interpreter.adaptivePredict(this._input, 94, this._ctx);\n        while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {\n          if (_alt === 1) {\n            {\n              {\n                this.state = 913;\n                this.match(_SolidityParser.T__15);\n                this.state = 914;\n                this.nameValue();\n              }\n            }\n          }\n          this.state = 919;\n          this._errHandler.sync(this);\n          _alt = this.interpreter.adaptivePredict(this._input, 94, this._ctx);\n        }\n        this.state = 921;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.T__15) {\n          {\n            this.state = 920;\n            this.match(_SolidityParser.T__15);\n          }\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  nameValue() {\n    let _localctx = new NameValueContext(this._ctx, this.state);\n    this.enterRule(_localctx, 140, _SolidityParser.RULE_nameValue);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 923;\n        this.identifier();\n        this.state = 924;\n        this.match(_SolidityParser.T__61);\n        this.state = 925;\n        this.expression(0);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  functionCallArguments() {\n    let _localctx = new FunctionCallArgumentsContext(this._ctx, this.state);\n    this.enterRule(_localctx, 142, _SolidityParser.RULE_functionCallArguments);\n    let _la;\n    try {\n      this.state = 935;\n      this._errHandler.sync(this);\n      switch (this._input.LA(1)) {\n        case _SolidityParser.T__14:\n          this.enterOuterAlt(_localctx, 1);\n          {\n            this.state = 927;\n            this.match(_SolidityParser.T__14);\n            this.state = 929;\n            this._errHandler.sync(this);\n            _la = this._input.LA(1);\n            if (_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {\n              {\n                this.state = 928;\n                this.nameValueList();\n              }\n            }\n            this.state = 931;\n            this.match(_SolidityParser.T__16);\n          }\n          break;\n        case _SolidityParser.T__5:\n        case _SolidityParser.T__13:\n        case _SolidityParser.T__22:\n        case _SolidityParser.T__23:\n        case _SolidityParser.T__24:\n        case _SolidityParser.T__29:\n        case _SolidityParser.T__33:\n        case _SolidityParser.T__35:\n        case _SolidityParser.T__37:\n        case _SolidityParser.T__41:\n        case _SolidityParser.T__53:\n        case _SolidityParser.T__54:\n        case _SolidityParser.T__55:\n        case _SolidityParser.T__56:\n        case _SolidityParser.T__57:\n        case _SolidityParser.T__58:\n        case _SolidityParser.T__59:\n        case _SolidityParser.T__60:\n        case _SolidityParser.T__62:\n        case _SolidityParser.T__63:\n        case _SolidityParser.T__64:\n        case _SolidityParser.T__65:\n        case _SolidityParser.T__66:\n        case _SolidityParser.T__95:\n        case _SolidityParser.Int:\n        case _SolidityParser.Uint:\n        case _SolidityParser.Byte:\n        case _SolidityParser.Fixed:\n        case _SolidityParser.Ufixed:\n        case _SolidityParser.BooleanLiteral:\n        case _SolidityParser.DecimalNumber:\n        case _SolidityParser.HexNumber:\n        case _SolidityParser.HexLiteralFragment:\n        case _SolidityParser.LeaveKeyword:\n        case _SolidityParser.PayableKeyword:\n        case _SolidityParser.TypeKeyword:\n        case _SolidityParser.ConstructorKeyword:\n        case _SolidityParser.ReceiveKeyword:\n        case _SolidityParser.Identifier:\n        case _SolidityParser.StringLiteralFragment:\n          this.enterOuterAlt(_localctx, 2);\n          {\n            this.state = 933;\n            this._errHandler.sync(this);\n            _la = this._input.LA(1);\n            if ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {\n              {\n                this.state = 932;\n                this.expressionList();\n              }\n            }\n          }\n          break;\n        default:\n          throw new import_NoViableAltException.NoViableAltException(this);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  functionCall() {\n    let _localctx = new FunctionCallContext(this._ctx, this.state);\n    this.enterRule(_localctx, 144, _SolidityParser.RULE_functionCall);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 937;\n        this.expression(0);\n        this.state = 938;\n        this.match(_SolidityParser.T__22);\n        this.state = 939;\n        this.functionCallArguments();\n        this.state = 940;\n        this.match(_SolidityParser.T__23);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  assemblyBlock() {\n    let _localctx = new AssemblyBlockContext(this._ctx, this.state);\n    this.enterRule(_localctx, 146, _SolidityParser.RULE_assemblyBlock);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 942;\n        this.match(_SolidityParser.T__14);\n        this.state = 946;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        while ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__13 | 1 << _SolidityParser.T__14 | 1 << _SolidityParser.T__22 | 1 << _SolidityParser.T__24 | 1 << _SolidityParser.T__26 | 1 << _SolidityParser.T__29)) !== 0 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__42 - 36 | 1 << _SolidityParser.T__48 - 36 | 1 << _SolidityParser.T__50 - 36 | 1 << _SolidityParser.T__53 - 36 | 1 << _SolidityParser.T__57 - 36)) !== 0 || (_la - 89 & ~31) === 0 && (1 << _la - 89 & (1 << _SolidityParser.T__88 - 89 | 1 << _SolidityParser.T__91 - 89 | 1 << _SolidityParser.T__95 - 89 | 1 << _SolidityParser.BooleanLiteral - 89 | 1 << _SolidityParser.DecimalNumber - 89 | 1 << _SolidityParser.HexNumber - 89 | 1 << _SolidityParser.HexLiteralFragment - 89 | 1 << _SolidityParser.BreakKeyword - 89 | 1 << _SolidityParser.ContinueKeyword - 89 | 1 << _SolidityParser.LeaveKeyword - 89 | 1 << _SolidityParser.PayableKeyword - 89)) !== 0 || (_la - 126 & ~31) === 0 && (1 << _la - 126 & (1 << _SolidityParser.ConstructorKeyword - 126 | 1 << _SolidityParser.ReceiveKeyword - 126 | 1 << _SolidityParser.Identifier - 126 | 1 << _SolidityParser.StringLiteralFragment - 126)) !== 0) {\n          {\n            {\n              this.state = 943;\n              this.assemblyItem();\n            }\n          }\n          this.state = 948;\n          this._errHandler.sync(this);\n          _la = this._input.LA(1);\n        }\n        this.state = 949;\n        this.match(_SolidityParser.T__16);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  assemblyItem() {\n    let _localctx = new AssemblyItemContext(this._ctx, this.state);\n    this.enterRule(_localctx, 148, _SolidityParser.RULE_assemblyItem);\n    try {\n      this.state = 969;\n      this._errHandler.sync(this);\n      switch (this.interpreter.adaptivePredict(this._input, 100, this._ctx)) {\n        case 1:\n          this.enterOuterAlt(_localctx, 1);\n          {\n            this.state = 951;\n            this.identifier();\n          }\n          break;\n        case 2:\n          this.enterOuterAlt(_localctx, 2);\n          {\n            this.state = 952;\n            this.assemblyBlock();\n          }\n          break;\n        case 3:\n          this.enterOuterAlt(_localctx, 3);\n          {\n            this.state = 953;\n            this.assemblyExpression();\n          }\n          break;\n        case 4:\n          this.enterOuterAlt(_localctx, 4);\n          {\n            this.state = 954;\n            this.assemblyLocalDefinition();\n          }\n          break;\n        case 5:\n          this.enterOuterAlt(_localctx, 5);\n          {\n            this.state = 955;\n            this.assemblyAssignment();\n          }\n          break;\n        case 6:\n          this.enterOuterAlt(_localctx, 6);\n          {\n            this.state = 956;\n            this.assemblyStackAssignment();\n          }\n          break;\n        case 7:\n          this.enterOuterAlt(_localctx, 7);\n          {\n            this.state = 957;\n            this.labelDefinition();\n          }\n          break;\n        case 8:\n          this.enterOuterAlt(_localctx, 8);\n          {\n            this.state = 958;\n            this.assemblySwitch();\n          }\n          break;\n        case 9:\n          this.enterOuterAlt(_localctx, 9);\n          {\n            this.state = 959;\n            this.assemblyFunctionDefinition();\n          }\n          break;\n        case 10:\n          this.enterOuterAlt(_localctx, 10);\n          {\n            this.state = 960;\n            this.assemblyFor();\n          }\n          break;\n        case 11:\n          this.enterOuterAlt(_localctx, 11);\n          {\n            this.state = 961;\n            this.assemblyIf();\n          }\n          break;\n        case 12:\n          this.enterOuterAlt(_localctx, 12);\n          {\n            this.state = 962;\n            this.match(_SolidityParser.BreakKeyword);\n          }\n          break;\n        case 13:\n          this.enterOuterAlt(_localctx, 13);\n          {\n            this.state = 963;\n            this.match(_SolidityParser.ContinueKeyword);\n          }\n          break;\n        case 14:\n          this.enterOuterAlt(_localctx, 14);\n          {\n            this.state = 964;\n            this.match(_SolidityParser.LeaveKeyword);\n          }\n          break;\n        case 15:\n          this.enterOuterAlt(_localctx, 15);\n          {\n            this.state = 965;\n            this.subAssembly();\n          }\n          break;\n        case 16:\n          this.enterOuterAlt(_localctx, 16);\n          {\n            this.state = 966;\n            this.numberLiteral();\n          }\n          break;\n        case 17:\n          this.enterOuterAlt(_localctx, 17);\n          {\n            this.state = 967;\n            this.stringLiteral();\n          }\n          break;\n        case 18:\n          this.enterOuterAlt(_localctx, 18);\n          {\n            this.state = 968;\n            this.hexLiteral();\n          }\n          break;\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  assemblyExpression() {\n    let _localctx = new AssemblyExpressionContext(this._ctx, this.state);\n    this.enterRule(_localctx, 150, _SolidityParser.RULE_assemblyExpression);\n    try {\n      this.state = 974;\n      this._errHandler.sync(this);\n      switch (this.interpreter.adaptivePredict(this._input, 101, this._ctx)) {\n        case 1:\n          this.enterOuterAlt(_localctx, 1);\n          {\n            this.state = 971;\n            this.assemblyCall();\n          }\n          break;\n        case 2:\n          this.enterOuterAlt(_localctx, 2);\n          {\n            this.state = 972;\n            this.assemblyLiteral();\n          }\n          break;\n        case 3:\n          this.enterOuterAlt(_localctx, 3);\n          {\n            this.state = 973;\n            this.assemblyMember();\n          }\n          break;\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  assemblyMember() {\n    let _localctx = new AssemblyMemberContext(this._ctx, this.state);\n    this.enterRule(_localctx, 152, _SolidityParser.RULE_assemblyMember);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 976;\n        this.identifier();\n        this.state = 977;\n        this.match(_SolidityParser.T__36);\n        this.state = 978;\n        this.identifier();\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  assemblyCall() {\n    let _localctx = new AssemblyCallContext(this._ctx, this.state);\n    this.enterRule(_localctx, 154, _SolidityParser.RULE_assemblyCall);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 984;\n        this._errHandler.sync(this);\n        switch (this.interpreter.adaptivePredict(this._input, 102, this._ctx)) {\n          case 1:\n            {\n              this.state = 980;\n              this.match(_SolidityParser.T__50);\n            }\n            break;\n          case 2:\n            {\n              this.state = 981;\n              this.match(_SolidityParser.T__35);\n            }\n            break;\n          case 3:\n            {\n              this.state = 982;\n              this.match(_SolidityParser.T__57);\n            }\n            break;\n          case 4:\n            {\n              this.state = 983;\n              this.identifier();\n            }\n            break;\n        }\n        this.state = 998;\n        this._errHandler.sync(this);\n        switch (this.interpreter.adaptivePredict(this._input, 105, this._ctx)) {\n          case 1:\n            {\n              this.state = 986;\n              this.match(_SolidityParser.T__22);\n              this.state = 988;\n              this._errHandler.sync(this);\n              _la = this._input.LA(1);\n              if (_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__50 - 36 | 1 << _SolidityParser.T__53 - 36 | 1 << _SolidityParser.T__57 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {\n                {\n                  this.state = 987;\n                  this.assemblyExpression();\n                }\n              }\n              this.state = 994;\n              this._errHandler.sync(this);\n              _la = this._input.LA(1);\n              while (_la === _SolidityParser.T__15) {\n                {\n                  {\n                    this.state = 990;\n                    this.match(_SolidityParser.T__15);\n                    this.state = 991;\n                    this.assemblyExpression();\n                  }\n                }\n                this.state = 996;\n                this._errHandler.sync(this);\n                _la = this._input.LA(1);\n              }\n              this.state = 997;\n              this.match(_SolidityParser.T__23);\n            }\n            break;\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  assemblyLocalDefinition() {\n    let _localctx = new AssemblyLocalDefinitionContext(this._ctx, this.state);\n    this.enterRule(_localctx, 156, _SolidityParser.RULE_assemblyLocalDefinition);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 1e3;\n        this.match(_SolidityParser.T__88);\n        this.state = 1001;\n        this.assemblyIdentifierOrList();\n        this.state = 1004;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.T__89) {\n          {\n            this.state = 1002;\n            this.match(_SolidityParser.T__89);\n            this.state = 1003;\n            this.assemblyExpression();\n          }\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  assemblyAssignment() {\n    let _localctx = new AssemblyAssignmentContext(this._ctx, this.state);\n    this.enterRule(_localctx, 158, _SolidityParser.RULE_assemblyAssignment);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 1006;\n        this.assemblyIdentifierOrList();\n        this.state = 1007;\n        this.match(_SolidityParser.T__89);\n        this.state = 1008;\n        this.assemblyExpression();\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  assemblyIdentifierOrList() {\n    let _localctx = new AssemblyIdentifierOrListContext(this._ctx, this.state);\n    this.enterRule(_localctx, 160, _SolidityParser.RULE_assemblyIdentifierOrList);\n    try {\n      this.state = 1017;\n      this._errHandler.sync(this);\n      switch (this.interpreter.adaptivePredict(this._input, 107, this._ctx)) {\n        case 1:\n          this.enterOuterAlt(_localctx, 1);\n          {\n            this.state = 1010;\n            this.identifier();\n          }\n          break;\n        case 2:\n          this.enterOuterAlt(_localctx, 2);\n          {\n            this.state = 1011;\n            this.assemblyMember();\n          }\n          break;\n        case 3:\n          this.enterOuterAlt(_localctx, 3);\n          {\n            this.state = 1012;\n            this.assemblyIdentifierList();\n          }\n          break;\n        case 4:\n          this.enterOuterAlt(_localctx, 4);\n          {\n            this.state = 1013;\n            this.match(_SolidityParser.T__22);\n            this.state = 1014;\n            this.assemblyIdentifierList();\n            this.state = 1015;\n            this.match(_SolidityParser.T__23);\n          }\n          break;\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  assemblyIdentifierList() {\n    let _localctx = new AssemblyIdentifierListContext(this._ctx, this.state);\n    this.enterRule(_localctx, 162, _SolidityParser.RULE_assemblyIdentifierList);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 1019;\n        this.identifier();\n        this.state = 1024;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        while (_la === _SolidityParser.T__15) {\n          {\n            {\n              this.state = 1020;\n              this.match(_SolidityParser.T__15);\n              this.state = 1021;\n              this.identifier();\n            }\n          }\n          this.state = 1026;\n          this._errHandler.sync(this);\n          _la = this._input.LA(1);\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  assemblyStackAssignment() {\n    let _localctx = new AssemblyStackAssignmentContext(this._ctx, this.state);\n    this.enterRule(_localctx, 164, _SolidityParser.RULE_assemblyStackAssignment);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 1027;\n        this.assemblyExpression();\n        this.state = 1028;\n        this.match(_SolidityParser.T__90);\n        this.state = 1029;\n        this.identifier();\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  labelDefinition() {\n    let _localctx = new LabelDefinitionContext(this._ctx, this.state);\n    this.enterRule(_localctx, 166, _SolidityParser.RULE_labelDefinition);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 1031;\n        this.identifier();\n        this.state = 1032;\n        this.match(_SolidityParser.T__61);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  assemblySwitch() {\n    let _localctx = new AssemblySwitchContext(this._ctx, this.state);\n    this.enterRule(_localctx, 168, _SolidityParser.RULE_assemblySwitch);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 1034;\n        this.match(_SolidityParser.T__91);\n        this.state = 1035;\n        this.assemblyExpression();\n        this.state = 1039;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        while (_la === _SolidityParser.T__92 || _la === _SolidityParser.T__93) {\n          {\n            {\n              this.state = 1036;\n              this.assemblyCase();\n            }\n          }\n          this.state = 1041;\n          this._errHandler.sync(this);\n          _la = this._input.LA(1);\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  assemblyCase() {\n    let _localctx = new AssemblyCaseContext(this._ctx, this.state);\n    this.enterRule(_localctx, 170, _SolidityParser.RULE_assemblyCase);\n    try {\n      this.state = 1048;\n      this._errHandler.sync(this);\n      switch (this._input.LA(1)) {\n        case _SolidityParser.T__92:\n          this.enterOuterAlt(_localctx, 1);\n          {\n            this.state = 1042;\n            this.match(_SolidityParser.T__92);\n            this.state = 1043;\n            this.assemblyLiteral();\n            this.state = 1044;\n            this.assemblyBlock();\n          }\n          break;\n        case _SolidityParser.T__93:\n          this.enterOuterAlt(_localctx, 2);\n          {\n            this.state = 1046;\n            this.match(_SolidityParser.T__93);\n            this.state = 1047;\n            this.assemblyBlock();\n          }\n          break;\n        default:\n          throw new import_NoViableAltException.NoViableAltException(this);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  assemblyFunctionDefinition() {\n    let _localctx = new AssemblyFunctionDefinitionContext(this._ctx, this.state);\n    this.enterRule(_localctx, 172, _SolidityParser.RULE_assemblyFunctionDefinition);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 1050;\n        this.match(_SolidityParser.T__29);\n        this.state = 1051;\n        this.identifier();\n        this.state = 1052;\n        this.match(_SolidityParser.T__22);\n        this.state = 1054;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {\n          {\n            this.state = 1053;\n            this.assemblyIdentifierList();\n          }\n        }\n        this.state = 1056;\n        this.match(_SolidityParser.T__23);\n        this.state = 1058;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.T__94) {\n          {\n            this.state = 1057;\n            this.assemblyFunctionReturns();\n          }\n        }\n        this.state = 1060;\n        this.assemblyBlock();\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  assemblyFunctionReturns() {\n    let _localctx = new AssemblyFunctionReturnsContext(this._ctx, this.state);\n    this.enterRule(_localctx, 174, _SolidityParser.RULE_assemblyFunctionReturns);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        {\n          this.state = 1062;\n          this.match(_SolidityParser.T__94);\n          this.state = 1063;\n          this.assemblyIdentifierList();\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  assemblyFor() {\n    let _localctx = new AssemblyForContext(this._ctx, this.state);\n    this.enterRule(_localctx, 176, _SolidityParser.RULE_assemblyFor);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 1065;\n        this.match(_SolidityParser.T__26);\n        this.state = 1068;\n        this._errHandler.sync(this);\n        switch (this._input.LA(1)) {\n          case _SolidityParser.T__14:\n            {\n              this.state = 1066;\n              this.assemblyBlock();\n            }\n            break;\n          case _SolidityParser.T__13:\n          case _SolidityParser.T__24:\n          case _SolidityParser.T__35:\n          case _SolidityParser.T__41:\n          case _SolidityParser.T__50:\n          case _SolidityParser.T__53:\n          case _SolidityParser.T__57:\n          case _SolidityParser.T__95:\n          case _SolidityParser.BooleanLiteral:\n          case _SolidityParser.DecimalNumber:\n          case _SolidityParser.HexNumber:\n          case _SolidityParser.HexLiteralFragment:\n          case _SolidityParser.LeaveKeyword:\n          case _SolidityParser.PayableKeyword:\n          case _SolidityParser.ConstructorKeyword:\n          case _SolidityParser.ReceiveKeyword:\n          case _SolidityParser.Identifier:\n          case _SolidityParser.StringLiteralFragment:\n            {\n              this.state = 1067;\n              this.assemblyExpression();\n            }\n            break;\n          default:\n            throw new import_NoViableAltException.NoViableAltException(this);\n        }\n        this.state = 1070;\n        this.assemblyExpression();\n        this.state = 1073;\n        this._errHandler.sync(this);\n        switch (this._input.LA(1)) {\n          case _SolidityParser.T__14:\n            {\n              this.state = 1071;\n              this.assemblyBlock();\n            }\n            break;\n          case _SolidityParser.T__13:\n          case _SolidityParser.T__24:\n          case _SolidityParser.T__35:\n          case _SolidityParser.T__41:\n          case _SolidityParser.T__50:\n          case _SolidityParser.T__53:\n          case _SolidityParser.T__57:\n          case _SolidityParser.T__95:\n          case _SolidityParser.BooleanLiteral:\n          case _SolidityParser.DecimalNumber:\n          case _SolidityParser.HexNumber:\n          case _SolidityParser.HexLiteralFragment:\n          case _SolidityParser.LeaveKeyword:\n          case _SolidityParser.PayableKeyword:\n          case _SolidityParser.ConstructorKeyword:\n          case _SolidityParser.ReceiveKeyword:\n          case _SolidityParser.Identifier:\n          case _SolidityParser.StringLiteralFragment:\n            {\n              this.state = 1072;\n              this.assemblyExpression();\n            }\n            break;\n          default:\n            throw new import_NoViableAltException.NoViableAltException(this);\n        }\n        this.state = 1075;\n        this.assemblyBlock();\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  assemblyIf() {\n    let _localctx = new AssemblyIfContext(this._ctx, this.state);\n    this.enterRule(_localctx, 178, _SolidityParser.RULE_assemblyIf);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 1077;\n        this.match(_SolidityParser.T__42);\n        this.state = 1078;\n        this.assemblyExpression();\n        this.state = 1079;\n        this.assemblyBlock();\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  assemblyLiteral() {\n    let _localctx = new AssemblyLiteralContext(this._ctx, this.state);\n    this.enterRule(_localctx, 180, _SolidityParser.RULE_assemblyLiteral);\n    try {\n      this.state = 1086;\n      this._errHandler.sync(this);\n      switch (this._input.LA(1)) {\n        case _SolidityParser.StringLiteralFragment:\n          this.enterOuterAlt(_localctx, 1);\n          {\n            this.state = 1081;\n            this.stringLiteral();\n          }\n          break;\n        case _SolidityParser.DecimalNumber:\n          this.enterOuterAlt(_localctx, 2);\n          {\n            this.state = 1082;\n            this.match(_SolidityParser.DecimalNumber);\n          }\n          break;\n        case _SolidityParser.HexNumber:\n          this.enterOuterAlt(_localctx, 3);\n          {\n            this.state = 1083;\n            this.match(_SolidityParser.HexNumber);\n          }\n          break;\n        case _SolidityParser.HexLiteralFragment:\n          this.enterOuterAlt(_localctx, 4);\n          {\n            this.state = 1084;\n            this.hexLiteral();\n          }\n          break;\n        case _SolidityParser.BooleanLiteral:\n          this.enterOuterAlt(_localctx, 5);\n          {\n            this.state = 1085;\n            this.match(_SolidityParser.BooleanLiteral);\n          }\n          break;\n        default:\n          throw new import_NoViableAltException.NoViableAltException(this);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  subAssembly() {\n    let _localctx = new SubAssemblyContext(this._ctx, this.state);\n    this.enterRule(_localctx, 182, _SolidityParser.RULE_subAssembly);\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 1088;\n        this.match(_SolidityParser.T__48);\n        this.state = 1089;\n        this.identifier();\n        this.state = 1090;\n        this.assemblyBlock();\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  tupleExpression() {\n    let _localctx = new TupleExpressionContext(this._ctx, this.state);\n    this.enterRule(_localctx, 184, _SolidityParser.RULE_tupleExpression);\n    let _la;\n    try {\n      this.state = 1118;\n      this._errHandler.sync(this);\n      switch (this._input.LA(1)) {\n        case _SolidityParser.T__22:\n          this.enterOuterAlt(_localctx, 1);\n          {\n            this.state = 1092;\n            this.match(_SolidityParser.T__22);\n            {\n              this.state = 1094;\n              this._errHandler.sync(this);\n              _la = this._input.LA(1);\n              if ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {\n                {\n                  this.state = 1093;\n                  this.expression(0);\n                }\n              }\n              this.state = 1102;\n              this._errHandler.sync(this);\n              _la = this._input.LA(1);\n              while (_la === _SolidityParser.T__15) {\n                {\n                  {\n                    this.state = 1096;\n                    this.match(_SolidityParser.T__15);\n                    this.state = 1098;\n                    this._errHandler.sync(this);\n                    _la = this._input.LA(1);\n                    if ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {\n                      {\n                        this.state = 1097;\n                        this.expression(0);\n                      }\n                    }\n                  }\n                }\n                this.state = 1104;\n                this._errHandler.sync(this);\n                _la = this._input.LA(1);\n              }\n            }\n            this.state = 1105;\n            this.match(_SolidityParser.T__23);\n          }\n          break;\n        case _SolidityParser.T__33:\n          this.enterOuterAlt(_localctx, 2);\n          {\n            this.state = 1106;\n            this.match(_SolidityParser.T__33);\n            this.state = 1115;\n            this._errHandler.sync(this);\n            _la = this._input.LA(1);\n            if ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {\n              {\n                this.state = 1107;\n                this.expression(0);\n                this.state = 1112;\n                this._errHandler.sync(this);\n                _la = this._input.LA(1);\n                while (_la === _SolidityParser.T__15) {\n                  {\n                    {\n                      this.state = 1108;\n                      this.match(_SolidityParser.T__15);\n                      this.state = 1109;\n                      this.expression(0);\n                    }\n                  }\n                  this.state = 1114;\n                  this._errHandler.sync(this);\n                  _la = this._input.LA(1);\n                }\n              }\n            }\n            this.state = 1117;\n            this.match(_SolidityParser.T__34);\n          }\n          break;\n        default:\n          throw new import_NoViableAltException.NoViableAltException(this);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  numberLiteral() {\n    let _localctx = new NumberLiteralContext(this._ctx, this.state);\n    this.enterRule(_localctx, 186, _SolidityParser.RULE_numberLiteral);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 1120;\n        _la = this._input.LA(1);\n        if (!(_la === _SolidityParser.DecimalNumber || _la === _SolidityParser.HexNumber)) {\n          this._errHandler.recoverInline(this);\n        } else {\n          if (this._input.LA(1) === import_Token.Token.EOF) {\n            this.matchedEOF = true;\n          }\n          this._errHandler.reportMatch(this);\n          this.consume();\n        }\n        this.state = 1122;\n        this._errHandler.sync(this);\n        switch (this.interpreter.adaptivePredict(this._input, 122, this._ctx)) {\n          case 1:\n            {\n              this.state = 1121;\n              this.match(_SolidityParser.NumberUnit);\n            }\n            break;\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  identifier() {\n    let _localctx = new IdentifierContext(this._ctx, this.state);\n    this.enterRule(_localctx, 188, _SolidityParser.RULE_identifier);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 1124;\n        _la = this._input.LA(1);\n        if (!(_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier)) {\n          this._errHandler.recoverInline(this);\n        } else {\n          if (this._input.LA(1) === import_Token.Token.EOF) {\n            this.matchedEOF = true;\n          }\n          this._errHandler.reportMatch(this);\n          this.consume();\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  hexLiteral() {\n    let _localctx = new HexLiteralContext(this._ctx, this.state);\n    this.enterRule(_localctx, 190, _SolidityParser.RULE_hexLiteral);\n    try {\n      let _alt;\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 1127;\n        this._errHandler.sync(this);\n        _alt = 1;\n        do {\n          switch (_alt) {\n            case 1:\n              {\n                {\n                  this.state = 1126;\n                  this.match(_SolidityParser.HexLiteralFragment);\n                }\n              }\n              break;\n            default:\n              throw new import_NoViableAltException.NoViableAltException(this);\n          }\n          this.state = 1129;\n          this._errHandler.sync(this);\n          _alt = this.interpreter.adaptivePredict(this._input, 123, this._ctx);\n        } while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  overrideSpecifier() {\n    let _localctx = new OverrideSpecifierContext(this._ctx, this.state);\n    this.enterRule(_localctx, 192, _SolidityParser.RULE_overrideSpecifier);\n    let _la;\n    try {\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 1131;\n        this.match(_SolidityParser.T__96);\n        this.state = 1143;\n        this._errHandler.sync(this);\n        _la = this._input.LA(1);\n        if (_la === _SolidityParser.T__22) {\n          {\n            this.state = 1132;\n            this.match(_SolidityParser.T__22);\n            this.state = 1133;\n            this.userDefinedTypeName();\n            this.state = 1138;\n            this._errHandler.sync(this);\n            _la = this._input.LA(1);\n            while (_la === _SolidityParser.T__15) {\n              {\n                {\n                  this.state = 1134;\n                  this.match(_SolidityParser.T__15);\n                  this.state = 1135;\n                  this.userDefinedTypeName();\n                }\n              }\n              this.state = 1140;\n              this._errHandler.sync(this);\n              _la = this._input.LA(1);\n            }\n            this.state = 1141;\n            this.match(_SolidityParser.T__23);\n          }\n        }\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  stringLiteral() {\n    let _localctx = new StringLiteralContext(this._ctx, this.state);\n    this.enterRule(_localctx, 194, _SolidityParser.RULE_stringLiteral);\n    try {\n      let _alt;\n      this.enterOuterAlt(_localctx, 1);\n      {\n        this.state = 1146;\n        this._errHandler.sync(this);\n        _alt = 1;\n        do {\n          switch (_alt) {\n            case 1:\n              {\n                {\n                  this.state = 1145;\n                  this.match(_SolidityParser.StringLiteralFragment);\n                }\n              }\n              break;\n            default:\n              throw new import_NoViableAltException.NoViableAltException(this);\n          }\n          this.state = 1148;\n          this._errHandler.sync(this);\n          _alt = this.interpreter.adaptivePredict(this._input, 126, this._ctx);\n        } while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER);\n      }\n    } catch (re) {\n      if (re instanceof import_RecognitionException.RecognitionException) {\n        _localctx.exception = re;\n        this._errHandler.reportError(this, re);\n        this._errHandler.recover(this, re);\n      } else {\n        throw re;\n      }\n    } finally {\n      this.exitRule();\n    }\n    return _localctx;\n  }\n  sempred(_localctx, ruleIndex, predIndex) {\n    switch (ruleIndex) {\n      case 36:\n        return this.typeName_sempred(_localctx, predIndex);\n      case 66:\n        return this.expression_sempred(_localctx, predIndex);\n    }\n    return true;\n  }\n  typeName_sempred(_localctx, predIndex) {\n    switch (predIndex) {\n      case 0:\n        return this.precpred(this._ctx, 3);\n    }\n    return true;\n  }\n  expression_sempred(_localctx, predIndex) {\n    switch (predIndex) {\n      case 1:\n        return this.precpred(this._ctx, 14);\n      case 2:\n        return this.precpred(this._ctx, 13);\n      case 3:\n        return this.precpred(this._ctx, 12);\n      case 4:\n        return this.precpred(this._ctx, 11);\n      case 5:\n        return this.precpred(this._ctx, 10);\n      case 6:\n        return this.precpred(this._ctx, 9);\n      case 7:\n        return this.precpred(this._ctx, 8);\n      case 8:\n        return this.precpred(this._ctx, 7);\n      case 9:\n        return this.precpred(this._ctx, 6);\n      case 10:\n        return this.precpred(this._ctx, 5);\n      case 11:\n        return this.precpred(this._ctx, 4);\n      case 12:\n        return this.precpred(this._ctx, 3);\n      case 13:\n        return this.precpred(this._ctx, 2);\n      case 14:\n        return this.precpred(this._ctx, 27);\n      case 15:\n        return this.precpred(this._ctx, 25);\n      case 16:\n        return this.precpred(this._ctx, 24);\n      case 17:\n        return this.precpred(this._ctx, 23);\n      case 18:\n        return this.precpred(this._ctx, 22);\n      case 19:\n        return this.precpred(this._ctx, 21);\n    }\n    return true;\n  }\n  static get _ATN() {\n    if (!_SolidityParser.__ATN) {\n      _SolidityParser.__ATN = new import_ATNDeserializer2.ATNDeserializer().deserialize(Utils2.toCharArray(_SolidityParser._serializedATN));\n    }\n    return _SolidityParser.__ATN;\n  }\n};\nvar SolidityParser = _SolidityParser;\nSolidityParser.T__0 = 1;\nSolidityParser.T__1 = 2;\nSolidityParser.T__2 = 3;\nSolidityParser.T__3 = 4;\nSolidityParser.T__4 = 5;\nSolidityParser.T__5 = 6;\nSolidityParser.T__6 = 7;\nSolidityParser.T__7 = 8;\nSolidityParser.T__8 = 9;\nSolidityParser.T__9 = 10;\nSolidityParser.T__10 = 11;\nSolidityParser.T__11 = 12;\nSolidityParser.T__12 = 13;\nSolidityParser.T__13 = 14;\nSolidityParser.T__14 = 15;\nSolidityParser.T__15 = 16;\nSolidityParser.T__16 = 17;\nSolidityParser.T__17 = 18;\nSolidityParser.T__18 = 19;\nSolidityParser.T__19 = 20;\nSolidityParser.T__20 = 21;\nSolidityParser.T__21 = 22;\nSolidityParser.T__22 = 23;\nSolidityParser.T__23 = 24;\nSolidityParser.T__24 = 25;\nSolidityParser.T__25 = 26;\nSolidityParser.T__26 = 27;\nSolidityParser.T__27 = 28;\nSolidityParser.T__28 = 29;\nSolidityParser.T__29 = 30;\nSolidityParser.T__30 = 31;\nSolidityParser.T__31 = 32;\nSolidityParser.T__32 = 33;\nSolidityParser.T__33 = 34;\nSolidityParser.T__34 = 35;\nSolidityParser.T__35 = 36;\nSolidityParser.T__36 = 37;\nSolidityParser.T__37 = 38;\nSolidityParser.T__38 = 39;\nSolidityParser.T__39 = 40;\nSolidityParser.T__40 = 41;\nSolidityParser.T__41 = 42;\nSolidityParser.T__42 = 43;\nSolidityParser.T__43 = 44;\nSolidityParser.T__44 = 45;\nSolidityParser.T__45 = 46;\nSolidityParser.T__46 = 47;\nSolidityParser.T__47 = 48;\nSolidityParser.T__48 = 49;\nSolidityParser.T__49 = 50;\nSolidityParser.T__50 = 51;\nSolidityParser.T__51 = 52;\nSolidityParser.T__52 = 53;\nSolidityParser.T__53 = 54;\nSolidityParser.T__54 = 55;\nSolidityParser.T__55 = 56;\nSolidityParser.T__56 = 57;\nSolidityParser.T__57 = 58;\nSolidityParser.T__58 = 59;\nSolidityParser.T__59 = 60;\nSolidityParser.T__60 = 61;\nSolidityParser.T__61 = 62;\nSolidityParser.T__62 = 63;\nSolidityParser.T__63 = 64;\nSolidityParser.T__64 = 65;\nSolidityParser.T__65 = 66;\nSolidityParser.T__66 = 67;\nSolidityParser.T__67 = 68;\nSolidityParser.T__68 = 69;\nSolidityParser.T__69 = 70;\nSolidityParser.T__70 = 71;\nSolidityParser.T__71 = 72;\nSolidityParser.T__72 = 73;\nSolidityParser.T__73 = 74;\nSolidityParser.T__74 = 75;\nSolidityParser.T__75 = 76;\nSolidityParser.T__76 = 77;\nSolidityParser.T__77 = 78;\nSolidityParser.T__78 = 79;\nSolidityParser.T__79 = 80;\nSolidityParser.T__80 = 81;\nSolidityParser.T__81 = 82;\nSolidityParser.T__82 = 83;\nSolidityParser.T__83 = 84;\nSolidityParser.T__84 = 85;\nSolidityParser.T__85 = 86;\nSolidityParser.T__86 = 87;\nSolidityParser.T__87 = 88;\nSolidityParser.T__88 = 89;\nSolidityParser.T__89 = 90;\nSolidityParser.T__90 = 91;\nSolidityParser.T__91 = 92;\nSolidityParser.T__92 = 93;\nSolidityParser.T__93 = 94;\nSolidityParser.T__94 = 95;\nSolidityParser.T__95 = 96;\nSolidityParser.T__96 = 97;\nSolidityParser.Int = 98;\nSolidityParser.Uint = 99;\nSolidityParser.Byte = 100;\nSolidityParser.Fixed = 101;\nSolidityParser.Ufixed = 102;\nSolidityParser.BooleanLiteral = 103;\nSolidityParser.DecimalNumber = 104;\nSolidityParser.HexNumber = 105;\nSolidityParser.NumberUnit = 106;\nSolidityParser.HexLiteralFragment = 107;\nSolidityParser.ReservedKeyword = 108;\nSolidityParser.AnonymousKeyword = 109;\nSolidityParser.BreakKeyword = 110;\nSolidityParser.ConstantKeyword = 111;\nSolidityParser.ImmutableKeyword = 112;\nSolidityParser.ContinueKeyword = 113;\nSolidityParser.LeaveKeyword = 114;\nSolidityParser.ExternalKeyword = 115;\nSolidityParser.IndexedKeyword = 116;\nSolidityParser.InternalKeyword = 117;\nSolidityParser.PayableKeyword = 118;\nSolidityParser.PrivateKeyword = 119;\nSolidityParser.PublicKeyword = 120;\nSolidityParser.VirtualKeyword = 121;\nSolidityParser.PureKeyword = 122;\nSolidityParser.TypeKeyword = 123;\nSolidityParser.ViewKeyword = 124;\nSolidityParser.GlobalKeyword = 125;\nSolidityParser.ConstructorKeyword = 126;\nSolidityParser.FallbackKeyword = 127;\nSolidityParser.ReceiveKeyword = 128;\nSolidityParser.Identifier = 129;\nSolidityParser.StringLiteralFragment = 130;\nSolidityParser.VersionLiteral = 131;\nSolidityParser.WS = 132;\nSolidityParser.COMMENT = 133;\nSolidityParser.LINE_COMMENT = 134;\nSolidityParser.RULE_sourceUnit = 0;\nSolidityParser.RULE_pragmaDirective = 1;\nSolidityParser.RULE_pragmaName = 2;\nSolidityParser.RULE_pragmaValue = 3;\nSolidityParser.RULE_version = 4;\nSolidityParser.RULE_versionOperator = 5;\nSolidityParser.RULE_versionConstraint = 6;\nSolidityParser.RULE_importDeclaration = 7;\nSolidityParser.RULE_importDirective = 8;\nSolidityParser.RULE_importPath = 9;\nSolidityParser.RULE_contractDefinition = 10;\nSolidityParser.RULE_inheritanceSpecifier = 11;\nSolidityParser.RULE_contractPart = 12;\nSolidityParser.RULE_stateVariableDeclaration = 13;\nSolidityParser.RULE_fileLevelConstant = 14;\nSolidityParser.RULE_customErrorDefinition = 15;\nSolidityParser.RULE_typeDefinition = 16;\nSolidityParser.RULE_usingForDeclaration = 17;\nSolidityParser.RULE_usingForObject = 18;\nSolidityParser.RULE_structDefinition = 19;\nSolidityParser.RULE_modifierDefinition = 20;\nSolidityParser.RULE_modifierInvocation = 21;\nSolidityParser.RULE_functionDefinition = 22;\nSolidityParser.RULE_functionDescriptor = 23;\nSolidityParser.RULE_returnParameters = 24;\nSolidityParser.RULE_modifierList = 25;\nSolidityParser.RULE_eventDefinition = 26;\nSolidityParser.RULE_enumValue = 27;\nSolidityParser.RULE_enumDefinition = 28;\nSolidityParser.RULE_parameterList = 29;\nSolidityParser.RULE_parameter = 30;\nSolidityParser.RULE_eventParameterList = 31;\nSolidityParser.RULE_eventParameter = 32;\nSolidityParser.RULE_functionTypeParameterList = 33;\nSolidityParser.RULE_functionTypeParameter = 34;\nSolidityParser.RULE_variableDeclaration = 35;\nSolidityParser.RULE_typeName = 36;\nSolidityParser.RULE_userDefinedTypeName = 37;\nSolidityParser.RULE_mappingKey = 38;\nSolidityParser.RULE_mapping = 39;\nSolidityParser.RULE_functionTypeName = 40;\nSolidityParser.RULE_storageLocation = 41;\nSolidityParser.RULE_stateMutability = 42;\nSolidityParser.RULE_block = 43;\nSolidityParser.RULE_statement = 44;\nSolidityParser.RULE_expressionStatement = 45;\nSolidityParser.RULE_ifStatement = 46;\nSolidityParser.RULE_tryStatement = 47;\nSolidityParser.RULE_catchClause = 48;\nSolidityParser.RULE_whileStatement = 49;\nSolidityParser.RULE_simpleStatement = 50;\nSolidityParser.RULE_uncheckedStatement = 51;\nSolidityParser.RULE_forStatement = 52;\nSolidityParser.RULE_inlineAssemblyStatement = 53;\nSolidityParser.RULE_inlineAssemblyStatementFlag = 54;\nSolidityParser.RULE_doWhileStatement = 55;\nSolidityParser.RULE_continueStatement = 56;\nSolidityParser.RULE_breakStatement = 57;\nSolidityParser.RULE_returnStatement = 58;\nSolidityParser.RULE_throwStatement = 59;\nSolidityParser.RULE_emitStatement = 60;\nSolidityParser.RULE_revertStatement = 61;\nSolidityParser.RULE_variableDeclarationStatement = 62;\nSolidityParser.RULE_variableDeclarationList = 63;\nSolidityParser.RULE_identifierList = 64;\nSolidityParser.RULE_elementaryTypeName = 65;\nSolidityParser.RULE_expression = 66;\nSolidityParser.RULE_primaryExpression = 67;\nSolidityParser.RULE_expressionList = 68;\nSolidityParser.RULE_nameValueList = 69;\nSolidityParser.RULE_nameValue = 70;\nSolidityParser.RULE_functionCallArguments = 71;\nSolidityParser.RULE_functionCall = 72;\nSolidityParser.RULE_assemblyBlock = 73;\nSolidityParser.RULE_assemblyItem = 74;\nSolidityParser.RULE_assemblyExpression = 75;\nSolidityParser.RULE_assemblyMember = 76;\nSolidityParser.RULE_assemblyCall = 77;\nSolidityParser.RULE_assemblyLocalDefinition = 78;\nSolidityParser.RULE_assemblyAssignment = 79;\nSolidityParser.RULE_assemblyIdentifierOrList = 80;\nSolidityParser.RULE_assemblyIdentifierList = 81;\nSolidityParser.RULE_assemblyStackAssignment = 82;\nSolidityParser.RULE_labelDefinition = 83;\nSolidityParser.RULE_assemblySwitch = 84;\nSolidityParser.RULE_assemblyCase = 85;\nSolidityParser.RULE_assemblyFunctionDefinition = 86;\nSolidityParser.RULE_assemblyFunctionReturns = 87;\nSolidityParser.RULE_assemblyFor = 88;\nSolidityParser.RULE_assemblyIf = 89;\nSolidityParser.RULE_assemblyLiteral = 90;\nSolidityParser.RULE_subAssembly = 91;\nSolidityParser.RULE_tupleExpression = 92;\nSolidityParser.RULE_numberLiteral = 93;\nSolidityParser.RULE_identifier = 94;\nSolidityParser.RULE_hexLiteral = 95;\nSolidityParser.RULE_overrideSpecifier = 96;\nSolidityParser.RULE_stringLiteral = 97;\nSolidityParser.ruleNames = [\n  \"sourceUnit\",\n  \"pragmaDirective\",\n  \"pragmaName\",\n  \"pragmaValue\",\n  \"version\",\n  \"versionOperator\",\n  \"versionConstraint\",\n  \"importDeclaration\",\n  \"importDirective\",\n  \"importPath\",\n  \"contractDefinition\",\n  \"inheritanceSpecifier\",\n  \"contractPart\",\n  \"stateVariableDeclaration\",\n  \"fileLevelConstant\",\n  \"customErrorDefinition\",\n  \"typeDefinition\",\n  \"usingForDeclaration\",\n  \"usingForObject\",\n  \"structDefinition\",\n  \"modifierDefinition\",\n  \"modifierInvocation\",\n  \"functionDefinition\",\n  \"functionDescriptor\",\n  \"returnParameters\",\n  \"modifierList\",\n  \"eventDefinition\",\n  \"enumValue\",\n  \"enumDefinition\",\n  \"parameterList\",\n  \"parameter\",\n  \"eventParameterList\",\n  \"eventParameter\",\n  \"functionTypeParameterList\",\n  \"functionTypeParameter\",\n  \"variableDeclaration\",\n  \"typeName\",\n  \"userDefinedTypeName\",\n  \"mappingKey\",\n  \"mapping\",\n  \"functionTypeName\",\n  \"storageLocation\",\n  \"stateMutability\",\n  \"block\",\n  \"statement\",\n  \"expressionStatement\",\n  \"ifStatement\",\n  \"tryStatement\",\n  \"catchClause\",\n  \"whileStatement\",\n  \"simpleStatement\",\n  \"uncheckedStatement\",\n  \"forStatement\",\n  \"inlineAssemblyStatement\",\n  \"inlineAssemblyStatementFlag\",\n  \"doWhileStatement\",\n  \"continueStatement\",\n  \"breakStatement\",\n  \"returnStatement\",\n  \"throwStatement\",\n  \"emitStatement\",\n  \"revertStatement\",\n  \"variableDeclarationStatement\",\n  \"variableDeclarationList\",\n  \"identifierList\",\n  \"elementaryTypeName\",\n  \"expression\",\n  \"primaryExpression\",\n  \"expressionList\",\n  \"nameValueList\",\n  \"nameValue\",\n  \"functionCallArguments\",\n  \"functionCall\",\n  \"assemblyBlock\",\n  \"assemblyItem\",\n  \"assemblyExpression\",\n  \"assemblyMember\",\n  \"assemblyCall\",\n  \"assemblyLocalDefinition\",\n  \"assemblyAssignment\",\n  \"assemblyIdentifierOrList\",\n  \"assemblyIdentifierList\",\n  \"assemblyStackAssignment\",\n  \"labelDefinition\",\n  \"assemblySwitch\",\n  \"assemblyCase\",\n  \"assemblyFunctionDefinition\",\n  \"assemblyFunctionReturns\",\n  \"assemblyFor\",\n  \"assemblyIf\",\n  \"assemblyLiteral\",\n  \"subAssembly\",\n  \"tupleExpression\",\n  \"numberLiteral\",\n  \"identifier\",\n  \"hexLiteral\",\n  \"overrideSpecifier\",\n  \"stringLiteral\"\n];\nSolidityParser._LITERAL_NAMES = [\n  void 0,\n  \"'pragma'\",\n  \"';'\",\n  \"'*'\",\n  \"'||'\",\n  \"'^'\",\n  \"'~'\",\n  \"'>='\",\n  \"'>'\",\n  \"'<'\",\n  \"'<='\",\n  \"'='\",\n  \"'as'\",\n  \"'import'\",\n  \"'from'\",\n  \"'{'\",\n  \"','\",\n  \"'}'\",\n  \"'abstract'\",\n  \"'contract'\",\n  \"'interface'\",\n  \"'library'\",\n  \"'is'\",\n  \"'('\",\n  \"')'\",\n  \"'error'\",\n  \"'using'\",\n  \"'for'\",\n  \"'struct'\",\n  \"'modifier'\",\n  \"'function'\",\n  \"'returns'\",\n  \"'event'\",\n  \"'enum'\",\n  \"'['\",\n  \"']'\",\n  \"'address'\",\n  \"'.'\",\n  \"'mapping'\",\n  \"'=>'\",\n  \"'memory'\",\n  \"'storage'\",\n  \"'calldata'\",\n  \"'if'\",\n  \"'else'\",\n  \"'try'\",\n  \"'catch'\",\n  \"'while'\",\n  \"'unchecked'\",\n  \"'assembly'\",\n  \"'do'\",\n  \"'return'\",\n  \"'throw'\",\n  \"'emit'\",\n  \"'revert'\",\n  \"'var'\",\n  \"'bool'\",\n  \"'string'\",\n  \"'byte'\",\n  \"'++'\",\n  \"'--'\",\n  \"'new'\",\n  \"':'\",\n  \"'+'\",\n  \"'-'\",\n  \"'after'\",\n  \"'delete'\",\n  \"'!'\",\n  \"'**'\",\n  \"'/'\",\n  \"'%'\",\n  \"'<<'\",\n  \"'>>'\",\n  \"'&'\",\n  \"'|'\",\n  \"'=='\",\n  \"'!='\",\n  \"'&&'\",\n  \"'?'\",\n  \"'|='\",\n  \"'^='\",\n  \"'&='\",\n  \"'<<='\",\n  \"'>>='\",\n  \"'+='\",\n  \"'-='\",\n  \"'*='\",\n  \"'/='\",\n  \"'%='\",\n  \"'let'\",\n  \"':='\",\n  \"'=:'\",\n  \"'switch'\",\n  \"'case'\",\n  \"'default'\",\n  \"'->'\",\n  \"'callback'\",\n  \"'override'\",\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  \"'anonymous'\",\n  \"'break'\",\n  \"'constant'\",\n  \"'immutable'\",\n  \"'continue'\",\n  \"'leave'\",\n  \"'external'\",\n  \"'indexed'\",\n  \"'internal'\",\n  \"'payable'\",\n  \"'private'\",\n  \"'public'\",\n  \"'virtual'\",\n  \"'pure'\",\n  \"'type'\",\n  \"'view'\",\n  \"'global'\",\n  \"'constructor'\",\n  \"'fallback'\",\n  \"'receive'\"\n];\nSolidityParser._SYMBOLIC_NAMES = [\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  void 0,\n  \"Int\",\n  \"Uint\",\n  \"Byte\",\n  \"Fixed\",\n  \"Ufixed\",\n  \"BooleanLiteral\",\n  \"DecimalNumber\",\n  \"HexNumber\",\n  \"NumberUnit\",\n  \"HexLiteralFragment\",\n  \"ReservedKeyword\",\n  \"AnonymousKeyword\",\n  \"BreakKeyword\",\n  \"ConstantKeyword\",\n  \"ImmutableKeyword\",\n  \"ContinueKeyword\",\n  \"LeaveKeyword\",\n  \"ExternalKeyword\",\n  \"IndexedKeyword\",\n  \"InternalKeyword\",\n  \"PayableKeyword\",\n  \"PrivateKeyword\",\n  \"PublicKeyword\",\n  \"VirtualKeyword\",\n  \"PureKeyword\",\n  \"TypeKeyword\",\n  \"ViewKeyword\",\n  \"GlobalKeyword\",\n  \"ConstructorKeyword\",\n  \"FallbackKeyword\",\n  \"ReceiveKeyword\",\n  \"Identifier\",\n  \"StringLiteralFragment\",\n  \"VersionLiteral\",\n  \"WS\",\n  \"COMMENT\",\n  \"LINE_COMMENT\"\n];\nSolidityParser.VOCABULARY = new import_VocabularyImpl2.VocabularyImpl(_SolidityParser._LITERAL_NAMES, _SolidityParser._SYMBOLIC_NAMES, []);\nSolidityParser._serializedATNSegments = 3;\nSolidityParser._serializedATNSegment0 = \"\u0003\\uC91D\\uCABA\\u058D\\uAFBA\\u4F53\\u0607\\uEA8B\\uC241\u0003\\x88\\u0481\u0004\u0002\t\u0002\u0004\u0003\t\u0003\u0004\u0004\t\u0004\u0004\u0005\t\u0005\u0004\u0006\t\u0006\u0004\\x07\t\\x07\u0004\\b\t\\b\u0004\t\t\t\u0004\\n\t\\n\u0004\\v\t\\v\u0004\\f\t\\f\u0004\\r\t\\r\u0004\u000e\t\u000e\u0004\u000f\t\u000f\u0004\u0010\t\u0010\u0004\u0011\t\u0011\u0004\u0012\t\u0012\u0004\u0013\t\u0013\u0004\u0014\t\u0014\u0004\u0015\t\u0015\u0004\u0016\t\u0016\u0004\u0017\t\u0017\u0004\u0018\t\u0018\u0004\u0019\t\u0019\u0004\u001a\t\u001a\u0004\u001b\t\u001b\u0004\u001c\t\u001c\u0004\u001d\t\u001d\u0004\u001e\t\u001e\u0004\u001f\t\u001f\u0004 \t \u0004!\t!\u0004\\\"\t\\\"\u0004#\t#\u0004$\t$\u0004%\t%\u0004&\t&\u0004'\t'\u0004(\t(\u0004)\t)\u0004*\t*\u0004+\t+\u0004,\t,\u0004-\t-\u0004.\t.\u0004/\t/\u00040\t0\u00041\t1\u00042\t2\u00043\t3\u00044\t4\u00045\t5\u00046\t6\u00047\t7\u00048\t8\u00049\t9\u0004:\t:\u0004;\t;\u0004<\t<\u0004=\t=\u0004>\t>\u0004?\t?\u0004@\t@\u0004A\tA\u0004B\tB\u0004C\tC\u0004D\tD\u0004E\tE\u0004F\tF\u0004G\tG\u0004H\tH\u0004I\tI\u0004J\tJ\u0004K\tK\u0004L\tL\u0004M\tM\u0004N\tN\u0004O\tO\u0004P\tP\u0004Q\tQ\u0004R\tR\u0004S\tS\u0004T\tT\u0004U\tU\u0004V\tV\u0004W\tW\u0004X\tX\u0004Y\tY\u0004Z\tZ\u0004[\t[\u0004\\\\\t\\\\\u0004]\t]\u0004^\t^\u0004_\t_\u0004`\t`\u0004a\ta\u0004b\tb\u0004c\tc\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\\x07\u0002\\xD1\\n\u0002\\f\u0002\u000e\u0002\\xD4\\v\u0002\u0003\u0002\u0003\u0002\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0004\u0003\u0004\u0003\u0005\u0003\u0005\u0003\u0005\u0005\u0005\\xE2\\n\u0005\u0003\u0006\u0003\u0006\u0005\u0006\\xE6\\n\u0006\u0003\u0006\\x07\u0006\\xE9\\n\u0006\\f\u0006\u000e\u0006\\xEC\\v\u0006\u0003\\x07\u0003\\x07\u0003\\b\u0005\\b\\xF1\\n\\b\u0003\\b\u0003\\b\u0005\\b\\xF5\\n\\b\u0003\\b\u0005\\b\\xF8\\n\\b\u0003\t\u0003\t\u0003\t\u0005\t\\xFD\\n\t\u0003\\n\u0003\\n\u0003\\n\u0003\\n\u0005\\n\\u0103\\n\\n\u0003\\n\u0003\\n\u0003\\n\u0003\\n\u0003\\n\u0005\\n\\u010A\\n\\n\u0003\\n\u0003\\n\u0005\\n\\u010E\\n\\n\u0003\\n\u0003\\n\u0003\\n\u0003\\n\u0003\\n\u0003\\n\u0003\\n\u0003\\n\u0003\\n\\x07\\n\\u0119\\n\\n\\f\\n\u000e\\n\\u011C\\v\\n\u0003\\n\u0003\\n\u0003\\n\u0003\\n\u0003\\n\u0005\\n\\u0123\\n\\n\u0003\\v\u0003\\v\u0003\\f\u0005\\f\\u0128\\n\\f\u0003\\f\u0003\\f\u0003\\f\u0003\\f\u0003\\f\u0003\\f\\x07\\f\\u0130\\n\\f\\f\\f\u000e\\f\\u0133\\v\\f\u0005\\f\\u0135\\n\\f\u0003\\f\u0003\\f\\x07\\f\\u0139\\n\\f\\f\\f\u000e\\f\\u013C\\v\\f\u0003\\f\u0003\\f\u0003\\r\u0003\\r\u0003\\r\u0005\\r\\u0143\\n\\r\u0003\\r\u0005\\r\\u0146\\n\\r\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0005\u000e\\u0151\\n\u000e\u0003\u000f\u0003\u000f\u0003\u000f\u0003\u000f\u0003\u000f\u0003\u000f\u0003\u000f\\x07\u000f\\u015A\\n\u000f\\f\u000f\u000e\u000f\\u015D\\v\u000f\u0003\u000f\u0003\u000f\u0003\u000f\u0005\u000f\\u0162\\n\u000f\u0003\u000f\u0003\u000f\u0003\u0010\u0003\u0010\u0003\u0010\u0003\u0010\u0003\u0010\u0003\u0010\u0003\u0010\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0012\u0003\u0012\u0003\u0012\u0003\u0012\u0003\u0012\u0003\u0012\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0005\u0013\\u017D\\n\u0013\u0003\u0013\u0005\u0013\\u0180\\n\u0013\u0003\u0013\u0003\u0013\u0003\u0014\u0003\u0014\u0003\u0014\u0003\u0014\u0003\u0014\\x07\u0014\\u0189\\n\u0014\\f\u0014\u000e\u0014\\u018C\\v\u0014\u0003\u0014\u0003\u0014\u0005\u0014\\u0190\\n\u0014\u0003\u0015\u0003\u0015\u0003\u0015\u0003\u0015\u0003\u0015\u0003\u0015\u0003\u0015\u0003\u0015\\x07\u0015\\u019A\\n\u0015\\f\u0015\u000e\u0015\\u019D\\v\u0015\u0005\u0015\\u019F\\n\u0015\u0003\u0015\u0003\u0015\u0003\u0016\u0003\u0016\u0003\u0016\u0005\u0016\\u01A6\\n\u0016\u0003\u0016\u0003\u0016\\x07\u0016\\u01AA\\n\u0016\\f\u0016\u000e\u0016\\u01AD\\v\u0016\u0003\u0016\u0003\u0016\u0005\u0016\\u01B1\\n\u0016\u0003\u0017\u0003\u0017\u0003\u0017\u0005\u0017\\u01B6\\n\u0017\u0003\u0017\u0005\u0017\\u01B9\\n\u0017\u0003\u0018\u0003\u0018\u0003\u0018\u0003\u0018\u0005\u0018\\u01BF\\n\u0018\u0003\u0018\u0003\u0018\u0005\u0018\\u01C3\\n\u0018\u0003\u0019\u0003\u0019\u0005\u0019\\u01C7\\n\u0019\u0003\u0019\u0003\u0019\u0003\u0019\u0005\u0019\\u01CC\\n\u0019\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b\\x07\u001b\\u01D9\\n\u001b\\f\u001b\u000e\u001b\\u01DC\\v\u001b\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0005\u001c\\u01E2\\n\u001c\u0003\u001c\u0003\u001c\u0003\u001d\u0003\u001d\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001e\u0005\u001e\\u01EC\\n\u001e\u0003\u001e\u0003\u001e\\x07\u001e\\u01F0\\n\u001e\\f\u001e\u000e\u001e\\u01F3\\v\u001e\u0003\u001e\u0003\u001e\u0003\u001f\u0003\u001f\u0003\u001f\u0003\u001f\\x07\u001f\\u01FB\\n\u001f\\f\u001f\u000e\u001f\\u01FE\\v\u001f\u0005\u001f\\u0200\\n\u001f\u0003\u001f\u0003\u001f\u0003 \u0003 \u0005 \\u0206\\n \u0003 \u0005 \\u0209\\n \u0003!\u0003!\u0003!\u0003!\\x07!\\u020F\\n!\\f!\u000e!\\u0212\\v!\u0005!\\u0214\\n!\u0003!\u0003!\u0003\\\"\u0003\\\"\u0005\\\"\\u021A\\n\\\"\u0003\\\"\u0005\\\"\\u021D\\n\\\"\u0003#\u0003#\u0003#\u0003#\\x07#\\u0223\\n#\\f#\u000e#\\u0226\\v#\u0005#\\u0228\\n#\u0003#\u0003#\u0003$\u0003$\u0005$\\u022E\\n$\u0003%\u0003%\u0005%\\u0232\\n%\u0003%\u0003%\u0003&\u0003&\u0003&\u0003&\u0003&\u0003&\u0003&\u0005&\\u023D\\n&\u0003&\u0003&\u0003&\u0005&\\u0242\\n&\u0003&\\x07&\\u0245\\n&\\f&\u000e&\\u0248\\v&\u0003'\u0003'\u0003'\\x07'\\u024D\\n'\\f'\u000e'\\u0250\\v'\u0003(\u0003(\u0005(\\u0254\\n(\u0003)\u0003)\u0003)\u0003)\u0003)\u0003)\u0003)\u0003*\u0003*\u0003*\u0003*\u0003*\\x07*\\u0262\\n*\\f*\u000e*\\u0265\\v*\u0003*\u0003*\u0005*\\u0269\\n*\u0003+\u0003+\u0003,\u0003,\u0003-\u0003-\\x07-\\u0271\\n-\\f-\u000e-\\u0274\\v-\u0003-\u0003-\u0003.\u0003.\u0003.\u0003.\u0003.\u0003.\u0003.\u0003.\u0003.\u0003.\u0003.\u0003.\u0003.\u0003.\u0003.\u0005.\\u0287\\n.\u0003/\u0003/\u0003/\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u00050\\u0293\\n0\u00031\u00031\u00031\u00051\\u0298\\n1\u00031\u00031\u00061\\u029C\\n1\\r1\u000e1\\u029D\u00032\u00032\u00052\\u02A2\\n2\u00032\u00052\\u02A5\\n2\u00032\u00032\u00033\u00033\u00033\u00033\u00033\u00033\u00034\u00034\u00054\\u02B1\\n4\u00035\u00035\u00035\u00036\u00036\u00036\u00036\u00056\\u02BA\\n6\u00036\u00036\u00056\\u02BE\\n6\u00036\u00056\\u02C1\\n6\u00036\u00036\u00036\u00037\u00037\u00057\\u02C8\\n7\u00037\u00037\u00037\u00037\u00057\\u02CE\\n7\u00037\u00037\u00038\u00038\u00039\u00039\u00039\u00039\u00039\u00039\u00039\u00039\u0003:\u0003:\u0003:\u0003;\u0003;\u0003;\u0003<\u0003<\u0005<\\u02E4\\n<\u0003<\u0003<\u0003=\u0003=\u0003=\u0003>\u0003>\u0003>\u0003>\u0003?\u0003?\u0003?\u0003?\u0003@\u0003@\u0003@\u0003@\u0003@\u0003@\u0003@\u0005@\\u02FA\\n@\u0003@\u0003@\u0005@\\u02FE\\n@\u0003@\u0003@\u0003A\u0005A\\u0303\\nA\u0003A\u0003A\u0005A\\u0307\\nA\\x07A\\u0309\\nA\\fA\u000eA\\u030C\\vA\u0003B\u0003B\u0005B\\u0310\\nB\u0003B\\x07B\\u0313\\nB\\fB\u000eB\\u0316\\vB\u0003B\u0005B\\u0319\\nB\u0003B\u0003B\u0003C\u0003C\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0005D\\u0331\\nD\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0005D\\u0367\\nD\u0003D\u0003D\u0005D\\u036B\\nD\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\u0003D\\x07D\\u037B\\nD\\fD\u000eD\\u037E\\vD\u0003E\u0003E\u0003E\u0003E\u0003E\u0003E\u0003E\u0003E\u0003E\u0005E\\u0389\\nE\u0003F\u0003F\u0003F\\x07F\\u038E\\nF\\fF\u000eF\\u0391\\vF\u0003G\u0003G\u0003G\\x07G\\u0396\\nG\\fG\u000eG\\u0399\\vG\u0003G\u0005G\\u039C\\nG\u0003H\u0003H\u0003H\u0003H\u0003I\u0003I\u0005I\\u03A4\\nI\u0003I\u0003I\u0005I\\u03A8\\nI\u0005I\\u03AA\\nI\u0003J\u0003J\u0003J\u0003J\u0003J\u0003K\u0003K\\x07K\\u03B3\\nK\\fK\u000eK\\u03B6\\vK\u0003K\u0003K\u0003L\u0003L\u0003L\u0003L\u0003L\u0003L\u0003L\u0003L\u0003L\u0003L\u0003L\u0003L\u0003L\u0003L\u0003L\u0003L\u0003L\u0003L\u0005L\\u03CC\\nL\u0003M\u0003M\u0003M\u0005M\\u03D1\\nM\u0003N\u0003N\u0003N\u0003N\u0003O\u0003O\u0003O\u0003O\u0005O\\u03DB\\nO\u0003O\u0003O\u0005O\\u03DF\\nO\u0003O\u0003O\\x07O\\u03E3\\nO\\fO\u000eO\\u03E6\\vO\u0003O\u0005O\\u03E9\\nO\u0003P\u0003P\u0003P\u0003P\u0005P\\u03EF\\nP\u0003Q\u0003Q\u0003Q\u0003Q\u0003R\u0003R\u0003R\u0003R\u0003R\u0003R\u0003R\u0005R\\u03FC\\nR\u0003S\u0003S\u0003S\\x07S\\u0401\\nS\\fS\u000eS\\u0404\\vS\u0003T\u0003T\u0003T\u0003T\u0003U\u0003U\u0003U\u0003V\u0003V\u0003V\\x07V\\u0410\\nV\\fV\u000eV\\u0413\\vV\u0003W\u0003W\u0003W\u0003W\u0003W\u0003W\u0005W\\u041B\\nW\u0003X\u0003X\u0003X\u0003X\u0005X\\u0421\\nX\u0003X\u0003X\u0005X\\u0425\\nX\u0003X\u0003X\u0003Y\u0003Y\u0003Y\u0003Z\u0003Z\u0003Z\u0005Z\\u042F\\nZ\u0003Z\u0003Z\u0003Z\u0005Z\\u0434\\nZ\u0003Z\u0003Z\u0003[\u0003[\u0003[\u0003[\u0003\\\\\u0003\\\\\u0003\\\\\u0003\\\\\u0003\\\\\u0005\\\\\\u0441\\n\\\\\u0003]\u0003]\u0003]\u0003]\u0003^\u0003^\u0005^\\u0449\\n^\u0003^\u0003^\u0005^\\u044D\\n^\\x07^\\u044F\\n^\\f^\u000e^\\u0452\\v^\u0003^\u0003^\u0003^\u0003^\u0003^\\x07^\\u0459\\n^\\f^\u000e^\\u045C\\v^\u0005^\\u045E\\n^\u0003^\u0005^\\u0461\\n^\u0003_\u0003_\u0005_\\u0465\\n_\u0003`\u0003`\u0003a\u0006a\\u046A\\na\\ra\u000ea\\u046B\u0003b\u0003b\u0003b\u0003b\u0003b\\x07b\\u0473\\nb\\fb\u000eb\\u0476\\vb\u0003b\u0003b\u0005b\\u047A\\nb\u0003c\u0006c\\u047D\\nc\\rc\u000ec\\u047E\u0003c\u0002\u0002\u0004J\\x86d\u0002\u0002\u0004\u0002\u0006\u0002\\b\u0002\\n\u0002\\f\u0002\u000e\u0002\u0010\u0002\u0012\u0002\u0014\u0002\u0016\u0002\u0018\u0002\u001a\u0002\u001c\u0002\u001e\u0002 \u0002\\\"\u0002$\u0002&\u0002(\u0002*\u0002,\u0002.\u00020\u00022\u00024\u00026\u00028\u0002:\u0002<\u0002>\u0002@\u0002B\u0002D\u0002F\u0002H\u0002J\u0002L\u0002N\u0002P\u0002R\u0002T\u0002V\u0002X\u0002Z\u0002\\\\\u0002^\u0002`\u0002b\u0002d\u0002f\u0002h\u0002j\u0002l\u0002n\u0002p\u0002r\u0002t\u0002v\u0002x\u0002z\u0002|\u0002~\u0002\\x80\u0002\\x82\u0002\\x84\u0002\\x86\u0002\\x88\u0002\\x8A\u0002\\x8C\u0002\\x8E\u0002\\x90\u0002\\x92\u0002\\x94\u0002\\x96\u0002\\x98\u0002\\x9A\u0002\\x9C\u0002\\x9E\u0002\\xA0\u0002\\xA2\u0002\\xA4\u0002\\xA6\u0002\\xA8\u0002\\xAA\u0002\\xAC\u0002\\xAE\u0002\\xB0\u0002\\xB2\u0002\\xB4\u0002\\xB6\u0002\\xB8\u0002\\xBA\u0002\\xBC\u0002\\xBE\u0002\\xC0\u0002\\xC2\u0002\\xC4\u0002\u0002\u0011\u0003\u0002\\x07\\r\u0003\u0002\u0015\u0017\u0003\u0002*,\u0006\u0002qqxx||~~\u0005\u0002&&9<dh\u0003\u0002=>\u0003\u0002AB\u0003\u0002CD\u0004\u0002\u0005\u0005GH\u0003\u0002IJ\u0003\u0002\t\\f\u0003\u0002MN\u0004\u0002\\r\\rQZ\u0003\u0002jk\\f\u0002\u0010\u0010\u001b\u001b&&,,88bbttxx\\x80\\x80\\x82\\x83\u0002\\u0502\u0002\\xD2\u0003\u0002\u0002\u0002\u0004\\xD7\u0003\u0002\u0002\u0002\u0006\\xDC\u0003\u0002\u0002\u0002\\b\\xE1\u0003\u0002\u0002\u0002\\n\\xE3\u0003\u0002\u0002\u0002\\f\\xED\u0003\u0002\u0002\u0002\u000e\\xF7\u0003\u0002\u0002\u0002\u0010\\xF9\u0003\u0002\u0002\u0002\u0012\\u0122\u0003\u0002\u0002\u0002\u0014\\u0124\u0003\u0002\u0002\u0002\u0016\\u0127\u0003\u0002\u0002\u0002\u0018\\u013F\u0003\u0002\u0002\u0002\u001a\\u0150\u0003\u0002\u0002\u0002\u001c\\u0152\u0003\u0002\u0002\u0002\u001e\\u0165\u0003\u0002\u0002\u0002 \\u016C\u0003\u0002\u0002\u0002\\\"\\u0171\u0003\u0002\u0002\u0002$\\u0177\u0003\u0002\u0002\u0002&\\u018F\u0003\u0002\u0002\u0002(\\u0191\u0003\u0002\u0002\u0002*\\u01A2\u0003\u0002\u0002\u0002,\\u01B2\u0003\u0002\u0002\u0002.\\u01BA\u0003\u0002\u0002\u00020\\u01CB\u0003\u0002\u0002\u00022\\u01CD\u0003\u0002\u0002\u00024\\u01DA\u0003\u0002\u0002\u00026\\u01DD\u0003\u0002\u0002\u00028\\u01E5\u0003\u0002\u0002\u0002:\\u01E7\u0003\u0002\u0002\u0002<\\u01F6\u0003\u0002\u0002\u0002>\\u0203\u0003\u0002\u0002\u0002@\\u020A\u0003\u0002\u0002\u0002B\\u0217\u0003\u0002\u0002\u0002D\\u021E\u0003\u0002\u0002\u0002F\\u022B\u0003\u0002\u0002\u0002H\\u022F\u0003\u0002\u0002\u0002J\\u023C\u0003\u0002\u0002\u0002L\\u0249\u0003\u0002\u0002\u0002N\\u0253\u0003\u0002\u0002\u0002P\\u0255\u0003\u0002\u0002\u0002R\\u025C\u0003\u0002\u0002\u0002T\\u026A\u0003\u0002\u0002\u0002V\\u026C\u0003\u0002\u0002\u0002X\\u026E\u0003\u0002\u0002\u0002Z\\u0286\u0003\u0002\u0002\u0002\\\\\\u0288\u0003\u0002\u0002\u0002^\\u028B\u0003\u0002\u0002\u0002`\\u0294\u0003\u0002\u0002\u0002b\\u029F\u0003\u0002\u0002\u0002d\\u02A8\u0003\u0002\u0002\u0002f\\u02B0\u0003\u0002\u0002\u0002h\\u02B2\u0003\u0002\u0002\u0002j\\u02B5\u0003\u0002\u0002\u0002l\\u02C5\u0003\u0002\u0002\u0002n\\u02D1\u0003\u0002\u0002\u0002p\\u02D3\u0003\u0002\u0002\u0002r\\u02DB\u0003\u0002\u0002\u0002t\\u02DE\u0003\u0002\u0002\u0002v\\u02E1\u0003\u0002\u0002\u0002x\\u02E7\u0003\u0002\u0002\u0002z\\u02EA\u0003\u0002\u0002\u0002|\\u02EE\u0003\u0002\u0002\u0002~\\u02F9\u0003\u0002\u0002\u0002\\x80\\u0302\u0003\u0002\u0002\u0002\\x82\\u030D\u0003\u0002\u0002\u0002\\x84\\u031C\u0003\u0002\u0002\u0002\\x86\\u0330\u0003\u0002\u0002\u0002\\x88\\u0388\u0003\u0002\u0002\u0002\\x8A\\u038A\u0003\u0002\u0002\u0002\\x8C\\u0392\u0003\u0002\u0002\u0002\\x8E\\u039D\u0003\u0002\u0002\u0002\\x90\\u03A9\u0003\u0002\u0002\u0002\\x92\\u03AB\u0003\u0002\u0002\u0002\\x94\\u03B0\u0003\u0002\u0002\u0002\\x96\\u03CB\u0003\u0002\u0002\u0002\\x98\\u03D0\u0003\u0002\u0002\u0002\\x9A\\u03D2\u0003\u0002\u0002\u0002\\x9C\\u03DA\u0003\u0002\u0002\u0002\\x9E\\u03EA\u0003\u0002\u0002\u0002\\xA0\\u03F0\u0003\u0002\u0002\u0002\\xA2\\u03FB\u0003\u0002\u0002\u0002\\xA4\\u03FD\u0003\u0002\u0002\u0002\\xA6\\u0405\u0003\u0002\u0002\u0002\\xA8\\u0409\u0003\u0002\u0002\u0002\\xAA\\u040C\u0003\u0002\u0002\u0002\\xAC\\u041A\u0003\u0002\u0002\u0002\\xAE\\u041C\u0003\u0002\u0002\u0002\\xB0\\u0428\u0003\u0002\u0002\u0002\\xB2\\u042B\u0003\u0002\u0002\u0002\\xB4\\u0437\u0003\u0002\u0002\u0002\\xB6\\u0440\u0003\u0002\u0002\u0002\\xB8\\u0442\u0003\u0002\u0002\u0002\\xBA\\u0460\u0003\u0002\u0002\u0002\\xBC\\u0462\u0003\u0002\u0002\u0002\\xBE\\u0466\u0003\u0002\u0002\u0002\\xC0\\u0469\u0003\u0002\u0002\u0002\\xC2\\u046D\u0003\u0002\u0002\u0002\\xC4\\u047C\u0003\u0002\u0002\u0002\\xC6\\xD1\u0005\u0004\u0003\u0002\\xC7\\xD1\u0005\u0012\\n\u0002\\xC8\\xD1\u0005\u0016\\f\u0002\\xC9\\xD1\u0005:\u001e\u0002\\xCA\\xD1\u0005(\u0015\u0002\\xCB\\xD1\u0005.\u0018\u0002\\xCC\\xD1\u0005\u001e\u0010\u0002\\xCD\\xD1\u0005 \u0011\u0002\\xCE\\xD1\u0005\\\"\u0012\u0002\\xCF\\xD1\u0005$\u0013\u0002\\xD0\\xC6\u0003\u0002\u0002\u0002\\xD0\\xC7\u0003\u0002\u0002\u0002\\xD0\\xC8\u0003\u0002\u0002\u0002\\xD0\\xC9\u0003\u0002\u0002\u0002\\xD0\\xCA\u0003\u0002\u0002\u0002\\xD0\\xCB\u0003\u0002\u0002\u0002\\xD0\\xCC\u0003\u0002\u0002\u0002\\xD0\\xCD\u0003\u0002\u0002\u0002\\xD0\\xCE\u0003\u0002\u0002\u0002\\xD0\\xCF\u0003\u0002\u0002\u0002\\xD1\\xD4\u0003\u0002\u0002\u0002\\xD2\\xD0\u0003\u0002\u0002\u0002\\xD2\\xD3\u0003\u0002\u0002\u0002\\xD3\\xD5\u0003\u0002\u0002\u0002\\xD4\\xD2\u0003\u0002\u0002\u0002\\xD5\\xD6\\x07\u0002\u0002\u0003\\xD6\u0003\u0003\u0002\u0002\u0002\\xD7\\xD8\\x07\u0003\u0002\u0002\\xD8\\xD9\u0005\u0006\u0004\u0002\\xD9\\xDA\u0005\\b\u0005\u0002\\xDA\\xDB\\x07\u0004\u0002\u0002\\xDB\u0005\u0003\u0002\u0002\u0002\\xDC\\xDD\u0005\\xBE`\u0002\\xDD\\x07\u0003\u0002\u0002\u0002\\xDE\\xE2\\x07\u0005\u0002\u0002\\xDF\\xE2\u0005\\n\u0006\u0002\\xE0\\xE2\u0005\\x86D\u0002\\xE1\\xDE\u0003\u0002\u0002\u0002\\xE1\\xDF\u0003\u0002\u0002\u0002\\xE1\\xE0\u0003\u0002\u0002\u0002\\xE2\t\u0003\u0002\u0002\u0002\\xE3\\xEA\u0005\u000e\\b\u0002\\xE4\\xE6\\x07\u0006\u0002\u0002\\xE5\\xE4\u0003\u0002\u0002\u0002\\xE5\\xE6\u0003\u0002\u0002\u0002\\xE6\\xE7\u0003\u0002\u0002\u0002\\xE7\\xE9\u0005\u000e\\b\u0002\\xE8\\xE5\u0003\u0002\u0002\u0002\\xE9\\xEC\u0003\u0002\u0002\u0002\\xEA\\xE8\u0003\u0002\u0002\u0002\\xEA\\xEB\u0003\u0002\u0002\u0002\\xEB\\v\u0003\u0002\u0002\u0002\\xEC\\xEA\u0003\u0002\u0002\u0002\\xED\\xEE\t\u0002\u0002\u0002\\xEE\\r\u0003\u0002\u0002\u0002\\xEF\\xF1\u0005\\f\\x07\u0002\\xF0\\xEF\u0003\u0002\u0002\u0002\\xF0\\xF1\u0003\u0002\u0002\u0002\\xF1\\xF2\u0003\u0002\u0002\u0002\\xF2\\xF8\\x07\\x85\u0002\u0002\\xF3\\xF5\u0005\\f\\x07\u0002\\xF4\\xF3\u0003\u0002\u0002\u0002\\xF4\\xF5\u0003\u0002\u0002\u0002\\xF5\\xF6\u0003\u0002\u0002\u0002\\xF6\\xF8\\x07j\u0002\u0002\\xF7\\xF0\u0003\u0002\u0002\u0002\\xF7\\xF4\u0003\u0002\u0002\u0002\\xF8\u000f\u0003\u0002\u0002\u0002\\xF9\\xFC\u0005\\xBE`\u0002\\xFA\\xFB\\x07\u000e\u0002\u0002\\xFB\\xFD\u0005\\xBE`\u0002\\xFC\\xFA\u0003\u0002\u0002\u0002\\xFC\\xFD\u0003\u0002\u0002\u0002\\xFD\u0011\u0003\u0002\u0002\u0002\\xFE\\xFF\\x07\u000f\u0002\u0002\\xFF\\u0102\u0005\u0014\\v\u0002\\u0100\\u0101\\x07\u000e\u0002\u0002\\u0101\\u0103\u0005\\xBE`\u0002\\u0102\\u0100\u0003\u0002\u0002\u0002\\u0102\\u0103\u0003\u0002\u0002\u0002\\u0103\\u0104\u0003\u0002\u0002\u0002\\u0104\\u0105\\x07\u0004\u0002\u0002\\u0105\\u0123\u0003\u0002\u0002\u0002\\u0106\\u0109\\x07\u000f\u0002\u0002\\u0107\\u010A\\x07\u0005\u0002\u0002\\u0108\\u010A\u0005\\xBE`\u0002\\u0109\\u0107\u0003\u0002\u0002\u0002\\u0109\\u0108\u0003\u0002\u0002\u0002\\u010A\\u010D\u0003\u0002\u0002\u0002\\u010B\\u010C\\x07\u000e\u0002\u0002\\u010C\\u010E\u0005\\xBE`\u0002\\u010D\\u010B\u0003\u0002\u0002\u0002\\u010D\\u010E\u0003\u0002\u0002\u0002\\u010E\\u010F\u0003\u0002\u0002\u0002\\u010F\\u0110\\x07\u0010\u0002\u0002\\u0110\\u0111\u0005\u0014\\v\u0002\\u0111\\u0112\\x07\u0004\u0002\u0002\\u0112\\u0123\u0003\u0002\u0002\u0002\\u0113\\u0114\\x07\u000f\u0002\u0002\\u0114\\u0115\\x07\u0011\u0002\u0002\\u0115\\u011A\u0005\u0010\t\u0002\\u0116\\u0117\\x07\u0012\u0002\u0002\\u0117\\u0119\u0005\u0010\t\u0002\\u0118\\u0116\u0003\u0002\u0002\u0002\\u0119\\u011C\u0003\u0002\u0002\u0002\\u011A\\u0118\u0003\u0002\u0002\u0002\\u011A\\u011B\u0003\u0002\u0002\u0002\\u011B\\u011D\u0003\u0002\u0002\u0002\\u011C\\u011A\u0003\u0002\u0002\u0002\\u011D\\u011E\\x07\u0013\u0002\u0002\\u011E\\u011F\\x07\u0010\u0002\u0002\\u011F\\u0120\u0005\u0014\\v\u0002\\u0120\\u0121\\x07\u0004\u0002\u0002\\u0121\\u0123\u0003\u0002\u0002\u0002\\u0122\\xFE\u0003\u0002\u0002\u0002\\u0122\\u0106\u0003\u0002\u0002\u0002\\u0122\\u0113\u0003\u0002\u0002\u0002\\u0123\u0013\u0003\u0002\u0002\u0002\\u0124\\u0125\\x07\\x84\u0002\u0002\\u0125\u0015\u0003\u0002\u0002\u0002\\u0126\\u0128\\x07\u0014\u0002\u0002\\u0127\\u0126\u0003\u0002\u0002\u0002\\u0127\\u0128\u0003\u0002\u0002\u0002\\u0128\\u0129\u0003\u0002\u0002\u0002\\u0129\\u012A\t\u0003\u0002\u0002\\u012A\\u0134\u0005\\xBE`\u0002\\u012B\\u012C\\x07\u0018\u0002\u0002\\u012C\\u0131\u0005\u0018\\r\u0002\\u012D\\u012E\\x07\u0012\u0002\u0002\\u012E\\u0130\u0005\u0018\\r\u0002\\u012F\\u012D\u0003\u0002\u0002\u0002\\u0130\\u0133\u0003\u0002\u0002\u0002\\u0131\\u012F\u0003\u0002\u0002\u0002\\u0131\\u0132\u0003\u0002\u0002\u0002\\u0132\\u0135\u0003\u0002\u0002\u0002\\u0133\\u0131\u0003\u0002\u0002\u0002\\u0134\\u012B\u0003\u0002\u0002\u0002\\u0134\\u0135\u0003\u0002\u0002\u0002\\u0135\\u0136\u0003\u0002\u0002\u0002\\u0136\\u013A\\x07\u0011\u0002\u0002\\u0137\\u0139\u0005\u001a\u000e\u0002\\u0138\\u0137\u0003\u0002\u0002\u0002\\u0139\\u013C\u0003\u0002\u0002\u0002\\u013A\\u0138\u0003\u0002\u0002\u0002\\u013A\\u013B\u0003\u0002\u0002\u0002\\u013B\\u013D\u0003\u0002\u0002\u0002\\u013C\\u013A\u0003\u0002\u0002\u0002\\u013D\\u013E\\x07\u0013\u0002\u0002\\u013E\u0017\u0003\u0002\u0002\u0002\\u013F\\u0145\u0005L'\u0002\\u0140\\u0142\\x07\u0019\u0002\u0002\\u0141\\u0143\u0005\\x8AF\u0002\\u0142\\u0141\u0003\u0002\u0002\u0002\\u0142\\u0143\u0003\u0002\u0002\u0002\\u0143\\u0144\u0003\u0002\u0002\u0002\\u0144\\u0146\\x07\u001a\u0002\u0002\\u0145\\u0140\u0003\u0002\u0002\u0002\\u0145\\u0146\u0003\u0002\u0002\u0002\\u0146\u0019\u0003\u0002\u0002\u0002\\u0147\\u0151\u0005\u001c\u000f\u0002\\u0148\\u0151\u0005$\u0013\u0002\\u0149\\u0151\u0005(\u0015\u0002\\u014A\\u0151\u0005*\u0016\u0002\\u014B\\u0151\u0005.\u0018\u0002\\u014C\\u0151\u00056\u001c\u0002\\u014D\\u0151\u0005:\u001e\u0002\\u014E\\u0151\u0005 \u0011\u0002\\u014F\\u0151\u0005\\\"\u0012\u0002\\u0150\\u0147\u0003\u0002\u0002\u0002\\u0150\\u0148\u0003\u0002\u0002\u0002\\u0150\\u0149\u0003\u0002\u0002\u0002\\u0150\\u014A\u0003\u0002\u0002\u0002\\u0150\\u014B\u0003\u0002\u0002\u0002\\u0150\\u014C\u0003\u0002\u0002\u0002\\u0150\\u014D\u0003\u0002\u0002\u0002\\u0150\\u014E\u0003\u0002\u0002\u0002\\u0150\\u014F\u0003\u0002\u0002\u0002\\u0151\u001b\u0003\u0002\u0002\u0002\\u0152\\u015B\u0005J&\u0002\\u0153\\u015A\\x07z\u0002\u0002\\u0154\\u015A\\x07w\u0002\u0002\\u0155\\u015A\\x07y\u0002\u0002\\u0156\\u015A\\x07q\u0002\u0002\\u0157\\u015A\\x07r\u0002\u0002\\u0158\\u015A\u0005\\xC2b\u0002\\u0159\\u0153\u0003\u0002\u0002\u0002\\u0159\\u0154\u0003\u0002\u0002\u0002\\u0159\\u0155\u0003\u0002\u0002\u0002\\u0159\\u0156\u0003\u0002\u0002\u0002\\u0159\\u0157\u0003\u0002\u0002\u0002\\u0159\\u0158\u0003\u0002\u0002\u0002\\u015A\\u015D\u0003\u0002\u0002\u0002\\u015B\\u0159\u0003\u0002\u0002\u0002\\u015B\\u015C\u0003\u0002\u0002\u0002\\u015C\\u015E\u0003\u0002\u0002\u0002\\u015D\\u015B\u0003\u0002\u0002\u0002\\u015E\\u0161\u0005\\xBE`\u0002\\u015F\\u0160\\x07\\r\u0002\u0002\\u0160\\u0162\u0005\\x86D\u0002\\u0161\\u015F\u0003\u0002\u0002\u0002\\u0161\\u0162\u0003\u0002\u0002\u0002\\u0162\\u0163\u0003\u0002\u0002\u0002\\u0163\\u0164\\x07\u0004\u0002\u0002\\u0164\u001d\u0003\u0002\u0002\u0002\\u0165\\u0166\u0005J&\u0002\\u0166\\u0167\\x07q\u0002\u0002\\u0167\\u0168\u0005\\xBE`\u0002\\u0168\\u0169\\x07\\r\u0002\u0002\\u0169\\u016A\u0005\\x86D\u0002\\u016A\\u016B\\x07\u0004\u0002\u0002\\u016B\u001f\u0003\u0002\u0002\u0002\\u016C\\u016D\\x07\u001b\u0002\u0002\\u016D\\u016E\u0005\\xBE`\u0002\\u016E\\u016F\u0005<\u001f\u0002\\u016F\\u0170\\x07\u0004\u0002\u0002\\u0170!\u0003\u0002\u0002\u0002\\u0171\\u0172\\x07}\u0002\u0002\\u0172\\u0173\u0005\\xBE`\u0002\\u0173\\u0174\\x07\u0018\u0002\u0002\\u0174\\u0175\u0005\\x84C\u0002\\u0175\\u0176\\x07\u0004\u0002\u0002\\u0176#\u0003\u0002\u0002\u0002\\u0177\\u0178\\x07\u001c\u0002\u0002\\u0178\\u0179\u0005&\u0014\u0002\\u0179\\u017C\\x07\u001d\u0002\u0002\\u017A\\u017D\\x07\u0005\u0002\u0002\\u017B\\u017D\u0005J&\u0002\\u017C\\u017A\u0003\u0002\u0002\u0002\\u017C\\u017B\u0003\u0002\u0002\u0002\\u017D\\u017F\u0003\u0002\u0002\u0002\\u017E\\u0180\\x07\\x7F\u0002\u0002\\u017F\\u017E\u0003\u0002\u0002\u0002\\u017F\\u0180\u0003\u0002\u0002\u0002\\u0180\\u0181\u0003\u0002\u0002\u0002\\u0181\\u0182\\x07\u0004\u0002\u0002\\u0182%\u0003\u0002\u0002\u0002\\u0183\\u0190\u0005L'\u0002\\u0184\\u0185\\x07\u0011\u0002\u0002\\u0185\\u018A\u0005L'\u0002\\u0186\\u0187\\x07\u0012\u0002\u0002\\u0187\\u0189\u0005L'\u0002\\u0188\\u0186\u0003\u0002\u0002\u0002\\u0189\\u018C\u0003\u0002\u0002\u0002\\u018A\\u0188\u0003\u0002\u0002\u0002\\u018A\\u018B\u0003\u0002\u0002\u0002\\u018B\\u018D\u0003\u0002\u0002\u0002\\u018C\\u018A\u0003\u0002\u0002\u0002\\u018D\\u018E\\x07\u0013\u0002\u0002\\u018E\\u0190\u0003\u0002\u0002\u0002\\u018F\\u0183\u0003\u0002\u0002\u0002\\u018F\\u0184\u0003\u0002\u0002\u0002\\u0190'\u0003\u0002\u0002\u0002\\u0191\\u0192\\x07\u001e\u0002\u0002\\u0192\\u0193\u0005\\xBE`\u0002\\u0193\\u019E\\x07\u0011\u0002\u0002\\u0194\\u0195\u0005H%\u0002\\u0195\\u019B\\x07\u0004\u0002\u0002\\u0196\\u0197\u0005H%\u0002\\u0197\\u0198\\x07\u0004\u0002\u0002\\u0198\\u019A\u0003\u0002\u0002\u0002\\u0199\\u0196\u0003\u0002\u0002\u0002\\u019A\\u019D\u0003\u0002\u0002\u0002\\u019B\\u0199\u0003\u0002\u0002\u0002\\u019B\\u019C\u0003\u0002\u0002\u0002\\u019C\\u019F\u0003\u0002\u0002\u0002\\u019D\\u019B\u0003\u0002\u0002\u0002\\u019E\\u0194\u0003\u0002\u0002\u0002\\u019E\\u019F\u0003\u0002\u0002\u0002\\u019F\\u01A0\u0003\u0002\u0002\u0002\\u01A0\\u01A1\\x07\u0013\u0002\u0002\\u01A1)\u0003\u0002\u0002\u0002\\u01A2\\u01A3\\x07\u001f\u0002\u0002\\u01A3\\u01A5\u0005\\xBE`\u0002\\u01A4\\u01A6\u0005<\u001f\u0002\\u01A5\\u01A4\";\nSolidityParser._serializedATNSegment1 = \"\u0003\u0002\u0002\u0002\\u01A5\\u01A6\u0003\u0002\u0002\u0002\\u01A6\\u01AB\u0003\u0002\u0002\u0002\\u01A7\\u01AA\\x07{\u0002\u0002\\u01A8\\u01AA\u0005\\xC2b\u0002\\u01A9\\u01A7\u0003\u0002\u0002\u0002\\u01A9\\u01A8\u0003\u0002\u0002\u0002\\u01AA\\u01AD\u0003\u0002\u0002\u0002\\u01AB\\u01A9\u0003\u0002\u0002\u0002\\u01AB\\u01AC\u0003\u0002\u0002\u0002\\u01AC\\u01B0\u0003\u0002\u0002\u0002\\u01AD\\u01AB\u0003\u0002\u0002\u0002\\u01AE\\u01B1\\x07\u0004\u0002\u0002\\u01AF\\u01B1\u0005X-\u0002\\u01B0\\u01AE\u0003\u0002\u0002\u0002\\u01B0\\u01AF\u0003\u0002\u0002\u0002\\u01B1+\u0003\u0002\u0002\u0002\\u01B2\\u01B8\u0005\\xBE`\u0002\\u01B3\\u01B5\\x07\u0019\u0002\u0002\\u01B4\\u01B6\u0005\\x8AF\u0002\\u01B5\\u01B4\u0003\u0002\u0002\u0002\\u01B5\\u01B6\u0003\u0002\u0002\u0002\\u01B6\\u01B7\u0003\u0002\u0002\u0002\\u01B7\\u01B9\\x07\u001a\u0002\u0002\\u01B8\\u01B3\u0003\u0002\u0002\u0002\\u01B8\\u01B9\u0003\u0002\u0002\u0002\\u01B9-\u0003\u0002\u0002\u0002\\u01BA\\u01BB\u00050\u0019\u0002\\u01BB\\u01BC\u0005<\u001f\u0002\\u01BC\\u01BE\u00054\u001b\u0002\\u01BD\\u01BF\u00052\u001a\u0002\\u01BE\\u01BD\u0003\u0002\u0002\u0002\\u01BE\\u01BF\u0003\u0002\u0002\u0002\\u01BF\\u01C2\u0003\u0002\u0002\u0002\\u01C0\\u01C3\\x07\u0004\u0002\u0002\\u01C1\\u01C3\u0005X-\u0002\\u01C2\\u01C0\u0003\u0002\u0002\u0002\\u01C2\\u01C1\u0003\u0002\u0002\u0002\\u01C3/\u0003\u0002\u0002\u0002\\u01C4\\u01C6\\x07 \u0002\u0002\\u01C5\\u01C7\u0005\\xBE`\u0002\\u01C6\\u01C5\u0003\u0002\u0002\u0002\\u01C6\\u01C7\u0003\u0002\u0002\u0002\\u01C7\\u01CC\u0003\u0002\u0002\u0002\\u01C8\\u01CC\\x07\\x80\u0002\u0002\\u01C9\\u01CC\\x07\\x81\u0002\u0002\\u01CA\\u01CC\\x07\\x82\u0002\u0002\\u01CB\\u01C4\u0003\u0002\u0002\u0002\\u01CB\\u01C8\u0003\u0002\u0002\u0002\\u01CB\\u01C9\u0003\u0002\u0002\u0002\\u01CB\\u01CA\u0003\u0002\u0002\u0002\\u01CC1\u0003\u0002\u0002\u0002\\u01CD\\u01CE\\x07!\u0002\u0002\\u01CE\\u01CF\u0005<\u001f\u0002\\u01CF3\u0003\u0002\u0002\u0002\\u01D0\\u01D9\\x07u\u0002\u0002\\u01D1\\u01D9\\x07z\u0002\u0002\\u01D2\\u01D9\\x07w\u0002\u0002\\u01D3\\u01D9\\x07y\u0002\u0002\\u01D4\\u01D9\\x07{\u0002\u0002\\u01D5\\u01D9\u0005V,\u0002\\u01D6\\u01D9\u0005,\u0017\u0002\\u01D7\\u01D9\u0005\\xC2b\u0002\\u01D8\\u01D0\u0003\u0002\u0002\u0002\\u01D8\\u01D1\u0003\u0002\u0002\u0002\\u01D8\\u01D2\u0003\u0002\u0002\u0002\\u01D8\\u01D3\u0003\u0002\u0002\u0002\\u01D8\\u01D4\u0003\u0002\u0002\u0002\\u01D8\\u01D5\u0003\u0002\u0002\u0002\\u01D8\\u01D6\u0003\u0002\u0002\u0002\\u01D8\\u01D7\u0003\u0002\u0002\u0002\\u01D9\\u01DC\u0003\u0002\u0002\u0002\\u01DA\\u01D8\u0003\u0002\u0002\u0002\\u01DA\\u01DB\u0003\u0002\u0002\u0002\\u01DB5\u0003\u0002\u0002\u0002\\u01DC\\u01DA\u0003\u0002\u0002\u0002\\u01DD\\u01DE\\x07\\\"\u0002\u0002\\u01DE\\u01DF\u0005\\xBE`\u0002\\u01DF\\u01E1\u0005@!\u0002\\u01E0\\u01E2\\x07o\u0002\u0002\\u01E1\\u01E0\u0003\u0002\u0002\u0002\\u01E1\\u01E2\u0003\u0002\u0002\u0002\\u01E2\\u01E3\u0003\u0002\u0002\u0002\\u01E3\\u01E4\\x07\u0004\u0002\u0002\\u01E47\u0003\u0002\u0002\u0002\\u01E5\\u01E6\u0005\\xBE`\u0002\\u01E69\u0003\u0002\u0002\u0002\\u01E7\\u01E8\\x07#\u0002\u0002\\u01E8\\u01E9\u0005\\xBE`\u0002\\u01E9\\u01EB\\x07\u0011\u0002\u0002\\u01EA\\u01EC\u00058\u001d\u0002\\u01EB\\u01EA\u0003\u0002\u0002\u0002\\u01EB\\u01EC\u0003\u0002\u0002\u0002\\u01EC\\u01F1\u0003\u0002\u0002\u0002\\u01ED\\u01EE\\x07\u0012\u0002\u0002\\u01EE\\u01F0\u00058\u001d\u0002\\u01EF\\u01ED\u0003\u0002\u0002\u0002\\u01F0\\u01F3\u0003\u0002\u0002\u0002\\u01F1\\u01EF\u0003\u0002\u0002\u0002\\u01F1\\u01F2\u0003\u0002\u0002\u0002\\u01F2\\u01F4\u0003\u0002\u0002\u0002\\u01F3\\u01F1\u0003\u0002\u0002\u0002\\u01F4\\u01F5\\x07\u0013\u0002\u0002\\u01F5;\u0003\u0002\u0002\u0002\\u01F6\\u01FF\\x07\u0019\u0002\u0002\\u01F7\\u01FC\u0005> \u0002\\u01F8\\u01F9\\x07\u0012\u0002\u0002\\u01F9\\u01FB\u0005> \u0002\\u01FA\\u01F8\u0003\u0002\u0002\u0002\\u01FB\\u01FE\u0003\u0002\u0002\u0002\\u01FC\\u01FA\u0003\u0002\u0002\u0002\\u01FC\\u01FD\u0003\u0002\u0002\u0002\\u01FD\\u0200\u0003\u0002\u0002\u0002\\u01FE\\u01FC\u0003\u0002\u0002\u0002\\u01FF\\u01F7\u0003\u0002\u0002\u0002\\u01FF\\u0200\u0003\u0002\u0002\u0002\\u0200\\u0201\u0003\u0002\u0002\u0002\\u0201\\u0202\\x07\u001a\u0002\u0002\\u0202=\u0003\u0002\u0002\u0002\\u0203\\u0205\u0005J&\u0002\\u0204\\u0206\u0005T+\u0002\\u0205\\u0204\u0003\u0002\u0002\u0002\\u0205\\u0206\u0003\u0002\u0002\u0002\\u0206\\u0208\u0003\u0002\u0002\u0002\\u0207\\u0209\u0005\\xBE`\u0002\\u0208\\u0207\u0003\u0002\u0002\u0002\\u0208\\u0209\u0003\u0002\u0002\u0002\\u0209?\u0003\u0002\u0002\u0002\\u020A\\u0213\\x07\u0019\u0002\u0002\\u020B\\u0210\u0005B\\\"\u0002\\u020C\\u020D\\x07\u0012\u0002\u0002\\u020D\\u020F\u0005B\\\"\u0002\\u020E\\u020C\u0003\u0002\u0002\u0002\\u020F\\u0212\u0003\u0002\u0002\u0002\\u0210\\u020E\u0003\u0002\u0002\u0002\\u0210\\u0211\u0003\u0002\u0002\u0002\\u0211\\u0214\u0003\u0002\u0002\u0002\\u0212\\u0210\u0003\u0002\u0002\u0002\\u0213\\u020B\u0003\u0002\u0002\u0002\\u0213\\u0214\u0003\u0002\u0002\u0002\\u0214\\u0215\u0003\u0002\u0002\u0002\\u0215\\u0216\\x07\u001a\u0002\u0002\\u0216A\u0003\u0002\u0002\u0002\\u0217\\u0219\u0005J&\u0002\\u0218\\u021A\\x07v\u0002\u0002\\u0219\\u0218\u0003\u0002\u0002\u0002\\u0219\\u021A\u0003\u0002\u0002\u0002\\u021A\\u021C\u0003\u0002\u0002\u0002\\u021B\\u021D\u0005\\xBE`\u0002\\u021C\\u021B\u0003\u0002\u0002\u0002\\u021C\\u021D\u0003\u0002\u0002\u0002\\u021DC\u0003\u0002\u0002\u0002\\u021E\\u0227\\x07\u0019\u0002\u0002\\u021F\\u0224\u0005F$\u0002\\u0220\\u0221\\x07\u0012\u0002\u0002\\u0221\\u0223\u0005F$\u0002\\u0222\\u0220\u0003\u0002\u0002\u0002\\u0223\\u0226\u0003\u0002\u0002\u0002\\u0224\\u0222\u0003\u0002\u0002\u0002\\u0224\\u0225\u0003\u0002\u0002\u0002\\u0225\\u0228\u0003\u0002\u0002\u0002\\u0226\\u0224\u0003\u0002\u0002\u0002\\u0227\\u021F\u0003\u0002\u0002\u0002\\u0227\\u0228\u0003\u0002\u0002\u0002\\u0228\\u0229\u0003\u0002\u0002\u0002\\u0229\\u022A\\x07\u001a\u0002\u0002\\u022AE\u0003\u0002\u0002\u0002\\u022B\\u022D\u0005J&\u0002\\u022C\\u022E\u0005T+\u0002\\u022D\\u022C\u0003\u0002\u0002\u0002\\u022D\\u022E\u0003\u0002\u0002\u0002\\u022EG\u0003\u0002\u0002\u0002\\u022F\\u0231\u0005J&\u0002\\u0230\\u0232\u0005T+\u0002\\u0231\\u0230\u0003\u0002\u0002\u0002\\u0231\\u0232\u0003\u0002\u0002\u0002\\u0232\\u0233\u0003\u0002\u0002\u0002\\u0233\\u0234\u0005\\xBE`\u0002\\u0234I\u0003\u0002\u0002\u0002\\u0235\\u0236\\b&\u0001\u0002\\u0236\\u023D\u0005\\x84C\u0002\\u0237\\u023D\u0005L'\u0002\\u0238\\u023D\u0005P)\u0002\\u0239\\u023D\u0005R*\u0002\\u023A\\u023B\\x07&\u0002\u0002\\u023B\\u023D\\x07x\u0002\u0002\\u023C\\u0235\u0003\u0002\u0002\u0002\\u023C\\u0237\u0003\u0002\u0002\u0002\\u023C\\u0238\u0003\u0002\u0002\u0002\\u023C\\u0239\u0003\u0002\u0002\u0002\\u023C\\u023A\u0003\u0002\u0002\u0002\\u023D\\u0246\u0003\u0002\u0002\u0002\\u023E\\u023F\\f\u0005\u0002\u0002\\u023F\\u0241\\x07$\u0002\u0002\\u0240\\u0242\u0005\\x86D\u0002\\u0241\\u0240\u0003\u0002\u0002\u0002\\u0241\\u0242\u0003\u0002\u0002\u0002\\u0242\\u0243\u0003\u0002\u0002\u0002\\u0243\\u0245\\x07%\u0002\u0002\\u0244\\u023E\u0003\u0002\u0002\u0002\\u0245\\u0248\u0003\u0002\u0002\u0002\\u0246\\u0244\u0003\u0002\u0002\u0002\\u0246\\u0247\u0003\u0002\u0002\u0002\\u0247K\u0003\u0002\u0002\u0002\\u0248\\u0246\u0003\u0002\u0002\u0002\\u0249\\u024E\u0005\\xBE`\u0002\\u024A\\u024B\\x07'\u0002\u0002\\u024B\\u024D\u0005\\xBE`\u0002\\u024C\\u024A\u0003\u0002\u0002\u0002\\u024D\\u0250\u0003\u0002\u0002\u0002\\u024E\\u024C\u0003\u0002\u0002\u0002\\u024E\\u024F\u0003\u0002\u0002\u0002\\u024FM\u0003\u0002\u0002\u0002\\u0250\\u024E\u0003\u0002\u0002\u0002\\u0251\\u0254\u0005\\x84C\u0002\\u0252\\u0254\u0005L'\u0002\\u0253\\u0251\u0003\u0002\u0002\u0002\\u0253\\u0252\u0003\u0002\u0002\u0002\\u0254O\u0003\u0002\u0002\u0002\\u0255\\u0256\\x07(\u0002\u0002\\u0256\\u0257\\x07\u0019\u0002\u0002\\u0257\\u0258\u0005N(\u0002\\u0258\\u0259\\x07)\u0002\u0002\\u0259\\u025A\u0005J&\u0002\\u025A\\u025B\\x07\u001a\u0002\u0002\\u025BQ\u0003\u0002\u0002\u0002\\u025C\\u025D\\x07 \u0002\u0002\\u025D\\u0263\u0005D#\u0002\\u025E\\u0262\\x07w\u0002\u0002\\u025F\\u0262\\x07u\u0002\u0002\\u0260\\u0262\u0005V,\u0002\\u0261\\u025E\u0003\u0002\u0002\u0002\\u0261\\u025F\u0003\u0002\u0002\u0002\\u0261\\u0260\u0003\u0002\u0002\u0002\\u0262\\u0265\u0003\u0002\u0002\u0002\\u0263\\u0261\u0003\u0002\u0002\u0002\\u0263\\u0264\u0003\u0002\u0002\u0002\\u0264\\u0268\u0003\u0002\u0002\u0002\\u0265\\u0263\u0003\u0002\u0002\u0002\\u0266\\u0267\\x07!\u0002\u0002\\u0267\\u0269\u0005D#\u0002\\u0268\\u0266\u0003\u0002\u0002\u0002\\u0268\\u0269\u0003\u0002\u0002\u0002\\u0269S\u0003\u0002\u0002\u0002\\u026A\\u026B\t\u0004\u0002\u0002\\u026BU\u0003\u0002\u0002\u0002\\u026C\\u026D\t\u0005\u0002\u0002\\u026DW\u0003\u0002\u0002\u0002\\u026E\\u0272\\x07\u0011\u0002\u0002\\u026F\\u0271\u0005Z.\u0002\\u0270\\u026F\u0003\u0002\u0002\u0002\\u0271\\u0274\u0003\u0002\u0002\u0002\\u0272\\u0270\u0003\u0002\u0002\u0002\\u0272\\u0273\u0003\u0002\u0002\u0002\\u0273\\u0275\u0003\u0002\u0002\u0002\\u0274\\u0272\u0003\u0002\u0002\u0002\\u0275\\u0276\\x07\u0013\u0002\u0002\\u0276Y\u0003\u0002\u0002\u0002\\u0277\\u0287\u0005^0\u0002\\u0278\\u0287\u0005`1\u0002\\u0279\\u0287\u0005d3\u0002\\u027A\\u0287\u0005j6\u0002\\u027B\\u0287\u0005X-\u0002\\u027C\\u0287\u0005l7\u0002\\u027D\\u0287\u0005p9\u0002\\u027E\\u0287\u0005r:\u0002\\u027F\\u0287\u0005t;\u0002\\u0280\\u0287\u0005v<\u0002\\u0281\\u0287\u0005x=\u0002\\u0282\\u0287\u0005z>\u0002\\u0283\\u0287\u0005f4\u0002\\u0284\\u0287\u0005h5\u0002\\u0285\\u0287\u0005|?\u0002\\u0286\\u0277\u0003\u0002\u0002\u0002\\u0286\\u0278\u0003\u0002\u0002\u0002\\u0286\\u0279\u0003\u0002\u0002\u0002\\u0286\\u027A\u0003\u0002\u0002\u0002\\u0286\\u027B\u0003\u0002\u0002\u0002\\u0286\\u027C\u0003\u0002\u0002\u0002\\u0286\\u027D\u0003\u0002\u0002\u0002\\u0286\\u027E\u0003\u0002\u0002\u0002\\u0286\\u027F\u0003\u0002\u0002\u0002\\u0286\\u0280\u0003\u0002\u0002\u0002\\u0286\\u0281\u0003\u0002\u0002\u0002\\u0286\\u0282\u0003\u0002\u0002\u0002\\u0286\\u0283\u0003\u0002\u0002\u0002\\u0286\\u0284\u0003\u0002\u0002\u0002\\u0286\\u0285\u0003\u0002\u0002\u0002\\u0287[\u0003\u0002\u0002\u0002\\u0288\\u0289\u0005\\x86D\u0002\\u0289\\u028A\\x07\u0004\u0002\u0002\\u028A]\u0003\u0002\u0002\u0002\\u028B\\u028C\\x07-\u0002\u0002\\u028C\\u028D\\x07\u0019\u0002\u0002\\u028D\\u028E\u0005\\x86D\u0002\\u028E\\u028F\\x07\u001a\u0002\u0002\\u028F\\u0292\u0005Z.\u0002\\u0290\\u0291\\x07.\u0002\u0002\\u0291\\u0293\u0005Z.\u0002\\u0292\\u0290\u0003\u0002\u0002\u0002\\u0292\\u0293\u0003\u0002\u0002\u0002\\u0293_\u0003\u0002\u0002\u0002\\u0294\\u0295\\x07/\u0002\u0002\\u0295\\u0297\u0005\\x86D\u0002\\u0296\\u0298\u00052\u001a\u0002\\u0297\\u0296\u0003\u0002\u0002\u0002\\u0297\\u0298\u0003\u0002\u0002\u0002\\u0298\\u0299\u0003\u0002\u0002\u0002\\u0299\\u029B\u0005X-\u0002\\u029A\\u029C\u0005b2\u0002\\u029B\\u029A\u0003\u0002\u0002\u0002\\u029C\\u029D\u0003\u0002\u0002\u0002\\u029D\\u029B\u0003\u0002\u0002\u0002\\u029D\\u029E\u0003\u0002\u0002\u0002\\u029Ea\u0003\u0002\u0002\u0002\\u029F\\u02A4\\x070\u0002\u0002\\u02A0\\u02A2\u0005\\xBE`\u0002\\u02A1\\u02A0\u0003\u0002\u0002\u0002\\u02A1\\u02A2\u0003\u0002\u0002\u0002\\u02A2\\u02A3\u0003\u0002\u0002\u0002\\u02A3\\u02A5\u0005<\u001f\u0002\\u02A4\\u02A1\u0003\u0002\u0002\u0002\\u02A4\\u02A5\u0003\u0002\u0002\u0002\\u02A5\\u02A6\u0003\u0002\u0002\u0002\\u02A6\\u02A7\u0005X-\u0002\\u02A7c\u0003\u0002\u0002\u0002\\u02A8\\u02A9\\x071\u0002\u0002\\u02A9\\u02AA\\x07\u0019\u0002\u0002\\u02AA\\u02AB\u0005\\x86D\u0002\\u02AB\\u02AC\\x07\u001a\u0002\u0002\\u02AC\\u02AD\u0005Z.\u0002\\u02ADe\u0003\u0002\u0002\u0002\\u02AE\\u02B1\u0005~@\u0002\\u02AF\\u02B1\u0005\\\\/\u0002\\u02B0\\u02AE\u0003\u0002\u0002\u0002\\u02B0\\u02AF\u0003\u0002\u0002\u0002\\u02B1g\u0003\u0002\u0002\u0002\\u02B2\\u02B3\\x072\u0002\u0002\\u02B3\\u02B4\u0005X-\u0002\\u02B4i\u0003\u0002\u0002\u0002\\u02B5\\u02B6\\x07\u001d\u0002\u0002\\u02B6\\u02B9\\x07\u0019\u0002\u0002\\u02B7\\u02BA\u0005f4\u0002\\u02B8\\u02BA\\x07\u0004\u0002\u0002\\u02B9\\u02B7\u0003\u0002\u0002\u0002\\u02B9\\u02B8\u0003\u0002\u0002\u0002\\u02BA\\u02BD\u0003\u0002\u0002\u0002\\u02BB\\u02BE\u0005\\\\/\u0002\\u02BC\\u02BE\\x07\u0004\u0002\u0002\\u02BD\\u02BB\u0003\u0002\u0002\u0002\\u02BD\\u02BC\u0003\u0002\u0002\u0002\\u02BE\\u02C0\u0003\u0002\u0002\u0002\\u02BF\\u02C1\u0005\\x86D\u0002\\u02C0\\u02BF\u0003\u0002\u0002\u0002\\u02C0\\u02C1\u0003\u0002\u0002\u0002\\u02C1\\u02C2\u0003\u0002\u0002\u0002\\u02C2\\u02C3\\x07\u001a\u0002\u0002\\u02C3\\u02C4\u0005Z.\u0002\\u02C4k\u0003\u0002\u0002\u0002\\u02C5\\u02C7\\x073\u0002\u0002\\u02C6\\u02C8\\x07\\x84\u0002\u0002\\u02C7\\u02C6\u0003\u0002\u0002\u0002\\u02C7\\u02C8\u0003\u0002\u0002\u0002\\u02C8\\u02CD\u0003\u0002\u0002\u0002\\u02C9\\u02CA\\x07\u0019\u0002\u0002\\u02CA\\u02CB\u0005n8\u0002\\u02CB\\u02CC\\x07\u001a\u0002\u0002\\u02CC\\u02CE\u0003\u0002\u0002\u0002\\u02CD\\u02C9\u0003\u0002\u0002\u0002\\u02CD\\u02CE\u0003\u0002\u0002\u0002\\u02CE\\u02CF\u0003\u0002\u0002\u0002\\u02CF\\u02D0\u0005\\x94K\u0002\\u02D0m\u0003\u0002\u0002\u0002\\u02D1\\u02D2\u0005\\xC4c\u0002\\u02D2o\u0003\u0002\u0002\u0002\\u02D3\\u02D4\\x074\u0002\u0002\\u02D4\\u02D5\u0005Z.\u0002\\u02D5\\u02D6\\x071\u0002\u0002\\u02D6\\u02D7\\x07\u0019\u0002\u0002\\u02D7\\u02D8\u0005\\x86D\u0002\\u02D8\\u02D9\\x07\u001a\u0002\u0002\\u02D9\\u02DA\\x07\u0004\u0002\u0002\\u02DAq\u0003\u0002\u0002\u0002\\u02DB\\u02DC\\x07s\u0002\u0002\\u02DC\\u02DD\\x07\u0004\u0002\u0002\\u02DDs\u0003\u0002\u0002\u0002\\u02DE\\u02DF\\x07p\u0002\u0002\\u02DF\\u02E0\\x07\u0004\u0002\u0002\\u02E0u\u0003\u0002\u0002\u0002\\u02E1\\u02E3\\x075\u0002\u0002\\u02E2\\u02E4\u0005\\x86D\u0002\\u02E3\\u02E2\u0003\u0002\u0002\u0002\\u02E3\\u02E4\u0003\u0002\u0002\u0002\\u02E4\\u02E5\u0003\u0002\u0002\u0002\\u02E5\\u02E6\\x07\u0004\u0002\u0002\\u02E6w\u0003\u0002\u0002\u0002\\u02E7\\u02E8\\x076\u0002\u0002\\u02E8\\u02E9\\x07\u0004\u0002\u0002\\u02E9y\u0003\u0002\u0002\u0002\\u02EA\\u02EB\\x077\u0002\u0002\\u02EB\\u02EC\u0005\\x92J\u0002\\u02EC\\u02ED\\x07\u0004\u0002\u0002\\u02ED{\u0003\u0002\u0002\u0002\\u02EE\\u02EF\\x078\u0002\u0002\\u02EF\\u02F0\u0005\\x92J\u0002\\u02F0\\u02F1\\x07\u0004\u0002\u0002\\u02F1}\u0003\u0002\u0002\u0002\\u02F2\\u02F3\\x079\u0002\u0002\\u02F3\\u02FA\u0005\\x82B\u0002\\u02F4\\u02FA\u0005H%\u0002\\u02F5\\u02F6\\x07\u0019\u0002\u0002\\u02F6\\u02F7\u0005\\x80A\u0002\\u02F7\\u02F8\\x07\u001a\u0002\u0002\\u02F8\\u02FA\u0003\u0002\u0002\u0002\\u02F9\\u02F2\u0003\u0002\u0002\u0002\\u02F9\\u02F4\u0003\u0002\u0002\u0002\\u02F9\\u02F5\u0003\u0002\u0002\u0002\\u02FA\\u02FD\u0003\u0002\u0002\u0002\\u02FB\\u02FC\\x07\\r\u0002\u0002\\u02FC\\u02FE\u0005\\x86D\u0002\\u02FD\\u02FB\u0003\u0002\u0002\u0002\\u02FD\\u02FE\u0003\u0002\u0002\u0002\\u02FE\\u02FF\u0003\u0002\u0002\u0002\\u02FF\\u0300\\x07\u0004\u0002\u0002\\u0300\\x7F\u0003\u0002\u0002\u0002\\u0301\\u0303\u0005H%\u0002\\u0302\\u0301\u0003\u0002\u0002\u0002\\u0302\\u0303\u0003\u0002\u0002\u0002\\u0303\\u030A\u0003\u0002\u0002\u0002\\u0304\\u0306\\x07\u0012\u0002\u0002\\u0305\\u0307\u0005H%\u0002\\u0306\\u0305\u0003\u0002\u0002\u0002\\u0306\\u0307\u0003\u0002\u0002\u0002\\u0307\\u0309\u0003\u0002\u0002\u0002\\u0308\\u0304\u0003\u0002\u0002\u0002\\u0309\\u030C\u0003\u0002\u0002\u0002\\u030A\\u0308\u0003\u0002\u0002\u0002\\u030A\\u030B\u0003\u0002\u0002\u0002\\u030B\\x81\u0003\u0002\u0002\u0002\\u030C\\u030A\u0003\u0002\u0002\u0002\\u030D\\u0314\\x07\u0019\u0002\u0002\\u030E\\u0310\u0005\\xBE`\u0002\\u030F\\u030E\u0003\u0002\u0002\u0002\\u030F\\u0310\u0003\u0002\u0002\u0002\\u0310\\u0311\u0003\u0002\u0002\u0002\\u0311\\u0313\\x07\u0012\u0002\u0002\\u0312\\u030F\u0003\u0002\u0002\u0002\\u0313\\u0316\u0003\u0002\u0002\u0002\\u0314\\u0312\u0003\u0002\u0002\u0002\\u0314\\u0315\u0003\u0002\u0002\u0002\\u0315\\u0318\u0003\u0002\u0002\u0002\\u0316\\u0314\u0003\u0002\u0002\u0002\\u0317\\u0319\u0005\\xBE`\u0002\\u0318\\u0317\u0003\u0002\u0002\u0002\\u0318\\u0319\u0003\u0002\u0002\u0002\\u0319\\u031A\u0003\u0002\u0002\u0002\\u031A\\u031B\\x07\u001a\u0002\u0002\\u031B\\x83\u0003\u0002\u0002\u0002\\u031C\\u031D\t\u0006\u0002\u0002\\u031D\\x85\u0003\u0002\u0002\u0002\\u031E\\u031F\\bD\u0001\u0002\\u031F\\u0320\\x07?\u0002\u0002\\u0320\\u0331\u0005J&\u0002\\u0321\\u0322\\x07\u0019\u0002\u0002\\u0322\\u0323\u0005\\x86D\u0002\\u0323\\u0324\\x07\u001a\u0002\u0002\\u0324\\u0331\u0003\u0002\u0002\u0002\\u0325\\u0326\t\\x07\u0002\u0002\\u0326\\u0331\u0005\\x86D\u0015\\u0327\\u0328\t\\b\u0002\u0002\\u0328\\u0331\u0005\\x86D\u0014\\u0329\\u032A\t\t\u0002\u0002\\u032A\\u0331\u0005\\x86D\u0013\\u032B\\u032C\\x07E\u0002\u0002\\u032C\\u0331\u0005\\x86D\u0012\\u032D\\u032E\\x07\\b\u0002\u0002\\u032E\\u0331\u0005\\x86D\u0011\\u032F\\u0331\u0005\\x88E\u0002\\u0330\\u031E\u0003\u0002\u0002\u0002\\u0330\\u0321\u0003\u0002\u0002\u0002\\u0330\\u0325\u0003\u0002\u0002\u0002\\u0330\\u0327\u0003\u0002\u0002\u0002\\u0330\\u0329\u0003\u0002\u0002\u0002\\u0330\\u032B\u0003\u0002\u0002\u0002\\u0330\\u032D\u0003\u0002\u0002\u0002\\u0330\\u032F\u0003\u0002\u0002\u0002\\u0331\\u037C\u0003\u0002\u0002\u0002\\u0332\\u0333\\f\u0010\u0002\u0002\\u0333\\u0334\\x07F\u0002\u0002\\u0334\\u037B\u0005\\x86D\u0011\\u0335\\u0336\\f\u000f\u0002\u0002\\u0336\\u0337\t\\n\u0002\u0002\\u0337\\u037B\u0005\\x86D\u0010\\u0338\\u0339\\f\u000e\u0002\u0002\\u0339\\u033A\t\\b\u0002\u0002\\u033A\\u037B\u0005\\x86D\u000f\\u033B\\u033C\\f\\r\u0002\u0002\\u033C\\u033D\t\\v\u0002\u0002\\u033D\\u037B\u0005\\x86D\u000e\\u033E\\u033F\\f\\f\u0002\u0002\\u033F\\u0340\\x07K\u0002\u0002\\u0340\\u037B\u0005\\x86D\\r\\u0341\\u0342\\f\\v\u0002\u0002\\u0342\\u0343\\x07\\x07\u0002\u0002\\u0343\\u037B\u0005\\x86D\\f\\u0344\\u0345\\f\\n\u0002\u0002\\u0345\\u0346\\x07L\u0002\u0002\\u0346\\u037B\u0005\\x86D\\v\\u0347\\u0348\\f\t\u0002\u0002\\u0348\\u0349\t\\f\u0002\u0002\\u0349\\u037B\u0005\\x86D\\n\\u034A\\u034B\\f\\b\u0002\u0002\\u034B\\u034C\t\\r\u0002\u0002\\u034C\\u037B\u0005\\x86D\t\\u034D\\u034E\\f\\x07\u0002\u0002\\u034E\\u034F\\x07O\u0002\u0002\\u034F\\u037B\u0005\\x86D\\b\\u0350\\u0351\\f\u0006\u0002\u0002\\u0351\\u0352\\x07\u0006\u0002\u0002\\u0352\\u037B\u0005\\x86D\\x07\\u0353\\u0354\\f\u0005\u0002\u0002\\u0354\\u0355\\x07P\u0002\u0002\\u0355\\u0356\u0005\\x86D\u0002\\u0356\\u0357\\x07@\u0002\u0002\\u0357\\u0358\u0005\\x86D\u0006\\u0358\\u037B\u0003\u0002\u0002\u0002\\u0359\\u035A\\f\u0004\u0002\u0002\\u035A\\u035B\t\u000e\u0002\u0002\\u035B\\u037B\u0005\\x86D\u0005\\u035C\\u035D\\f\u001d\u0002\u0002\\u035D\\u037B\t\\x07\u0002\u0002\\u035E\\u035F\\f\u001b\u0002\u0002\\u035F\\u0360\\x07$\u0002\u0002\\u0360\\u0361\u0005\\x86D\u0002\\u0361\\u0362\\x07%\u0002\u0002\\u0362\\u037B\u0003\u0002\u0002\u0002\\u0363\\u0364\\f\u001a\u0002\u0002\\u0364\\u0366\\x07$\u0002\u0002\\u0365\\u0367\u0005\\x86D\u0002\\u0366\\u0365\u0003\u0002\u0002\u0002\\u0366\\u0367\u0003\u0002\u0002\u0002\\u0367\\u0368\u0003\u0002\u0002\u0002\\u0368\\u036A\\x07@\u0002\u0002\\u0369\\u036B\u0005\\x86D\u0002\\u036A\\u0369\u0003\u0002\u0002\u0002\\u036A\\u036B\u0003\u0002\u0002\u0002\\u036B\\u036C\u0003\u0002\u0002\u0002\\u036C\\u037B\\x07%\u0002\u0002\\u036D\\u036E\\f\u0019\u0002\u0002\\u036E\\u036F\\x07'\u0002\u0002\\u036F\\u037B\u0005\\xBE`\u0002\\u0370\\u0371\\f\u0018\u0002\u0002\\u0371\\u0372\\x07\u0011\u0002\u0002\\u0372\\u0373\u0005\\x8CG\u0002\\u0373\\u0374\\x07\u0013\u0002\u0002\\u0374\\u037B\u0003\u0002\u0002\u0002\\u0375\\u0376\\f\u0017\u0002\u0002\\u0376\\u0377\\x07\u0019\u0002\u0002\\u0377\\u0378\u0005\\x90I\u0002\\u0378\\u0379\\x07\u001a\u0002\u0002\\u0379\\u037B\u0003\u0002\u0002\u0002\\u037A\\u0332\u0003\u0002\u0002\u0002\\u037A\\u0335\u0003\u0002\u0002\u0002\\u037A\\u0338\u0003\u0002\u0002\u0002\\u037A\\u033B\u0003\u0002\u0002\u0002\\u037A\\u033E\u0003\u0002\u0002\u0002\\u037A\\u0341\u0003\u0002\u0002\u0002\\u037A\\u0344\u0003\u0002\u0002\u0002\\u037A\\u0347\u0003\u0002\u0002\u0002\\u037A\\u034A\u0003\u0002\u0002\u0002\\u037A\\u034D\u0003\u0002\u0002\u0002\\u037A\\u0350\u0003\u0002\u0002\u0002\\u037A\\u0353\u0003\u0002\u0002\u0002\\u037A\\u0359\u0003\u0002\u0002\u0002\\u037A\\u035C\u0003\u0002\u0002\u0002\\u037A\\u035E\u0003\u0002\u0002\u0002\\u037A\\u0363\u0003\u0002\u0002\u0002\\u037A\\u036D\u0003\u0002\u0002\u0002\\u037A\\u0370\u0003\u0002\u0002\u0002\\u037A\\u0375\u0003\u0002\u0002\u0002\\u037B\\u037E\u0003\u0002\u0002\u0002\\u037C\\u037A\u0003\u0002\u0002\u0002\\u037C\\u037D\u0003\u0002\u0002\u0002\\u037D\\x87\u0003\u0002\u0002\u0002\\u037E\\u037C\u0003\u0002\u0002\u0002\\u037F\\u0389\\x07i\u0002\u0002\\u0380\\u0389\u0005\\xBC_\u0002\\u0381\\u0389\u0005\\xC0a\u0002\\u0382\\u0389\u0005\\xC4c\u0002\\u0383\\u0389\u0005\\xBE`\u0002\\u0384\\u0389\\x07}\u0002\u0002\\u0385\\u0389\\x07x\u0002\u0002\\u0386\\u0389\u0005\\xBA^\u0002\\u0387\\u0389\u0005J&\u0002\\u0388\\u037F\u0003\u0002\u0002\u0002\\u0388\\u0380\u0003\u0002\u0002\u0002\\u0388\\u0381\u0003\u0002\u0002\u0002\\u0388\\u0382\u0003\u0002\u0002\u0002\\u0388\\u0383\u0003\u0002\u0002\u0002\\u0388\\u0384\u0003\u0002\u0002\u0002\\u0388\\u0385\u0003\u0002\u0002\u0002\\u0388\\u0386\u0003\u0002\u0002\u0002\\u0388\\u0387\u0003\u0002\u0002\u0002\\u0389\\x89\u0003\u0002\u0002\u0002\\u038A\\u038F\u0005\\x86D\u0002\\u038B\\u038C\\x07\u0012\u0002\u0002\\u038C\\u038E\u0005\\x86D\u0002\\u038D\\u038B\u0003\u0002\u0002\u0002\\u038E\\u0391\u0003\u0002\u0002\u0002\\u038F\\u038D\u0003\u0002\u0002\u0002\\u038F\\u0390\u0003\u0002\u0002\u0002\\u0390\\x8B\u0003\u0002\u0002\u0002\\u0391\\u038F\u0003\u0002\u0002\u0002\\u0392\\u0397\u0005\\x8EH\u0002\\u0393\\u0394\\x07\u0012\u0002\u0002\\u0394\\u0396\u0005\\x8EH\u0002\\u0395\\u0393\u0003\u0002\u0002\u0002\\u0396\\u0399\u0003\u0002\u0002\u0002\\u0397\\u0395\u0003\u0002\u0002\u0002\\u0397\\u0398\u0003\u0002\u0002\u0002\\u0398\\u039B\u0003\u0002\u0002\u0002\\u0399\\u0397\u0003\u0002\u0002\u0002\\u039A\\u039C\\x07\u0012\u0002\u0002\\u039B\\u039A\u0003\u0002\u0002\u0002\\u039B\\u039C\u0003\u0002\u0002\u0002\\u039C\\x8D\u0003\u0002\u0002\u0002\\u039D\\u039E\u0005\\xBE`\u0002\\u039E\\u039F\\x07@\u0002\u0002\\u039F\\u03A0\u0005\\x86D\u0002\\u03A0\\x8F\u0003\u0002\u0002\u0002\\u03A1\\u03A3\\x07\u0011\u0002\u0002\\u03A2\\u03A4\u0005\\x8CG\u0002\\u03A3\\u03A2\u0003\u0002\u0002\u0002\\u03A3\\u03A4\u0003\u0002\u0002\u0002\\u03A4\\u03A5\u0003\u0002\u0002\u0002\\u03A5\\u03AA\\x07\u0013\u0002\u0002\\u03A6\\u03A8\u0005\\x8AF\u0002\\u03A7\\u03A6\u0003\u0002\u0002\u0002\\u03A7\\u03A8\u0003\u0002\u0002\u0002\\u03A8\\u03AA\u0003\u0002\u0002\u0002\\u03A9\\u03A1\u0003\u0002\u0002\u0002\\u03A9\\u03A7\u0003\u0002\u0002\u0002\\u03AA\\x91\u0003\u0002\u0002\u0002\\u03AB\\u03AC\u0005\\x86D\u0002\\u03AC\\u03AD\\x07\u0019\u0002\u0002\\u03AD\\u03AE\u0005\\x90I\u0002\\u03AE\\u03AF\\x07\u001a\u0002\u0002\\u03AF\\x93\u0003\u0002\u0002\u0002\\u03B0\\u03B4\\x07\u0011\u0002\u0002\\u03B1\\u03B3\u0005\\x96L\u0002\\u03B2\\u03B1\u0003\u0002\u0002\u0002\\u03B3\\u03B6\u0003\u0002\u0002\u0002\\u03B4\\u03B2\u0003\u0002\u0002\u0002\\u03B4\\u03B5\u0003\u0002\u0002\u0002\\u03B5\\u03B7\u0003\u0002\u0002\u0002\\u03B6\\u03B4\u0003\u0002\u0002\u0002\\u03B7\\u03B8\\x07\u0013\u0002\u0002\\u03B8\\x95\u0003\u0002\u0002\u0002\\u03B9\\u03CC\u0005\\xBE`\u0002\\u03BA\\u03CC\u0005\\x94K\u0002\\u03BB\\u03CC\u0005\\x98M\u0002\\u03BC\\u03CC\u0005\\x9EP\u0002\\u03BD\\u03CC\u0005\\xA0Q\u0002\\u03BE\\u03CC\u0005\\xA6T\u0002\\u03BF\\u03CC\u0005\\xA8U\u0002\\u03C0\\u03CC\u0005\\xAAV\u0002\\u03C1\\u03CC\u0005\\xAEX\u0002\\u03C2\\u03CC\u0005\\xB2Z\u0002\\u03C3\\u03CC\u0005\\xB4[\u0002\\u03C4\\u03CC\\x07p\u0002\u0002\\u03C5\\u03CC\\x07s\u0002\u0002\\u03C6\\u03CC\\x07t\u0002\u0002\\u03C7\\u03CC\u0005\\xB8]\u0002\\u03C8\\u03CC\u0005\\xBC_\u0002\\u03C9\\u03CC\u0005\\xC4c\u0002\\u03CA\\u03CC\u0005\\xC0a\u0002\\u03CB\\u03B9\u0003\u0002\u0002\u0002\\u03CB\\u03BA\u0003\u0002\u0002\u0002\\u03CB\\u03BB\u0003\u0002\u0002\u0002\\u03CB\\u03BC\u0003\u0002\u0002\u0002\\u03CB\\u03BD\u0003\u0002\u0002\u0002\\u03CB\\u03BE\u0003\u0002\u0002\u0002\\u03CB\\u03BF\u0003\u0002\u0002\u0002\\u03CB\\u03C0\u0003\u0002\u0002\u0002\\u03CB\\u03C1\u0003\u0002\u0002\u0002\\u03CB\\u03C2\u0003\u0002\u0002\u0002\\u03CB\\u03C3\u0003\u0002\u0002\u0002\\u03CB\\u03C4\u0003\u0002\u0002\u0002\\u03CB\\u03C5\u0003\u0002\u0002\u0002\\u03CB\\u03C6\u0003\u0002\u0002\u0002\\u03CB\\u03C7\u0003\u0002\u0002\u0002\\u03CB\\u03C8\u0003\u0002\u0002\u0002\\u03CB\\u03C9\u0003\u0002\u0002\u0002\\u03CB\\u03CA\u0003\u0002\u0002\u0002\\u03CC\\x97\u0003\u0002\u0002\u0002\\u03CD\\u03D1\u0005\\x9CO\u0002\\u03CE\\u03D1\u0005\\xB6\\\\\u0002\\u03CF\\u03D1\u0005\\x9AN\u0002\\u03D0\\u03CD\u0003\u0002\u0002\u0002\\u03D0\\u03CE\u0003\u0002\u0002\u0002\\u03D0\\u03CF\u0003\u0002\u0002\u0002\\u03D1\\x99\u0003\u0002\u0002\u0002\\u03D2\\u03D3\u0005\\xBE`\u0002\\u03D3\\u03D4\\x07'\u0002\u0002\\u03D4\\u03D5\u0005\\xBE`\u0002\\u03D5\\x9B\u0003\u0002\u0002\u0002\\u03D6\\u03DB\\x075\u0002\u0002\\u03D7\\u03DB\\x07&\u0002\u0002\\u03D8\\u03DB\\x07<\u0002\u0002\\u03D9\\u03DB\u0005\\xBE`\u0002\\u03DA\\u03D6\u0003\u0002\u0002\u0002\\u03DA\\u03D7\u0003\u0002\u0002\u0002\\u03DA\\u03D8\u0003\u0002\u0002\u0002\\u03DA\\u03D9\u0003\u0002\u0002\u0002\\u03DB\\u03E8\u0003\u0002\u0002\u0002\\u03DC\\u03DE\\x07\u0019\u0002\u0002\\u03DD\\u03DF\u0005\\x98M\u0002\\u03DE\\u03DD\u0003\u0002\u0002\u0002\\u03DE\\u03DF\u0003\u0002\u0002\u0002\\u03DF\\u03E4\u0003\u0002\u0002\u0002\\u03E0\\u03E1\\x07\u0012\u0002\u0002\\u03E1\\u03E3\u0005\\x98M\u0002\\u03E2\\u03E0\u0003\u0002\u0002\u0002\\u03E3\\u03E6\u0003\u0002\u0002\u0002\\u03E4\\u03E2\u0003\u0002\u0002\u0002\\u03E4\\u03E5\u0003\u0002\u0002\u0002\\u03E5\\u03E7\u0003\u0002\u0002\u0002\\u03E6\\u03E4\u0003\u0002\u0002\u0002\\u03E7\\u03E9\\x07\u001a\u0002\u0002\\u03E8\\u03DC\u0003\u0002\u0002\u0002\\u03E8\\u03E9\u0003\u0002\u0002\u0002\\u03E9\\x9D\u0003\u0002\u0002\u0002\\u03EA\\u03EB\\x07[\u0002\u0002\\u03EB\\u03EE\u0005\\xA2R\u0002\\u03EC\\u03ED\\x07\\\\\u0002\u0002\\u03ED\\u03EF\u0005\\x98M\u0002\\u03EE\\u03EC\u0003\u0002\u0002\u0002\\u03EE\\u03EF\u0003\u0002\u0002\u0002\\u03EF\\x9F\u0003\u0002\u0002\u0002\\u03F0\\u03F1\u0005\\xA2R\u0002\\u03F1\\u03F2\\x07\\\\\u0002\u0002\\u03F2\\u03F3\u0005\\x98M\u0002\\u03F3\\xA1\u0003\u0002\u0002\u0002\\u03F4\\u03FC\u0005\\xBE`\u0002\\u03F5\\u03FC\u0005\\x9AN\u0002\\u03F6\\u03FC\u0005\\xA4S\u0002\\u03F7\\u03F8\\x07\u0019\u0002\u0002\\u03F8\\u03F9\u0005\\xA4S\u0002\\u03F9\\u03FA\\x07\u001a\u0002\u0002\\u03FA\\u03FC\u0003\u0002\u0002\u0002\\u03FB\\u03F4\u0003\u0002\u0002\u0002\\u03FB\\u03F5\u0003\u0002\u0002\u0002\\u03FB\\u03F6\u0003\u0002\u0002\u0002\\u03FB\\u03F7\u0003\u0002\u0002\u0002\\u03FC\\xA3\u0003\u0002\u0002\u0002\\u03FD\\u0402\u0005\\xBE`\u0002\\u03FE\\u03FF\\x07\u0012\u0002\u0002\\u03FF\\u0401\u0005\\xBE`\u0002\\u0400\\u03FE\u0003\u0002\u0002\u0002\\u0401\\u0404\u0003\u0002\u0002\u0002\\u0402\\u0400\u0003\u0002\u0002\u0002\\u0402\\u0403\u0003\u0002\u0002\u0002\\u0403\\xA5\u0003\u0002\u0002\u0002\\u0404\\u0402\u0003\u0002\u0002\u0002\\u0405\\u0406\u0005\\x98M\u0002\\u0406\\u0407\\x07]\u0002\u0002\\u0407\\u0408\u0005\\xBE`\u0002\\u0408\\xA7\u0003\u0002\u0002\u0002\\u0409\\u040A\u0005\\xBE`\u0002\\u040A\\u040B\\x07@\u0002\u0002\\u040B\\xA9\u0003\u0002\u0002\u0002\\u040C\\u040D\\x07^\u0002\u0002\\u040D\\u0411\u0005\\x98M\u0002\\u040E\\u0410\u0005\\xACW\u0002\\u040F\\u040E\u0003\u0002\u0002\u0002\\u0410\\u0413\u0003\u0002\u0002\u0002\\u0411\\u040F\u0003\u0002\u0002\u0002\\u0411\\u0412\u0003\u0002\u0002\u0002\\u0412\\xAB\u0003\u0002\u0002\u0002\\u0413\\u0411\u0003\u0002\u0002\u0002\\u0414\\u0415\\x07_\u0002\u0002\\u0415\\u0416\u0005\\xB6\\\\\u0002\\u0416\\u0417\u0005\\x94K\u0002\\u0417\\u041B\u0003\u0002\u0002\u0002\\u0418\\u0419\\x07`\u0002\u0002\\u0419\\u041B\u0005\\x94K\u0002\\u041A\\u0414\u0003\u0002\u0002\u0002\\u041A\\u0418\u0003\u0002\u0002\u0002\\u041B\\xAD\u0003\u0002\u0002\u0002\\u041C\\u041D\\x07 \u0002\u0002\\u041D\\u041E\u0005\\xBE`\u0002\\u041E\\u0420\\x07\u0019\u0002\u0002\\u041F\\u0421\u0005\\xA4S\u0002\\u0420\\u041F\u0003\u0002\u0002\u0002\\u0420\\u0421\u0003\u0002\u0002\u0002\\u0421\\u0422\u0003\u0002\u0002\u0002\\u0422\\u0424\\x07\u001a\u0002\u0002\\u0423\\u0425\u0005\\xB0Y\u0002\\u0424\\u0423\u0003\u0002\u0002\u0002\\u0424\\u0425\u0003\u0002\u0002\u0002\\u0425\\u0426\u0003\u0002\u0002\u0002\\u0426\\u0427\u0005\\x94K\u0002\\u0427\\xAF\u0003\u0002\u0002\u0002\\u0428\\u0429\\x07a\u0002\u0002\\u0429\\u042A\u0005\\xA4S\u0002\\u042A\\xB1\u0003\u0002\u0002\u0002\\u042B\\u042E\\x07\u001d\u0002\u0002\\u042C\\u042F\u0005\\x94K\u0002\\u042D\\u042F\u0005\\x98M\u0002\\u042E\\u042C\u0003\u0002\u0002\u0002\\u042E\\u042D\u0003\u0002\u0002\u0002\\u042F\\u0430\u0003\u0002\u0002\u0002\\u0430\\u0433\u0005\\x98M\u0002\\u0431\\u0434\u0005\\x94K\u0002\\u0432\\u0434\u0005\\x98M\u0002\\u0433\\u0431\u0003\u0002\u0002\u0002\\u0433\\u0432\u0003\u0002\u0002\u0002\\u0434\\u0435\u0003\u0002\u0002\u0002\\u0435\\u0436\u0005\\x94K\u0002\\u0436\\xB3\u0003\u0002\u0002\u0002\\u0437\\u0438\\x07-\u0002\u0002\\u0438\\u0439\u0005\\x98M\u0002\\u0439\\u043A\u0005\\x94K\u0002\\u043A\\xB5\u0003\u0002\u0002\u0002\\u043B\\u0441\u0005\\xC4c\u0002\\u043C\\u0441\\x07j\u0002\u0002\\u043D\\u0441\\x07k\u0002\u0002\\u043E\\u0441\u0005\\xC0a\u0002\\u043F\\u0441\\x07i\u0002\u0002\\u0440\\u043B\u0003\u0002\u0002\u0002\\u0440\\u043C\u0003\u0002\u0002\u0002\\u0440\\u043D\u0003\u0002\u0002\u0002\\u0440\\u043E\u0003\u0002\u0002\u0002\\u0440\\u043F\u0003\u0002\";\nSolidityParser._serializedATNSegment2 = \"\u0002\u0002\\u0441\\xB7\u0003\u0002\u0002\u0002\\u0442\\u0443\\x073\u0002\u0002\\u0443\\u0444\u0005\\xBE`\u0002\\u0444\\u0445\u0005\\x94K\u0002\\u0445\\xB9\u0003\u0002\u0002\u0002\\u0446\\u0448\\x07\u0019\u0002\u0002\\u0447\\u0449\u0005\\x86D\u0002\\u0448\\u0447\u0003\u0002\u0002\u0002\\u0448\\u0449\u0003\u0002\u0002\u0002\\u0449\\u0450\u0003\u0002\u0002\u0002\\u044A\\u044C\\x07\u0012\u0002\u0002\\u044B\\u044D\u0005\\x86D\u0002\\u044C\\u044B\u0003\u0002\u0002\u0002\\u044C\\u044D\u0003\u0002\u0002\u0002\\u044D\\u044F\u0003\u0002\u0002\u0002\\u044E\\u044A\u0003\u0002\u0002\u0002\\u044F\\u0452\u0003\u0002\u0002\u0002\\u0450\\u044E\u0003\u0002\u0002\u0002\\u0450\\u0451\u0003\u0002\u0002\u0002\\u0451\\u0453\u0003\u0002\u0002\u0002\\u0452\\u0450\u0003\u0002\u0002\u0002\\u0453\\u0461\\x07\u001a\u0002\u0002\\u0454\\u045D\\x07$\u0002\u0002\\u0455\\u045A\u0005\\x86D\u0002\\u0456\\u0457\\x07\u0012\u0002\u0002\\u0457\\u0459\u0005\\x86D\u0002\\u0458\\u0456\u0003\u0002\u0002\u0002\\u0459\\u045C\u0003\u0002\u0002\u0002\\u045A\\u0458\u0003\u0002\u0002\u0002\\u045A\\u045B\u0003\u0002\u0002\u0002\\u045B\\u045E\u0003\u0002\u0002\u0002\\u045C\\u045A\u0003\u0002\u0002\u0002\\u045D\\u0455\u0003\u0002\u0002\u0002\\u045D\\u045E\u0003\u0002\u0002\u0002\\u045E\\u045F\u0003\u0002\u0002\u0002\\u045F\\u0461\\x07%\u0002\u0002\\u0460\\u0446\u0003\u0002\u0002\u0002\\u0460\\u0454\u0003\u0002\u0002\u0002\\u0461\\xBB\u0003\u0002\u0002\u0002\\u0462\\u0464\t\u000f\u0002\u0002\\u0463\\u0465\\x07l\u0002\u0002\\u0464\\u0463\u0003\u0002\u0002\u0002\\u0464\\u0465\u0003\u0002\u0002\u0002\\u0465\\xBD\u0003\u0002\u0002\u0002\\u0466\\u0467\t\u0010\u0002\u0002\\u0467\\xBF\u0003\u0002\u0002\u0002\\u0468\\u046A\\x07m\u0002\u0002\\u0469\\u0468\u0003\u0002\u0002\u0002\\u046A\\u046B\u0003\u0002\u0002\u0002\\u046B\\u0469\u0003\u0002\u0002\u0002\\u046B\\u046C\u0003\u0002\u0002\u0002\\u046C\\xC1\u0003\u0002\u0002\u0002\\u046D\\u0479\\x07c\u0002\u0002\\u046E\\u046F\\x07\u0019\u0002\u0002\\u046F\\u0474\u0005L'\u0002\\u0470\\u0471\\x07\u0012\u0002\u0002\\u0471\\u0473\u0005L'\u0002\\u0472\\u0470\u0003\u0002\u0002\u0002\\u0473\\u0476\u0003\u0002\u0002\u0002\\u0474\\u0472\u0003\u0002\u0002\u0002\\u0474\\u0475\u0003\u0002\u0002\u0002\\u0475\\u0477\u0003\u0002\u0002\u0002\\u0476\\u0474\u0003\u0002\u0002\u0002\\u0477\\u0478\\x07\u001a\u0002\u0002\\u0478\\u047A\u0003\u0002\u0002\u0002\\u0479\\u046E\u0003\u0002\u0002\u0002\\u0479\\u047A\u0003\u0002\u0002\u0002\\u047A\\xC3\u0003\u0002\u0002\u0002\\u047B\\u047D\\x07\\x84\u0002\u0002\\u047C\\u047B\u0003\u0002\u0002\u0002\\u047D\\u047E\u0003\u0002\u0002\u0002\\u047E\\u047C\u0003\u0002\u0002\u0002\\u047E\\u047F\u0003\u0002\u0002\u0002\\u047F\\xC5\u0003\u0002\u0002\u0002\\x81\\xD0\\xD2\\xE1\\xE5\\xEA\\xF0\\xF4\\xF7\\xFC\\u0102\\u0109\\u010D\\u011A\\u0122\\u0127\\u0131\\u0134\\u013A\\u0142\\u0145\\u0150\\u0159\\u015B\\u0161\\u017C\\u017F\\u018A\\u018F\\u019B\\u019E\\u01A5\\u01A9\\u01AB\\u01B0\\u01B5\\u01B8\\u01BE\\u01C2\\u01C6\\u01CB\\u01D8\\u01DA\\u01E1\\u01EB\\u01F1\\u01FC\\u01FF\\u0205\\u0208\\u0210\\u0213\\u0219\\u021C\\u0224\\u0227\\u022D\\u0231\\u023C\\u0241\\u0246\\u024E\\u0253\\u0261\\u0263\\u0268\\u0272\\u0286\\u0292\\u0297\\u029D\\u02A1\\u02A4\\u02B0\\u02B9\\u02BD\\u02C0\\u02C7\\u02CD\\u02E3\\u02F9\\u02FD\\u0302\\u0306\\u030A\\u030F\\u0314\\u0318\\u0330\\u0366\\u036A\\u037A\\u037C\\u0388\\u038F\\u0397\\u039B\\u03A3\\u03A7\\u03A9\\u03B4\\u03CB\\u03D0\\u03DA\\u03DE\\u03E4\\u03E8\\u03EE\\u03FB\\u0402\\u0411\\u041A\\u0420\\u0424\\u042E\\u0433\\u0440\\u0448\\u044C\\u0450\\u045A\\u045D\\u0460\\u0464\\u046B\\u0474\\u0479\\u047E\";\nSolidityParser._serializedATN = Utils2.join([\n  _SolidityParser._serializedATNSegment0,\n  _SolidityParser._serializedATNSegment1,\n  _SolidityParser._serializedATNSegment2\n], \"\");\nvar SourceUnitContext = class extends import_ParserRuleContext.ParserRuleContext {\n  EOF() {\n    return this.getToken(SolidityParser.EOF, 0);\n  }\n  pragmaDirective(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(PragmaDirectiveContext);\n    } else {\n      return this.getRuleContext(i, PragmaDirectiveContext);\n    }\n  }\n  importDirective(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(ImportDirectiveContext);\n    } else {\n      return this.getRuleContext(i, ImportDirectiveContext);\n    }\n  }\n  contractDefinition(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(ContractDefinitionContext);\n    } else {\n      return this.getRuleContext(i, ContractDefinitionContext);\n    }\n  }\n  enumDefinition(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(EnumDefinitionContext);\n    } else {\n      return this.getRuleContext(i, EnumDefinitionContext);\n    }\n  }\n  structDefinition(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(StructDefinitionContext);\n    } else {\n      return this.getRuleContext(i, StructDefinitionContext);\n    }\n  }\n  functionDefinition(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(FunctionDefinitionContext);\n    } else {\n      return this.getRuleContext(i, FunctionDefinitionContext);\n    }\n  }\n  fileLevelConstant(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(FileLevelConstantContext);\n    } else {\n      return this.getRuleContext(i, FileLevelConstantContext);\n    }\n  }\n  customErrorDefinition(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(CustomErrorDefinitionContext);\n    } else {\n      return this.getRuleContext(i, CustomErrorDefinitionContext);\n    }\n  }\n  typeDefinition(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(TypeDefinitionContext);\n    } else {\n      return this.getRuleContext(i, TypeDefinitionContext);\n    }\n  }\n  usingForDeclaration(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(UsingForDeclarationContext);\n    } else {\n      return this.getRuleContext(i, UsingForDeclarationContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_sourceUnit;\n  }\n  enterRule(listener) {\n    if (listener.enterSourceUnit) {\n      listener.enterSourceUnit(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitSourceUnit) {\n      listener.exitSourceUnit(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitSourceUnit) {\n      return visitor.visitSourceUnit(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar PragmaDirectiveContext = class extends import_ParserRuleContext.ParserRuleContext {\n  pragmaName() {\n    return this.getRuleContext(0, PragmaNameContext);\n  }\n  pragmaValue() {\n    return this.getRuleContext(0, PragmaValueContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_pragmaDirective;\n  }\n  enterRule(listener) {\n    if (listener.enterPragmaDirective) {\n      listener.enterPragmaDirective(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitPragmaDirective) {\n      listener.exitPragmaDirective(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitPragmaDirective) {\n      return visitor.visitPragmaDirective(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar PragmaNameContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifier() {\n    return this.getRuleContext(0, IdentifierContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_pragmaName;\n  }\n  enterRule(listener) {\n    if (listener.enterPragmaName) {\n      listener.enterPragmaName(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitPragmaName) {\n      listener.exitPragmaName(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitPragmaName) {\n      return visitor.visitPragmaName(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar PragmaValueContext = class extends import_ParserRuleContext.ParserRuleContext {\n  version() {\n    return this.tryGetRuleContext(0, VersionContext);\n  }\n  expression() {\n    return this.tryGetRuleContext(0, ExpressionContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_pragmaValue;\n  }\n  enterRule(listener) {\n    if (listener.enterPragmaValue) {\n      listener.enterPragmaValue(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitPragmaValue) {\n      listener.exitPragmaValue(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitPragmaValue) {\n      return visitor.visitPragmaValue(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar VersionContext = class extends import_ParserRuleContext.ParserRuleContext {\n  versionConstraint(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(VersionConstraintContext);\n    } else {\n      return this.getRuleContext(i, VersionConstraintContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_version;\n  }\n  enterRule(listener) {\n    if (listener.enterVersion) {\n      listener.enterVersion(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitVersion) {\n      listener.exitVersion(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitVersion) {\n      return visitor.visitVersion(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar VersionOperatorContext = class extends import_ParserRuleContext.ParserRuleContext {\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_versionOperator;\n  }\n  enterRule(listener) {\n    if (listener.enterVersionOperator) {\n      listener.enterVersionOperator(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitVersionOperator) {\n      listener.exitVersionOperator(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitVersionOperator) {\n      return visitor.visitVersionOperator(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar VersionConstraintContext = class extends import_ParserRuleContext.ParserRuleContext {\n  VersionLiteral() {\n    return this.tryGetToken(SolidityParser.VersionLiteral, 0);\n  }\n  versionOperator() {\n    return this.tryGetRuleContext(0, VersionOperatorContext);\n  }\n  DecimalNumber() {\n    return this.tryGetToken(SolidityParser.DecimalNumber, 0);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_versionConstraint;\n  }\n  enterRule(listener) {\n    if (listener.enterVersionConstraint) {\n      listener.enterVersionConstraint(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitVersionConstraint) {\n      listener.exitVersionConstraint(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitVersionConstraint) {\n      return visitor.visitVersionConstraint(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar ImportDeclarationContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifier(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(IdentifierContext);\n    } else {\n      return this.getRuleContext(i, IdentifierContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_importDeclaration;\n  }\n  enterRule(listener) {\n    if (listener.enterImportDeclaration) {\n      listener.enterImportDeclaration(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitImportDeclaration) {\n      listener.exitImportDeclaration(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitImportDeclaration) {\n      return visitor.visitImportDeclaration(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar ImportDirectiveContext = class extends import_ParserRuleContext.ParserRuleContext {\n  importPath() {\n    return this.getRuleContext(0, ImportPathContext);\n  }\n  identifier(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(IdentifierContext);\n    } else {\n      return this.getRuleContext(i, IdentifierContext);\n    }\n  }\n  importDeclaration(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(ImportDeclarationContext);\n    } else {\n      return this.getRuleContext(i, ImportDeclarationContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_importDirective;\n  }\n  enterRule(listener) {\n    if (listener.enterImportDirective) {\n      listener.enterImportDirective(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitImportDirective) {\n      listener.exitImportDirective(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitImportDirective) {\n      return visitor.visitImportDirective(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar ImportPathContext = class extends import_ParserRuleContext.ParserRuleContext {\n  StringLiteralFragment() {\n    return this.getToken(SolidityParser.StringLiteralFragment, 0);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_importPath;\n  }\n  enterRule(listener) {\n    if (listener.enterImportPath) {\n      listener.enterImportPath(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitImportPath) {\n      listener.exitImportPath(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitImportPath) {\n      return visitor.visitImportPath(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar ContractDefinitionContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifier() {\n    return this.getRuleContext(0, IdentifierContext);\n  }\n  inheritanceSpecifier(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(InheritanceSpecifierContext);\n    } else {\n      return this.getRuleContext(i, InheritanceSpecifierContext);\n    }\n  }\n  contractPart(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(ContractPartContext);\n    } else {\n      return this.getRuleContext(i, ContractPartContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_contractDefinition;\n  }\n  enterRule(listener) {\n    if (listener.enterContractDefinition) {\n      listener.enterContractDefinition(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitContractDefinition) {\n      listener.exitContractDefinition(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitContractDefinition) {\n      return visitor.visitContractDefinition(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar InheritanceSpecifierContext = class extends import_ParserRuleContext.ParserRuleContext {\n  userDefinedTypeName() {\n    return this.getRuleContext(0, UserDefinedTypeNameContext);\n  }\n  expressionList() {\n    return this.tryGetRuleContext(0, ExpressionListContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_inheritanceSpecifier;\n  }\n  enterRule(listener) {\n    if (listener.enterInheritanceSpecifier) {\n      listener.enterInheritanceSpecifier(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitInheritanceSpecifier) {\n      listener.exitInheritanceSpecifier(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitInheritanceSpecifier) {\n      return visitor.visitInheritanceSpecifier(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar ContractPartContext = class extends import_ParserRuleContext.ParserRuleContext {\n  stateVariableDeclaration() {\n    return this.tryGetRuleContext(0, StateVariableDeclarationContext);\n  }\n  usingForDeclaration() {\n    return this.tryGetRuleContext(0, UsingForDeclarationContext);\n  }\n  structDefinition() {\n    return this.tryGetRuleContext(0, StructDefinitionContext);\n  }\n  modifierDefinition() {\n    return this.tryGetRuleContext(0, ModifierDefinitionContext);\n  }\n  functionDefinition() {\n    return this.tryGetRuleContext(0, FunctionDefinitionContext);\n  }\n  eventDefinition() {\n    return this.tryGetRuleContext(0, EventDefinitionContext);\n  }\n  enumDefinition() {\n    return this.tryGetRuleContext(0, EnumDefinitionContext);\n  }\n  customErrorDefinition() {\n    return this.tryGetRuleContext(0, CustomErrorDefinitionContext);\n  }\n  typeDefinition() {\n    return this.tryGetRuleContext(0, TypeDefinitionContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_contractPart;\n  }\n  enterRule(listener) {\n    if (listener.enterContractPart) {\n      listener.enterContractPart(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitContractPart) {\n      listener.exitContractPart(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitContractPart) {\n      return visitor.visitContractPart(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar StateVariableDeclarationContext = class extends import_ParserRuleContext.ParserRuleContext {\n  typeName() {\n    return this.getRuleContext(0, TypeNameContext);\n  }\n  identifier() {\n    return this.getRuleContext(0, IdentifierContext);\n  }\n  PublicKeyword(i) {\n    if (i === void 0) {\n      return this.getTokens(SolidityParser.PublicKeyword);\n    } else {\n      return this.getToken(SolidityParser.PublicKeyword, i);\n    }\n  }\n  InternalKeyword(i) {\n    if (i === void 0) {\n      return this.getTokens(SolidityParser.InternalKeyword);\n    } else {\n      return this.getToken(SolidityParser.InternalKeyword, i);\n    }\n  }\n  PrivateKeyword(i) {\n    if (i === void 0) {\n      return this.getTokens(SolidityParser.PrivateKeyword);\n    } else {\n      return this.getToken(SolidityParser.PrivateKeyword, i);\n    }\n  }\n  ConstantKeyword(i) {\n    if (i === void 0) {\n      return this.getTokens(SolidityParser.ConstantKeyword);\n    } else {\n      return this.getToken(SolidityParser.ConstantKeyword, i);\n    }\n  }\n  ImmutableKeyword(i) {\n    if (i === void 0) {\n      return this.getTokens(SolidityParser.ImmutableKeyword);\n    } else {\n      return this.getToken(SolidityParser.ImmutableKeyword, i);\n    }\n  }\n  overrideSpecifier(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(OverrideSpecifierContext);\n    } else {\n      return this.getRuleContext(i, OverrideSpecifierContext);\n    }\n  }\n  expression() {\n    return this.tryGetRuleContext(0, ExpressionContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_stateVariableDeclaration;\n  }\n  enterRule(listener) {\n    if (listener.enterStateVariableDeclaration) {\n      listener.enterStateVariableDeclaration(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitStateVariableDeclaration) {\n      listener.exitStateVariableDeclaration(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitStateVariableDeclaration) {\n      return visitor.visitStateVariableDeclaration(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar FileLevelConstantContext = class extends import_ParserRuleContext.ParserRuleContext {\n  typeName() {\n    return this.getRuleContext(0, TypeNameContext);\n  }\n  ConstantKeyword() {\n    return this.getToken(SolidityParser.ConstantKeyword, 0);\n  }\n  identifier() {\n    return this.getRuleContext(0, IdentifierContext);\n  }\n  expression() {\n    return this.getRuleContext(0, ExpressionContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_fileLevelConstant;\n  }\n  enterRule(listener) {\n    if (listener.enterFileLevelConstant) {\n      listener.enterFileLevelConstant(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitFileLevelConstant) {\n      listener.exitFileLevelConstant(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitFileLevelConstant) {\n      return visitor.visitFileLevelConstant(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar CustomErrorDefinitionContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifier() {\n    return this.getRuleContext(0, IdentifierContext);\n  }\n  parameterList() {\n    return this.getRuleContext(0, ParameterListContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_customErrorDefinition;\n  }\n  enterRule(listener) {\n    if (listener.enterCustomErrorDefinition) {\n      listener.enterCustomErrorDefinition(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitCustomErrorDefinition) {\n      listener.exitCustomErrorDefinition(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitCustomErrorDefinition) {\n      return visitor.visitCustomErrorDefinition(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar TypeDefinitionContext = class extends import_ParserRuleContext.ParserRuleContext {\n  TypeKeyword() {\n    return this.getToken(SolidityParser.TypeKeyword, 0);\n  }\n  identifier() {\n    return this.getRuleContext(0, IdentifierContext);\n  }\n  elementaryTypeName() {\n    return this.getRuleContext(0, ElementaryTypeNameContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_typeDefinition;\n  }\n  enterRule(listener) {\n    if (listener.enterTypeDefinition) {\n      listener.enterTypeDefinition(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitTypeDefinition) {\n      listener.exitTypeDefinition(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitTypeDefinition) {\n      return visitor.visitTypeDefinition(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar UsingForDeclarationContext = class extends import_ParserRuleContext.ParserRuleContext {\n  usingForObject() {\n    return this.getRuleContext(0, UsingForObjectContext);\n  }\n  typeName() {\n    return this.tryGetRuleContext(0, TypeNameContext);\n  }\n  GlobalKeyword() {\n    return this.tryGetToken(SolidityParser.GlobalKeyword, 0);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_usingForDeclaration;\n  }\n  enterRule(listener) {\n    if (listener.enterUsingForDeclaration) {\n      listener.enterUsingForDeclaration(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitUsingForDeclaration) {\n      listener.exitUsingForDeclaration(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitUsingForDeclaration) {\n      return visitor.visitUsingForDeclaration(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar UsingForObjectContext = class extends import_ParserRuleContext.ParserRuleContext {\n  userDefinedTypeName(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(UserDefinedTypeNameContext);\n    } else {\n      return this.getRuleContext(i, UserDefinedTypeNameContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_usingForObject;\n  }\n  enterRule(listener) {\n    if (listener.enterUsingForObject) {\n      listener.enterUsingForObject(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitUsingForObject) {\n      listener.exitUsingForObject(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitUsingForObject) {\n      return visitor.visitUsingForObject(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar StructDefinitionContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifier() {\n    return this.getRuleContext(0, IdentifierContext);\n  }\n  variableDeclaration(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(VariableDeclarationContext);\n    } else {\n      return this.getRuleContext(i, VariableDeclarationContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_structDefinition;\n  }\n  enterRule(listener) {\n    if (listener.enterStructDefinition) {\n      listener.enterStructDefinition(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitStructDefinition) {\n      listener.exitStructDefinition(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitStructDefinition) {\n      return visitor.visitStructDefinition(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar ModifierDefinitionContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifier() {\n    return this.getRuleContext(0, IdentifierContext);\n  }\n  block() {\n    return this.tryGetRuleContext(0, BlockContext);\n  }\n  parameterList() {\n    return this.tryGetRuleContext(0, ParameterListContext);\n  }\n  VirtualKeyword(i) {\n    if (i === void 0) {\n      return this.getTokens(SolidityParser.VirtualKeyword);\n    } else {\n      return this.getToken(SolidityParser.VirtualKeyword, i);\n    }\n  }\n  overrideSpecifier(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(OverrideSpecifierContext);\n    } else {\n      return this.getRuleContext(i, OverrideSpecifierContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_modifierDefinition;\n  }\n  enterRule(listener) {\n    if (listener.enterModifierDefinition) {\n      listener.enterModifierDefinition(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitModifierDefinition) {\n      listener.exitModifierDefinition(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitModifierDefinition) {\n      return visitor.visitModifierDefinition(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar ModifierInvocationContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifier() {\n    return this.getRuleContext(0, IdentifierContext);\n  }\n  expressionList() {\n    return this.tryGetRuleContext(0, ExpressionListContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_modifierInvocation;\n  }\n  enterRule(listener) {\n    if (listener.enterModifierInvocation) {\n      listener.enterModifierInvocation(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitModifierInvocation) {\n      listener.exitModifierInvocation(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitModifierInvocation) {\n      return visitor.visitModifierInvocation(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar FunctionDefinitionContext = class extends import_ParserRuleContext.ParserRuleContext {\n  functionDescriptor() {\n    return this.getRuleContext(0, FunctionDescriptorContext);\n  }\n  parameterList() {\n    return this.getRuleContext(0, ParameterListContext);\n  }\n  modifierList() {\n    return this.getRuleContext(0, ModifierListContext);\n  }\n  block() {\n    return this.tryGetRuleContext(0, BlockContext);\n  }\n  returnParameters() {\n    return this.tryGetRuleContext(0, ReturnParametersContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_functionDefinition;\n  }\n  enterRule(listener) {\n    if (listener.enterFunctionDefinition) {\n      listener.enterFunctionDefinition(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitFunctionDefinition) {\n      listener.exitFunctionDefinition(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitFunctionDefinition) {\n      return visitor.visitFunctionDefinition(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar FunctionDescriptorContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifier() {\n    return this.tryGetRuleContext(0, IdentifierContext);\n  }\n  ConstructorKeyword() {\n    return this.tryGetToken(SolidityParser.ConstructorKeyword, 0);\n  }\n  FallbackKeyword() {\n    return this.tryGetToken(SolidityParser.FallbackKeyword, 0);\n  }\n  ReceiveKeyword() {\n    return this.tryGetToken(SolidityParser.ReceiveKeyword, 0);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_functionDescriptor;\n  }\n  enterRule(listener) {\n    if (listener.enterFunctionDescriptor) {\n      listener.enterFunctionDescriptor(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitFunctionDescriptor) {\n      listener.exitFunctionDescriptor(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitFunctionDescriptor) {\n      return visitor.visitFunctionDescriptor(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar ReturnParametersContext = class extends import_ParserRuleContext.ParserRuleContext {\n  parameterList() {\n    return this.getRuleContext(0, ParameterListContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_returnParameters;\n  }\n  enterRule(listener) {\n    if (listener.enterReturnParameters) {\n      listener.enterReturnParameters(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitReturnParameters) {\n      listener.exitReturnParameters(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitReturnParameters) {\n      return visitor.visitReturnParameters(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar ModifierListContext = class extends import_ParserRuleContext.ParserRuleContext {\n  ExternalKeyword(i) {\n    if (i === void 0) {\n      return this.getTokens(SolidityParser.ExternalKeyword);\n    } else {\n      return this.getToken(SolidityParser.ExternalKeyword, i);\n    }\n  }\n  PublicKeyword(i) {\n    if (i === void 0) {\n      return this.getTokens(SolidityParser.PublicKeyword);\n    } else {\n      return this.getToken(SolidityParser.PublicKeyword, i);\n    }\n  }\n  InternalKeyword(i) {\n    if (i === void 0) {\n      return this.getTokens(SolidityParser.InternalKeyword);\n    } else {\n      return this.getToken(SolidityParser.InternalKeyword, i);\n    }\n  }\n  PrivateKeyword(i) {\n    if (i === void 0) {\n      return this.getTokens(SolidityParser.PrivateKeyword);\n    } else {\n      return this.getToken(SolidityParser.PrivateKeyword, i);\n    }\n  }\n  VirtualKeyword(i) {\n    if (i === void 0) {\n      return this.getTokens(SolidityParser.VirtualKeyword);\n    } else {\n      return this.getToken(SolidityParser.VirtualKeyword, i);\n    }\n  }\n  stateMutability(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(StateMutabilityContext);\n    } else {\n      return this.getRuleContext(i, StateMutabilityContext);\n    }\n  }\n  modifierInvocation(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(ModifierInvocationContext);\n    } else {\n      return this.getRuleContext(i, ModifierInvocationContext);\n    }\n  }\n  overrideSpecifier(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(OverrideSpecifierContext);\n    } else {\n      return this.getRuleContext(i, OverrideSpecifierContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_modifierList;\n  }\n  enterRule(listener) {\n    if (listener.enterModifierList) {\n      listener.enterModifierList(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitModifierList) {\n      listener.exitModifierList(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitModifierList) {\n      return visitor.visitModifierList(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar EventDefinitionContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifier() {\n    return this.getRuleContext(0, IdentifierContext);\n  }\n  eventParameterList() {\n    return this.getRuleContext(0, EventParameterListContext);\n  }\n  AnonymousKeyword() {\n    return this.tryGetToken(SolidityParser.AnonymousKeyword, 0);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_eventDefinition;\n  }\n  enterRule(listener) {\n    if (listener.enterEventDefinition) {\n      listener.enterEventDefinition(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitEventDefinition) {\n      listener.exitEventDefinition(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitEventDefinition) {\n      return visitor.visitEventDefinition(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar EnumValueContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifier() {\n    return this.getRuleContext(0, IdentifierContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_enumValue;\n  }\n  enterRule(listener) {\n    if (listener.enterEnumValue) {\n      listener.enterEnumValue(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitEnumValue) {\n      listener.exitEnumValue(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitEnumValue) {\n      return visitor.visitEnumValue(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar EnumDefinitionContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifier() {\n    return this.getRuleContext(0, IdentifierContext);\n  }\n  enumValue(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(EnumValueContext);\n    } else {\n      return this.getRuleContext(i, EnumValueContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_enumDefinition;\n  }\n  enterRule(listener) {\n    if (listener.enterEnumDefinition) {\n      listener.enterEnumDefinition(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitEnumDefinition) {\n      listener.exitEnumDefinition(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitEnumDefinition) {\n      return visitor.visitEnumDefinition(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar ParameterListContext = class extends import_ParserRuleContext.ParserRuleContext {\n  parameter(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(ParameterContext);\n    } else {\n      return this.getRuleContext(i, ParameterContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_parameterList;\n  }\n  enterRule(listener) {\n    if (listener.enterParameterList) {\n      listener.enterParameterList(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitParameterList) {\n      listener.exitParameterList(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitParameterList) {\n      return visitor.visitParameterList(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar ParameterContext = class extends import_ParserRuleContext.ParserRuleContext {\n  typeName() {\n    return this.getRuleContext(0, TypeNameContext);\n  }\n  storageLocation() {\n    return this.tryGetRuleContext(0, StorageLocationContext);\n  }\n  identifier() {\n    return this.tryGetRuleContext(0, IdentifierContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_parameter;\n  }\n  enterRule(listener) {\n    if (listener.enterParameter) {\n      listener.enterParameter(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitParameter) {\n      listener.exitParameter(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitParameter) {\n      return visitor.visitParameter(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar EventParameterListContext = class extends import_ParserRuleContext.ParserRuleContext {\n  eventParameter(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(EventParameterContext);\n    } else {\n      return this.getRuleContext(i, EventParameterContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_eventParameterList;\n  }\n  enterRule(listener) {\n    if (listener.enterEventParameterList) {\n      listener.enterEventParameterList(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitEventParameterList) {\n      listener.exitEventParameterList(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitEventParameterList) {\n      return visitor.visitEventParameterList(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar EventParameterContext = class extends import_ParserRuleContext.ParserRuleContext {\n  typeName() {\n    return this.getRuleContext(0, TypeNameContext);\n  }\n  IndexedKeyword() {\n    return this.tryGetToken(SolidityParser.IndexedKeyword, 0);\n  }\n  identifier() {\n    return this.tryGetRuleContext(0, IdentifierContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_eventParameter;\n  }\n  enterRule(listener) {\n    if (listener.enterEventParameter) {\n      listener.enterEventParameter(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitEventParameter) {\n      listener.exitEventParameter(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitEventParameter) {\n      return visitor.visitEventParameter(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar FunctionTypeParameterListContext = class extends import_ParserRuleContext.ParserRuleContext {\n  functionTypeParameter(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(FunctionTypeParameterContext);\n    } else {\n      return this.getRuleContext(i, FunctionTypeParameterContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_functionTypeParameterList;\n  }\n  enterRule(listener) {\n    if (listener.enterFunctionTypeParameterList) {\n      listener.enterFunctionTypeParameterList(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitFunctionTypeParameterList) {\n      listener.exitFunctionTypeParameterList(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitFunctionTypeParameterList) {\n      return visitor.visitFunctionTypeParameterList(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar FunctionTypeParameterContext = class extends import_ParserRuleContext.ParserRuleContext {\n  typeName() {\n    return this.getRuleContext(0, TypeNameContext);\n  }\n  storageLocation() {\n    return this.tryGetRuleContext(0, StorageLocationContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_functionTypeParameter;\n  }\n  enterRule(listener) {\n    if (listener.enterFunctionTypeParameter) {\n      listener.enterFunctionTypeParameter(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitFunctionTypeParameter) {\n      listener.exitFunctionTypeParameter(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitFunctionTypeParameter) {\n      return visitor.visitFunctionTypeParameter(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar VariableDeclarationContext = class extends import_ParserRuleContext.ParserRuleContext {\n  typeName() {\n    return this.getRuleContext(0, TypeNameContext);\n  }\n  identifier() {\n    return this.getRuleContext(0, IdentifierContext);\n  }\n  storageLocation() {\n    return this.tryGetRuleContext(0, StorageLocationContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_variableDeclaration;\n  }\n  enterRule(listener) {\n    if (listener.enterVariableDeclaration) {\n      listener.enterVariableDeclaration(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitVariableDeclaration) {\n      listener.exitVariableDeclaration(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitVariableDeclaration) {\n      return visitor.visitVariableDeclaration(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar TypeNameContext = class extends import_ParserRuleContext.ParserRuleContext {\n  elementaryTypeName() {\n    return this.tryGetRuleContext(0, ElementaryTypeNameContext);\n  }\n  userDefinedTypeName() {\n    return this.tryGetRuleContext(0, UserDefinedTypeNameContext);\n  }\n  mapping() {\n    return this.tryGetRuleContext(0, MappingContext);\n  }\n  typeName() {\n    return this.tryGetRuleContext(0, TypeNameContext);\n  }\n  expression() {\n    return this.tryGetRuleContext(0, ExpressionContext);\n  }\n  functionTypeName() {\n    return this.tryGetRuleContext(0, FunctionTypeNameContext);\n  }\n  PayableKeyword() {\n    return this.tryGetToken(SolidityParser.PayableKeyword, 0);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_typeName;\n  }\n  enterRule(listener) {\n    if (listener.enterTypeName) {\n      listener.enterTypeName(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitTypeName) {\n      listener.exitTypeName(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitTypeName) {\n      return visitor.visitTypeName(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar UserDefinedTypeNameContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifier(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(IdentifierContext);\n    } else {\n      return this.getRuleContext(i, IdentifierContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_userDefinedTypeName;\n  }\n  enterRule(listener) {\n    if (listener.enterUserDefinedTypeName) {\n      listener.enterUserDefinedTypeName(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitUserDefinedTypeName) {\n      listener.exitUserDefinedTypeName(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitUserDefinedTypeName) {\n      return visitor.visitUserDefinedTypeName(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar MappingKeyContext = class extends import_ParserRuleContext.ParserRuleContext {\n  elementaryTypeName() {\n    return this.tryGetRuleContext(0, ElementaryTypeNameContext);\n  }\n  userDefinedTypeName() {\n    return this.tryGetRuleContext(0, UserDefinedTypeNameContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_mappingKey;\n  }\n  enterRule(listener) {\n    if (listener.enterMappingKey) {\n      listener.enterMappingKey(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitMappingKey) {\n      listener.exitMappingKey(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitMappingKey) {\n      return visitor.visitMappingKey(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar MappingContext = class extends import_ParserRuleContext.ParserRuleContext {\n  mappingKey() {\n    return this.getRuleContext(0, MappingKeyContext);\n  }\n  typeName() {\n    return this.getRuleContext(0, TypeNameContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_mapping;\n  }\n  enterRule(listener) {\n    if (listener.enterMapping) {\n      listener.enterMapping(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitMapping) {\n      listener.exitMapping(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitMapping) {\n      return visitor.visitMapping(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar FunctionTypeNameContext = class extends import_ParserRuleContext.ParserRuleContext {\n  functionTypeParameterList(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(FunctionTypeParameterListContext);\n    } else {\n      return this.getRuleContext(i, FunctionTypeParameterListContext);\n    }\n  }\n  InternalKeyword(i) {\n    if (i === void 0) {\n      return this.getTokens(SolidityParser.InternalKeyword);\n    } else {\n      return this.getToken(SolidityParser.InternalKeyword, i);\n    }\n  }\n  ExternalKeyword(i) {\n    if (i === void 0) {\n      return this.getTokens(SolidityParser.ExternalKeyword);\n    } else {\n      return this.getToken(SolidityParser.ExternalKeyword, i);\n    }\n  }\n  stateMutability(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(StateMutabilityContext);\n    } else {\n      return this.getRuleContext(i, StateMutabilityContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_functionTypeName;\n  }\n  enterRule(listener) {\n    if (listener.enterFunctionTypeName) {\n      listener.enterFunctionTypeName(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitFunctionTypeName) {\n      listener.exitFunctionTypeName(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitFunctionTypeName) {\n      return visitor.visitFunctionTypeName(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar StorageLocationContext = class extends import_ParserRuleContext.ParserRuleContext {\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_storageLocation;\n  }\n  enterRule(listener) {\n    if (listener.enterStorageLocation) {\n      listener.enterStorageLocation(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitStorageLocation) {\n      listener.exitStorageLocation(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitStorageLocation) {\n      return visitor.visitStorageLocation(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar StateMutabilityContext = class extends import_ParserRuleContext.ParserRuleContext {\n  PureKeyword() {\n    return this.tryGetToken(SolidityParser.PureKeyword, 0);\n  }\n  ConstantKeyword() {\n    return this.tryGetToken(SolidityParser.ConstantKeyword, 0);\n  }\n  ViewKeyword() {\n    return this.tryGetToken(SolidityParser.ViewKeyword, 0);\n  }\n  PayableKeyword() {\n    return this.tryGetToken(SolidityParser.PayableKeyword, 0);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_stateMutability;\n  }\n  enterRule(listener) {\n    if (listener.enterStateMutability) {\n      listener.enterStateMutability(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitStateMutability) {\n      listener.exitStateMutability(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitStateMutability) {\n      return visitor.visitStateMutability(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar BlockContext = class extends import_ParserRuleContext.ParserRuleContext {\n  statement(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(StatementContext);\n    } else {\n      return this.getRuleContext(i, StatementContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_block;\n  }\n  enterRule(listener) {\n    if (listener.enterBlock) {\n      listener.enterBlock(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitBlock) {\n      listener.exitBlock(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitBlock) {\n      return visitor.visitBlock(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar StatementContext = class extends import_ParserRuleContext.ParserRuleContext {\n  ifStatement() {\n    return this.tryGetRuleContext(0, IfStatementContext);\n  }\n  tryStatement() {\n    return this.tryGetRuleContext(0, TryStatementContext);\n  }\n  whileStatement() {\n    return this.tryGetRuleContext(0, WhileStatementContext);\n  }\n  forStatement() {\n    return this.tryGetRuleContext(0, ForStatementContext);\n  }\n  block() {\n    return this.tryGetRuleContext(0, BlockContext);\n  }\n  inlineAssemblyStatement() {\n    return this.tryGetRuleContext(0, InlineAssemblyStatementContext);\n  }\n  doWhileStatement() {\n    return this.tryGetRuleContext(0, DoWhileStatementContext);\n  }\n  continueStatement() {\n    return this.tryGetRuleContext(0, ContinueStatementContext);\n  }\n  breakStatement() {\n    return this.tryGetRuleContext(0, BreakStatementContext);\n  }\n  returnStatement() {\n    return this.tryGetRuleContext(0, ReturnStatementContext);\n  }\n  throwStatement() {\n    return this.tryGetRuleContext(0, ThrowStatementContext);\n  }\n  emitStatement() {\n    return this.tryGetRuleContext(0, EmitStatementContext);\n  }\n  simpleStatement() {\n    return this.tryGetRuleContext(0, SimpleStatementContext);\n  }\n  uncheckedStatement() {\n    return this.tryGetRuleContext(0, UncheckedStatementContext);\n  }\n  revertStatement() {\n    return this.tryGetRuleContext(0, RevertStatementContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_statement;\n  }\n  enterRule(listener) {\n    if (listener.enterStatement) {\n      listener.enterStatement(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitStatement) {\n      listener.exitStatement(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitStatement) {\n      return visitor.visitStatement(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar ExpressionStatementContext = class extends import_ParserRuleContext.ParserRuleContext {\n  expression() {\n    return this.getRuleContext(0, ExpressionContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_expressionStatement;\n  }\n  enterRule(listener) {\n    if (listener.enterExpressionStatement) {\n      listener.enterExpressionStatement(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitExpressionStatement) {\n      listener.exitExpressionStatement(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitExpressionStatement) {\n      return visitor.visitExpressionStatement(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar IfStatementContext = class extends import_ParserRuleContext.ParserRuleContext {\n  expression() {\n    return this.getRuleContext(0, ExpressionContext);\n  }\n  statement(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(StatementContext);\n    } else {\n      return this.getRuleContext(i, StatementContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_ifStatement;\n  }\n  enterRule(listener) {\n    if (listener.enterIfStatement) {\n      listener.enterIfStatement(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitIfStatement) {\n      listener.exitIfStatement(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitIfStatement) {\n      return visitor.visitIfStatement(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar TryStatementContext = class extends import_ParserRuleContext.ParserRuleContext {\n  expression() {\n    return this.getRuleContext(0, ExpressionContext);\n  }\n  block() {\n    return this.getRuleContext(0, BlockContext);\n  }\n  returnParameters() {\n    return this.tryGetRuleContext(0, ReturnParametersContext);\n  }\n  catchClause(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(CatchClauseContext);\n    } else {\n      return this.getRuleContext(i, CatchClauseContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_tryStatement;\n  }\n  enterRule(listener) {\n    if (listener.enterTryStatement) {\n      listener.enterTryStatement(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitTryStatement) {\n      listener.exitTryStatement(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitTryStatement) {\n      return visitor.visitTryStatement(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar CatchClauseContext = class extends import_ParserRuleContext.ParserRuleContext {\n  block() {\n    return this.getRuleContext(0, BlockContext);\n  }\n  parameterList() {\n    return this.tryGetRuleContext(0, ParameterListContext);\n  }\n  identifier() {\n    return this.tryGetRuleContext(0, IdentifierContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_catchClause;\n  }\n  enterRule(listener) {\n    if (listener.enterCatchClause) {\n      listener.enterCatchClause(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitCatchClause) {\n      listener.exitCatchClause(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitCatchClause) {\n      return visitor.visitCatchClause(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar WhileStatementContext = class extends import_ParserRuleContext.ParserRuleContext {\n  expression() {\n    return this.getRuleContext(0, ExpressionContext);\n  }\n  statement() {\n    return this.getRuleContext(0, StatementContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_whileStatement;\n  }\n  enterRule(listener) {\n    if (listener.enterWhileStatement) {\n      listener.enterWhileStatement(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitWhileStatement) {\n      listener.exitWhileStatement(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitWhileStatement) {\n      return visitor.visitWhileStatement(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar SimpleStatementContext = class extends import_ParserRuleContext.ParserRuleContext {\n  variableDeclarationStatement() {\n    return this.tryGetRuleContext(0, VariableDeclarationStatementContext);\n  }\n  expressionStatement() {\n    return this.tryGetRuleContext(0, ExpressionStatementContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_simpleStatement;\n  }\n  enterRule(listener) {\n    if (listener.enterSimpleStatement) {\n      listener.enterSimpleStatement(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitSimpleStatement) {\n      listener.exitSimpleStatement(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitSimpleStatement) {\n      return visitor.visitSimpleStatement(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar UncheckedStatementContext = class extends import_ParserRuleContext.ParserRuleContext {\n  block() {\n    return this.getRuleContext(0, BlockContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_uncheckedStatement;\n  }\n  enterRule(listener) {\n    if (listener.enterUncheckedStatement) {\n      listener.enterUncheckedStatement(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitUncheckedStatement) {\n      listener.exitUncheckedStatement(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitUncheckedStatement) {\n      return visitor.visitUncheckedStatement(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar ForStatementContext = class extends import_ParserRuleContext.ParserRuleContext {\n  statement() {\n    return this.getRuleContext(0, StatementContext);\n  }\n  simpleStatement() {\n    return this.tryGetRuleContext(0, SimpleStatementContext);\n  }\n  expressionStatement() {\n    return this.tryGetRuleContext(0, ExpressionStatementContext);\n  }\n  expression() {\n    return this.tryGetRuleContext(0, ExpressionContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_forStatement;\n  }\n  enterRule(listener) {\n    if (listener.enterForStatement) {\n      listener.enterForStatement(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitForStatement) {\n      listener.exitForStatement(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitForStatement) {\n      return visitor.visitForStatement(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar InlineAssemblyStatementContext = class extends import_ParserRuleContext.ParserRuleContext {\n  assemblyBlock() {\n    return this.getRuleContext(0, AssemblyBlockContext);\n  }\n  StringLiteralFragment() {\n    return this.tryGetToken(SolidityParser.StringLiteralFragment, 0);\n  }\n  inlineAssemblyStatementFlag() {\n    return this.tryGetRuleContext(0, InlineAssemblyStatementFlagContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_inlineAssemblyStatement;\n  }\n  enterRule(listener) {\n    if (listener.enterInlineAssemblyStatement) {\n      listener.enterInlineAssemblyStatement(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitInlineAssemblyStatement) {\n      listener.exitInlineAssemblyStatement(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitInlineAssemblyStatement) {\n      return visitor.visitInlineAssemblyStatement(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar InlineAssemblyStatementFlagContext = class extends import_ParserRuleContext.ParserRuleContext {\n  stringLiteral() {\n    return this.getRuleContext(0, StringLiteralContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_inlineAssemblyStatementFlag;\n  }\n  enterRule(listener) {\n    if (listener.enterInlineAssemblyStatementFlag) {\n      listener.enterInlineAssemblyStatementFlag(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitInlineAssemblyStatementFlag) {\n      listener.exitInlineAssemblyStatementFlag(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitInlineAssemblyStatementFlag) {\n      return visitor.visitInlineAssemblyStatementFlag(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar DoWhileStatementContext = class extends import_ParserRuleContext.ParserRuleContext {\n  statement() {\n    return this.getRuleContext(0, StatementContext);\n  }\n  expression() {\n    return this.getRuleContext(0, ExpressionContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_doWhileStatement;\n  }\n  enterRule(listener) {\n    if (listener.enterDoWhileStatement) {\n      listener.enterDoWhileStatement(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitDoWhileStatement) {\n      listener.exitDoWhileStatement(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitDoWhileStatement) {\n      return visitor.visitDoWhileStatement(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar ContinueStatementContext = class extends import_ParserRuleContext.ParserRuleContext {\n  ContinueKeyword() {\n    return this.getToken(SolidityParser.ContinueKeyword, 0);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_continueStatement;\n  }\n  enterRule(listener) {\n    if (listener.enterContinueStatement) {\n      listener.enterContinueStatement(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitContinueStatement) {\n      listener.exitContinueStatement(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitContinueStatement) {\n      return visitor.visitContinueStatement(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar BreakStatementContext = class extends import_ParserRuleContext.ParserRuleContext {\n  BreakKeyword() {\n    return this.getToken(SolidityParser.BreakKeyword, 0);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_breakStatement;\n  }\n  enterRule(listener) {\n    if (listener.enterBreakStatement) {\n      listener.enterBreakStatement(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitBreakStatement) {\n      listener.exitBreakStatement(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitBreakStatement) {\n      return visitor.visitBreakStatement(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar ReturnStatementContext = class extends import_ParserRuleContext.ParserRuleContext {\n  expression() {\n    return this.tryGetRuleContext(0, ExpressionContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_returnStatement;\n  }\n  enterRule(listener) {\n    if (listener.enterReturnStatement) {\n      listener.enterReturnStatement(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitReturnStatement) {\n      listener.exitReturnStatement(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitReturnStatement) {\n      return visitor.visitReturnStatement(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar ThrowStatementContext = class extends import_ParserRuleContext.ParserRuleContext {\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_throwStatement;\n  }\n  enterRule(listener) {\n    if (listener.enterThrowStatement) {\n      listener.enterThrowStatement(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitThrowStatement) {\n      listener.exitThrowStatement(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitThrowStatement) {\n      return visitor.visitThrowStatement(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar EmitStatementContext = class extends import_ParserRuleContext.ParserRuleContext {\n  functionCall() {\n    return this.getRuleContext(0, FunctionCallContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_emitStatement;\n  }\n  enterRule(listener) {\n    if (listener.enterEmitStatement) {\n      listener.enterEmitStatement(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitEmitStatement) {\n      listener.exitEmitStatement(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitEmitStatement) {\n      return visitor.visitEmitStatement(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar RevertStatementContext = class extends import_ParserRuleContext.ParserRuleContext {\n  functionCall() {\n    return this.getRuleContext(0, FunctionCallContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_revertStatement;\n  }\n  enterRule(listener) {\n    if (listener.enterRevertStatement) {\n      listener.enterRevertStatement(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitRevertStatement) {\n      listener.exitRevertStatement(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitRevertStatement) {\n      return visitor.visitRevertStatement(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar VariableDeclarationStatementContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifierList() {\n    return this.tryGetRuleContext(0, IdentifierListContext);\n  }\n  variableDeclaration() {\n    return this.tryGetRuleContext(0, VariableDeclarationContext);\n  }\n  variableDeclarationList() {\n    return this.tryGetRuleContext(0, VariableDeclarationListContext);\n  }\n  expression() {\n    return this.tryGetRuleContext(0, ExpressionContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_variableDeclarationStatement;\n  }\n  enterRule(listener) {\n    if (listener.enterVariableDeclarationStatement) {\n      listener.enterVariableDeclarationStatement(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitVariableDeclarationStatement) {\n      listener.exitVariableDeclarationStatement(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitVariableDeclarationStatement) {\n      return visitor.visitVariableDeclarationStatement(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar VariableDeclarationListContext = class extends import_ParserRuleContext.ParserRuleContext {\n  variableDeclaration(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(VariableDeclarationContext);\n    } else {\n      return this.getRuleContext(i, VariableDeclarationContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_variableDeclarationList;\n  }\n  enterRule(listener) {\n    if (listener.enterVariableDeclarationList) {\n      listener.enterVariableDeclarationList(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitVariableDeclarationList) {\n      listener.exitVariableDeclarationList(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitVariableDeclarationList) {\n      return visitor.visitVariableDeclarationList(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar IdentifierListContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifier(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(IdentifierContext);\n    } else {\n      return this.getRuleContext(i, IdentifierContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_identifierList;\n  }\n  enterRule(listener) {\n    if (listener.enterIdentifierList) {\n      listener.enterIdentifierList(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitIdentifierList) {\n      listener.exitIdentifierList(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitIdentifierList) {\n      return visitor.visitIdentifierList(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar ElementaryTypeNameContext = class extends import_ParserRuleContext.ParserRuleContext {\n  Int() {\n    return this.tryGetToken(SolidityParser.Int, 0);\n  }\n  Uint() {\n    return this.tryGetToken(SolidityParser.Uint, 0);\n  }\n  Byte() {\n    return this.tryGetToken(SolidityParser.Byte, 0);\n  }\n  Fixed() {\n    return this.tryGetToken(SolidityParser.Fixed, 0);\n  }\n  Ufixed() {\n    return this.tryGetToken(SolidityParser.Ufixed, 0);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_elementaryTypeName;\n  }\n  enterRule(listener) {\n    if (listener.enterElementaryTypeName) {\n      listener.enterElementaryTypeName(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitElementaryTypeName) {\n      listener.exitElementaryTypeName(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitElementaryTypeName) {\n      return visitor.visitElementaryTypeName(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar ExpressionContext = class extends import_ParserRuleContext.ParserRuleContext {\n  expression(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(ExpressionContext);\n    } else {\n      return this.getRuleContext(i, ExpressionContext);\n    }\n  }\n  typeName() {\n    return this.tryGetRuleContext(0, TypeNameContext);\n  }\n  identifier() {\n    return this.tryGetRuleContext(0, IdentifierContext);\n  }\n  nameValueList() {\n    return this.tryGetRuleContext(0, NameValueListContext);\n  }\n  functionCallArguments() {\n    return this.tryGetRuleContext(0, FunctionCallArgumentsContext);\n  }\n  primaryExpression() {\n    return this.tryGetRuleContext(0, PrimaryExpressionContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_expression;\n  }\n  enterRule(listener) {\n    if (listener.enterExpression) {\n      listener.enterExpression(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitExpression) {\n      listener.exitExpression(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitExpression) {\n      return visitor.visitExpression(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar PrimaryExpressionContext = class extends import_ParserRuleContext.ParserRuleContext {\n  BooleanLiteral() {\n    return this.tryGetToken(SolidityParser.BooleanLiteral, 0);\n  }\n  numberLiteral() {\n    return this.tryGetRuleContext(0, NumberLiteralContext);\n  }\n  hexLiteral() {\n    return this.tryGetRuleContext(0, HexLiteralContext);\n  }\n  stringLiteral() {\n    return this.tryGetRuleContext(0, StringLiteralContext);\n  }\n  identifier() {\n    return this.tryGetRuleContext(0, IdentifierContext);\n  }\n  TypeKeyword() {\n    return this.tryGetToken(SolidityParser.TypeKeyword, 0);\n  }\n  PayableKeyword() {\n    return this.tryGetToken(SolidityParser.PayableKeyword, 0);\n  }\n  tupleExpression() {\n    return this.tryGetRuleContext(0, TupleExpressionContext);\n  }\n  typeName() {\n    return this.tryGetRuleContext(0, TypeNameContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_primaryExpression;\n  }\n  enterRule(listener) {\n    if (listener.enterPrimaryExpression) {\n      listener.enterPrimaryExpression(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitPrimaryExpression) {\n      listener.exitPrimaryExpression(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitPrimaryExpression) {\n      return visitor.visitPrimaryExpression(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar ExpressionListContext = class extends import_ParserRuleContext.ParserRuleContext {\n  expression(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(ExpressionContext);\n    } else {\n      return this.getRuleContext(i, ExpressionContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_expressionList;\n  }\n  enterRule(listener) {\n    if (listener.enterExpressionList) {\n      listener.enterExpressionList(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitExpressionList) {\n      listener.exitExpressionList(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitExpressionList) {\n      return visitor.visitExpressionList(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar NameValueListContext = class extends import_ParserRuleContext.ParserRuleContext {\n  nameValue(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(NameValueContext);\n    } else {\n      return this.getRuleContext(i, NameValueContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_nameValueList;\n  }\n  enterRule(listener) {\n    if (listener.enterNameValueList) {\n      listener.enterNameValueList(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitNameValueList) {\n      listener.exitNameValueList(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitNameValueList) {\n      return visitor.visitNameValueList(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar NameValueContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifier() {\n    return this.getRuleContext(0, IdentifierContext);\n  }\n  expression() {\n    return this.getRuleContext(0, ExpressionContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_nameValue;\n  }\n  enterRule(listener) {\n    if (listener.enterNameValue) {\n      listener.enterNameValue(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitNameValue) {\n      listener.exitNameValue(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitNameValue) {\n      return visitor.visitNameValue(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar FunctionCallArgumentsContext = class extends import_ParserRuleContext.ParserRuleContext {\n  nameValueList() {\n    return this.tryGetRuleContext(0, NameValueListContext);\n  }\n  expressionList() {\n    return this.tryGetRuleContext(0, ExpressionListContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_functionCallArguments;\n  }\n  enterRule(listener) {\n    if (listener.enterFunctionCallArguments) {\n      listener.enterFunctionCallArguments(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitFunctionCallArguments) {\n      listener.exitFunctionCallArguments(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitFunctionCallArguments) {\n      return visitor.visitFunctionCallArguments(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar FunctionCallContext = class extends import_ParserRuleContext.ParserRuleContext {\n  expression() {\n    return this.getRuleContext(0, ExpressionContext);\n  }\n  functionCallArguments() {\n    return this.getRuleContext(0, FunctionCallArgumentsContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_functionCall;\n  }\n  enterRule(listener) {\n    if (listener.enterFunctionCall) {\n      listener.enterFunctionCall(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitFunctionCall) {\n      listener.exitFunctionCall(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitFunctionCall) {\n      return visitor.visitFunctionCall(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar AssemblyBlockContext = class extends import_ParserRuleContext.ParserRuleContext {\n  assemblyItem(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(AssemblyItemContext);\n    } else {\n      return this.getRuleContext(i, AssemblyItemContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_assemblyBlock;\n  }\n  enterRule(listener) {\n    if (listener.enterAssemblyBlock) {\n      listener.enterAssemblyBlock(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitAssemblyBlock) {\n      listener.exitAssemblyBlock(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitAssemblyBlock) {\n      return visitor.visitAssemblyBlock(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar AssemblyItemContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifier() {\n    return this.tryGetRuleContext(0, IdentifierContext);\n  }\n  assemblyBlock() {\n    return this.tryGetRuleContext(0, AssemblyBlockContext);\n  }\n  assemblyExpression() {\n    return this.tryGetRuleContext(0, AssemblyExpressionContext);\n  }\n  assemblyLocalDefinition() {\n    return this.tryGetRuleContext(0, AssemblyLocalDefinitionContext);\n  }\n  assemblyAssignment() {\n    return this.tryGetRuleContext(0, AssemblyAssignmentContext);\n  }\n  assemblyStackAssignment() {\n    return this.tryGetRuleContext(0, AssemblyStackAssignmentContext);\n  }\n  labelDefinition() {\n    return this.tryGetRuleContext(0, LabelDefinitionContext);\n  }\n  assemblySwitch() {\n    return this.tryGetRuleContext(0, AssemblySwitchContext);\n  }\n  assemblyFunctionDefinition() {\n    return this.tryGetRuleContext(0, AssemblyFunctionDefinitionContext);\n  }\n  assemblyFor() {\n    return this.tryGetRuleContext(0, AssemblyForContext);\n  }\n  assemblyIf() {\n    return this.tryGetRuleContext(0, AssemblyIfContext);\n  }\n  BreakKeyword() {\n    return this.tryGetToken(SolidityParser.BreakKeyword, 0);\n  }\n  ContinueKeyword() {\n    return this.tryGetToken(SolidityParser.ContinueKeyword, 0);\n  }\n  LeaveKeyword() {\n    return this.tryGetToken(SolidityParser.LeaveKeyword, 0);\n  }\n  subAssembly() {\n    return this.tryGetRuleContext(0, SubAssemblyContext);\n  }\n  numberLiteral() {\n    return this.tryGetRuleContext(0, NumberLiteralContext);\n  }\n  stringLiteral() {\n    return this.tryGetRuleContext(0, StringLiteralContext);\n  }\n  hexLiteral() {\n    return this.tryGetRuleContext(0, HexLiteralContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_assemblyItem;\n  }\n  enterRule(listener) {\n    if (listener.enterAssemblyItem) {\n      listener.enterAssemblyItem(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitAssemblyItem) {\n      listener.exitAssemblyItem(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitAssemblyItem) {\n      return visitor.visitAssemblyItem(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar AssemblyExpressionContext = class extends import_ParserRuleContext.ParserRuleContext {\n  assemblyCall() {\n    return this.tryGetRuleContext(0, AssemblyCallContext);\n  }\n  assemblyLiteral() {\n    return this.tryGetRuleContext(0, AssemblyLiteralContext);\n  }\n  assemblyMember() {\n    return this.tryGetRuleContext(0, AssemblyMemberContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_assemblyExpression;\n  }\n  enterRule(listener) {\n    if (listener.enterAssemblyExpression) {\n      listener.enterAssemblyExpression(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitAssemblyExpression) {\n      listener.exitAssemblyExpression(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitAssemblyExpression) {\n      return visitor.visitAssemblyExpression(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar AssemblyMemberContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifier(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(IdentifierContext);\n    } else {\n      return this.getRuleContext(i, IdentifierContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_assemblyMember;\n  }\n  enterRule(listener) {\n    if (listener.enterAssemblyMember) {\n      listener.enterAssemblyMember(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitAssemblyMember) {\n      listener.exitAssemblyMember(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitAssemblyMember) {\n      return visitor.visitAssemblyMember(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar AssemblyCallContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifier() {\n    return this.tryGetRuleContext(0, IdentifierContext);\n  }\n  assemblyExpression(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(AssemblyExpressionContext);\n    } else {\n      return this.getRuleContext(i, AssemblyExpressionContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_assemblyCall;\n  }\n  enterRule(listener) {\n    if (listener.enterAssemblyCall) {\n      listener.enterAssemblyCall(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitAssemblyCall) {\n      listener.exitAssemblyCall(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitAssemblyCall) {\n      return visitor.visitAssemblyCall(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar AssemblyLocalDefinitionContext = class extends import_ParserRuleContext.ParserRuleContext {\n  assemblyIdentifierOrList() {\n    return this.getRuleContext(0, AssemblyIdentifierOrListContext);\n  }\n  assemblyExpression() {\n    return this.tryGetRuleContext(0, AssemblyExpressionContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_assemblyLocalDefinition;\n  }\n  enterRule(listener) {\n    if (listener.enterAssemblyLocalDefinition) {\n      listener.enterAssemblyLocalDefinition(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitAssemblyLocalDefinition) {\n      listener.exitAssemblyLocalDefinition(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitAssemblyLocalDefinition) {\n      return visitor.visitAssemblyLocalDefinition(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar AssemblyAssignmentContext = class extends import_ParserRuleContext.ParserRuleContext {\n  assemblyIdentifierOrList() {\n    return this.getRuleContext(0, AssemblyIdentifierOrListContext);\n  }\n  assemblyExpression() {\n    return this.getRuleContext(0, AssemblyExpressionContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_assemblyAssignment;\n  }\n  enterRule(listener) {\n    if (listener.enterAssemblyAssignment) {\n      listener.enterAssemblyAssignment(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitAssemblyAssignment) {\n      listener.exitAssemblyAssignment(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitAssemblyAssignment) {\n      return visitor.visitAssemblyAssignment(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar AssemblyIdentifierOrListContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifier() {\n    return this.tryGetRuleContext(0, IdentifierContext);\n  }\n  assemblyMember() {\n    return this.tryGetRuleContext(0, AssemblyMemberContext);\n  }\n  assemblyIdentifierList() {\n    return this.tryGetRuleContext(0, AssemblyIdentifierListContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_assemblyIdentifierOrList;\n  }\n  enterRule(listener) {\n    if (listener.enterAssemblyIdentifierOrList) {\n      listener.enterAssemblyIdentifierOrList(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitAssemblyIdentifierOrList) {\n      listener.exitAssemblyIdentifierOrList(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitAssemblyIdentifierOrList) {\n      return visitor.visitAssemblyIdentifierOrList(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar AssemblyIdentifierListContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifier(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(IdentifierContext);\n    } else {\n      return this.getRuleContext(i, IdentifierContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_assemblyIdentifierList;\n  }\n  enterRule(listener) {\n    if (listener.enterAssemblyIdentifierList) {\n      listener.enterAssemblyIdentifierList(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitAssemblyIdentifierList) {\n      listener.exitAssemblyIdentifierList(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitAssemblyIdentifierList) {\n      return visitor.visitAssemblyIdentifierList(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar AssemblyStackAssignmentContext = class extends import_ParserRuleContext.ParserRuleContext {\n  assemblyExpression() {\n    return this.getRuleContext(0, AssemblyExpressionContext);\n  }\n  identifier() {\n    return this.getRuleContext(0, IdentifierContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_assemblyStackAssignment;\n  }\n  enterRule(listener) {\n    if (listener.enterAssemblyStackAssignment) {\n      listener.enterAssemblyStackAssignment(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitAssemblyStackAssignment) {\n      listener.exitAssemblyStackAssignment(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitAssemblyStackAssignment) {\n      return visitor.visitAssemblyStackAssignment(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar LabelDefinitionContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifier() {\n    return this.getRuleContext(0, IdentifierContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_labelDefinition;\n  }\n  enterRule(listener) {\n    if (listener.enterLabelDefinition) {\n      listener.enterLabelDefinition(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitLabelDefinition) {\n      listener.exitLabelDefinition(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitLabelDefinition) {\n      return visitor.visitLabelDefinition(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar AssemblySwitchContext = class extends import_ParserRuleContext.ParserRuleContext {\n  assemblyExpression() {\n    return this.getRuleContext(0, AssemblyExpressionContext);\n  }\n  assemblyCase(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(AssemblyCaseContext);\n    } else {\n      return this.getRuleContext(i, AssemblyCaseContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_assemblySwitch;\n  }\n  enterRule(listener) {\n    if (listener.enterAssemblySwitch) {\n      listener.enterAssemblySwitch(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitAssemblySwitch) {\n      listener.exitAssemblySwitch(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitAssemblySwitch) {\n      return visitor.visitAssemblySwitch(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar AssemblyCaseContext = class extends import_ParserRuleContext.ParserRuleContext {\n  assemblyLiteral() {\n    return this.tryGetRuleContext(0, AssemblyLiteralContext);\n  }\n  assemblyBlock() {\n    return this.getRuleContext(0, AssemblyBlockContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_assemblyCase;\n  }\n  enterRule(listener) {\n    if (listener.enterAssemblyCase) {\n      listener.enterAssemblyCase(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitAssemblyCase) {\n      listener.exitAssemblyCase(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitAssemblyCase) {\n      return visitor.visitAssemblyCase(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar AssemblyFunctionDefinitionContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifier() {\n    return this.getRuleContext(0, IdentifierContext);\n  }\n  assemblyBlock() {\n    return this.getRuleContext(0, AssemblyBlockContext);\n  }\n  assemblyIdentifierList() {\n    return this.tryGetRuleContext(0, AssemblyIdentifierListContext);\n  }\n  assemblyFunctionReturns() {\n    return this.tryGetRuleContext(0, AssemblyFunctionReturnsContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_assemblyFunctionDefinition;\n  }\n  enterRule(listener) {\n    if (listener.enterAssemblyFunctionDefinition) {\n      listener.enterAssemblyFunctionDefinition(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitAssemblyFunctionDefinition) {\n      listener.exitAssemblyFunctionDefinition(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitAssemblyFunctionDefinition) {\n      return visitor.visitAssemblyFunctionDefinition(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar AssemblyFunctionReturnsContext = class extends import_ParserRuleContext.ParserRuleContext {\n  assemblyIdentifierList() {\n    return this.tryGetRuleContext(0, AssemblyIdentifierListContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_assemblyFunctionReturns;\n  }\n  enterRule(listener) {\n    if (listener.enterAssemblyFunctionReturns) {\n      listener.enterAssemblyFunctionReturns(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitAssemblyFunctionReturns) {\n      listener.exitAssemblyFunctionReturns(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitAssemblyFunctionReturns) {\n      return visitor.visitAssemblyFunctionReturns(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar AssemblyForContext = class extends import_ParserRuleContext.ParserRuleContext {\n  assemblyExpression(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(AssemblyExpressionContext);\n    } else {\n      return this.getRuleContext(i, AssemblyExpressionContext);\n    }\n  }\n  assemblyBlock(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(AssemblyBlockContext);\n    } else {\n      return this.getRuleContext(i, AssemblyBlockContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_assemblyFor;\n  }\n  enterRule(listener) {\n    if (listener.enterAssemblyFor) {\n      listener.enterAssemblyFor(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitAssemblyFor) {\n      listener.exitAssemblyFor(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitAssemblyFor) {\n      return visitor.visitAssemblyFor(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar AssemblyIfContext = class extends import_ParserRuleContext.ParserRuleContext {\n  assemblyExpression() {\n    return this.getRuleContext(0, AssemblyExpressionContext);\n  }\n  assemblyBlock() {\n    return this.getRuleContext(0, AssemblyBlockContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_assemblyIf;\n  }\n  enterRule(listener) {\n    if (listener.enterAssemblyIf) {\n      listener.enterAssemblyIf(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitAssemblyIf) {\n      listener.exitAssemblyIf(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitAssemblyIf) {\n      return visitor.visitAssemblyIf(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar AssemblyLiteralContext = class extends import_ParserRuleContext.ParserRuleContext {\n  stringLiteral() {\n    return this.tryGetRuleContext(0, StringLiteralContext);\n  }\n  DecimalNumber() {\n    return this.tryGetToken(SolidityParser.DecimalNumber, 0);\n  }\n  HexNumber() {\n    return this.tryGetToken(SolidityParser.HexNumber, 0);\n  }\n  hexLiteral() {\n    return this.tryGetRuleContext(0, HexLiteralContext);\n  }\n  BooleanLiteral() {\n    return this.tryGetToken(SolidityParser.BooleanLiteral, 0);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_assemblyLiteral;\n  }\n  enterRule(listener) {\n    if (listener.enterAssemblyLiteral) {\n      listener.enterAssemblyLiteral(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitAssemblyLiteral) {\n      listener.exitAssemblyLiteral(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitAssemblyLiteral) {\n      return visitor.visitAssemblyLiteral(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar SubAssemblyContext = class extends import_ParserRuleContext.ParserRuleContext {\n  identifier() {\n    return this.getRuleContext(0, IdentifierContext);\n  }\n  assemblyBlock() {\n    return this.getRuleContext(0, AssemblyBlockContext);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_subAssembly;\n  }\n  enterRule(listener) {\n    if (listener.enterSubAssembly) {\n      listener.enterSubAssembly(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitSubAssembly) {\n      listener.exitSubAssembly(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitSubAssembly) {\n      return visitor.visitSubAssembly(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar TupleExpressionContext = class extends import_ParserRuleContext.ParserRuleContext {\n  expression(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(ExpressionContext);\n    } else {\n      return this.getRuleContext(i, ExpressionContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_tupleExpression;\n  }\n  enterRule(listener) {\n    if (listener.enterTupleExpression) {\n      listener.enterTupleExpression(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitTupleExpression) {\n      listener.exitTupleExpression(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitTupleExpression) {\n      return visitor.visitTupleExpression(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar NumberLiteralContext = class extends import_ParserRuleContext.ParserRuleContext {\n  DecimalNumber() {\n    return this.tryGetToken(SolidityParser.DecimalNumber, 0);\n  }\n  HexNumber() {\n    return this.tryGetToken(SolidityParser.HexNumber, 0);\n  }\n  NumberUnit() {\n    return this.tryGetToken(SolidityParser.NumberUnit, 0);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_numberLiteral;\n  }\n  enterRule(listener) {\n    if (listener.enterNumberLiteral) {\n      listener.enterNumberLiteral(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitNumberLiteral) {\n      listener.exitNumberLiteral(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitNumberLiteral) {\n      return visitor.visitNumberLiteral(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar IdentifierContext = class extends import_ParserRuleContext.ParserRuleContext {\n  ReceiveKeyword() {\n    return this.tryGetToken(SolidityParser.ReceiveKeyword, 0);\n  }\n  ConstructorKeyword() {\n    return this.tryGetToken(SolidityParser.ConstructorKeyword, 0);\n  }\n  PayableKeyword() {\n    return this.tryGetToken(SolidityParser.PayableKeyword, 0);\n  }\n  LeaveKeyword() {\n    return this.tryGetToken(SolidityParser.LeaveKeyword, 0);\n  }\n  Identifier() {\n    return this.tryGetToken(SolidityParser.Identifier, 0);\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_identifier;\n  }\n  enterRule(listener) {\n    if (listener.enterIdentifier) {\n      listener.enterIdentifier(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitIdentifier) {\n      listener.exitIdentifier(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitIdentifier) {\n      return visitor.visitIdentifier(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar HexLiteralContext = class extends import_ParserRuleContext.ParserRuleContext {\n  HexLiteralFragment(i) {\n    if (i === void 0) {\n      return this.getTokens(SolidityParser.HexLiteralFragment);\n    } else {\n      return this.getToken(SolidityParser.HexLiteralFragment, i);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_hexLiteral;\n  }\n  enterRule(listener) {\n    if (listener.enterHexLiteral) {\n      listener.enterHexLiteral(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitHexLiteral) {\n      listener.exitHexLiteral(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitHexLiteral) {\n      return visitor.visitHexLiteral(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar OverrideSpecifierContext = class extends import_ParserRuleContext.ParserRuleContext {\n  userDefinedTypeName(i) {\n    if (i === void 0) {\n      return this.getRuleContexts(UserDefinedTypeNameContext);\n    } else {\n      return this.getRuleContext(i, UserDefinedTypeNameContext);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_overrideSpecifier;\n  }\n  enterRule(listener) {\n    if (listener.enterOverrideSpecifier) {\n      listener.enterOverrideSpecifier(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitOverrideSpecifier) {\n      listener.exitOverrideSpecifier(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitOverrideSpecifier) {\n      return visitor.visitOverrideSpecifier(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\nvar StringLiteralContext = class extends import_ParserRuleContext.ParserRuleContext {\n  StringLiteralFragment(i) {\n    if (i === void 0) {\n      return this.getTokens(SolidityParser.StringLiteralFragment);\n    } else {\n      return this.getToken(SolidityParser.StringLiteralFragment, i);\n    }\n  }\n  constructor(parent, invokingState) {\n    super(parent, invokingState);\n  }\n  get ruleIndex() {\n    return SolidityParser.RULE_stringLiteral;\n  }\n  enterRule(listener) {\n    if (listener.enterStringLiteral) {\n      listener.enterStringLiteral(this);\n    }\n  }\n  exitRule(listener) {\n    if (listener.exitStringLiteral) {\n      listener.exitStringLiteral(this);\n    }\n  }\n  accept(visitor) {\n    if (visitor.visitStringLiteral) {\n      return visitor.visitStringLiteral(this);\n    } else {\n      return visitor.visitChildren(this);\n    }\n  }\n};\n\n// src/ast-types.ts\nvar astNodeTypes = [\n  \"SourceUnit\",\n  \"PragmaDirective\",\n  \"ImportDirective\",\n  \"ContractDefinition\",\n  \"InheritanceSpecifier\",\n  \"StateVariableDeclaration\",\n  \"UsingForDeclaration\",\n  \"StructDefinition\",\n  \"ModifierDefinition\",\n  \"ModifierInvocation\",\n  \"FunctionDefinition\",\n  \"EventDefinition\",\n  \"CustomErrorDefinition\",\n  \"RevertStatement\",\n  \"EnumValue\",\n  \"EnumDefinition\",\n  \"VariableDeclaration\",\n  \"UserDefinedTypeName\",\n  \"Mapping\",\n  \"ArrayTypeName\",\n  \"FunctionTypeName\",\n  \"Block\",\n  \"ExpressionStatement\",\n  \"IfStatement\",\n  \"WhileStatement\",\n  \"ForStatement\",\n  \"InlineAssemblyStatement\",\n  \"DoWhileStatement\",\n  \"ContinueStatement\",\n  \"Break\",\n  \"Continue\",\n  \"BreakStatement\",\n  \"ReturnStatement\",\n  \"EmitStatement\",\n  \"ThrowStatement\",\n  \"VariableDeclarationStatement\",\n  \"ElementaryTypeName\",\n  \"FunctionCall\",\n  \"AssemblyBlock\",\n  \"AssemblyCall\",\n  \"AssemblyLocalDefinition\",\n  \"AssemblyAssignment\",\n  \"AssemblyStackAssignment\",\n  \"LabelDefinition\",\n  \"AssemblySwitch\",\n  \"AssemblyCase\",\n  \"AssemblyFunctionDefinition\",\n  \"AssemblyFunctionReturns\",\n  \"AssemblyFor\",\n  \"AssemblyIf\",\n  \"SubAssembly\",\n  \"TupleExpression\",\n  \"NameValueExpression\",\n  \"BooleanLiteral\",\n  \"NumberLiteral\",\n  \"Identifier\",\n  \"BinaryOperation\",\n  \"UnaryOperation\",\n  \"NewExpression\",\n  \"Conditional\",\n  \"StringLiteral\",\n  \"HexLiteral\",\n  \"HexNumber\",\n  \"DecimalNumber\",\n  \"MemberAccess\",\n  \"IndexAccess\",\n  \"IndexRangeAccess\",\n  \"NameValueList\",\n  \"UncheckedStatement\",\n  \"TryStatement\",\n  \"CatchClause\",\n  \"FileLevelConstant\",\n  \"AssemblyMemberAccess\",\n  \"TypeDefinition\"\n];\nvar binaryOpValues = [\n  \"+\",\n  \"-\",\n  \"*\",\n  \"/\",\n  \"**\",\n  \"%\",\n  \"<<\",\n  \">>\",\n  \"&&\",\n  \"||\",\n  \",,\",\n  \"&\",\n  \",\",\n  \"^\",\n  \"<\",\n  \">\",\n  \"<=\",\n  \">=\",\n  \"==\",\n  \"!=\",\n  \"=\",\n  \",=\",\n  \"^=\",\n  \"&=\",\n  \"<<=\",\n  \">>=\",\n  \"+=\",\n  \"-=\",\n  \"*=\",\n  \"/=\",\n  \"%=\",\n  \"|\",\n  \"|=\"\n];\nvar unaryOpValues = [\n  \"-\",\n  \"+\",\n  \"++\",\n  \"--\",\n  \"~\",\n  \"after\",\n  \"delete\",\n  \"!\"\n];\n\n// src/ASTBuilder.ts\nvar import_AbstractParseTreeVisitor = __toModule(require_AbstractParseTreeVisitor());\nvar import_ErrorNode = __toModule(require_ErrorNode());\nvar ASTBuilder = class extends import_AbstractParseTreeVisitor.AbstractParseTreeVisitor {\n  constructor(options) {\n    super();\n    this.options = options;\n    this.result = null;\n  }\n  defaultResult() {\n    throw new Error(\"Unknown node\");\n  }\n  aggregateResult() {\n    return {type: \"\"};\n  }\n  visitSourceUnit(ctx) {\n    var _a;\n    const children = ((_a = ctx.children) != null ? _a : []).filter((x) => !(x instanceof import_ErrorNode.ErrorNode));\n    const node = {\n      type: \"SourceUnit\",\n      children: children.slice(0, -1).map((child) => this.visit(child))\n    };\n    const result = this._addMeta(node, ctx);\n    this.result = result;\n    return result;\n  }\n  visitContractPart(ctx) {\n    return this.visit(ctx.getChild(0));\n  }\n  visitContractDefinition(ctx) {\n    const name = this._toText(ctx.identifier());\n    const kind = this._toText(ctx.getChild(0));\n    this._currentContract = name;\n    const node = {\n      type: \"ContractDefinition\",\n      name,\n      baseContracts: ctx.inheritanceSpecifier().map((x) => this.visitInheritanceSpecifier(x)),\n      subNodes: ctx.contractPart().map((x) => this.visit(x)),\n      kind\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitStateVariableDeclaration(ctx) {\n    const type = this.visitTypeName(ctx.typeName());\n    const iden = ctx.identifier();\n    const name = this._toText(iden);\n    let expression = null;\n    const ctxExpression = ctx.expression();\n    if (ctxExpression) {\n      expression = this.visitExpression(ctxExpression);\n    }\n    let visibility = \"default\";\n    if (ctx.InternalKeyword().length > 0) {\n      visibility = \"internal\";\n    } else if (ctx.PublicKeyword().length > 0) {\n      visibility = \"public\";\n    } else if (ctx.PrivateKeyword().length > 0) {\n      visibility = \"private\";\n    }\n    let isDeclaredConst = false;\n    if (ctx.ConstantKeyword().length > 0) {\n      isDeclaredConst = true;\n    }\n    let override;\n    const overrideSpecifier = ctx.overrideSpecifier();\n    if (overrideSpecifier.length === 0) {\n      override = null;\n    } else {\n      override = overrideSpecifier[0].userDefinedTypeName().map((x) => this.visitUserDefinedTypeName(x));\n    }\n    let isImmutable = false;\n    if (ctx.ImmutableKeyword().length > 0) {\n      isImmutable = true;\n    }\n    const decl = {\n      type: \"VariableDeclaration\",\n      typeName: type,\n      name,\n      identifier: this.visitIdentifier(iden),\n      expression,\n      visibility,\n      isStateVar: true,\n      isDeclaredConst,\n      isIndexed: false,\n      isImmutable,\n      override,\n      storageLocation: null\n    };\n    const node = {\n      type: \"StateVariableDeclaration\",\n      variables: [this._addMeta(decl, ctx)],\n      initialValue: expression\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitVariableDeclaration(ctx) {\n    let storageLocation = null;\n    const ctxStorageLocation = ctx.storageLocation();\n    if (ctxStorageLocation) {\n      storageLocation = this._toText(ctxStorageLocation);\n    }\n    const identifierCtx = ctx.identifier();\n    const node = {\n      type: \"VariableDeclaration\",\n      typeName: this.visitTypeName(ctx.typeName()),\n      name: this._toText(identifierCtx),\n      identifier: this.visitIdentifier(identifierCtx),\n      storageLocation,\n      isStateVar: false,\n      isIndexed: false,\n      expression: null\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitVariableDeclarationStatement(ctx) {\n    let variables = [];\n    const ctxVariableDeclaration = ctx.variableDeclaration();\n    const ctxIdentifierList = ctx.identifierList();\n    const ctxVariableDeclarationList = ctx.variableDeclarationList();\n    if (ctxVariableDeclaration !== void 0) {\n      variables = [this.visitVariableDeclaration(ctxVariableDeclaration)];\n    } else if (ctxIdentifierList !== void 0) {\n      variables = this.buildIdentifierList(ctxIdentifierList);\n    } else if (ctxVariableDeclarationList) {\n      variables = this.buildVariableDeclarationList(ctxVariableDeclarationList);\n    }\n    let initialValue = null;\n    const ctxExpression = ctx.expression();\n    if (ctxExpression) {\n      initialValue = this.visitExpression(ctxExpression);\n    }\n    const node = {\n      type: \"VariableDeclarationStatement\",\n      variables,\n      initialValue\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitStatement(ctx) {\n    return this.visit(ctx.getChild(0));\n  }\n  visitSimpleStatement(ctx) {\n    return this.visit(ctx.getChild(0));\n  }\n  visitEventDefinition(ctx) {\n    const parameters = ctx.eventParameterList().eventParameter().map((paramCtx) => {\n      const type = this.visitTypeName(paramCtx.typeName());\n      let name = null;\n      const paramCtxIdentifier = paramCtx.identifier();\n      if (paramCtxIdentifier) {\n        name = this._toText(paramCtxIdentifier);\n      }\n      const node2 = {\n        type: \"VariableDeclaration\",\n        typeName: type,\n        name,\n        identifier: paramCtxIdentifier !== void 0 ? this.visitIdentifier(paramCtxIdentifier) : null,\n        isStateVar: false,\n        isIndexed: paramCtx.IndexedKeyword() !== void 0,\n        storageLocation: null,\n        expression: null\n      };\n      return this._addMeta(node2, paramCtx);\n    });\n    const node = {\n      type: \"EventDefinition\",\n      name: this._toText(ctx.identifier()),\n      parameters,\n      isAnonymous: ctx.AnonymousKeyword() !== void 0\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitBlock(ctx) {\n    const node = {\n      type: \"Block\",\n      statements: ctx.statement().map((x) => this.visitStatement(x))\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitParameter(ctx) {\n    let storageLocation = null;\n    const ctxStorageLocation = ctx.storageLocation();\n    if (ctxStorageLocation !== void 0) {\n      storageLocation = this._toText(ctxStorageLocation);\n    }\n    let name = null;\n    const ctxIdentifier = ctx.identifier();\n    if (ctxIdentifier !== void 0) {\n      name = this._toText(ctxIdentifier);\n    }\n    const node = {\n      type: \"VariableDeclaration\",\n      typeName: this.visitTypeName(ctx.typeName()),\n      name,\n      identifier: ctxIdentifier !== void 0 ? this.visitIdentifier(ctxIdentifier) : null,\n      storageLocation,\n      isStateVar: false,\n      isIndexed: false,\n      expression: null\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitFunctionDefinition(ctx) {\n    let isConstructor = false;\n    let isFallback = false;\n    let isReceiveEther = false;\n    let isVirtual = false;\n    let name = null;\n    let parameters = [];\n    let returnParameters = null;\n    let visibility = \"default\";\n    let block = null;\n    const ctxBlock = ctx.block();\n    if (ctxBlock !== void 0) {\n      block = this.visitBlock(ctxBlock);\n    }\n    const modifiers = ctx.modifierList().modifierInvocation().map((mod) => this.visitModifierInvocation(mod));\n    let stateMutability = null;\n    if (ctx.modifierList().stateMutability().length > 0) {\n      stateMutability = this._stateMutabilityToText(ctx.modifierList().stateMutability(0));\n    }\n    const ctxReturnParameters = ctx.returnParameters();\n    switch (this._toText(ctx.functionDescriptor().getChild(0))) {\n      case \"constructor\":\n        parameters = ctx.parameterList().parameter().map((x) => this.visit(x));\n        if (ctx.modifierList().InternalKeyword().length > 0) {\n          visibility = \"internal\";\n        } else if (ctx.modifierList().PublicKeyword().length > 0) {\n          visibility = \"public\";\n        } else {\n          visibility = \"default\";\n        }\n        isConstructor = true;\n        break;\n      case \"fallback\":\n        parameters = ctx.parameterList().parameter().map((x) => this.visit(x));\n        returnParameters = ctxReturnParameters !== void 0 ? this.visitReturnParameters(ctxReturnParameters) : null;\n        visibility = \"external\";\n        isFallback = true;\n        break;\n      case \"receive\":\n        visibility = \"external\";\n        isReceiveEther = true;\n        break;\n      case \"function\": {\n        const identifier = ctx.functionDescriptor().identifier();\n        name = identifier !== void 0 ? this._toText(identifier) : \"\";\n        parameters = ctx.parameterList().parameter().map((x) => this.visit(x));\n        returnParameters = ctxReturnParameters !== void 0 ? this.visitReturnParameters(ctxReturnParameters) : null;\n        if (ctx.modifierList().ExternalKeyword().length > 0) {\n          visibility = \"external\";\n        } else if (ctx.modifierList().InternalKeyword().length > 0) {\n          visibility = \"internal\";\n        } else if (ctx.modifierList().PublicKeyword().length > 0) {\n          visibility = \"public\";\n        } else if (ctx.modifierList().PrivateKeyword().length > 0) {\n          visibility = \"private\";\n        }\n        isConstructor = name === this._currentContract;\n        isFallback = name === \"\";\n        break;\n      }\n    }\n    if (ctx.modifierList().VirtualKeyword().length > 0) {\n      isVirtual = true;\n    }\n    let override;\n    const overrideSpecifier = ctx.modifierList().overrideSpecifier();\n    if (overrideSpecifier.length === 0) {\n      override = null;\n    } else {\n      override = overrideSpecifier[0].userDefinedTypeName().map((x) => this.visitUserDefinedTypeName(x));\n    }\n    const node = {\n      type: \"FunctionDefinition\",\n      name,\n      parameters,\n      returnParameters,\n      body: block,\n      visibility,\n      modifiers,\n      override,\n      isConstructor,\n      isReceiveEther,\n      isFallback,\n      isVirtual,\n      stateMutability\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitEnumDefinition(ctx) {\n    const node = {\n      type: \"EnumDefinition\",\n      name: this._toText(ctx.identifier()),\n      members: ctx.enumValue().map((x) => this.visitEnumValue(x))\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitEnumValue(ctx) {\n    const node = {\n      type: \"EnumValue\",\n      name: this._toText(ctx.identifier())\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitElementaryTypeName(ctx) {\n    const node = {\n      type: \"ElementaryTypeName\",\n      name: this._toText(ctx),\n      stateMutability: null\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitIdentifier(ctx) {\n    const node = {\n      type: \"Identifier\",\n      name: this._toText(ctx)\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitTypeName(ctx) {\n    var _a;\n    if (ctx.children !== void 0 && ctx.children.length > 2) {\n      let length = null;\n      if (ctx.children.length === 4) {\n        const expression = ctx.expression();\n        if (expression === void 0) {\n          throw new Error(\"Assertion error: a typeName with 4 children should have an expression\");\n        }\n        length = this.visitExpression(expression);\n      }\n      const ctxTypeName = ctx.typeName();\n      const node = {\n        type: \"ArrayTypeName\",\n        baseTypeName: this.visitTypeName(ctxTypeName),\n        length\n      };\n      return this._addMeta(node, ctx);\n    }\n    if (((_a = ctx.children) == null ? void 0 : _a.length) === 2) {\n      const node = {\n        type: \"ElementaryTypeName\",\n        name: this._toText(ctx.getChild(0)),\n        stateMutability: this._toText(ctx.getChild(1))\n      };\n      return this._addMeta(node, ctx);\n    }\n    if (ctx.elementaryTypeName() !== void 0) {\n      return this.visitElementaryTypeName(ctx.elementaryTypeName());\n    }\n    if (ctx.userDefinedTypeName() !== void 0) {\n      return this.visitUserDefinedTypeName(ctx.userDefinedTypeName());\n    }\n    if (ctx.mapping() !== void 0) {\n      return this.visitMapping(ctx.mapping());\n    }\n    if (ctx.functionTypeName() !== void 0) {\n      return this.visitFunctionTypeName(ctx.functionTypeName());\n    }\n    throw new Error(\"Assertion error: unhandled type name case\");\n  }\n  visitUserDefinedTypeName(ctx) {\n    const node = {\n      type: \"UserDefinedTypeName\",\n      namePath: this._toText(ctx)\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitUsingForDeclaration(ctx) {\n    let typeName = null;\n    const ctxTypeName = ctx.typeName();\n    if (ctxTypeName !== void 0) {\n      typeName = this.visitTypeName(ctxTypeName);\n    }\n    const isGlobal = ctx.GlobalKeyword() !== void 0;\n    let node;\n    const usingForObject = ctx.usingForObject();\n    const firstChild = this._toText(usingForObject.getChild(0));\n    if (firstChild === \"{\") {\n      node = {\n        type: \"UsingForDeclaration\",\n        isGlobal,\n        typeName,\n        libraryName: null,\n        functions: usingForObject.userDefinedTypeName().map((x) => this._toText(x))\n      };\n    } else {\n      node = {\n        type: \"UsingForDeclaration\",\n        isGlobal,\n        typeName,\n        libraryName: this._toText(usingForObject.userDefinedTypeName(0)),\n        functions: []\n      };\n    }\n    return this._addMeta(node, ctx);\n  }\n  visitPragmaDirective(ctx) {\n    const versionContext = ctx.pragmaValue().version();\n    let value = this._toText(ctx.pragmaValue());\n    if ((versionContext == null ? void 0 : versionContext.children) !== void 0) {\n      value = versionContext.children.map((x) => this._toText(x)).join(\" \");\n    }\n    const node = {\n      type: \"PragmaDirective\",\n      name: this._toText(ctx.pragmaName()),\n      value\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitInheritanceSpecifier(ctx) {\n    const exprList = ctx.expressionList();\n    const args = exprList !== void 0 ? exprList.expression().map((x) => this.visitExpression(x)) : [];\n    const node = {\n      type: \"InheritanceSpecifier\",\n      baseName: this.visitUserDefinedTypeName(ctx.userDefinedTypeName()),\n      arguments: args\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitModifierInvocation(ctx) {\n    const exprList = ctx.expressionList();\n    let args;\n    if (exprList != null) {\n      args = exprList.expression().map((x) => this.visit(x));\n    } else if (ctx.children !== void 0 && ctx.children.length > 1) {\n      args = [];\n    } else {\n      args = null;\n    }\n    const node = {\n      type: \"ModifierInvocation\",\n      name: this._toText(ctx.identifier()),\n      arguments: args\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitFunctionTypeName(ctx) {\n    const parameterTypes = ctx.functionTypeParameterList(0).functionTypeParameter().map((typeCtx) => this.visitFunctionTypeParameter(typeCtx));\n    let returnTypes = [];\n    if (ctx.functionTypeParameterList().length > 1) {\n      returnTypes = ctx.functionTypeParameterList(1).functionTypeParameter().map((typeCtx) => this.visitFunctionTypeParameter(typeCtx));\n    }\n    let visibility = \"default\";\n    if (ctx.InternalKeyword().length > 0) {\n      visibility = \"internal\";\n    } else if (ctx.ExternalKeyword().length > 0) {\n      visibility = \"external\";\n    }\n    let stateMutability = null;\n    if (ctx.stateMutability().length > 0) {\n      stateMutability = this._toText(ctx.stateMutability(0));\n    }\n    const node = {\n      type: \"FunctionTypeName\",\n      parameterTypes,\n      returnTypes,\n      visibility,\n      stateMutability\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitFunctionTypeParameter(ctx) {\n    let storageLocation = null;\n    if (ctx.storageLocation()) {\n      storageLocation = this._toText(ctx.storageLocation());\n    }\n    const node = {\n      type: \"VariableDeclaration\",\n      typeName: this.visitTypeName(ctx.typeName()),\n      name: null,\n      identifier: null,\n      storageLocation,\n      isStateVar: false,\n      isIndexed: false,\n      expression: null\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitThrowStatement(ctx) {\n    const node = {\n      type: \"ThrowStatement\"\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitReturnStatement(ctx) {\n    let expression = null;\n    const ctxExpression = ctx.expression();\n    if (ctxExpression) {\n      expression = this.visitExpression(ctxExpression);\n    }\n    const node = {\n      type: \"ReturnStatement\",\n      expression\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitEmitStatement(ctx) {\n    const node = {\n      type: \"EmitStatement\",\n      eventCall: this.visitFunctionCall(ctx.functionCall())\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitCustomErrorDefinition(ctx) {\n    const node = {\n      type: \"CustomErrorDefinition\",\n      name: this._toText(ctx.identifier()),\n      parameters: this.visitParameterList(ctx.parameterList())\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitTypeDefinition(ctx) {\n    const node = {\n      type: \"TypeDefinition\",\n      name: this._toText(ctx.identifier()),\n      definition: this.visitElementaryTypeName(ctx.elementaryTypeName())\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitRevertStatement(ctx) {\n    const node = {\n      type: \"RevertStatement\",\n      revertCall: this.visitFunctionCall(ctx.functionCall())\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitFunctionCall(ctx) {\n    let args = [];\n    const names = [];\n    const identifiers = [];\n    const ctxArgs = ctx.functionCallArguments();\n    const ctxArgsExpressionList = ctxArgs.expressionList();\n    const ctxArgsNameValueList = ctxArgs.nameValueList();\n    if (ctxArgsExpressionList) {\n      args = ctxArgsExpressionList.expression().map((exprCtx) => this.visitExpression(exprCtx));\n    } else if (ctxArgsNameValueList) {\n      for (const nameValue of ctxArgsNameValueList.nameValue()) {\n        args.push(this.visitExpression(nameValue.expression()));\n        names.push(this._toText(nameValue.identifier()));\n        identifiers.push(this.visitIdentifier(nameValue.identifier()));\n      }\n    }\n    const node = {\n      type: \"FunctionCall\",\n      expression: this.visitExpression(ctx.expression()),\n      arguments: args,\n      names,\n      identifiers\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitStructDefinition(ctx) {\n    const node = {\n      type: \"StructDefinition\",\n      name: this._toText(ctx.identifier()),\n      members: ctx.variableDeclaration().map((x) => this.visitVariableDeclaration(x))\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitWhileStatement(ctx) {\n    const node = {\n      type: \"WhileStatement\",\n      condition: this.visitExpression(ctx.expression()),\n      body: this.visitStatement(ctx.statement())\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitDoWhileStatement(ctx) {\n    const node = {\n      type: \"DoWhileStatement\",\n      condition: this.visitExpression(ctx.expression()),\n      body: this.visitStatement(ctx.statement())\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitIfStatement(ctx) {\n    const trueBody = this.visitStatement(ctx.statement(0));\n    let falseBody = null;\n    if (ctx.statement().length > 1) {\n      falseBody = this.visitStatement(ctx.statement(1));\n    }\n    const node = {\n      type: \"IfStatement\",\n      condition: this.visitExpression(ctx.expression()),\n      trueBody,\n      falseBody\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitTryStatement(ctx) {\n    let returnParameters = null;\n    const ctxReturnParameters = ctx.returnParameters();\n    if (ctxReturnParameters !== void 0) {\n      returnParameters = this.visitReturnParameters(ctxReturnParameters);\n    }\n    const catchClauses = ctx.catchClause().map((exprCtx) => this.visitCatchClause(exprCtx));\n    const node = {\n      type: \"TryStatement\",\n      expression: this.visitExpression(ctx.expression()),\n      returnParameters,\n      body: this.visitBlock(ctx.block()),\n      catchClauses\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitCatchClause(ctx) {\n    let parameters = null;\n    if (ctx.parameterList()) {\n      parameters = this.visitParameterList(ctx.parameterList());\n    }\n    if (ctx.identifier() && this._toText(ctx.identifier()) !== \"Error\" && this._toText(ctx.identifier()) !== \"Panic\") {\n      throw new Error('Expected \"Error\" or \"Panic\" identifier in catch clause');\n    }\n    let kind = null;\n    const ctxIdentifier = ctx.identifier();\n    if (ctxIdentifier !== void 0) {\n      kind = this._toText(ctxIdentifier);\n    }\n    const node = {\n      type: \"CatchClause\",\n      isReasonStringType: kind === \"Error\",\n      kind,\n      parameters,\n      body: this.visitBlock(ctx.block())\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitExpressionStatement(ctx) {\n    if (!ctx) {\n      return null;\n    }\n    const node = {\n      type: \"ExpressionStatement\",\n      expression: this.visitExpression(ctx.expression())\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitNumberLiteral(ctx) {\n    var _a;\n    const number = this._toText(ctx.getChild(0));\n    let subdenomination = null;\n    if (((_a = ctx.children) == null ? void 0 : _a.length) === 2) {\n      subdenomination = this._toText(ctx.getChild(1));\n    }\n    const node = {\n      type: \"NumberLiteral\",\n      number,\n      subdenomination\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitMappingKey(ctx) {\n    if (ctx.elementaryTypeName()) {\n      return this.visitElementaryTypeName(ctx.elementaryTypeName());\n    } else if (ctx.userDefinedTypeName()) {\n      return this.visitUserDefinedTypeName(ctx.userDefinedTypeName());\n    } else {\n      throw new Error(\"Expected MappingKey to have either elementaryTypeName or userDefinedTypeName\");\n    }\n  }\n  visitMapping(ctx) {\n    const node = {\n      type: \"Mapping\",\n      keyType: this.visitMappingKey(ctx.mappingKey()),\n      valueType: this.visitTypeName(ctx.typeName())\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitModifierDefinition(ctx) {\n    let parameters = null;\n    if (ctx.parameterList()) {\n      parameters = this.visitParameterList(ctx.parameterList());\n    }\n    let isVirtual = false;\n    if (ctx.VirtualKeyword().length > 0) {\n      isVirtual = true;\n    }\n    let override;\n    const overrideSpecifier = ctx.overrideSpecifier();\n    if (overrideSpecifier.length === 0) {\n      override = null;\n    } else {\n      override = overrideSpecifier[0].userDefinedTypeName().map((x) => this.visitUserDefinedTypeName(x));\n    }\n    let body = null;\n    const blockCtx = ctx.block();\n    if (blockCtx !== void 0) {\n      body = this.visitBlock(blockCtx);\n    }\n    const node = {\n      type: \"ModifierDefinition\",\n      name: this._toText(ctx.identifier()),\n      parameters,\n      body,\n      isVirtual,\n      override\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitUncheckedStatement(ctx) {\n    const node = {\n      type: \"UncheckedStatement\",\n      block: this.visitBlock(ctx.block())\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitExpression(ctx) {\n    let op;\n    switch (ctx.children.length) {\n      case 1: {\n        const primaryExpressionCtx = ctx.tryGetRuleContext(0, PrimaryExpressionContext);\n        if (primaryExpressionCtx === void 0) {\n          throw new Error(\"Assertion error: primary expression should exist when children length is 1\");\n        }\n        return this.visitPrimaryExpression(primaryExpressionCtx);\n      }\n      case 2:\n        op = this._toText(ctx.getChild(0));\n        if (op === \"new\") {\n          const node = {\n            type: \"NewExpression\",\n            typeName: this.visitTypeName(ctx.typeName())\n          };\n          return this._addMeta(node, ctx);\n        }\n        if (unaryOpValues.includes(op)) {\n          const node = {\n            type: \"UnaryOperation\",\n            operator: op,\n            subExpression: this.visitExpression(ctx.getRuleContext(0, ExpressionContext)),\n            isPrefix: true\n          };\n          return this._addMeta(node, ctx);\n        }\n        op = this._toText(ctx.getChild(1));\n        if ([\"++\", \"--\"].includes(op)) {\n          const node = {\n            type: \"UnaryOperation\",\n            operator: op,\n            subExpression: this.visitExpression(ctx.getRuleContext(0, ExpressionContext)),\n            isPrefix: false\n          };\n          return this._addMeta(node, ctx);\n        }\n        break;\n      case 3:\n        if (this._toText(ctx.getChild(0)) === \"(\" && this._toText(ctx.getChild(2)) === \")\") {\n          const node = {\n            type: \"TupleExpression\",\n            components: [\n              this.visitExpression(ctx.getRuleContext(0, ExpressionContext))\n            ],\n            isArray: false\n          };\n          return this._addMeta(node, ctx);\n        }\n        op = this._toText(ctx.getChild(1));\n        if (op === \".\") {\n          const node = {\n            type: \"MemberAccess\",\n            expression: this.visitExpression(ctx.expression(0)),\n            memberName: this._toText(ctx.identifier())\n          };\n          return this._addMeta(node, ctx);\n        }\n        if (isBinOp(op)) {\n          const node = {\n            type: \"BinaryOperation\",\n            operator: op,\n            left: this.visitExpression(ctx.expression(0)),\n            right: this.visitExpression(ctx.expression(1))\n          };\n          return this._addMeta(node, ctx);\n        }\n        break;\n      case 4:\n        if (this._toText(ctx.getChild(1)) === \"(\" && this._toText(ctx.getChild(3)) === \")\") {\n          let args = [];\n          const names = [];\n          const identifiers = [];\n          const ctxArgs = ctx.functionCallArguments();\n          if (ctxArgs.expressionList()) {\n            args = ctxArgs.expressionList().expression().map((exprCtx) => this.visitExpression(exprCtx));\n          } else if (ctxArgs.nameValueList()) {\n            for (const nameValue of ctxArgs.nameValueList().nameValue()) {\n              args.push(this.visitExpression(nameValue.expression()));\n              names.push(this._toText(nameValue.identifier()));\n              identifiers.push(this.visitIdentifier(nameValue.identifier()));\n            }\n          }\n          const node = {\n            type: \"FunctionCall\",\n            expression: this.visitExpression(ctx.expression(0)),\n            arguments: args,\n            names,\n            identifiers\n          };\n          return this._addMeta(node, ctx);\n        }\n        if (this._toText(ctx.getChild(1)) === \"[\" && this._toText(ctx.getChild(3)) === \"]\") {\n          if (ctx.getChild(2).text === \":\") {\n            const node2 = {\n              type: \"IndexRangeAccess\",\n              base: this.visitExpression(ctx.expression(0))\n            };\n            return this._addMeta(node2, ctx);\n          }\n          const node = {\n            type: \"IndexAccess\",\n            base: this.visitExpression(ctx.expression(0)),\n            index: this.visitExpression(ctx.expression(1))\n          };\n          return this._addMeta(node, ctx);\n        }\n        if (this._toText(ctx.getChild(1)) === \"{\" && this._toText(ctx.getChild(3)) === \"}\") {\n          const node = {\n            type: \"NameValueExpression\",\n            expression: this.visitExpression(ctx.expression(0)),\n            arguments: this.visitNameValueList(ctx.nameValueList())\n          };\n          return this._addMeta(node, ctx);\n        }\n        break;\n      case 5:\n        if (this._toText(ctx.getChild(1)) === \"?\" && this._toText(ctx.getChild(3)) === \":\") {\n          const node = {\n            type: \"Conditional\",\n            condition: this.visitExpression(ctx.expression(0)),\n            trueExpression: this.visitExpression(ctx.expression(1)),\n            falseExpression: this.visitExpression(ctx.expression(2))\n          };\n          return this._addMeta(node, ctx);\n        }\n        if (this._toText(ctx.getChild(1)) === \"[\" && this._toText(ctx.getChild(2)) === \":\" && this._toText(ctx.getChild(4)) === \"]\") {\n          const node = {\n            type: \"IndexRangeAccess\",\n            base: this.visitExpression(ctx.expression(0)),\n            indexEnd: this.visitExpression(ctx.expression(1))\n          };\n          return this._addMeta(node, ctx);\n        } else if (this._toText(ctx.getChild(1)) === \"[\" && this._toText(ctx.getChild(3)) === \":\" && this._toText(ctx.getChild(4)) === \"]\") {\n          const node = {\n            type: \"IndexRangeAccess\",\n            base: this.visitExpression(ctx.expression(0)),\n            indexStart: this.visitExpression(ctx.expression(1))\n          };\n          return this._addMeta(node, ctx);\n        }\n        break;\n      case 6:\n        if (this._toText(ctx.getChild(1)) === \"[\" && this._toText(ctx.getChild(3)) === \":\" && this._toText(ctx.getChild(5)) === \"]\") {\n          const node = {\n            type: \"IndexRangeAccess\",\n            base: this.visitExpression(ctx.expression(0)),\n            indexStart: this.visitExpression(ctx.expression(1)),\n            indexEnd: this.visitExpression(ctx.expression(2))\n          };\n          return this._addMeta(node, ctx);\n        }\n        break;\n    }\n    throw new Error(\"Unrecognized expression\");\n  }\n  visitNameValueList(ctx) {\n    const names = [];\n    const identifiers = [];\n    const args = [];\n    for (const nameValue of ctx.nameValue()) {\n      names.push(this._toText(nameValue.identifier()));\n      identifiers.push(this.visitIdentifier(nameValue.identifier()));\n      args.push(this.visitExpression(nameValue.expression()));\n    }\n    const node = {\n      type: \"NameValueList\",\n      names,\n      identifiers,\n      arguments: args\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitFileLevelConstant(ctx) {\n    const type = this.visitTypeName(ctx.typeName());\n    const iden = ctx.identifier();\n    const name = this._toText(iden);\n    const expression = this.visitExpression(ctx.expression());\n    const node = {\n      type: \"FileLevelConstant\",\n      typeName: type,\n      name,\n      initialValue: expression,\n      isDeclaredConst: true,\n      isImmutable: false\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitForStatement(ctx) {\n    let conditionExpression = this.visitExpressionStatement(ctx.expressionStatement());\n    if (conditionExpression) {\n      conditionExpression = conditionExpression.expression;\n    }\n    const node = {\n      type: \"ForStatement\",\n      initExpression: ctx.simpleStatement() ? this.visitSimpleStatement(ctx.simpleStatement()) : null,\n      conditionExpression,\n      loopExpression: {\n        type: \"ExpressionStatement\",\n        expression: ctx.expression() !== void 0 ? this.visitExpression(ctx.expression()) : null\n      },\n      body: this.visitStatement(ctx.statement())\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitHexLiteral(ctx) {\n    const parts = ctx.HexLiteralFragment().map((x) => this._toText(x)).map((x) => x.substring(4, x.length - 1));\n    const node = {\n      type: \"HexLiteral\",\n      value: parts.join(\"\"),\n      parts\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitPrimaryExpression(ctx) {\n    if (ctx.BooleanLiteral()) {\n      const node = {\n        type: \"BooleanLiteral\",\n        value: this._toText(ctx.BooleanLiteral()) === \"true\"\n      };\n      return this._addMeta(node, ctx);\n    }\n    if (ctx.hexLiteral()) {\n      return this.visitHexLiteral(ctx.hexLiteral());\n    }\n    if (ctx.stringLiteral()) {\n      const fragments = ctx.stringLiteral().StringLiteralFragment().map((stringLiteralFragmentCtx) => {\n        let text = this._toText(stringLiteralFragmentCtx);\n        const isUnicode = text.slice(0, 7) === \"unicode\";\n        if (isUnicode) {\n          text = text.slice(7);\n        }\n        const singleQuotes = text[0] === \"'\";\n        const textWithoutQuotes = text.substring(1, text.length - 1);\n        const value = singleQuotes ? textWithoutQuotes.replace(new RegExp(\"\\\\\\\\'\", \"g\"), \"'\") : textWithoutQuotes.replace(new RegExp('\\\\\\\\\"', \"g\"), '\"');\n        return {value, isUnicode};\n      });\n      const parts = fragments.map((x) => x.value);\n      const node = {\n        type: \"StringLiteral\",\n        value: parts.join(\"\"),\n        parts,\n        isUnicode: fragments.map((x) => x.isUnicode)\n      };\n      return this._addMeta(node, ctx);\n    }\n    if (ctx.numberLiteral()) {\n      return this.visitNumberLiteral(ctx.numberLiteral());\n    }\n    if (ctx.TypeKeyword()) {\n      const node = {\n        type: \"Identifier\",\n        name: \"type\"\n      };\n      return this._addMeta(node, ctx);\n    }\n    if (ctx.typeName()) {\n      return this.visitTypeName(ctx.typeName());\n    }\n    return this.visit(ctx.getChild(0));\n  }\n  visitTupleExpression(ctx) {\n    const children = ctx.children.slice(1, -1);\n    const components = this._mapCommasToNulls(children).map((expr) => {\n      if (expr === null) {\n        return null;\n      }\n      return this.visit(expr);\n    });\n    const node = {\n      type: \"TupleExpression\",\n      components,\n      isArray: this._toText(ctx.getChild(0)) === \"[\"\n    };\n    return this._addMeta(node, ctx);\n  }\n  buildIdentifierList(ctx) {\n    const children = ctx.children.slice(1, -1);\n    const identifiers = ctx.identifier();\n    let i = 0;\n    return this._mapCommasToNulls(children).map((idenOrNull) => {\n      if (!idenOrNull) {\n        return null;\n      }\n      const iden = identifiers[i];\n      i++;\n      const node = {\n        type: \"VariableDeclaration\",\n        name: this._toText(iden),\n        identifier: this.visitIdentifier(iden),\n        isStateVar: false,\n        isIndexed: false,\n        typeName: null,\n        storageLocation: null,\n        expression: null\n      };\n      return this._addMeta(node, iden);\n    });\n  }\n  buildVariableDeclarationList(ctx) {\n    var _a;\n    const variableDeclarations = ctx.variableDeclaration();\n    let i = 0;\n    return this._mapCommasToNulls((_a = ctx.children) != null ? _a : []).map((declOrNull) => {\n      if (!declOrNull) {\n        return null;\n      }\n      const decl = variableDeclarations[i];\n      i++;\n      let storageLocation = null;\n      if (decl.storageLocation()) {\n        storageLocation = this._toText(decl.storageLocation());\n      }\n      const identifierCtx = decl.identifier();\n      const result = {\n        type: \"VariableDeclaration\",\n        name: this._toText(identifierCtx),\n        identifier: this.visitIdentifier(identifierCtx),\n        typeName: this.visitTypeName(decl.typeName()),\n        storageLocation,\n        isStateVar: false,\n        isIndexed: false,\n        expression: null\n      };\n      return this._addMeta(result, decl);\n    });\n  }\n  visitImportDirective(ctx) {\n    const pathString = this._toText(ctx.importPath());\n    let unitAlias = null;\n    let unitAliasIdentifier = null;\n    let symbolAliases = null;\n    let symbolAliasesIdentifiers = null;\n    if (ctx.importDeclaration().length > 0) {\n      symbolAliases = ctx.importDeclaration().map((decl) => {\n        const symbol = this._toText(decl.identifier(0));\n        let alias = null;\n        if (decl.identifier().length > 1) {\n          alias = this._toText(decl.identifier(1));\n        }\n        return [symbol, alias];\n      });\n      symbolAliasesIdentifiers = ctx.importDeclaration().map((decl) => {\n        const symbolIdentifier = this.visitIdentifier(decl.identifier(0));\n        let aliasIdentifier = null;\n        if (decl.identifier().length > 1) {\n          aliasIdentifier = this.visitIdentifier(decl.identifier(1));\n        }\n        return [symbolIdentifier, aliasIdentifier];\n      });\n    } else {\n      const identifierCtxList = ctx.identifier();\n      if (identifierCtxList.length === 0) {\n      } else if (identifierCtxList.length === 1) {\n        const aliasIdentifierCtx = ctx.identifier(0);\n        unitAlias = this._toText(aliasIdentifierCtx);\n        unitAliasIdentifier = this.visitIdentifier(aliasIdentifierCtx);\n      } else if (identifierCtxList.length === 2) {\n        const aliasIdentifierCtx = ctx.identifier(1);\n        unitAlias = this._toText(aliasIdentifierCtx);\n        unitAliasIdentifier = this.visitIdentifier(aliasIdentifierCtx);\n      } else {\n        throw new Error(\"Assertion error: an import should have one or two identifiers\");\n      }\n    }\n    const path = pathString.substring(1, pathString.length - 1);\n    const pathLiteral = {\n      type: \"StringLiteral\",\n      value: path,\n      parts: [path],\n      isUnicode: [false]\n    };\n    const node = {\n      type: \"ImportDirective\",\n      path,\n      pathLiteral: this._addMeta(pathLiteral, ctx.importPath()),\n      unitAlias,\n      unitAliasIdentifier,\n      symbolAliases,\n      symbolAliasesIdentifiers\n    };\n    return this._addMeta(node, ctx);\n  }\n  buildEventParameterList(ctx) {\n    return ctx.eventParameter().map((paramCtx) => {\n      const type = this.visit(paramCtx.typeName());\n      let name = null;\n      if (paramCtx.identifier()) {\n        name = this._toText(paramCtx.identifier());\n      }\n      return {\n        type: \"VariableDeclaration\",\n        typeName: type,\n        name,\n        isStateVar: false,\n        isIndexed: !!paramCtx.IndexedKeyword(0)\n      };\n    });\n  }\n  visitReturnParameters(ctx) {\n    return this.visitParameterList(ctx.parameterList());\n  }\n  visitParameterList(ctx) {\n    return ctx.parameter().map((paramCtx) => this.visitParameter(paramCtx));\n  }\n  visitInlineAssemblyStatement(ctx) {\n    let language = null;\n    if (ctx.StringLiteralFragment()) {\n      language = this._toText(ctx.StringLiteralFragment());\n      language = language.substring(1, language.length - 1);\n    }\n    const flags = [];\n    const flag = ctx.inlineAssemblyStatementFlag();\n    if (flag !== void 0) {\n      const flagString = this._toText(flag.stringLiteral());\n      flags.push(flagString.slice(1, flagString.length - 1));\n    }\n    const node = {\n      type: \"InlineAssemblyStatement\",\n      language,\n      flags,\n      body: this.visitAssemblyBlock(ctx.assemblyBlock())\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitAssemblyBlock(ctx) {\n    const operations = ctx.assemblyItem().map((item) => this.visitAssemblyItem(item));\n    const node = {\n      type: \"AssemblyBlock\",\n      operations\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitAssemblyItem(ctx) {\n    let text;\n    if (ctx.hexLiteral()) {\n      return this.visitHexLiteral(ctx.hexLiteral());\n    }\n    if (ctx.stringLiteral()) {\n      text = this._toText(ctx.stringLiteral());\n      const value = text.substring(1, text.length - 1);\n      const node = {\n        type: \"StringLiteral\",\n        value,\n        parts: [value],\n        isUnicode: [false]\n      };\n      return this._addMeta(node, ctx);\n    }\n    if (ctx.BreakKeyword()) {\n      const node = {\n        type: \"Break\"\n      };\n      return this._addMeta(node, ctx);\n    }\n    if (ctx.ContinueKeyword()) {\n      const node = {\n        type: \"Continue\"\n      };\n      return this._addMeta(node, ctx);\n    }\n    return this.visit(ctx.getChild(0));\n  }\n  visitAssemblyExpression(ctx) {\n    return this.visit(ctx.getChild(0));\n  }\n  visitAssemblyCall(ctx) {\n    const functionName = this._toText(ctx.getChild(0));\n    const args = ctx.assemblyExpression().map((assemblyExpr) => this.visitAssemblyExpression(assemblyExpr));\n    const node = {\n      type: \"AssemblyCall\",\n      functionName,\n      arguments: args\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitAssemblyLiteral(ctx) {\n    let text;\n    if (ctx.stringLiteral()) {\n      text = this._toText(ctx);\n      const value = text.substring(1, text.length - 1);\n      const node = {\n        type: \"StringLiteral\",\n        value,\n        parts: [value],\n        isUnicode: [false]\n      };\n      return this._addMeta(node, ctx);\n    }\n    if (ctx.BooleanLiteral()) {\n      const node = {\n        type: \"BooleanLiteral\",\n        value: this._toText(ctx.BooleanLiteral()) === \"true\"\n      };\n      return this._addMeta(node, ctx);\n    }\n    if (ctx.DecimalNumber()) {\n      const node = {\n        type: \"DecimalNumber\",\n        value: this._toText(ctx)\n      };\n      return this._addMeta(node, ctx);\n    }\n    if (ctx.HexNumber()) {\n      const node = {\n        type: \"HexNumber\",\n        value: this._toText(ctx)\n      };\n      return this._addMeta(node, ctx);\n    }\n    if (ctx.hexLiteral()) {\n      return this.visitHexLiteral(ctx.hexLiteral());\n    }\n    throw new Error(\"Should never reach here\");\n  }\n  visitAssemblySwitch(ctx) {\n    const node = {\n      type: \"AssemblySwitch\",\n      expression: this.visitAssemblyExpression(ctx.assemblyExpression()),\n      cases: ctx.assemblyCase().map((c) => this.visitAssemblyCase(c))\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitAssemblyCase(ctx) {\n    let value = null;\n    if (this._toText(ctx.getChild(0)) === \"case\") {\n      value = this.visitAssemblyLiteral(ctx.assemblyLiteral());\n    }\n    const node = {\n      type: \"AssemblyCase\",\n      block: this.visitAssemblyBlock(ctx.assemblyBlock()),\n      value,\n      default: value === null\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitAssemblyLocalDefinition(ctx) {\n    const ctxAssemblyIdentifierOrList = ctx.assemblyIdentifierOrList();\n    let names;\n    if (ctxAssemblyIdentifierOrList.identifier()) {\n      names = [this.visitIdentifier(ctxAssemblyIdentifierOrList.identifier())];\n    } else if (ctxAssemblyIdentifierOrList.assemblyMember()) {\n      names = [\n        this.visitAssemblyMember(ctxAssemblyIdentifierOrList.assemblyMember())\n      ];\n    } else {\n      names = ctxAssemblyIdentifierOrList.assemblyIdentifierList().identifier().map((x) => this.visitIdentifier(x));\n    }\n    let expression = null;\n    if (ctx.assemblyExpression() !== void 0) {\n      expression = this.visitAssemblyExpression(ctx.assemblyExpression());\n    }\n    const node = {\n      type: \"AssemblyLocalDefinition\",\n      names,\n      expression\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitAssemblyFunctionDefinition(ctx) {\n    const ctxAssemblyIdentifierList = ctx.assemblyIdentifierList();\n    const args = ctxAssemblyIdentifierList !== void 0 ? ctxAssemblyIdentifierList.identifier().map((x) => this.visitIdentifier(x)) : [];\n    const ctxAssemblyFunctionReturns = ctx.assemblyFunctionReturns();\n    const returnArgs = ctxAssemblyFunctionReturns ? ctxAssemblyFunctionReturns.assemblyIdentifierList().identifier().map((x) => this.visitIdentifier(x)) : [];\n    const node = {\n      type: \"AssemblyFunctionDefinition\",\n      name: this._toText(ctx.identifier()),\n      arguments: args,\n      returnArguments: returnArgs,\n      body: this.visitAssemblyBlock(ctx.assemblyBlock())\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitAssemblyAssignment(ctx) {\n    const ctxAssemblyIdentifierOrList = ctx.assemblyIdentifierOrList();\n    let names;\n    if (ctxAssemblyIdentifierOrList.identifier()) {\n      names = [this.visitIdentifier(ctxAssemblyIdentifierOrList.identifier())];\n    } else if (ctxAssemblyIdentifierOrList.assemblyMember()) {\n      names = [\n        this.visitAssemblyMember(ctxAssemblyIdentifierOrList.assemblyMember())\n      ];\n    } else {\n      names = ctxAssemblyIdentifierOrList.assemblyIdentifierList().identifier().map((x) => this.visitIdentifier(x));\n    }\n    const node = {\n      type: \"AssemblyAssignment\",\n      names,\n      expression: this.visitAssemblyExpression(ctx.assemblyExpression())\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitAssemblyMember(ctx) {\n    const [accessed, member] = ctx.identifier();\n    const node = {\n      type: \"AssemblyMemberAccess\",\n      expression: this.visitIdentifier(accessed),\n      memberName: this.visitIdentifier(member)\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitLabelDefinition(ctx) {\n    const node = {\n      type: \"LabelDefinition\",\n      name: this._toText(ctx.identifier())\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitAssemblyStackAssignment(ctx) {\n    const node = {\n      type: \"AssemblyStackAssignment\",\n      name: this._toText(ctx.identifier()),\n      expression: this.visitAssemblyExpression(ctx.assemblyExpression())\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitAssemblyFor(ctx) {\n    const node = {\n      type: \"AssemblyFor\",\n      pre: this.visit(ctx.getChild(1)),\n      condition: this.visit(ctx.getChild(2)),\n      post: this.visit(ctx.getChild(3)),\n      body: this.visit(ctx.getChild(4))\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitAssemblyIf(ctx) {\n    const node = {\n      type: \"AssemblyIf\",\n      condition: this.visitAssemblyExpression(ctx.assemblyExpression()),\n      body: this.visitAssemblyBlock(ctx.assemblyBlock())\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitContinueStatement(ctx) {\n    const node = {\n      type: \"ContinueStatement\"\n    };\n    return this._addMeta(node, ctx);\n  }\n  visitBreakStatement(ctx) {\n    const node = {\n      type: \"BreakStatement\"\n    };\n    return this._addMeta(node, ctx);\n  }\n  _toText(ctx) {\n    const text = ctx.text;\n    if (text === void 0) {\n      throw new Error(\"Assertion error: text should never be undefiend\");\n    }\n    return text;\n  }\n  _stateMutabilityToText(ctx) {\n    if (ctx.PureKeyword() !== void 0) {\n      return \"pure\";\n    }\n    if (ctx.ConstantKeyword() !== void 0) {\n      return \"constant\";\n    }\n    if (ctx.PayableKeyword() !== void 0) {\n      return \"payable\";\n    }\n    if (ctx.ViewKeyword() !== void 0) {\n      return \"view\";\n    }\n    throw new Error(\"Assertion error: non-exhaustive stateMutability check\");\n  }\n  _loc(ctx) {\n    const sourceLocation = {\n      start: {\n        line: ctx.start.line,\n        column: ctx.start.charPositionInLine\n      },\n      end: {\n        line: ctx.stop ? ctx.stop.line : ctx.start.line,\n        column: ctx.stop ? ctx.stop.charPositionInLine : ctx.start.charPositionInLine\n      }\n    };\n    return sourceLocation;\n  }\n  _range(ctx) {\n    var _a, _b;\n    return [ctx.start.startIndex, (_b = (_a = ctx.stop) == null ? void 0 : _a.stopIndex) != null ? _b : ctx.start.startIndex];\n  }\n  _addMeta(node, ctx) {\n    const nodeWithMeta = {\n      type: node.type\n    };\n    if (this.options.loc === true) {\n      node.loc = this._loc(ctx);\n    }\n    if (this.options.range === true) {\n      node.range = this._range(ctx);\n    }\n    return __objSpread(__objSpread({}, nodeWithMeta), node);\n  }\n  _mapCommasToNulls(children) {\n    if (children.length === 0) {\n      return [];\n    }\n    const values = [];\n    let comma = true;\n    for (const el of children) {\n      if (comma) {\n        if (this._toText(el) === \",\") {\n          values.push(null);\n        } else {\n          values.push(el);\n          comma = false;\n        }\n      } else {\n        if (this._toText(el) !== \",\") {\n          throw new Error(\"expected comma\");\n        }\n        comma = true;\n      }\n    }\n    if (comma) {\n      values.push(null);\n    }\n    return values;\n  }\n};\nfunction isBinOp(op) {\n  return binaryOpValues.includes(op);\n}\n\n// src/ErrorListener.ts\nvar import_antlr4 = __toModule(require_antlr4());\nvar ErrorListener = class extends import_antlr4.default.error.ErrorListener {\n  constructor() {\n    super();\n    this._errors = [];\n  }\n  syntaxError(recognizer, offendingSymbol, line, column, message) {\n    this._errors.push({message, line, column});\n  }\n  getErrors() {\n    return this._errors;\n  }\n  hasErrors() {\n    return this._errors.length > 0;\n  }\n};\nvar ErrorListener_default = ErrorListener;\n\n// src/tokens.ts\nvar import_tokens_string = __toModule(require_tokens_string());\nvar tokens = import_tokens_string.default;\nvar TYPE_TOKENS = [\n  \"var\",\n  \"bool\",\n  \"address\",\n  \"string\",\n  \"Int\",\n  \"Uint\",\n  \"Byte\",\n  \"Fixed\",\n  \"UFixed\"\n];\nfunction rsplit(str, value) {\n  const index = str.lastIndexOf(value);\n  return [str.substring(0, index), str.substring(index + 1, str.length)];\n}\nfunction normalizeTokenType(value) {\n  if (value.endsWith(\"'\")) {\n    value = value.substring(0, value.length - 1);\n  }\n  if (value.startsWith(\"'\")) {\n    value = value.substring(1, value.length);\n  }\n  return value;\n}\nfunction getTokenType(value) {\n  if (value === \"Identifier\" || value === \"from\") {\n    return \"Identifier\";\n  } else if (value === \"TrueLiteral\" || value === \"FalseLiteral\") {\n    return \"Boolean\";\n  } else if (value === \"VersionLiteral\") {\n    return \"Version\";\n  } else if (value === \"StringLiteral\") {\n    return \"String\";\n  } else if (TYPE_TOKENS.includes(value)) {\n    return \"Type\";\n  } else if (value === \"NumberUnit\") {\n    return \"Subdenomination\";\n  } else if (value === \"DecimalNumber\") {\n    return \"Numeric\";\n  } else if (value === \"HexLiteral\") {\n    return \"Hex\";\n  } else if (value === \"ReservedKeyword\") {\n    return \"Reserved\";\n  } else if (/^\\W+$/.test(value)) {\n    return \"Punctuator\";\n  } else {\n    return \"Keyword\";\n  }\n}\nfunction getTokenTypeMap() {\n  return tokens.split(\"\\n\").map((line) => rsplit(line, \"=\")).reduce((acum, [value, key]) => {\n    acum[parseInt(key, 10)] = normalizeTokenType(value);\n    return acum;\n  }, {});\n}\nfunction buildTokenList(tokensArg, options) {\n  const tokenTypes = getTokenTypeMap();\n  const result = tokensArg.map((token) => {\n    var _a, _b;\n    const type = getTokenType(tokenTypes[token.type]);\n    const node = {type, value: token.text};\n    if (options.range === true) {\n      node.range = [token.startIndex, token.stopIndex + 1];\n    }\n    if (options.loc === true) {\n      node.loc = {\n        start: {line: token.line, column: token.charPositionInLine},\n        end: {line: token.line, column: token.charPositionInLine + ((_b = (_a = token.text) == null ? void 0 : _a.length) != null ? _b : 0)}\n      };\n    }\n    return node;\n  });\n  return result;\n}\n\n// src/parser.ts\nvar ParserError = class extends Error {\n  constructor(args) {\n    super();\n    const {message, line, column} = args.errors[0];\n    this.message = `${message} (${line}:${column})`;\n    this.errors = args.errors;\n    if (Error.captureStackTrace !== void 0) {\n      Error.captureStackTrace(this, this.constructor);\n    } else {\n      this.stack = new Error().stack;\n    }\n  }\n};\nfunction tokenize(input, options = {}) {\n  const inputStream = new import_antlr4ts.ANTLRInputStream(input);\n  const lexer = new SolidityLexer(inputStream);\n  return buildTokenList(lexer.getAllTokens(), options);\n}\nfunction parse(input, options = {}) {\n  const inputStream = new import_antlr4ts.ANTLRInputStream(input);\n  const lexer = new SolidityLexer(inputStream);\n  const tokenStream = new import_antlr4ts.CommonTokenStream(lexer);\n  const parser = new SolidityParser(tokenStream);\n  const listener = new ErrorListener_default();\n  lexer.removeErrorListeners();\n  lexer.addErrorListener(listener);\n  parser.removeErrorListeners();\n  parser.addErrorListener(listener);\n  parser.buildParseTree = true;\n  const sourceUnit = parser.sourceUnit();\n  const astBuilder = new ASTBuilder(options);\n  astBuilder.visit(sourceUnit);\n  const ast = astBuilder.result;\n  if (ast === null) {\n    throw new Error(\"ast should never be null\");\n  }\n  let tokenList = [];\n  if (options.tokens === true) {\n    tokenList = buildTokenList(tokenStream.getTokens(), options);\n  }\n  if (options.tolerant !== true && listener.hasErrors()) {\n    throw new ParserError({errors: listener.getErrors()});\n  }\n  if (options.tolerant === true && listener.hasErrors()) {\n    ast.errors = listener.getErrors();\n  }\n  if (options.tokens === true) {\n    ast.tokens = tokenList;\n  }\n  return ast;\n}\nfunction _isASTNode(node) {\n  if (typeof node !== \"object\" || node === null) {\n    return false;\n  }\n  const nodeAsAny = node;\n  if (Object.prototype.hasOwnProperty.call(nodeAsAny, \"type\") && typeof nodeAsAny.type === \"string\") {\n    return astNodeTypes.includes(nodeAsAny.type);\n  }\n  return false;\n}\nfunction visit(node, visitor, nodeParent) {\n  if (Array.isArray(node)) {\n    node.forEach((child) => visit(child, visitor, nodeParent));\n  }\n  if (!_isASTNode(node))\n    return;\n  let cont = true;\n  if (visitor[node.type] !== void 0) {\n    cont = visitor[node.type](node, nodeParent);\n  }\n  if (cont === false)\n    return;\n  for (const prop in node) {\n    if (Object.prototype.hasOwnProperty.call(node, prop)) {\n      visit(node[prop], visitor, node);\n    }\n  }\n  const selector = node.type + \":exit\";\n  if (visitor[selector] !== void 0) {\n    visitor[selector](node, nodeParent);\n  }\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n/*! https://mths.be/codepointat v0.2.0 by @mathias */\n/*! https://mths.be/fromcodepoint v0.2.1 by @mathias */\n//# sourceMappingURL=index.cjs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWdhcy1yZXBvcnRlci9ub2RlX21vZHVsZXMvQHNvbGlkaXR5LXBhcnNlci9wYXJzZXIvZGlzdC9pbmRleC5janMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSw0REFBNEQ7QUFDekk7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFlBQVk7QUFDOUUsdURBQXVELFlBQVk7QUFDbkU7QUFDQTtBQUNBLDZCQUE2QixpQ0FBaUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpR0FBaUc7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsc0VBQXNFLDhDQUE4QyxHQUFHLGlDQUFpQztBQUMzUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVELENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywwREFBMEQ7QUFDN0QsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx1REFBdUQ7QUFDMUQsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsbUVBQW1FO0FBQ3RFLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw2REFBNkQ7QUFDaEUsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhDQUE4QztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDRFQUE0RTtBQUMvRSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEVBQUUsV0FBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGlEQUFpRDtBQUNwRCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsK0NBQStDO0FBQ2xELENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcscUZBQXFGO0FBQ3hGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxJQUFJO0FBQzdDO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVztBQUMxQyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxpR0FBaUc7QUFDcEcsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxrRkFBa0Y7QUFDckYsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQSxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx1REFBdUQ7QUFDMUQsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLG1FQUFtRTtBQUN0RTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUssR0FBRyxvQkFBb0IsRUFBRSxJQUFJO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkJBQTZCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHlDQUF5QztBQUM1QztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtCQUErQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFdBQVcsU0FBUyxXQUFXO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDZDQUE2QztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFlBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxVQUFVO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNCQUFzQixLQUFLLDZCQUE2QjtBQUN6RjtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9CQUFvQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw4Q0FBOEMsWUFBWSxPQUFPO0FBQ3ZHLFlBQVk7QUFDWixnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9DQUFvQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxtRkFBbUY7QUFDdEY7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDRFQUE0RTtBQUMvRSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcscUZBQXFGO0FBQ3hGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw0RUFBNEU7QUFDL0UsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG1EQUFtRDtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHlFQUF5RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHlFQUF5RTtBQUM1RSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQ0FBb0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxvQkFBb0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxvQkFBb0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsb0JBQW9CO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEVBQUUsYUFBYSxFQUFFLGFBQWEsRUFBRSxhQUFhLEVBQUUsYUFBYSxHQUFHO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsNERBQTREO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxTQUFTLFlBQVksb0NBQW9DO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsTUFBTSxZQUFZLGtDQUFrQztBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrQkFBK0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1Q0FBdUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDBCQUEwQix1Q0FBdUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2QkFBNkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSw0QkFBNEIsK0JBQStCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQ0FBaUM7QUFDekQ7QUFDQTtBQUNBLHdCQUF3QixpQ0FBaUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUNBQWlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdDQUF3QztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3Q0FBd0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQ0FBK0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0NBQStDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJDQUEyQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQ0FBMkM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0JBQStCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdDQUF3QztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsTUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsTUFBTTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQSxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvQkFBb0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsNEVBQTRFO0FBQy9FLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQSxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZ0VBQWdFO0FBQ25FLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHVDQUF1QztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csV0FBVztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBDQUEwQyxRQUFRLGtCQUFrQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0UkFBNFI7QUFDNVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE1BQU07QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHFHQUFxRztBQUN4RyxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdjQUFnYztBQUMvYztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLHlEQUF5RCxFQUFFO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEJBQTRCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsNkRBQTZEO0FBQ2hFLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTLGNBQWMsZ0JBQWdCLFdBQVcsS0FBSztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUyxXQUFXLEtBQUs7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFNBQVMsV0FBVyxLQUFLO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVUsR0FBRyxTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVELENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxLQUFLLElBQUksR0FBRyxRQUFRLGlCQUFpQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWix3REFBd0QsS0FBSyx3QkFBd0IsUUFBUTtBQUM3RjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsS0FBSyxnQ0FBZ0MsSUFBSTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQ0FBbUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUNBQWlDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBLFFBQVE7QUFDUiwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNDQUFzQztBQUN2RCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsT0FBTyxxQ0FBcUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOENBQThDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4QkFBOEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxPQUFPLGVBQWU7QUFDdEIsT0FBTyxpQkFBaUI7QUFDeEIsT0FBTyxhQUFhO0FBQ3BCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsT0FBTyxlQUFlO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDBCQUEwQiw2QkFBNkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBLHFDQUFxQyxtQkFBbUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLE9BQU8sZUFBZTtBQUN0QixPQUFPLGFBQWE7QUFDcEIsT0FBTyxnQ0FBZ0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsT0FBTyxlQUFlO0FBQ3RCLE9BQU8sVUFBVTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxPQUFPLGVBQWU7QUFDdEIsT0FBTywrQ0FBK0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLE9BQU8sVUFBVTtBQUNqQixPQUFPLGtCQUFrQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsT0FBTyxxQ0FBcUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx3QkFBd0IsOEJBQThCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0JBQW9CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxPQUFPLG1CQUFtQjtBQUMxQixPQUFPLGVBQWU7QUFDdEIsT0FBTyxXQUFXO0FBQ2xCLE9BQU8sYUFBYTtBQUNwQixPQUFPLGVBQWU7QUFDdEIsT0FBTyxtRkFBbUY7QUFDMUYsT0FBTyxpRkFBaUY7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrQkFBK0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsT0FBTyxhQUFhO0FBQ3BCLE9BQU8sZUFBZTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxPQUFPLGVBQWU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixPQUFPLGFBQWE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlDQUFpQztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOEJBQThCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0JBQXNCLDhCQUE4QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLENBQUM7O0FBRUQ7QUFDQTtBQUNBLE9BQU8sZUFBZTtBQUN0QixPQUFPLHNCQUFzQjtBQUM3QixPQUFPLG9CQUFvQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxPQUFPLHFCQUFxQjtBQUM1QixPQUFPLFVBQVU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpREFBaUQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0NBQW9DO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrRkFBa0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsT0FBTyxlQUFlO0FBQ3RCO0FBQ0E7QUFDQSxPQUFPLDZDQUE2QztBQUNwRCxPQUFPLDJCQUEyQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxpQkFBaUI7QUFDeEIsT0FBTyxPQUFPO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsT0FBTyxjQUFjO0FBQ3JCLE9BQU8sd0JBQXdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsT0FBTyxVQUFVO0FBQ2pCLE9BQU8sY0FBYztBQUNyQixPQUFPLDRCQUE0QjtBQUNuQyxPQUFPLFdBQVc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxPQUFPLFdBQVc7QUFDbEIsT0FBTywwQkFBMEI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4QkFBOEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLE9BQU8sZUFBZTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxPQUFPLFVBQVU7QUFDakIsT0FBTyxxQkFBcUI7QUFDNUIsT0FBTyxtQkFBbUI7QUFDMUIsT0FBTyw0QkFBNEI7QUFDbkMsT0FBTyxlQUFlO0FBQ3RCLE9BQU8sZ0JBQWdCO0FBQ3ZCLE9BQU8sWUFBWTtBQUNuQjtBQUNBLE9BQU8sMkJBQTJCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0NBQWtDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsbUNBQW1DO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0Esd0NBQXdDLG1EQUFtRDtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiw0Q0FBNEMsc0RBQXNEO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJCQUEyQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msd0NBQXdDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUNBQXFDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx5Q0FBeUM7QUFDM0UsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxvQ0FBb0MseUNBQXlDO0FBQzdFLFVBQVU7QUFDVixvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0EsUUFBUTtBQUNSLGtDQUFrQyxvQkFBb0I7QUFDdEQsUUFBUTtBQUNSO0FBQ0E7QUFDQSxzQ0FBc0Msb0JBQW9CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxPQUFPLHVDQUF1QztBQUM5QztBQUNBLE9BQU8sZUFBZTtBQUN0QixPQUFPLGNBQWM7QUFDckIsT0FBTyxXQUFXO0FBQ2xCLE9BQU8saUJBQWlCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0EsK0JBQStCLHNDQUFzQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLE9BQU8sK0JBQStCO0FBQ3RDO0FBQ0EsT0FBTyx5QkFBeUI7QUFDaEMsT0FBTyxXQUFXO0FBQ2xCLE9BQU8sY0FBYztBQUNyQixPQUFPLGVBQWU7QUFDdEIsT0FBTywwQkFBMEI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGlCQUFpQjtBQUN4QixPQUFPLG1CQUFtQjtBQUMxQixPQUFPLFVBQVU7QUFDakIsT0FBTywrRUFBK0U7QUFDdEYsT0FBTyw2Q0FBNkM7QUFDcEQsT0FBTyw4REFBOEQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtCQUErQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4QkFBOEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0EsaUNBQWlDLG1EQUFtRDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdDQUFnQztBQUN2RSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyQkFBMkI7QUFDckQ7QUFDQTtBQUNBLDJDQUEyQyxzREFBc0Q7QUFDakc7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQSxVQUFVO0FBQ1Y7QUFDQSw2QkFBNkIsNkNBQTZDO0FBQzFFO0FBQ0EsUUFBUTtBQUNSLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBLFVBQVU7QUFDVjtBQUNBLDZCQUE2Qiw2Q0FBNkM7QUFDMUU7QUFDQSxRQUFRO0FBQ1IsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUNBQXFDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixDQUFDOztBQUVEO0FBQ0E7QUFDQSxPQUFPLFdBQVc7QUFDbEIsT0FBTyxVQUFVO0FBQ2pCLE9BQU8sb0JBQW9CO0FBQzNCLE9BQU8sY0FBYztBQUNyQixPQUFPLGVBQWU7QUFDdEIsT0FBTyxvQkFBb0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsVUFBVSxNQUFNO0FBQzlELENBQUM7O0FBRUQ7QUFDQTtBQUNBLE9BQU8sUUFBUTtBQUNmLE9BQU8sK0JBQStCO0FBQ3RDLE9BQU8sVUFBVTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVUsR0FBRyxTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBLGVBQWUsRUFBRSw0QkFBNEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsT0FBTyxlQUFlO0FBQ3RCLE9BQU8sc0pBQXNKO0FBQzdKLE9BQU8sVUFBVTtBQUNqQixPQUFPLHVCQUF1QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLE9BQU8sZUFBZTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsT0FBTyxlQUFlO0FBQ3RCO0FBQ0EsT0FBTyxVQUFVO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxPQUFPLGVBQWU7QUFDdEIsT0FBTyx3REFBd0Q7QUFDL0Q7QUFDQSxPQUFPLHNCQUFzQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVDQUF1QztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osc0JBQXNCLGtEQUEwQixDQUFDLDhDQUFvQjtBQUNyRTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsME1BQTBNLG9RQUFvUSxRQUFRO0FBQ3RkO0FBQ0EsNGhCQUE0aEIsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUNwaUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkpBQTJKLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsa0JBQWtCLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQ3ZNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxzRkFBc0YsVUFBVSxHQUFHLDhYQUE4WCxZQUFZLDhKQUE4SixnQkFBZ0Isd0JBQXdCLHVPQUF1TyxnTUFBZ00sTUFBTTtBQUNocUMsdWtCQUF1a0IsZ1dBQWdXLFdBQVcsczREQUFzNEQsNHNCQUE0c0IsaXNEQUFpc0QsK2ZBQStmLDhpQkFBOGlCLHF6QkFBcXpCLG1uSEFBbW5ILHcxQ0FBdzFDO0FBQ2wvWCwybkNBQTJuQyw0akRBQTRqRCwrbkRBQStuRCwrRkFBK0Ysa0hBQWtILGtIQUFrSCxrSEFBa0gsa0hBQWtILGtIQUFrSCxrSEFBa0gsa0hBQWtILGtIQUFrSCw0RUFBNEUsc0NBQXNDLHFJQUFxSSxxSUFBcUkscUlBQXFJLHFJQUFxSSxxSUFBcUkscUlBQXFJLHFJQUFxSSxxSUFBcUkscUlBQXFJLCtGQUErRixzQ0FBc0MscUlBQXFJLHFJQUFxSSxxSUFBcUkscUlBQXFJLHFJQUFxSSxxSUFBcUkscUlBQXFJLHFJQUFxSSxxSUFBcUksK0ZBQStGLHNDQUFzQyxxSUFBcUkscUlBQXFJLHl6RkFBeXpGLGlnQkFBaWdCLHFJQUFxSSwyckVBQTJyRSxzQ0FBc0MseWNBQXljO0FBQzkyYyw2eUJBQTZ5Qixnb0JBQWdvQjtBQUM3NkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK1ZBQStWLDQrREFBNCtELEVBQUUsRUFBRSwrbE1BQStsTTtBQUM5NlEsOEZBQThGLHM2QkFBczZCLDRzQkFBNHNCLCtrRkFBK2tGLHVyRUFBdXJFLG9FQUFvRSwrbkdBQStuRztBQUN6cFQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHlDQUF5QztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtREFBbUQ7QUFDbkUsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsc0JBQXNCLFNBQVMsR0FBRyxLQUFLLEdBQUcsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkJBQTZCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FLTDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy9ldGgtZ2FzLXJlcG9ydGVyL25vZGVfbW9kdWxlcy9Ac29saWRpdHktcGFyc2VyL3BhcnNlci9kaXN0L2luZGV4LmNqcy5qcz80OWRlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7ZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWV9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19vYmpTcHJlYWQgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gKCkgPT4gKG1vZCB8fCBjYigobW9kID0ge2V4cG9ydHM6IHt9fSkuZXhwb3J0cywgbW9kKSwgbW9kLmV4cG9ydHMpO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHtnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZX0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7Z2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8ge2dldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlfSA6IHt2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZX0pKSwgbW9kdWxlMik7XG59O1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvQU5UTFJFcnJvckxpc3RlbmVyLmpzXG52YXIgcmVxdWlyZV9BTlRMUkVycm9yTGlzdGVuZXIgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9BTlRMUkVycm9yU3RyYXRlZ3kuanNcbnZhciByZXF1aXJlX0FOVExSRXJyb3JTdHJhdGVneSA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL0RlY29yYXRvcnMuanNcbnZhciByZXF1aXJlX0RlY29yYXRvcnMgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLlN1cHByZXNzV2FybmluZ3MgPSBleHBvcnRzLk92ZXJyaWRlID0gZXhwb3J0cy5OdWxsYWJsZSA9IGV4cG9ydHMuTm90TnVsbCA9IHZvaWQgMDtcbiAgZnVuY3Rpb24gTm90TnVsbCh0YXJnZXQsIHByb3BlcnR5S2V5LCBwcm9wZXJ0eURlc2NyaXB0b3IpIHtcbiAgfVxuICBleHBvcnRzLk5vdE51bGwgPSBOb3ROdWxsO1xuICBmdW5jdGlvbiBOdWxsYWJsZSh0YXJnZXQsIHByb3BlcnR5S2V5LCBwcm9wZXJ0eURlc2NyaXB0b3IpIHtcbiAgfVxuICBleHBvcnRzLk51bGxhYmxlID0gTnVsbGFibGU7XG4gIGZ1bmN0aW9uIE92ZXJyaWRlKHRhcmdldCwgcHJvcGVydHlLZXksIHByb3BlcnR5RGVzY3JpcHRvcikge1xuICB9XG4gIGV4cG9ydHMuT3ZlcnJpZGUgPSBPdmVycmlkZTtcbiAgZnVuY3Rpb24gU3VwcHJlc3NXYXJuaW5ncyhvcHRpb25zKSB7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKSA9PiB7XG4gICAgfTtcbiAgfVxuICBleHBvcnRzLlN1cHByZXNzV2FybmluZ3MgPSBTdXBwcmVzc1dhcm5pbmdzO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9JbnRTdHJlYW0uanNcbnZhciByZXF1aXJlX0ludFN0cmVhbSA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuSW50U3RyZWFtID0gdm9pZCAwO1xuICB2YXIgSW50U3RyZWFtO1xuICAoZnVuY3Rpb24oSW50U3RyZWFtMikge1xuICAgIEludFN0cmVhbTIuRU9GID0gLTE7XG4gICAgSW50U3RyZWFtMi5VTktOT1dOX1NPVVJDRV9OQU1FID0gXCI8dW5rbm93bj5cIjtcbiAgfSkoSW50U3RyZWFtID0gZXhwb3J0cy5JbnRTdHJlYW0gfHwgKGV4cG9ydHMuSW50U3RyZWFtID0ge30pKTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvQU5UTFJJbnB1dFN0cmVhbS5qc1xudmFyIHJlcXVpcmVfQU5UTFJJbnB1dFN0cmVhbSA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5BTlRMUklucHV0U3RyZWFtID0gdm9pZCAwO1xuICB2YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgSW50U3RyZWFtXzEgPSByZXF1aXJlX0ludFN0cmVhbSgpO1xuICB2YXIgQU5UTFJJbnB1dFN0cmVhbTIgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgIHRoaXMucCA9IDA7XG4gICAgICB0aGlzLmRhdGEgPSBpbnB1dDtcbiAgICAgIHRoaXMubiA9IGlucHV0Lmxlbmd0aDtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICB0aGlzLnAgPSAwO1xuICAgIH1cbiAgICBjb25zdW1lKCkge1xuICAgICAgaWYgKHRoaXMucCA+PSB0aGlzLm4pIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuTEEoMSkgPT09IEludFN0cmVhbV8xLkludFN0cmVhbS5FT0YpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgY29uc3VtZSBFT0ZcIik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wIDwgdGhpcy5uKSB7XG4gICAgICAgIHRoaXMucCsrO1xuICAgICAgfVxuICAgIH1cbiAgICBMQShpKSB7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICBpKys7XG4gICAgICAgIGlmICh0aGlzLnAgKyBpIC0gMSA8IDApIHtcbiAgICAgICAgICByZXR1cm4gSW50U3RyZWFtXzEuSW50U3RyZWFtLkVPRjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMucCArIGkgLSAxID49IHRoaXMubikge1xuICAgICAgICByZXR1cm4gSW50U3RyZWFtXzEuSW50U3RyZWFtLkVPRjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnAgKyBpIC0gMSk7XG4gICAgfVxuICAgIExUKGkpIHtcbiAgICAgIHJldHVybiB0aGlzLkxBKGkpO1xuICAgIH1cbiAgICBnZXQgaW5kZXgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm47XG4gICAgfVxuICAgIG1hcmsoKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHJlbGVhc2UobWFya2VyKSB7XG4gICAgfVxuICAgIHNlZWsoaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA8PSB0aGlzLnApIHtcbiAgICAgICAgdGhpcy5wID0gaW5kZXg7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGluZGV4ID0gTWF0aC5taW4oaW5kZXgsIHRoaXMubik7XG4gICAgICB3aGlsZSAodGhpcy5wIDwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGdldFRleHQoaW50ZXJ2YWwpIHtcbiAgICAgIGxldCBzdGFydCA9IGludGVydmFsLmE7XG4gICAgICBsZXQgc3RvcCA9IGludGVydmFsLmI7XG4gICAgICBpZiAoc3RvcCA+PSB0aGlzLm4pIHtcbiAgICAgICAgc3RvcCA9IHRoaXMubiAtIDE7XG4gICAgICB9XG4gICAgICBsZXQgY291bnQgPSBzdG9wIC0gc3RhcnQgKyAxO1xuICAgICAgaWYgKHN0YXJ0ID49IHRoaXMubikge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmRhdGEuc3Vic3RyKHN0YXJ0LCBjb3VudCk7XG4gICAgfVxuICAgIGdldCBzb3VyY2VOYW1lKCkge1xuICAgICAgaWYgKCF0aGlzLm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIEludFN0cmVhbV8xLkludFN0cmVhbS5VTktOT1dOX1NPVVJDRV9OQU1FO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEFOVExSSW5wdXRTdHJlYW0yLnByb3RvdHlwZSwgXCJjb25zdW1lXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQU5UTFJJbnB1dFN0cmVhbTIucHJvdG90eXBlLCBcIkxBXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQU5UTFJJbnB1dFN0cmVhbTIucHJvdG90eXBlLCBcImluZGV4XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQU5UTFJJbnB1dFN0cmVhbTIucHJvdG90eXBlLCBcInNpemVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBBTlRMUklucHV0U3RyZWFtMi5wcm90b3R5cGUsIFwibWFya1wiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEFOVExSSW5wdXRTdHJlYW0yLnByb3RvdHlwZSwgXCJyZWxlYXNlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQU5UTFJJbnB1dFN0cmVhbTIucHJvdG90eXBlLCBcInNlZWtcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBBTlRMUklucHV0U3RyZWFtMi5wcm90b3R5cGUsIFwiZ2V0VGV4dFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEFOVExSSW5wdXRTdHJlYW0yLnByb3RvdHlwZSwgXCJzb3VyY2VOYW1lXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQU5UTFJJbnB1dFN0cmVhbTIucHJvdG90eXBlLCBcInRvU3RyaW5nXCIsIG51bGwpO1xuICBleHBvcnRzLkFOVExSSW5wdXRTdHJlYW0gPSBBTlRMUklucHV0U3RyZWFtMjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvYXRuL0FUTlN0YXRlLmpzXG52YXIgcmVxdWlyZV9BVE5TdGF0ZSA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5BVE5TdGF0ZSA9IHZvaWQgMDtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgQVROU3RhdGUgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLnN0YXRlTnVtYmVyID0gQVROU3RhdGUuSU5WQUxJRF9TVEFURV9OVU1CRVI7XG4gICAgICB0aGlzLnJ1bGVJbmRleCA9IDA7XG4gICAgICB0aGlzLmVwc2lsb25Pbmx5VHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICAgIHRoaXMudHJhbnNpdGlvbnMgPSBbXTtcbiAgICAgIHRoaXMub3B0aW1pemVkVHJhbnNpdGlvbnMgPSB0aGlzLnRyYW5zaXRpb25zO1xuICAgIH1cbiAgICBnZXRTdGF0ZU51bWJlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlTnVtYmVyO1xuICAgIH1cbiAgICBnZXQgbm9uU3RvcFN0YXRlTnVtYmVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGVOdW1iZXIoKTtcbiAgICB9XG4gICAgaGFzaENvZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZU51bWJlcjtcbiAgICB9XG4gICAgZXF1YWxzKG8pIHtcbiAgICAgIGlmIChvIGluc3RhbmNlb2YgQVROU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVOdW1iZXIgPT09IG8uc3RhdGVOdW1iZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBpc05vbkdyZWVkeUV4aXRTdGF0ZSgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKHRoaXMuc3RhdGVOdW1iZXIpO1xuICAgIH1cbiAgICBnZXRUcmFuc2l0aW9ucygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25zLnNsaWNlKDApO1xuICAgIH1cbiAgICBnZXQgbnVtYmVyT2ZUcmFuc2l0aW9ucygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25zLmxlbmd0aDtcbiAgICB9XG4gICAgYWRkVHJhbnNpdGlvbihlLCBpbmRleCkge1xuICAgICAgaWYgKHRoaXMudHJhbnNpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuZXBzaWxvbk9ubHlUcmFuc2l0aW9ucyA9IGUuaXNFcHNpbG9uO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmVwc2lsb25Pbmx5VHJhbnNpdGlvbnMgIT09IGUuaXNFcHNpbG9uKSB7XG4gICAgICAgIHRoaXMuZXBzaWxvbk9ubHlUcmFuc2l0aW9ucyA9IGZhbHNlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBVE4gc3RhdGUgXCIgKyB0aGlzLnN0YXRlTnVtYmVyICsgXCIgaGFzIGJvdGggZXBzaWxvbiBhbmQgbm9uLWVwc2lsb24gdHJhbnNpdGlvbnMuXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2l0aW9ucy5zcGxpY2UoaW5kZXggIT09IHZvaWQgMCA/IGluZGV4IDogdGhpcy50cmFuc2l0aW9ucy5sZW5ndGgsIDAsIGUpO1xuICAgIH1cbiAgICB0cmFuc2l0aW9uKGkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25zW2ldO1xuICAgIH1cbiAgICBzZXRUcmFuc2l0aW9uKGksIGUpIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbnNbaV0gPSBlO1xuICAgIH1cbiAgICByZW1vdmVUcmFuc2l0aW9uKGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9ucy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuICAgIH1cbiAgICBnZXQgb25seUhhc0Vwc2lsb25UcmFuc2l0aW9ucygpIHtcbiAgICAgIHJldHVybiB0aGlzLmVwc2lsb25Pbmx5VHJhbnNpdGlvbnM7XG4gICAgfVxuICAgIHNldFJ1bGVJbmRleChydWxlSW5kZXgpIHtcbiAgICAgIHRoaXMucnVsZUluZGV4ID0gcnVsZUluZGV4O1xuICAgIH1cbiAgICBnZXQgaXNPcHRpbWl6ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpbWl6ZWRUcmFuc2l0aW9ucyAhPT0gdGhpcy50cmFuc2l0aW9ucztcbiAgICB9XG4gICAgZ2V0IG51bWJlck9mT3B0aW1pemVkVHJhbnNpdGlvbnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpbWl6ZWRUcmFuc2l0aW9ucy5sZW5ndGg7XG4gICAgfVxuICAgIGdldE9wdGltaXplZFRyYW5zaXRpb24oaSkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW1pemVkVHJhbnNpdGlvbnNbaV07XG4gICAgfVxuICAgIGFkZE9wdGltaXplZFRyYW5zaXRpb24oZSkge1xuICAgICAgaWYgKCF0aGlzLmlzT3B0aW1pemVkKSB7XG4gICAgICAgIHRoaXMub3B0aW1pemVkVHJhbnNpdGlvbnMgPSBuZXcgQXJyYXkoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW1pemVkVHJhbnNpdGlvbnMucHVzaChlKTtcbiAgICB9XG4gICAgc2V0T3B0aW1pemVkVHJhbnNpdGlvbihpLCBlKSB7XG4gICAgICBpZiAoIXRoaXMuaXNPcHRpbWl6ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBBVE5TdGF0ZSBpcyBub3Qgb3B0aW1pemVkLlwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW1pemVkVHJhbnNpdGlvbnNbaV0gPSBlO1xuICAgIH1cbiAgICByZW1vdmVPcHRpbWl6ZWRUcmFuc2l0aW9uKGkpIHtcbiAgICAgIGlmICghdGhpcy5pc09wdGltaXplZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIEFUTlN0YXRlIGlzIG5vdCBvcHRpbWl6ZWQuXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpbWl6ZWRUcmFuc2l0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQVROU3RhdGUucHJvdG90eXBlLCBcImhhc2hDb2RlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQVROU3RhdGUucHJvdG90eXBlLCBcImVxdWFsc1wiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEFUTlN0YXRlLnByb3RvdHlwZSwgXCJ0b1N0cmluZ1wiLCBudWxsKTtcbiAgZXhwb3J0cy5BVE5TdGF0ZSA9IEFUTlN0YXRlO1xuICAoZnVuY3Rpb24oQVROU3RhdGUyKSB7XG4gICAgQVROU3RhdGUyLklOVkFMSURfU1RBVEVfTlVNQkVSID0gLTE7XG4gIH0pKEFUTlN0YXRlID0gZXhwb3J0cy5BVE5TdGF0ZSB8fCAoZXhwb3J0cy5BVE5TdGF0ZSA9IHt9KSk7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9BVE5TdGF0ZVR5cGUuanNcbnZhciByZXF1aXJlX0FUTlN0YXRlVHlwZSA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuQVROU3RhdGVUeXBlID0gdm9pZCAwO1xuICB2YXIgQVROU3RhdGVUeXBlO1xuICAoZnVuY3Rpb24oQVROU3RhdGVUeXBlMikge1xuICAgIEFUTlN0YXRlVHlwZTJbQVROU3RhdGVUeXBlMltcIklOVkFMSURfVFlQRVwiXSA9IDBdID0gXCJJTlZBTElEX1RZUEVcIjtcbiAgICBBVE5TdGF0ZVR5cGUyW0FUTlN0YXRlVHlwZTJbXCJCQVNJQ1wiXSA9IDFdID0gXCJCQVNJQ1wiO1xuICAgIEFUTlN0YXRlVHlwZTJbQVROU3RhdGVUeXBlMltcIlJVTEVfU1RBUlRcIl0gPSAyXSA9IFwiUlVMRV9TVEFSVFwiO1xuICAgIEFUTlN0YXRlVHlwZTJbQVROU3RhdGVUeXBlMltcIkJMT0NLX1NUQVJUXCJdID0gM10gPSBcIkJMT0NLX1NUQVJUXCI7XG4gICAgQVROU3RhdGVUeXBlMltBVE5TdGF0ZVR5cGUyW1wiUExVU19CTE9DS19TVEFSVFwiXSA9IDRdID0gXCJQTFVTX0JMT0NLX1NUQVJUXCI7XG4gICAgQVROU3RhdGVUeXBlMltBVE5TdGF0ZVR5cGUyW1wiU1RBUl9CTE9DS19TVEFSVFwiXSA9IDVdID0gXCJTVEFSX0JMT0NLX1NUQVJUXCI7XG4gICAgQVROU3RhdGVUeXBlMltBVE5TdGF0ZVR5cGUyW1wiVE9LRU5fU1RBUlRcIl0gPSA2XSA9IFwiVE9LRU5fU1RBUlRcIjtcbiAgICBBVE5TdGF0ZVR5cGUyW0FUTlN0YXRlVHlwZTJbXCJSVUxFX1NUT1BcIl0gPSA3XSA9IFwiUlVMRV9TVE9QXCI7XG4gICAgQVROU3RhdGVUeXBlMltBVE5TdGF0ZVR5cGUyW1wiQkxPQ0tfRU5EXCJdID0gOF0gPSBcIkJMT0NLX0VORFwiO1xuICAgIEFUTlN0YXRlVHlwZTJbQVROU3RhdGVUeXBlMltcIlNUQVJfTE9PUF9CQUNLXCJdID0gOV0gPSBcIlNUQVJfTE9PUF9CQUNLXCI7XG4gICAgQVROU3RhdGVUeXBlMltBVE5TdGF0ZVR5cGUyW1wiU1RBUl9MT09QX0VOVFJZXCJdID0gMTBdID0gXCJTVEFSX0xPT1BfRU5UUllcIjtcbiAgICBBVE5TdGF0ZVR5cGUyW0FUTlN0YXRlVHlwZTJbXCJQTFVTX0xPT1BfQkFDS1wiXSA9IDExXSA9IFwiUExVU19MT09QX0JBQ0tcIjtcbiAgICBBVE5TdGF0ZVR5cGUyW0FUTlN0YXRlVHlwZTJbXCJMT09QX0VORFwiXSA9IDEyXSA9IFwiTE9PUF9FTkRcIjtcbiAgfSkoQVROU3RhdGVUeXBlID0gZXhwb3J0cy5BVE5TdGF0ZVR5cGUgfHwgKGV4cG9ydHMuQVROU3RhdGVUeXBlID0ge30pKTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvUmVjb2duaXRpb25FeGNlcHRpb24uanNcbnZhciByZXF1aXJlX1JlY29nbml0aW9uRXhjZXB0aW9uID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5SZWNvZ25pdGlvbkV4Y2VwdGlvbiA9IHZvaWQgMDtcbiAgdmFyIFJlY29nbml0aW9uRXhjZXB0aW9uMiA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlY29nbml6ZXIsIGlucHV0LCBjdHgsIG1lc3NhZ2UpIHtcbiAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5fb2ZmZW5kaW5nU3RhdGUgPSAtMTtcbiAgICAgIHRoaXMuX3JlY29nbml6ZXIgPSByZWNvZ25pemVyO1xuICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgICB0aGlzLl9vZmZlbmRpbmdTdGF0ZSA9IHJlY29nbml6ZXIuc3RhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIGdldCBvZmZlbmRpbmdTdGF0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vZmZlbmRpbmdTdGF0ZTtcbiAgICB9XG4gICAgc2V0T2ZmZW5kaW5nU3RhdGUob2ZmZW5kaW5nU3RhdGUpIHtcbiAgICAgIHRoaXMuX29mZmVuZGluZ1N0YXRlID0gb2ZmZW5kaW5nU3RhdGU7XG4gICAgfVxuICAgIGdldCBleHBlY3RlZFRva2VucygpIHtcbiAgICAgIGlmICh0aGlzLl9yZWNvZ25pemVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWNvZ25pemVyLmF0bi5nZXRFeHBlY3RlZFRva2Vucyh0aGlzLl9vZmZlbmRpbmdTdGF0ZSwgdGhpcy5jdHgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgZ2V0IGNvbnRleHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdHg7XG4gICAgfVxuICAgIGdldCBpbnB1dFN0cmVhbSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlucHV0O1xuICAgIH1cbiAgICBnZXRPZmZlbmRpbmdUb2tlbihyZWNvZ25pemVyKSB7XG4gICAgICBpZiAocmVjb2duaXplciAmJiByZWNvZ25pemVyICE9PSB0aGlzLl9yZWNvZ25pemVyKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5vZmZlbmRpbmdUb2tlbjtcbiAgICB9XG4gICAgc2V0T2ZmZW5kaW5nVG9rZW4ocmVjb2duaXplciwgb2ZmZW5kaW5nVG9rZW4pIHtcbiAgICAgIGlmIChyZWNvZ25pemVyID09PSB0aGlzLl9yZWNvZ25pemVyKSB7XG4gICAgICAgIHRoaXMub2ZmZW5kaW5nVG9rZW4gPSBvZmZlbmRpbmdUb2tlbjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHJlY29nbml6ZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVjb2duaXplcjtcbiAgICB9XG4gIH07XG4gIGV4cG9ydHMuUmVjb2duaXRpb25FeGNlcHRpb24gPSBSZWNvZ25pdGlvbkV4Y2VwdGlvbjI7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9UcmFuc2l0aW9uLmpzXG52YXIgcmVxdWlyZV9UcmFuc2l0aW9uID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLlRyYW5zaXRpb24gPSB2b2lkIDA7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIFRyYW5zaXRpb24gPSBjbGFzcyBUcmFuc2l0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcbiAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXQgY2Fubm90IGJlIG51bGwuXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgfVxuICAgIGdldCBpc0Vwc2lsb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBsYWJlbCgpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9O1xuICBUcmFuc2l0aW9uLnNlcmlhbGl6YXRpb25OYW1lcyA9IFtcbiAgICBcIklOVkFMSURcIixcbiAgICBcIkVQU0lMT05cIixcbiAgICBcIlJBTkdFXCIsXG4gICAgXCJSVUxFXCIsXG4gICAgXCJQUkVESUNBVEVcIixcbiAgICBcIkFUT01cIixcbiAgICBcIkFDVElPTlwiLFxuICAgIFwiU0VUXCIsXG4gICAgXCJOT1RfU0VUXCIsXG4gICAgXCJXSUxEQ0FSRFwiLFxuICAgIFwiUFJFQ0VERU5DRVwiXG4gIF07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIFRyYW5zaXRpb24ucHJvdG90eXBlLCBcInRhcmdldFwiLCB2b2lkIDApO1xuICBUcmFuc2l0aW9uID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgVHJhbnNpdGlvbik7XG4gIGV4cG9ydHMuVHJhbnNpdGlvbiA9IFRyYW5zaXRpb247XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9BYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb24uanNcbnZhciByZXF1aXJlX0Fic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbiA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uID0gdm9pZCAwO1xuICB2YXIgVHJhbnNpdGlvbl8xID0gcmVxdWlyZV9UcmFuc2l0aW9uKCk7XG4gIHZhciBBYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb24gPSBjbGFzcyBleHRlbmRzIFRyYW5zaXRpb25fMS5UcmFuc2l0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcbiAgICAgIHN1cGVyKHRhcmdldCk7XG4gICAgfVxuICB9O1xuICBleHBvcnRzLkFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbiA9IEFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvbWlzYy9NdXJtdXJIYXNoLmpzXG52YXIgcmVxdWlyZV9NdXJtdXJIYXNoID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5NdXJtdXJIYXNoID0gdm9pZCAwO1xuICB2YXIgTXVybXVySGFzaDtcbiAgKGZ1bmN0aW9uKE11cm11ckhhc2gyKSB7XG4gICAgY29uc3QgREVGQVVMVF9TRUVEID0gMDtcbiAgICBmdW5jdGlvbiBpbml0aWFsaXplKHNlZWQgPSBERUZBVUxUX1NFRUQpIHtcbiAgICAgIHJldHVybiBzZWVkO1xuICAgIH1cbiAgICBNdXJtdXJIYXNoMi5pbml0aWFsaXplID0gaW5pdGlhbGl6ZTtcbiAgICBmdW5jdGlvbiB1cGRhdGUoaGFzaCwgdmFsdWUpIHtcbiAgICAgIGNvbnN0IGMxID0gMzQzMjkxODM1MztcbiAgICAgIGNvbnN0IGMyID0gNDYxODQ1OTA3O1xuICAgICAgY29uc3QgcjEgPSAxNTtcbiAgICAgIGNvbnN0IHIyID0gMTM7XG4gICAgICBjb25zdCBtID0gNTtcbiAgICAgIGNvbnN0IG4gPSAzODY0MjkyMTk2O1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSBoYXNoU3RyaW5nKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuaGFzaENvZGUoKTtcbiAgICAgIH1cbiAgICAgIGxldCBrID0gdmFsdWU7XG4gICAgICBrID0gTWF0aC5pbXVsKGssIGMxKTtcbiAgICAgIGsgPSBrIDw8IHIxIHwgayA+Pj4gMzIgLSByMTtcbiAgICAgIGsgPSBNYXRoLmltdWwoaywgYzIpO1xuICAgICAgaGFzaCA9IGhhc2ggXiBrO1xuICAgICAgaGFzaCA9IGhhc2ggPDwgcjIgfCBoYXNoID4+PiAzMiAtIHIyO1xuICAgICAgaGFzaCA9IE1hdGguaW11bChoYXNoLCBtKSArIG47XG4gICAgICByZXR1cm4gaGFzaCAmIDQyOTQ5NjcyOTU7XG4gICAgfVxuICAgIE11cm11ckhhc2gyLnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICBmdW5jdGlvbiBmaW5pc2goaGFzaCwgbnVtYmVyT2ZXb3Jkcykge1xuICAgICAgaGFzaCA9IGhhc2ggXiBudW1iZXJPZldvcmRzICogNDtcbiAgICAgIGhhc2ggPSBoYXNoIF4gaGFzaCA+Pj4gMTY7XG4gICAgICBoYXNoID0gTWF0aC5pbXVsKGhhc2gsIDIyNDY4MjI1MDcpO1xuICAgICAgaGFzaCA9IGhhc2ggXiBoYXNoID4+PiAxMztcbiAgICAgIGhhc2ggPSBNYXRoLmltdWwoaGFzaCwgMzI2NjQ4OTkwOSk7XG4gICAgICBoYXNoID0gaGFzaCBeIGhhc2ggPj4+IDE2O1xuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICAgIE11cm11ckhhc2gyLmZpbmlzaCA9IGZpbmlzaDtcbiAgICBmdW5jdGlvbiBoYXNoQ29kZShkYXRhLCBzZWVkID0gREVGQVVMVF9TRUVEKSB7XG4gICAgICBsZXQgaGFzaCA9IGluaXRpYWxpemUoc2VlZCk7XG4gICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgIGZvciAobGV0IHZhbHVlIG9mIGRhdGEpIHtcbiAgICAgICAgaGFzaCA9IHVwZGF0ZShoYXNoLCB2YWx1ZSk7XG4gICAgICAgIGxlbmd0aCsrO1xuICAgICAgfVxuICAgICAgaGFzaCA9IGZpbmlzaChoYXNoLCBsZW5ndGgpO1xuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICAgIE11cm11ckhhc2gyLmhhc2hDb2RlID0gaGFzaENvZGU7XG4gICAgZnVuY3Rpb24gaGFzaFN0cmluZyhzdHIpIHtcbiAgICAgIGxldCBsZW4gPSBzdHIubGVuZ3RoO1xuICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGxldCBoYXNoID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGV0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaGFzaCA9IChoYXNoIDw8IDUgPj4+IDApIC0gaGFzaCArIGM7XG4gICAgICAgIGhhc2ggfD0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgfSkoTXVybXVySGFzaCA9IGV4cG9ydHMuTXVybXVySGFzaCB8fCAoZXhwb3J0cy5NdXJtdXJIYXNoID0ge30pKTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvbWlzYy9PYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IuanNcbnZhciByZXF1aXJlX09iamVjdEVxdWFsaXR5Q29tcGFyYXRvciA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5PYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IgPSB2b2lkIDA7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvciA9IGNsYXNzIHtcbiAgICBoYXNoQ29kZShvYmopIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmouaGFzaENvZGUoKTtcbiAgICB9XG4gICAgZXF1YWxzKGEsIGIpIHtcbiAgICAgIGlmIChhID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGIgPT0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhLmVxdWFscyhiKTtcbiAgICB9XG4gIH07XG4gIE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRSA9IG5ldyBPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IoKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvci5wcm90b3R5cGUsIFwiaGFzaENvZGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IucHJvdG90eXBlLCBcImVxdWFsc1wiLCBudWxsKTtcbiAgZXhwb3J0cy5PYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IgPSBPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3I7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL21pc2MvRGVmYXVsdEVxdWFsaXR5Q29tcGFyYXRvci5qc1xudmFyIHJlcXVpcmVfRGVmYXVsdEVxdWFsaXR5Q29tcGFyYXRvciA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5EZWZhdWx0RXF1YWxpdHlDb21wYXJhdG9yID0gdm9pZCAwO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBNdXJtdXJIYXNoXzEgPSByZXF1aXJlX011cm11ckhhc2goKTtcbiAgdmFyIE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvcl8xID0gcmVxdWlyZV9PYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IoKTtcbiAgdmFyIERlZmF1bHRFcXVhbGl0eUNvbXBhcmF0b3IgPSBjbGFzcyB7XG4gICAgaGFzaENvZGUob2JqKSB7XG4gICAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gTXVybXVySGFzaF8xLk11cm11ckhhc2guaGFzaENvZGUoW29ial0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvcl8xLk9iamVjdEVxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRS5oYXNoQ29kZShvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICBlcXVhbHMoYSwgYikge1xuICAgICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYiA9PSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgYSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3JfMS5PYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UuZXF1YWxzKGEsIGIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgRGVmYXVsdEVxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRSA9IG5ldyBEZWZhdWx0RXF1YWxpdHlDb21wYXJhdG9yKCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBEZWZhdWx0RXF1YWxpdHlDb21wYXJhdG9yLnByb3RvdHlwZSwgXCJoYXNoQ29kZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIERlZmF1bHRFcXVhbGl0eUNvbXBhcmF0b3IucHJvdG90eXBlLCBcImVxdWFsc1wiLCBudWxsKTtcbiAgZXhwb3J0cy5EZWZhdWx0RXF1YWxpdHlDb21wYXJhdG9yID0gRGVmYXVsdEVxdWFsaXR5Q29tcGFyYXRvcjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvbWlzYy9BcnJheTJESGFzaFNldC5qc1xudmFyIHJlcXVpcmVfQXJyYXkyREhhc2hTZXQgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuQXJyYXkyREhhc2hTZXQgPSB2b2lkIDA7XG4gIHZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuICB2YXIgRGVmYXVsdEVxdWFsaXR5Q29tcGFyYXRvcl8xID0gcmVxdWlyZV9EZWZhdWx0RXF1YWxpdHlDb21wYXJhdG9yKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIE11cm11ckhhc2hfMSA9IHJlcXVpcmVfTXVybXVySGFzaCgpO1xuICB2YXIgSU5JVEFMX0NBUEFDSVRZID0gMTY7XG4gIHZhciBMT0FEX0ZBQ1RPUiA9IDAuNzU7XG4gIHZhciBBcnJheTJESGFzaFNldCA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wYXJhdG9yT3JTZXQsIGluaXRpYWxDYXBhY2l0eSA9IElOSVRBTF9DQVBBQ0lUWSkge1xuICAgICAgdGhpcy5uID0gMDtcbiAgICAgIHRoaXMudGhyZXNob2xkID0gTWF0aC5mbG9vcihJTklUQUxfQ0FQQUNJVFkgKiBMT0FEX0ZBQ1RPUik7XG4gICAgICBpZiAoY29tcGFyYXRvck9yU2V0IGluc3RhbmNlb2YgQXJyYXkyREhhc2hTZXQpIHtcbiAgICAgICAgdGhpcy5jb21wYXJhdG9yID0gY29tcGFyYXRvck9yU2V0LmNvbXBhcmF0b3I7XG4gICAgICAgIHRoaXMuYnVja2V0cyA9IGNvbXBhcmF0b3JPclNldC5idWNrZXRzLnNsaWNlKDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYnVja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBidWNrZXQgPSB0aGlzLmJ1Y2tldHNbaV07XG4gICAgICAgICAgaWYgKGJ1Y2tldCkge1xuICAgICAgICAgICAgdGhpcy5idWNrZXRzW2ldID0gYnVja2V0LnNsaWNlKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm4gPSBjb21wYXJhdG9yT3JTZXQubjtcbiAgICAgICAgdGhpcy50aHJlc2hvbGQgPSBjb21wYXJhdG9yT3JTZXQudGhyZXNob2xkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb21wYXJhdG9yID0gY29tcGFyYXRvck9yU2V0IHx8IERlZmF1bHRFcXVhbGl0eUNvbXBhcmF0b3JfMS5EZWZhdWx0RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFO1xuICAgICAgICB0aGlzLmJ1Y2tldHMgPSB0aGlzLmNyZWF0ZUJ1Y2tldHMoaW5pdGlhbENhcGFjaXR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0T3JBZGQobykge1xuICAgICAgaWYgKHRoaXMubiA+IHRoaXMudGhyZXNob2xkKSB7XG4gICAgICAgIHRoaXMuZXhwYW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5nZXRPckFkZEltcGwobyk7XG4gICAgfVxuICAgIGdldE9yQWRkSW1wbChvKSB7XG4gICAgICBsZXQgYiA9IHRoaXMuZ2V0QnVja2V0KG8pO1xuICAgICAgbGV0IGJ1Y2tldCA9IHRoaXMuYnVja2V0c1tiXTtcbiAgICAgIGlmICghYnVja2V0KSB7XG4gICAgICAgIGJ1Y2tldCA9IFtvXTtcbiAgICAgICAgdGhpcy5idWNrZXRzW2JdID0gYnVja2V0O1xuICAgICAgICB0aGlzLm4rKztcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBleGlzdGluZyBvZiBidWNrZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcGFyYXRvci5lcXVhbHMoZXhpc3RpbmcsIG8pKSB7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBidWNrZXQucHVzaChvKTtcbiAgICAgIHRoaXMubisrO1xuICAgICAgcmV0dXJuIG87XG4gICAgfVxuICAgIGdldChvKSB7XG4gICAgICBpZiAobyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgbGV0IGIgPSB0aGlzLmdldEJ1Y2tldChvKTtcbiAgICAgIGxldCBidWNrZXQgPSB0aGlzLmJ1Y2tldHNbYl07XG4gICAgICBpZiAoIWJ1Y2tldCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgZSBvZiBidWNrZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcGFyYXRvci5lcXVhbHMoZSwgbykpIHtcbiAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgZ2V0QnVja2V0KG8pIHtcbiAgICAgIGxldCBoYXNoID0gdGhpcy5jb21wYXJhdG9yLmhhc2hDb2RlKG8pO1xuICAgICAgbGV0IGIgPSBoYXNoICYgdGhpcy5idWNrZXRzLmxlbmd0aCAtIDE7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgaGFzaENvZGUoKSB7XG4gICAgICBsZXQgaGFzaCA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLmluaXRpYWxpemUoKTtcbiAgICAgIGZvciAobGV0IGJ1Y2tldCBvZiB0aGlzLmJ1Y2tldHMpIHtcbiAgICAgICAgaWYgKGJ1Y2tldCA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbyBvZiBidWNrZXQpIHtcbiAgICAgICAgICBpZiAobyA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaGFzaCA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLmNvbXBhcmF0b3IuaGFzaENvZGUobykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBoYXNoID0gTXVybXVySGFzaF8xLk11cm11ckhhc2guZmluaXNoKGhhc2gsIHRoaXMuc2l6ZSk7XG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gICAgZXF1YWxzKG8pIHtcbiAgICAgIGlmIChvID09PSB0aGlzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCEobyBpbnN0YW5jZW9mIEFycmF5MkRIYXNoU2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoby5zaXplICE9PSB0aGlzLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbGV0IHNhbWUgPSB0aGlzLmNvbnRhaW5zQWxsKG8pO1xuICAgICAgcmV0dXJuIHNhbWU7XG4gICAgfVxuICAgIGV4cGFuZCgpIHtcbiAgICAgIGxldCBvbGQgPSB0aGlzLmJ1Y2tldHM7XG4gICAgICBsZXQgbmV3Q2FwYWNpdHkgPSB0aGlzLmJ1Y2tldHMubGVuZ3RoICogMjtcbiAgICAgIGxldCBuZXdUYWJsZSA9IHRoaXMuY3JlYXRlQnVja2V0cyhuZXdDYXBhY2l0eSk7XG4gICAgICB0aGlzLmJ1Y2tldHMgPSBuZXdUYWJsZTtcbiAgICAgIHRoaXMudGhyZXNob2xkID0gTWF0aC5mbG9vcihuZXdDYXBhY2l0eSAqIExPQURfRkFDVE9SKTtcbiAgICAgIGxldCBvbGRTaXplID0gdGhpcy5zaXplO1xuICAgICAgZm9yIChsZXQgYnVja2V0IG9mIG9sZCkge1xuICAgICAgICBpZiAoIWJ1Y2tldCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG8gb2YgYnVja2V0KSB7XG4gICAgICAgICAgbGV0IGIgPSB0aGlzLmdldEJ1Y2tldChvKTtcbiAgICAgICAgICBsZXQgbmV3QnVja2V0ID0gdGhpcy5idWNrZXRzW2JdO1xuICAgICAgICAgIGlmICghbmV3QnVja2V0KSB7XG4gICAgICAgICAgICBuZXdCdWNrZXQgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuYnVja2V0c1tiXSA9IG5ld0J1Y2tldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV3QnVja2V0LnB1c2gobyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFzc2VydCh0aGlzLm4gPT09IG9sZFNpemUpO1xuICAgIH1cbiAgICBhZGQodCkge1xuICAgICAgbGV0IGV4aXN0aW5nID0gdGhpcy5nZXRPckFkZCh0KTtcbiAgICAgIHJldHVybiBleGlzdGluZyA9PT0gdDtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5uO1xuICAgIH1cbiAgICBnZXQgaXNFbXB0eSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm4gPT09IDA7XG4gICAgfVxuICAgIGNvbnRhaW5zKG8pIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5zRmFzdCh0aGlzLmFzRWxlbWVudFR5cGUobykpO1xuICAgIH1cbiAgICBjb250YWluc0Zhc3Qob2JqKSB7XG4gICAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0KG9iaikgIT0gbnVsbDtcbiAgICB9XG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgeWllbGQqIHRoaXMudG9BcnJheSgpO1xuICAgIH1cbiAgICB0b0FycmF5KCkge1xuICAgICAgY29uc3QgYSA9IG5ldyBBcnJheSh0aGlzLnNpemUpO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChsZXQgYnVja2V0IG9mIHRoaXMuYnVja2V0cykge1xuICAgICAgICBpZiAoYnVja2V0ID09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBvIG9mIGJ1Y2tldCkge1xuICAgICAgICAgIGlmIChvID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhW2krK10gPSBvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgY29udGFpbnNBbGwoY29sbGVjdGlvbikge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gaW5zdGFuY2VvZiBBcnJheTJESGFzaFNldCkge1xuICAgICAgICBsZXQgcyA9IGNvbGxlY3Rpb247XG4gICAgICAgIGZvciAobGV0IGJ1Y2tldCBvZiBzLmJ1Y2tldHMpIHtcbiAgICAgICAgICBpZiAoYnVja2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBvIG9mIGJ1Y2tldCkge1xuICAgICAgICAgICAgaWYgKG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5jb250YWluc0Zhc3QodGhpcy5hc0VsZW1lbnRUeXBlKG8pKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBvIG9mIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBpZiAoIXRoaXMuY29udGFpbnNGYXN0KHRoaXMuYXNFbGVtZW50VHlwZShvKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhZGRBbGwoYykge1xuICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IG8gb2YgYykge1xuICAgICAgICBsZXQgZXhpc3RpbmcgPSB0aGlzLmdldE9yQWRkKG8pO1xuICAgICAgICBpZiAoZXhpc3RpbmcgIT09IG8pIHtcbiAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgdGhpcy5idWNrZXRzID0gdGhpcy5jcmVhdGVCdWNrZXRzKElOSVRBTF9DQVBBQ0lUWSk7XG4gICAgICB0aGlzLm4gPSAwO1xuICAgICAgdGhpcy50aHJlc2hvbGQgPSBNYXRoLmZsb29yKElOSVRBTF9DQVBBQ0lUWSAqIExPQURfRkFDVE9SKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBcInt9XCI7XG4gICAgICB9XG4gICAgICBsZXQgYnVmID0gXCJ7XCI7XG4gICAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgICAgZm9yIChsZXQgYnVja2V0IG9mIHRoaXMuYnVja2V0cykge1xuICAgICAgICBpZiAoYnVja2V0ID09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBvIG9mIGJ1Y2tldCkge1xuICAgICAgICAgIGlmIChvID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZiArPSBcIiwgXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZiArPSBvLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJ1ZiArPSBcIn1cIjtcbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHRvVGFibGVTdHJpbmcoKSB7XG4gICAgICBsZXQgYnVmID0gXCJcIjtcbiAgICAgIGZvciAobGV0IGJ1Y2tldCBvZiB0aGlzLmJ1Y2tldHMpIHtcbiAgICAgICAgaWYgKGJ1Y2tldCA9PSBudWxsKSB7XG4gICAgICAgICAgYnVmICs9IFwibnVsbFxcblwiO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZiArPSBcIltcIjtcbiAgICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgbyBvZiBidWNrZXQpIHtcbiAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZiArPSBcIiBcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgYnVmICs9IFwiX1wiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWYgKz0gby50b1N0cmluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBidWYgKz0gXCJdXFxuXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICBhc0VsZW1lbnRUeXBlKG8pIHtcbiAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgICBjcmVhdGVCdWNrZXRzKGNhcGFjaXR5KSB7XG4gICAgICByZXR1cm4gbmV3IEFycmF5KGNhcGFjaXR5KTtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIEFycmF5MkRIYXNoU2V0LnByb3RvdHlwZSwgXCJjb21wYXJhdG9yXCIsIHZvaWQgMCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBBcnJheTJESGFzaFNldC5wcm90b3R5cGUsIFwiaGFzaENvZGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBBcnJheTJESGFzaFNldC5wcm90b3R5cGUsIFwiZXF1YWxzXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQXJyYXkyREhhc2hTZXQucHJvdG90eXBlLCBcImFkZFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEFycmF5MkRIYXNoU2V0LnByb3RvdHlwZSwgXCJzaXplXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQXJyYXkyREhhc2hTZXQucHJvdG90eXBlLCBcImlzRW1wdHlcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBBcnJheTJESGFzaFNldC5wcm90b3R5cGUsIFwiY29udGFpbnNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk51bGxhYmxlKVxuICBdLCBBcnJheTJESGFzaFNldC5wcm90b3R5cGUsIFwiY29udGFpbnNGYXN0XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQXJyYXkyREhhc2hTZXQucHJvdG90eXBlLCBTeW1ib2wuaXRlcmF0b3IsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQXJyYXkyREhhc2hTZXQucHJvdG90eXBlLCBcInRvQXJyYXlcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBBcnJheTJESGFzaFNldC5wcm90b3R5cGUsIFwiY29udGFpbnNBbGxcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBBcnJheTJESGFzaFNldC5wcm90b3R5cGUsIFwiYWRkQWxsXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQXJyYXkyREhhc2hTZXQucHJvdG90eXBlLCBcImNsZWFyXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQXJyYXkyREhhc2hTZXQucHJvdG90eXBlLCBcInRvU3RyaW5nXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuU3VwcHJlc3NXYXJuaW5ncyhcInVuY2hlY2tlZFwiKVxuICBdLCBBcnJheTJESGFzaFNldC5wcm90b3R5cGUsIFwiYXNFbGVtZW50VHlwZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLlN1cHByZXNzV2FybmluZ3MoXCJ1bmNoZWNrZWRcIilcbiAgXSwgQXJyYXkyREhhc2hTZXQucHJvdG90eXBlLCBcImNyZWF0ZUJ1Y2tldHNcIiwgbnVsbCk7XG4gIGV4cG9ydHMuQXJyYXkyREhhc2hTZXQgPSBBcnJheTJESGFzaFNldDtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvbWlzYy9BcnJheUVxdWFsaXR5Q29tcGFyYXRvci5qc1xudmFyIHJlcXVpcmVfQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3IgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3IgPSB2b2lkIDA7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIE11cm11ckhhc2hfMSA9IHJlcXVpcmVfTXVybXVySGFzaCgpO1xuICB2YXIgT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yXzEgPSByZXF1aXJlX09iamVjdEVxdWFsaXR5Q29tcGFyYXRvcigpO1xuICB2YXIgQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3IgPSBjbGFzcyB7XG4gICAgaGFzaENvZGUob2JqKSB7XG4gICAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gTXVybXVySGFzaF8xLk11cm11ckhhc2guaGFzaENvZGUob2JqLCAwKTtcbiAgICB9XG4gICAgZXF1YWxzKGEsIGIpIHtcbiAgICAgIGlmIChhID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGIgPT0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yXzEuT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFLmVxdWFscyhhW2ldLCBiW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuICBBcnJheUVxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRSA9IG5ldyBBcnJheUVxdWFsaXR5Q29tcGFyYXRvcigpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3IucHJvdG90eXBlLCBcImhhc2hDb2RlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3IucHJvdG90eXBlLCBcImVxdWFsc1wiLCBudWxsKTtcbiAgZXhwb3J0cy5BcnJheUVxdWFsaXR5Q29tcGFyYXRvciA9IEFycmF5RXF1YWxpdHlDb21wYXJhdG9yO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9taXNjL1V0aWxzLmpzXG52YXIgcmVxdWlyZV9VdGlscyA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMudG9DaGFyQXJyYXkgPSBleHBvcnRzLnRvTWFwID0gZXhwb3J0cy5lcXVhbHMgPSBleHBvcnRzLmpvaW4gPSBleHBvcnRzLmVzY2FwZVdoaXRlc3BhY2UgPSB2b2lkIDA7XG4gIGZ1bmN0aW9uIGVzY2FwZVdoaXRlc3BhY2UocywgZXNjYXBlU3BhY2VzKSB7XG4gICAgcmV0dXJuIGVzY2FwZVNwYWNlcyA/IHMucmVwbGFjZSgvIC8sIFwiXFx4QjdcIikgOiBzLnJlcGxhY2UoL1xcdC8sIFwiXFxcXHRcIikucmVwbGFjZSgvXFxuLywgXCJcXFxcblwiKS5yZXBsYWNlKC9cXHIvLCBcIlxcXFxyXCIpO1xuICB9XG4gIGV4cG9ydHMuZXNjYXBlV2hpdGVzcGFjZSA9IGVzY2FwZVdoaXRlc3BhY2U7XG4gIGZ1bmN0aW9uIGpvaW4zKGNvbGxlY3Rpb24sIHNlcGFyYXRvcikge1xuICAgIGxldCBidWYgPSBcIlwiO1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgZm9yIChsZXQgY3VycmVudCBvZiBjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZiArPSBzZXBhcmF0b3I7XG4gICAgICB9XG4gICAgICBidWYgKz0gY3VycmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuICBleHBvcnRzLmpvaW4gPSBqb2luMztcbiAgZnVuY3Rpb24gZXF1YWxzKHgsIHkpIHtcbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh4ID09PSB2b2lkIDAgfHwgeSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB4LmVxdWFscyh5KTtcbiAgfVxuICBleHBvcnRzLmVxdWFscyA9IGVxdWFscztcbiAgZnVuY3Rpb24gdG9NYXAoa2V5cykge1xuICAgIGxldCBtID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgbS5zZXQoa2V5c1tpXSwgaSk7XG4gICAgfVxuICAgIHJldHVybiBtO1xuICB9XG4gIGV4cG9ydHMudG9NYXAgPSB0b01hcDtcbiAgZnVuY3Rpb24gdG9DaGFyQXJyYXkzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gbmV3IFVpbnQxNkFycmF5KHN0ci5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0W2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RyLnRvQ2hhckFycmF5KCk7XG4gICAgfVxuICB9XG4gIGV4cG9ydHMudG9DaGFyQXJyYXkgPSB0b0NoYXJBcnJheTM7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9TZW1hbnRpY0NvbnRleHQuanNcbnZhciByZXF1aXJlX1NlbWFudGljQ29udGV4dCA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgdmFyIF9fcGFyYW0gPSBleHBvcnRzICYmIGV4cG9ydHMuX19wYXJhbSB8fCBmdW5jdGlvbihwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7XG4gICAgfTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5TZW1hbnRpY0NvbnRleHQgPSB2b2lkIDA7XG4gIHZhciBBcnJheTJESGFzaFNldF8xID0gcmVxdWlyZV9BcnJheTJESGFzaFNldCgpO1xuICB2YXIgQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3JfMSA9IHJlcXVpcmVfQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3IoKTtcbiAgdmFyIE11cm11ckhhc2hfMSA9IHJlcXVpcmVfTXVybXVySGFzaCgpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3JfMSA9IHJlcXVpcmVfT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yKCk7XG4gIHZhciBVdGlsczMgPSByZXF1aXJlX1V0aWxzKCk7XG4gIGZ1bmN0aW9uIG1heChpdGVtcykge1xuICAgIGxldCByZXN1bHQ7XG4gICAgZm9yIChsZXQgY3VycmVudCBvZiBpdGVtcykge1xuICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJlc3VsdCA9IGN1cnJlbnQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IGNvbXBhcmlzb24gPSByZXN1bHQuY29tcGFyZVRvKGN1cnJlbnQpO1xuICAgICAgaWYgKGNvbXBhcmlzb24gPCAwKSB7XG4gICAgICAgIHJlc3VsdCA9IGN1cnJlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZnVuY3Rpb24gbWluKGl0ZW1zKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBmb3IgKGxldCBjdXJyZW50IG9mIGl0ZW1zKSB7XG4gICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmVzdWx0ID0gY3VycmVudDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgY29tcGFyaXNvbiA9IHJlc3VsdC5jb21wYXJlVG8oY3VycmVudCk7XG4gICAgICBpZiAoY29tcGFyaXNvbiA+IDApIHtcbiAgICAgICAgcmVzdWx0ID0gY3VycmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB2YXIgU2VtYW50aWNDb250ZXh0ID0gY2xhc3Mge1xuICAgIHN0YXRpYyBnZXQgTk9ORSgpIHtcbiAgICAgIGlmIChTZW1hbnRpY0NvbnRleHQuX05PTkUgPT09IHZvaWQgMCkge1xuICAgICAgICBTZW1hbnRpY0NvbnRleHQuX05PTkUgPSBuZXcgU2VtYW50aWNDb250ZXh0LlByZWRpY2F0ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFNlbWFudGljQ29udGV4dC5fTk9ORTtcbiAgICB9XG4gICAgZXZhbFByZWNlZGVuY2UocGFyc2VyLCBwYXJzZXJDYWxsU3RhY2spIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGF0aWMgYW5kKGEsIGIpIHtcbiAgICAgIGlmICghYSB8fCBhID09PSBTZW1hbnRpY0NvbnRleHQuTk9ORSkge1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH1cbiAgICAgIGlmIChiID09PSBTZW1hbnRpY0NvbnRleHQuTk9ORSkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH1cbiAgICAgIGxldCByZXN1bHQgPSBuZXcgU2VtYW50aWNDb250ZXh0LkFORChhLCBiKTtcbiAgICAgIGlmIChyZXN1bHQub3BuZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQub3BuZHNbMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgb3IoYSwgYikge1xuICAgICAgaWYgKCFhKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfVxuICAgICAgaWYgKGEgPT09IFNlbWFudGljQ29udGV4dC5OT05FIHx8IGIgPT09IFNlbWFudGljQ29udGV4dC5OT05FKSB7XG4gICAgICAgIHJldHVybiBTZW1hbnRpY0NvbnRleHQuTk9ORTtcbiAgICAgIH1cbiAgICAgIGxldCByZXN1bHQgPSBuZXcgU2VtYW50aWNDb250ZXh0Lk9SKGEsIGIpO1xuICAgICAgaWYgKHJlc3VsdC5vcG5kcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5vcG5kc1swXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xuICBleHBvcnRzLlNlbWFudGljQ29udGV4dCA9IFNlbWFudGljQ29udGV4dDtcbiAgKGZ1bmN0aW9uKFNlbWFudGljQ29udGV4dDIpIHtcbiAgICBjb25zdCBBTkRfSEFTSENPREUgPSA0MDM2MzYxMztcbiAgICBjb25zdCBPUl9IQVNIQ09ERSA9IDQ4NjI3OTk3MztcbiAgICBmdW5jdGlvbiBmaWx0ZXJQcmVjZWRlbmNlUHJlZGljYXRlcyhjb2xsZWN0aW9uKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBjb2xsZWN0aW9uW2ldO1xuICAgICAgICBpZiAoY29udGV4dCBpbnN0YW5jZW9mIFNlbWFudGljQ29udGV4dDIuUHJlY2VkZW5jZVByZWRpY2F0ZSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGNvbnRleHQpO1xuICAgICAgICAgIGNvbGxlY3Rpb24uc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2xhc3MgUHJlZGljYXRlIGV4dGVuZHMgU2VtYW50aWNDb250ZXh0MiB7XG4gICAgICBjb25zdHJ1Y3RvcihydWxlSW5kZXggPSAtMSwgcHJlZEluZGV4ID0gLTEsIGlzQ3R4RGVwZW5kZW50ID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ydWxlSW5kZXggPSBydWxlSW5kZXg7XG4gICAgICAgIHRoaXMucHJlZEluZGV4ID0gcHJlZEluZGV4O1xuICAgICAgICB0aGlzLmlzQ3R4RGVwZW5kZW50ID0gaXNDdHhEZXBlbmRlbnQ7XG4gICAgICB9XG4gICAgICBldmFsKHBhcnNlciwgcGFyc2VyQ2FsbFN0YWNrKSB7XG4gICAgICAgIGxldCBsb2NhbGN0eCA9IHRoaXMuaXNDdHhEZXBlbmRlbnQgPyBwYXJzZXJDYWxsU3RhY2sgOiB2b2lkIDA7XG4gICAgICAgIHJldHVybiBwYXJzZXIuc2VtcHJlZChsb2NhbGN0eCwgdGhpcy5ydWxlSW5kZXgsIHRoaXMucHJlZEluZGV4KTtcbiAgICAgIH1cbiAgICAgIGhhc2hDb2RlKCkge1xuICAgICAgICBsZXQgaGFzaENvZGUgPSBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC5pbml0aWFsaXplKCk7XG4gICAgICAgIGhhc2hDb2RlID0gTXVybXVySGFzaF8xLk11cm11ckhhc2gudXBkYXRlKGhhc2hDb2RlLCB0aGlzLnJ1bGVJbmRleCk7XG4gICAgICAgIGhhc2hDb2RlID0gTXVybXVySGFzaF8xLk11cm11ckhhc2gudXBkYXRlKGhhc2hDb2RlLCB0aGlzLnByZWRJbmRleCk7XG4gICAgICAgIGhhc2hDb2RlID0gTXVybXVySGFzaF8xLk11cm11ckhhc2gudXBkYXRlKGhhc2hDb2RlLCB0aGlzLmlzQ3R4RGVwZW5kZW50ID8gMSA6IDApO1xuICAgICAgICBoYXNoQ29kZSA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLmZpbmlzaChoYXNoQ29kZSwgMyk7XG4gICAgICAgIHJldHVybiBoYXNoQ29kZTtcbiAgICAgIH1cbiAgICAgIGVxdWFscyhvYmopIHtcbiAgICAgICAgaWYgKCEob2JqIGluc3RhbmNlb2YgUHJlZGljYXRlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyA9PT0gb2JqKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucnVsZUluZGV4ID09PSBvYmoucnVsZUluZGV4ICYmIHRoaXMucHJlZEluZGV4ID09PSBvYmoucHJlZEluZGV4ICYmIHRoaXMuaXNDdHhEZXBlbmRlbnQgPT09IG9iai5pc0N0eERlcGVuZGVudDtcbiAgICAgIH1cbiAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyB0aGlzLnJ1bGVJbmRleCArIFwiOlwiICsgdGhpcy5wcmVkSW5kZXggKyBcIn0/XCI7XG4gICAgICB9XG4gICAgfVxuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gICAgXSwgUHJlZGljYXRlLnByb3RvdHlwZSwgXCJldmFsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gICAgXSwgUHJlZGljYXRlLnByb3RvdHlwZSwgXCJoYXNoQ29kZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICAgIF0sIFByZWRpY2F0ZS5wcm90b3R5cGUsIFwiZXF1YWxzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gICAgXSwgUHJlZGljYXRlLnByb3RvdHlwZSwgXCJ0b1N0cmluZ1wiLCBudWxsKTtcbiAgICBTZW1hbnRpY0NvbnRleHQyLlByZWRpY2F0ZSA9IFByZWRpY2F0ZTtcbiAgICBjbGFzcyBQcmVjZWRlbmNlUHJlZGljYXRlIGV4dGVuZHMgU2VtYW50aWNDb250ZXh0MiB7XG4gICAgICBjb25zdHJ1Y3RvcihwcmVjZWRlbmNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucHJlY2VkZW5jZSA9IHByZWNlZGVuY2U7XG4gICAgICB9XG4gICAgICBldmFsKHBhcnNlciwgcGFyc2VyQ2FsbFN0YWNrKSB7XG4gICAgICAgIHJldHVybiBwYXJzZXIucHJlY3ByZWQocGFyc2VyQ2FsbFN0YWNrLCB0aGlzLnByZWNlZGVuY2UpO1xuICAgICAgfVxuICAgICAgZXZhbFByZWNlZGVuY2UocGFyc2VyLCBwYXJzZXJDYWxsU3RhY2spIHtcbiAgICAgICAgaWYgKHBhcnNlci5wcmVjcHJlZChwYXJzZXJDYWxsU3RhY2ssIHRoaXMucHJlY2VkZW5jZSkpIHtcbiAgICAgICAgICByZXR1cm4gU2VtYW50aWNDb250ZXh0Mi5OT05FO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbXBhcmVUbyhvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZWNlZGVuY2UgLSBvLnByZWNlZGVuY2U7XG4gICAgICB9XG4gICAgICBoYXNoQ29kZSgpIHtcbiAgICAgICAgbGV0IGhhc2hDb2RlID0gMTtcbiAgICAgICAgaGFzaENvZGUgPSAzMSAqIGhhc2hDb2RlICsgdGhpcy5wcmVjZWRlbmNlO1xuICAgICAgICByZXR1cm4gaGFzaENvZGU7XG4gICAgICB9XG4gICAgICBlcXVhbHMob2JqKSB7XG4gICAgICAgIGlmICghKG9iaiBpbnN0YW5jZW9mIFByZWNlZGVuY2VQcmVkaWNhdGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzID09PSBvYmopIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcmVjZWRlbmNlID09PSBvYmoucHJlY2VkZW5jZTtcbiAgICAgIH1cbiAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyB0aGlzLnByZWNlZGVuY2UgKyBcIj49cHJlY30/XCI7XG4gICAgICB9XG4gICAgfVxuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gICAgXSwgUHJlY2VkZW5jZVByZWRpY2F0ZS5wcm90b3R5cGUsIFwiZXZhbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICAgIF0sIFByZWNlZGVuY2VQcmVkaWNhdGUucHJvdG90eXBlLCBcImV2YWxQcmVjZWRlbmNlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gICAgXSwgUHJlY2VkZW5jZVByZWRpY2F0ZS5wcm90b3R5cGUsIFwiY29tcGFyZVRvXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gICAgXSwgUHJlY2VkZW5jZVByZWRpY2F0ZS5wcm90b3R5cGUsIFwiaGFzaENvZGVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgICBdLCBQcmVjZWRlbmNlUHJlZGljYXRlLnByb3RvdHlwZSwgXCJlcXVhbHNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgICBdLCBQcmVjZWRlbmNlUHJlZGljYXRlLnByb3RvdHlwZSwgXCJ0b1N0cmluZ1wiLCBudWxsKTtcbiAgICBTZW1hbnRpY0NvbnRleHQyLlByZWNlZGVuY2VQcmVkaWNhdGUgPSBQcmVjZWRlbmNlUHJlZGljYXRlO1xuICAgIGNsYXNzIE9wZXJhdG9yIGV4dGVuZHMgU2VtYW50aWNDb250ZXh0MiB7XG4gICAgfVxuICAgIFNlbWFudGljQ29udGV4dDIuT3BlcmF0b3IgPSBPcGVyYXRvcjtcbiAgICBsZXQgQU5EID0gY2xhc3MgQU5EMiBleHRlbmRzIE9wZXJhdG9yIHtcbiAgICAgIGNvbnN0cnVjdG9yKGEsIGIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgbGV0IG9wZXJhbmRzID0gbmV3IEFycmF5MkRIYXNoU2V0XzEuQXJyYXkyREhhc2hTZXQoT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yXzEuT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFKTtcbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBBTkQyKSB7XG4gICAgICAgICAgb3BlcmFuZHMuYWRkQWxsKGEub3BuZHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wZXJhbmRzLmFkZChhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIEFORDIpIHtcbiAgICAgICAgICBvcGVyYW5kcy5hZGRBbGwoYi5vcG5kcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3BlcmFuZHMuYWRkKGIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3BuZHMgPSBvcGVyYW5kcy50b0FycmF5KCk7XG4gICAgICAgIGxldCBwcmVjZWRlbmNlUHJlZGljYXRlcyA9IGZpbHRlclByZWNlZGVuY2VQcmVkaWNhdGVzKHRoaXMub3BuZHMpO1xuICAgICAgICBsZXQgcmVkdWNlZCA9IG1pbihwcmVjZWRlbmNlUHJlZGljYXRlcyk7XG4gICAgICAgIGlmIChyZWR1Y2VkKSB7XG4gICAgICAgICAgdGhpcy5vcG5kcy5wdXNoKHJlZHVjZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnZXQgb3BlcmFuZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wbmRzO1xuICAgICAgfVxuICAgICAgZXF1YWxzKG9iaikge1xuICAgICAgICBpZiAodGhpcyA9PT0gb2JqKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEob2JqIGluc3RhbmNlb2YgQU5EMikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5RXF1YWxpdHlDb21wYXJhdG9yXzEuQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UuZXF1YWxzKHRoaXMub3BuZHMsIG9iai5vcG5kcyk7XG4gICAgICB9XG4gICAgICBoYXNoQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLmhhc2hDb2RlKHRoaXMub3BuZHMsIEFORF9IQVNIQ09ERSk7XG4gICAgICB9XG4gICAgICBldmFsKHBhcnNlciwgcGFyc2VyQ2FsbFN0YWNrKSB7XG4gICAgICAgIGZvciAobGV0IG9wbmQgb2YgdGhpcy5vcG5kcykge1xuICAgICAgICAgIGlmICghb3BuZC5ldmFsKHBhcnNlciwgcGFyc2VyQ2FsbFN0YWNrKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGV2YWxQcmVjZWRlbmNlKHBhcnNlciwgcGFyc2VyQ2FsbFN0YWNrKSB7XG4gICAgICAgIGxldCBkaWZmZXJzID0gZmFsc2U7XG4gICAgICAgIGxldCBvcGVyYW5kcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBjb250ZXh0IG9mIHRoaXMub3BuZHMpIHtcbiAgICAgICAgICBsZXQgZXZhbHVhdGVkID0gY29udGV4dC5ldmFsUHJlY2VkZW5jZShwYXJzZXIsIHBhcnNlckNhbGxTdGFjayk7XG4gICAgICAgICAgZGlmZmVycyA9IGRpZmZlcnMgfHwgZXZhbHVhdGVkICE9PSBjb250ZXh0O1xuICAgICAgICAgIGlmIChldmFsdWF0ZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlZCAhPT0gU2VtYW50aWNDb250ZXh0Mi5OT05FKSB7XG4gICAgICAgICAgICBvcGVyYW5kcy5wdXNoKGV2YWx1YXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZGlmZmVycykge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcGVyYW5kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gU2VtYW50aWNDb250ZXh0Mi5OT05FO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBvcGVyYW5kc1swXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBvcGVyYW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJlc3VsdCA9IFNlbWFudGljQ29udGV4dDIuYW5kKHJlc3VsdCwgb3BlcmFuZHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFV0aWxzMy5qb2luKHRoaXMub3BuZHMsIFwiJiZcIik7XG4gICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICAgIF0sIEFORC5wcm90b3R5cGUsIFwib3BlcmFuZHNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgICBdLCBBTkQucHJvdG90eXBlLCBcImVxdWFsc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICAgIF0sIEFORC5wcm90b3R5cGUsIFwiaGFzaENvZGVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgICBdLCBBTkQucHJvdG90eXBlLCBcImV2YWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgICBdLCBBTkQucHJvdG90eXBlLCBcImV2YWxQcmVjZWRlbmNlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gICAgXSwgQU5ELnByb3RvdHlwZSwgXCJ0b1N0cmluZ1wiLCBudWxsKTtcbiAgICBBTkQgPSBfX2RlY29yYXRlKFtcbiAgICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgICBdLCBBTkQpO1xuICAgIFNlbWFudGljQ29udGV4dDIuQU5EID0gQU5EO1xuICAgIGxldCBPUiA9IGNsYXNzIE9SMiBleHRlbmRzIE9wZXJhdG9yIHtcbiAgICAgIGNvbnN0cnVjdG9yKGEsIGIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgbGV0IG9wZXJhbmRzID0gbmV3IEFycmF5MkRIYXNoU2V0XzEuQXJyYXkyREhhc2hTZXQoT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yXzEuT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFKTtcbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBPUjIpIHtcbiAgICAgICAgICBvcGVyYW5kcy5hZGRBbGwoYS5vcG5kcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3BlcmFuZHMuYWRkKGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiIGluc3RhbmNlb2YgT1IyKSB7XG4gICAgICAgICAgb3BlcmFuZHMuYWRkQWxsKGIub3BuZHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wZXJhbmRzLmFkZChiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wbmRzID0gb3BlcmFuZHMudG9BcnJheSgpO1xuICAgICAgICBsZXQgcHJlY2VkZW5jZVByZWRpY2F0ZXMgPSBmaWx0ZXJQcmVjZWRlbmNlUHJlZGljYXRlcyh0aGlzLm9wbmRzKTtcbiAgICAgICAgbGV0IHJlZHVjZWQgPSBtYXgocHJlY2VkZW5jZVByZWRpY2F0ZXMpO1xuICAgICAgICBpZiAocmVkdWNlZCkge1xuICAgICAgICAgIHRoaXMub3BuZHMucHVzaChyZWR1Y2VkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2V0IG9wZXJhbmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcG5kcztcbiAgICAgIH1cbiAgICAgIGVxdWFscyhvYmopIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IG9iaikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKG9iaiBpbnN0YW5jZW9mIE9SMikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5RXF1YWxpdHlDb21wYXJhdG9yXzEuQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UuZXF1YWxzKHRoaXMub3BuZHMsIG9iai5vcG5kcyk7XG4gICAgICB9XG4gICAgICBoYXNoQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLmhhc2hDb2RlKHRoaXMub3BuZHMsIE9SX0hBU0hDT0RFKTtcbiAgICAgIH1cbiAgICAgIGV2YWwocGFyc2VyLCBwYXJzZXJDYWxsU3RhY2spIHtcbiAgICAgICAgZm9yIChsZXQgb3BuZCBvZiB0aGlzLm9wbmRzKSB7XG4gICAgICAgICAgaWYgKG9wbmQuZXZhbChwYXJzZXIsIHBhcnNlckNhbGxTdGFjaykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBldmFsUHJlY2VkZW5jZShwYXJzZXIsIHBhcnNlckNhbGxTdGFjaykge1xuICAgICAgICBsZXQgZGlmZmVycyA9IGZhbHNlO1xuICAgICAgICBsZXQgb3BlcmFuZHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgY29udGV4dCBvZiB0aGlzLm9wbmRzKSB7XG4gICAgICAgICAgbGV0IGV2YWx1YXRlZCA9IGNvbnRleHQuZXZhbFByZWNlZGVuY2UocGFyc2VyLCBwYXJzZXJDYWxsU3RhY2spO1xuICAgICAgICAgIGRpZmZlcnMgPSBkaWZmZXJzIHx8IGV2YWx1YXRlZCAhPT0gY29udGV4dDtcbiAgICAgICAgICBpZiAoZXZhbHVhdGVkID09PSBTZW1hbnRpY0NvbnRleHQyLk5PTkUpIHtcbiAgICAgICAgICAgIHJldHVybiBTZW1hbnRpY0NvbnRleHQyLk5PTkU7XG4gICAgICAgICAgfSBlbHNlIGlmIChldmFsdWF0ZWQpIHtcbiAgICAgICAgICAgIG9wZXJhbmRzLnB1c2goZXZhbHVhdGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkaWZmZXJzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wZXJhbmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IG9wZXJhbmRzWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG9wZXJhbmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcmVzdWx0ID0gU2VtYW50aWNDb250ZXh0Mi5vcihyZXN1bHQsIG9wZXJhbmRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBVdGlsczMuam9pbih0aGlzLm9wbmRzLCBcInx8XCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgICBdLCBPUi5wcm90b3R5cGUsIFwib3BlcmFuZHNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgICBdLCBPUi5wcm90b3R5cGUsIFwiZXF1YWxzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gICAgXSwgT1IucHJvdG90eXBlLCBcImhhc2hDb2RlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gICAgXSwgT1IucHJvdG90eXBlLCBcImV2YWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgICBdLCBPUi5wcm90b3R5cGUsIFwiZXZhbFByZWNlZGVuY2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgICBdLCBPUi5wcm90b3R5cGUsIFwidG9TdHJpbmdcIiwgbnVsbCk7XG4gICAgT1IgPSBfX2RlY29yYXRlKFtcbiAgICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgICBdLCBPUik7XG4gICAgU2VtYW50aWNDb250ZXh0Mi5PUiA9IE9SO1xuICB9KShTZW1hbnRpY0NvbnRleHQgPSBleHBvcnRzLlNlbWFudGljQ29udGV4dCB8fCAoZXhwb3J0cy5TZW1hbnRpY0NvbnRleHQgPSB7fSkpO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9hdG4vUHJlZGljYXRlVHJhbnNpdGlvbi5qc1xudmFyIHJlcXVpcmVfUHJlZGljYXRlVHJhbnNpdGlvbiA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgdmFyIF9fcGFyYW0gPSBleHBvcnRzICYmIGV4cG9ydHMuX19wYXJhbSB8fCBmdW5jdGlvbihwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7XG4gICAgfTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5QcmVkaWNhdGVUcmFuc2l0aW9uID0gdm9pZCAwO1xuICB2YXIgQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uXzEgPSByZXF1aXJlX0Fic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbigpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBTZW1hbnRpY0NvbnRleHRfMSA9IHJlcXVpcmVfU2VtYW50aWNDb250ZXh0KCk7XG4gIHZhciBQcmVkaWNhdGVUcmFuc2l0aW9uID0gY2xhc3MgUHJlZGljYXRlVHJhbnNpdGlvbiBleHRlbmRzIEFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbl8xLkFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbiB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBydWxlSW5kZXgsIHByZWRJbmRleCwgaXNDdHhEZXBlbmRlbnQpIHtcbiAgICAgIHN1cGVyKHRhcmdldCk7XG4gICAgICB0aGlzLnJ1bGVJbmRleCA9IHJ1bGVJbmRleDtcbiAgICAgIHRoaXMucHJlZEluZGV4ID0gcHJlZEluZGV4O1xuICAgICAgdGhpcy5pc0N0eERlcGVuZGVudCA9IGlzQ3R4RGVwZW5kZW50O1xuICAgIH1cbiAgICBnZXQgc2VyaWFsaXphdGlvblR5cGUoKSB7XG4gICAgICByZXR1cm4gNDtcbiAgICB9XG4gICAgZ2V0IGlzRXBzaWxvbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtYXRjaGVzKHN5bWJvbCwgbWluVm9jYWJTeW1ib2wsIG1heFZvY2FiU3ltYm9sKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBwcmVkaWNhdGUoKSB7XG4gICAgICByZXR1cm4gbmV3IFNlbWFudGljQ29udGV4dF8xLlNlbWFudGljQ29udGV4dC5QcmVkaWNhdGUodGhpcy5ydWxlSW5kZXgsIHRoaXMucHJlZEluZGV4LCB0aGlzLmlzQ3R4RGVwZW5kZW50KTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJwcmVkX1wiICsgdGhpcy5ydWxlSW5kZXggKyBcIjpcIiArIHRoaXMucHJlZEluZGV4O1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFByZWRpY2F0ZVRyYW5zaXRpb24ucHJvdG90eXBlLCBcInNlcmlhbGl6YXRpb25UeXBlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgUHJlZGljYXRlVHJhbnNpdGlvbi5wcm90b3R5cGUsIFwiaXNFcHNpbG9uXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgUHJlZGljYXRlVHJhbnNpdGlvbi5wcm90b3R5cGUsIFwibWF0Y2hlc1wiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlLFxuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIFByZWRpY2F0ZVRyYW5zaXRpb24ucHJvdG90eXBlLCBcInRvU3RyaW5nXCIsIG51bGwpO1xuICBQcmVkaWNhdGVUcmFuc2l0aW9uID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgUHJlZGljYXRlVHJhbnNpdGlvbik7XG4gIGV4cG9ydHMuUHJlZGljYXRlVHJhbnNpdGlvbiA9IFByZWRpY2F0ZVRyYW5zaXRpb247XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL0ZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbi5qc1xudmFyIHJlcXVpcmVfRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbiA9IHZvaWQgMDtcbiAgdmFyIFJlY29nbml0aW9uRXhjZXB0aW9uXzEgPSByZXF1aXJlX1JlY29nbml0aW9uRXhjZXB0aW9uKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIFByZWRpY2F0ZVRyYW5zaXRpb25fMSA9IHJlcXVpcmVfUHJlZGljYXRlVHJhbnNpdGlvbigpO1xuICB2YXIgRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uMiA9IGNsYXNzIEZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbjMgZXh0ZW5kcyBSZWNvZ25pdGlvbkV4Y2VwdGlvbl8xLlJlY29nbml0aW9uRXhjZXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihyZWNvZ25pemVyLCBwcmVkaWNhdGUsIG1lc3NhZ2UpIHtcbiAgICAgIHN1cGVyKHJlY29nbml6ZXIsIHJlY29nbml6ZXIuaW5wdXRTdHJlYW0sIHJlY29nbml6ZXIuY29udGV4dCwgRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uMy5mb3JtYXRNZXNzYWdlKHByZWRpY2F0ZSwgbWVzc2FnZSkpO1xuICAgICAgbGV0IHMgPSByZWNvZ25pemVyLmludGVycHJldGVyLmF0bi5zdGF0ZXNbcmVjb2duaXplci5zdGF0ZV07XG4gICAgICBsZXQgdHJhbnMgPSBzLnRyYW5zaXRpb24oMCk7XG4gICAgICBpZiAodHJhbnMgaW5zdGFuY2VvZiBQcmVkaWNhdGVUcmFuc2l0aW9uXzEuUHJlZGljYXRlVHJhbnNpdGlvbikge1xuICAgICAgICB0aGlzLl9ydWxlSW5kZXggPSB0cmFucy5ydWxlSW5kZXg7XG4gICAgICAgIHRoaXMuX3ByZWRpY2F0ZUluZGV4ID0gdHJhbnMucHJlZEluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcnVsZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fcHJlZGljYXRlSW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5fcHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgc3VwZXIuc2V0T2ZmZW5kaW5nVG9rZW4ocmVjb2duaXplciwgcmVjb2duaXplci5jdXJyZW50VG9rZW4pO1xuICAgIH1cbiAgICBnZXQgcnVsZUluZGV4KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1bGVJbmRleDtcbiAgICB9XG4gICAgZ2V0IHByZWRpY2F0ZUluZGV4KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByZWRpY2F0ZUluZGV4O1xuICAgIH1cbiAgICBnZXQgcHJlZGljYXRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByZWRpY2F0ZTtcbiAgICB9XG4gICAgc3RhdGljIGZvcm1hdE1lc3NhZ2UocHJlZGljYXRlLCBtZXNzYWdlKSB7XG4gICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgZmFpbGVkIHByZWRpY2F0ZTogeyR7cHJlZGljYXRlfX0/YDtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIEZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbjIsIFwiZm9ybWF0TWVzc2FnZVwiLCBudWxsKTtcbiAgRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uMiA9IF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIEZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbjIpO1xuICBleHBvcnRzLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbiA9IEZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbjI7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL0lucHV0TWlzbWF0Y2hFeGNlcHRpb24uanNcbnZhciByZXF1aXJlX0lucHV0TWlzbWF0Y2hFeGNlcHRpb24gPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbiA9IHZvaWQgMDtcbiAgdmFyIFJlY29nbml0aW9uRXhjZXB0aW9uXzEgPSByZXF1aXJlX1JlY29nbml0aW9uRXhjZXB0aW9uKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIElucHV0TWlzbWF0Y2hFeGNlcHRpb24gPSBjbGFzcyBJbnB1dE1pc21hdGNoRXhjZXB0aW9uIGV4dGVuZHMgUmVjb2duaXRpb25FeGNlcHRpb25fMS5SZWNvZ25pdGlvbkV4Y2VwdGlvbiB7XG4gICAgY29uc3RydWN0b3IocmVjb2duaXplciwgc3RhdGUsIGNvbnRleHQpIHtcbiAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGV4dCA9IHJlY29nbml6ZXIuY29udGV4dDtcbiAgICAgIH1cbiAgICAgIHN1cGVyKHJlY29nbml6ZXIsIHJlY29nbml6ZXIuaW5wdXRTdHJlYW0sIGNvbnRleHQpO1xuICAgICAgaWYgKHN0YXRlICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5zZXRPZmZlbmRpbmdTdGF0ZShzdGF0ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldE9mZmVuZGluZ1Rva2VuKHJlY29nbml6ZXIsIHJlY29nbml6ZXIuY3VycmVudFRva2VuKTtcbiAgICB9XG4gIH07XG4gIElucHV0TWlzbWF0Y2hFeGNlcHRpb24gPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBJbnB1dE1pc21hdGNoRXhjZXB0aW9uKTtcbiAgZXhwb3J0cy5JbnB1dE1pc21hdGNoRXhjZXB0aW9uID0gSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvbWlzYy9BcnJheXMuanNcbnZhciByZXF1aXJlX0FycmF5cyA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuQXJyYXlzID0gdm9pZCAwO1xuICB2YXIgQXJyYXlzO1xuICAoZnVuY3Rpb24oQXJyYXlzMikge1xuICAgIGZ1bmN0aW9uIGJpbmFyeVNlYXJjaChhcnJheSwga2V5LCBmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICAgIHJldHVybiBiaW5hcnlTZWFyY2gwKGFycmF5LCBmcm9tSW5kZXggIT09IHZvaWQgMCA/IGZyb21JbmRleCA6IDAsIHRvSW5kZXggIT09IHZvaWQgMCA/IHRvSW5kZXggOiBhcnJheS5sZW5ndGgsIGtleSk7XG4gICAgfVxuICAgIEFycmF5czIuYmluYXJ5U2VhcmNoID0gYmluYXJ5U2VhcmNoO1xuICAgIGZ1bmN0aW9uIGJpbmFyeVNlYXJjaDAoYXJyYXksIGZyb21JbmRleCwgdG9JbmRleCwga2V5KSB7XG4gICAgICBsZXQgbG93ID0gZnJvbUluZGV4O1xuICAgICAgbGV0IGhpZ2ggPSB0b0luZGV4IC0gMTtcbiAgICAgIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgICAgICBsZXQgbWlkID0gbG93ICsgaGlnaCA+Pj4gMTtcbiAgICAgICAgbGV0IG1pZFZhbCA9IGFycmF5W21pZF07XG4gICAgICAgIGlmIChtaWRWYWwgPCBrZXkpIHtcbiAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9IGVsc2UgaWYgKG1pZFZhbCA+IGtleSkge1xuICAgICAgICAgIGhpZ2ggPSBtaWQgLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtKGxvdyArIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b1N0cmluZyhhcnJheSkge1xuICAgICAgbGV0IHJlc3VsdCA9IFwiW1wiO1xuICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICAgIGZvciAobGV0IGVsZW1lbnQgb2YgYXJyYXkpIHtcbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgKz0gXCIsIFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwibnVsbFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJlc3VsdCArPSBcInVuZGVmaW5lZFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCArPSBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQgKz0gXCJdXCI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBBcnJheXMyLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gIH0pKEFycmF5cyA9IGV4cG9ydHMuQXJyYXlzIHx8IChleHBvcnRzLkFycmF5cyA9IHt9KSk7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL21pc2MvSW50ZWdlckxpc3QuanNcbnZhciByZXF1aXJlX0ludGVnZXJMaXN0ID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkludGVnZXJMaXN0ID0gdm9pZCAwO1xuICB2YXIgQXJyYXlzXzEgPSByZXF1aXJlX0FycmF5cygpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBFTVBUWV9EQVRBID0gbmV3IEludDMyQXJyYXkoMCk7XG4gIHZhciBJTklUSUFMX1NJWkUgPSA0O1xuICB2YXIgTUFYX0FSUkFZX1NJWkUgPSAoMSA8PCAzMSA+Pj4gMCkgLSAxIC0gODtcbiAgdmFyIEludGVnZXJMaXN0ID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGFyZykge1xuICAgICAgaWYgKCFhcmcpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IEVNUFRZX0RBVEE7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgICAgfSBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBJbnRlZ2VyTGlzdCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gYXJnLl9kYXRhLnNsaWNlKDApO1xuICAgICAgICB0aGlzLl9zaXplID0gYXJnLl9zaXplO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmIChhcmcgPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9kYXRhID0gRU1QVFlfREFUQTtcbiAgICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9kYXRhID0gbmV3IEludDMyQXJyYXkoYXJnKTtcbiAgICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IEVNUFRZX0RBVEE7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgICAgICBmb3IgKGxldCB2YWx1ZSBvZiBhcmcpIHtcbiAgICAgICAgICB0aGlzLmFkZCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYWRkKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5fZGF0YS5sZW5ndGggPT09IHRoaXMuX3NpemUpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVDYXBhY2l0eSh0aGlzLl9zaXplICsgMSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9kYXRhW3RoaXMuX3NpemVdID0gdmFsdWU7XG4gICAgICB0aGlzLl9zaXplKys7XG4gICAgfVxuICAgIGFkZEFsbChsaXN0KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgICAgICB0aGlzLmVuc3VyZUNhcGFjaXR5KHRoaXMuX3NpemUgKyBsaXN0Lmxlbmd0aCk7XG4gICAgICAgIHRoaXMuX2RhdGEuc3ViYXJyYXkodGhpcy5fc2l6ZSwgdGhpcy5fc2l6ZSArIGxpc3QubGVuZ3RoKS5zZXQobGlzdCk7XG4gICAgICAgIHRoaXMuX3NpemUgKz0gbGlzdC5sZW5ndGg7XG4gICAgICB9IGVsc2UgaWYgKGxpc3QgaW5zdGFuY2VvZiBJbnRlZ2VyTGlzdCkge1xuICAgICAgICB0aGlzLmVuc3VyZUNhcGFjaXR5KHRoaXMuX3NpemUgKyBsaXN0Ll9zaXplKTtcbiAgICAgICAgdGhpcy5fZGF0YS5zdWJhcnJheSh0aGlzLl9zaXplLCB0aGlzLl9zaXplICsgbGlzdC5zaXplKS5zZXQobGlzdC5fZGF0YSk7XG4gICAgICAgIHRoaXMuX3NpemUgKz0gbGlzdC5fc2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQ2FwYWNpdHkodGhpcy5fc2l6ZSArIGxpc3Quc2l6ZSk7XG4gICAgICAgIGxldCBjdXJyZW50ID0gMDtcbiAgICAgICAgZm9yIChsZXQgeGkgb2YgbGlzdCkge1xuICAgICAgICAgIHRoaXMuX2RhdGFbdGhpcy5fc2l6ZSArIGN1cnJlbnRdID0geGk7XG4gICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NpemUgKz0gbGlzdC5zaXplO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXQoaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5fc2l6ZSkge1xuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fZGF0YVtpbmRleF07XG4gICAgfVxuICAgIGNvbnRhaW5zKHZhbHVlKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3NpemU7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5fZGF0YVtpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZXQoaW5kZXgsIHZhbHVlKSB7XG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuX3NpemUpIHtcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigpO1xuICAgICAgfVxuICAgICAgbGV0IHByZXZpb3VzID0gdGhpcy5fZGF0YVtpbmRleF07XG4gICAgICB0aGlzLl9kYXRhW2luZGV4XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHByZXZpb3VzO1xuICAgIH1cbiAgICByZW1vdmVBdChpbmRleCkge1xuICAgICAgbGV0IHZhbHVlID0gdGhpcy5nZXQoaW5kZXgpO1xuICAgICAgdGhpcy5fZGF0YS5jb3B5V2l0aGluKGluZGV4LCBpbmRleCArIDEsIHRoaXMuX3NpemUpO1xuICAgICAgdGhpcy5fZGF0YVt0aGlzLl9zaXplIC0gMV0gPSAwO1xuICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZW1vdmVSYW5nZShmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICAgIGlmIChmcm9tSW5kZXggPCAwIHx8IHRvSW5kZXggPCAwIHx8IGZyb21JbmRleCA+IHRoaXMuX3NpemUgfHwgdG9JbmRleCA+IHRoaXMuX3NpemUpIHtcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigpO1xuICAgICAgfVxuICAgICAgaWYgKGZyb21JbmRleCA+IHRvSW5kZXgpIHtcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZGF0YS5jb3B5V2l0aGluKHRvSW5kZXgsIGZyb21JbmRleCwgdGhpcy5fc2l6ZSk7XG4gICAgICB0aGlzLl9kYXRhLmZpbGwoMCwgdGhpcy5fc2l6ZSAtICh0b0luZGV4IC0gZnJvbUluZGV4KSwgdGhpcy5fc2l6ZSk7XG4gICAgICB0aGlzLl9zaXplIC09IHRvSW5kZXggLSBmcm9tSW5kZXg7XG4gICAgfVxuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NpemUgPT09IDA7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuICAgIHRyaW1Ub1NpemUoKSB7XG4gICAgICBpZiAodGhpcy5fZGF0YS5sZW5ndGggPT09IHRoaXMuX3NpemUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fZGF0YSA9IHRoaXMuX2RhdGEuc2xpY2UoMCwgdGhpcy5fc2l6ZSk7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgdGhpcy5fZGF0YS5maWxsKDAsIDAsIHRoaXMuX3NpemUpO1xuICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgfVxuICAgIHRvQXJyYXkoKSB7XG4gICAgICBpZiAodGhpcy5fc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9kYXRhLnN1YmFycmF5KDAsIHRoaXMuX3NpemUpKTtcbiAgICB9XG4gICAgc29ydCgpIHtcbiAgICAgIHRoaXMuX2RhdGEuc3ViYXJyYXkoMCwgdGhpcy5fc2l6ZSkuc29ydCgpO1xuICAgIH1cbiAgICBlcXVhbHMobykge1xuICAgICAgaWYgKG8gPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIShvIGluc3RhbmNlb2YgSW50ZWdlckxpc3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zaXplICE9PSBvLl9zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc2l6ZTsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9kYXRhW2ldICE9PSBvLl9kYXRhW2ldKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaGFzaENvZGUoKSB7XG4gICAgICBsZXQgaGFzaENvZGUgPSAxO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9zaXplOyBpKyspIHtcbiAgICAgICAgaGFzaENvZGUgPSAzMSAqIGhhc2hDb2RlICsgdGhpcy5fZGF0YVtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNoQ29kZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBiaW5hcnlTZWFyY2goa2V5LCBmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICAgIGlmIChmcm9tSW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgICBmcm9tSW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHRvSW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgICB0b0luZGV4ID0gdGhpcy5fc2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChmcm9tSW5kZXggPCAwIHx8IHRvSW5kZXggPCAwIHx8IGZyb21JbmRleCA+IHRoaXMuX3NpemUgfHwgdG9JbmRleCA+IHRoaXMuX3NpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcm9tSW5kZXggPiB0b0luZGV4KSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQXJyYXlzXzEuQXJyYXlzLmJpbmFyeVNlYXJjaCh0aGlzLl9kYXRhLCBrZXksIGZyb21JbmRleCwgdG9JbmRleCk7XG4gICAgfVxuICAgIGVuc3VyZUNhcGFjaXR5KGNhcGFjaXR5KSB7XG4gICAgICBpZiAoY2FwYWNpdHkgPCAwIHx8IGNhcGFjaXR5ID4gTUFYX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIGxldCBuZXdMZW5ndGg7XG4gICAgICBpZiAodGhpcy5fZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbmV3TGVuZ3RoID0gSU5JVElBTF9TSVpFO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3TGVuZ3RoID0gdGhpcy5fZGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgICB3aGlsZSAobmV3TGVuZ3RoIDwgY2FwYWNpdHkpIHtcbiAgICAgICAgbmV3TGVuZ3RoID0gbmV3TGVuZ3RoICogMjtcbiAgICAgICAgaWYgKG5ld0xlbmd0aCA8IDAgfHwgbmV3TGVuZ3RoID4gTUFYX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgICBuZXdMZW5ndGggPSBNQVhfQVJSQVlfU0laRTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IHRtcCA9IG5ldyBJbnQzMkFycmF5KG5ld0xlbmd0aCk7XG4gICAgICB0bXAuc2V0KHRoaXMuX2RhdGEpO1xuICAgICAgdGhpcy5fZGF0YSA9IHRtcDtcbiAgICB9XG4gICAgdG9DaGFyQXJyYXkoKSB7XG4gICAgICBsZXQgcmVzdWx0QXJyYXkgPSBuZXcgVWludDE2QXJyYXkodGhpcy5fc2l6ZSk7XG4gICAgICBsZXQgcmVzdWx0SWR4ID0gMDtcbiAgICAgIGxldCBjYWxjdWxhdGVkUHJlY2lzZVJlc3VsdFNpemUgPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc2l6ZTsgaSsrKSB7XG4gICAgICAgIGxldCBjb2RlUG9pbnQgPSB0aGlzLl9kYXRhW2ldO1xuICAgICAgICBpZiAoY29kZVBvaW50ID49IDAgJiYgY29kZVBvaW50IDwgNjU1MzYpIHtcbiAgICAgICAgICByZXN1bHRBcnJheVtyZXN1bHRJZHhdID0gY29kZVBvaW50O1xuICAgICAgICAgIHJlc3VsdElkeCsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FsY3VsYXRlZFByZWNpc2VSZXN1bHRTaXplKSB7XG4gICAgICAgICAgbGV0IG5ld1Jlc3VsdEFycmF5ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuY2hhckFycmF5U2l6ZSgpKTtcbiAgICAgICAgICBuZXdSZXN1bHRBcnJheS5zZXQocmVzdWx0QXJyYXksIDApO1xuICAgICAgICAgIHJlc3VsdEFycmF5ID0gbmV3UmVzdWx0QXJyYXk7XG4gICAgICAgICAgY2FsY3VsYXRlZFByZWNpc2VSZXN1bHRTaXplID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFpciA9IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGVQb2ludCk7XG4gICAgICAgIHJlc3VsdEFycmF5W3Jlc3VsdElkeF0gPSBwYWlyLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHJlc3VsdEFycmF5W3Jlc3VsdElkeCArIDFdID0gcGFpci5jaGFyQ29kZUF0KDEpO1xuICAgICAgICByZXN1bHRJZHggKz0gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRBcnJheTtcbiAgICB9XG4gICAgY2hhckFycmF5U2l6ZSgpIHtcbiAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9zaXplOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IHRoaXMuX2RhdGFbaV0gPj0gNjU1MzYgPyAyIDogMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBJbnRlZ2VyTGlzdC5wcm90b3R5cGUsIFwiX2RhdGFcIiwgdm9pZCAwKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEludGVnZXJMaXN0LnByb3RvdHlwZSwgXCJlcXVhbHNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBJbnRlZ2VyTGlzdC5wcm90b3R5cGUsIFwiaGFzaENvZGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBJbnRlZ2VyTGlzdC5wcm90b3R5cGUsIFwidG9TdHJpbmdcIiwgbnVsbCk7XG4gIGV4cG9ydHMuSW50ZWdlckxpc3QgPSBJbnRlZ2VyTGlzdDtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvbWlzYy9JbnRlcnZhbC5qc1xudmFyIHJlcXVpcmVfSW50ZXJ2YWwgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuSW50ZXJ2YWwgPSB2b2lkIDA7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIElOVEVSVkFMX1BPT0xfTUFYX1ZBTFVFID0gMWUzO1xuICB2YXIgSW50ZXJ2YWwgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoYSwgYikge1xuICAgICAgdGhpcy5hID0gYTtcbiAgICAgIHRoaXMuYiA9IGI7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgSU5WQUxJRCgpIHtcbiAgICAgIHJldHVybiBJbnRlcnZhbC5fSU5WQUxJRDtcbiAgICB9XG4gICAgc3RhdGljIG9mKGEsIGIpIHtcbiAgICAgIGlmIChhICE9PSBiIHx8IGEgPCAwIHx8IGEgPiBJTlRFUlZBTF9QT09MX01BWF9WQUxVRSkge1xuICAgICAgICByZXR1cm4gbmV3IEludGVydmFsKGEsIGIpO1xuICAgICAgfVxuICAgICAgaWYgKEludGVydmFsLmNhY2hlW2FdID09IG51bGwpIHtcbiAgICAgICAgSW50ZXJ2YWwuY2FjaGVbYV0gPSBuZXcgSW50ZXJ2YWwoYSwgYSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gSW50ZXJ2YWwuY2FjaGVbYV07XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICBpZiAodGhpcy5iIDwgdGhpcy5hKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuYiAtIHRoaXMuYSArIDE7XG4gICAgfVxuICAgIGVxdWFscyhvKSB7XG4gICAgICBpZiAobyA9PT0gdGhpcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIShvIGluc3RhbmNlb2YgSW50ZXJ2YWwpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmEgPT09IG8uYSAmJiB0aGlzLmIgPT09IG8uYjtcbiAgICB9XG4gICAgaGFzaENvZGUoKSB7XG4gICAgICBsZXQgaGFzaCA9IDIzO1xuICAgICAgaGFzaCA9IGhhc2ggKiAzMSArIHRoaXMuYTtcbiAgICAgIGhhc2ggPSBoYXNoICogMzEgKyB0aGlzLmI7XG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gICAgc3RhcnRzQmVmb3JlRGlzam9pbnQob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmEgPCBvdGhlci5hICYmIHRoaXMuYiA8IG90aGVyLmE7XG4gICAgfVxuICAgIHN0YXJ0c0JlZm9yZU5vbkRpc2pvaW50KG90aGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5hIDw9IG90aGVyLmEgJiYgdGhpcy5iID49IG90aGVyLmE7XG4gICAgfVxuICAgIHN0YXJ0c0FmdGVyKG90aGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5hID4gb3RoZXIuYTtcbiAgICB9XG4gICAgc3RhcnRzQWZ0ZXJEaXNqb2ludChvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMuYSA+IG90aGVyLmI7XG4gICAgfVxuICAgIHN0YXJ0c0FmdGVyTm9uRGlzam9pbnQob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmEgPiBvdGhlci5hICYmIHRoaXMuYSA8PSBvdGhlci5iO1xuICAgIH1cbiAgICBkaXNqb2ludChvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnRzQmVmb3JlRGlzam9pbnQob3RoZXIpIHx8IHRoaXMuc3RhcnRzQWZ0ZXJEaXNqb2ludChvdGhlcik7XG4gICAgfVxuICAgIGFkamFjZW50KG90aGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5hID09PSBvdGhlci5iICsgMSB8fCB0aGlzLmIgPT09IG90aGVyLmEgLSAxO1xuICAgIH1cbiAgICBwcm9wZXJseUNvbnRhaW5zKG90aGVyKSB7XG4gICAgICByZXR1cm4gb3RoZXIuYSA+PSB0aGlzLmEgJiYgb3RoZXIuYiA8PSB0aGlzLmI7XG4gICAgfVxuICAgIHVuaW9uKG90aGVyKSB7XG4gICAgICByZXR1cm4gSW50ZXJ2YWwub2YoTWF0aC5taW4odGhpcy5hLCBvdGhlci5hKSwgTWF0aC5tYXgodGhpcy5iLCBvdGhlci5iKSk7XG4gICAgfVxuICAgIGludGVyc2VjdGlvbihvdGhlcikge1xuICAgICAgcmV0dXJuIEludGVydmFsLm9mKE1hdGgubWF4KHRoaXMuYSwgb3RoZXIuYSksIE1hdGgubWluKHRoaXMuYiwgb3RoZXIuYikpO1xuICAgIH1cbiAgICBkaWZmZXJlbmNlTm90UHJvcGVybHlDb250YWluZWQob3RoZXIpIHtcbiAgICAgIGxldCBkaWZmO1xuICAgICAgaWYgKG90aGVyLnN0YXJ0c0JlZm9yZU5vbkRpc2pvaW50KHRoaXMpKSB7XG4gICAgICAgIGRpZmYgPSBJbnRlcnZhbC5vZihNYXRoLm1heCh0aGlzLmEsIG90aGVyLmIgKyAxKSwgdGhpcy5iKTtcbiAgICAgIH0gZWxzZSBpZiAob3RoZXIuc3RhcnRzQWZ0ZXJOb25EaXNqb2ludCh0aGlzKSkge1xuICAgICAgICBkaWZmID0gSW50ZXJ2YWwub2YodGhpcy5hLCBvdGhlci5hIC0gMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlmZjtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hICsgXCIuLlwiICsgdGhpcy5iO1xuICAgIH1cbiAgfTtcbiAgSW50ZXJ2YWwuX0lOVkFMSUQgPSBuZXcgSW50ZXJ2YWwoLTEsIC0yKTtcbiAgSW50ZXJ2YWwuY2FjaGUgPSBuZXcgQXJyYXkoSU5URVJWQUxfUE9PTF9NQVhfVkFMVUUgKyAxKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEludGVydmFsLnByb3RvdHlwZSwgXCJlcXVhbHNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBJbnRlcnZhbC5wcm90b3R5cGUsIFwiaGFzaENvZGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBJbnRlcnZhbC5wcm90b3R5cGUsIFwidG9TdHJpbmdcIiwgbnVsbCk7XG4gIGV4cG9ydHMuSW50ZXJ2YWwgPSBJbnRlcnZhbDtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvVG9rZW4uanNcbnZhciByZXF1aXJlX1Rva2VuID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5Ub2tlbiA9IHZvaWQgMDtcbiAgdmFyIEludFN0cmVhbV8xID0gcmVxdWlyZV9JbnRTdHJlYW0oKTtcbiAgdmFyIFRva2VuMjtcbiAgKGZ1bmN0aW9uKFRva2VuMykge1xuICAgIFRva2VuMy5JTlZBTElEX1RZUEUgPSAwO1xuICAgIFRva2VuMy5FUFNJTE9OID0gLTI7XG4gICAgVG9rZW4zLk1JTl9VU0VSX1RPS0VOX1RZUEUgPSAxO1xuICAgIFRva2VuMy5FT0YgPSBJbnRTdHJlYW1fMS5JbnRTdHJlYW0uRU9GO1xuICAgIFRva2VuMy5ERUZBVUxUX0NIQU5ORUwgPSAwO1xuICAgIFRva2VuMy5ISURERU5fQ0hBTk5FTCA9IDE7XG4gICAgVG9rZW4zLk1JTl9VU0VSX0NIQU5ORUxfVkFMVUUgPSAyO1xuICB9KShUb2tlbjIgPSBleHBvcnRzLlRva2VuIHx8IChleHBvcnRzLlRva2VuID0ge30pKTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvQ29tbW9uVG9rZW4uanNcbnZhciByZXF1aXJlX0NvbW1vblRva2VuID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkNvbW1vblRva2VuID0gdm9pZCAwO1xuICB2YXIgSW50ZXJ2YWxfMSA9IHJlcXVpcmVfSW50ZXJ2YWwoKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgVG9rZW5fMSA9IHJlcXVpcmVfVG9rZW4oKTtcbiAgdmFyIENvbW1vblRva2VuID0gY2xhc3MgQ29tbW9uVG9rZW4yIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCB0ZXh0LCBzb3VyY2UgPSBDb21tb25Ub2tlbjIuRU1QVFlfU09VUkNFLCBjaGFubmVsID0gVG9rZW5fMS5Ub2tlbi5ERUZBVUxUX0NIQU5ORUwsIHN0YXJ0ID0gMCwgc3RvcCA9IDApIHtcbiAgICAgIHRoaXMuX2xpbmUgPSAwO1xuICAgICAgdGhpcy5fY2hhclBvc2l0aW9uSW5MaW5lID0gLTE7XG4gICAgICB0aGlzLl9jaGFubmVsID0gVG9rZW5fMS5Ub2tlbi5ERUZBVUxUX0NIQU5ORUw7XG4gICAgICB0aGlzLmluZGV4ID0gLTE7XG4gICAgICB0aGlzLl90ZXh0ID0gdGV4dDtcbiAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLl9jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgIHRoaXMuc3RvcCA9IHN0b3A7XG4gICAgICBpZiAoc291cmNlLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2xpbmUgPSBzb3VyY2Uuc291cmNlLmxpbmU7XG4gICAgICAgIHRoaXMuX2NoYXJQb3NpdGlvbkluTGluZSA9IHNvdXJjZS5zb3VyY2UuY2hhclBvc2l0aW9uSW5MaW5lO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZnJvbVRva2VuKG9sZFRva2VuKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gbmV3IENvbW1vblRva2VuMihvbGRUb2tlbi50eXBlLCB2b2lkIDAsIENvbW1vblRva2VuMi5FTVBUWV9TT1VSQ0UsIG9sZFRva2VuLmNoYW5uZWwsIG9sZFRva2VuLnN0YXJ0SW5kZXgsIG9sZFRva2VuLnN0b3BJbmRleCk7XG4gICAgICByZXN1bHQuX2xpbmUgPSBvbGRUb2tlbi5saW5lO1xuICAgICAgcmVzdWx0LmluZGV4ID0gb2xkVG9rZW4udG9rZW5JbmRleDtcbiAgICAgIHJlc3VsdC5fY2hhclBvc2l0aW9uSW5MaW5lID0gb2xkVG9rZW4uY2hhclBvc2l0aW9uSW5MaW5lO1xuICAgICAgaWYgKG9sZFRva2VuIGluc3RhbmNlb2YgQ29tbW9uVG9rZW4yKSB7XG4gICAgICAgIHJlc3VsdC5fdGV4dCA9IG9sZFRva2VuLl90ZXh0O1xuICAgICAgICByZXN1bHQuc291cmNlID0gb2xkVG9rZW4uc291cmNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0Ll90ZXh0ID0gb2xkVG9rZW4udGV4dDtcbiAgICAgICAgcmVzdWx0LnNvdXJjZSA9IHtzb3VyY2U6IG9sZFRva2VuLnRva2VuU291cmNlLCBzdHJlYW06IG9sZFRva2VuLmlucHV0U3RyZWFtfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGdldCB0eXBlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfVxuICAgIHNldCB0eXBlKHR5cGUpIHtcbiAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBnZXQgbGluZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9saW5lO1xuICAgIH1cbiAgICBzZXQgbGluZShsaW5lKSB7XG4gICAgICB0aGlzLl9saW5lID0gbGluZTtcbiAgICB9XG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICBpZiAodGhpcy5fdGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0O1xuICAgICAgfVxuICAgICAgbGV0IGlucHV0ID0gdGhpcy5pbnB1dFN0cmVhbTtcbiAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBsZXQgbiA9IGlucHV0LnNpemU7XG4gICAgICBpZiAodGhpcy5zdGFydCA8IG4gJiYgdGhpcy5zdG9wIDwgbikge1xuICAgICAgICByZXR1cm4gaW5wdXQuZ2V0VGV4dChJbnRlcnZhbF8xLkludGVydmFsLm9mKHRoaXMuc3RhcnQsIHRoaXMuc3RvcCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiPEVPRj5cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0IHRleHQodGV4dCkge1xuICAgICAgdGhpcy5fdGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIGdldCBjaGFyUG9zaXRpb25JbkxpbmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2hhclBvc2l0aW9uSW5MaW5lO1xuICAgIH1cbiAgICBzZXQgY2hhclBvc2l0aW9uSW5MaW5lKGNoYXJQb3NpdGlvbkluTGluZSkge1xuICAgICAgdGhpcy5fY2hhclBvc2l0aW9uSW5MaW5lID0gY2hhclBvc2l0aW9uSW5MaW5lO1xuICAgIH1cbiAgICBnZXQgY2hhbm5lbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaGFubmVsO1xuICAgIH1cbiAgICBzZXQgY2hhbm5lbChjaGFubmVsKSB7XG4gICAgICB0aGlzLl9jaGFubmVsID0gY2hhbm5lbDtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0SW5kZXgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGFydDtcbiAgICB9XG4gICAgc2V0IHN0YXJ0SW5kZXgoc3RhcnQpIHtcbiAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB9XG4gICAgZ2V0IHN0b3BJbmRleCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0b3A7XG4gICAgfVxuICAgIHNldCBzdG9wSW5kZXgoc3RvcCkge1xuICAgICAgdGhpcy5zdG9wID0gc3RvcDtcbiAgICB9XG4gICAgZ2V0IHRva2VuSW5kZXgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleDtcbiAgICB9XG4gICAgc2V0IHRva2VuSW5kZXgoaW5kZXgpIHtcbiAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB9XG4gICAgZ2V0IHRva2VuU291cmNlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnNvdXJjZTtcbiAgICB9XG4gICAgZ2V0IGlucHV0U3RyZWFtKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN0cmVhbTtcbiAgICB9XG4gICAgdG9TdHJpbmcocmVjb2duaXplcikge1xuICAgICAgbGV0IGNoYW5uZWxTdHIgPSBcIlwiO1xuICAgICAgaWYgKHRoaXMuX2NoYW5uZWwgPiAwKSB7XG4gICAgICAgIGNoYW5uZWxTdHIgPSBcIixjaGFubmVsPVwiICsgdGhpcy5fY2hhbm5lbDtcbiAgICAgIH1cbiAgICAgIGxldCB0eHQgPSB0aGlzLnRleHQ7XG4gICAgICBpZiAodHh0ICE9IG51bGwpIHtcbiAgICAgICAgdHh0ID0gdHh0LnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpO1xuICAgICAgICB0eHQgPSB0eHQucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIik7XG4gICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR4dCA9IFwiPG5vIHRleHQ+XCI7XG4gICAgICB9XG4gICAgICBsZXQgdHlwZVN0cmluZyA9IFN0cmluZyh0aGlzLl90eXBlKTtcbiAgICAgIGlmIChyZWNvZ25pemVyKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSByZWNvZ25pemVyLnZvY2FidWxhcnkuZ2V0RGlzcGxheU5hbWUodGhpcy5fdHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJbQFwiICsgdGhpcy50b2tlbkluZGV4ICsgXCIsXCIgKyB0aGlzLnN0YXJ0ICsgXCI6XCIgKyB0aGlzLnN0b3AgKyBcIj0nXCIgKyB0eHQgKyBcIicsPFwiICsgdHlwZVN0cmluZyArIFwiPlwiICsgY2hhbm5lbFN0ciArIFwiLFwiICsgdGhpcy5fbGluZSArIFwiOlwiICsgdGhpcy5jaGFyUG9zaXRpb25JbkxpbmUgKyBcIl1cIjtcbiAgICB9XG4gIH07XG4gIENvbW1vblRva2VuLkVNUFRZX1NPVVJDRSA9IHtzb3VyY2U6IHZvaWQgMCwgc3RyZWFtOiB2b2lkIDB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBDb21tb25Ub2tlbi5wcm90b3R5cGUsIFwic291cmNlXCIsIHZvaWQgMCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBDb21tb25Ub2tlbi5wcm90b3R5cGUsIFwidHlwZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIENvbW1vblRva2VuLnByb3RvdHlwZSwgXCJsaW5lXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQ29tbW9uVG9rZW4ucHJvdG90eXBlLCBcInRleHRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBDb21tb25Ub2tlbi5wcm90b3R5cGUsIFwiY2hhclBvc2l0aW9uSW5MaW5lXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQ29tbW9uVG9rZW4ucHJvdG90eXBlLCBcImNoYW5uZWxcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBDb21tb25Ub2tlbi5wcm90b3R5cGUsIFwic3RhcnRJbmRleFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIENvbW1vblRva2VuLnByb3RvdHlwZSwgXCJzdG9wSW5kZXhcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBDb21tb25Ub2tlbi5wcm90b3R5cGUsIFwidG9rZW5JbmRleFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIENvbW1vblRva2VuLnByb3RvdHlwZSwgXCJ0b2tlblNvdXJjZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIENvbW1vblRva2VuLnByb3RvdHlwZSwgXCJpbnB1dFN0cmVhbVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIENvbW1vblRva2VuLnByb3RvdHlwZSwgXCJ0b1N0cmluZ1wiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgQ29tbW9uVG9rZW4sIFwiZnJvbVRva2VuXCIsIG51bGwpO1xuICBDb21tb25Ub2tlbiA9IF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMiwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIENvbW1vblRva2VuKTtcbiAgZXhwb3J0cy5Db21tb25Ub2tlbiA9IENvbW1vblRva2VuO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9Db21tb25Ub2tlbkZhY3RvcnkuanNcbnZhciByZXF1aXJlX0NvbW1vblRva2VuRmFjdG9yeSA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5Db21tb25Ub2tlbkZhY3RvcnkgPSB2b2lkIDA7XG4gIHZhciBDb21tb25Ub2tlbl8xID0gcmVxdWlyZV9Db21tb25Ub2tlbigpO1xuICB2YXIgSW50ZXJ2YWxfMSA9IHJlcXVpcmVfSW50ZXJ2YWwoKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgQ29tbW9uVG9rZW5GYWN0b3J5ID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGNvcHlUZXh0ID0gZmFsc2UpIHtcbiAgICAgIHRoaXMuY29weVRleHQgPSBjb3B5VGV4dDtcbiAgICB9XG4gICAgY3JlYXRlKHNvdXJjZSwgdHlwZSwgdGV4dCwgY2hhbm5lbCwgc3RhcnQsIHN0b3AsIGxpbmUsIGNoYXJQb3NpdGlvbkluTGluZSkge1xuICAgICAgbGV0IHQgPSBuZXcgQ29tbW9uVG9rZW5fMS5Db21tb25Ub2tlbih0eXBlLCB0ZXh0LCBzb3VyY2UsIGNoYW5uZWwsIHN0YXJ0LCBzdG9wKTtcbiAgICAgIHQubGluZSA9IGxpbmU7XG4gICAgICB0LmNoYXJQb3NpdGlvbkluTGluZSA9IGNoYXJQb3NpdGlvbkluTGluZTtcbiAgICAgIGlmICh0ZXh0ID09IG51bGwgJiYgdGhpcy5jb3B5VGV4dCAmJiBzb3VyY2Uuc3RyZWFtICE9IG51bGwpIHtcbiAgICAgICAgdC50ZXh0ID0gc291cmNlLnN0cmVhbS5nZXRUZXh0KEludGVydmFsXzEuSW50ZXJ2YWwub2Yoc3RhcnQsIHN0b3ApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgICBjcmVhdGVTaW1wbGUodHlwZSwgdGV4dCkge1xuICAgICAgcmV0dXJuIG5ldyBDb21tb25Ub2tlbl8xLkNvbW1vblRva2VuKHR5cGUsIHRleHQpO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIENvbW1vblRva2VuRmFjdG9yeS5wcm90b3R5cGUsIFwiY3JlYXRlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQ29tbW9uVG9rZW5GYWN0b3J5LnByb3RvdHlwZSwgXCJjcmVhdGVTaW1wbGVcIiwgbnVsbCk7XG4gIGV4cG9ydHMuQ29tbW9uVG9rZW5GYWN0b3J5ID0gQ29tbW9uVG9rZW5GYWN0b3J5O1xuICAoZnVuY3Rpb24oQ29tbW9uVG9rZW5GYWN0b3J5Mikge1xuICAgIENvbW1vblRva2VuRmFjdG9yeTIuREVGQVVMVCA9IG5ldyBDb21tb25Ub2tlbkZhY3RvcnkyKCk7XG4gIH0pKENvbW1vblRva2VuRmFjdG9yeSA9IGV4cG9ydHMuQ29tbW9uVG9rZW5GYWN0b3J5IHx8IChleHBvcnRzLkNvbW1vblRva2VuRmFjdG9yeSA9IHt9KSk7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL21pc2MvSW50ZWdlclN0YWNrLmpzXG52YXIgcmVxdWlyZV9JbnRlZ2VyU3RhY2sgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkludGVnZXJTdGFjayA9IHZvaWQgMDtcbiAgdmFyIEludGVnZXJMaXN0XzEgPSByZXF1aXJlX0ludGVnZXJMaXN0KCk7XG4gIHZhciBJbnRlZ2VyU3RhY2sgPSBjbGFzcyBleHRlbmRzIEludGVnZXJMaXN0XzEuSW50ZWdlckxpc3Qge1xuICAgIGNvbnN0cnVjdG9yKGFyZykge1xuICAgICAgc3VwZXIoYXJnKTtcbiAgICB9XG4gICAgcHVzaCh2YWx1ZSkge1xuICAgICAgdGhpcy5hZGQodmFsdWUpO1xuICAgIH1cbiAgICBwb3AoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmVBdCh0aGlzLnNpemUgLSAxKTtcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnNpemUgLSAxKTtcbiAgICB9XG4gIH07XG4gIGV4cG9ydHMuSW50ZWdlclN0YWNrID0gSW50ZWdlclN0YWNrO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9kZmEvQWNjZXB0U3RhdGVJbmZvLmpzXG52YXIgcmVxdWlyZV9BY2NlcHRTdGF0ZUluZm8gPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkFjY2VwdFN0YXRlSW5mbyA9IHZvaWQgMDtcbiAgdmFyIEFjY2VwdFN0YXRlSW5mbyA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVkaWN0aW9uLCBsZXhlckFjdGlvbkV4ZWN1dG9yKSB7XG4gICAgICB0aGlzLl9wcmVkaWN0aW9uID0gcHJlZGljdGlvbjtcbiAgICAgIHRoaXMuX2xleGVyQWN0aW9uRXhlY3V0b3IgPSBsZXhlckFjdGlvbkV4ZWN1dG9yO1xuICAgIH1cbiAgICBnZXQgcHJlZGljdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcmVkaWN0aW9uO1xuICAgIH1cbiAgICBnZXQgbGV4ZXJBY3Rpb25FeGVjdXRvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sZXhlckFjdGlvbkV4ZWN1dG9yO1xuICAgIH1cbiAgfTtcbiAgZXhwb3J0cy5BY2NlcHRTdGF0ZUluZm8gPSBBY2NlcHRTdGF0ZUluZm87XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL21pc2MvQXJyYXkyREhhc2hNYXAuanNcbnZhciByZXF1aXJlX0FycmF5MkRIYXNoTWFwID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5BcnJheTJESGFzaE1hcCA9IHZvaWQgMDtcbiAgdmFyIEFycmF5MkRIYXNoU2V0XzEgPSByZXF1aXJlX0FycmF5MkRIYXNoU2V0KCk7XG4gIHZhciBNYXBLZXlFcXVhbGl0eUNvbXBhcmF0b3IgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3Ioa2V5Q29tcGFyYXRvcikge1xuICAgICAgdGhpcy5rZXlDb21wYXJhdG9yID0ga2V5Q29tcGFyYXRvcjtcbiAgICB9XG4gICAgaGFzaENvZGUob2JqKSB7XG4gICAgICByZXR1cm4gdGhpcy5rZXlDb21wYXJhdG9yLmhhc2hDb2RlKG9iai5rZXkpO1xuICAgIH1cbiAgICBlcXVhbHMoYSwgYikge1xuICAgICAgcmV0dXJuIHRoaXMua2V5Q29tcGFyYXRvci5lcXVhbHMoYS5rZXksIGIua2V5KTtcbiAgICB9XG4gIH07XG4gIHZhciBBcnJheTJESGFzaE1hcCA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihrZXlDb21wYXJlcikge1xuICAgICAgaWYgKGtleUNvbXBhcmVyIGluc3RhbmNlb2YgQXJyYXkyREhhc2hNYXApIHtcbiAgICAgICAgdGhpcy5iYWNraW5nU3RvcmUgPSBuZXcgQXJyYXkyREhhc2hTZXRfMS5BcnJheTJESGFzaFNldChrZXlDb21wYXJlci5iYWNraW5nU3RvcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iYWNraW5nU3RvcmUgPSBuZXcgQXJyYXkyREhhc2hTZXRfMS5BcnJheTJESGFzaFNldChuZXcgTWFwS2V5RXF1YWxpdHlDb21wYXJhdG9yKGtleUNvbXBhcmVyKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgdGhpcy5iYWNraW5nU3RvcmUuY2xlYXIoKTtcbiAgICB9XG4gICAgY29udGFpbnNLZXkoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5iYWNraW5nU3RvcmUuY29udGFpbnMoe2tleX0pO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICBsZXQgYnVja2V0ID0gdGhpcy5iYWNraW5nU3RvcmUuZ2V0KHtrZXl9KTtcbiAgICAgIGlmICghYnVja2V0KSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVja2V0LnZhbHVlO1xuICAgIH1cbiAgICBnZXQgaXNFbXB0eSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJhY2tpbmdTdG9yZS5pc0VtcHR5O1xuICAgIH1cbiAgICBwdXQoa2V5LCB2YWx1ZSkge1xuICAgICAgbGV0IGVsZW1lbnQgPSB0aGlzLmJhY2tpbmdTdG9yZS5nZXQoe2tleSwgdmFsdWV9KTtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5iYWNraW5nU3RvcmUuYWRkKHtrZXksIHZhbHVlfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBlbGVtZW50LnZhbHVlO1xuICAgICAgICBlbGVtZW50LnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBwdXRJZkFic2VudChrZXksIHZhbHVlKSB7XG4gICAgICBsZXQgZWxlbWVudCA9IHRoaXMuYmFja2luZ1N0b3JlLmdldCh7a2V5LCB2YWx1ZX0pO1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICB0aGlzLmJhY2tpbmdTdG9yZS5hZGQoe2tleSwgdmFsdWV9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGVsZW1lbnQudmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJhY2tpbmdTdG9yZS5zaXplO1xuICAgIH1cbiAgICBoYXNoQ29kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJhY2tpbmdTdG9yZS5oYXNoQ29kZSgpO1xuICAgIH1cbiAgICBlcXVhbHMobykge1xuICAgICAgaWYgKCEobyBpbnN0YW5jZW9mIEFycmF5MkRIYXNoTWFwKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5iYWNraW5nU3RvcmUuZXF1YWxzKG8uYmFja2luZ1N0b3JlKTtcbiAgICB9XG4gIH07XG4gIGV4cG9ydHMuQXJyYXkyREhhc2hNYXAgPSBBcnJheTJESGFzaE1hcDtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvYXRuL0RlY2lzaW9uU3RhdGUuanNcbnZhciByZXF1aXJlX0RlY2lzaW9uU3RhdGUgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkRlY2lzaW9uU3RhdGUgPSB2b2lkIDA7XG4gIHZhciBBVE5TdGF0ZV8xID0gcmVxdWlyZV9BVE5TdGF0ZSgpO1xuICB2YXIgRGVjaXNpb25TdGF0ZSA9IGNsYXNzIGV4dGVuZHMgQVROU3RhdGVfMS5BVE5TdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgdGhpcy5kZWNpc2lvbiA9IC0xO1xuICAgICAgdGhpcy5ub25HcmVlZHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2xsID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICBleHBvcnRzLkRlY2lzaW9uU3RhdGUgPSBEZWNpc2lvblN0YXRlO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9hdG4vUHJlZGljdGlvbkNvbnRleHRDYWNoZS5qc1xudmFyIHJlcXVpcmVfUHJlZGljdGlvbkNvbnRleHRDYWNoZSA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5QcmVkaWN0aW9uQ29udGV4dENhY2hlID0gdm9pZCAwO1xuICB2YXIgQXJyYXkyREhhc2hNYXBfMSA9IHJlcXVpcmVfQXJyYXkyREhhc2hNYXAoKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yXzEgPSByZXF1aXJlX09iamVjdEVxdWFsaXR5Q29tcGFyYXRvcigpO1xuICB2YXIgUHJlZGljdGlvbkNvbnRleHRfMSA9IHJlcXVpcmVfUHJlZGljdGlvbkNvbnRleHQoKTtcbiAgdmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG4gIHZhciBQcmVkaWN0aW9uQ29udGV4dENhY2hlID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGVuYWJsZUNhY2hlID0gdHJ1ZSkge1xuICAgICAgdGhpcy5jb250ZXh0cyA9IG5ldyBBcnJheTJESGFzaE1hcF8xLkFycmF5MkRIYXNoTWFwKE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvcl8xLk9iamVjdEVxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRSk7XG4gICAgICB0aGlzLmNoaWxkQ29udGV4dHMgPSBuZXcgQXJyYXkyREhhc2hNYXBfMS5BcnJheTJESGFzaE1hcChPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3JfMS5PYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UpO1xuICAgICAgdGhpcy5qb2luQ29udGV4dHMgPSBuZXcgQXJyYXkyREhhc2hNYXBfMS5BcnJheTJESGFzaE1hcChPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3JfMS5PYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UpO1xuICAgICAgdGhpcy5lbmFibGVDYWNoZSA9IGVuYWJsZUNhY2hlO1xuICAgIH1cbiAgICBnZXRBc0NhY2hlZChjb250ZXh0KSB7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdWx0ID0gdGhpcy5jb250ZXh0cy5nZXQoY29udGV4dCk7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXN1bHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmNvbnRleHRzLnB1dChjb250ZXh0LCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGdldENoaWxkKGNvbnRleHQsIGludm9raW5nU3RhdGUpIHtcbiAgICAgIGlmICghdGhpcy5lbmFibGVDYWNoZSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5nZXRDaGlsZChpbnZva2luZ1N0YXRlKTtcbiAgICAgIH1cbiAgICAgIGxldCBvcGVyYW5kcyA9IG5ldyBQcmVkaWN0aW9uQ29udGV4dENhY2hlLlByZWRpY3Rpb25Db250ZXh0QW5kSW50KGNvbnRleHQsIGludm9raW5nU3RhdGUpO1xuICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuY2hpbGRDb250ZXh0cy5nZXQob3BlcmFuZHMpO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0ID0gY29udGV4dC5nZXRDaGlsZChpbnZva2luZ1N0YXRlKTtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5nZXRBc0NhY2hlZChyZXN1bHQpO1xuICAgICAgICB0aGlzLmNoaWxkQ29udGV4dHMucHV0KG9wZXJhbmRzLCByZXN1bHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgam9pbih4LCB5KSB7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIFByZWRpY3Rpb25Db250ZXh0XzEuUHJlZGljdGlvbkNvbnRleHQuam9pbih4LCB5LCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIGxldCBvcGVyYW5kcyA9IG5ldyBQcmVkaWN0aW9uQ29udGV4dENhY2hlLklkZW50aXR5Q29tbXV0YXRpdmVQcmVkaWN0aW9uQ29udGV4dE9wZXJhbmRzKHgsIHkpO1xuICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuam9pbkNvbnRleHRzLmdldChvcGVyYW5kcyk7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBQcmVkaWN0aW9uQ29udGV4dF8xLlByZWRpY3Rpb25Db250ZXh0LmpvaW4oeCwgeSwgdGhpcyk7XG4gICAgICByZXN1bHQgPSB0aGlzLmdldEFzQ2FjaGVkKHJlc3VsdCk7XG4gICAgICB0aGlzLmpvaW5Db250ZXh0cy5wdXQob3BlcmFuZHMsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcbiAgZXhwb3J0cy5QcmVkaWN0aW9uQ29udGV4dENhY2hlID0gUHJlZGljdGlvbkNvbnRleHRDYWNoZTtcbiAgUHJlZGljdGlvbkNvbnRleHRDYWNoZS5VTkNBQ0hFRCA9IG5ldyBQcmVkaWN0aW9uQ29udGV4dENhY2hlKGZhbHNlKTtcbiAgKGZ1bmN0aW9uKFByZWRpY3Rpb25Db250ZXh0Q2FjaGUyKSB7XG4gICAgY2xhc3MgUHJlZGljdGlvbkNvbnRleHRBbmRJbnQge1xuICAgICAgY29uc3RydWN0b3Iob2JqLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgZXF1YWxzKG9iaikge1xuICAgICAgICBpZiAoIShvYmogaW5zdGFuY2VvZiBQcmVkaWN0aW9uQ29udGV4dEFuZEludCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqID09PSB0aGlzKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG90aGVyID0gb2JqO1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gb3RoZXIudmFsdWUgJiYgKHRoaXMub2JqID09PSBvdGhlci5vYmogfHwgdGhpcy5vYmogIT0gbnVsbCAmJiB0aGlzLm9iai5lcXVhbHMob3RoZXIub2JqKSk7XG4gICAgICB9XG4gICAgICBoYXNoQ29kZSgpIHtcbiAgICAgICAgbGV0IGhhc2hDb2RlID0gNTtcbiAgICAgICAgaGFzaENvZGUgPSA3ICogaGFzaENvZGUgKyAodGhpcy5vYmogIT0gbnVsbCA/IHRoaXMub2JqLmhhc2hDb2RlKCkgOiAwKTtcbiAgICAgICAgaGFzaENvZGUgPSA3ICogaGFzaENvZGUgKyB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4gaGFzaENvZGU7XG4gICAgICB9XG4gICAgfVxuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gICAgXSwgUHJlZGljdGlvbkNvbnRleHRBbmRJbnQucHJvdG90eXBlLCBcImVxdWFsc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICAgIF0sIFByZWRpY3Rpb25Db250ZXh0QW5kSW50LnByb3RvdHlwZSwgXCJoYXNoQ29kZVwiLCBudWxsKTtcbiAgICBQcmVkaWN0aW9uQ29udGV4dENhY2hlMi5QcmVkaWN0aW9uQ29udGV4dEFuZEludCA9IFByZWRpY3Rpb25Db250ZXh0QW5kSW50O1xuICAgIGNsYXNzIElkZW50aXR5Q29tbXV0YXRpdmVQcmVkaWN0aW9uQ29udGV4dE9wZXJhbmRzIHtcbiAgICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgYXNzZXJ0KHggIT0gbnVsbCk7XG4gICAgICAgIGFzc2VydCh5ICE9IG51bGwpO1xuICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICB9XG4gICAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgICB9XG4gICAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3k7XG4gICAgICB9XG4gICAgICBlcXVhbHMobykge1xuICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgSWRlbnRpdHlDb21tdXRhdGl2ZVByZWRpY3Rpb25Db250ZXh0T3BlcmFuZHMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMgPT09IG8pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3RoZXIgPSBvO1xuICAgICAgICByZXR1cm4gdGhpcy5feCA9PT0gb3RoZXIuX3ggJiYgdGhpcy5feSA9PT0gb3RoZXIuX3kgfHwgdGhpcy5feCA9PT0gb3RoZXIuX3kgJiYgdGhpcy5feSA9PT0gb3RoZXIuX3g7XG4gICAgICB9XG4gICAgICBoYXNoQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3guaGFzaENvZGUoKSBeIHRoaXMuX3kuaGFzaENvZGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgICBdLCBJZGVudGl0eUNvbW11dGF0aXZlUHJlZGljdGlvbkNvbnRleHRPcGVyYW5kcy5wcm90b3R5cGUsIFwiZXF1YWxzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gICAgXSwgSWRlbnRpdHlDb21tdXRhdGl2ZVByZWRpY3Rpb25Db250ZXh0T3BlcmFuZHMucHJvdG90eXBlLCBcImhhc2hDb2RlXCIsIG51bGwpO1xuICAgIFByZWRpY3Rpb25Db250ZXh0Q2FjaGUyLklkZW50aXR5Q29tbXV0YXRpdmVQcmVkaWN0aW9uQ29udGV4dE9wZXJhbmRzID0gSWRlbnRpdHlDb21tdXRhdGl2ZVByZWRpY3Rpb25Db250ZXh0T3BlcmFuZHM7XG4gIH0pKFByZWRpY3Rpb25Db250ZXh0Q2FjaGUgPSBleHBvcnRzLlByZWRpY3Rpb25Db250ZXh0Q2FjaGUgfHwgKGV4cG9ydHMuUHJlZGljdGlvbkNvbnRleHRDYWNoZSA9IHt9KSk7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9QcmVkaWN0aW9uQ29udGV4dC5qc1xudmFyIHJlcXVpcmVfUHJlZGljdGlvbkNvbnRleHQgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQgPSBleHBvcnRzLlByZWRpY3Rpb25Db250ZXh0ID0gdm9pZCAwO1xuICB2YXIgQXJyYXkyREhhc2hNYXBfMSA9IHJlcXVpcmVfQXJyYXkyREhhc2hNYXAoKTtcbiAgdmFyIEFycmF5MkRIYXNoU2V0XzEgPSByZXF1aXJlX0FycmF5MkRIYXNoU2V0KCk7XG4gIHZhciBBcnJheXNfMSA9IHJlcXVpcmVfQXJyYXlzKCk7XG4gIHZhciBNdXJtdXJIYXNoXzEgPSByZXF1aXJlX011cm11ckhhc2goKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgUHJlZGljdGlvbkNvbnRleHRDYWNoZV8xID0gcmVxdWlyZV9QcmVkaWN0aW9uQ29udGV4dENhY2hlKCk7XG4gIHZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuICB2YXIgSU5JVElBTF9IQVNIID0gMTtcbiAgdmFyIFByZWRpY3Rpb25Db250ZXh0ID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGNhY2hlZEhhc2hDb2RlKSB7XG4gICAgICB0aGlzLmNhY2hlZEhhc2hDb2RlID0gY2FjaGVkSGFzaENvZGU7XG4gICAgfVxuICAgIHN0YXRpYyBjYWxjdWxhdGVFbXB0eUhhc2hDb2RlKCkge1xuICAgICAgbGV0IGhhc2ggPSBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC5pbml0aWFsaXplKElOSVRJQUxfSEFTSCk7XG4gICAgICBoYXNoID0gTXVybXVySGFzaF8xLk11cm11ckhhc2guZmluaXNoKGhhc2gsIDApO1xuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICAgIHN0YXRpYyBjYWxjdWxhdGVTaW5nbGVIYXNoQ29kZShwYXJlbnQsIHJldHVyblN0YXRlKSB7XG4gICAgICBsZXQgaGFzaCA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLmluaXRpYWxpemUoSU5JVElBTF9IQVNIKTtcbiAgICAgIGhhc2ggPSBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC51cGRhdGUoaGFzaCwgcGFyZW50KTtcbiAgICAgIGhhc2ggPSBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC51cGRhdGUoaGFzaCwgcmV0dXJuU3RhdGUpO1xuICAgICAgaGFzaCA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLmZpbmlzaChoYXNoLCAyKTtcbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgICBzdGF0aWMgY2FsY3VsYXRlSGFzaENvZGUocGFyZW50cywgcmV0dXJuU3RhdGVzKSB7XG4gICAgICBsZXQgaGFzaCA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLmluaXRpYWxpemUoSU5JVElBTF9IQVNIKTtcbiAgICAgIGZvciAobGV0IHBhcmVudCBvZiBwYXJlbnRzKSB7XG4gICAgICAgIGhhc2ggPSBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC51cGRhdGUoaGFzaCwgcGFyZW50KTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHJldHVyblN0YXRlIG9mIHJldHVyblN0YXRlcykge1xuICAgICAgICBoYXNoID0gTXVybXVySGFzaF8xLk11cm11ckhhc2gudXBkYXRlKGhhc2gsIHJldHVyblN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGhhc2ggPSBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC5maW5pc2goaGFzaCwgMiAqIHBhcmVudHMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJ1bGVDb250ZXh0KGF0biwgb3V0ZXJDb250ZXh0LCBmdWxsQ29udGV4dCA9IHRydWUpIHtcbiAgICAgIGlmIChvdXRlckNvbnRleHQuaXNFbXB0eSkge1xuICAgICAgICByZXR1cm4gZnVsbENvbnRleHQgPyBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMIDogUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfTE9DQUw7XG4gICAgICB9XG4gICAgICBsZXQgcGFyZW50O1xuICAgICAgaWYgKG91dGVyQ29udGV4dC5fcGFyZW50KSB7XG4gICAgICAgIHBhcmVudCA9IFByZWRpY3Rpb25Db250ZXh0LmZyb21SdWxlQ29udGV4dChhdG4sIG91dGVyQ29udGV4dC5fcGFyZW50LCBmdWxsQ29udGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQgPSBmdWxsQ29udGV4dCA/IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTEwgOiBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9MT0NBTDtcbiAgICAgIH1cbiAgICAgIGxldCBzdGF0ZSA9IGF0bi5zdGF0ZXNbb3V0ZXJDb250ZXh0Lmludm9raW5nU3RhdGVdO1xuICAgICAgbGV0IHRyYW5zaXRpb24gPSBzdGF0ZS50cmFuc2l0aW9uKDApO1xuICAgICAgcmV0dXJuIHBhcmVudC5nZXRDaGlsZCh0cmFuc2l0aW9uLmZvbGxvd1N0YXRlLnN0YXRlTnVtYmVyKTtcbiAgICB9XG4gICAgc3RhdGljIGFkZEVtcHR5Q29udGV4dChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gY29udGV4dC5hZGRFbXB0eUNvbnRleHQoKTtcbiAgICB9XG4gICAgc3RhdGljIHJlbW92ZUVtcHR5Q29udGV4dChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gY29udGV4dC5yZW1vdmVFbXB0eUNvbnRleHQoKTtcbiAgICB9XG4gICAgc3RhdGljIGpvaW4oY29udGV4dDAsIGNvbnRleHQxLCBjb250ZXh0Q2FjaGUgPSBQcmVkaWN0aW9uQ29udGV4dENhY2hlXzEuUHJlZGljdGlvbkNvbnRleHRDYWNoZS5VTkNBQ0hFRCkge1xuICAgICAgaWYgKGNvbnRleHQwID09PSBjb250ZXh0MSkge1xuICAgICAgICByZXR1cm4gY29udGV4dDA7XG4gICAgICB9XG4gICAgICBpZiAoY29udGV4dDAuaXNFbXB0eSkge1xuICAgICAgICByZXR1cm4gUHJlZGljdGlvbkNvbnRleHQuaXNFbXB0eUxvY2FsKGNvbnRleHQwKSA/IGNvbnRleHQwIDogUHJlZGljdGlvbkNvbnRleHQuYWRkRW1wdHlDb250ZXh0KGNvbnRleHQxKTtcbiAgICAgIH0gZWxzZSBpZiAoY29udGV4dDEuaXNFbXB0eSkge1xuICAgICAgICByZXR1cm4gUHJlZGljdGlvbkNvbnRleHQuaXNFbXB0eUxvY2FsKGNvbnRleHQxKSA/IGNvbnRleHQxIDogUHJlZGljdGlvbkNvbnRleHQuYWRkRW1wdHlDb250ZXh0KGNvbnRleHQwKTtcbiAgICAgIH1cbiAgICAgIGxldCBjb250ZXh0MHNpemUgPSBjb250ZXh0MC5zaXplO1xuICAgICAgbGV0IGNvbnRleHQxc2l6ZSA9IGNvbnRleHQxLnNpemU7XG4gICAgICBpZiAoY29udGV4dDBzaXplID09PSAxICYmIGNvbnRleHQxc2l6ZSA9PT0gMSAmJiBjb250ZXh0MC5nZXRSZXR1cm5TdGF0ZSgwKSA9PT0gY29udGV4dDEuZ2V0UmV0dXJuU3RhdGUoMCkpIHtcbiAgICAgICAgbGV0IG1lcmdlZCA9IGNvbnRleHRDYWNoZS5qb2luKGNvbnRleHQwLmdldFBhcmVudCgwKSwgY29udGV4dDEuZ2V0UGFyZW50KDApKTtcbiAgICAgICAgaWYgKG1lcmdlZCA9PT0gY29udGV4dDAuZ2V0UGFyZW50KDApKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQwO1xuICAgICAgICB9IGVsc2UgaWYgKG1lcmdlZCA9PT0gY29udGV4dDEuZ2V0UGFyZW50KDApKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtZXJnZWQuZ2V0Q2hpbGQoY29udGV4dDAuZ2V0UmV0dXJuU3RhdGUoMCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgbGV0IHBhcmVudHNMaXN0ID0gbmV3IEFycmF5KGNvbnRleHQwc2l6ZSArIGNvbnRleHQxc2l6ZSk7XG4gICAgICBsZXQgcmV0dXJuU3RhdGVzTGlzdCA9IG5ldyBBcnJheShwYXJlbnRzTGlzdC5sZW5ndGgpO1xuICAgICAgbGV0IGxlZnRJbmRleCA9IDA7XG4gICAgICBsZXQgcmlnaHRJbmRleCA9IDA7XG4gICAgICBsZXQgY2FuUmV0dXJuTGVmdCA9IHRydWU7XG4gICAgICBsZXQgY2FuUmV0dXJuUmlnaHQgPSB0cnVlO1xuICAgICAgd2hpbGUgKGxlZnRJbmRleCA8IGNvbnRleHQwc2l6ZSAmJiByaWdodEluZGV4IDwgY29udGV4dDFzaXplKSB7XG4gICAgICAgIGlmIChjb250ZXh0MC5nZXRSZXR1cm5TdGF0ZShsZWZ0SW5kZXgpID09PSBjb250ZXh0MS5nZXRSZXR1cm5TdGF0ZShyaWdodEluZGV4KSkge1xuICAgICAgICAgIHBhcmVudHNMaXN0W2NvdW50XSA9IGNvbnRleHRDYWNoZS5qb2luKGNvbnRleHQwLmdldFBhcmVudChsZWZ0SW5kZXgpLCBjb250ZXh0MS5nZXRQYXJlbnQocmlnaHRJbmRleCkpO1xuICAgICAgICAgIHJldHVyblN0YXRlc0xpc3RbY291bnRdID0gY29udGV4dDAuZ2V0UmV0dXJuU3RhdGUobGVmdEluZGV4KTtcbiAgICAgICAgICBjYW5SZXR1cm5MZWZ0ID0gY2FuUmV0dXJuTGVmdCAmJiBwYXJlbnRzTGlzdFtjb3VudF0gPT09IGNvbnRleHQwLmdldFBhcmVudChsZWZ0SW5kZXgpO1xuICAgICAgICAgIGNhblJldHVyblJpZ2h0ID0gY2FuUmV0dXJuUmlnaHQgJiYgcGFyZW50c0xpc3RbY291bnRdID09PSBjb250ZXh0MS5nZXRQYXJlbnQocmlnaHRJbmRleCk7XG4gICAgICAgICAgbGVmdEluZGV4Kys7XG4gICAgICAgICAgcmlnaHRJbmRleCsrO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQwLmdldFJldHVyblN0YXRlKGxlZnRJbmRleCkgPCBjb250ZXh0MS5nZXRSZXR1cm5TdGF0ZShyaWdodEluZGV4KSkge1xuICAgICAgICAgIHBhcmVudHNMaXN0W2NvdW50XSA9IGNvbnRleHQwLmdldFBhcmVudChsZWZ0SW5kZXgpO1xuICAgICAgICAgIHJldHVyblN0YXRlc0xpc3RbY291bnRdID0gY29udGV4dDAuZ2V0UmV0dXJuU3RhdGUobGVmdEluZGV4KTtcbiAgICAgICAgICBjYW5SZXR1cm5SaWdodCA9IGZhbHNlO1xuICAgICAgICAgIGxlZnRJbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2VydChjb250ZXh0MS5nZXRSZXR1cm5TdGF0ZShyaWdodEluZGV4KSA8IGNvbnRleHQwLmdldFJldHVyblN0YXRlKGxlZnRJbmRleCkpO1xuICAgICAgICAgIHBhcmVudHNMaXN0W2NvdW50XSA9IGNvbnRleHQxLmdldFBhcmVudChyaWdodEluZGV4KTtcbiAgICAgICAgICByZXR1cm5TdGF0ZXNMaXN0W2NvdW50XSA9IGNvbnRleHQxLmdldFJldHVyblN0YXRlKHJpZ2h0SW5kZXgpO1xuICAgICAgICAgIGNhblJldHVybkxlZnQgPSBmYWxzZTtcbiAgICAgICAgICByaWdodEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICAgIHdoaWxlIChsZWZ0SW5kZXggPCBjb250ZXh0MHNpemUpIHtcbiAgICAgICAgcGFyZW50c0xpc3RbY291bnRdID0gY29udGV4dDAuZ2V0UGFyZW50KGxlZnRJbmRleCk7XG4gICAgICAgIHJldHVyblN0YXRlc0xpc3RbY291bnRdID0gY29udGV4dDAuZ2V0UmV0dXJuU3RhdGUobGVmdEluZGV4KTtcbiAgICAgICAgbGVmdEluZGV4Kys7XG4gICAgICAgIGNhblJldHVyblJpZ2h0ID0gZmFsc2U7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgICB3aGlsZSAocmlnaHRJbmRleCA8IGNvbnRleHQxc2l6ZSkge1xuICAgICAgICBwYXJlbnRzTGlzdFtjb3VudF0gPSBjb250ZXh0MS5nZXRQYXJlbnQocmlnaHRJbmRleCk7XG4gICAgICAgIHJldHVyblN0YXRlc0xpc3RbY291bnRdID0gY29udGV4dDEuZ2V0UmV0dXJuU3RhdGUocmlnaHRJbmRleCk7XG4gICAgICAgIHJpZ2h0SW5kZXgrKztcbiAgICAgICAgY2FuUmV0dXJuTGVmdCA9IGZhbHNlO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgICAgaWYgKGNhblJldHVybkxlZnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQwO1xuICAgICAgfSBlbHNlIGlmIChjYW5SZXR1cm5SaWdodCkge1xuICAgICAgICByZXR1cm4gY29udGV4dDE7XG4gICAgICB9XG4gICAgICBpZiAoY291bnQgPCBwYXJlbnRzTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgcGFyZW50c0xpc3QgPSBwYXJlbnRzTGlzdC5zbGljZSgwLCBjb3VudCk7XG4gICAgICAgIHJldHVyblN0YXRlc0xpc3QgPSByZXR1cm5TdGF0ZXNMaXN0LnNsaWNlKDAsIGNvdW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTEw7XG4gICAgICB9IGVsc2UgaWYgKHBhcmVudHNMaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gbmV3IFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0KHBhcmVudHNMaXN0WzBdLCByZXR1cm5TdGF0ZXNMaXN0WzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlQcmVkaWN0aW9uQ29udGV4dChwYXJlbnRzTGlzdCwgcmV0dXJuU3RhdGVzTGlzdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBpc0VtcHR5TG9jYWwoY29udGV4dCkge1xuICAgICAgcmV0dXJuIGNvbnRleHQgPT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0xPQ0FMO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q2FjaGVkQ29udGV4dChjb250ZXh0LCBjb250ZXh0Q2FjaGUsIHZpc2l0ZWQpIHtcbiAgICAgIGlmIChjb250ZXh0LmlzRW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICB9XG4gICAgICBsZXQgZXhpc3RpbmcgPSB2aXNpdGVkLmdldChjb250ZXh0KTtcbiAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICB9XG4gICAgICBleGlzdGluZyA9IGNvbnRleHRDYWNoZS5nZXQoY29udGV4dCk7XG4gICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgdmlzaXRlZC5wdXQoY29udGV4dCwgZXhpc3RpbmcpO1xuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICB9XG4gICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgbGV0IHBhcmVudHMgPSBuZXcgQXJyYXkoY29udGV4dC5zaXplKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcGFyZW50ID0gUHJlZGljdGlvbkNvbnRleHQuZ2V0Q2FjaGVkQ29udGV4dChjb250ZXh0LmdldFBhcmVudChpKSwgY29udGV4dENhY2hlLCB2aXNpdGVkKTtcbiAgICAgICAgaWYgKGNoYW5nZWQgfHwgcGFyZW50ICE9PSBjb250ZXh0LmdldFBhcmVudChpKSkge1xuICAgICAgICAgIGlmICghY2hhbmdlZCkge1xuICAgICAgICAgICAgcGFyZW50cyA9IG5ldyBBcnJheShjb250ZXh0LnNpemUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb250ZXh0LnNpemU7IGorKykge1xuICAgICAgICAgICAgICBwYXJlbnRzW2pdID0gY29udGV4dC5nZXRQYXJlbnQoaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50c1tpXSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjaGFuZ2VkKSB7XG4gICAgICAgIGV4aXN0aW5nID0gY29udGV4dENhY2hlLnB1dElmQWJzZW50KGNvbnRleHQsIGNvbnRleHQpO1xuICAgICAgICB2aXNpdGVkLnB1dChjb250ZXh0LCBleGlzdGluZyAhPSBudWxsID8gZXhpc3RpbmcgOiBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICB9XG4gICAgICBsZXQgdXBkYXRlZDtcbiAgICAgIGlmIChwYXJlbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB1cGRhdGVkID0gbmV3IFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0KHBhcmVudHNbMF0sIGNvbnRleHQuZ2V0UmV0dXJuU3RhdGUoMCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHJldHVyblN0YXRlcyA9IG5ldyBBcnJheShjb250ZXh0LnNpemUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRleHQuc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgcmV0dXJuU3RhdGVzW2ldID0gY29udGV4dC5nZXRSZXR1cm5TdGF0ZShpKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVkID0gbmV3IEFycmF5UHJlZGljdGlvbkNvbnRleHQocGFyZW50cywgcmV0dXJuU3RhdGVzLCBjb250ZXh0Lmhhc2hDb2RlKCkpO1xuICAgICAgfVxuICAgICAgZXhpc3RpbmcgPSBjb250ZXh0Q2FjaGUucHV0SWZBYnNlbnQodXBkYXRlZCwgdXBkYXRlZCk7XG4gICAgICB2aXNpdGVkLnB1dCh1cGRhdGVkLCBleGlzdGluZyB8fCB1cGRhdGVkKTtcbiAgICAgIHZpc2l0ZWQucHV0KGNvbnRleHQsIGV4aXN0aW5nIHx8IHVwZGF0ZWQpO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfVxuICAgIGFwcGVuZFNpbmdsZUNvbnRleHQocmV0dXJuQ29udGV4dCwgY29udGV4dENhY2hlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcHBlbmRDb250ZXh0KFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTEwuZ2V0Q2hpbGQocmV0dXJuQ29udGV4dCksIGNvbnRleHRDYWNoZSk7XG4gICAgfVxuICAgIGdldENoaWxkKHJldHVyblN0YXRlKSB7XG4gICAgICByZXR1cm4gbmV3IFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0KHRoaXMsIHJldHVyblN0YXRlKTtcbiAgICB9XG4gICAgaGFzaENvZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZWRIYXNoQ29kZTtcbiAgICB9XG4gICAgdG9TdHJpbmdzKHJlY29nbml6ZXIsIGN1cnJlbnRTdGF0ZSwgc3RvcCA9IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTEwpIHtcbiAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgIG91dGVyOlxuICAgICAgICBmb3IgKGxldCBwZXJtID0gMDsgOyBwZXJtKyspIHtcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgICBsZXQgbGFzdCA9IHRydWU7XG4gICAgICAgICAgbGV0IHAgPSB0aGlzO1xuICAgICAgICAgIGxldCBzdGF0ZU51bWJlciA9IGN1cnJlbnRTdGF0ZTtcbiAgICAgICAgICBsZXQgbG9jYWxCdWZmZXIgPSBcIlwiO1xuICAgICAgICAgIGxvY2FsQnVmZmVyICs9IFwiW1wiO1xuICAgICAgICAgIHdoaWxlICghcC5pc0VtcHR5ICYmIHAgIT09IHN0b3ApIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAocC5zaXplID4gMCkge1xuICAgICAgICAgICAgICBsZXQgYml0cyA9IDE7XG4gICAgICAgICAgICAgIHdoaWxlICgxIDw8IGJpdHMgPj4+IDAgPCBwLnNpemUpIHtcbiAgICAgICAgICAgICAgICBiaXRzKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IG1hc2sgPSAoMSA8PCBiaXRzID4+PiAwKSAtIDE7XG4gICAgICAgICAgICAgIGluZGV4ID0gcGVybSA+PiBvZmZzZXQgJiBtYXNrO1xuICAgICAgICAgICAgICBsYXN0ID0gbGFzdCAmJiBpbmRleCA+PSBwLnNpemUgLSAxO1xuICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gcC5zaXplKSB7XG4gICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IGJpdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgICAgICAgICBpZiAobG9jYWxCdWZmZXIubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGxvY2FsQnVmZmVyICs9IFwiIFwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBhdG4gPSByZWNvZ25pemVyLmF0bjtcbiAgICAgICAgICAgICAgbGV0IHMgPSBhdG4uc3RhdGVzW3N0YXRlTnVtYmVyXTtcbiAgICAgICAgICAgICAgbGV0IHJ1bGVOYW1lID0gcmVjb2duaXplci5ydWxlTmFtZXNbcy5ydWxlSW5kZXhdO1xuICAgICAgICAgICAgICBsb2NhbEJ1ZmZlciArPSBydWxlTmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocC5nZXRSZXR1cm5TdGF0ZShpbmRleCkgIT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZKSB7XG4gICAgICAgICAgICAgIGlmICghcC5pc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsQnVmZmVyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIGxvY2FsQnVmZmVyICs9IFwiIFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbEJ1ZmZlciArPSBwLmdldFJldHVyblN0YXRlKGluZGV4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGVOdW1iZXIgPSBwLmdldFJldHVyblN0YXRlKGluZGV4KTtcbiAgICAgICAgICAgIHAgPSBwLmdldFBhcmVudChpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvY2FsQnVmZmVyICs9IFwiXVwiO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGxvY2FsQnVmZmVyKTtcbiAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFByZWRpY3Rpb25Db250ZXh0LnByb3RvdHlwZSwgXCJoYXNoQ29kZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgyLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgUHJlZGljdGlvbkNvbnRleHQsIFwiam9pblwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgyLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgUHJlZGljdGlvbkNvbnRleHQsIFwiZ2V0Q2FjaGVkQ29udGV4dFwiLCBudWxsKTtcbiAgZXhwb3J0cy5QcmVkaWN0aW9uQ29udGV4dCA9IFByZWRpY3Rpb25Db250ZXh0O1xuICB2YXIgRW1wdHlQcmVkaWN0aW9uQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgUHJlZGljdGlvbkNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKGZ1bGxDb250ZXh0KSB7XG4gICAgICBzdXBlcihQcmVkaWN0aW9uQ29udGV4dC5jYWxjdWxhdGVFbXB0eUhhc2hDb2RlKCkpO1xuICAgICAgdGhpcy5mdWxsQ29udGV4dCA9IGZ1bGxDb250ZXh0O1xuICAgIH1cbiAgICBnZXQgaXNGdWxsQ29udGV4dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZ1bGxDb250ZXh0O1xuICAgIH1cbiAgICBhZGRFbXB0eUNvbnRleHQoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlRW1wdHlDb250ZXh0KCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlbW92ZSB0aGUgZW1wdHkgY29udGV4dCBmcm9tIGl0c2VsZi5cIik7XG4gICAgfVxuICAgIGdldFBhcmVudChpbmRleCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbiAgICB9XG4gICAgZ2V0UmV0dXJuU3RhdGUoaW5kZXgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG4gICAgfVxuICAgIGZpbmRSZXR1cm5TdGF0ZShyZXR1cm5TdGF0ZSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBhcHBlbmRTaW5nbGVDb250ZXh0KHJldHVybkNvbnRleHQsIGNvbnRleHRDYWNoZSkge1xuICAgICAgcmV0dXJuIGNvbnRleHRDYWNoZS5nZXRDaGlsZCh0aGlzLCByZXR1cm5Db250ZXh0KTtcbiAgICB9XG4gICAgYXBwZW5kQ29udGV4dChzdWZmaXgsIGNvbnRleHRDYWNoZSkge1xuICAgICAgcmV0dXJuIHN1ZmZpeDtcbiAgICB9XG4gICAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IGhhc0VtcHR5KCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVxdWFscyhvKSB7XG4gICAgICByZXR1cm4gdGhpcyA9PT0gbztcbiAgICB9XG4gICAgdG9TdHJpbmdzKHJlY29nbml6ZXIsIGN1cnJlbnRTdGF0ZSwgc3RvcCkge1xuICAgICAgcmV0dXJuIFtcIltdXCJdO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEVtcHR5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLCBcImFkZEVtcHR5Q29udGV4dFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEVtcHR5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLCBcInJlbW92ZUVtcHR5Q29udGV4dFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEVtcHR5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLCBcImdldFBhcmVudFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEVtcHR5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLCBcImdldFJldHVyblN0YXRlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgRW1wdHlQcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUsIFwiZmluZFJldHVyblN0YXRlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgRW1wdHlQcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUsIFwic2l6ZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEVtcHR5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLCBcImFwcGVuZFNpbmdsZUNvbnRleHRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBFbXB0eVByZWRpY3Rpb25Db250ZXh0LnByb3RvdHlwZSwgXCJhcHBlbmRDb250ZXh0XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgRW1wdHlQcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUsIFwiaXNFbXB0eVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEVtcHR5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLCBcImhhc0VtcHR5XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgRW1wdHlQcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUsIFwiZXF1YWxzXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgRW1wdHlQcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUsIFwidG9TdHJpbmdzXCIsIG51bGwpO1xuICB2YXIgQXJyYXlQcmVkaWN0aW9uQ29udGV4dCA9IGNsYXNzIEFycmF5UHJlZGljdGlvbkNvbnRleHQyIGV4dGVuZHMgUHJlZGljdGlvbkNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudHMsIHJldHVyblN0YXRlcywgaGFzaENvZGUpIHtcbiAgICAgIHN1cGVyKGhhc2hDb2RlIHx8IFByZWRpY3Rpb25Db250ZXh0LmNhbGN1bGF0ZUhhc2hDb2RlKHBhcmVudHMsIHJldHVyblN0YXRlcykpO1xuICAgICAgYXNzZXJ0KHBhcmVudHMubGVuZ3RoID09PSByZXR1cm5TdGF0ZXMubGVuZ3RoKTtcbiAgICAgIGFzc2VydChyZXR1cm5TdGF0ZXMubGVuZ3RoID4gMSB8fCByZXR1cm5TdGF0ZXNbMF0gIT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZLCBcIlNob3VsZCBiZSB1c2luZyBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWSBpbnN0ZWFkLlwiKTtcbiAgICAgIHRoaXMucGFyZW50cyA9IHBhcmVudHM7XG4gICAgICB0aGlzLnJldHVyblN0YXRlcyA9IHJldHVyblN0YXRlcztcbiAgICB9XG4gICAgZ2V0UGFyZW50KGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnRzW2luZGV4XTtcbiAgICB9XG4gICAgZ2V0UmV0dXJuU3RhdGUoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldHVyblN0YXRlc1tpbmRleF07XG4gICAgfVxuICAgIGZpbmRSZXR1cm5TdGF0ZShyZXR1cm5TdGF0ZSkge1xuICAgICAgcmV0dXJuIEFycmF5c18xLkFycmF5cy5iaW5hcnlTZWFyY2godGhpcy5yZXR1cm5TdGF0ZXMsIHJldHVyblN0YXRlKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXR1cm5TdGF0ZXMubGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgaXNFbXB0eSgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGhhc0VtcHR5KCkge1xuICAgICAgcmV0dXJuIHRoaXMucmV0dXJuU3RhdGVzW3RoaXMucmV0dXJuU3RhdGVzLmxlbmd0aCAtIDFdID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWTtcbiAgICB9XG4gICAgYWRkRW1wdHlDb250ZXh0KCkge1xuICAgICAgaWYgKHRoaXMuaGFzRW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBsZXQgcGFyZW50czIgPSB0aGlzLnBhcmVudHMuc2xpY2UoMCk7XG4gICAgICBsZXQgcmV0dXJuU3RhdGVzMiA9IHRoaXMucmV0dXJuU3RhdGVzLnNsaWNlKDApO1xuICAgICAgcGFyZW50czIucHVzaChQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMKTtcbiAgICAgIHJldHVyblN0YXRlczIucHVzaChQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWSk7XG4gICAgICByZXR1cm4gbmV3IEFycmF5UHJlZGljdGlvbkNvbnRleHQyKHBhcmVudHMyLCByZXR1cm5TdGF0ZXMyKTtcbiAgICB9XG4gICAgcmVtb3ZlRW1wdHlDb250ZXh0KCkge1xuICAgICAgaWYgKCF0aGlzLmhhc0VtcHR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmV0dXJuU3RhdGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICByZXR1cm4gbmV3IFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0KHRoaXMucGFyZW50c1swXSwgdGhpcy5yZXR1cm5TdGF0ZXNbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHBhcmVudHMyID0gdGhpcy5wYXJlbnRzLnNsaWNlKDAsIHRoaXMucGFyZW50cy5sZW5ndGggLSAxKTtcbiAgICAgICAgbGV0IHJldHVyblN0YXRlczIgPSB0aGlzLnJldHVyblN0YXRlcy5zbGljZSgwLCB0aGlzLnJldHVyblN0YXRlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheVByZWRpY3Rpb25Db250ZXh0MihwYXJlbnRzMiwgcmV0dXJuU3RhdGVzMik7XG4gICAgICB9XG4gICAgfVxuICAgIGFwcGVuZENvbnRleHQoc3VmZml4LCBjb250ZXh0Q2FjaGUpIHtcbiAgICAgIHJldHVybiBBcnJheVByZWRpY3Rpb25Db250ZXh0Mi5hcHBlbmRDb250ZXh0SW1wbCh0aGlzLCBzdWZmaXgsIG5ldyBQcmVkaWN0aW9uQ29udGV4dC5JZGVudGl0eUhhc2hNYXAoKSk7XG4gICAgfVxuICAgIHN0YXRpYyBhcHBlbmRDb250ZXh0SW1wbChjb250ZXh0LCBzdWZmaXgsIHZpc2l0ZWQpIHtcbiAgICAgIGlmIChzdWZmaXguaXNFbXB0eSkge1xuICAgICAgICBpZiAoUHJlZGljdGlvbkNvbnRleHQuaXNFbXB0eUxvY2FsKHN1ZmZpeCkpIHtcbiAgICAgICAgICBpZiAoY29udGV4dC5oYXNFbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0xPQ0FMO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3aGF0IHRvIGRvIGhlcmU/XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgfVxuICAgICAgaWYgKHN1ZmZpeC5zaXplICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFwcGVuZGluZyBhIHRyZWUgc3VmZml4IGlzIG5vdCB5ZXQgc3VwcG9ydGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIGxldCByZXN1bHQgPSB2aXNpdGVkLmdldChjb250ZXh0KTtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmlzRW1wdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSBzdWZmaXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IHBhcmVudENvdW50ID0gY29udGV4dC5zaXplO1xuICAgICAgICAgIGlmIChjb250ZXh0Lmhhc0VtcHR5KSB7XG4gICAgICAgICAgICBwYXJlbnRDb3VudC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgdXBkYXRlZFBhcmVudHMgPSBuZXcgQXJyYXkocGFyZW50Q291bnQpO1xuICAgICAgICAgIGxldCB1cGRhdGVkUmV0dXJuU3RhdGVzID0gbmV3IEFycmF5KHBhcmVudENvdW50KTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHVwZGF0ZWRSZXR1cm5TdGF0ZXNbaV0gPSBjb250ZXh0LmdldFJldHVyblN0YXRlKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHVwZGF0ZWRQYXJlbnRzW2ldID0gQXJyYXlQcmVkaWN0aW9uQ29udGV4dDIuYXBwZW5kQ29udGV4dEltcGwoY29udGV4dC5nZXRQYXJlbnQoaSksIHN1ZmZpeCwgdmlzaXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1cGRhdGVkUGFyZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dCh1cGRhdGVkUGFyZW50c1swXSwgdXBkYXRlZFJldHVyblN0YXRlc1swXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydCh1cGRhdGVkUGFyZW50cy5sZW5ndGggPiAxKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBcnJheVByZWRpY3Rpb25Db250ZXh0Mih1cGRhdGVkUGFyZW50cywgdXBkYXRlZFJldHVyblN0YXRlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb250ZXh0Lmhhc0VtcHR5KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBQcmVkaWN0aW9uQ29udGV4dC5qb2luKHJlc3VsdCwgc3VmZml4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRlZC5wdXQoY29udGV4dCwgcmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVxdWFscyhvKSB7XG4gICAgICBpZiAodGhpcyA9PT0gbykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIShvIGluc3RhbmNlb2YgQXJyYXlQcmVkaWN0aW9uQ29udGV4dDIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc2hDb2RlKCkgIT09IG8uaGFzaENvZGUoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBsZXQgb3RoZXIgPSBvO1xuICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzSW1wbChvdGhlciwgbmV3IEFycmF5MkRIYXNoU2V0XzEuQXJyYXkyREhhc2hTZXQoKSk7XG4gICAgfVxuICAgIGVxdWFsc0ltcGwob3RoZXIsIHZpc2l0ZWQpIHtcbiAgICAgIGxldCBzZWxmV29ya0xpc3QgPSBbXTtcbiAgICAgIGxldCBvdGhlcldvcmtMaXN0ID0gW107XG4gICAgICBzZWxmV29ya0xpc3QucHVzaCh0aGlzKTtcbiAgICAgIG90aGVyV29ya0xpc3QucHVzaChvdGhlcik7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgY3VycmVudFNlbGYgPSBzZWxmV29ya0xpc3QucG9wKCk7XG4gICAgICAgIGxldCBjdXJyZW50T3RoZXIgPSBvdGhlcldvcmtMaXN0LnBvcCgpO1xuICAgICAgICBpZiAoIWN1cnJlbnRTZWxmIHx8ICFjdXJyZW50T3RoZXIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3BlcmFuZHMgPSBuZXcgUHJlZGljdGlvbkNvbnRleHRDYWNoZV8xLlByZWRpY3Rpb25Db250ZXh0Q2FjaGUuSWRlbnRpdHlDb21tdXRhdGl2ZVByZWRpY3Rpb25Db250ZXh0T3BlcmFuZHMoY3VycmVudFNlbGYsIGN1cnJlbnRPdGhlcik7XG4gICAgICAgIGlmICghdmlzaXRlZC5hZGQob3BlcmFuZHMpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlbGZTaXplID0gb3BlcmFuZHMueC5zaXplO1xuICAgICAgICBpZiAoc2VsZlNpemUgPT09IDApIHtcbiAgICAgICAgICBpZiAoIW9wZXJhbmRzLnguZXF1YWxzKG9wZXJhbmRzLnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdGhlclNpemUgPSBvcGVyYW5kcy55LnNpemU7XG4gICAgICAgIGlmIChzZWxmU2l6ZSAhPT0gb3RoZXJTaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZlNpemU7IGkrKykge1xuICAgICAgICAgIGlmIChvcGVyYW5kcy54LmdldFJldHVyblN0YXRlKGkpICE9PSBvcGVyYW5kcy55LmdldFJldHVyblN0YXRlKGkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBzZWxmUGFyZW50ID0gb3BlcmFuZHMueC5nZXRQYXJlbnQoaSk7XG4gICAgICAgICAgbGV0IG90aGVyUGFyZW50ID0gb3BlcmFuZHMueS5nZXRQYXJlbnQoaSk7XG4gICAgICAgICAgaWYgKHNlbGZQYXJlbnQuaGFzaENvZGUoKSAhPT0gb3RoZXJQYXJlbnQuaGFzaENvZGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2VsZlBhcmVudCAhPT0gb3RoZXJQYXJlbnQpIHtcbiAgICAgICAgICAgIHNlbGZXb3JrTGlzdC5wdXNoKHNlbGZQYXJlbnQpO1xuICAgICAgICAgICAgb3RoZXJXb3JrTGlzdC5wdXNoKG90aGVyUGFyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgQXJyYXlQcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUsIFwicGFyZW50c1wiLCB2b2lkIDApO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBBcnJheVByZWRpY3Rpb25Db250ZXh0LnByb3RvdHlwZSwgXCJyZXR1cm5TdGF0ZXNcIiwgdm9pZCAwKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEFycmF5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLCBcImdldFBhcmVudFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEFycmF5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLCBcImdldFJldHVyblN0YXRlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQXJyYXlQcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUsIFwiZmluZFJldHVyblN0YXRlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQXJyYXlQcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUsIFwic2l6ZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEFycmF5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLCBcImlzRW1wdHlcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBBcnJheVByZWRpY3Rpb25Db250ZXh0LnByb3RvdHlwZSwgXCJoYXNFbXB0eVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEFycmF5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLCBcImFkZEVtcHR5Q29udGV4dFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEFycmF5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLCBcInJlbW92ZUVtcHR5Q29udGV4dFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEFycmF5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLCBcImFwcGVuZENvbnRleHRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBBcnJheVByZWRpY3Rpb25Db250ZXh0LnByb3RvdHlwZSwgXCJlcXVhbHNcIiwgbnVsbCk7XG4gIEFycmF5UHJlZGljdGlvbkNvbnRleHQgPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBBcnJheVByZWRpY3Rpb25Db250ZXh0KTtcbiAgdmFyIFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0ID0gY2xhc3MgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQyIGV4dGVuZHMgUHJlZGljdGlvbkNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgcmV0dXJuU3RhdGUpIHtcbiAgICAgIHN1cGVyKFByZWRpY3Rpb25Db250ZXh0LmNhbGN1bGF0ZVNpbmdsZUhhc2hDb2RlKHBhcmVudCwgcmV0dXJuU3RhdGUpKTtcbiAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgdGhpcy5yZXR1cm5TdGF0ZSA9IHJldHVyblN0YXRlO1xuICAgIH1cbiAgICBnZXRQYXJlbnQoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICB9XG4gICAgZ2V0UmV0dXJuU3RhdGUoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldHVyblN0YXRlO1xuICAgIH1cbiAgICBmaW5kUmV0dXJuU3RhdGUocmV0dXJuU3RhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldHVyblN0YXRlID09PSByZXR1cm5TdGF0ZSA/IDAgOiAtMTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBoYXNFbXB0eSgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXBwZW5kQ29udGV4dChzdWZmaXgsIGNvbnRleHRDYWNoZSkge1xuICAgICAgcmV0dXJuIGNvbnRleHRDYWNoZS5nZXRDaGlsZCh0aGlzLnBhcmVudC5hcHBlbmRDb250ZXh0KHN1ZmZpeCwgY29udGV4dENhY2hlKSwgdGhpcy5yZXR1cm5TdGF0ZSk7XG4gICAgfVxuICAgIGFkZEVtcHR5Q29udGV4dCgpIHtcbiAgICAgIGxldCBwYXJlbnRzID0gW3RoaXMucGFyZW50LCBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMXTtcbiAgICAgIGxldCByZXR1cm5TdGF0ZXMgPSBbdGhpcy5yZXR1cm5TdGF0ZSwgUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTF9TVEFURV9LRVldO1xuICAgICAgcmV0dXJuIG5ldyBBcnJheVByZWRpY3Rpb25Db250ZXh0KHBhcmVudHMsIHJldHVyblN0YXRlcyk7XG4gICAgfVxuICAgIHJlbW92ZUVtcHR5Q29udGV4dCgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBlcXVhbHMobykge1xuICAgICAgaWYgKG8gPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCEobyBpbnN0YW5jZW9mIFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0MikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbGV0IG90aGVyID0gbztcbiAgICAgIGlmICh0aGlzLmhhc2hDb2RlKCkgIT09IG90aGVyLmhhc2hDb2RlKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmV0dXJuU3RhdGUgPT09IG90aGVyLnJldHVyblN0YXRlICYmIHRoaXMucGFyZW50LmVxdWFscyhvdGhlci5wYXJlbnQpO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLCBcInBhcmVudFwiLCB2b2lkIDApO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLCBcImdldFBhcmVudFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0LnByb3RvdHlwZSwgXCJnZXRSZXR1cm5TdGF0ZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0LnByb3RvdHlwZSwgXCJmaW5kUmV0dXJuU3RhdGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUsIFwic2l6ZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0LnByb3RvdHlwZSwgXCJpc0VtcHR5XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLCBcImhhc0VtcHR5XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLCBcImFwcGVuZENvbnRleHRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUsIFwiYWRkRW1wdHlDb250ZXh0XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLCBcInJlbW92ZUVtcHR5Q29udGV4dFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0LnByb3RvdHlwZSwgXCJlcXVhbHNcIiwgbnVsbCk7XG4gIFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0ID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQpO1xuICBleHBvcnRzLlNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0ID0gU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQ7XG4gIChmdW5jdGlvbihQcmVkaWN0aW9uQ29udGV4dDIpIHtcbiAgICBQcmVkaWN0aW9uQ29udGV4dDIuRU1QVFlfTE9DQUwgPSBuZXcgRW1wdHlQcmVkaWN0aW9uQ29udGV4dChmYWxzZSk7XG4gICAgUHJlZGljdGlvbkNvbnRleHQyLkVNUFRZX0ZVTEwgPSBuZXcgRW1wdHlQcmVkaWN0aW9uQ29udGV4dCh0cnVlKTtcbiAgICBQcmVkaWN0aW9uQ29udGV4dDIuRU1QVFlfTE9DQUxfU1RBVEVfS0VZID0gLSgxIDw8IDMxID4+PiAwKTtcbiAgICBQcmVkaWN0aW9uQ29udGV4dDIuRU1QVFlfRlVMTF9TVEFURV9LRVkgPSAoMSA8PCAzMSA+Pj4gMCkgLSAxO1xuICAgIGNsYXNzIElkZW50aXR5SGFzaE1hcCBleHRlbmRzIEFycmF5MkRIYXNoTWFwXzEuQXJyYXkyREhhc2hNYXAge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKElkZW50aXR5RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFKTtcbiAgICAgIH1cbiAgICB9XG4gICAgUHJlZGljdGlvbkNvbnRleHQyLklkZW50aXR5SGFzaE1hcCA9IElkZW50aXR5SGFzaE1hcDtcbiAgICBjbGFzcyBJZGVudGl0eUVxdWFsaXR5Q29tcGFyYXRvciB7XG4gICAgICBJZGVudGl0eUVxdWFsaXR5Q29tcGFyYXRvcigpIHtcbiAgICAgIH1cbiAgICAgIGhhc2hDb2RlKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqLmhhc2hDb2RlKCk7XG4gICAgICB9XG4gICAgICBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICAgIH1cbiAgICB9XG4gICAgSWRlbnRpdHlFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UgPSBuZXcgSWRlbnRpdHlFcXVhbGl0eUNvbXBhcmF0b3IoKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICAgIF0sIElkZW50aXR5RXF1YWxpdHlDb21wYXJhdG9yLnByb3RvdHlwZSwgXCJoYXNoQ29kZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICAgIF0sIElkZW50aXR5RXF1YWxpdHlDb21wYXJhdG9yLnByb3RvdHlwZSwgXCJlcXVhbHNcIiwgbnVsbCk7XG4gICAgUHJlZGljdGlvbkNvbnRleHQyLklkZW50aXR5RXF1YWxpdHlDb21wYXJhdG9yID0gSWRlbnRpdHlFcXVhbGl0eUNvbXBhcmF0b3I7XG4gIH0pKFByZWRpY3Rpb25Db250ZXh0ID0gZXhwb3J0cy5QcmVkaWN0aW9uQ29udGV4dCB8fCAoZXhwb3J0cy5QcmVkaWN0aW9uQ29udGV4dCA9IHt9KSk7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9BVE5Db25maWcuanNcbnZhciByZXF1aXJlX0FUTkNvbmZpZyA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgdmFyIF9fcGFyYW0gPSBleHBvcnRzICYmIGV4cG9ydHMuX19wYXJhbSB8fCBmdW5jdGlvbihwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7XG4gICAgfTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5BVE5Db25maWcgPSB2b2lkIDA7XG4gIHZhciBBcnJheTJESGFzaE1hcF8xID0gcmVxdWlyZV9BcnJheTJESGFzaE1hcCgpO1xuICB2YXIgRGVjaXNpb25TdGF0ZV8xID0gcmVxdWlyZV9EZWNpc2lvblN0YXRlKCk7XG4gIHZhciBNdXJtdXJIYXNoXzEgPSByZXF1aXJlX011cm11ckhhc2goKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yXzEgPSByZXF1aXJlX09iamVjdEVxdWFsaXR5Q29tcGFyYXRvcigpO1xuICB2YXIgUHJlZGljdGlvbkNvbnRleHRfMSA9IHJlcXVpcmVfUHJlZGljdGlvbkNvbnRleHQoKTtcbiAgdmFyIFNlbWFudGljQ29udGV4dF8xID0gcmVxdWlyZV9TZW1hbnRpY0NvbnRleHQoKTtcbiAgdmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG4gIHZhciBTVVBQUkVTU19QUkVDRURFTkNFX0ZJTFRFUiA9IDIxNDc0ODM2NDg7XG4gIHZhciBBVE5Db25maWcgPSBjbGFzcyBBVE5Db25maWcyIHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0ZSwgYWx0T3JDb25maWcsIGNvbnRleHQpIHtcbiAgICAgIGlmICh0eXBlb2YgYWx0T3JDb25maWcgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgYXNzZXJ0KChhbHRPckNvbmZpZyAmIDE2Nzc3MjE1KSA9PT0gYWx0T3JDb25maWcpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLmFsdEFuZE91dGVyQ29udGV4dERlcHRoID0gYWx0T3JDb25maWc7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5hbHRBbmRPdXRlckNvbnRleHREZXB0aCA9IGFsdE9yQ29uZmlnLmFsdEFuZE91dGVyQ29udGV4dERlcHRoO1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShzdGF0ZSwgYWx0LCBjb250ZXh0LCBzZW1hbnRpY0NvbnRleHQgPSBTZW1hbnRpY0NvbnRleHRfMS5TZW1hbnRpY0NvbnRleHQuTk9ORSwgbGV4ZXJBY3Rpb25FeGVjdXRvcikge1xuICAgICAgaWYgKHNlbWFudGljQ29udGV4dCAhPT0gU2VtYW50aWNDb250ZXh0XzEuU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcbiAgICAgICAgaWYgKGxleGVyQWN0aW9uRXhlY3V0b3IgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQWN0aW9uU2VtYW50aWNDb250ZXh0QVROQ29uZmlnKGxleGVyQWN0aW9uRXhlY3V0b3IsIHNlbWFudGljQ29udGV4dCwgc3RhdGUsIGFsdCwgY29udGV4dCwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgU2VtYW50aWNDb250ZXh0QVROQ29uZmlnKHNlbWFudGljQ29udGV4dCwgc3RhdGUsIGFsdCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobGV4ZXJBY3Rpb25FeGVjdXRvciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWN0aW9uQVROQ29uZmlnKGxleGVyQWN0aW9uRXhlY3V0b3IsIHN0YXRlLCBhbHQsIGNvbnRleHQsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQVROQ29uZmlnMihzdGF0ZSwgYWx0LCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cbiAgICBnZXQgYWx0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWx0QW5kT3V0ZXJDb250ZXh0RGVwdGggJiAxNjc3NzIxNTtcbiAgICB9XG4gICAgZ2V0IGNvbnRleHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGV4dDtcbiAgICB9XG4gICAgc2V0IGNvbnRleHQoY29udGV4dCkge1xuICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIGdldCByZWFjaGVzSW50b091dGVyQ29udGV4dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm91dGVyQ29udGV4dERlcHRoICE9PSAwO1xuICAgIH1cbiAgICBnZXQgb3V0ZXJDb250ZXh0RGVwdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hbHRBbmRPdXRlckNvbnRleHREZXB0aCA+Pj4gMjQgJiAxMjc7XG4gICAgfVxuICAgIHNldCBvdXRlckNvbnRleHREZXB0aChvdXRlckNvbnRleHREZXB0aCkge1xuICAgICAgYXNzZXJ0KG91dGVyQ29udGV4dERlcHRoID49IDApO1xuICAgICAgb3V0ZXJDb250ZXh0RGVwdGggPSBNYXRoLm1pbihvdXRlckNvbnRleHREZXB0aCwgMTI3KTtcbiAgICAgIHRoaXMuYWx0QW5kT3V0ZXJDb250ZXh0RGVwdGggPSBvdXRlckNvbnRleHREZXB0aCA8PCAyNCB8ICh0aGlzLmFsdEFuZE91dGVyQ29udGV4dERlcHRoICYgfjIxMzA3MDY0MzIpID4+PiAwO1xuICAgIH1cbiAgICBnZXQgbGV4ZXJBY3Rpb25FeGVjdXRvcigpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGdldCBzZW1hbnRpY0NvbnRleHQoKSB7XG4gICAgICByZXR1cm4gU2VtYW50aWNDb250ZXh0XzEuU2VtYW50aWNDb250ZXh0Lk5PTkU7XG4gICAgfVxuICAgIGdldCBoYXNQYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHRoaXMuc3RhdGUsIGZhbHNlKTtcbiAgICB9XG4gICAgdHJhbnNmb3JtKHN0YXRlLCBjaGVja05vbkdyZWVkeSwgYXJnMikge1xuICAgICAgaWYgKGFyZzIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1JbXBsKHN0YXRlLCB0aGlzLl9jb250ZXh0LCB0aGlzLnNlbWFudGljQ29udGV4dCwgY2hlY2tOb25HcmVlZHksIHRoaXMubGV4ZXJBY3Rpb25FeGVjdXRvcik7XG4gICAgICB9IGVsc2UgaWYgKGFyZzIgaW5zdGFuY2VvZiBQcmVkaWN0aW9uQ29udGV4dF8xLlByZWRpY3Rpb25Db250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUltcGwoc3RhdGUsIGFyZzIsIHRoaXMuc2VtYW50aWNDb250ZXh0LCBjaGVja05vbkdyZWVkeSwgdGhpcy5sZXhlckFjdGlvbkV4ZWN1dG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJnMiBpbnN0YW5jZW9mIFNlbWFudGljQ29udGV4dF8xLlNlbWFudGljQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1JbXBsKHN0YXRlLCB0aGlzLl9jb250ZXh0LCBhcmcyLCBjaGVja05vbkdyZWVkeSwgdGhpcy5sZXhlckFjdGlvbkV4ZWN1dG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUltcGwoc3RhdGUsIHRoaXMuX2NvbnRleHQsIHRoaXMuc2VtYW50aWNDb250ZXh0LCBjaGVja05vbkdyZWVkeSwgYXJnMik7XG4gICAgICB9XG4gICAgfVxuICAgIHRyYW5zZm9ybUltcGwoc3RhdGUsIGNvbnRleHQsIHNlbWFudGljQ29udGV4dCwgY2hlY2tOb25HcmVlZHksIGxleGVyQWN0aW9uRXhlY3V0b3IpIHtcbiAgICAgIGxldCBwYXNzZWRUaHJvdWdoTm9uR3JlZWR5ID0gY2hlY2tOb25HcmVlZHkgJiYgQVROQ29uZmlnMi5jaGVja05vbkdyZWVkeURlY2lzaW9uKHRoaXMsIHN0YXRlKTtcbiAgICAgIGlmIChzZW1hbnRpY0NvbnRleHQgIT09IFNlbWFudGljQ29udGV4dF8xLlNlbWFudGljQ29udGV4dC5OT05FKSB7XG4gICAgICAgIGlmIChsZXhlckFjdGlvbkV4ZWN1dG9yICE9IG51bGwgfHwgcGFzc2VkVGhyb3VnaE5vbkdyZWVkeSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQWN0aW9uU2VtYW50aWNDb250ZXh0QVROQ29uZmlnKGxleGVyQWN0aW9uRXhlY3V0b3IsIHNlbWFudGljQ29udGV4dCwgc3RhdGUsIHRoaXMsIGNvbnRleHQsIHBhc3NlZFRocm91Z2hOb25HcmVlZHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgU2VtYW50aWNDb250ZXh0QVROQ29uZmlnKHNlbWFudGljQ29udGV4dCwgc3RhdGUsIHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxleGVyQWN0aW9uRXhlY3V0b3IgIT0gbnVsbCB8fCBwYXNzZWRUaHJvdWdoTm9uR3JlZWR5KSB7XG4gICAgICAgIHJldHVybiBuZXcgQWN0aW9uQVROQ29uZmlnKGxleGVyQWN0aW9uRXhlY3V0b3IsIHN0YXRlLCB0aGlzLCBjb250ZXh0LCBwYXNzZWRUaHJvdWdoTm9uR3JlZWR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQVROQ29uZmlnMihzdGF0ZSwgdGhpcywgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBjaGVja05vbkdyZWVkeURlY2lzaW9uKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gc291cmNlLmhhc1Bhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbiB8fCB0YXJnZXQgaW5zdGFuY2VvZiBEZWNpc2lvblN0YXRlXzEuRGVjaXNpb25TdGF0ZSAmJiB0YXJnZXQubm9uR3JlZWR5O1xuICAgIH1cbiAgICBhcHBlbmRDb250ZXh0KGNvbnRleHQsIGNvbnRleHRDYWNoZSkge1xuICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGxldCBhcHBlbmRlZENvbnRleHQgPSB0aGlzLmNvbnRleHQuYXBwZW5kU2luZ2xlQ29udGV4dChjb250ZXh0LCBjb250ZXh0Q2FjaGUpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy50cmFuc2Zvcm0odGhpcy5zdGF0ZSwgZmFsc2UsIGFwcGVuZGVkQ29udGV4dCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgYXBwZW5kZWRDb250ZXh0ID0gdGhpcy5jb250ZXh0LmFwcGVuZENvbnRleHQoY29udGV4dCwgY29udGV4dENhY2hlKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMudHJhbnNmb3JtKHRoaXMuc3RhdGUsIGZhbHNlLCBhcHBlbmRlZENvbnRleHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICBjb250YWlucyhzdWJjb25maWcpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLnN0YXRlTnVtYmVyICE9PSBzdWJjb25maWcuc3RhdGUuc3RhdGVOdW1iZXIgfHwgdGhpcy5hbHQgIT09IHN1YmNvbmZpZy5hbHQgfHwgIXRoaXMuc2VtYW50aWNDb250ZXh0LmVxdWFscyhzdWJjb25maWcuc2VtYW50aWNDb250ZXh0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBsZXQgbGVmdFdvcmtMaXN0ID0gW107XG4gICAgICBsZXQgcmlnaHRXb3JrTGlzdCA9IFtdO1xuICAgICAgbGVmdFdvcmtMaXN0LnB1c2godGhpcy5jb250ZXh0KTtcbiAgICAgIHJpZ2h0V29ya0xpc3QucHVzaChzdWJjb25maWcuY29udGV4dCk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgbGVmdCA9IGxlZnRXb3JrTGlzdC5wb3AoKTtcbiAgICAgICAgbGV0IHJpZ2h0ID0gcmlnaHRXb3JrTGlzdC5wb3AoKTtcbiAgICAgICAgaWYgKCFsZWZ0IHx8ICFyaWdodCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0ID09PSByaWdodCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0LnNpemUgPCByaWdodC5zaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodC5pc0VtcHR5KSB7XG4gICAgICAgICAgcmV0dXJuIGxlZnQuaGFzRW1wdHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByaWdodC5zaXplOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGxlZnQuZmluZFJldHVyblN0YXRlKHJpZ2h0LmdldFJldHVyblN0YXRlKGkpKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVmdFdvcmtMaXN0LnB1c2gobGVmdC5nZXRQYXJlbnQoaW5kZXgpKTtcbiAgICAgICAgICAgIHJpZ2h0V29ya0xpc3QucHVzaChyaWdodC5nZXRQYXJlbnQoaSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgaXNQcmVjZWRlbmNlRmlsdGVyU3VwcHJlc3NlZCgpIHtcbiAgICAgIHJldHVybiAodGhpcy5hbHRBbmRPdXRlckNvbnRleHREZXB0aCAmIFNVUFBSRVNTX1BSRUNFREVOQ0VfRklMVEVSKSAhPT0gMDtcbiAgICB9XG4gICAgc2V0IGlzUHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWQodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFsdEFuZE91dGVyQ29udGV4dERlcHRoIHw9IFNVUFBSRVNTX1BSRUNFREVOQ0VfRklMVEVSO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hbHRBbmRPdXRlckNvbnRleHREZXB0aCAmPSB+U1VQUFJFU1NfUFJFQ0VERU5DRV9GSUxURVI7XG4gICAgICB9XG4gICAgfVxuICAgIGVxdWFscyhvKSB7XG4gICAgICBpZiAodGhpcyA9PT0gbykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIShvIGluc3RhbmNlb2YgQVROQ29uZmlnMikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc3RhdGVOdW1iZXIgPT09IG8uc3RhdGUuc3RhdGVOdW1iZXIgJiYgdGhpcy5hbHQgPT09IG8uYWx0ICYmIHRoaXMucmVhY2hlc0ludG9PdXRlckNvbnRleHQgPT09IG8ucmVhY2hlc0ludG9PdXRlckNvbnRleHQgJiYgdGhpcy5jb250ZXh0LmVxdWFscyhvLmNvbnRleHQpICYmIHRoaXMuc2VtYW50aWNDb250ZXh0LmVxdWFscyhvLnNlbWFudGljQ29udGV4dCkgJiYgdGhpcy5pc1ByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkID09PSBvLmlzUHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWQgJiYgdGhpcy5oYXNQYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb24gPT09IG8uaGFzUGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uICYmIE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvcl8xLk9iamVjdEVxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRS5lcXVhbHModGhpcy5sZXhlckFjdGlvbkV4ZWN1dG9yLCBvLmxleGVyQWN0aW9uRXhlY3V0b3IpO1xuICAgIH1cbiAgICBoYXNoQ29kZSgpIHtcbiAgICAgIGxldCBoYXNoQ29kZSA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLmluaXRpYWxpemUoNyk7XG4gICAgICBoYXNoQ29kZSA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLnVwZGF0ZShoYXNoQ29kZSwgdGhpcy5zdGF0ZS5zdGF0ZU51bWJlcik7XG4gICAgICBoYXNoQ29kZSA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLnVwZGF0ZShoYXNoQ29kZSwgdGhpcy5hbHQpO1xuICAgICAgaGFzaENvZGUgPSBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC51cGRhdGUoaGFzaENvZGUsIHRoaXMucmVhY2hlc0ludG9PdXRlckNvbnRleHQgPyAxIDogMCk7XG4gICAgICBoYXNoQ29kZSA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLnVwZGF0ZShoYXNoQ29kZSwgdGhpcy5jb250ZXh0KTtcbiAgICAgIGhhc2hDb2RlID0gTXVybXVySGFzaF8xLk11cm11ckhhc2gudXBkYXRlKGhhc2hDb2RlLCB0aGlzLnNlbWFudGljQ29udGV4dCk7XG4gICAgICBoYXNoQ29kZSA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLnVwZGF0ZShoYXNoQ29kZSwgdGhpcy5oYXNQYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb24gPyAxIDogMCk7XG4gICAgICBoYXNoQ29kZSA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLnVwZGF0ZShoYXNoQ29kZSwgdGhpcy5sZXhlckFjdGlvbkV4ZWN1dG9yKTtcbiAgICAgIGhhc2hDb2RlID0gTXVybXVySGFzaF8xLk11cm11ckhhc2guZmluaXNoKGhhc2hDb2RlLCA3KTtcbiAgICAgIHJldHVybiBoYXNoQ29kZTtcbiAgICB9XG4gICAgdG9Eb3RTdHJpbmcoKSB7XG4gICAgICBsZXQgYnVpbGRlciA9IFwiXCI7XG4gICAgICBidWlsZGVyICs9IFwiZGlncmFwaCBHIHtcXG5cIjtcbiAgICAgIGJ1aWxkZXIgKz0gXCJyYW5rZGlyPUxSO1xcblwiO1xuICAgICAgbGV0IHZpc2l0ZWQgPSBuZXcgQXJyYXkyREhhc2hNYXBfMS5BcnJheTJESGFzaE1hcChQcmVkaWN0aW9uQ29udGV4dF8xLlByZWRpY3Rpb25Db250ZXh0LklkZW50aXR5RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFKTtcbiAgICAgIGxldCB3b3JrTGlzdCA9IFtdO1xuICAgICAgZnVuY3Rpb24gZ2V0T3JBZGRDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgbGV0IG5ld051bWJlciA9IHZpc2l0ZWQuc2l6ZTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHZpc2l0ZWQucHV0SWZBYnNlbnQoY29udGV4dCwgbmV3TnVtYmVyKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB3b3JrTGlzdC5wdXNoKGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gbmV3TnVtYmVyO1xuICAgICAgfVxuICAgICAgd29ya0xpc3QucHVzaCh0aGlzLmNvbnRleHQpO1xuICAgICAgdmlzaXRlZC5wdXQodGhpcy5jb250ZXh0LCAwKTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gd29ya0xpc3QucG9wKCk7XG4gICAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudC5zaXplOyBpKyspIHtcbiAgICAgICAgICBidWlsZGVyICs9IFwiICBzXCIgKyBnZXRPckFkZENvbnRleHQoY3VycmVudCk7XG4gICAgICAgICAgYnVpbGRlciArPSBcIi0+XCI7XG4gICAgICAgICAgYnVpbGRlciArPSBcInNcIiArIGdldE9yQWRkQ29udGV4dChjdXJyZW50LmdldFBhcmVudChpKSk7XG4gICAgICAgICAgYnVpbGRlciArPSAnW2xhYmVsPVwiJyArIGN1cnJlbnQuZ2V0UmV0dXJuU3RhdGUoaSkgKyAnXCJdO1xcbic7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJ1aWxkZXIgKz0gXCJ9XFxuXCI7XG4gICAgICByZXR1cm4gYnVpbGRlci50b1N0cmluZygpO1xuICAgIH1cbiAgICB0b1N0cmluZyhyZWNvZywgc2hvd0FsdCwgc2hvd0NvbnRleHQpIHtcbiAgICAgIGlmIChzaG93Q29udGV4dCA9PSBudWxsKSB7XG4gICAgICAgIHNob3dDb250ZXh0ID0gc2hvd0FsdCAhPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHNob3dBbHQgPT0gbnVsbCkge1xuICAgICAgICBzaG93QWx0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxldCBidWYgPSBcIlwiO1xuICAgICAgbGV0IGNvbnRleHRzO1xuICAgICAgaWYgKHNob3dDb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHRzID0gdGhpcy5jb250ZXh0LnRvU3RyaW5ncyhyZWNvZywgdGhpcy5zdGF0ZS5zdGF0ZU51bWJlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0cyA9IFtcIj9cIl07XG4gICAgICB9XG4gICAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgICAgZm9yIChsZXQgY29udGV4dERlc2Mgb2YgY29udGV4dHMpIHtcbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWYgKz0gXCIsIFwiO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZiArPSBcIihcIjtcbiAgICAgICAgYnVmICs9IHRoaXMuc3RhdGU7XG4gICAgICAgIGlmIChzaG93QWx0KSB7XG4gICAgICAgICAgYnVmICs9IFwiLFwiO1xuICAgICAgICAgIGJ1ZiArPSB0aGlzLmFsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICAgICAgYnVmICs9IFwiLFwiO1xuICAgICAgICAgIGJ1ZiArPSBjb250ZXh0RGVzYztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZW1hbnRpY0NvbnRleHQgIT09IFNlbWFudGljQ29udGV4dF8xLlNlbWFudGljQ29udGV4dC5OT05FKSB7XG4gICAgICAgICAgYnVmICs9IFwiLFwiO1xuICAgICAgICAgIGJ1ZiArPSB0aGlzLnNlbWFudGljQ29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWFjaGVzSW50b091dGVyQ29udGV4dCkge1xuICAgICAgICAgIGJ1ZiArPSBcIix1cD1cIiArIHRoaXMub3V0ZXJDb250ZXh0RGVwdGg7XG4gICAgICAgIH1cbiAgICAgICAgYnVmICs9IFwiKVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi50b1N0cmluZygpO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgQVROQ29uZmlnLnByb3RvdHlwZSwgXCJfc3RhdGVcIiwgdm9pZCAwKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgQVROQ29uZmlnLnByb3RvdHlwZSwgXCJfY29udGV4dFwiLCB2b2lkIDApO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBBVE5Db25maWcucHJvdG90eXBlLCBcInN0YXRlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbCxcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBBVE5Db25maWcucHJvdG90eXBlLCBcImNvbnRleHRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIEFUTkNvbmZpZy5wcm90b3R5cGUsIFwic2VtYW50aWNDb250ZXh0XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQVROQ29uZmlnLnByb3RvdHlwZSwgXCJjbG9uZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgyLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgQVROQ29uZmlnLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1JbXBsXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQVROQ29uZmlnLnByb3RvdHlwZSwgXCJlcXVhbHNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBBVE5Db25maWcucHJvdG90eXBlLCBcImhhc2hDb2RlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDMsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBBVE5Db25maWcsIFwiY3JlYXRlXCIsIG51bGwpO1xuICBBVE5Db25maWcgPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDIsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBBVE5Db25maWcpO1xuICBleHBvcnRzLkFUTkNvbmZpZyA9IEFUTkNvbmZpZztcbiAgdmFyIFNlbWFudGljQ29udGV4dEFUTkNvbmZpZyA9IGNsYXNzIFNlbWFudGljQ29udGV4dEFUTkNvbmZpZyBleHRlbmRzIEFUTkNvbmZpZyB7XG4gICAgY29uc3RydWN0b3Ioc2VtYW50aWNDb250ZXh0LCBzdGF0ZSwgYWx0T3JDb25maWcsIGNvbnRleHQpIHtcbiAgICAgIGlmICh0eXBlb2YgYWx0T3JDb25maWcgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgc3VwZXIoc3RhdGUsIGFsdE9yQ29uZmlnLCBjb250ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1cGVyKHN0YXRlLCBhbHRPckNvbmZpZywgY29udGV4dCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZW1hbnRpY0NvbnRleHQgPSBzZW1hbnRpY0NvbnRleHQ7XG4gICAgfVxuICAgIGdldCBzZW1hbnRpY0NvbnRleHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VtYW50aWNDb250ZXh0O1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgU2VtYW50aWNDb250ZXh0QVROQ29uZmlnLnByb3RvdHlwZSwgXCJfc2VtYW50aWNDb250ZXh0XCIsIHZvaWQgMCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBTZW1hbnRpY0NvbnRleHRBVE5Db25maWcucHJvdG90eXBlLCBcInNlbWFudGljQ29udGV4dFwiLCBudWxsKTtcbiAgU2VtYW50aWNDb250ZXh0QVROQ29uZmlnID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgyLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgU2VtYW50aWNDb250ZXh0QVROQ29uZmlnKTtcbiAgdmFyIEFjdGlvbkFUTkNvbmZpZyA9IGNsYXNzIEFjdGlvbkFUTkNvbmZpZyBleHRlbmRzIEFUTkNvbmZpZyB7XG4gICAgY29uc3RydWN0b3IobGV4ZXJBY3Rpb25FeGVjdXRvciwgc3RhdGUsIGFsdE9yQ29uZmlnLCBjb250ZXh0LCBwYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb24pIHtcbiAgICAgIGlmICh0eXBlb2YgYWx0T3JDb25maWcgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgc3VwZXIoc3RhdGUsIGFsdE9yQ29uZmlnLCBjb250ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1cGVyKHN0YXRlLCBhbHRPckNvbmZpZywgY29udGV4dCk7XG4gICAgICAgIGlmIChhbHRPckNvbmZpZy5zZW1hbnRpY0NvbnRleHQgIT09IFNlbWFudGljQ29udGV4dF8xLlNlbWFudGljQ29udGV4dC5OT05FKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fbGV4ZXJBY3Rpb25FeGVjdXRvciA9IGxleGVyQWN0aW9uRXhlY3V0b3I7XG4gICAgICB0aGlzLnBhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbiA9IHBhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbjtcbiAgICB9XG4gICAgZ2V0IGxleGVyQWN0aW9uRXhlY3V0b3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGV4ZXJBY3Rpb25FeGVjdXRvcjtcbiAgICB9XG4gICAgZ2V0IGhhc1Bhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbjtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBBY3Rpb25BVE5Db25maWcucHJvdG90eXBlLCBcImxleGVyQWN0aW9uRXhlY3V0b3JcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBBY3Rpb25BVE5Db25maWcucHJvdG90eXBlLCBcImhhc1Bhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvblwiLCBudWxsKTtcbiAgQWN0aW9uQVROQ29uZmlnID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgyLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgQWN0aW9uQVROQ29uZmlnKTtcbiAgdmFyIEFjdGlvblNlbWFudGljQ29udGV4dEFUTkNvbmZpZyA9IGNsYXNzIEFjdGlvblNlbWFudGljQ29udGV4dEFUTkNvbmZpZyBleHRlbmRzIFNlbWFudGljQ29udGV4dEFUTkNvbmZpZyB7XG4gICAgY29uc3RydWN0b3IobGV4ZXJBY3Rpb25FeGVjdXRvciwgc2VtYW50aWNDb250ZXh0LCBzdGF0ZSwgYWx0T3JDb25maWcsIGNvbnRleHQsIHBhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbikge1xuICAgICAgaWYgKHR5cGVvZiBhbHRPckNvbmZpZyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBzdXBlcihzZW1hbnRpY0NvbnRleHQsIHN0YXRlLCBhbHRPckNvbmZpZywgY29udGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdXBlcihzZW1hbnRpY0NvbnRleHQsIHN0YXRlLCBhbHRPckNvbmZpZywgY29udGV4dCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9sZXhlckFjdGlvbkV4ZWN1dG9yID0gbGV4ZXJBY3Rpb25FeGVjdXRvcjtcbiAgICAgIHRoaXMucGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uID0gcGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uO1xuICAgIH1cbiAgICBnZXQgbGV4ZXJBY3Rpb25FeGVjdXRvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sZXhlckFjdGlvbkV4ZWN1dG9yO1xuICAgIH1cbiAgICBnZXQgaGFzUGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEFjdGlvblNlbWFudGljQ29udGV4dEFUTkNvbmZpZy5wcm90b3R5cGUsIFwibGV4ZXJBY3Rpb25FeGVjdXRvclwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEFjdGlvblNlbWFudGljQ29udGV4dEFUTkNvbmZpZy5wcm90b3R5cGUsIFwiaGFzUGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uXCIsIG51bGwpO1xuICBBY3Rpb25TZW1hbnRpY0NvbnRleHRBVE5Db25maWcgPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDEsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDIsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBBY3Rpb25TZW1hbnRpY0NvbnRleHRBVE5Db25maWcpO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9taXNjL0JpdFNldC5qc1xudmFyIHJlcXVpcmVfQml0U2V0ID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5CaXRTZXQgPSB2b2lkIDA7XG4gIHZhciB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG4gIHZhciBNdXJtdXJIYXNoXzEgPSByZXF1aXJlX011cm11ckhhc2goKTtcbiAgdmFyIEVNUFRZX0RBVEEgPSBuZXcgVWludDE2QXJyYXkoMCk7XG4gIGZ1bmN0aW9uIGdldEluZGV4KGJpdE51bWJlcikge1xuICAgIHJldHVybiBiaXROdW1iZXIgPj4+IDQ7XG4gIH1cbiAgZnVuY3Rpb24gdW5JbmRleChuKSB7XG4gICAgcmV0dXJuIG4gKiAxNjtcbiAgfVxuICBmdW5jdGlvbiBmaW5kTFNCU2V0KHdvcmQpIHtcbiAgICBsZXQgYml0ID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGlmICgod29yZCAmIGJpdCkgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICBiaXQgPSBiaXQgPDwgMSA+Pj4gMDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBzcGVjaWZpZWQgYml0IGZvdW5kXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmRNU0JTZXQod29yZCkge1xuICAgIGxldCBiaXQgPSAxIDw8IDE1ID4+PiAwO1xuICAgIGZvciAobGV0IGkgPSAxNTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICgod29yZCAmIGJpdCkgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICBiaXQgPSBiaXQgPj4+IDE7XG4gICAgfVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gc3BlY2lmaWVkIGJpdCBmb3VuZFwiKTtcbiAgfVxuICBmdW5jdGlvbiBiaXRzRm9yKGZyb21CaXQsIHRvQml0KSB7XG4gICAgZnJvbUJpdCAmPSAxNTtcbiAgICB0b0JpdCAmPSAxNTtcbiAgICBpZiAoZnJvbUJpdCA9PT0gdG9CaXQpIHtcbiAgICAgIHJldHVybiAxIDw8IGZyb21CaXQgPj4+IDA7XG4gICAgfVxuICAgIHJldHVybiA2NTUzNSA+Pj4gMTUgLSB0b0JpdCBeIDY1NTM1ID4+PiAxNiAtIGZyb21CaXQ7XG4gIH1cbiAgdmFyIFBPUF9DTlQgPSBuZXcgVWludDhBcnJheSg2NTUzNik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIGNvbnN0IHN0cmlkZSA9IDEgPDwgaSA+Pj4gMDtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIHdoaWxlIChpbmRleCA8IFBPUF9DTlQubGVuZ3RoKSB7XG4gICAgICBpbmRleCArPSBzdHJpZGU7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0cmlkZTsgaisrKSB7XG4gICAgICAgIFBPUF9DTlRbaW5kZXhdKys7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBCaXRTZXQgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoYXJnKSB7XG4gICAgICBpZiAoIWFyZykge1xuICAgICAgICB0aGlzLmRhdGEgPSBFTVBUWV9EQVRBO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmIChhcmcgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJuYml0cyBjYW5ub3QgYmUgbmVnYXRpdmVcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kYXRhID0gbmV3IFVpbnQxNkFycmF5KGdldEluZGV4KGFyZyAtIDEpICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBCaXRTZXQpIHtcbiAgICAgICAgICB0aGlzLmRhdGEgPSBhcmcuZGF0YS5zbGljZSgwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgbWF4ID0gLTE7XG4gICAgICAgICAgZm9yIChsZXQgdiBvZiBhcmcpIHtcbiAgICAgICAgICAgIGlmIChtYXggPCB2KSB7XG4gICAgICAgICAgICAgIG1heCA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBVaW50MTZBcnJheShnZXRJbmRleChtYXggLSAxKSArIDEpO1xuICAgICAgICAgIGZvciAobGV0IHYgb2YgYXJnKSB7XG4gICAgICAgICAgICB0aGlzLnNldCh2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYW5kKHNldCkge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIGNvbnN0IG90aGVyID0gc2V0LmRhdGE7XG4gICAgICBjb25zdCB3b3JkcyA9IE1hdGgubWluKGRhdGEubGVuZ3RoLCBvdGhlci5sZW5ndGgpO1xuICAgICAgbGV0IGxhc3RXb3JkID0gLTE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzOyBpKyspIHtcbiAgICAgICAgbGV0IHZhbHVlID0gZGF0YVtpXSAmPSBvdGhlcltpXTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSAwKSB7XG4gICAgICAgICAgbGFzdFdvcmQgPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGFzdFdvcmQgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IEVNUFRZX0RBVEE7XG4gICAgICB9XG4gICAgICBpZiAobGFzdFdvcmQgPCBkYXRhLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YS5zbGljZSgwLCBsYXN0V29yZCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBhbmROb3Qoc2V0KSB7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgY29uc3Qgb3RoZXIgPSBzZXQuZGF0YTtcbiAgICAgIGNvbnN0IHdvcmRzID0gTWF0aC5taW4oZGF0YS5sZW5ndGgsIG90aGVyLmxlbmd0aCk7XG4gICAgICBsZXQgbGFzdFdvcmQgPSAtMTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHM7IGkrKykge1xuICAgICAgICBsZXQgdmFsdWUgPSBkYXRhW2ldICY9IG90aGVyW2ldIF4gNjU1MzU7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gMCkge1xuICAgICAgICAgIGxhc3RXb3JkID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxhc3RXb3JkID09PSAtMSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBFTVBUWV9EQVRBO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3RXb3JkIDwgZGF0YS5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGEuc2xpY2UoMCwgbGFzdFdvcmQgKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2FyZGluYWxpdHkoKSB7XG4gICAgICBpZiAodGhpcy5pc0VtcHR5KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCArPSBQT1BfQ05UW2RhdGFbaV1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2xlYXIoZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgICBpZiAoZnJvbUluZGV4ID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5kYXRhLmZpbGwoMCk7XG4gICAgICB9IGVsc2UgaWYgKHRvSW5kZXggPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNldChmcm9tSW5kZXgsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0KGZyb21JbmRleCwgdG9JbmRleCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBmbGlwKGZyb21JbmRleCwgdG9JbmRleCkge1xuICAgICAgaWYgKHRvSW5kZXggPT0gbnVsbCkge1xuICAgICAgICB0b0luZGV4ID0gZnJvbUluZGV4O1xuICAgICAgfVxuICAgICAgaWYgKGZyb21JbmRleCA8IDAgfHwgdG9JbmRleCA8IGZyb21JbmRleCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigpO1xuICAgICAgfVxuICAgICAgbGV0IHdvcmQgPSBnZXRJbmRleChmcm9tSW5kZXgpO1xuICAgICAgY29uc3QgbGFzdFdvcmQgPSBnZXRJbmRleCh0b0luZGV4KTtcbiAgICAgIGlmICh3b3JkID09PSBsYXN0V29yZCkge1xuICAgICAgICB0aGlzLmRhdGFbd29yZF0gXj0gYml0c0Zvcihmcm9tSW5kZXgsIHRvSW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kYXRhW3dvcmQrK10gXj0gYml0c0Zvcihmcm9tSW5kZXgsIDE1KTtcbiAgICAgICAgd2hpbGUgKHdvcmQgPCBsYXN0V29yZCkge1xuICAgICAgICAgIHRoaXMuZGF0YVt3b3JkKytdIF49IDY1NTM1O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YVt3b3JkKytdIF49IGJpdHNGb3IoMCwgdG9JbmRleCk7XG4gICAgICB9XG4gICAgfVxuICAgIGdldChmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICAgIGlmICh0b0luZGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuZGF0YVtnZXRJbmRleChmcm9tSW5kZXgpXSAmIGJpdHNGb3IoZnJvbUluZGV4LCBmcm9tSW5kZXgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBuZXcgQml0U2V0KHRvSW5kZXggKyAxKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb21JbmRleDsgaSA8PSB0b0luZGV4OyBpKyspIHtcbiAgICAgICAgICByZXN1bHQuc2V0KGksIHRoaXMuZ2V0KGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICBpbnRlcnNlY3RzKHNldCkge1xuICAgICAgbGV0IHNtYWxsZXJMZW5ndGggPSBNYXRoLm1pbih0aGlzLmxlbmd0aCgpLCBzZXQubGVuZ3RoKCkpO1xuICAgICAgaWYgKHNtYWxsZXJMZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbGV0IGJvdW5kID0gZ2V0SW5kZXgoc21hbGxlckxlbmd0aCAtIDEpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gYm91bmQ7IGkrKykge1xuICAgICAgICBpZiAoKHRoaXMuZGF0YVtpXSAmIHNldC5kYXRhW2ldKSAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoKCkgPT09IDA7XG4gICAgfVxuICAgIGxlbmd0aCgpIHtcbiAgICAgIGlmICghdGhpcy5kYXRhLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzU2V0Qml0KHVuSW5kZXgodGhpcy5kYXRhLmxlbmd0aCkgLSAxKSArIDE7XG4gICAgfVxuICAgIG5leHRDbGVhckJpdChmcm9tSW5kZXgpIHtcbiAgICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiZnJvbUluZGV4IGNhbm5vdCBiZSBuZWdhdGl2ZVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIGxldCB3b3JkID0gZ2V0SW5kZXgoZnJvbUluZGV4KTtcbiAgICAgIGlmICh3b3JkID4gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGxldCBpZ25vcmUgPSA2NTUzNSBeIGJpdHNGb3IoZnJvbUluZGV4LCAxNSk7XG4gICAgICBpZiAoKGRhdGFbd29yZF0gfCBpZ25vcmUpID09PSA2NTUzNSkge1xuICAgICAgICB3b3JkKys7XG4gICAgICAgIGlnbm9yZSA9IDA7XG4gICAgICAgIGZvciAoOyB3b3JkIDwgbGVuZ3RoOyB3b3JkKyspIHtcbiAgICAgICAgICBpZiAoZGF0YVt3b3JkXSAhPT0gNjU1MzUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod29yZCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5JbmRleCh3b3JkKSArIGZpbmRMU0JTZXQoKGRhdGFbd29yZF0gfCBpZ25vcmUpIF4gNjU1MzUpO1xuICAgIH1cbiAgICBuZXh0U2V0Qml0KGZyb21JbmRleCkge1xuICAgICAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJmcm9tSW5kZXggY2Fubm90IGJlIG5lZ2F0aXZlXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgbGV0IHdvcmQgPSBnZXRJbmRleChmcm9tSW5kZXgpO1xuICAgICAgaWYgKHdvcmQgPiBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgbGV0IG1hc2sgPSBiaXRzRm9yKGZyb21JbmRleCwgMTUpO1xuICAgICAgaWYgKChkYXRhW3dvcmRdICYgbWFzaykgPT09IDApIHtcbiAgICAgICAgd29yZCsrO1xuICAgICAgICBtYXNrID0gNjU1MzU7XG4gICAgICAgIGZvciAoOyB3b3JkIDwgbGVuZ3RoOyB3b3JkKyspIHtcbiAgICAgICAgICBpZiAoZGF0YVt3b3JkXSAhPT0gMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JkID49IGxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHVuSW5kZXgod29yZCkgKyBmaW5kTFNCU2V0KGRhdGFbd29yZF0gJiBtYXNrKTtcbiAgICB9XG4gICAgb3Ioc2V0KSB7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgY29uc3Qgb3RoZXIgPSBzZXQuZGF0YTtcbiAgICAgIGNvbnN0IG1pbldvcmRzID0gTWF0aC5taW4oZGF0YS5sZW5ndGgsIG90aGVyLmxlbmd0aCk7XG4gICAgICBjb25zdCB3b3JkcyA9IE1hdGgubWF4KGRhdGEubGVuZ3RoLCBvdGhlci5sZW5ndGgpO1xuICAgICAgY29uc3QgZGVzdCA9IGRhdGEubGVuZ3RoID09PSB3b3JkcyA/IGRhdGEgOiBuZXcgVWludDE2QXJyYXkod29yZHMpO1xuICAgICAgbGV0IGxhc3RXb3JkID0gLTE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1pbldvcmRzOyBpKyspIHtcbiAgICAgICAgbGV0IHZhbHVlID0gZGVzdFtpXSA9IGRhdGFbaV0gfCBvdGhlcltpXTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSAwKSB7XG4gICAgICAgICAgbGFzdFdvcmQgPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBsb25nZXIgPSBkYXRhLmxlbmd0aCA+IG90aGVyLmxlbmd0aCA/IGRhdGEgOiBvdGhlcjtcbiAgICAgIGZvciAobGV0IGkgPSBtaW5Xb3JkczsgaSA8IHdvcmRzOyBpKyspIHtcbiAgICAgICAgbGV0IHZhbHVlID0gZGVzdFtpXSA9IGxvbmdlcltpXTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSAwKSB7XG4gICAgICAgICAgbGFzdFdvcmQgPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGFzdFdvcmQgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IEVNUFRZX0RBVEE7XG4gICAgICB9IGVsc2UgaWYgKGRlc3QubGVuZ3RoID09PSBsYXN0V29yZCArIDEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGVzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRlc3Quc2xpY2UoMCwgbGFzdFdvcmQpO1xuICAgICAgfVxuICAgIH1cbiAgICBwcmV2aW91c0NsZWFyQml0KGZyb21JbmRleCkge1xuICAgICAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJmcm9tSW5kZXggY2Fubm90IGJlIG5lZ2F0aXZlXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgbGV0IHdvcmQgPSBnZXRJbmRleChmcm9tSW5kZXgpO1xuICAgICAgaWYgKHdvcmQgPj0gbGVuZ3RoKSB7XG4gICAgICAgIHdvcmQgPSBsZW5ndGggLSAxO1xuICAgICAgfVxuICAgICAgbGV0IGlnbm9yZSA9IDY1NTM1IF4gYml0c0ZvcigwLCBmcm9tSW5kZXgpO1xuICAgICAgaWYgKChkYXRhW3dvcmRdIHwgaWdub3JlKSA9PT0gNjU1MzUpIHtcbiAgICAgICAgaWdub3JlID0gMDtcbiAgICAgICAgd29yZC0tO1xuICAgICAgICBmb3IgKDsgd29yZCA+PSAwOyB3b3JkLS0pIHtcbiAgICAgICAgICBpZiAoZGF0YVt3b3JkXSAhPT0gNjU1MzUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod29yZCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1bkluZGV4KHdvcmQpICsgZmluZE1TQlNldCgoZGF0YVt3b3JkXSB8IGlnbm9yZSkgXiA2NTUzNSk7XG4gICAgfVxuICAgIHByZXZpb3VzU2V0Qml0KGZyb21JbmRleCkge1xuICAgICAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJmcm9tSW5kZXggY2Fubm90IGJlIG5lZ2F0aXZlXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgbGV0IHdvcmQgPSBnZXRJbmRleChmcm9tSW5kZXgpO1xuICAgICAgaWYgKHdvcmQgPj0gbGVuZ3RoKSB7XG4gICAgICAgIHdvcmQgPSBsZW5ndGggLSAxO1xuICAgICAgfVxuICAgICAgbGV0IG1hc2sgPSBiaXRzRm9yKDAsIGZyb21JbmRleCk7XG4gICAgICBpZiAoKGRhdGFbd29yZF0gJiBtYXNrKSA9PT0gMCkge1xuICAgICAgICB3b3JkLS07XG4gICAgICAgIG1hc2sgPSA2NTUzNTtcbiAgICAgICAgZm9yICg7IHdvcmQgPj0gMDsgd29yZC0tKSB7XG4gICAgICAgICAgaWYgKGRhdGFbd29yZF0gIT09IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod29yZCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1bkluZGV4KHdvcmQpICsgZmluZE1TQlNldChkYXRhW3dvcmRdICYgbWFzayk7XG4gICAgfVxuICAgIHNldChmcm9tSW5kZXgsIHRvSW5kZXgsIHZhbHVlKSB7XG4gICAgICBpZiAodG9JbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRvSW5kZXggPSBmcm9tSW5kZXg7XG4gICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRvSW5kZXggPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHZhbHVlID0gdG9JbmRleDtcbiAgICAgICAgdG9JbmRleCA9IGZyb21JbmRleDtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChmcm9tSW5kZXggPCAwIHx8IGZyb21JbmRleCA+IHRvSW5kZXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIGxldCB3b3JkID0gZ2V0SW5kZXgoZnJvbUluZGV4KTtcbiAgICAgIGxldCBsYXN0V29yZCA9IGdldEluZGV4KHRvSW5kZXgpO1xuICAgICAgaWYgKHZhbHVlICYmIGxhc3RXb3JkID49IHRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHRlbXAgPSBuZXcgVWludDE2QXJyYXkobGFzdFdvcmQgKyAxKTtcbiAgICAgICAgdGhpcy5kYXRhLmZvckVhY2goKHZhbHVlMiwgaW5kZXgpID0+IHRlbXBbaW5kZXhdID0gdmFsdWUyKTtcbiAgICAgICAgdGhpcy5kYXRhID0gdGVtcDtcbiAgICAgIH0gZWxzZSBpZiAoIXZhbHVlKSB7XG4gICAgICAgIGlmICh3b3JkID49IHRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RXb3JkID49IHRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBsYXN0V29yZCA9IHRoaXMuZGF0YS5sZW5ndGggLSAxO1xuICAgICAgICAgIHRvSW5kZXggPSB0aGlzLmRhdGEubGVuZ3RoICogMTYgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAod29yZCA9PT0gbGFzdFdvcmQpIHtcbiAgICAgICAgdGhpcy5fc2V0Qml0cyh3b3JkLCB2YWx1ZSwgYml0c0Zvcihmcm9tSW5kZXgsIHRvSW5kZXgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NldEJpdHMod29yZCsrLCB2YWx1ZSwgYml0c0Zvcihmcm9tSW5kZXgsIDE1KSk7XG4gICAgICAgIHdoaWxlICh3b3JkIDwgbGFzdFdvcmQpIHtcbiAgICAgICAgICB0aGlzLmRhdGFbd29yZCsrXSA9IHZhbHVlID8gNjU1MzUgOiAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldEJpdHMod29yZCwgdmFsdWUsIGJpdHNGb3IoMCwgdG9JbmRleCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBfc2V0Qml0cyh3b3JkLCB2YWx1ZSwgbWFzaykge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGF0YVt3b3JkXSB8PSBtYXNrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kYXRhW3dvcmRdICY9IDY1NTM1IF4gbWFzaztcbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhLmJ5dGVMZW5ndGggKiA4O1xuICAgIH1cbiAgICBoYXNoQ29kZSgpIHtcbiAgICAgIHJldHVybiBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC5oYXNoQ29kZSh0aGlzLmRhdGEsIDIyKTtcbiAgICB9XG4gICAgZXF1YWxzKG9iaikge1xuICAgICAgaWYgKG9iaiA9PT0gdGhpcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIShvYmogaW5zdGFuY2VvZiBCaXRTZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoKCk7XG4gICAgICBpZiAobGVuICE9PSBvYmoubGVuZ3RoKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxldCBib3VuZCA9IGdldEluZGV4KGxlbiAtIDEpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gYm91bmQ7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5kYXRhW2ldICE9PSBvYmouZGF0YVtpXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgbGV0IHJlc3VsdCA9IFwie1wiO1xuICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLm5leHRTZXRCaXQoMCk7IGkgPj0gMDsgaSA9IHRoaXMubmV4dFNldEJpdChpICsgMSkpIHtcbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgKz0gXCIsIFwiO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ICs9IFwifVwiO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgeG9yKHNldCkge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIGNvbnN0IG90aGVyID0gc2V0LmRhdGE7XG4gICAgICBjb25zdCBtaW5Xb3JkcyA9IE1hdGgubWluKGRhdGEubGVuZ3RoLCBvdGhlci5sZW5ndGgpO1xuICAgICAgY29uc3Qgd29yZHMgPSBNYXRoLm1heChkYXRhLmxlbmd0aCwgb3RoZXIubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGRlc3QgPSBkYXRhLmxlbmd0aCA9PT0gd29yZHMgPyBkYXRhIDogbmV3IFVpbnQxNkFycmF5KHdvcmRzKTtcbiAgICAgIGxldCBsYXN0V29yZCA9IC0xO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaW5Xb3JkczsgaSsrKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGRlc3RbaV0gPSBkYXRhW2ldIF4gb3RoZXJbaV07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gMCkge1xuICAgICAgICAgIGxhc3RXb3JkID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbG9uZ2VyID0gZGF0YS5sZW5ndGggPiBvdGhlci5sZW5ndGggPyBkYXRhIDogb3RoZXI7XG4gICAgICBmb3IgKGxldCBpID0gbWluV29yZHM7IGkgPCB3b3JkczsgaSsrKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGRlc3RbaV0gPSBsb25nZXJbaV07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gMCkge1xuICAgICAgICAgIGxhc3RXb3JkID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxhc3RXb3JkID09PSAtMSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBFTVBUWV9EQVRBO1xuICAgICAgfSBlbHNlIGlmIChkZXN0Lmxlbmd0aCA9PT0gbGFzdFdvcmQgKyAxKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRlc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRhdGEgPSBkZXN0LnNsaWNlKDAsIGxhc3RXb3JkICsgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyBCaXRTZXQodGhpcyk7XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgcmV0dXJuIG5ldyBCaXRTZXRJdGVyYXRvcih0aGlzLmRhdGEpO1xuICAgIH1cbiAgICBbdXRpbC5pbnNwZWN0LmN1c3RvbV0oKSB7XG4gICAgICByZXR1cm4gXCJCaXRTZXQgXCIgKyB0aGlzLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9O1xuICBleHBvcnRzLkJpdFNldCA9IEJpdFNldDtcbiAgdmFyIEJpdFNldEl0ZXJhdG9yID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgIHRoaXMubWFzayA9IDY1NTM1O1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGJpdHMgPSB0aGlzLmRhdGFbdGhpcy5pbmRleF0gJiB0aGlzLm1hc2s7XG4gICAgICAgIGlmIChiaXRzICE9PSAwKSB7XG4gICAgICAgICAgY29uc3QgYml0TnVtYmVyID0gdW5JbmRleCh0aGlzLmluZGV4KSArIGZpbmRMU0JTZXQoYml0cyk7XG4gICAgICAgICAgdGhpcy5tYXNrID0gYml0c0ZvcihiaXROdW1iZXIgKyAxLCAxNSk7XG4gICAgICAgICAgcmV0dXJuIHtkb25lOiBmYWxzZSwgdmFsdWU6IGJpdE51bWJlcn07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICB0aGlzLm1hc2sgPSA2NTUzNTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7ZG9uZTogdHJ1ZSwgdmFsdWU6IC0xfTtcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9BVE5Db25maWdTZXQuanNcbnZhciByZXF1aXJlX0FUTkNvbmZpZ1NldCA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5BVE5Db25maWdTZXQgPSB2b2lkIDA7XG4gIHZhciBBcnJheTJESGFzaE1hcF8xID0gcmVxdWlyZV9BcnJheTJESGFzaE1hcCgpO1xuICB2YXIgQXJyYXkyREhhc2hTZXRfMSA9IHJlcXVpcmVfQXJyYXkyREhhc2hTZXQoKTtcbiAgdmFyIEFycmF5RXF1YWxpdHlDb21wYXJhdG9yXzEgPSByZXF1aXJlX0FycmF5RXF1YWxpdHlDb21wYXJhdG9yKCk7XG4gIHZhciBBVE5fMSA9IHJlcXVpcmVfQVROKCk7XG4gIHZhciBBVE5Db25maWdfMSA9IHJlcXVpcmVfQVROQ29uZmlnKCk7XG4gIHZhciBCaXRTZXRfMSA9IHJlcXVpcmVfQml0U2V0KCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvcl8xID0gcmVxdWlyZV9PYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IoKTtcbiAgdmFyIFByZWRpY3Rpb25Db250ZXh0XzEgPSByZXF1aXJlX1ByZWRpY3Rpb25Db250ZXh0KCk7XG4gIHZhciBQcmVkaWN0aW9uQ29udGV4dENhY2hlXzEgPSByZXF1aXJlX1ByZWRpY3Rpb25Db250ZXh0Q2FjaGUoKTtcbiAgdmFyIFNlbWFudGljQ29udGV4dF8xID0gcmVxdWlyZV9TZW1hbnRpY0NvbnRleHQoKTtcbiAgdmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG4gIHZhciBVdGlsczMgPSByZXF1aXJlX1V0aWxzKCk7XG4gIHZhciBLZXlUeXBlRXF1YWxpdHlDb21wYXJlciA9IGNsYXNzIHtcbiAgICBoYXNoQ29kZShrZXkpIHtcbiAgICAgIHJldHVybiBrZXkuc3RhdGUgXiBrZXkuYWx0O1xuICAgIH1cbiAgICBlcXVhbHMoYSwgYikge1xuICAgICAgcmV0dXJuIGEuc3RhdGUgPT09IGIuc3RhdGUgJiYgYS5hbHQgPT09IGIuYWx0O1xuICAgIH1cbiAgfTtcbiAgS2V5VHlwZUVxdWFsaXR5Q29tcGFyZXIuSU5TVEFOQ0UgPSBuZXcgS2V5VHlwZUVxdWFsaXR5Q29tcGFyZXIoKTtcbiAgZnVuY3Rpb24gTmV3S2V5ZWRDb25maWdNYXAobWFwKSB7XG4gICAgaWYgKG1hcCkge1xuICAgICAgcmV0dXJuIG5ldyBBcnJheTJESGFzaE1hcF8xLkFycmF5MkRIYXNoTWFwKG1hcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgQXJyYXkyREhhc2hNYXBfMS5BcnJheTJESGFzaE1hcChLZXlUeXBlRXF1YWxpdHlDb21wYXJlci5JTlNUQU5DRSk7XG4gICAgfVxuICB9XG4gIHZhciBBVE5Db25maWdTZXQgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3Ioc2V0LCByZWFkb25seSkge1xuICAgICAgdGhpcy5fdW5pcXVlQWx0ID0gMDtcbiAgICAgIHRoaXMuX2hhc1NlbWFudGljQ29udGV4dCA9IGZhbHNlO1xuICAgICAgdGhpcy5fZGlwc0ludG9PdXRlckNvbnRleHQgPSBmYWxzZTtcbiAgICAgIHRoaXMub3V0ZXJtb3N0Q29uZmlnU2V0ID0gZmFsc2U7XG4gICAgICB0aGlzLmNhY2hlZEhhc2hDb2RlID0gLTE7XG4gICAgICBpZiAoIXNldCkge1xuICAgICAgICB0aGlzLm1lcmdlZENvbmZpZ3MgPSBOZXdLZXllZENvbmZpZ01hcCgpO1xuICAgICAgICB0aGlzLnVubWVyZ2VkID0gW107XG4gICAgICAgIHRoaXMuY29uZmlncyA9IFtdO1xuICAgICAgICB0aGlzLl91bmlxdWVBbHQgPSBBVE5fMS5BVE4uSU5WQUxJRF9BTFRfTlVNQkVSO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlYWRvbmx5KSB7XG4gICAgICAgICAgdGhpcy5tZXJnZWRDb25maWdzID0gdm9pZCAwO1xuICAgICAgICAgIHRoaXMudW5tZXJnZWQgPSB2b2lkIDA7XG4gICAgICAgIH0gZWxzZSBpZiAoIXNldC5pc1JlYWRPbmx5KSB7XG4gICAgICAgICAgdGhpcy5tZXJnZWRDb25maWdzID0gTmV3S2V5ZWRDb25maWdNYXAoc2V0Lm1lcmdlZENvbmZpZ3MpO1xuICAgICAgICAgIHRoaXMudW5tZXJnZWQgPSBzZXQudW5tZXJnZWQuc2xpY2UoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5tZXJnZWRDb25maWdzID0gTmV3S2V5ZWRDb25maWdNYXAoKTtcbiAgICAgICAgICB0aGlzLnVubWVyZ2VkID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25maWdzID0gc2V0LmNvbmZpZ3Muc2xpY2UoMCk7XG4gICAgICAgIHRoaXMuX2RpcHNJbnRvT3V0ZXJDb250ZXh0ID0gc2V0Ll9kaXBzSW50b091dGVyQ29udGV4dDtcbiAgICAgICAgdGhpcy5faGFzU2VtYW50aWNDb250ZXh0ID0gc2V0Ll9oYXNTZW1hbnRpY0NvbnRleHQ7XG4gICAgICAgIHRoaXMub3V0ZXJtb3N0Q29uZmlnU2V0ID0gc2V0Lm91dGVybW9zdENvbmZpZ1NldDtcbiAgICAgICAgaWYgKHJlYWRvbmx5IHx8ICFzZXQuaXNSZWFkT25seSkge1xuICAgICAgICAgIHRoaXMuX3VuaXF1ZUFsdCA9IHNldC5fdW5pcXVlQWx0O1xuICAgICAgICAgIHRoaXMuX2NvbmZsaWN0SW5mbyA9IHNldC5fY29uZmxpY3RJbmZvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGdldFJlcHJlc2VudGVkQWx0ZXJuYXRpdmVzKCkge1xuICAgICAgaWYgKHRoaXMuX2NvbmZsaWN0SW5mbyAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25mbGljdEluZm8uY29uZmxpY3RlZEFsdHMuY2xvbmUoKTtcbiAgICAgIH1cbiAgICAgIGxldCBhbHRzID0gbmV3IEJpdFNldF8xLkJpdFNldCgpO1xuICAgICAgZm9yIChsZXQgY29uZmlnIG9mIHRoaXMpIHtcbiAgICAgICAgYWx0cy5zZXQoY29uZmlnLmFsdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWx0cztcbiAgICB9XG4gICAgZ2V0IGlzUmVhZE9ubHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXJnZWRDb25maWdzID09IG51bGw7XG4gICAgfVxuICAgIGdldCBpc091dGVybW9zdENvbmZpZ1NldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm91dGVybW9zdENvbmZpZ1NldDtcbiAgICB9XG4gICAgc2V0IGlzT3V0ZXJtb3N0Q29uZmlnU2V0KG91dGVybW9zdENvbmZpZ1NldCkge1xuICAgICAgaWYgKHRoaXMub3V0ZXJtb3N0Q29uZmlnU2V0ICYmICFvdXRlcm1vc3RDb25maWdTZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbFN0YXRlRXhjZXB0aW9uXCIpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KCFvdXRlcm1vc3RDb25maWdTZXQgfHwgIXRoaXMuX2RpcHNJbnRvT3V0ZXJDb250ZXh0KTtcbiAgICAgIHRoaXMub3V0ZXJtb3N0Q29uZmlnU2V0ID0gb3V0ZXJtb3N0Q29uZmlnU2V0O1xuICAgIH1cbiAgICBnZXRTdGF0ZXMoKSB7XG4gICAgICBsZXQgc3RhdGVzID0gbmV3IEFycmF5MkRIYXNoU2V0XzEuQXJyYXkyREhhc2hTZXQoT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yXzEuT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFKTtcbiAgICAgIGZvciAobGV0IGMgb2YgdGhpcy5jb25maWdzKSB7XG4gICAgICAgIHN0YXRlcy5hZGQoYy5zdGF0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdGVzO1xuICAgIH1cbiAgICBvcHRpbWl6ZUNvbmZpZ3MoaW50ZXJwcmV0ZXIpIHtcbiAgICAgIGlmICh0aGlzLmNvbmZpZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGNvbmZpZyBvZiB0aGlzLmNvbmZpZ3MpIHtcbiAgICAgICAgY29uZmlnLmNvbnRleHQgPSBpbnRlcnByZXRlci5hdG4uZ2V0Q2FjaGVkQ29udGV4dChjb25maWcuY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNsb25lKHJlYWRvbmx5KSB7XG4gICAgICBsZXQgY29weSA9IG5ldyBBVE5Db25maWdTZXQodGhpcywgcmVhZG9ubHkpO1xuICAgICAgaWYgKCFyZWFkb25seSAmJiB0aGlzLmlzUmVhZE9ubHkpIHtcbiAgICAgICAgY29weS5hZGRBbGwodGhpcy5jb25maWdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3MubGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgaXNFbXB0eSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3MubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBjb250YWlucyhvKSB7XG4gICAgICBpZiAoIShvIGluc3RhbmNlb2YgQVROQ29uZmlnXzEuQVROQ29uZmlnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tZXJnZWRDb25maWdzICYmIHRoaXMudW5tZXJnZWQpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IG87XG4gICAgICAgIGxldCBjb25maWdLZXkgPSB0aGlzLmdldEtleShjb25maWcpO1xuICAgICAgICBsZXQgbWVyZ2VkQ29uZmlnID0gdGhpcy5tZXJnZWRDb25maWdzLmdldChjb25maWdLZXkpO1xuICAgICAgICBpZiAobWVyZ2VkQ29uZmlnICE9IG51bGwgJiYgdGhpcy5jYW5NZXJnZShjb25maWcsIGNvbmZpZ0tleSwgbWVyZ2VkQ29uZmlnKSkge1xuICAgICAgICAgIHJldHVybiBtZXJnZWRDb25maWcuY29udGFpbnMoY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjIG9mIHRoaXMudW5tZXJnZWQpIHtcbiAgICAgICAgICBpZiAoYy5jb250YWlucyhvKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBjIG9mIHRoaXMuY29uZmlncykge1xuICAgICAgICAgIGlmIChjLmNvbnRhaW5zKG8pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgeWllbGQqIHRoaXMuY29uZmlncztcbiAgICB9XG4gICAgdG9BcnJheSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3M7XG4gICAgfVxuICAgIGFkZChlLCBjb250ZXh0Q2FjaGUpIHtcbiAgICAgIHRoaXMuZW5zdXJlV3JpdGFibGUoKTtcbiAgICAgIGlmICghdGhpcy5tZXJnZWRDb25maWdzIHx8ICF0aGlzLnVubWVyZ2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdmVyZWQgYnkgZW5zdXJlV3JpdGFibGUgYnV0IGR1cGxpY2F0ZWQgaGVyZSBmb3Igc3RyaWN0IG51bGwgY2hlY2sgbGltaXRhdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydCghdGhpcy5vdXRlcm1vc3RDb25maWdTZXQgfHwgIWUucmVhY2hlc0ludG9PdXRlckNvbnRleHQpO1xuICAgICAgaWYgKGNvbnRleHRDYWNoZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRleHRDYWNoZSA9IFByZWRpY3Rpb25Db250ZXh0Q2FjaGVfMS5QcmVkaWN0aW9uQ29udGV4dENhY2hlLlVOQ0FDSEVEO1xuICAgICAgfVxuICAgICAgbGV0IGFkZEtleTtcbiAgICAgIGxldCBrZXkgPSB0aGlzLmdldEtleShlKTtcbiAgICAgIGxldCBtZXJnZWRDb25maWcgPSB0aGlzLm1lcmdlZENvbmZpZ3MuZ2V0KGtleSk7XG4gICAgICBhZGRLZXkgPSBtZXJnZWRDb25maWcgPT0gbnVsbDtcbiAgICAgIGlmIChtZXJnZWRDb25maWcgIT0gbnVsbCAmJiB0aGlzLmNhbk1lcmdlKGUsIGtleSwgbWVyZ2VkQ29uZmlnKSkge1xuICAgICAgICBtZXJnZWRDb25maWcub3V0ZXJDb250ZXh0RGVwdGggPSBNYXRoLm1heChtZXJnZWRDb25maWcub3V0ZXJDb250ZXh0RGVwdGgsIGUub3V0ZXJDb250ZXh0RGVwdGgpO1xuICAgICAgICBpZiAoZS5pc1ByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkKSB7XG4gICAgICAgICAgbWVyZ2VkQ29uZmlnLmlzUHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBqb2luZWQgPSBQcmVkaWN0aW9uQ29udGV4dF8xLlByZWRpY3Rpb25Db250ZXh0LmpvaW4obWVyZ2VkQ29uZmlnLmNvbnRleHQsIGUuY29udGV4dCwgY29udGV4dENhY2hlKTtcbiAgICAgICAgdGhpcy51cGRhdGVQcm9wZXJ0aWVzRm9yTWVyZ2VkQ29uZmlnKGUpO1xuICAgICAgICBpZiAobWVyZ2VkQ29uZmlnLmNvbnRleHQgPT09IGpvaW5lZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBtZXJnZWRDb25maWcuY29udGV4dCA9IGpvaW5lZDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudW5tZXJnZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHVubWVyZ2VkQ29uZmlnID0gdGhpcy51bm1lcmdlZFtpXTtcbiAgICAgICAgaWYgKHRoaXMuY2FuTWVyZ2UoZSwga2V5LCB1bm1lcmdlZENvbmZpZykpIHtcbiAgICAgICAgICB1bm1lcmdlZENvbmZpZy5vdXRlckNvbnRleHREZXB0aCA9IE1hdGgubWF4KHVubWVyZ2VkQ29uZmlnLm91dGVyQ29udGV4dERlcHRoLCBlLm91dGVyQ29udGV4dERlcHRoKTtcbiAgICAgICAgICBpZiAoZS5pc1ByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkKSB7XG4gICAgICAgICAgICB1bm1lcmdlZENvbmZpZy5pc1ByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGpvaW5lZCA9IFByZWRpY3Rpb25Db250ZXh0XzEuUHJlZGljdGlvbkNvbnRleHQuam9pbih1bm1lcmdlZENvbmZpZy5jb250ZXh0LCBlLmNvbnRleHQsIGNvbnRleHRDYWNoZSk7XG4gICAgICAgICAgdGhpcy51cGRhdGVQcm9wZXJ0aWVzRm9yTWVyZ2VkQ29uZmlnKGUpO1xuICAgICAgICAgIGlmICh1bm1lcmdlZENvbmZpZy5jb250ZXh0ID09PSBqb2luZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdW5tZXJnZWRDb25maWcuY29udGV4dCA9IGpvaW5lZDtcbiAgICAgICAgICBpZiAoYWRkS2V5KSB7XG4gICAgICAgICAgICB0aGlzLm1lcmdlZENvbmZpZ3MucHV0KGtleSwgdW5tZXJnZWRDb25maWcpO1xuICAgICAgICAgICAgdGhpcy51bm1lcmdlZC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmNvbmZpZ3MucHVzaChlKTtcbiAgICAgIGlmIChhZGRLZXkpIHtcbiAgICAgICAgdGhpcy5tZXJnZWRDb25maWdzLnB1dChrZXksIGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bm1lcmdlZC5wdXNoKGUpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVQcm9wZXJ0aWVzRm9yQWRkZWRDb25maWcoZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdXBkYXRlUHJvcGVydGllc0Zvck1lcmdlZENvbmZpZyhjb25maWcpIHtcbiAgICAgIHRoaXMuX2RpcHNJbnRvT3V0ZXJDb250ZXh0ID0gdGhpcy5fZGlwc0ludG9PdXRlckNvbnRleHQgfHwgY29uZmlnLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0O1xuICAgICAgYXNzZXJ0KCF0aGlzLm91dGVybW9zdENvbmZpZ1NldCB8fCAhdGhpcy5fZGlwc0ludG9PdXRlckNvbnRleHQpO1xuICAgIH1cbiAgICB1cGRhdGVQcm9wZXJ0aWVzRm9yQWRkZWRDb25maWcoY29uZmlnKSB7XG4gICAgICBpZiAodGhpcy5jb25maWdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLl91bmlxdWVBbHQgPSBjb25maWcuYWx0O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl91bmlxdWVBbHQgIT09IGNvbmZpZy5hbHQpIHtcbiAgICAgICAgdGhpcy5fdW5pcXVlQWx0ID0gQVROXzEuQVROLklOVkFMSURfQUxUX05VTUJFUjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2hhc1NlbWFudGljQ29udGV4dCA9IHRoaXMuX2hhc1NlbWFudGljQ29udGV4dCB8fCAhU2VtYW50aWNDb250ZXh0XzEuU2VtYW50aWNDb250ZXh0Lk5PTkUuZXF1YWxzKGNvbmZpZy5zZW1hbnRpY0NvbnRleHQpO1xuICAgICAgdGhpcy5fZGlwc0ludG9PdXRlckNvbnRleHQgPSB0aGlzLl9kaXBzSW50b091dGVyQ29udGV4dCB8fCBjb25maWcucmVhY2hlc0ludG9PdXRlckNvbnRleHQ7XG4gICAgICBhc3NlcnQoIXRoaXMub3V0ZXJtb3N0Q29uZmlnU2V0IHx8ICF0aGlzLl9kaXBzSW50b091dGVyQ29udGV4dCk7XG4gICAgfVxuICAgIGNhbk1lcmdlKGxlZnQsIGxlZnRLZXksIHJpZ2h0KSB7XG4gICAgICBpZiAobGVmdC5zdGF0ZS5zdGF0ZU51bWJlciAhPT0gcmlnaHQuc3RhdGUuc3RhdGVOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGxlZnRLZXkuYWx0ICE9PSByaWdodC5hbHQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuc2VtYW50aWNDb250ZXh0LmVxdWFscyhyaWdodC5zZW1hbnRpY0NvbnRleHQpO1xuICAgIH1cbiAgICBnZXRLZXkoZSkge1xuICAgICAgcmV0dXJuIHtzdGF0ZTogZS5zdGF0ZS5zdGF0ZU51bWJlciwgYWx0OiBlLmFsdH07XG4gICAgfVxuICAgIGNvbnRhaW5zQWxsKGMpIHtcbiAgICAgIGZvciAobGV0IG8gb2YgYykge1xuICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgQVROQ29uZmlnXzEuQVROQ29uZmlnKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY29udGFpbnMobykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhZGRBbGwoYywgY29udGV4dENhY2hlKSB7XG4gICAgICB0aGlzLmVuc3VyZVdyaXRhYmxlKCk7XG4gICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgZ3JvdXAgb2YgYykge1xuICAgICAgICBpZiAodGhpcy5hZGQoZ3JvdXAsIGNvbnRleHRDYWNoZSkpIHtcbiAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgdGhpcy5lbnN1cmVXcml0YWJsZSgpO1xuICAgICAgaWYgKCF0aGlzLm1lcmdlZENvbmZpZ3MgfHwgIXRoaXMudW5tZXJnZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ292ZXJlZCBieSBlbnN1cmVXcml0YWJsZSBidXQgZHVwbGljYXRlZCBoZXJlIGZvciBzdHJpY3QgbnVsbCBjaGVjayBsaW1pdGF0aW9uXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5tZXJnZWRDb25maWdzLmNsZWFyKCk7XG4gICAgICB0aGlzLnVubWVyZ2VkLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLmNvbmZpZ3MubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuX2RpcHNJbnRvT3V0ZXJDb250ZXh0ID0gZmFsc2U7XG4gICAgICB0aGlzLl9oYXNTZW1hbnRpY0NvbnRleHQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3VuaXF1ZUFsdCA9IEFUTl8xLkFUTi5JTlZBTElEX0FMVF9OVU1CRVI7XG4gICAgICB0aGlzLl9jb25mbGljdEluZm8gPSB2b2lkIDA7XG4gICAgfVxuICAgIGVxdWFscyhvYmopIHtcbiAgICAgIGlmICh0aGlzID09PSBvYmopIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIShvYmogaW5zdGFuY2VvZiBBVE5Db25maWdTZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm91dGVybW9zdENvbmZpZ1NldCA9PT0gb2JqLm91dGVybW9zdENvbmZpZ1NldCAmJiBVdGlsczMuZXF1YWxzKHRoaXMuX2NvbmZsaWN0SW5mbywgb2JqLl9jb25mbGljdEluZm8pICYmIEFycmF5RXF1YWxpdHlDb21wYXJhdG9yXzEuQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UuZXF1YWxzKHRoaXMuY29uZmlncywgb2JqLmNvbmZpZ3MpO1xuICAgIH1cbiAgICBoYXNoQ29kZSgpIHtcbiAgICAgIGlmICh0aGlzLmlzUmVhZE9ubHkgJiYgdGhpcy5jYWNoZWRIYXNoQ29kZSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkSGFzaENvZGU7XG4gICAgICB9XG4gICAgICBsZXQgaGFzaENvZGUgPSAxO1xuICAgICAgaGFzaENvZGUgPSA1ICogaGFzaENvZGUgXiAodGhpcy5vdXRlcm1vc3RDb25maWdTZXQgPyAxIDogMCk7XG4gICAgICBoYXNoQ29kZSA9IDUgKiBoYXNoQ29kZSBeIEFycmF5RXF1YWxpdHlDb21wYXJhdG9yXzEuQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UuaGFzaENvZGUodGhpcy5jb25maWdzKTtcbiAgICAgIGlmICh0aGlzLmlzUmVhZE9ubHkpIHtcbiAgICAgICAgdGhpcy5jYWNoZWRIYXNoQ29kZSA9IGhhc2hDb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc2hDb2RlO1xuICAgIH1cbiAgICB0b1N0cmluZyhzaG93Q29udGV4dCkge1xuICAgICAgaWYgKHNob3dDb250ZXh0ID09IG51bGwpIHtcbiAgICAgICAgc2hvd0NvbnRleHQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxldCBidWYgPSBcIlwiO1xuICAgICAgbGV0IHNvcnRlZENvbmZpZ3MgPSB0aGlzLmNvbmZpZ3Muc2xpY2UoMCk7XG4gICAgICBzb3J0ZWRDb25maWdzLnNvcnQoKG8xLCBvMikgPT4ge1xuICAgICAgICBpZiAobzEuYWx0ICE9PSBvMi5hbHQpIHtcbiAgICAgICAgICByZXR1cm4gbzEuYWx0IC0gbzIuYWx0O1xuICAgICAgICB9IGVsc2UgaWYgKG8xLnN0YXRlLnN0YXRlTnVtYmVyICE9PSBvMi5zdGF0ZS5zdGF0ZU51bWJlcikge1xuICAgICAgICAgIHJldHVybiBvMS5zdGF0ZS5zdGF0ZU51bWJlciAtIG8yLnN0YXRlLnN0YXRlTnVtYmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBvMS5zZW1hbnRpY0NvbnRleHQudG9TdHJpbmcoKS5sb2NhbGVDb21wYXJlKG8yLnNlbWFudGljQ29udGV4dC50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBidWYgKz0gXCJbXCI7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvcnRlZENvbmZpZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgYnVmICs9IFwiLCBcIjtcbiAgICAgICAgfVxuICAgICAgICBidWYgKz0gc29ydGVkQ29uZmlnc1tpXS50b1N0cmluZyh2b2lkIDAsIHRydWUsIHNob3dDb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGJ1ZiArPSBcIl1cIjtcbiAgICAgIGlmICh0aGlzLl9oYXNTZW1hbnRpY0NvbnRleHQpIHtcbiAgICAgICAgYnVmICs9IFwiLGhhc1NlbWFudGljQ29udGV4dD1cIiArIHRoaXMuX2hhc1NlbWFudGljQ29udGV4dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl91bmlxdWVBbHQgIT09IEFUTl8xLkFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcbiAgICAgICAgYnVmICs9IFwiLHVuaXF1ZUFsdD1cIiArIHRoaXMuX3VuaXF1ZUFsdDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jb25mbGljdEluZm8gIT0gbnVsbCkge1xuICAgICAgICBidWYgKz0gXCIsY29uZmxpY3RpbmdBbHRzPVwiICsgdGhpcy5fY29uZmxpY3RJbmZvLmNvbmZsaWN0ZWRBbHRzO1xuICAgICAgICBpZiAoIXRoaXMuX2NvbmZsaWN0SW5mby5pc0V4YWN0KSB7XG4gICAgICAgICAgYnVmICs9IFwiKlwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fZGlwc0ludG9PdXRlckNvbnRleHQpIHtcbiAgICAgICAgYnVmICs9IFwiLGRpcHNJbnRvT3V0ZXJDb250ZXh0XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGdldCB1bmlxdWVBbHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdW5pcXVlQWx0O1xuICAgIH1cbiAgICBnZXQgaGFzU2VtYW50aWNDb250ZXh0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1NlbWFudGljQ29udGV4dDtcbiAgICB9XG4gICAgc2V0IGhhc1NlbWFudGljQ29udGV4dCh2YWx1ZSkge1xuICAgICAgdGhpcy5lbnN1cmVXcml0YWJsZSgpO1xuICAgICAgdGhpcy5faGFzU2VtYW50aWNDb250ZXh0ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBjb25mbGljdEluZm8oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29uZmxpY3RJbmZvO1xuICAgIH1cbiAgICBzZXQgY29uZmxpY3RJbmZvKGNvbmZsaWN0SW5mbykge1xuICAgICAgdGhpcy5lbnN1cmVXcml0YWJsZSgpO1xuICAgICAgdGhpcy5fY29uZmxpY3RJbmZvID0gY29uZmxpY3RJbmZvO1xuICAgIH1cbiAgICBnZXQgY29uZmxpY3RpbmdBbHRzKCkge1xuICAgICAgaWYgKHRoaXMuX2NvbmZsaWN0SW5mbyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fY29uZmxpY3RJbmZvLmNvbmZsaWN0ZWRBbHRzO1xuICAgIH1cbiAgICBnZXQgaXNFeGFjdENvbmZsaWN0KCkge1xuICAgICAgaWYgKHRoaXMuX2NvbmZsaWN0SW5mbyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9jb25mbGljdEluZm8uaXNFeGFjdDtcbiAgICB9XG4gICAgZ2V0IGRpcHNJbnRvT3V0ZXJDb250ZXh0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RpcHNJbnRvT3V0ZXJDb250ZXh0O1xuICAgIH1cbiAgICBnZXQoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBlbnN1cmVXcml0YWJsZSgpIHtcbiAgICAgIGlmICh0aGlzLmlzUmVhZE9ubHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBBVE5Db25maWdTZXQgaXMgcmVhZCBvbmx5LlwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIEFUTkNvbmZpZ1NldC5wcm90b3R5cGUsIFwiZ2V0UmVwcmVzZW50ZWRBbHRlcm5hdGl2ZXNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBBVE5Db25maWdTZXQucHJvdG90eXBlLCBcInNpemVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBBVE5Db25maWdTZXQucHJvdG90eXBlLCBcImlzRW1wdHlcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBBVE5Db25maWdTZXQucHJvdG90eXBlLCBcImNvbnRhaW5zXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQVROQ29uZmlnU2V0LnByb3RvdHlwZSwgU3ltYm9sLml0ZXJhdG9yLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEFUTkNvbmZpZ1NldC5wcm90b3R5cGUsIFwidG9BcnJheVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEFUTkNvbmZpZ1NldC5wcm90b3R5cGUsIFwiY29udGFpbnNBbGxcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBBVE5Db25maWdTZXQucHJvdG90eXBlLCBcImNsZWFyXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQVROQ29uZmlnU2V0LnByb3RvdHlwZSwgXCJlcXVhbHNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBBVE5Db25maWdTZXQucHJvdG90eXBlLCBcImhhc2hDb2RlXCIsIG51bGwpO1xuICBleHBvcnRzLkFUTkNvbmZpZ1NldCA9IEFUTkNvbmZpZ1NldDtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvZGZhL0RGQVN0YXRlLmpzXG52YXIgcmVxdWlyZV9ERkFTdGF0ZSA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgdmFyIF9fcGFyYW0gPSBleHBvcnRzICYmIGV4cG9ydHMuX19wYXJhbSB8fCBmdW5jdGlvbihwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7XG4gICAgfTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5ERkFTdGF0ZSA9IHZvaWQgMDtcbiAgdmFyIEFUTl8xID0gcmVxdWlyZV9BVE4oKTtcbiAgdmFyIEJpdFNldF8xID0gcmVxdWlyZV9CaXRTZXQoKTtcbiAgdmFyIE11cm11ckhhc2hfMSA9IHJlcXVpcmVfTXVybXVySGFzaCgpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBQcmVkaWN0aW9uQ29udGV4dF8xID0gcmVxdWlyZV9QcmVkaWN0aW9uQ29udGV4dCgpO1xuICB2YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbiAgdmFyIERGQVN0YXRlID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3MpIHtcbiAgICAgIHRoaXMuc3RhdGVOdW1iZXIgPSAtMTtcbiAgICAgIHRoaXMuY29uZmlncyA9IGNvbmZpZ3M7XG4gICAgICB0aGlzLmVkZ2VzID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5jb250ZXh0RWRnZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGdldCBpc0NvbnRleHRTZW5zaXRpdmUoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLmNvbnRleHRTeW1ib2xzO1xuICAgIH1cbiAgICBpc0NvbnRleHRTeW1ib2woc3ltYm9sKSB7XG4gICAgICBpZiAoIXRoaXMuaXNDb250ZXh0U2Vuc2l0aXZlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHRTeW1ib2xzLmdldChzeW1ib2wpO1xuICAgIH1cbiAgICBzZXRDb250ZXh0U3ltYm9sKHN5bWJvbCkge1xuICAgICAgYXNzZXJ0KHRoaXMuaXNDb250ZXh0U2Vuc2l0aXZlKTtcbiAgICAgIHRoaXMuY29udGV4dFN5bWJvbHMuc2V0KHN5bWJvbCk7XG4gICAgfVxuICAgIHNldENvbnRleHRTZW5zaXRpdmUoYXRuKSB7XG4gICAgICBhc3NlcnQoIXRoaXMuY29uZmlncy5pc091dGVybW9zdENvbmZpZ1NldCk7XG4gICAgICBpZiAodGhpcy5pc0NvbnRleHRTZW5zaXRpdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNvbnRleHRTeW1ib2xzKSB7XG4gICAgICAgIHRoaXMuY29udGV4dFN5bWJvbHMgPSBuZXcgQml0U2V0XzEuQml0U2V0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGdldCBhY2NlcHRTdGF0ZUluZm8oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWNjZXB0U3RhdGVJbmZvO1xuICAgIH1cbiAgICBzZXQgYWNjZXB0U3RhdGVJbmZvKGFjY2VwdFN0YXRlSW5mbykge1xuICAgICAgdGhpcy5fYWNjZXB0U3RhdGVJbmZvID0gYWNjZXB0U3RhdGVJbmZvO1xuICAgIH1cbiAgICBnZXQgaXNBY2NlcHRTdGF0ZSgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuX2FjY2VwdFN0YXRlSW5mbztcbiAgICB9XG4gICAgZ2V0IHByZWRpY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX2FjY2VwdFN0YXRlSW5mbykge1xuICAgICAgICByZXR1cm4gQVROXzEuQVROLklOVkFMSURfQUxUX05VTUJFUjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9hY2NlcHRTdGF0ZUluZm8ucHJlZGljdGlvbjtcbiAgICB9XG4gICAgZ2V0IGxleGVyQWN0aW9uRXhlY3V0b3IoKSB7XG4gICAgICBpZiAoIXRoaXMuX2FjY2VwdFN0YXRlSW5mbykge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2FjY2VwdFN0YXRlSW5mby5sZXhlckFjdGlvbkV4ZWN1dG9yO1xuICAgIH1cbiAgICBnZXRUYXJnZXQoc3ltYm9sKSB7XG4gICAgICByZXR1cm4gdGhpcy5lZGdlcy5nZXQoc3ltYm9sKTtcbiAgICB9XG4gICAgc2V0VGFyZ2V0KHN5bWJvbCwgdGFyZ2V0KSB7XG4gICAgICB0aGlzLmVkZ2VzLnNldChzeW1ib2wsIHRhcmdldCk7XG4gICAgfVxuICAgIGdldEVkZ2VNYXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lZGdlcztcbiAgICB9XG4gICAgZ2V0Q29udGV4dFRhcmdldChpbnZva2luZ1N0YXRlKSB7XG4gICAgICBpZiAoaW52b2tpbmdTdGF0ZSA9PT0gUHJlZGljdGlvbkNvbnRleHRfMS5QcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWSkge1xuICAgICAgICBpbnZva2luZ1N0YXRlID0gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0RWRnZXMuZ2V0KGludm9raW5nU3RhdGUpO1xuICAgIH1cbiAgICBzZXRDb250ZXh0VGFyZ2V0KGludm9raW5nU3RhdGUsIHRhcmdldCkge1xuICAgICAgaWYgKCF0aGlzLmlzQ29udGV4dFNlbnNpdGl2ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3RhdGUgaXMgbm90IGNvbnRleHQgc2Vuc2l0aXZlLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnZva2luZ1N0YXRlID09PSBQcmVkaWN0aW9uQ29udGV4dF8xLlByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZKSB7XG4gICAgICAgIGludm9raW5nU3RhdGUgPSAtMTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGV4dEVkZ2VzLnNldChpbnZva2luZ1N0YXRlLCB0YXJnZXQpO1xuICAgIH1cbiAgICBnZXRDb250ZXh0RWRnZU1hcCgpIHtcbiAgICAgIGxldCBtYXAgPSBuZXcgTWFwKHRoaXMuY29udGV4dEVkZ2VzKTtcbiAgICAgIGxldCBleGlzdGluZyA9IG1hcC5nZXQoLTEpO1xuICAgICAgaWYgKGV4aXN0aW5nICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKG1hcC5zaXplID09PSAxKSB7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICByZXN1bHQuc2V0KFByZWRpY3Rpb25Db250ZXh0XzEuUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTF9TVEFURV9LRVksIGV4aXN0aW5nKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcC5kZWxldGUoLTEpO1xuICAgICAgICAgIG1hcC5zZXQoUHJlZGljdGlvbkNvbnRleHRfMS5QcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWSwgZXhpc3RpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBoYXNoQ29kZSgpIHtcbiAgICAgIGxldCBoYXNoID0gTXVybXVySGFzaF8xLk11cm11ckhhc2guaW5pdGlhbGl6ZSg3KTtcbiAgICAgIGhhc2ggPSBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC51cGRhdGUoaGFzaCwgdGhpcy5jb25maWdzLmhhc2hDb2RlKCkpO1xuICAgICAgaGFzaCA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLmZpbmlzaChoYXNoLCAxKTtcbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgICBlcXVhbHMobykge1xuICAgICAgaWYgKHRoaXMgPT09IG8pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIShvIGluc3RhbmNlb2YgREZBU3RhdGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxldCBvdGhlciA9IG87XG4gICAgICBsZXQgc2FtZVNldCA9IHRoaXMuY29uZmlncy5lcXVhbHMob3RoZXIuY29uZmlncyk7XG4gICAgICByZXR1cm4gc2FtZVNldDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICBsZXQgYnVmID0gXCJcIjtcbiAgICAgIGJ1ZiArPSB0aGlzLnN0YXRlTnVtYmVyICsgXCI6XCIgKyB0aGlzLmNvbmZpZ3M7XG4gICAgICBpZiAodGhpcy5pc0FjY2VwdFN0YXRlKSB7XG4gICAgICAgIGJ1ZiArPSBcIj0+XCI7XG4gICAgICAgIGlmICh0aGlzLnByZWRpY2F0ZXMpIHtcbiAgICAgICAgICBidWYgKz0gdGhpcy5wcmVkaWNhdGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1ZiArPSB0aGlzLnByZWRpY3Rpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYudG9TdHJpbmcoKTtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIERGQVN0YXRlLnByb3RvdHlwZSwgXCJjb25maWdzXCIsIHZvaWQgMCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIERGQVN0YXRlLnByb3RvdHlwZSwgXCJlZGdlc1wiLCB2b2lkIDApO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBERkFTdGF0ZS5wcm90b3R5cGUsIFwiY29udGV4dEVkZ2VzXCIsIHZvaWQgMCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBERkFTdGF0ZS5wcm90b3R5cGUsIFwiaGFzaENvZGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBERkFTdGF0ZS5wcm90b3R5cGUsIFwiZXF1YWxzXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgREZBU3RhdGUucHJvdG90eXBlLCBcInRvU3RyaW5nXCIsIG51bGwpO1xuICBleHBvcnRzLkRGQVN0YXRlID0gREZBU3RhdGU7XG4gIChmdW5jdGlvbihERkFTdGF0ZTIpIHtcbiAgICBsZXQgUHJlZFByZWRpY3Rpb24gPSBjbGFzcyBQcmVkUHJlZGljdGlvbiB7XG4gICAgICBjb25zdHJ1Y3RvcihwcmVkLCBhbHQpIHtcbiAgICAgICAgdGhpcy5hbHQgPSBhbHQ7XG4gICAgICAgIHRoaXMucHJlZCA9IHByZWQ7XG4gICAgICB9XG4gICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiKFwiICsgdGhpcy5wcmVkICsgXCIsIFwiICsgdGhpcy5hbHQgKyBcIilcIjtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgICBdLCBQcmVkUHJlZGljdGlvbi5wcm90b3R5cGUsIFwicHJlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gICAgXSwgUHJlZFByZWRpY3Rpb24ucHJvdG90eXBlLCBcInRvU3RyaW5nXCIsIG51bGwpO1xuICAgIFByZWRQcmVkaWN0aW9uID0gX19kZWNvcmF0ZShbXG4gICAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICAgIF0sIFByZWRQcmVkaWN0aW9uKTtcbiAgICBERkFTdGF0ZTIuUHJlZFByZWRpY3Rpb24gPSBQcmVkUHJlZGljdGlvbjtcbiAgfSkoREZBU3RhdGUgPSBleHBvcnRzLkRGQVN0YXRlIHx8IChleHBvcnRzLkRGQVN0YXRlID0ge30pKTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvYXRuL0FUTlNpbXVsYXRvci5qc1xudmFyIHJlcXVpcmVfQVROU2ltdWxhdG9yID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkFUTlNpbXVsYXRvciA9IHZvaWQgMDtcbiAgdmFyIEFUTkNvbmZpZ1NldF8xID0gcmVxdWlyZV9BVE5Db25maWdTZXQoKTtcbiAgdmFyIERGQVN0YXRlXzEgPSByZXF1aXJlX0RGQVN0YXRlKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIFByZWRpY3Rpb25Db250ZXh0XzEgPSByZXF1aXJlX1ByZWRpY3Rpb25Db250ZXh0KCk7XG4gIHZhciBBVE5TaW11bGF0b3IgPSBjbGFzcyBBVE5TaW11bGF0b3IyIHtcbiAgICBjb25zdHJ1Y3RvcihhdG4pIHtcbiAgICAgIHRoaXMuYXRuID0gYXRuO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IEVSUk9SKCkge1xuICAgICAgaWYgKCFBVE5TaW11bGF0b3IyLl9FUlJPUikge1xuICAgICAgICBBVE5TaW11bGF0b3IyLl9FUlJPUiA9IG5ldyBERkFTdGF0ZV8xLkRGQVN0YXRlKG5ldyBBVE5Db25maWdTZXRfMS5BVE5Db25maWdTZXQoKSk7XG4gICAgICAgIEFUTlNpbXVsYXRvcjIuX0VSUk9SLnN0YXRlTnVtYmVyID0gUHJlZGljdGlvbkNvbnRleHRfMS5QcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBVE5TaW11bGF0b3IyLl9FUlJPUjtcbiAgICB9XG4gICAgY2xlYXJERkEoKSB7XG4gICAgICB0aGlzLmF0bi5jbGVhckRGQSgpO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgQVROU2ltdWxhdG9yLnByb3RvdHlwZSwgXCJhdG5cIiwgdm9pZCAwKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgQVROU2ltdWxhdG9yLCBcIkVSUk9SXCIsIG51bGwpO1xuICBBVE5TaW11bGF0b3IgPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBBVE5TaW11bGF0b3IpO1xuICBleHBvcnRzLkFUTlNpbXVsYXRvciA9IEFUTlNpbXVsYXRvcjtcbiAgKGZ1bmN0aW9uKEFUTlNpbXVsYXRvcjIpIHtcbiAgICBjb25zdCBSVUxFX1ZBUklBTlRfREVMSU1JVEVSID0gXCIkXCI7XG4gICAgY29uc3QgUlVMRV9MRl9WQVJJQU5UX01BUktFUiA9IFwiJGxmJFwiO1xuICAgIGNvbnN0IFJVTEVfTk9MRl9WQVJJQU5UX01BUktFUiA9IFwiJG5vbGYkXCI7XG4gIH0pKEFUTlNpbXVsYXRvciA9IGV4cG9ydHMuQVROU2ltdWxhdG9yIHx8IChleHBvcnRzLkFUTlNpbXVsYXRvciA9IHt9KSk7XG4gIGV4cG9ydHMuQVROU2ltdWxhdG9yID0gQVROU2ltdWxhdG9yO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9Db25zb2xlRXJyb3JMaXN0ZW5lci5qc1xudmFyIHJlcXVpcmVfQ29uc29sZUVycm9yTGlzdGVuZXIgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkNvbnNvbGVFcnJvckxpc3RlbmVyID0gdm9pZCAwO1xuICB2YXIgQ29uc29sZUVycm9yTGlzdGVuZXIgPSBjbGFzcyB7XG4gICAgc3ludGF4RXJyb3IocmVjb2duaXplciwgb2ZmZW5kaW5nU3ltYm9sLCBsaW5lLCBjaGFyUG9zaXRpb25JbkxpbmUsIG1zZywgZSkge1xuICAgICAgY29uc29sZS5lcnJvcihgbGluZSAke2xpbmV9OiR7Y2hhclBvc2l0aW9uSW5MaW5lfSAke21zZ31gKTtcbiAgICB9XG4gIH07XG4gIGV4cG9ydHMuQ29uc29sZUVycm9yTGlzdGVuZXIgPSBDb25zb2xlRXJyb3JMaXN0ZW5lcjtcbiAgQ29uc29sZUVycm9yTGlzdGVuZXIuSU5TVEFOQ0UgPSBuZXcgQ29uc29sZUVycm9yTGlzdGVuZXIoKTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvUHJveHlFcnJvckxpc3RlbmVyLmpzXG52YXIgcmVxdWlyZV9Qcm94eUVycm9yTGlzdGVuZXIgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuUHJveHlFcnJvckxpc3RlbmVyID0gdm9pZCAwO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBQcm94eUVycm9yTGlzdGVuZXIgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoZGVsZWdhdGVzKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlcyA9IGRlbGVnYXRlcztcbiAgICAgIGlmICghZGVsZWdhdGVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGVsZWdhdGVzXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXREZWxlZ2F0ZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZXM7XG4gICAgfVxuICAgIHN5bnRheEVycm9yKHJlY29nbml6ZXIsIG9mZmVuZGluZ1N5bWJvbCwgbGluZSwgY2hhclBvc2l0aW9uSW5MaW5lLCBtc2csIGUpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGVzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgIGlmIChsaXN0ZW5lci5zeW50YXhFcnJvcikge1xuICAgICAgICAgIGxpc3RlbmVyLnN5bnRheEVycm9yKHJlY29nbml6ZXIsIG9mZmVuZGluZ1N5bWJvbCwgbGluZSwgY2hhclBvc2l0aW9uSW5MaW5lLCBtc2csIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZSxcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDQsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBQcm94eUVycm9yTGlzdGVuZXIucHJvdG90eXBlLCBcInN5bnRheEVycm9yXCIsIG51bGwpO1xuICBleHBvcnRzLlByb3h5RXJyb3JMaXN0ZW5lciA9IFByb3h5RXJyb3JMaXN0ZW5lcjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvUmVjb2duaXplci5qc1xudmFyIHJlcXVpcmVfUmVjb2duaXplciA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgdmFyIF9fcGFyYW0gPSBleHBvcnRzICYmIGV4cG9ydHMuX19wYXJhbSB8fCBmdW5jdGlvbihwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7XG4gICAgfTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5SZWNvZ25pemVyID0gdm9pZCAwO1xuICB2YXIgQ29uc29sZUVycm9yTGlzdGVuZXJfMSA9IHJlcXVpcmVfQ29uc29sZUVycm9yTGlzdGVuZXIoKTtcbiAgdmFyIFByb3h5RXJyb3JMaXN0ZW5lcl8xID0gcmVxdWlyZV9Qcm94eUVycm9yTGlzdGVuZXIoKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgVG9rZW5fMSA9IHJlcXVpcmVfVG9rZW4oKTtcbiAgdmFyIFV0aWxzMyA9IHJlcXVpcmVfVXRpbHMoKTtcbiAgdmFyIFJlY29nbml6ZXIgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbQ29uc29sZUVycm9yTGlzdGVuZXJfMS5Db25zb2xlRXJyb3JMaXN0ZW5lci5JTlNUQU5DRV07XG4gICAgICB0aGlzLl9zdGF0ZU51bWJlciA9IC0xO1xuICAgIH1cbiAgICBnZXRUb2tlblR5cGVNYXAoKSB7XG4gICAgICBsZXQgdm9jYWJ1bGFyeSA9IHRoaXMudm9jYWJ1bGFyeTtcbiAgICAgIGxldCByZXN1bHQgPSBSZWNvZ25pemVyLnRva2VuVHlwZU1hcENhY2hlLmdldCh2b2NhYnVsYXJ5KTtcbiAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICBsZXQgaW50ZXJtZWRpYXRlUmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB0aGlzLmF0bi5tYXhUb2tlblR5cGU7IGkrKykge1xuICAgICAgICAgIGxldCBsaXRlcmFsTmFtZSA9IHZvY2FidWxhcnkuZ2V0TGl0ZXJhbE5hbWUoaSk7XG4gICAgICAgICAgaWYgKGxpdGVyYWxOYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIGludGVybWVkaWF0ZVJlc3VsdC5zZXQobGl0ZXJhbE5hbWUsIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgc3ltYm9saWNOYW1lID0gdm9jYWJ1bGFyeS5nZXRTeW1ib2xpY05hbWUoaSk7XG4gICAgICAgICAgaWYgKHN5bWJvbGljTmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnRlcm1lZGlhdGVSZXN1bHQuc2V0KHN5bWJvbGljTmFtZSwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGludGVybWVkaWF0ZVJlc3VsdC5zZXQoXCJFT0ZcIiwgVG9rZW5fMS5Ub2tlbi5FT0YpO1xuICAgICAgICByZXN1bHQgPSBpbnRlcm1lZGlhdGVSZXN1bHQ7XG4gICAgICAgIFJlY29nbml6ZXIudG9rZW5UeXBlTWFwQ2FjaGUuc2V0KHZvY2FidWxhcnksIHJlc3VsdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXRSdWxlSW5kZXhNYXAoKSB7XG4gICAgICBsZXQgcnVsZU5hbWVzID0gdGhpcy5ydWxlTmFtZXM7XG4gICAgICBpZiAocnVsZU5hbWVzID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgcmVjb2duaXplciBkb2VzIG5vdCBwcm92aWRlIGEgbGlzdCBvZiBydWxlIG5hbWVzLlwiKTtcbiAgICAgIH1cbiAgICAgIGxldCByZXN1bHQgPSBSZWNvZ25pemVyLnJ1bGVJbmRleE1hcENhY2hlLmdldChydWxlTmFtZXMpO1xuICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdCA9IFV0aWxzMy50b01hcChydWxlTmFtZXMpO1xuICAgICAgICBSZWNvZ25pemVyLnJ1bGVJbmRleE1hcENhY2hlLnNldChydWxlTmFtZXMsIHJlc3VsdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXRUb2tlblR5cGUodG9rZW5OYW1lKSB7XG4gICAgICBsZXQgdHR5cGUgPSB0aGlzLmdldFRva2VuVHlwZU1hcCgpLmdldCh0b2tlbk5hbWUpO1xuICAgICAgaWYgKHR0eXBlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHR0eXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRva2VuXzEuVG9rZW4uSU5WQUxJRF9UWVBFO1xuICAgIH1cbiAgICBnZXQgc2VyaWFsaXplZEFUTigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInRoZXJlIGlzIG5vIHNlcmlhbGl6ZWQgQVROXCIpO1xuICAgIH1cbiAgICBnZXQgYXRuKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ludGVycC5hdG47XG4gICAgfVxuICAgIGdldCBpbnRlcnByZXRlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbnRlcnA7XG4gICAgfVxuICAgIHNldCBpbnRlcnByZXRlcihpbnRlcnByZXRlcikge1xuICAgICAgdGhpcy5faW50ZXJwID0gaW50ZXJwcmV0ZXI7XG4gICAgfVxuICAgIGdldCBwYXJzZUluZm8oKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfVxuICAgIGdldEVycm9ySGVhZGVyKGUpIHtcbiAgICAgIGxldCB0b2tlbiA9IGUuZ2V0T2ZmZW5kaW5nVG9rZW4oKTtcbiAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBsZXQgbGluZSA9IHRva2VuLmxpbmU7XG4gICAgICBsZXQgY2hhclBvc2l0aW9uSW5MaW5lID0gdG9rZW4uY2hhclBvc2l0aW9uSW5MaW5lO1xuICAgICAgcmV0dXJuIFwibGluZSBcIiArIGxpbmUgKyBcIjpcIiArIGNoYXJQb3NpdGlvbkluTGluZTtcbiAgICB9XG4gICAgYWRkRXJyb3JMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibGlzdGVuZXIgbXVzdCBub3QgYmUgbnVsbFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmVtb3ZlRXJyb3JMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgbGV0IHBvc2l0aW9uID0gdGhpcy5fbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgaWYgKHBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlRXJyb3JMaXN0ZW5lcnMoKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgZ2V0RXJyb3JMaXN0ZW5lcnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzLnNsaWNlKDApO1xuICAgIH1cbiAgICBnZXRFcnJvckxpc3RlbmVyRGlzcGF0Y2goKSB7XG4gICAgICByZXR1cm4gbmV3IFByb3h5RXJyb3JMaXN0ZW5lcl8xLlByb3h5RXJyb3JMaXN0ZW5lcih0aGlzLmdldEVycm9yTGlzdGVuZXJzKCkpO1xuICAgIH1cbiAgICBzZW1wcmVkKF9sb2NhbGN0eCwgcnVsZUluZGV4LCBhY3Rpb25JbmRleCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHByZWNwcmVkKGxvY2FsY3R4LCBwcmVjZWRlbmNlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYWN0aW9uKF9sb2NhbGN0eCwgcnVsZUluZGV4LCBhY3Rpb25JbmRleCkge1xuICAgIH1cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhdGVOdW1iZXI7XG4gICAgfVxuICAgIHNldCBzdGF0ZShhdG5TdGF0ZSkge1xuICAgICAgdGhpcy5fc3RhdGVOdW1iZXIgPSBhdG5TdGF0ZTtcbiAgICB9XG4gIH07XG4gIFJlY29nbml6ZXIuRU9GID0gLTE7XG4gIFJlY29nbml6ZXIudG9rZW5UeXBlTWFwQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuICBSZWNvZ25pemVyLnJ1bGVJbmRleE1hcENhY2hlID0gbmV3IFdlYWtNYXAoKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLlN1cHByZXNzV2FybmluZ3MoXCJzZXJpYWxcIiksXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgUmVjb2duaXplci5wcm90b3R5cGUsIFwiX2xpc3RlbmVyc1wiLCB2b2lkIDApO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBSZWNvZ25pemVyLnByb3RvdHlwZSwgXCJnZXRUb2tlblR5cGVNYXBcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIFJlY29nbml6ZXIucHJvdG90eXBlLCBcImdldFJ1bGVJbmRleE1hcFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgUmVjb2duaXplci5wcm90b3R5cGUsIFwic2VyaWFsaXplZEFUTlwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgUmVjb2duaXplci5wcm90b3R5cGUsIFwiYXRuXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbCxcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBSZWNvZ25pemVyLnByb3RvdHlwZSwgXCJpbnRlcnByZXRlclwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGwsXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgUmVjb2duaXplci5wcm90b3R5cGUsIFwiZ2V0RXJyb3JIZWFkZXJcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIFJlY29nbml6ZXIucHJvdG90eXBlLCBcImFkZEVycm9yTGlzdGVuZXJcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIFJlY29nbml6ZXIucHJvdG90eXBlLCBcInJlbW92ZUVycm9yTGlzdGVuZXJcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIFJlY29nbml6ZXIucHJvdG90eXBlLCBcImdldEVycm9yTGlzdGVuZXJzXCIsIG51bGwpO1xuICBleHBvcnRzLlJlY29nbml6ZXIgPSBSZWNvZ25pemVyO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9Wb2NhYnVsYXJ5SW1wbC5qc1xudmFyIHJlcXVpcmVfVm9jYWJ1bGFyeUltcGwgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuVm9jYWJ1bGFyeUltcGwgPSB2b2lkIDA7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIFRva2VuXzEgPSByZXF1aXJlX1Rva2VuKCk7XG4gIHZhciBWb2NhYnVsYXJ5SW1wbDMgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IobGl0ZXJhbE5hbWVzLCBzeW1ib2xpY05hbWVzLCBkaXNwbGF5TmFtZXMpIHtcbiAgICAgIHRoaXMubGl0ZXJhbE5hbWVzID0gbGl0ZXJhbE5hbWVzO1xuICAgICAgdGhpcy5zeW1ib2xpY05hbWVzID0gc3ltYm9saWNOYW1lcztcbiAgICAgIHRoaXMuZGlzcGxheU5hbWVzID0gZGlzcGxheU5hbWVzO1xuICAgICAgdGhpcy5fbWF4VG9rZW5UeXBlID0gTWF0aC5tYXgodGhpcy5kaXNwbGF5TmFtZXMubGVuZ3RoLCBNYXRoLm1heCh0aGlzLmxpdGVyYWxOYW1lcy5sZW5ndGgsIHRoaXMuc3ltYm9saWNOYW1lcy5sZW5ndGgpKSAtIDE7XG4gICAgfVxuICAgIGdldCBtYXhUb2tlblR5cGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWF4VG9rZW5UeXBlO1xuICAgIH1cbiAgICBnZXRMaXRlcmFsTmFtZSh0b2tlblR5cGUpIHtcbiAgICAgIGlmICh0b2tlblR5cGUgPj0gMCAmJiB0b2tlblR5cGUgPCB0aGlzLmxpdGVyYWxOYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGl0ZXJhbE5hbWVzW3Rva2VuVHlwZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBnZXRTeW1ib2xpY05hbWUodG9rZW5UeXBlKSB7XG4gICAgICBpZiAodG9rZW5UeXBlID49IDAgJiYgdG9rZW5UeXBlIDwgdGhpcy5zeW1ib2xpY05hbWVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zeW1ib2xpY05hbWVzW3Rva2VuVHlwZV07XG4gICAgICB9XG4gICAgICBpZiAodG9rZW5UeXBlID09PSBUb2tlbl8xLlRva2VuLkVPRikge1xuICAgICAgICByZXR1cm4gXCJFT0ZcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGdldERpc3BsYXlOYW1lKHRva2VuVHlwZSkge1xuICAgICAgaWYgKHRva2VuVHlwZSA+PSAwICYmIHRva2VuVHlwZSA8IHRoaXMuZGlzcGxheU5hbWVzLmxlbmd0aCkge1xuICAgICAgICBsZXQgZGlzcGxheU5hbWUgPSB0aGlzLmRpc3BsYXlOYW1lc1t0b2tlblR5cGVdO1xuICAgICAgICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBsaXRlcmFsTmFtZSA9IHRoaXMuZ2V0TGl0ZXJhbE5hbWUodG9rZW5UeXBlKTtcbiAgICAgIGlmIChsaXRlcmFsTmFtZSkge1xuICAgICAgICByZXR1cm4gbGl0ZXJhbE5hbWU7XG4gICAgICB9XG4gICAgICBsZXQgc3ltYm9saWNOYW1lID0gdGhpcy5nZXRTeW1ib2xpY05hbWUodG9rZW5UeXBlKTtcbiAgICAgIGlmIChzeW1ib2xpY05hbWUpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbGljTmFtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTdHJpbmcodG9rZW5UeXBlKTtcbiAgICB9XG4gIH07XG4gIFZvY2FidWxhcnlJbXBsMy5FTVBUWV9WT0NBQlVMQVJZID0gbmV3IFZvY2FidWxhcnlJbXBsMyhbXSwgW10sIFtdKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgVm9jYWJ1bGFyeUltcGwzLnByb3RvdHlwZSwgXCJsaXRlcmFsTmFtZXNcIiwgdm9pZCAwKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgVm9jYWJ1bGFyeUltcGwzLnByb3RvdHlwZSwgXCJzeW1ib2xpY05hbWVzXCIsIHZvaWQgMCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIFZvY2FidWxhcnlJbXBsMy5wcm90b3R5cGUsIFwiZGlzcGxheU5hbWVzXCIsIHZvaWQgMCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBWb2NhYnVsYXJ5SW1wbDMucHJvdG90eXBlLCBcIm1heFRva2VuVHlwZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFZvY2FidWxhcnlJbXBsMy5wcm90b3R5cGUsIFwiZ2V0TGl0ZXJhbE5hbWVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBWb2NhYnVsYXJ5SW1wbDMucHJvdG90eXBlLCBcImdldFN5bWJvbGljTmFtZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlLFxuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIFZvY2FidWxhcnlJbXBsMy5wcm90b3R5cGUsIFwiZ2V0RGlzcGxheU5hbWVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIFZvY2FidWxhcnlJbXBsMywgXCJFTVBUWV9WT0NBQlVMQVJZXCIsIHZvaWQgMCk7XG4gIGV4cG9ydHMuVm9jYWJ1bGFyeUltcGwgPSBWb2NhYnVsYXJ5SW1wbDM7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2RmYS9ERkFTZXJpYWxpemVyLmpzXG52YXIgcmVxdWlyZV9ERkFTZXJpYWxpemVyID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkRGQVNlcmlhbGl6ZXIgPSB2b2lkIDA7XG4gIHZhciBBVE5TaW11bGF0b3JfMSA9IHJlcXVpcmVfQVROU2ltdWxhdG9yKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIFByZWRpY3Rpb25Db250ZXh0XzEgPSByZXF1aXJlX1ByZWRpY3Rpb25Db250ZXh0KCk7XG4gIHZhciBSZWNvZ25pemVyXzEgPSByZXF1aXJlX1JlY29nbml6ZXIoKTtcbiAgdmFyIFZvY2FidWxhcnlJbXBsXzEgPSByZXF1aXJlX1ZvY2FidWxhcnlJbXBsKCk7XG4gIHZhciBERkFTZXJpYWxpemVyID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGRmYSwgdm9jYWJ1bGFyeSwgcnVsZU5hbWVzLCBhdG4pIHtcbiAgICAgIGlmICh2b2NhYnVsYXJ5IGluc3RhbmNlb2YgUmVjb2duaXplcl8xLlJlY29nbml6ZXIpIHtcbiAgICAgICAgcnVsZU5hbWVzID0gdm9jYWJ1bGFyeS5ydWxlTmFtZXM7XG4gICAgICAgIGF0biA9IHZvY2FidWxhcnkuYXRuO1xuICAgICAgICB2b2NhYnVsYXJ5ID0gdm9jYWJ1bGFyeS52b2NhYnVsYXJ5O1xuICAgICAgfSBlbHNlIGlmICghdm9jYWJ1bGFyeSkge1xuICAgICAgICB2b2NhYnVsYXJ5ID0gVm9jYWJ1bGFyeUltcGxfMS5Wb2NhYnVsYXJ5SW1wbC5FTVBUWV9WT0NBQlVMQVJZO1xuICAgICAgfVxuICAgICAgdGhpcy5kZmEgPSBkZmE7XG4gICAgICB0aGlzLnZvY2FidWxhcnkgPSB2b2NhYnVsYXJ5O1xuICAgICAgdGhpcy5ydWxlTmFtZXMgPSBydWxlTmFtZXM7XG4gICAgICB0aGlzLmF0biA9IGF0bjtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICBpZiAoIXRoaXMuZGZhLnMwKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgbGV0IGJ1ZiA9IFwiXCI7XG4gICAgICBpZiAodGhpcy5kZmEuc3RhdGVzKSB7XG4gICAgICAgIGxldCBzdGF0ZXMgPSBuZXcgQXJyYXkoLi4udGhpcy5kZmEuc3RhdGVzLnRvQXJyYXkoKSk7XG4gICAgICAgIHN0YXRlcy5zb3J0KChvMSwgbzIpID0+IG8xLnN0YXRlTnVtYmVyIC0gbzIuc3RhdGVOdW1iZXIpO1xuICAgICAgICBmb3IgKGxldCBzIG9mIHN0YXRlcykge1xuICAgICAgICAgIGxldCBlZGdlcyA9IHMuZ2V0RWRnZU1hcCgpO1xuICAgICAgICAgIGxldCBlZGdlS2V5cyA9IFsuLi5lZGdlcy5rZXlzKCldLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgICBsZXQgY29udGV4dEVkZ2VzID0gcy5nZXRDb250ZXh0RWRnZU1hcCgpO1xuICAgICAgICAgIGxldCBjb250ZXh0RWRnZUtleXMgPSBbLi4uY29udGV4dEVkZ2VzLmtleXMoKV0uc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICAgIGZvciAobGV0IGVudHJ5IG9mIGVkZ2VLZXlzKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBlZGdlcy5nZXQoZW50cnkpO1xuICAgICAgICAgICAgaWYgKCh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSBBVE5TaW11bGF0b3JfMS5BVE5TaW11bGF0b3IuRVJST1IpICYmICFzLmlzQ29udGV4dFN5bWJvbChlbnRyeSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY29udGV4dFN5bWJvbCA9IGZhbHNlO1xuICAgICAgICAgICAgYnVmICs9IHRoaXMuZ2V0U3RhdGVTdHJpbmcocykgKyBcIi1cIiArIHRoaXMuZ2V0RWRnZUxhYmVsKGVudHJ5KSArIFwiLT5cIjtcbiAgICAgICAgICAgIGlmIChzLmlzQ29udGV4dFN5bWJvbChlbnRyeSkpIHtcbiAgICAgICAgICAgICAgYnVmICs9IFwiIVwiO1xuICAgICAgICAgICAgICBjb250ZXh0U3ltYm9sID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0ID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodCAmJiB0LnN0YXRlTnVtYmVyICE9PSBBVE5TaW11bGF0b3JfMS5BVE5TaW11bGF0b3IuRVJST1Iuc3RhdGVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgYnVmICs9IHRoaXMuZ2V0U3RhdGVTdHJpbmcodCkgKyBcIlxcblwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0U3ltYm9sKSB7XG4gICAgICAgICAgICAgIGJ1ZiArPSBcImN0eFxcblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocy5pc0NvbnRleHRTZW5zaXRpdmUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGVudHJ5IG9mIGNvbnRleHRFZGdlS2V5cykge1xuICAgICAgICAgICAgICBidWYgKz0gdGhpcy5nZXRTdGF0ZVN0cmluZyhzKSArIFwiLVwiICsgdGhpcy5nZXRDb250ZXh0TGFiZWwoZW50cnkpICsgXCItPlwiICsgdGhpcy5nZXRTdGF0ZVN0cmluZyhjb250ZXh0RWRnZXMuZ2V0KGVudHJ5KSkgKyBcIlxcblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IG91dHB1dCA9IGJ1ZjtcbiAgICAgIGlmIChvdXRwdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgZ2V0Q29udGV4dExhYmVsKGkpIHtcbiAgICAgIGlmIChpID09PSBQcmVkaWN0aW9uQ29udGV4dF8xLlByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZKSB7XG4gICAgICAgIHJldHVybiBcImN0eDpFTVBUWV9GVUxMXCI7XG4gICAgICB9IGVsc2UgaWYgKGkgPT09IFByZWRpY3Rpb25Db250ZXh0XzEuUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfTE9DQUxfU1RBVEVfS0VZKSB7XG4gICAgICAgIHJldHVybiBcImN0eDpFTVBUWV9MT0NBTFwiO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYXRuICYmIGkgPiAwICYmIGkgPD0gdGhpcy5hdG4uc3RhdGVzLmxlbmd0aCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmF0bi5zdGF0ZXNbaV07XG4gICAgICAgIGxldCBydWxlSW5kZXggPSBzdGF0ZS5ydWxlSW5kZXg7XG4gICAgICAgIGlmICh0aGlzLnJ1bGVOYW1lcyAmJiBydWxlSW5kZXggPj0gMCAmJiBydWxlSW5kZXggPCB0aGlzLnJ1bGVOYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gXCJjdHg6XCIgKyBTdHJpbmcoaSkgKyBcIihcIiArIHRoaXMucnVsZU5hbWVzW3J1bGVJbmRleF0gKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFwiY3R4OlwiICsgU3RyaW5nKGkpO1xuICAgIH1cbiAgICBnZXRFZGdlTGFiZWwoaSkge1xuICAgICAgcmV0dXJuIHRoaXMudm9jYWJ1bGFyeS5nZXREaXNwbGF5TmFtZShpKTtcbiAgICB9XG4gICAgZ2V0U3RhdGVTdHJpbmcocykge1xuICAgICAgaWYgKHMgPT09IEFUTlNpbXVsYXRvcl8xLkFUTlNpbXVsYXRvci5FUlJPUikge1xuICAgICAgICByZXR1cm4gXCJFUlJPUlwiO1xuICAgICAgfVxuICAgICAgbGV0IG4gPSBzLnN0YXRlTnVtYmVyO1xuICAgICAgbGV0IHN0YXRlU3RyID0gXCJzXCIgKyBuO1xuICAgICAgaWYgKHMuaXNBY2NlcHRTdGF0ZSkge1xuICAgICAgICBpZiAocy5wcmVkaWNhdGVzKSB7XG4gICAgICAgICAgc3RhdGVTdHIgPSBcIjpzXCIgKyBuICsgXCI9PlwiICsgcy5wcmVkaWNhdGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlU3RyID0gXCI6c1wiICsgbiArIFwiPT5cIiArIHMucHJlZGljdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHMuaXNDb250ZXh0U2Vuc2l0aXZlKSB7XG4gICAgICAgIHN0YXRlU3RyICs9IFwiKlwiO1xuICAgICAgICBmb3IgKGxldCBjb25maWcgb2Ygcy5jb25maWdzKSB7XG4gICAgICAgICAgaWYgKGNvbmZpZy5yZWFjaGVzSW50b091dGVyQ29udGV4dCkge1xuICAgICAgICAgICAgc3RhdGVTdHIgKz0gXCIqXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGF0ZVN0cjtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIERGQVNlcmlhbGl6ZXIucHJvdG90eXBlLCBcImRmYVwiLCB2b2lkIDApO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBERkFTZXJpYWxpemVyLnByb3RvdHlwZSwgXCJ2b2NhYnVsYXJ5XCIsIHZvaWQgMCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBERkFTZXJpYWxpemVyLnByb3RvdHlwZSwgXCJ0b1N0cmluZ1wiLCBudWxsKTtcbiAgZXhwb3J0cy5ERkFTZXJpYWxpemVyID0gREZBU2VyaWFsaXplcjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvZGZhL0xleGVyREZBU2VyaWFsaXplci5qc1xudmFyIHJlcXVpcmVfTGV4ZXJERkFTZXJpYWxpemVyID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkxleGVyREZBU2VyaWFsaXplciA9IHZvaWQgMDtcbiAgdmFyIERGQVNlcmlhbGl6ZXJfMSA9IHJlcXVpcmVfREZBU2VyaWFsaXplcigpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBWb2NhYnVsYXJ5SW1wbF8xID0gcmVxdWlyZV9Wb2NhYnVsYXJ5SW1wbCgpO1xuICB2YXIgTGV4ZXJERkFTZXJpYWxpemVyID0gY2xhc3MgTGV4ZXJERkFTZXJpYWxpemVyIGV4dGVuZHMgREZBU2VyaWFsaXplcl8xLkRGQVNlcmlhbGl6ZXIge1xuICAgIGNvbnN0cnVjdG9yKGRmYSkge1xuICAgICAgc3VwZXIoZGZhLCBWb2NhYnVsYXJ5SW1wbF8xLlZvY2FidWxhcnlJbXBsLkVNUFRZX1ZPQ0FCVUxBUlkpO1xuICAgIH1cbiAgICBnZXRFZGdlTGFiZWwoaSkge1xuICAgICAgcmV0dXJuIFwiJ1wiICsgU3RyaW5nLmZyb21Db2RlUG9pbnQoaSkgKyBcIidcIjtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZSxcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBMZXhlckRGQVNlcmlhbGl6ZXIucHJvdG90eXBlLCBcImdldEVkZ2VMYWJlbFwiLCBudWxsKTtcbiAgTGV4ZXJERkFTZXJpYWxpemVyID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgTGV4ZXJERkFTZXJpYWxpemVyKTtcbiAgZXhwb3J0cy5MZXhlckRGQVNlcmlhbGl6ZXIgPSBMZXhlckRGQVNlcmlhbGl6ZXI7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9TdGFyTG9vcEVudHJ5U3RhdGUuanNcbnZhciByZXF1aXJlX1N0YXJMb29wRW50cnlTdGF0ZSA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5TdGFyTG9vcEVudHJ5U3RhdGUgPSB2b2lkIDA7XG4gIHZhciBBVE5TdGF0ZVR5cGVfMSA9IHJlcXVpcmVfQVROU3RhdGVUeXBlKCk7XG4gIHZhciBCaXRTZXRfMSA9IHJlcXVpcmVfQml0U2V0KCk7XG4gIHZhciBEZWNpc2lvblN0YXRlXzEgPSByZXF1aXJlX0RlY2lzaW9uU3RhdGUoKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgU3Rhckxvb3BFbnRyeVN0YXRlID0gY2xhc3MgZXh0ZW5kcyBEZWNpc2lvblN0YXRlXzEuRGVjaXNpb25TdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgdGhpcy5wcmVjZWRlbmNlUnVsZURlY2lzaW9uID0gZmFsc2U7XG4gICAgICB0aGlzLnByZWNlZGVuY2VMb29wYmFja1N0YXRlcyA9IG5ldyBCaXRTZXRfMS5CaXRTZXQoKTtcbiAgICB9XG4gICAgZ2V0IHN0YXRlVHlwZSgpIHtcbiAgICAgIHJldHVybiBBVE5TdGF0ZVR5cGVfMS5BVE5TdGF0ZVR5cGUuU1RBUl9MT09QX0VOVFJZO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFN0YXJMb29wRW50cnlTdGF0ZS5wcm90b3R5cGUsIFwic3RhdGVUeXBlXCIsIG51bGwpO1xuICBleHBvcnRzLlN0YXJMb29wRW50cnlTdGF0ZSA9IFN0YXJMb29wRW50cnlTdGF0ZTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvZGZhL0RGQS5qc1xudmFyIHJlcXVpcmVfREZBID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkRGQSA9IHZvaWQgMDtcbiAgdmFyIEFycmF5MkRIYXNoU2V0XzEgPSByZXF1aXJlX0FycmF5MkRIYXNoU2V0KCk7XG4gIHZhciBBVE5Db25maWdTZXRfMSA9IHJlcXVpcmVfQVROQ29uZmlnU2V0KCk7XG4gIHZhciBERkFTZXJpYWxpemVyXzEgPSByZXF1aXJlX0RGQVNlcmlhbGl6ZXIoKTtcbiAgdmFyIERGQVN0YXRlXzEgPSByZXF1aXJlX0RGQVN0YXRlKCk7XG4gIHZhciBMZXhlckRGQVNlcmlhbGl6ZXJfMSA9IHJlcXVpcmVfTGV4ZXJERkFTZXJpYWxpemVyKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvcl8xID0gcmVxdWlyZV9PYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IoKTtcbiAgdmFyIFN0YXJMb29wRW50cnlTdGF0ZV8xID0gcmVxdWlyZV9TdGFyTG9vcEVudHJ5U3RhdGUoKTtcbiAgdmFyIFZvY2FidWxhcnlJbXBsXzEgPSByZXF1aXJlX1ZvY2FidWxhcnlJbXBsKCk7XG4gIHZhciBERkEgPSBjbGFzcyBERkEge1xuICAgIGNvbnN0cnVjdG9yKGF0blN0YXJ0U3RhdGUsIGRlY2lzaW9uID0gMCkge1xuICAgICAgdGhpcy5zdGF0ZXMgPSBuZXcgQXJyYXkyREhhc2hTZXRfMS5BcnJheTJESGFzaFNldChPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3JfMS5PYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UpO1xuICAgICAgdGhpcy5uZXh0U3RhdGVOdW1iZXIgPSAwO1xuICAgICAgaWYgKCFhdG5TdGFydFN0YXRlLmF0bikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgQVROU3RhdGUgbXVzdCBiZSBhc3NvY2lhdGVkIHdpdGggYW4gQVROXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5hdG5TdGFydFN0YXRlID0gYXRuU3RhcnRTdGF0ZTtcbiAgICAgIHRoaXMuYXRuID0gYXRuU3RhcnRTdGF0ZS5hdG47XG4gICAgICB0aGlzLmRlY2lzaW9uID0gZGVjaXNpb247XG4gICAgICBsZXQgaXNQcmVjZWRlbmNlRGZhID0gZmFsc2U7XG4gICAgICBpZiAoYXRuU3RhcnRTdGF0ZSBpbnN0YW5jZW9mIFN0YXJMb29wRW50cnlTdGF0ZV8xLlN0YXJMb29wRW50cnlTdGF0ZSkge1xuICAgICAgICBpZiAoYXRuU3RhcnRTdGF0ZS5wcmVjZWRlbmNlUnVsZURlY2lzaW9uKSB7XG4gICAgICAgICAgaXNQcmVjZWRlbmNlRGZhID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnMwID0gbmV3IERGQVN0YXRlXzEuREZBU3RhdGUobmV3IEFUTkNvbmZpZ1NldF8xLkFUTkNvbmZpZ1NldCgpKTtcbiAgICAgICAgICB0aGlzLnMwZnVsbCA9IG5ldyBERkFTdGF0ZV8xLkRGQVN0YXRlKG5ldyBBVE5Db25maWdTZXRfMS5BVE5Db25maWdTZXQoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucHJlY2VkZW5jZURmYSA9IGlzUHJlY2VkZW5jZURmYTtcbiAgICB9XG4gICAgZ2V0IGlzUHJlY2VkZW5jZURmYSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWNlZGVuY2VEZmE7XG4gICAgfVxuICAgIGdldFByZWNlZGVuY2VTdGFydFN0YXRlKHByZWNlZGVuY2UsIGZ1bGxDb250ZXh0KSB7XG4gICAgICBpZiAoIXRoaXMuaXNQcmVjZWRlbmNlRGZhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgcHJlY2VkZW5jZSBERkFzIG1heSBjb250YWluIGEgcHJlY2VkZW5jZSBzdGFydCBzdGF0ZS5cIik7XG4gICAgICB9XG4gICAgICBpZiAoZnVsbENvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuczBmdWxsLmdldFRhcmdldChwcmVjZWRlbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnMwLmdldFRhcmdldChwcmVjZWRlbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0UHJlY2VkZW5jZVN0YXJ0U3RhdGUocHJlY2VkZW5jZSwgZnVsbENvbnRleHQsIHN0YXJ0U3RhdGUpIHtcbiAgICAgIGlmICghdGhpcy5pc1ByZWNlZGVuY2VEZmEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBwcmVjZWRlbmNlIERGQXMgbWF5IGNvbnRhaW4gYSBwcmVjZWRlbmNlIHN0YXJ0IHN0YXRlLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVjZWRlbmNlIDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZnVsbENvbnRleHQpIHtcbiAgICAgICAgdGhpcy5zMGZ1bGwuc2V0VGFyZ2V0KHByZWNlZGVuY2UsIHN0YXJ0U3RhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zMC5zZXRUYXJnZXQocHJlY2VkZW5jZSwgc3RhcnRTdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgaWYgKHRoaXMuaXNQcmVjZWRlbmNlRGZhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnMwLmdldEVkZ2VNYXAoKS5zaXplID09PSAwICYmIHRoaXMuczBmdWxsLmdldEVkZ2VNYXAoKS5zaXplID09PSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuczAgPT0gbnVsbCAmJiB0aGlzLnMwZnVsbCA9PSBudWxsO1xuICAgIH1cbiAgICBnZXQgaXNDb250ZXh0U2Vuc2l0aXZlKCkge1xuICAgICAgaWYgKHRoaXMuaXNQcmVjZWRlbmNlRGZhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnMwZnVsbC5nZXRFZGdlTWFwKCkuc2l6ZSA+IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zMGZ1bGwgIT0gbnVsbDtcbiAgICB9XG4gICAgYWRkU3RhdGUoc3RhdGUpIHtcbiAgICAgIHN0YXRlLnN0YXRlTnVtYmVyID0gdGhpcy5uZXh0U3RhdGVOdW1iZXIrKztcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlcy5nZXRPckFkZChzdGF0ZSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKHZvY2FidWxhcnksIHJ1bGVOYW1lcykge1xuICAgICAgaWYgKCF2b2NhYnVsYXJ5KSB7XG4gICAgICAgIHZvY2FidWxhcnkgPSBWb2NhYnVsYXJ5SW1wbF8xLlZvY2FidWxhcnlJbXBsLkVNUFRZX1ZPQ0FCVUxBUlk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuczApIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBsZXQgc2VyaWFsaXplcjtcbiAgICAgIGlmIChydWxlTmFtZXMpIHtcbiAgICAgICAgc2VyaWFsaXplciA9IG5ldyBERkFTZXJpYWxpemVyXzEuREZBU2VyaWFsaXplcih0aGlzLCB2b2NhYnVsYXJ5LCBydWxlTmFtZXMsIHRoaXMuYXRuU3RhcnRTdGF0ZS5hdG4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VyaWFsaXplciA9IG5ldyBERkFTZXJpYWxpemVyXzEuREZBU2VyaWFsaXplcih0aGlzLCB2b2NhYnVsYXJ5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXJpYWxpemVyLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRvTGV4ZXJTdHJpbmcoKSB7XG4gICAgICBpZiAoIXRoaXMuczApIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBsZXQgc2VyaWFsaXplciA9IG5ldyBMZXhlckRGQVNlcmlhbGl6ZXJfMS5MZXhlckRGQVNlcmlhbGl6ZXIodGhpcyk7XG4gICAgICByZXR1cm4gc2VyaWFsaXplci50b1N0cmluZygpO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgREZBLnByb3RvdHlwZSwgXCJzdGF0ZXNcIiwgdm9pZCAwKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgREZBLnByb3RvdHlwZSwgXCJhdG5TdGFydFN0YXRlXCIsIHZvaWQgMCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIERGQS5wcm90b3R5cGUsIFwiYXRuXCIsIHZvaWQgMCk7XG4gIERGQSA9IF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIERGQSk7XG4gIGV4cG9ydHMuREZBID0gREZBO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9hdG4vQmFzaWNTdGF0ZS5qc1xudmFyIHJlcXVpcmVfQmFzaWNTdGF0ZSA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5CYXNpY1N0YXRlID0gdm9pZCAwO1xuICB2YXIgQVROU3RhdGVfMSA9IHJlcXVpcmVfQVROU3RhdGUoKTtcbiAgdmFyIEFUTlN0YXRlVHlwZV8xID0gcmVxdWlyZV9BVE5TdGF0ZVR5cGUoKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgQmFzaWNTdGF0ZSA9IGNsYXNzIGV4dGVuZHMgQVROU3RhdGVfMS5BVE5TdGF0ZSB7XG4gICAgZ2V0IHN0YXRlVHlwZSgpIHtcbiAgICAgIHJldHVybiBBVE5TdGF0ZVR5cGVfMS5BVE5TdGF0ZVR5cGUuQkFTSUM7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQmFzaWNTdGF0ZS5wcm90b3R5cGUsIFwic3RhdGVUeXBlXCIsIG51bGwpO1xuICBleHBvcnRzLkJhc2ljU3RhdGUgPSBCYXNpY1N0YXRlO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9hdG4vSW52YWxpZFN0YXRlLmpzXG52YXIgcmVxdWlyZV9JbnZhbGlkU3RhdGUgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuSW52YWxpZFN0YXRlID0gdm9pZCAwO1xuICB2YXIgQVROU3RhdGVUeXBlXzEgPSByZXF1aXJlX0FUTlN0YXRlVHlwZSgpO1xuICB2YXIgQmFzaWNTdGF0ZV8xID0gcmVxdWlyZV9CYXNpY1N0YXRlKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIEludmFsaWRTdGF0ZSA9IGNsYXNzIGV4dGVuZHMgQmFzaWNTdGF0ZV8xLkJhc2ljU3RhdGUge1xuICAgIGdldCBzdGF0ZVR5cGUoKSB7XG4gICAgICByZXR1cm4gQVROU3RhdGVUeXBlXzEuQVROU3RhdGVUeXBlLklOVkFMSURfVFlQRTtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBJbnZhbGlkU3RhdGUucHJvdG90eXBlLCBcInN0YXRlVHlwZVwiLCBudWxsKTtcbiAgZXhwb3J0cy5JbnZhbGlkU3RhdGUgPSBJbnZhbGlkU3RhdGU7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9TZXRUcmFuc2l0aW9uLmpzXG52YXIgcmVxdWlyZV9TZXRUcmFuc2l0aW9uID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLlNldFRyYW5zaXRpb24gPSB2b2lkIDA7XG4gIHZhciBJbnRlcnZhbFNldF8xID0gcmVxdWlyZV9JbnRlcnZhbFNldCgpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBUb2tlbl8xID0gcmVxdWlyZV9Ub2tlbigpO1xuICB2YXIgVHJhbnNpdGlvbl8xID0gcmVxdWlyZV9UcmFuc2l0aW9uKCk7XG4gIHZhciBTZXRUcmFuc2l0aW9uID0gY2xhc3MgU2V0VHJhbnNpdGlvbiBleHRlbmRzIFRyYW5zaXRpb25fMS5UcmFuc2l0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIHNldCkge1xuICAgICAgc3VwZXIodGFyZ2V0KTtcbiAgICAgIGlmIChzZXQgPT0gbnVsbCkge1xuICAgICAgICBzZXQgPSBJbnRlcnZhbFNldF8xLkludGVydmFsU2V0Lm9mKFRva2VuXzEuVG9rZW4uSU5WQUxJRF9UWVBFKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgIH1cbiAgICBnZXQgc2VyaWFsaXphdGlvblR5cGUoKSB7XG4gICAgICByZXR1cm4gNztcbiAgICB9XG4gICAgZ2V0IGxhYmVsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0O1xuICAgIH1cbiAgICBtYXRjaGVzKHN5bWJvbCwgbWluVm9jYWJTeW1ib2wsIG1heFZvY2FiU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXQuY29udGFpbnMoc3ltYm9sKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXQudG9TdHJpbmcoKTtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIFNldFRyYW5zaXRpb24ucHJvdG90eXBlLCBcInNldFwiLCB2b2lkIDApO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgU2V0VHJhbnNpdGlvbi5wcm90b3R5cGUsIFwic2VyaWFsaXphdGlvblR5cGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZSxcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBTZXRUcmFuc2l0aW9uLnByb3RvdHlwZSwgXCJsYWJlbFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFNldFRyYW5zaXRpb24ucHJvdG90eXBlLCBcIm1hdGNoZXNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZSxcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBTZXRUcmFuc2l0aW9uLnByb3RvdHlwZSwgXCJ0b1N0cmluZ1wiLCBudWxsKTtcbiAgU2V0VHJhbnNpdGlvbiA9IF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMSwgRGVjb3JhdG9yc18xLk51bGxhYmxlKVxuICBdLCBTZXRUcmFuc2l0aW9uKTtcbiAgZXhwb3J0cy5TZXRUcmFuc2l0aW9uID0gU2V0VHJhbnNpdGlvbjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvYXRuL05vdFNldFRyYW5zaXRpb24uanNcbnZhciByZXF1aXJlX05vdFNldFRyYW5zaXRpb24gPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuTm90U2V0VHJhbnNpdGlvbiA9IHZvaWQgMDtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgU2V0VHJhbnNpdGlvbl8xID0gcmVxdWlyZV9TZXRUcmFuc2l0aW9uKCk7XG4gIHZhciBOb3RTZXRUcmFuc2l0aW9uID0gY2xhc3MgTm90U2V0VHJhbnNpdGlvbiBleHRlbmRzIFNldFRyYW5zaXRpb25fMS5TZXRUcmFuc2l0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIHNldCkge1xuICAgICAgc3VwZXIodGFyZ2V0LCBzZXQpO1xuICAgIH1cbiAgICBnZXQgc2VyaWFsaXphdGlvblR5cGUoKSB7XG4gICAgICByZXR1cm4gODtcbiAgICB9XG4gICAgbWF0Y2hlcyhzeW1ib2wsIG1pblZvY2FiU3ltYm9sLCBtYXhWb2NhYlN5bWJvbCkge1xuICAgICAgcmV0dXJuIHN5bWJvbCA+PSBtaW5Wb2NhYlN5bWJvbCAmJiBzeW1ib2wgPD0gbWF4Vm9jYWJTeW1ib2wgJiYgIXN1cGVyLm1hdGNoZXMoc3ltYm9sLCBtaW5Wb2NhYlN5bWJvbCwgbWF4Vm9jYWJTeW1ib2wpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIn5cIiArIHN1cGVyLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTm90U2V0VHJhbnNpdGlvbi5wcm90b3R5cGUsIFwic2VyaWFsaXphdGlvblR5cGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBOb3RTZXRUcmFuc2l0aW9uLnByb3RvdHlwZSwgXCJtYXRjaGVzXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTm90U2V0VHJhbnNpdGlvbi5wcm90b3R5cGUsIFwidG9TdHJpbmdcIiwgbnVsbCk7XG4gIE5vdFNldFRyYW5zaXRpb24gPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDEsIERlY29yYXRvcnNfMS5OdWxsYWJsZSlcbiAgXSwgTm90U2V0VHJhbnNpdGlvbik7XG4gIGV4cG9ydHMuTm90U2V0VHJhbnNpdGlvbiA9IE5vdFNldFRyYW5zaXRpb247XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9SdWxlU3RvcFN0YXRlLmpzXG52YXIgcmVxdWlyZV9SdWxlU3RvcFN0YXRlID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLlJ1bGVTdG9wU3RhdGUgPSB2b2lkIDA7XG4gIHZhciBBVE5TdGF0ZV8xID0gcmVxdWlyZV9BVE5TdGF0ZSgpO1xuICB2YXIgQVROU3RhdGVUeXBlXzEgPSByZXF1aXJlX0FUTlN0YXRlVHlwZSgpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBSdWxlU3RvcFN0YXRlID0gY2xhc3MgZXh0ZW5kcyBBVE5TdGF0ZV8xLkFUTlN0YXRlIHtcbiAgICBnZXQgbm9uU3RvcFN0YXRlTnVtYmVyKCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBnZXQgc3RhdGVUeXBlKCkge1xuICAgICAgcmV0dXJuIEFUTlN0YXRlVHlwZV8xLkFUTlN0YXRlVHlwZS5SVUxFX1NUT1A7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgUnVsZVN0b3BTdGF0ZS5wcm90b3R5cGUsIFwibm9uU3RvcFN0YXRlTnVtYmVyXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgUnVsZVN0b3BTdGF0ZS5wcm90b3R5cGUsIFwic3RhdGVUeXBlXCIsIG51bGwpO1xuICBleHBvcnRzLlJ1bGVTdG9wU3RhdGUgPSBSdWxlU3RvcFN0YXRlO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9hdG4vUnVsZVRyYW5zaXRpb24uanNcbnZhciByZXF1aXJlX1J1bGVUcmFuc2l0aW9uID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLlJ1bGVUcmFuc2l0aW9uID0gdm9pZCAwO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBUcmFuc2l0aW9uXzEgPSByZXF1aXJlX1RyYW5zaXRpb24oKTtcbiAgdmFyIFJ1bGVUcmFuc2l0aW9uID0gY2xhc3MgUnVsZVRyYW5zaXRpb24gZXh0ZW5kcyBUcmFuc2l0aW9uXzEuVHJhbnNpdGlvbiB7XG4gICAgY29uc3RydWN0b3IocnVsZVN0YXJ0LCBydWxlSW5kZXgsIHByZWNlZGVuY2UsIGZvbGxvd1N0YXRlKSB7XG4gICAgICBzdXBlcihydWxlU3RhcnQpO1xuICAgICAgdGhpcy50YWlsQ2FsbCA9IGZhbHNlO1xuICAgICAgdGhpcy5vcHRpbWl6ZWRUYWlsQ2FsbCA9IGZhbHNlO1xuICAgICAgdGhpcy5ydWxlSW5kZXggPSBydWxlSW5kZXg7XG4gICAgICB0aGlzLnByZWNlZGVuY2UgPSBwcmVjZWRlbmNlO1xuICAgICAgdGhpcy5mb2xsb3dTdGF0ZSA9IGZvbGxvd1N0YXRlO1xuICAgIH1cbiAgICBnZXQgc2VyaWFsaXphdGlvblR5cGUoKSB7XG4gICAgICByZXR1cm4gMztcbiAgICB9XG4gICAgZ2V0IGlzRXBzaWxvbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtYXRjaGVzKHN5bWJvbCwgbWluVm9jYWJTeW1ib2wsIG1heFZvY2FiU3ltYm9sKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBSdWxlVHJhbnNpdGlvbi5wcm90b3R5cGUsIFwiZm9sbG93U3RhdGVcIiwgdm9pZCAwKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFJ1bGVUcmFuc2l0aW9uLnByb3RvdHlwZSwgXCJzZXJpYWxpemF0aW9uVHlwZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFJ1bGVUcmFuc2l0aW9uLnByb3RvdHlwZSwgXCJpc0Vwc2lsb25cIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBSdWxlVHJhbnNpdGlvbi5wcm90b3R5cGUsIFwibWF0Y2hlc1wiLCBudWxsKTtcbiAgUnVsZVRyYW5zaXRpb24gPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDMsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBSdWxlVHJhbnNpdGlvbik7XG4gIGV4cG9ydHMuUnVsZVRyYW5zaXRpb24gPSBSdWxlVHJhbnNpdGlvbjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvYXRuL1dpbGRjYXJkVHJhbnNpdGlvbi5qc1xudmFyIHJlcXVpcmVfV2lsZGNhcmRUcmFuc2l0aW9uID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLldpbGRjYXJkVHJhbnNpdGlvbiA9IHZvaWQgMDtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgVHJhbnNpdGlvbl8xID0gcmVxdWlyZV9UcmFuc2l0aW9uKCk7XG4gIHZhciBXaWxkY2FyZFRyYW5zaXRpb24gPSBjbGFzcyBXaWxkY2FyZFRyYW5zaXRpb24gZXh0ZW5kcyBUcmFuc2l0aW9uXzEuVHJhbnNpdGlvbiB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgICBzdXBlcih0YXJnZXQpO1xuICAgIH1cbiAgICBnZXQgc2VyaWFsaXphdGlvblR5cGUoKSB7XG4gICAgICByZXR1cm4gOTtcbiAgICB9XG4gICAgbWF0Y2hlcyhzeW1ib2wsIG1pblZvY2FiU3ltYm9sLCBtYXhWb2NhYlN5bWJvbCkge1xuICAgICAgcmV0dXJuIHN5bWJvbCA+PSBtaW5Wb2NhYlN5bWJvbCAmJiBzeW1ib2wgPD0gbWF4Vm9jYWJTeW1ib2w7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwiLlwiO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFdpbGRjYXJkVHJhbnNpdGlvbi5wcm90b3R5cGUsIFwic2VyaWFsaXphdGlvblR5cGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBXaWxkY2FyZFRyYW5zaXRpb24ucHJvdG90eXBlLCBcIm1hdGNoZXNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZSxcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBXaWxkY2FyZFRyYW5zaXRpb24ucHJvdG90eXBlLCBcInRvU3RyaW5nXCIsIG51bGwpO1xuICBXaWxkY2FyZFRyYW5zaXRpb24gPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBXaWxkY2FyZFRyYW5zaXRpb24pO1xuICBleHBvcnRzLldpbGRjYXJkVHJhbnNpdGlvbiA9IFdpbGRjYXJkVHJhbnNpdGlvbjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvYXRuL0xMMUFuYWx5emVyLmpzXG52YXIgcmVxdWlyZV9MTDFBbmFseXplciA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgdmFyIF9fcGFyYW0gPSBleHBvcnRzICYmIGV4cG9ydHMuX19wYXJhbSB8fCBmdW5jdGlvbihwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7XG4gICAgfTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5MTDFBbmFseXplciA9IHZvaWQgMDtcbiAgdmFyIEFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbl8xID0gcmVxdWlyZV9BYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb24oKTtcbiAgdmFyIEFycmF5MkRIYXNoU2V0XzEgPSByZXF1aXJlX0FycmF5MkRIYXNoU2V0KCk7XG4gIHZhciBBVE5Db25maWdfMSA9IHJlcXVpcmVfQVROQ29uZmlnKCk7XG4gIHZhciBCaXRTZXRfMSA9IHJlcXVpcmVfQml0U2V0KCk7XG4gIHZhciBJbnRlcnZhbFNldF8xID0gcmVxdWlyZV9JbnRlcnZhbFNldCgpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBOb3RTZXRUcmFuc2l0aW9uXzEgPSByZXF1aXJlX05vdFNldFRyYW5zaXRpb24oKTtcbiAgdmFyIE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvcl8xID0gcmVxdWlyZV9PYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IoKTtcbiAgdmFyIFByZWRpY3Rpb25Db250ZXh0XzEgPSByZXF1aXJlX1ByZWRpY3Rpb25Db250ZXh0KCk7XG4gIHZhciBSdWxlU3RvcFN0YXRlXzEgPSByZXF1aXJlX1J1bGVTdG9wU3RhdGUoKTtcbiAgdmFyIFJ1bGVUcmFuc2l0aW9uXzEgPSByZXF1aXJlX1J1bGVUcmFuc2l0aW9uKCk7XG4gIHZhciBUb2tlbl8xID0gcmVxdWlyZV9Ub2tlbigpO1xuICB2YXIgV2lsZGNhcmRUcmFuc2l0aW9uXzEgPSByZXF1aXJlX1dpbGRjYXJkVHJhbnNpdGlvbigpO1xuICB2YXIgTEwxQW5hbHl6ZXIgPSBjbGFzcyBMTDFBbmFseXplcjIge1xuICAgIGNvbnN0cnVjdG9yKGF0bikge1xuICAgICAgdGhpcy5hdG4gPSBhdG47XG4gICAgfVxuICAgIGdldERlY2lzaW9uTG9va2FoZWFkKHMpIHtcbiAgICAgIGlmIChzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGxldCBsb29rID0gbmV3IEFycmF5KHMubnVtYmVyT2ZUcmFuc2l0aW9ucyk7XG4gICAgICBmb3IgKGxldCBhbHQgPSAwOyBhbHQgPCBzLm51bWJlck9mVHJhbnNpdGlvbnM7IGFsdCsrKSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gbmV3IEludGVydmFsU2V0XzEuSW50ZXJ2YWxTZXQoKTtcbiAgICAgICAgbG9va1thbHRdID0gY3VycmVudDtcbiAgICAgICAgbGV0IGxvb2tCdXN5ID0gbmV3IEFycmF5MkRIYXNoU2V0XzEuQXJyYXkyREhhc2hTZXQoT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yXzEuT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFKTtcbiAgICAgICAgbGV0IHNlZVRocnVQcmVkcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9MT09LKHMudHJhbnNpdGlvbihhbHQpLnRhcmdldCwgdm9pZCAwLCBQcmVkaWN0aW9uQ29udGV4dF8xLlByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0xPQ0FMLCBjdXJyZW50LCBsb29rQnVzeSwgbmV3IEJpdFNldF8xLkJpdFNldCgpLCBzZWVUaHJ1UHJlZHMsIGZhbHNlKTtcbiAgICAgICAgaWYgKGN1cnJlbnQuc2l6ZSA9PT0gMCB8fCBjdXJyZW50LmNvbnRhaW5zKExMMUFuYWx5emVyMi5ISVRfUFJFRCkpIHtcbiAgICAgICAgICBjdXJyZW50ID0gdm9pZCAwO1xuICAgICAgICAgIGxvb2tbYWx0XSA9IGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsb29rO1xuICAgIH1cbiAgICBMT09LKHMsIGN0eCwgc3RvcFN0YXRlKSB7XG4gICAgICBpZiAoc3RvcFN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKHMuYXRuID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3BTdGF0ZSA9IHMuYXRuLnJ1bGVUb1N0b3BTdGF0ZVtzLnJ1bGVJbmRleF07XG4gICAgICB9IGVsc2UgaWYgKHN0b3BTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICBzdG9wU3RhdGUgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICBsZXQgciA9IG5ldyBJbnRlcnZhbFNldF8xLkludGVydmFsU2V0KCk7XG4gICAgICBsZXQgc2VlVGhydVByZWRzID0gdHJ1ZTtcbiAgICAgIGxldCBhZGRFT0YgPSB0cnVlO1xuICAgICAgdGhpcy5fTE9PSyhzLCBzdG9wU3RhdGUsIGN0eCwgciwgbmV3IEFycmF5MkRIYXNoU2V0XzEuQXJyYXkyREhhc2hTZXQoKSwgbmV3IEJpdFNldF8xLkJpdFNldCgpLCBzZWVUaHJ1UHJlZHMsIGFkZEVPRik7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgX0xPT0socywgc3RvcFN0YXRlLCBjdHgsIGxvb2ssIGxvb2tCdXN5LCBjYWxsZWRSdWxlU3RhY2ssIHNlZVRocnVQcmVkcywgYWRkRU9GKSB7XG4gICAgICBsZXQgYyA9IEFUTkNvbmZpZ18xLkFUTkNvbmZpZy5jcmVhdGUocywgMCwgY3R4KTtcbiAgICAgIGlmICghbG9va0J1c3kuYWRkKGMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzID09PSBzdG9wU3RhdGUpIHtcbiAgICAgICAgaWYgKFByZWRpY3Rpb25Db250ZXh0XzEuUHJlZGljdGlvbkNvbnRleHQuaXNFbXB0eUxvY2FsKGN0eCkpIHtcbiAgICAgICAgICBsb29rLmFkZChUb2tlbl8xLlRva2VuLkVQU0lMT04pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChjdHguaXNFbXB0eSkge1xuICAgICAgICAgIGlmIChhZGRFT0YpIHtcbiAgICAgICAgICAgIGxvb2suYWRkKFRva2VuXzEuVG9rZW4uRU9GKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocyBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGVfMS5SdWxlU3RvcFN0YXRlKSB7XG4gICAgICAgIGlmIChjdHguaXNFbXB0eSAmJiAhUHJlZGljdGlvbkNvbnRleHRfMS5QcmVkaWN0aW9uQ29udGV4dC5pc0VtcHR5TG9jYWwoY3R4KSkge1xuICAgICAgICAgIGlmIChhZGRFT0YpIHtcbiAgICAgICAgICAgIGxvb2suYWRkKFRva2VuXzEuVG9rZW4uRU9GKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZW1vdmVkID0gY2FsbGVkUnVsZVN0YWNrLmdldChzLnJ1bGVJbmRleCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2FsbGVkUnVsZVN0YWNrLmNsZWFyKHMucnVsZUluZGV4KTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN0eC5zaXplOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjdHguZ2V0UmV0dXJuU3RhdGUoaSkgPT09IFByZWRpY3Rpb25Db250ZXh0XzEuUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTF9TVEFURV9LRVkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmV0dXJuU3RhdGUgPSB0aGlzLmF0bi5zdGF0ZXNbY3R4LmdldFJldHVyblN0YXRlKGkpXTtcbiAgICAgICAgICAgIHRoaXMuX0xPT0socmV0dXJuU3RhdGUsIHN0b3BTdGF0ZSwgY3R4LmdldFBhcmVudChpKSwgbG9vaywgbG9va0J1c3ksIGNhbGxlZFJ1bGVTdGFjaywgc2VlVGhydVByZWRzLCBhZGRFT0YpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgICAgY2FsbGVkUnVsZVN0YWNrLnNldChzLnJ1bGVJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgbiA9IHMubnVtYmVyT2ZUcmFuc2l0aW9ucztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGxldCB0ID0gcy50cmFuc2l0aW9uKGkpO1xuICAgICAgICBpZiAodCBpbnN0YW5jZW9mIFJ1bGVUcmFuc2l0aW9uXzEuUnVsZVRyYW5zaXRpb24pIHtcbiAgICAgICAgICBpZiAoY2FsbGVkUnVsZVN0YWNrLmdldCh0LnJ1bGVJbmRleCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgbmV3Q29udGV4dCA9IGN0eC5nZXRDaGlsZCh0LmZvbGxvd1N0YXRlLnN0YXRlTnVtYmVyKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2FsbGVkUnVsZVN0YWNrLnNldCh0LnJ1bGVJbmRleCk7XG4gICAgICAgICAgICB0aGlzLl9MT09LKHQudGFyZ2V0LCBzdG9wU3RhdGUsIG5ld0NvbnRleHQsIGxvb2ssIGxvb2tCdXN5LCBjYWxsZWRSdWxlU3RhY2ssIHNlZVRocnVQcmVkcywgYWRkRU9GKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgY2FsbGVkUnVsZVN0YWNrLmNsZWFyKHQucnVsZUluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodCBpbnN0YW5jZW9mIEFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbl8xLkFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbikge1xuICAgICAgICAgIGlmIChzZWVUaHJ1UHJlZHMpIHtcbiAgICAgICAgICAgIHRoaXMuX0xPT0sodC50YXJnZXQsIHN0b3BTdGF0ZSwgY3R4LCBsb29rLCBsb29rQnVzeSwgY2FsbGVkUnVsZVN0YWNrLCBzZWVUaHJ1UHJlZHMsIGFkZEVPRik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvb2suYWRkKExMMUFuYWx5emVyMi5ISVRfUFJFRCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHQuaXNFcHNpbG9uKSB7XG4gICAgICAgICAgdGhpcy5fTE9PSyh0LnRhcmdldCwgc3RvcFN0YXRlLCBjdHgsIGxvb2ssIGxvb2tCdXN5LCBjYWxsZWRSdWxlU3RhY2ssIHNlZVRocnVQcmVkcywgYWRkRU9GKTtcbiAgICAgICAgfSBlbHNlIGlmICh0IGluc3RhbmNlb2YgV2lsZGNhcmRUcmFuc2l0aW9uXzEuV2lsZGNhcmRUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgbG9vay5hZGRBbGwoSW50ZXJ2YWxTZXRfMS5JbnRlcnZhbFNldC5vZihUb2tlbl8xLlRva2VuLk1JTl9VU0VSX1RPS0VOX1RZUEUsIHRoaXMuYXRuLm1heFRva2VuVHlwZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBzZXQgPSB0LmxhYmVsO1xuICAgICAgICAgIGlmIChzZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiBOb3RTZXRUcmFuc2l0aW9uXzEuTm90U2V0VHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICBzZXQgPSBzZXQuY29tcGxlbWVudChJbnRlcnZhbFNldF8xLkludGVydmFsU2V0Lm9mKFRva2VuXzEuVG9rZW4uTUlOX1VTRVJfVE9LRU5fVFlQRSwgdGhpcy5hdG4ubWF4VG9rZW5UeXBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb29rLmFkZEFsbChzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgTEwxQW5hbHl6ZXIuSElUX1BSRUQgPSBUb2tlbl8xLlRva2VuLklOVkFMSURfVFlQRTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgTEwxQW5hbHl6ZXIucHJvdG90eXBlLCBcImF0blwiLCB2b2lkIDApO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbCxcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDEsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBMTDFBbmFseXplci5wcm90b3R5cGUsIFwiTE9PS1wiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgyLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgzLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSg0LCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSg1LCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgTEwxQW5hbHl6ZXIucHJvdG90eXBlLCBcIl9MT09LXCIsIG51bGwpO1xuICBMTDFBbmFseXplciA9IF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIExMMUFuYWx5emVyKTtcbiAgZXhwb3J0cy5MTDFBbmFseXplciA9IExMMUFuYWx5emVyO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9hdG4vQVROLmpzXG52YXIgcmVxdWlyZV9BVE4gPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuQVROID0gdm9pZCAwO1xuICB2YXIgQXJyYXkyREhhc2hNYXBfMSA9IHJlcXVpcmVfQXJyYXkyREhhc2hNYXAoKTtcbiAgdmFyIERGQV8xID0gcmVxdWlyZV9ERkEoKTtcbiAgdmFyIEludGVydmFsU2V0XzEgPSByZXF1aXJlX0ludGVydmFsU2V0KCk7XG4gIHZhciBJbnZhbGlkU3RhdGVfMSA9IHJlcXVpcmVfSW52YWxpZFN0YXRlKCk7XG4gIHZhciBMTDFBbmFseXplcl8xID0gcmVxdWlyZV9MTDFBbmFseXplcigpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3JfMSA9IHJlcXVpcmVfT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yKCk7XG4gIHZhciBQcmVkaWN0aW9uQ29udGV4dF8xID0gcmVxdWlyZV9QcmVkaWN0aW9uQ29udGV4dCgpO1xuICB2YXIgVG9rZW5fMSA9IHJlcXVpcmVfVG9rZW4oKTtcbiAgdmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG4gIHZhciBBVE4yID0gY2xhc3MgQVROIHtcbiAgICBjb25zdHJ1Y3RvcihncmFtbWFyVHlwZSwgbWF4VG9rZW5UeXBlKSB7XG4gICAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgICAgdGhpcy5kZWNpc2lvblRvU3RhdGUgPSBbXTtcbiAgICAgIHRoaXMubW9kZU5hbWVUb1N0YXJ0U3RhdGUgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLm1vZGVUb1N0YXJ0U3RhdGUgPSBbXTtcbiAgICAgIHRoaXMuY29udGV4dENhY2hlID0gbmV3IEFycmF5MkRIYXNoTWFwXzEuQXJyYXkyREhhc2hNYXAoT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yXzEuT2JqZWN0RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFKTtcbiAgICAgIHRoaXMuZGVjaXNpb25Ub0RGQSA9IFtdO1xuICAgICAgdGhpcy5tb2RlVG9ERkEgPSBbXTtcbiAgICAgIHRoaXMuTEwxVGFibGUgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLmdyYW1tYXJUeXBlID0gZ3JhbW1hclR5cGU7XG4gICAgICB0aGlzLm1heFRva2VuVHlwZSA9IG1heFRva2VuVHlwZTtcbiAgICB9XG4gICAgY2xlYXJERkEoKSB7XG4gICAgICB0aGlzLmRlY2lzaW9uVG9ERkEgPSBuZXcgQXJyYXkodGhpcy5kZWNpc2lvblRvU3RhdGUubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kZWNpc2lvblRvREZBLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZGVjaXNpb25Ub0RGQVtpXSA9IG5ldyBERkFfMS5ERkEodGhpcy5kZWNpc2lvblRvU3RhdGVbaV0sIGkpO1xuICAgICAgfVxuICAgICAgdGhpcy5tb2RlVG9ERkEgPSBuZXcgQXJyYXkodGhpcy5tb2RlVG9TdGFydFN0YXRlLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubW9kZVRvREZBLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMubW9kZVRvREZBW2ldID0gbmV3IERGQV8xLkRGQSh0aGlzLm1vZGVUb1N0YXJ0U3RhdGVbaV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5jb250ZXh0Q2FjaGUuY2xlYXIoKTtcbiAgICAgIHRoaXMuTEwxVGFibGUuY2xlYXIoKTtcbiAgICB9XG4gICAgZ2V0IGNvbnRleHRDYWNoZVNpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0Q2FjaGUuc2l6ZTtcbiAgICB9XG4gICAgZ2V0Q2FjaGVkQ29udGV4dChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gUHJlZGljdGlvbkNvbnRleHRfMS5QcmVkaWN0aW9uQ29udGV4dC5nZXRDYWNoZWRDb250ZXh0KGNvbnRleHQsIHRoaXMuY29udGV4dENhY2hlLCBuZXcgUHJlZGljdGlvbkNvbnRleHRfMS5QcmVkaWN0aW9uQ29udGV4dC5JZGVudGl0eUhhc2hNYXAoKSk7XG4gICAgfVxuICAgIGdldERlY2lzaW9uVG9ERkEoKSB7XG4gICAgICBhc3NlcnQodGhpcy5kZWNpc2lvblRvREZBICE9IG51bGwgJiYgdGhpcy5kZWNpc2lvblRvREZBLmxlbmd0aCA9PT0gdGhpcy5kZWNpc2lvblRvU3RhdGUubGVuZ3RoKTtcbiAgICAgIHJldHVybiB0aGlzLmRlY2lzaW9uVG9ERkE7XG4gICAgfVxuICAgIG5leHRUb2tlbnMocywgY3R4KSB7XG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIGxldCBhbmFsID0gbmV3IExMMUFuYWx5emVyXzEuTEwxQW5hbHl6ZXIodGhpcyk7XG4gICAgICAgIGxldCBuZXh0ID0gYW5hbC5MT09LKHMsIGN0eCk7XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHMubmV4dFRva2VuV2l0aGluUnVsZSkge1xuICAgICAgICAgIHJldHVybiBzLm5leHRUb2tlbldpdGhpblJ1bGU7XG4gICAgICAgIH1cbiAgICAgICAgcy5uZXh0VG9rZW5XaXRoaW5SdWxlID0gdGhpcy5uZXh0VG9rZW5zKHMsIFByZWRpY3Rpb25Db250ZXh0XzEuUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfTE9DQUwpO1xuICAgICAgICBzLm5leHRUb2tlbldpdGhpblJ1bGUuc2V0UmVhZG9ubHkodHJ1ZSk7XG4gICAgICAgIHJldHVybiBzLm5leHRUb2tlbldpdGhpblJ1bGU7XG4gICAgICB9XG4gICAgfVxuICAgIGFkZFN0YXRlKHN0YXRlKSB7XG4gICAgICBzdGF0ZS5hdG4gPSB0aGlzO1xuICAgICAgc3RhdGUuc3RhdGVOdW1iZXIgPSB0aGlzLnN0YXRlcy5sZW5ndGg7XG4gICAgICB0aGlzLnN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICB9XG4gICAgcmVtb3ZlU3RhdGUoc3RhdGUpIHtcbiAgICAgIGxldCBpbnZhbGlkU3RhdGUgPSBuZXcgSW52YWxpZFN0YXRlXzEuSW52YWxpZFN0YXRlKCk7XG4gICAgICBpbnZhbGlkU3RhdGUuYXRuID0gdGhpcztcbiAgICAgIGludmFsaWRTdGF0ZS5zdGF0ZU51bWJlciA9IHN0YXRlLnN0YXRlTnVtYmVyO1xuICAgICAgdGhpcy5zdGF0ZXNbc3RhdGUuc3RhdGVOdW1iZXJdID0gaW52YWxpZFN0YXRlO1xuICAgIH1cbiAgICBkZWZpbmVNb2RlKG5hbWUsIHMpIHtcbiAgICAgIHRoaXMubW9kZU5hbWVUb1N0YXJ0U3RhdGUuc2V0KG5hbWUsIHMpO1xuICAgICAgdGhpcy5tb2RlVG9TdGFydFN0YXRlLnB1c2gocyk7XG4gICAgICB0aGlzLm1vZGVUb0RGQS5wdXNoKG5ldyBERkFfMS5ERkEocykpO1xuICAgICAgdGhpcy5kZWZpbmVEZWNpc2lvblN0YXRlKHMpO1xuICAgIH1cbiAgICBkZWZpbmVEZWNpc2lvblN0YXRlKHMpIHtcbiAgICAgIHRoaXMuZGVjaXNpb25Ub1N0YXRlLnB1c2gocyk7XG4gICAgICBzLmRlY2lzaW9uID0gdGhpcy5kZWNpc2lvblRvU3RhdGUubGVuZ3RoIC0gMTtcbiAgICAgIHRoaXMuZGVjaXNpb25Ub0RGQS5wdXNoKG5ldyBERkFfMS5ERkEocywgcy5kZWNpc2lvbikpO1xuICAgICAgcmV0dXJuIHMuZGVjaXNpb247XG4gICAgfVxuICAgIGdldERlY2lzaW9uU3RhdGUoZGVjaXNpb24pIHtcbiAgICAgIGlmICh0aGlzLmRlY2lzaW9uVG9TdGF0ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY2lzaW9uVG9TdGF0ZVtkZWNpc2lvbl07XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBnZXQgbnVtYmVyT2ZEZWNpc2lvbnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNpc2lvblRvU3RhdGUubGVuZ3RoO1xuICAgIH1cbiAgICBnZXRFeHBlY3RlZFRva2VucyhzdGF0ZU51bWJlciwgY29udGV4dCkge1xuICAgICAgaWYgKHN0YXRlTnVtYmVyIDwgMCB8fCBzdGF0ZU51bWJlciA+PSB0aGlzLnN0YXRlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHN0YXRlIG51bWJlci5cIik7XG4gICAgICB9XG4gICAgICBsZXQgY3R4ID0gY29udGV4dDtcbiAgICAgIGxldCBzID0gdGhpcy5zdGF0ZXNbc3RhdGVOdW1iZXJdO1xuICAgICAgbGV0IGZvbGxvd2luZyA9IHRoaXMubmV4dFRva2VucyhzKTtcbiAgICAgIGlmICghZm9sbG93aW5nLmNvbnRhaW5zKFRva2VuXzEuVG9rZW4uRVBTSUxPTikpIHtcbiAgICAgICAgcmV0dXJuIGZvbGxvd2luZztcbiAgICAgIH1cbiAgICAgIGxldCBleHBlY3RlZCA9IG5ldyBJbnRlcnZhbFNldF8xLkludGVydmFsU2V0KCk7XG4gICAgICBleHBlY3RlZC5hZGRBbGwoZm9sbG93aW5nKTtcbiAgICAgIGV4cGVjdGVkLnJlbW92ZShUb2tlbl8xLlRva2VuLkVQU0lMT04pO1xuICAgICAgd2hpbGUgKGN0eCAhPSBudWxsICYmIGN0eC5pbnZva2luZ1N0YXRlID49IDAgJiYgZm9sbG93aW5nLmNvbnRhaW5zKFRva2VuXzEuVG9rZW4uRVBTSUxPTikpIHtcbiAgICAgICAgbGV0IGludm9raW5nU3RhdGUgPSB0aGlzLnN0YXRlc1tjdHguaW52b2tpbmdTdGF0ZV07XG4gICAgICAgIGxldCBydCA9IGludm9raW5nU3RhdGUudHJhbnNpdGlvbigwKTtcbiAgICAgICAgZm9sbG93aW5nID0gdGhpcy5uZXh0VG9rZW5zKHJ0LmZvbGxvd1N0YXRlKTtcbiAgICAgICAgZXhwZWN0ZWQuYWRkQWxsKGZvbGxvd2luZyk7XG4gICAgICAgIGV4cGVjdGVkLnJlbW92ZShUb2tlbl8xLlRva2VuLkVQU0lMT04pO1xuICAgICAgICBjdHggPSBjdHguX3BhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmIChmb2xsb3dpbmcuY29udGFpbnMoVG9rZW5fMS5Ub2tlbi5FUFNJTE9OKSkge1xuICAgICAgICBleHBlY3RlZC5hZGQoVG9rZW5fMS5Ub2tlbi5FT0YpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgQVROMi5wcm90b3R5cGUsIFwic3RhdGVzXCIsIHZvaWQgMCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIEFUTjIucHJvdG90eXBlLCBcImRlY2lzaW9uVG9TdGF0ZVwiLCB2b2lkIDApO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBBVE4yLnByb3RvdHlwZSwgXCJtb2RlTmFtZVRvU3RhcnRTdGF0ZVwiLCB2b2lkIDApO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBBVE4yLnByb3RvdHlwZSwgXCJtb2RlVG9TdGFydFN0YXRlXCIsIHZvaWQgMCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIEFUTjIucHJvdG90eXBlLCBcImRlY2lzaW9uVG9ERkFcIiwgdm9pZCAwKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgQVROMi5wcm90b3R5cGUsIFwibW9kZVRvREZBXCIsIHZvaWQgMCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIEFUTjIucHJvdG90eXBlLCBcIm5leHRUb2tlbnNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIEFUTjIucHJvdG90eXBlLCBcInJlbW92ZVN0YXRlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDEsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBBVE4yLnByb3RvdHlwZSwgXCJkZWZpbmVNb2RlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBBVE4yLnByb3RvdHlwZSwgXCJkZWZpbmVEZWNpc2lvblN0YXRlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBBVE4yLnByb3RvdHlwZSwgXCJnZXRFeHBlY3RlZFRva2Vuc1wiLCBudWxsKTtcbiAgQVROMiA9IF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIEFUTjIpO1xuICBleHBvcnRzLkFUTiA9IEFUTjI7XG4gIChmdW5jdGlvbihBVE4zKSB7XG4gICAgQVROMy5JTlZBTElEX0FMVF9OVU1CRVIgPSAwO1xuICB9KShBVE4yID0gZXhwb3J0cy5BVE4gfHwgKGV4cG9ydHMuQVROID0ge30pKTtcbiAgZXhwb3J0cy5BVE4gPSBBVE4yO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9hdG4vTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uLmpzXG52YXIgcmVxdWlyZV9MZXhlckluZGV4ZWRDdXN0b21BY3Rpb24gPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uID0gdm9pZCAwO1xuICB2YXIgTXVybXVySGFzaF8xID0gcmVxdWlyZV9NdXJtdXJIYXNoKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIExleGVySW5kZXhlZEN1c3RvbUFjdGlvbiA9IGNsYXNzIExleGVySW5kZXhlZEN1c3RvbUFjdGlvbjIge1xuICAgIGNvbnN0cnVjdG9yKG9mZnNldCwgYWN0aW9uKSB7XG4gICAgICB0aGlzLl9vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICB0aGlzLl9hY3Rpb24gPSBhY3Rpb247XG4gICAgfVxuICAgIGdldCBvZmZzZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0O1xuICAgIH1cbiAgICBnZXQgYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbjtcbiAgICB9XG4gICAgZ2V0IGFjdGlvblR5cGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWN0aW9uLmFjdGlvblR5cGU7XG4gICAgfVxuICAgIGdldCBpc1Bvc2l0aW9uRGVwZW5kZW50KCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGV4ZWN1dGUobGV4ZXIpIHtcbiAgICAgIHRoaXMuX2FjdGlvbi5leGVjdXRlKGxleGVyKTtcbiAgICB9XG4gICAgaGFzaENvZGUoKSB7XG4gICAgICBsZXQgaGFzaCA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLmluaXRpYWxpemUoKTtcbiAgICAgIGhhc2ggPSBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC51cGRhdGUoaGFzaCwgdGhpcy5fb2Zmc2V0KTtcbiAgICAgIGhhc2ggPSBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC51cGRhdGUoaGFzaCwgdGhpcy5fYWN0aW9uKTtcbiAgICAgIHJldHVybiBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC5maW5pc2goaGFzaCwgMik7XG4gICAgfVxuICAgIGVxdWFscyhvYmopIHtcbiAgICAgIGlmIChvYmogPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCEob2JqIGluc3RhbmNlb2YgTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uMikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX29mZnNldCA9PT0gb2JqLl9vZmZzZXQgJiYgdGhpcy5fYWN0aW9uLmVxdWFscyhvYmouX2FjdGlvbik7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBMZXhlckluZGV4ZWRDdXN0b21BY3Rpb24ucHJvdG90eXBlLCBcImFjdGlvblwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExleGVySW5kZXhlZEN1c3RvbUFjdGlvbi5wcm90b3R5cGUsIFwiYWN0aW9uVHlwZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExleGVySW5kZXhlZEN1c3RvbUFjdGlvbi5wcm90b3R5cGUsIFwiaXNQb3NpdGlvbkRlcGVuZGVudFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExleGVySW5kZXhlZEN1c3RvbUFjdGlvbi5wcm90b3R5cGUsIFwiZXhlY3V0ZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExleGVySW5kZXhlZEN1c3RvbUFjdGlvbi5wcm90b3R5cGUsIFwiaGFzaENvZGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBMZXhlckluZGV4ZWRDdXN0b21BY3Rpb24ucHJvdG90eXBlLCBcImVxdWFsc1wiLCBudWxsKTtcbiAgTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uKTtcbiAgZXhwb3J0cy5MZXhlckluZGV4ZWRDdXN0b21BY3Rpb24gPSBMZXhlckluZGV4ZWRDdXN0b21BY3Rpb247XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9MZXhlckFjdGlvbkV4ZWN1dG9yLmpzXG52YXIgcmVxdWlyZV9MZXhlckFjdGlvbkV4ZWN1dG9yID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkxleGVyQWN0aW9uRXhlY3V0b3IgPSB2b2lkIDA7XG4gIHZhciBBcnJheUVxdWFsaXR5Q29tcGFyYXRvcl8xID0gcmVxdWlyZV9BcnJheUVxdWFsaXR5Q29tcGFyYXRvcigpO1xuICB2YXIgTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uXzEgPSByZXF1aXJlX0xleGVySW5kZXhlZEN1c3RvbUFjdGlvbigpO1xuICB2YXIgTXVybXVySGFzaF8xID0gcmVxdWlyZV9NdXJtdXJIYXNoKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIExleGVyQWN0aW9uRXhlY3V0b3IgPSBjbGFzcyBMZXhlckFjdGlvbkV4ZWN1dG9yMiB7XG4gICAgY29uc3RydWN0b3IobGV4ZXJBY3Rpb25zKSB7XG4gICAgICB0aGlzLl9sZXhlckFjdGlvbnMgPSBsZXhlckFjdGlvbnM7XG4gICAgICBsZXQgaGFzaCA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLmluaXRpYWxpemUoKTtcbiAgICAgIGZvciAobGV0IGxleGVyQWN0aW9uIG9mIGxleGVyQWN0aW9ucykge1xuICAgICAgICBoYXNoID0gTXVybXVySGFzaF8xLk11cm11ckhhc2gudXBkYXRlKGhhc2gsIGxleGVyQWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGVkSGFzaENvZGUgPSBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC5maW5pc2goaGFzaCwgbGV4ZXJBY3Rpb25zLmxlbmd0aCk7XG4gICAgfVxuICAgIHN0YXRpYyBhcHBlbmQobGV4ZXJBY3Rpb25FeGVjdXRvciwgbGV4ZXJBY3Rpb24pIHtcbiAgICAgIGlmICghbGV4ZXJBY3Rpb25FeGVjdXRvcikge1xuICAgICAgICByZXR1cm4gbmV3IExleGVyQWN0aW9uRXhlY3V0b3IyKFtsZXhlckFjdGlvbl0pO1xuICAgICAgfVxuICAgICAgbGV0IGxleGVyQWN0aW9ucyA9IGxleGVyQWN0aW9uRXhlY3V0b3IuX2xleGVyQWN0aW9ucy5zbGljZSgwKTtcbiAgICAgIGxleGVyQWN0aW9ucy5wdXNoKGxleGVyQWN0aW9uKTtcbiAgICAgIHJldHVybiBuZXcgTGV4ZXJBY3Rpb25FeGVjdXRvcjIobGV4ZXJBY3Rpb25zKTtcbiAgICB9XG4gICAgZml4T2Zmc2V0QmVmb3JlTWF0Y2gob2Zmc2V0KSB7XG4gICAgICBsZXQgdXBkYXRlZExleGVyQWN0aW9ucztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbGV4ZXJBY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9sZXhlckFjdGlvbnNbaV0uaXNQb3NpdGlvbkRlcGVuZGVudCAmJiAhKHRoaXMuX2xleGVyQWN0aW9uc1tpXSBpbnN0YW5jZW9mIExleGVySW5kZXhlZEN1c3RvbUFjdGlvbl8xLkxleGVySW5kZXhlZEN1c3RvbUFjdGlvbikpIHtcbiAgICAgICAgICBpZiAoIXVwZGF0ZWRMZXhlckFjdGlvbnMpIHtcbiAgICAgICAgICAgIHVwZGF0ZWRMZXhlckFjdGlvbnMgPSB0aGlzLl9sZXhlckFjdGlvbnMuc2xpY2UoMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZWRMZXhlckFjdGlvbnNbaV0gPSBuZXcgTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uXzEuTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uKG9mZnNldCwgdGhpcy5fbGV4ZXJBY3Rpb25zW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF1cGRhdGVkTGV4ZXJBY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBMZXhlckFjdGlvbkV4ZWN1dG9yMih1cGRhdGVkTGV4ZXJBY3Rpb25zKTtcbiAgICB9XG4gICAgZ2V0IGxleGVyQWN0aW9ucygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sZXhlckFjdGlvbnM7XG4gICAgfVxuICAgIGV4ZWN1dGUobGV4ZXIsIGlucHV0LCBzdGFydEluZGV4KSB7XG4gICAgICBsZXQgcmVxdWlyZXNTZWVrID0gZmFsc2U7XG4gICAgICBsZXQgc3RvcEluZGV4ID0gaW5wdXQuaW5kZXg7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKGxldCBsZXhlckFjdGlvbiBvZiB0aGlzLl9sZXhlckFjdGlvbnMpIHtcbiAgICAgICAgICBpZiAobGV4ZXJBY3Rpb24gaW5zdGFuY2VvZiBMZXhlckluZGV4ZWRDdXN0b21BY3Rpb25fMS5MZXhlckluZGV4ZWRDdXN0b21BY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSBsZXhlckFjdGlvbi5vZmZzZXQ7XG4gICAgICAgICAgICBpbnB1dC5zZWVrKHN0YXJ0SW5kZXggKyBvZmZzZXQpO1xuICAgICAgICAgICAgbGV4ZXJBY3Rpb24gPSBsZXhlckFjdGlvbi5hY3Rpb247XG4gICAgICAgICAgICByZXF1aXJlc1NlZWsgPSBzdGFydEluZGV4ICsgb2Zmc2V0ICE9PSBzdG9wSW5kZXg7XG4gICAgICAgICAgfSBlbHNlIGlmIChsZXhlckFjdGlvbi5pc1Bvc2l0aW9uRGVwZW5kZW50KSB7XG4gICAgICAgICAgICBpbnB1dC5zZWVrKHN0b3BJbmRleCk7XG4gICAgICAgICAgICByZXF1aXJlc1NlZWsgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV4ZXJBY3Rpb24uZXhlY3V0ZShsZXhlcik7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChyZXF1aXJlc1NlZWspIHtcbiAgICAgICAgICBpbnB1dC5zZWVrKHN0b3BJbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaGFzaENvZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZWRIYXNoQ29kZTtcbiAgICB9XG4gICAgZXF1YWxzKG9iaikge1xuICAgICAgaWYgKG9iaiA9PT0gdGhpcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIShvYmogaW5zdGFuY2VvZiBMZXhlckFjdGlvbkV4ZWN1dG9yMikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkSGFzaENvZGUgPT09IG9iai5jYWNoZWRIYXNoQ29kZSAmJiBBcnJheUVxdWFsaXR5Q29tcGFyYXRvcl8xLkFycmF5RXF1YWxpdHlDb21wYXJhdG9yLklOU1RBTkNFLmVxdWFscyh0aGlzLl9sZXhlckFjdGlvbnMsIG9iai5fbGV4ZXJBY3Rpb25zKTtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIExleGVyQWN0aW9uRXhlY3V0b3IucHJvdG90eXBlLCBcIl9sZXhlckFjdGlvbnNcIiwgdm9pZCAwKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgTGV4ZXJBY3Rpb25FeGVjdXRvci5wcm90b3R5cGUsIFwibGV4ZXJBY3Rpb25zXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBMZXhlckFjdGlvbkV4ZWN1dG9yLnByb3RvdHlwZSwgXCJleGVjdXRlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJBY3Rpb25FeGVjdXRvci5wcm90b3R5cGUsIFwiaGFzaENvZGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBMZXhlckFjdGlvbkV4ZWN1dG9yLnByb3RvdHlwZSwgXCJlcXVhbHNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsLFxuICAgIF9fcGFyYW0oMSwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIExleGVyQWN0aW9uRXhlY3V0b3IsIFwiYXBwZW5kXCIsIG51bGwpO1xuICBMZXhlckFjdGlvbkV4ZWN1dG9yID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgTGV4ZXJBY3Rpb25FeGVjdXRvcik7XG4gIGV4cG9ydHMuTGV4ZXJBY3Rpb25FeGVjdXRvciA9IExleGVyQWN0aW9uRXhlY3V0b3I7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL0xleGVyTm9WaWFibGVBbHRFeGNlcHRpb24uanNcbnZhciByZXF1aXJlX0xleGVyTm9WaWFibGVBbHRFeGNlcHRpb24gPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbiA9IHZvaWQgMDtcbiAgdmFyIFJlY29nbml0aW9uRXhjZXB0aW9uXzEgPSByZXF1aXJlX1JlY29nbml0aW9uRXhjZXB0aW9uKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIEludGVydmFsXzEgPSByZXF1aXJlX0ludGVydmFsKCk7XG4gIHZhciBVdGlsczMgPSByZXF1aXJlX1V0aWxzKCk7XG4gIHZhciBMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uID0gY2xhc3MgTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbiBleHRlbmRzIFJlY29nbml0aW9uRXhjZXB0aW9uXzEuUmVjb2duaXRpb25FeGNlcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGxleGVyLCBpbnB1dCwgc3RhcnRJbmRleCwgZGVhZEVuZENvbmZpZ3MpIHtcbiAgICAgIHN1cGVyKGxleGVyLCBpbnB1dCk7XG4gICAgICB0aGlzLl9zdGFydEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgIHRoaXMuX2RlYWRFbmRDb25maWdzID0gZGVhZEVuZENvbmZpZ3M7XG4gICAgfVxuICAgIGdldCBzdGFydEluZGV4KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0SW5kZXg7XG4gICAgfVxuICAgIGdldCBkZWFkRW5kQ29uZmlncygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWFkRW5kQ29uZmlncztcbiAgICB9XG4gICAgZ2V0IGlucHV0U3RyZWFtKCkge1xuICAgICAgcmV0dXJuIHN1cGVyLmlucHV0U3RyZWFtO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIGxldCBzeW1ib2wgPSBcIlwiO1xuICAgICAgaWYgKHRoaXMuX3N0YXJ0SW5kZXggPj0gMCAmJiB0aGlzLl9zdGFydEluZGV4IDwgdGhpcy5pbnB1dFN0cmVhbS5zaXplKSB7XG4gICAgICAgIHN5bWJvbCA9IHRoaXMuaW5wdXRTdHJlYW0uZ2V0VGV4dChJbnRlcnZhbF8xLkludGVydmFsLm9mKHRoaXMuX3N0YXJ0SW5kZXgsIHRoaXMuX3N0YXJ0SW5kZXgpKTtcbiAgICAgICAgc3ltYm9sID0gVXRpbHMzLmVzY2FwZVdoaXRlc3BhY2Uoc3ltYm9sLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYExleGVyTm9WaWFibGVBbHRFeGNlcHRpb24oJyR7c3ltYm9sfScpYDtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uLnByb3RvdHlwZSwgXCJpbnB1dFN0cmVhbVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExleGVyTm9WaWFibGVBbHRFeGNlcHRpb24ucHJvdG90eXBlLCBcInRvU3RyaW5nXCIsIG51bGwpO1xuICBMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbik7XG4gIGV4cG9ydHMuTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbiA9IExleGVyTm9WaWFibGVBbHRFeGNlcHRpb247XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9PcmRlcmVkQVROQ29uZmlnU2V0LmpzXG52YXIgcmVxdWlyZV9PcmRlcmVkQVROQ29uZmlnU2V0ID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLk9yZGVyZWRBVE5Db25maWdTZXQgPSB2b2lkIDA7XG4gIHZhciBBVE5Db25maWdTZXRfMSA9IHJlcXVpcmVfQVROQ29uZmlnU2V0KCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIE9yZGVyZWRBVE5Db25maWdTZXQgPSBjbGFzcyBleHRlbmRzIEFUTkNvbmZpZ1NldF8xLkFUTkNvbmZpZ1NldCB7XG4gICAgY29uc3RydWN0b3Ioc2V0LCByZWFkb25seSkge1xuICAgICAgaWYgKHNldCAhPSBudWxsICYmIHJlYWRvbmx5ICE9IG51bGwpIHtcbiAgICAgICAgc3VwZXIoc2V0LCByZWFkb25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgfVxuICAgIH1cbiAgICBjbG9uZShyZWFkb25seSkge1xuICAgICAgbGV0IGNvcHkgPSBuZXcgT3JkZXJlZEFUTkNvbmZpZ1NldCh0aGlzLCByZWFkb25seSk7XG4gICAgICBpZiAoIXJlYWRvbmx5ICYmIHRoaXMuaXNSZWFkT25seSkge1xuICAgICAgICBjb3B5LmFkZEFsbCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICBnZXRLZXkoZSkge1xuICAgICAgcmV0dXJuIHtzdGF0ZTogMCwgYWx0OiBlLmhhc2hDb2RlKCl9O1xuICAgIH1cbiAgICBjYW5NZXJnZShsZWZ0LCBsZWZ0S2V5LCByaWdodCkge1xuICAgICAgcmV0dXJuIGxlZnQuZXF1YWxzKHJpZ2h0KTtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBPcmRlcmVkQVROQ29uZmlnU2V0LnByb3RvdHlwZSwgXCJjbG9uZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIE9yZGVyZWRBVE5Db25maWdTZXQucHJvdG90eXBlLCBcImdldEtleVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIE9yZGVyZWRBVE5Db25maWdTZXQucHJvdG90eXBlLCBcImNhbk1lcmdlXCIsIG51bGwpO1xuICBleHBvcnRzLk9yZGVyZWRBVE5Db25maWdTZXQgPSBPcmRlcmVkQVROQ29uZmlnU2V0O1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9hdG4vTGV4ZXJBVE5TaW11bGF0b3IuanNcbnZhciByZXF1aXJlX0xleGVyQVROU2ltdWxhdG9yID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkxleGVyQVROU2ltdWxhdG9yID0gdm9pZCAwO1xuICB2YXIgQWNjZXB0U3RhdGVJbmZvXzEgPSByZXF1aXJlX0FjY2VwdFN0YXRlSW5mbygpO1xuICB2YXIgQVROXzEgPSByZXF1aXJlX0FUTigpO1xuICB2YXIgQVROQ29uZmlnXzEgPSByZXF1aXJlX0FUTkNvbmZpZygpO1xuICB2YXIgQVROQ29uZmlnU2V0XzEgPSByZXF1aXJlX0FUTkNvbmZpZ1NldCgpO1xuICB2YXIgQVROU2ltdWxhdG9yXzEgPSByZXF1aXJlX0FUTlNpbXVsYXRvcigpO1xuICB2YXIgREZBU3RhdGVfMSA9IHJlcXVpcmVfREZBU3RhdGUoKTtcbiAgdmFyIEludGVydmFsXzEgPSByZXF1aXJlX0ludGVydmFsKCk7XG4gIHZhciBJbnRTdHJlYW1fMSA9IHJlcXVpcmVfSW50U3RyZWFtKCk7XG4gIHZhciBMZXhlcl8xID0gcmVxdWlyZV9MZXhlcigpO1xuICB2YXIgTGV4ZXJBY3Rpb25FeGVjdXRvcl8xID0gcmVxdWlyZV9MZXhlckFjdGlvbkV4ZWN1dG9yKCk7XG4gIHZhciBMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uXzEgPSByZXF1aXJlX0xleGVyTm9WaWFibGVBbHRFeGNlcHRpb24oKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgT3JkZXJlZEFUTkNvbmZpZ1NldF8xID0gcmVxdWlyZV9PcmRlcmVkQVROQ29uZmlnU2V0KCk7XG4gIHZhciBQcmVkaWN0aW9uQ29udGV4dF8xID0gcmVxdWlyZV9QcmVkaWN0aW9uQ29udGV4dCgpO1xuICB2YXIgUnVsZVN0b3BTdGF0ZV8xID0gcmVxdWlyZV9SdWxlU3RvcFN0YXRlKCk7XG4gIHZhciBUb2tlbl8xID0gcmVxdWlyZV9Ub2tlbigpO1xuICB2YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbiAgdmFyIExleGVyQVROU2ltdWxhdG9yMiA9IGNsYXNzIExleGVyQVROU2ltdWxhdG9yMyBleHRlbmRzIEFUTlNpbXVsYXRvcl8xLkFUTlNpbXVsYXRvciB7XG4gICAgY29uc3RydWN0b3IoYXRuLCByZWNvZykge1xuICAgICAgc3VwZXIoYXRuKTtcbiAgICAgIHRoaXMub3B0aW1pemVfdGFpbF9jYWxscyA9IHRydWU7XG4gICAgICB0aGlzLnN0YXJ0SW5kZXggPSAtMTtcbiAgICAgIHRoaXMuX2xpbmUgPSAxO1xuICAgICAgdGhpcy5fY2hhclBvc2l0aW9uSW5MaW5lID0gMDtcbiAgICAgIHRoaXMubW9kZSA9IExleGVyXzEuTGV4ZXIuREVGQVVMVF9NT0RFO1xuICAgICAgdGhpcy5wcmV2QWNjZXB0ID0gbmV3IExleGVyQVROU2ltdWxhdG9yMy5TaW1TdGF0ZSgpO1xuICAgICAgdGhpcy5yZWNvZyA9IHJlY29nO1xuICAgIH1cbiAgICBjb3B5U3RhdGUoc2ltdWxhdG9yKSB7XG4gICAgICB0aGlzLl9jaGFyUG9zaXRpb25JbkxpbmUgPSBzaW11bGF0b3IuY2hhclBvc2l0aW9uSW5MaW5lO1xuICAgICAgdGhpcy5fbGluZSA9IHNpbXVsYXRvci5fbGluZTtcbiAgICAgIHRoaXMubW9kZSA9IHNpbXVsYXRvci5tb2RlO1xuICAgICAgdGhpcy5zdGFydEluZGV4ID0gc2ltdWxhdG9yLnN0YXJ0SW5kZXg7XG4gICAgfVxuICAgIG1hdGNoKGlucHV0LCBtb2RlKSB7XG4gICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgbGV0IG1hcmsgPSBpbnB1dC5tYXJrKCk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSBpbnB1dC5pbmRleDtcbiAgICAgICAgdGhpcy5wcmV2QWNjZXB0LnJlc2V0KCk7XG4gICAgICAgIGxldCBzMCA9IHRoaXMuYXRuLm1vZGVUb0RGQVttb2RlXS5zMDtcbiAgICAgICAgaWYgKHMwID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5tYXRjaEFUTihpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXhlY0FUTihpbnB1dCwgczApO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpbnB1dC5yZWxlYXNlKG1hcmspO1xuICAgICAgfVxuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgIHRoaXMucHJldkFjY2VwdC5yZXNldCgpO1xuICAgICAgdGhpcy5zdGFydEluZGV4ID0gLTE7XG4gICAgICB0aGlzLl9saW5lID0gMTtcbiAgICAgIHRoaXMuX2NoYXJQb3NpdGlvbkluTGluZSA9IDA7XG4gICAgICB0aGlzLm1vZGUgPSBMZXhlcl8xLkxleGVyLkRFRkFVTFRfTU9ERTtcbiAgICB9XG4gICAgbWF0Y2hBVE4oaW5wdXQpIHtcbiAgICAgIGxldCBzdGFydFN0YXRlID0gdGhpcy5hdG4ubW9kZVRvU3RhcnRTdGF0ZVt0aGlzLm1vZGVdO1xuICAgICAgaWYgKExleGVyQVROU2ltdWxhdG9yMy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhgbWF0Y2hBVE4gbW9kZSAke3RoaXMubW9kZX0gc3RhcnQ6ICR7c3RhcnRTdGF0ZX1gKTtcbiAgICAgIH1cbiAgICAgIGxldCBvbGRfbW9kZSA9IHRoaXMubW9kZTtcbiAgICAgIGxldCBzMF9jbG9zdXJlID0gdGhpcy5jb21wdXRlU3RhcnRTdGF0ZShpbnB1dCwgc3RhcnRTdGF0ZSk7XG4gICAgICBsZXQgc3VwcHJlc3NFZGdlID0gczBfY2xvc3VyZS5oYXNTZW1hbnRpY0NvbnRleHQ7XG4gICAgICBpZiAoc3VwcHJlc3NFZGdlKSB7XG4gICAgICAgIHMwX2Nsb3N1cmUuaGFzU2VtYW50aWNDb250ZXh0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBsZXQgbmV4dCA9IHRoaXMuYWRkREZBU3RhdGUoczBfY2xvc3VyZSk7XG4gICAgICBpZiAoIXN1cHByZXNzRWRnZSkge1xuICAgICAgICBsZXQgZGZhID0gdGhpcy5hdG4ubW9kZVRvREZBW3RoaXMubW9kZV07XG4gICAgICAgIGlmICghZGZhLnMwKSB7XG4gICAgICAgICAgZGZhLnMwID0gbmV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0ID0gZGZhLnMwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgcHJlZGljdCA9IHRoaXMuZXhlY0FUTihpbnB1dCwgbmV4dCk7XG4gICAgICBpZiAoTGV4ZXJBVE5TaW11bGF0b3IzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBERkEgYWZ0ZXIgbWF0Y2hBVE46ICR7dGhpcy5hdG4ubW9kZVRvREZBW29sZF9tb2RlXS50b0xleGVyU3RyaW5nKCl9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJlZGljdDtcbiAgICB9XG4gICAgZXhlY0FUTihpbnB1dCwgZHMwKSB7XG4gICAgICBpZiAoTGV4ZXJBVE5TaW11bGF0b3IzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBzdGFydCBzdGF0ZSBjbG9zdXJlPSR7ZHMwLmNvbmZpZ3N9YCk7XG4gICAgICB9XG4gICAgICBpZiAoZHMwLmlzQWNjZXB0U3RhdGUpIHtcbiAgICAgICAgdGhpcy5jYXB0dXJlU2ltU3RhdGUodGhpcy5wcmV2QWNjZXB0LCBpbnB1dCwgZHMwKTtcbiAgICAgIH1cbiAgICAgIGxldCB0ID0gaW5wdXQuTEEoMSk7XG4gICAgICBsZXQgcyA9IGRzMDtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChMZXhlckFUTlNpbXVsYXRvcjMuZGVidWcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgZXhlY0FUTiBsb29wIHN0YXJ0aW5nIGNsb3N1cmU6ICR7cy5jb25maWdzfWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLmdldEV4aXN0aW5nVGFyZ2V0U3RhdGUocywgdCk7XG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgIHRhcmdldCA9IHRoaXMuY29tcHV0ZVRhcmdldFN0YXRlKGlucHV0LCBzLCB0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0ID09PSBBVE5TaW11bGF0b3JfMS5BVE5TaW11bGF0b3IuRVJST1IpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodCAhPT0gSW50U3RyZWFtXzEuSW50U3RyZWFtLkVPRikge1xuICAgICAgICAgIHRoaXMuY29uc3VtZShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldC5pc0FjY2VwdFN0YXRlKSB7XG4gICAgICAgICAgdGhpcy5jYXB0dXJlU2ltU3RhdGUodGhpcy5wcmV2QWNjZXB0LCBpbnB1dCwgdGFyZ2V0KTtcbiAgICAgICAgICBpZiAodCA9PT0gSW50U3RyZWFtXzEuSW50U3RyZWFtLkVPRikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHQgPSBpbnB1dC5MQSgxKTtcbiAgICAgICAgcyA9IHRhcmdldDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZhaWxPckFjY2VwdCh0aGlzLnByZXZBY2NlcHQsIGlucHV0LCBzLmNvbmZpZ3MsIHQpO1xuICAgIH1cbiAgICBnZXRFeGlzdGluZ1RhcmdldFN0YXRlKHMsIHQpIHtcbiAgICAgIGxldCB0YXJnZXQgPSBzLmdldFRhcmdldCh0KTtcbiAgICAgIGlmIChMZXhlckFUTlNpbXVsYXRvcjMuZGVidWcgJiYgdGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJyZXVzZSBzdGF0ZSBcIiArIHMuc3RhdGVOdW1iZXIgKyBcIiBlZGdlIHRvIFwiICsgdGFyZ2V0LnN0YXRlTnVtYmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGNvbXB1dGVUYXJnZXRTdGF0ZShpbnB1dCwgcywgdCkge1xuICAgICAgbGV0IHJlYWNoID0gbmV3IE9yZGVyZWRBVE5Db25maWdTZXRfMS5PcmRlcmVkQVROQ29uZmlnU2V0KCk7XG4gICAgICB0aGlzLmdldFJlYWNoYWJsZUNvbmZpZ1NldChpbnB1dCwgcy5jb25maWdzLCByZWFjaCwgdCk7XG4gICAgICBpZiAocmVhY2guaXNFbXB0eSkge1xuICAgICAgICBpZiAoIXJlYWNoLmhhc1NlbWFudGljQ29udGV4dCkge1xuICAgICAgICAgIHRoaXMuYWRkREZBRWRnZShzLCB0LCBBVE5TaW11bGF0b3JfMS5BVE5TaW11bGF0b3IuRVJST1IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBVE5TaW11bGF0b3JfMS5BVE5TaW11bGF0b3IuRVJST1I7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5hZGRERkFFZGdlKHMsIHQsIHJlYWNoKTtcbiAgICB9XG4gICAgZmFpbE9yQWNjZXB0KHByZXZBY2NlcHQsIGlucHV0LCByZWFjaCwgdCkge1xuICAgICAgaWYgKHByZXZBY2NlcHQuZGZhU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBsZXQgbGV4ZXJBY3Rpb25FeGVjdXRvciA9IHByZXZBY2NlcHQuZGZhU3RhdGUubGV4ZXJBY3Rpb25FeGVjdXRvcjtcbiAgICAgICAgdGhpcy5hY2NlcHQoaW5wdXQsIGxleGVyQWN0aW9uRXhlY3V0b3IsIHRoaXMuc3RhcnRJbmRleCwgcHJldkFjY2VwdC5pbmRleCwgcHJldkFjY2VwdC5saW5lLCBwcmV2QWNjZXB0LmNoYXJQb3MpO1xuICAgICAgICByZXR1cm4gcHJldkFjY2VwdC5kZmFTdGF0ZS5wcmVkaWN0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHQgPT09IEludFN0cmVhbV8xLkludFN0cmVhbS5FT0YgJiYgaW5wdXQuaW5kZXggPT09IHRoaXMuc3RhcnRJbmRleCkge1xuICAgICAgICAgIHJldHVybiBUb2tlbl8xLlRva2VuLkVPRjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbl8xLkxleGVyTm9WaWFibGVBbHRFeGNlcHRpb24odGhpcy5yZWNvZywgaW5wdXQsIHRoaXMuc3RhcnRJbmRleCwgcmVhY2gpO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXRSZWFjaGFibGVDb25maWdTZXQoaW5wdXQsIGNsb3N1cmUsIHJlYWNoLCB0KSB7XG4gICAgICBsZXQgc2tpcEFsdCA9IEFUTl8xLkFUTi5JTlZBTElEX0FMVF9OVU1CRVI7XG4gICAgICBmb3IgKGxldCBjIG9mIGNsb3N1cmUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGUgPSBjLmFsdCA9PT0gc2tpcEFsdDtcbiAgICAgICAgaWYgKGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGUgJiYgYy5oYXNQYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb24pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTGV4ZXJBVE5TaW11bGF0b3IzLmRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYHRlc3RpbmcgJHt0aGlzLmdldFRva2VuTmFtZSh0KX0gYXQgJHtjLnRvU3RyaW5nKHRoaXMucmVjb2csIHRydWUpfWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuID0gYy5zdGF0ZS5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zO1xuICAgICAgICBmb3IgKGxldCB0aSA9IDA7IHRpIDwgbjsgdGkrKykge1xuICAgICAgICAgIGxldCB0cmFucyA9IGMuc3RhdGUuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbih0aSk7XG4gICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuZ2V0UmVhY2hhYmxlVGFyZ2V0KHRyYW5zLCB0KTtcbiAgICAgICAgICBpZiAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBsZXhlckFjdGlvbkV4ZWN1dG9yID0gYy5sZXhlckFjdGlvbkV4ZWN1dG9yO1xuICAgICAgICAgICAgbGV0IGNvbmZpZztcbiAgICAgICAgICAgIGlmIChsZXhlckFjdGlvbkV4ZWN1dG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgbGV4ZXJBY3Rpb25FeGVjdXRvciA9IGxleGVyQWN0aW9uRXhlY3V0b3IuZml4T2Zmc2V0QmVmb3JlTWF0Y2goaW5wdXQuaW5kZXggLSB0aGlzLnN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgICBjb25maWcgPSBjLnRyYW5zZm9ybSh0YXJnZXQsIHRydWUsIGxleGVyQWN0aW9uRXhlY3V0b3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXNzZXJ0KGMubGV4ZXJBY3Rpb25FeGVjdXRvciA9PSBudWxsKTtcbiAgICAgICAgICAgICAgY29uZmlnID0gYy50cmFuc2Zvcm0odGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0cmVhdEVvZkFzRXBzaWxvbiA9IHQgPT09IEludFN0cmVhbV8xLkludFN0cmVhbS5FT0Y7XG4gICAgICAgICAgICBpZiAodGhpcy5jbG9zdXJlKGlucHV0LCBjb25maWcsIHJlYWNoLCBjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlLCB0cnVlLCB0cmVhdEVvZkFzRXBzaWxvbikpIHtcbiAgICAgICAgICAgICAgc2tpcEFsdCA9IGMuYWx0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYWNjZXB0KGlucHV0LCBsZXhlckFjdGlvbkV4ZWN1dG9yLCBzdGFydEluZGV4LCBpbmRleCwgbGluZSwgY2hhclBvcykge1xuICAgICAgaWYgKExleGVyQVROU2ltdWxhdG9yMy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhgQUNUSU9OICR7bGV4ZXJBY3Rpb25FeGVjdXRvcn1gKTtcbiAgICAgIH1cbiAgICAgIGlucHV0LnNlZWsoaW5kZXgpO1xuICAgICAgdGhpcy5fbGluZSA9IGxpbmU7XG4gICAgICB0aGlzLl9jaGFyUG9zaXRpb25JbkxpbmUgPSBjaGFyUG9zO1xuICAgICAgaWYgKGxleGVyQWN0aW9uRXhlY3V0b3IgIT0gbnVsbCAmJiB0aGlzLnJlY29nICE9IG51bGwpIHtcbiAgICAgICAgbGV4ZXJBY3Rpb25FeGVjdXRvci5leGVjdXRlKHRoaXMucmVjb2csIGlucHV0LCBzdGFydEluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0UmVhY2hhYmxlVGFyZ2V0KHRyYW5zLCB0KSB7XG4gICAgICBpZiAodHJhbnMubWF0Y2hlcyh0LCBMZXhlcl8xLkxleGVyLk1JTl9DSEFSX1ZBTFVFLCBMZXhlcl8xLkxleGVyLk1BWF9DSEFSX1ZBTFVFKSkge1xuICAgICAgICByZXR1cm4gdHJhbnMudGFyZ2V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgY29tcHV0ZVN0YXJ0U3RhdGUoaW5wdXQsIHApIHtcbiAgICAgIGxldCBpbml0aWFsQ29udGV4dCA9IFByZWRpY3Rpb25Db250ZXh0XzEuUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTDtcbiAgICAgIGxldCBjb25maWdzID0gbmV3IE9yZGVyZWRBVE5Db25maWdTZXRfMS5PcmRlcmVkQVROQ29uZmlnU2V0KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHAubnVtYmVyT2ZUcmFuc2l0aW9uczsgaSsrKSB7XG4gICAgICAgIGxldCB0YXJnZXQgPSBwLnRyYW5zaXRpb24oaSkudGFyZ2V0O1xuICAgICAgICBsZXQgYyA9IEFUTkNvbmZpZ18xLkFUTkNvbmZpZy5jcmVhdGUodGFyZ2V0LCBpICsgMSwgaW5pdGlhbENvbnRleHQpO1xuICAgICAgICB0aGlzLmNsb3N1cmUoaW5wdXQsIGMsIGNvbmZpZ3MsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmZpZ3M7XG4gICAgfVxuICAgIGNsb3N1cmUoaW5wdXQsIGNvbmZpZywgY29uZmlncywgY3VycmVudEFsdFJlYWNoZWRBY2NlcHRTdGF0ZSwgc3BlY3VsYXRpdmUsIHRyZWF0RW9mQXNFcHNpbG9uKSB7XG4gICAgICBpZiAoTGV4ZXJBVE5TaW11bGF0b3IzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiY2xvc3VyZShcIiArIGNvbmZpZy50b1N0cmluZyh0aGlzLnJlY29nLCB0cnVlKSArIFwiKVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb25maWcuc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlXzEuUnVsZVN0b3BTdGF0ZSkge1xuICAgICAgICBpZiAoTGV4ZXJBVE5TaW11bGF0b3IzLmRlYnVnKSB7XG4gICAgICAgICAgaWYgKHRoaXMucmVjb2cgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYGNsb3N1cmUgYXQgJHt0aGlzLnJlY29nLnJ1bGVOYW1lc1tjb25maWcuc3RhdGUucnVsZUluZGV4XX0gcnVsZSBzdG9wICR7Y29uZmlnfWApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgY2xvc3VyZSBhdCBydWxlIHN0b3AgJHtjb25maWd9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZXh0ID0gY29uZmlnLmNvbnRleHQ7XG4gICAgICAgIGlmIChjb250ZXh0LmlzRW1wdHkpIHtcbiAgICAgICAgICBjb25maWdzLmFkZChjb25maWcpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQuaGFzRW1wdHkpIHtcbiAgICAgICAgICBjb25maWdzLmFkZChjb25maWcudHJhbnNmb3JtKGNvbmZpZy5zdGF0ZSwgdHJ1ZSwgUHJlZGljdGlvbkNvbnRleHRfMS5QcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMKSk7XG4gICAgICAgICAgY3VycmVudEFsdFJlYWNoZWRBY2NlcHRTdGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZXh0LnNpemU7IGkrKykge1xuICAgICAgICAgIGxldCByZXR1cm5TdGF0ZU51bWJlciA9IGNvbnRleHQuZ2V0UmV0dXJuU3RhdGUoaSk7XG4gICAgICAgICAgaWYgKHJldHVyblN0YXRlTnVtYmVyID09PSBQcmVkaWN0aW9uQ29udGV4dF8xLlByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IG5ld0NvbnRleHQgPSBjb250ZXh0LmdldFBhcmVudChpKTtcbiAgICAgICAgICBsZXQgcmV0dXJuU3RhdGUgPSB0aGlzLmF0bi5zdGF0ZXNbcmV0dXJuU3RhdGVOdW1iZXJdO1xuICAgICAgICAgIGxldCBjID0gY29uZmlnLnRyYW5zZm9ybShyZXR1cm5TdGF0ZSwgZmFsc2UsIG5ld0NvbnRleHQpO1xuICAgICAgICAgIGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGUgPSB0aGlzLmNsb3N1cmUoaW5wdXQsIGMsIGNvbmZpZ3MsIGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGUsIHNwZWN1bGF0aXZlLCB0cmVhdEVvZkFzRXBzaWxvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGU7XG4gICAgICB9XG4gICAgICBpZiAoIWNvbmZpZy5zdGF0ZS5vbmx5SGFzRXBzaWxvblRyYW5zaXRpb25zKSB7XG4gICAgICAgIGlmICghY3VycmVudEFsdFJlYWNoZWRBY2NlcHRTdGF0ZSB8fCAhY29uZmlnLmhhc1Bhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbikge1xuICAgICAgICAgIGNvbmZpZ3MuYWRkKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBwID0gY29uZmlnLnN0YXRlO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwLm51bWJlck9mT3B0aW1pemVkVHJhbnNpdGlvbnM7IGkrKykge1xuICAgICAgICBsZXQgdCA9IHAuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbihpKTtcbiAgICAgICAgbGV0IGMgPSB0aGlzLmdldEVwc2lsb25UYXJnZXQoaW5wdXQsIGNvbmZpZywgdCwgY29uZmlncywgc3BlY3VsYXRpdmUsIHRyZWF0RW9mQXNFcHNpbG9uKTtcbiAgICAgICAgaWYgKGMgIT0gbnVsbCkge1xuICAgICAgICAgIGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGUgPSB0aGlzLmNsb3N1cmUoaW5wdXQsIGMsIGNvbmZpZ3MsIGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGUsIHNwZWN1bGF0aXZlLCB0cmVhdEVvZkFzRXBzaWxvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlO1xuICAgIH1cbiAgICBnZXRFcHNpbG9uVGFyZ2V0KGlucHV0LCBjb25maWcsIHQsIGNvbmZpZ3MsIHNwZWN1bGF0aXZlLCB0cmVhdEVvZkFzRXBzaWxvbikge1xuICAgICAgbGV0IGM7XG4gICAgICBzd2l0Y2ggKHQuc2VyaWFsaXphdGlvblR5cGUpIHtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGxldCBydWxlVHJhbnNpdGlvbiA9IHQ7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW1pemVfdGFpbF9jYWxscyAmJiBydWxlVHJhbnNpdGlvbi5vcHRpbWl6ZWRUYWlsQ2FsbCAmJiAhY29uZmlnLmNvbnRleHQuaGFzRW1wdHkpIHtcbiAgICAgICAgICAgIGMgPSBjb25maWcudHJhbnNmb3JtKHQudGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5ld0NvbnRleHQgPSBjb25maWcuY29udGV4dC5nZXRDaGlsZChydWxlVHJhbnNpdGlvbi5mb2xsb3dTdGF0ZS5zdGF0ZU51bWJlcik7XG4gICAgICAgICAgICBjID0gY29uZmlnLnRyYW5zZm9ybSh0LnRhcmdldCwgdHJ1ZSwgbmV3Q29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByZWNlZGVuY2UgcHJlZGljYXRlcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBsZXhlcnMuXCIpO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgbGV0IHB0ID0gdDtcbiAgICAgICAgICBpZiAoTGV4ZXJBVE5TaW11bGF0b3IzLmRlYnVnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVWQUwgcnVsZSBcIiArIHB0LnJ1bGVJbmRleCArIFwiOlwiICsgcHQucHJlZEluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uZmlncy5oYXNTZW1hbnRpY0NvbnRleHQgPSB0cnVlO1xuICAgICAgICAgIGlmICh0aGlzLmV2YWx1YXRlUHJlZGljYXRlKGlucHV0LCBwdC5ydWxlSW5kZXgsIHB0LnByZWRJbmRleCwgc3BlY3VsYXRpdmUpKSB7XG4gICAgICAgICAgICBjID0gY29uZmlnLnRyYW5zZm9ybSh0LnRhcmdldCwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGMgPSB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgaWYgKGNvbmZpZy5jb250ZXh0Lmhhc0VtcHR5KSB7XG4gICAgICAgICAgICBsZXQgbGV4ZXJBY3Rpb25FeGVjdXRvciA9IExleGVyQWN0aW9uRXhlY3V0b3JfMS5MZXhlckFjdGlvbkV4ZWN1dG9yLmFwcGVuZChjb25maWcubGV4ZXJBY3Rpb25FeGVjdXRvciwgdGhpcy5hdG4ubGV4ZXJBY3Rpb25zW3QuYWN0aW9uSW5kZXhdKTtcbiAgICAgICAgICAgIGMgPSBjb25maWcudHJhbnNmb3JtKHQudGFyZ2V0LCB0cnVlLCBsZXhlckFjdGlvbkV4ZWN1dG9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjID0gY29uZmlnLnRyYW5zZm9ybSh0LnRhcmdldCwgdHJ1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBjID0gY29uZmlnLnRyYW5zZm9ybSh0LnRhcmdldCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgaWYgKHRyZWF0RW9mQXNFcHNpbG9uKSB7XG4gICAgICAgICAgICBpZiAodC5tYXRjaGVzKEludFN0cmVhbV8xLkludFN0cmVhbS5FT0YsIExleGVyXzEuTGV4ZXIuTUlOX0NIQVJfVkFMVUUsIExleGVyXzEuTGV4ZXIuTUFYX0NIQVJfVkFMVUUpKSB7XG4gICAgICAgICAgICAgIGMgPSBjb25maWcudHJhbnNmb3JtKHQudGFyZ2V0LCBmYWxzZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjID0gdm9pZCAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSB2b2lkIDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgZXZhbHVhdGVQcmVkaWNhdGUoaW5wdXQsIHJ1bGVJbmRleCwgcHJlZEluZGV4LCBzcGVjdWxhdGl2ZSkge1xuICAgICAgaWYgKHRoaXMucmVjb2cgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghc3BlY3VsYXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjb2cuc2VtcHJlZCh2b2lkIDAsIHJ1bGVJbmRleCwgcHJlZEluZGV4KTtcbiAgICAgIH1cbiAgICAgIGxldCBzYXZlZENoYXJQb3NpdGlvbkluTGluZSA9IHRoaXMuX2NoYXJQb3NpdGlvbkluTGluZTtcbiAgICAgIGxldCBzYXZlZExpbmUgPSB0aGlzLl9saW5lO1xuICAgICAgbGV0IGluZGV4ID0gaW5wdXQuaW5kZXg7XG4gICAgICBsZXQgbWFya2VyID0gaW5wdXQubWFyaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5jb25zdW1lKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjb2cuc2VtcHJlZCh2b2lkIDAsIHJ1bGVJbmRleCwgcHJlZEluZGV4KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2NoYXJQb3NpdGlvbkluTGluZSA9IHNhdmVkQ2hhclBvc2l0aW9uSW5MaW5lO1xuICAgICAgICB0aGlzLl9saW5lID0gc2F2ZWRMaW5lO1xuICAgICAgICBpbnB1dC5zZWVrKGluZGV4KTtcbiAgICAgICAgaW5wdXQucmVsZWFzZShtYXJrZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjYXB0dXJlU2ltU3RhdGUoc2V0dGluZ3MsIGlucHV0LCBkZmFTdGF0ZSkge1xuICAgICAgc2V0dGluZ3MuaW5kZXggPSBpbnB1dC5pbmRleDtcbiAgICAgIHNldHRpbmdzLmxpbmUgPSB0aGlzLl9saW5lO1xuICAgICAgc2V0dGluZ3MuY2hhclBvcyA9IHRoaXMuX2NoYXJQb3NpdGlvbkluTGluZTtcbiAgICAgIHNldHRpbmdzLmRmYVN0YXRlID0gZGZhU3RhdGU7XG4gICAgfVxuICAgIGFkZERGQUVkZ2UocCwgdCwgcSkge1xuICAgICAgaWYgKHEgaW5zdGFuY2VvZiBBVE5Db25maWdTZXRfMS5BVE5Db25maWdTZXQpIHtcbiAgICAgICAgbGV0IHN1cHByZXNzRWRnZSA9IHEuaGFzU2VtYW50aWNDb250ZXh0O1xuICAgICAgICBpZiAoc3VwcHJlc3NFZGdlKSB7XG4gICAgICAgICAgcS5oYXNTZW1hbnRpY0NvbnRleHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG8gPSB0aGlzLmFkZERGQVN0YXRlKHEpO1xuICAgICAgICBpZiAoc3VwcHJlc3NFZGdlKSB7XG4gICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkREZBRWRnZShwLCB0LCB0byk7XG4gICAgICAgIHJldHVybiB0bztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChMZXhlckFUTlNpbXVsYXRvcjMuZGVidWcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkVER0UgXCIgKyBwICsgXCIgLT4gXCIgKyBxICsgXCIgdXBvbiBcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUodCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwICE9IG51bGwpIHtcbiAgICAgICAgICBwLnNldFRhcmdldCh0LCBxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBhZGRERkFTdGF0ZShjb25maWdzKSB7XG4gICAgICBhc3NlcnQoIWNvbmZpZ3MuaGFzU2VtYW50aWNDb250ZXh0KTtcbiAgICAgIGxldCBwcm9wb3NlZCA9IG5ldyBERkFTdGF0ZV8xLkRGQVN0YXRlKGNvbmZpZ3MpO1xuICAgICAgbGV0IGV4aXN0aW5nID0gdGhpcy5hdG4ubW9kZVRvREZBW3RoaXMubW9kZV0uc3RhdGVzLmdldChwcm9wb3NlZCk7XG4gICAgICBpZiAoZXhpc3RpbmcgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICB9XG4gICAgICBjb25maWdzLm9wdGltaXplQ29uZmlncyh0aGlzKTtcbiAgICAgIGxldCBuZXdTdGF0ZSA9IG5ldyBERkFTdGF0ZV8xLkRGQVN0YXRlKGNvbmZpZ3MuY2xvbmUodHJ1ZSkpO1xuICAgICAgbGV0IGZpcnN0Q29uZmlnV2l0aFJ1bGVTdG9wU3RhdGU7XG4gICAgICBmb3IgKGxldCBjIG9mIGNvbmZpZ3MpIHtcbiAgICAgICAgaWYgKGMuc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlXzEuUnVsZVN0b3BTdGF0ZSkge1xuICAgICAgICAgIGZpcnN0Q29uZmlnV2l0aFJ1bGVTdG9wU3RhdGUgPSBjO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZmlyc3RDb25maWdXaXRoUnVsZVN0b3BTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIGxldCBwcmVkaWN0aW9uID0gdGhpcy5hdG4ucnVsZVRvVG9rZW5UeXBlW2ZpcnN0Q29uZmlnV2l0aFJ1bGVTdG9wU3RhdGUuc3RhdGUucnVsZUluZGV4XTtcbiAgICAgICAgbGV0IGxleGVyQWN0aW9uRXhlY3V0b3IgPSBmaXJzdENvbmZpZ1dpdGhSdWxlU3RvcFN0YXRlLmxleGVyQWN0aW9uRXhlY3V0b3I7XG4gICAgICAgIG5ld1N0YXRlLmFjY2VwdFN0YXRlSW5mbyA9IG5ldyBBY2NlcHRTdGF0ZUluZm9fMS5BY2NlcHRTdGF0ZUluZm8ocHJlZGljdGlvbiwgbGV4ZXJBY3Rpb25FeGVjdXRvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5hdG4ubW9kZVRvREZBW3RoaXMubW9kZV0uYWRkU3RhdGUobmV3U3RhdGUpO1xuICAgIH1cbiAgICBnZXRERkEobW9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXRuLm1vZGVUb0RGQVttb2RlXTtcbiAgICB9XG4gICAgZ2V0VGV4dChpbnB1dCkge1xuICAgICAgcmV0dXJuIGlucHV0LmdldFRleHQoSW50ZXJ2YWxfMS5JbnRlcnZhbC5vZih0aGlzLnN0YXJ0SW5kZXgsIGlucHV0LmluZGV4IC0gMSkpO1xuICAgIH1cbiAgICBnZXQgbGluZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9saW5lO1xuICAgIH1cbiAgICBzZXQgbGluZShsaW5lKSB7XG4gICAgICB0aGlzLl9saW5lID0gbGluZTtcbiAgICB9XG4gICAgZ2V0IGNoYXJQb3NpdGlvbkluTGluZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaGFyUG9zaXRpb25JbkxpbmU7XG4gICAgfVxuICAgIHNldCBjaGFyUG9zaXRpb25JbkxpbmUoY2hhclBvc2l0aW9uSW5MaW5lKSB7XG4gICAgICB0aGlzLl9jaGFyUG9zaXRpb25JbkxpbmUgPSBjaGFyUG9zaXRpb25JbkxpbmU7XG4gICAgfVxuICAgIGNvbnN1bWUoaW5wdXQpIHtcbiAgICAgIGxldCBjdXJDaGFyID0gaW5wdXQuTEEoMSk7XG4gICAgICBpZiAoY3VyQ2hhciA9PT0gXCJcXG5cIi5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIHRoaXMuX2xpbmUrKztcbiAgICAgICAgdGhpcy5fY2hhclBvc2l0aW9uSW5MaW5lID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NoYXJQb3NpdGlvbkluTGluZSsrO1xuICAgICAgfVxuICAgICAgaW5wdXQuY29uc3VtZSgpO1xuICAgIH1cbiAgICBnZXRUb2tlbk5hbWUodCkge1xuICAgICAgaWYgKHQgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBcIkVPRlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiJ1wiICsgU3RyaW5nLmZyb21DaGFyQ29kZSh0KSArIFwiJ1wiO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgTGV4ZXJBVE5TaW11bGF0b3IyLnByb3RvdHlwZSwgXCJwcmV2QWNjZXB0XCIsIHZvaWQgMCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIExleGVyQVROU2ltdWxhdG9yMi5wcm90b3R5cGUsIFwiY29weVN0YXRlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBMZXhlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcIm1hdGNoXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJBVE5TaW11bGF0b3IyLnByb3RvdHlwZSwgXCJyZXNldFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgTGV4ZXJBVE5TaW11bGF0b3IyLnByb3RvdHlwZSwgXCJtYXRjaEFUTlwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgTGV4ZXJBVE5TaW11bGF0b3IyLnByb3RvdHlwZSwgXCJleGVjQVROXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBMZXhlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcImdldEV4aXN0aW5nVGFyZ2V0U3RhdGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsLFxuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMSwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIExleGVyQVROU2ltdWxhdG9yMi5wcm90b3R5cGUsIFwiY29tcHV0ZVRhcmdldFN0YXRlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDEsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDIsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBMZXhlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcImdldFJlYWNoYWJsZUNvbmZpZ1NldFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgTGV4ZXJBVE5TaW11bGF0b3IyLnByb3RvdHlwZSwgXCJhY2NlcHRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsLFxuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMSwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIExleGVyQVROU2ltdWxhdG9yMi5wcm90b3R5cGUsIFwiY29tcHV0ZVN0YXJ0U3RhdGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMSwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMiwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIExleGVyQVROU2ltdWxhdG9yMi5wcm90b3R5cGUsIFwiY2xvc3VyZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgyLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgzLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgTGV4ZXJBVE5TaW11bGF0b3IyLnByb3RvdHlwZSwgXCJnZXRFcHNpbG9uVGFyZ2V0XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBMZXhlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcImV2YWx1YXRlUHJlZGljYXRlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDEsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDIsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBMZXhlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcImNhcHR1cmVTaW1TdGF0ZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGwsXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgTGV4ZXJBVE5TaW11bGF0b3IyLnByb3RvdHlwZSwgXCJhZGRERkFTdGF0ZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgTGV4ZXJBVE5TaW11bGF0b3IyLnByb3RvdHlwZSwgXCJnZXRERkFcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsLFxuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIExleGVyQVROU2ltdWxhdG9yMi5wcm90b3R5cGUsIFwiZ2V0VGV4dFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgTGV4ZXJBVE5TaW11bGF0b3IyLnByb3RvdHlwZSwgXCJjb25zdW1lXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBMZXhlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcImdldFRva2VuTmFtZVwiLCBudWxsKTtcbiAgTGV4ZXJBVE5TaW11bGF0b3IyID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgTGV4ZXJBVE5TaW11bGF0b3IyKTtcbiAgZXhwb3J0cy5MZXhlckFUTlNpbXVsYXRvciA9IExleGVyQVROU2ltdWxhdG9yMjtcbiAgKGZ1bmN0aW9uKExleGVyQVROU2ltdWxhdG9yMykge1xuICAgIExleGVyQVROU2ltdWxhdG9yMy5kZWJ1ZyA9IGZhbHNlO1xuICAgIExleGVyQVROU2ltdWxhdG9yMy5kZmFfZGVidWcgPSBmYWxzZTtcbiAgICBjbGFzcyBTaW1TdGF0ZSB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IC0xO1xuICAgICAgICB0aGlzLmxpbmUgPSAwO1xuICAgICAgICB0aGlzLmNoYXJQb3MgPSAtMTtcbiAgICAgIH1cbiAgICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMubGluZSA9IDA7XG4gICAgICAgIHRoaXMuY2hhclBvcyA9IC0xO1xuICAgICAgICB0aGlzLmRmYVN0YXRlID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBMZXhlckFUTlNpbXVsYXRvcjMuU2ltU3RhdGUgPSBTaW1TdGF0ZTtcbiAgfSkoTGV4ZXJBVE5TaW11bGF0b3IyID0gZXhwb3J0cy5MZXhlckFUTlNpbXVsYXRvciB8fCAoZXhwb3J0cy5MZXhlckFUTlNpbXVsYXRvciA9IHt9KSk7XG4gIGV4cG9ydHMuTGV4ZXJBVE5TaW11bGF0b3IgPSBMZXhlckFUTlNpbXVsYXRvcjI7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL0xleGVyLmpzXG52YXIgcmVxdWlyZV9MZXhlciA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5MZXhlciA9IHZvaWQgMDtcbiAgdmFyIENvbW1vblRva2VuRmFjdG9yeV8xID0gcmVxdWlyZV9Db21tb25Ub2tlbkZhY3RvcnkoKTtcbiAgdmFyIEludGVnZXJTdGFja18xID0gcmVxdWlyZV9JbnRlZ2VyU3RhY2soKTtcbiAgdmFyIEludGVydmFsXzEgPSByZXF1aXJlX0ludGVydmFsKCk7XG4gIHZhciBJbnRTdHJlYW1fMSA9IHJlcXVpcmVfSW50U3RyZWFtKCk7XG4gIHZhciBMZXhlckFUTlNpbXVsYXRvcl8xID0gcmVxdWlyZV9MZXhlckFUTlNpbXVsYXRvcigpO1xuICB2YXIgTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbl8xID0gcmVxdWlyZV9MZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIFJlY29nbml6ZXJfMSA9IHJlcXVpcmVfUmVjb2duaXplcigpO1xuICB2YXIgVG9rZW5fMSA9IHJlcXVpcmVfVG9rZW4oKTtcbiAgdmFyIExleGVyMiA9IGNsYXNzIGV4dGVuZHMgUmVjb2duaXplcl8xLlJlY29nbml6ZXIge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5fZmFjdG9yeSA9IENvbW1vblRva2VuRmFjdG9yeV8xLkNvbW1vblRva2VuRmFjdG9yeS5ERUZBVUxUO1xuICAgICAgdGhpcy5fdG9rZW5TdGFydENoYXJJbmRleCA9IC0xO1xuICAgICAgdGhpcy5fdG9rZW5TdGFydExpbmUgPSAwO1xuICAgICAgdGhpcy5fdG9rZW5TdGFydENoYXJQb3NpdGlvbkluTGluZSA9IDA7XG4gICAgICB0aGlzLl9oaXRFT0YgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2NoYW5uZWwgPSAwO1xuICAgICAgdGhpcy5fdHlwZSA9IDA7XG4gICAgICB0aGlzLl9tb2RlU3RhY2sgPSBuZXcgSW50ZWdlclN0YWNrXzEuSW50ZWdlclN0YWNrKCk7XG4gICAgICB0aGlzLl9tb2RlID0gTGV4ZXIyLkRFRkFVTFRfTU9ERTtcbiAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgICB0aGlzLl90b2tlbkZhY3RvcnlTb3VyY2VQYWlyID0ge3NvdXJjZTogdGhpcywgc3RyZWFtOiBpbnB1dH07XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgREVGQVVMVF9UT0tFTl9DSEFOTkVMKCkge1xuICAgICAgcmV0dXJuIFRva2VuXzEuVG9rZW4uREVGQVVMVF9DSEFOTkVMO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IEhJRERFTigpIHtcbiAgICAgIHJldHVybiBUb2tlbl8xLlRva2VuLkhJRERFTl9DSEFOTkVMO1xuICAgIH1cbiAgICByZXNldChyZXNldElucHV0KSB7XG4gICAgICBpZiAocmVzZXRJbnB1dCA9PT0gdm9pZCAwIHx8IHJlc2V0SW5wdXQpIHtcbiAgICAgICAgdGhpcy5faW5wdXQuc2VlaygwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Rva2VuID0gdm9pZCAwO1xuICAgICAgdGhpcy5fdHlwZSA9IFRva2VuXzEuVG9rZW4uSU5WQUxJRF9UWVBFO1xuICAgICAgdGhpcy5fY2hhbm5lbCA9IFRva2VuXzEuVG9rZW4uREVGQVVMVF9DSEFOTkVMO1xuICAgICAgdGhpcy5fdG9rZW5TdGFydENoYXJJbmRleCA9IC0xO1xuICAgICAgdGhpcy5fdG9rZW5TdGFydENoYXJQb3NpdGlvbkluTGluZSA9IC0xO1xuICAgICAgdGhpcy5fdG9rZW5TdGFydExpbmUgPSAtMTtcbiAgICAgIHRoaXMuX3RleHQgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9oaXRFT0YgPSBmYWxzZTtcbiAgICAgIHRoaXMuX21vZGUgPSBMZXhlcjIuREVGQVVMVF9NT0RFO1xuICAgICAgdGhpcy5fbW9kZVN0YWNrLmNsZWFyKCk7XG4gICAgICB0aGlzLmludGVycHJldGVyLnJlc2V0KCk7XG4gICAgfVxuICAgIG5leHRUb2tlbigpIHtcbiAgICAgIGlmICh0aGlzLl9pbnB1dCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5leHRUb2tlbiByZXF1aXJlcyBhIG5vbi1udWxsIGlucHV0IHN0cmVhbS5cIik7XG4gICAgICB9XG4gICAgICBsZXQgdG9rZW5TdGFydE1hcmtlciA9IHRoaXMuX2lucHV0Lm1hcmsoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG91dGVyOlxuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faGl0RU9GKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXRFT0YoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gdm9pZCAwO1xuICAgICAgICAgICAgdGhpcy5fY2hhbm5lbCA9IFRva2VuXzEuVG9rZW4uREVGQVVMVF9DSEFOTkVMO1xuICAgICAgICAgICAgdGhpcy5fdG9rZW5TdGFydENoYXJJbmRleCA9IHRoaXMuX2lucHV0LmluZGV4O1xuICAgICAgICAgICAgdGhpcy5fdG9rZW5TdGFydENoYXJQb3NpdGlvbkluTGluZSA9IHRoaXMuaW50ZXJwcmV0ZXIuY2hhclBvc2l0aW9uSW5MaW5lO1xuICAgICAgICAgICAgdGhpcy5fdG9rZW5TdGFydExpbmUgPSB0aGlzLmludGVycHJldGVyLmxpbmU7XG4gICAgICAgICAgICB0aGlzLl90ZXh0ID0gdm9pZCAwO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICB0aGlzLl90eXBlID0gVG9rZW5fMS5Ub2tlbi5JTlZBTElEX1RZUEU7XG4gICAgICAgICAgICAgIGxldCB0dHlwZTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0dHlwZSA9IHRoaXMuaW50ZXJwcmV0ZXIubWF0Y2godGhpcy5faW5wdXQsIHRoaXMuX21vZGUpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uXzEuTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoZSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLnJlY292ZXIoZSk7XG4gICAgICAgICAgICAgICAgICB0dHlwZSA9IExleGVyMi5TS0lQO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5faW5wdXQuTEEoMSkgPT09IEludFN0cmVhbV8xLkludFN0cmVhbS5FT0YpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaXRFT0YgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLl90eXBlID09PSBUb2tlbl8xLlRva2VuLklOVkFMSURfVFlQRSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3R5cGUgPSB0dHlwZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5fdHlwZSA9PT0gTGV4ZXIyLlNLSVApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5fdHlwZSA9PT0gTGV4ZXIyLk1PUkUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Rva2VuID09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuO1xuICAgICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2lucHV0LnJlbGVhc2UodG9rZW5TdGFydE1hcmtlcik7XG4gICAgICB9XG4gICAgfVxuICAgIHNraXAoKSB7XG4gICAgICB0aGlzLl90eXBlID0gTGV4ZXIyLlNLSVA7XG4gICAgfVxuICAgIG1vcmUoKSB7XG4gICAgICB0aGlzLl90eXBlID0gTGV4ZXIyLk1PUkU7XG4gICAgfVxuICAgIG1vZGUobSkge1xuICAgICAgdGhpcy5fbW9kZSA9IG07XG4gICAgfVxuICAgIHB1c2hNb2RlKG0pIHtcbiAgICAgIGlmIChMZXhlckFUTlNpbXVsYXRvcl8xLkxleGVyQVROU2ltdWxhdG9yLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwicHVzaE1vZGUgXCIgKyBtKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21vZGVTdGFjay5wdXNoKHRoaXMuX21vZGUpO1xuICAgICAgdGhpcy5tb2RlKG0pO1xuICAgIH1cbiAgICBwb3BNb2RlKCkge1xuICAgICAgaWYgKHRoaXMuX21vZGVTdGFjay5pc0VtcHR5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVtcHR5U3RhY2tFeGNlcHRpb25cIik7XG4gICAgICB9XG4gICAgICBpZiAoTGV4ZXJBVE5TaW11bGF0b3JfMS5MZXhlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcInBvcE1vZGUgYmFjayB0byBcIiArIHRoaXMuX21vZGVTdGFjay5wZWVrKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5tb2RlKHRoaXMuX21vZGVTdGFjay5wb3AoKSk7XG4gICAgICByZXR1cm4gdGhpcy5fbW9kZTtcbiAgICB9XG4gICAgZ2V0IHRva2VuRmFjdG9yeSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mYWN0b3J5O1xuICAgIH1cbiAgICBzZXQgdG9rZW5GYWN0b3J5KGZhY3RvcnkpIHtcbiAgICAgIHRoaXMuX2ZhY3RvcnkgPSBmYWN0b3J5O1xuICAgIH1cbiAgICBnZXQgaW5wdXRTdHJlYW0oKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5wdXQ7XG4gICAgfVxuICAgIHNldCBpbnB1dFN0cmVhbShpbnB1dCkge1xuICAgICAgdGhpcy5yZXNldChmYWxzZSk7XG4gICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICAgICAgdGhpcy5fdG9rZW5GYWN0b3J5U291cmNlUGFpciA9IHtzb3VyY2U6IHRoaXMsIHN0cmVhbTogdGhpcy5faW5wdXR9O1xuICAgIH1cbiAgICBnZXQgc291cmNlTmFtZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbnB1dC5zb3VyY2VOYW1lO1xuICAgIH1cbiAgICBlbWl0KHRva2VuKSB7XG4gICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgIHRva2VuID0gdGhpcy5fZmFjdG9yeS5jcmVhdGUodGhpcy5fdG9rZW5GYWN0b3J5U291cmNlUGFpciwgdGhpcy5fdHlwZSwgdGhpcy5fdGV4dCwgdGhpcy5fY2hhbm5lbCwgdGhpcy5fdG9rZW5TdGFydENoYXJJbmRleCwgdGhpcy5jaGFySW5kZXggLSAxLCB0aGlzLl90b2tlblN0YXJ0TGluZSwgdGhpcy5fdG9rZW5TdGFydENoYXJQb3NpdGlvbkluTGluZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl90b2tlbiA9IHRva2VuO1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgICBlbWl0RU9GKCkge1xuICAgICAgbGV0IGNwb3MgPSB0aGlzLmNoYXJQb3NpdGlvbkluTGluZTtcbiAgICAgIGxldCBsaW5lID0gdGhpcy5saW5lO1xuICAgICAgbGV0IGVvZiA9IHRoaXMuX2ZhY3RvcnkuY3JlYXRlKHRoaXMuX3Rva2VuRmFjdG9yeVNvdXJjZVBhaXIsIFRva2VuXzEuVG9rZW4uRU9GLCB2b2lkIDAsIFRva2VuXzEuVG9rZW4uREVGQVVMVF9DSEFOTkVMLCB0aGlzLl9pbnB1dC5pbmRleCwgdGhpcy5faW5wdXQuaW5kZXggLSAxLCBsaW5lLCBjcG9zKTtcbiAgICAgIHRoaXMuZW1pdChlb2YpO1xuICAgICAgcmV0dXJuIGVvZjtcbiAgICB9XG4gICAgZ2V0IGxpbmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnRlcnByZXRlci5saW5lO1xuICAgIH1cbiAgICBzZXQgbGluZShsaW5lKSB7XG4gICAgICB0aGlzLmludGVycHJldGVyLmxpbmUgPSBsaW5lO1xuICAgIH1cbiAgICBnZXQgY2hhclBvc2l0aW9uSW5MaW5lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJwcmV0ZXIuY2hhclBvc2l0aW9uSW5MaW5lO1xuICAgIH1cbiAgICBzZXQgY2hhclBvc2l0aW9uSW5MaW5lKGNoYXJQb3NpdGlvbkluTGluZSkge1xuICAgICAgdGhpcy5pbnRlcnByZXRlci5jaGFyUG9zaXRpb25JbkxpbmUgPSBjaGFyUG9zaXRpb25JbkxpbmU7XG4gICAgfVxuICAgIGdldCBjaGFySW5kZXgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5wdXQuaW5kZXg7XG4gICAgfVxuICAgIGdldCB0ZXh0KCkge1xuICAgICAgaWYgKHRoaXMuX3RleHQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmludGVycHJldGVyLmdldFRleHQodGhpcy5faW5wdXQpO1xuICAgIH1cbiAgICBzZXQgdGV4dCh0ZXh0KSB7XG4gICAgICB0aGlzLl90ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgZ2V0IHRva2VuKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuO1xuICAgIH1cbiAgICBzZXQgdG9rZW4oX3Rva2VuKSB7XG4gICAgICB0aGlzLl90b2tlbiA9IF90b2tlbjtcbiAgICB9XG4gICAgc2V0IHR5cGUodHR5cGUpIHtcbiAgICAgIHRoaXMuX3R5cGUgPSB0dHlwZTtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICB9XG4gICAgc2V0IGNoYW5uZWwoY2hhbm5lbCkge1xuICAgICAgdGhpcy5fY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgfVxuICAgIGdldCBjaGFubmVsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NoYW5uZWw7XG4gICAgfVxuICAgIGdldEFsbFRva2VucygpIHtcbiAgICAgIGxldCB0b2tlbnMyID0gW107XG4gICAgICBsZXQgdCA9IHRoaXMubmV4dFRva2VuKCk7XG4gICAgICB3aGlsZSAodC50eXBlICE9PSBUb2tlbl8xLlRva2VuLkVPRikge1xuICAgICAgICB0b2tlbnMyLnB1c2godCk7XG4gICAgICAgIHQgPSB0aGlzLm5leHRUb2tlbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRva2VuczI7XG4gICAgfVxuICAgIG5vdGlmeUxpc3RlbmVycyhlKSB7XG4gICAgICBsZXQgdGV4dCA9IHRoaXMuX2lucHV0LmdldFRleHQoSW50ZXJ2YWxfMS5JbnRlcnZhbC5vZih0aGlzLl90b2tlblN0YXJ0Q2hhckluZGV4LCB0aGlzLl9pbnB1dC5pbmRleCkpO1xuICAgICAgbGV0IG1zZyA9IFwidG9rZW4gcmVjb2duaXRpb24gZXJyb3IgYXQ6ICdcIiArIHRoaXMuZ2V0RXJyb3JEaXNwbGF5KHRleHQpICsgXCInXCI7XG4gICAgICBsZXQgbGlzdGVuZXIgPSB0aGlzLmdldEVycm9yTGlzdGVuZXJEaXNwYXRjaCgpO1xuICAgICAgaWYgKGxpc3RlbmVyLnN5bnRheEVycm9yKSB7XG4gICAgICAgIGxpc3RlbmVyLnN5bnRheEVycm9yKHRoaXMsIHZvaWQgMCwgdGhpcy5fdG9rZW5TdGFydExpbmUsIHRoaXMuX3Rva2VuU3RhcnRDaGFyUG9zaXRpb25JbkxpbmUsIG1zZywgZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGdldEVycm9yRGlzcGxheShzKSB7XG4gICAgICBpZiAodHlwZW9mIHMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgc3dpdGNoIChzKSB7XG4gICAgICAgICAgY2FzZSBUb2tlbl8xLlRva2VuLkVPRjpcbiAgICAgICAgICAgIHJldHVybiBcIjxFT0Y+XCI7XG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHJldHVybiBcIlxcXFxuXCI7XG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHRcIjtcbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLnJlcGxhY2UoL1xcdC9nLCBcIlxcXFx0XCIpLnJlcGxhY2UoL1xcci9nLCBcIlxcXFxyXCIpO1xuICAgIH1cbiAgICBnZXRDaGFyRXJyb3JEaXNwbGF5KGMpIHtcbiAgICAgIGxldCBzID0gdGhpcy5nZXRFcnJvckRpc3BsYXkoYyk7XG4gICAgICByZXR1cm4gXCInXCIgKyBzICsgXCInXCI7XG4gICAgfVxuICAgIHJlY292ZXIocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIExleGVyTm9WaWFibGVBbHRFeGNlcHRpb25fMS5MZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dC5MQSgxKSAhPT0gSW50U3RyZWFtXzEuSW50U3RyZWFtLkVPRikge1xuICAgICAgICAgIHRoaXMuaW50ZXJwcmV0ZXIuY29uc3VtZSh0aGlzLl9pbnB1dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lucHV0LmNvbnN1bWUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIExleGVyMi5ERUZBVUxUX01PREUgPSAwO1xuICBMZXhlcjIuTU9SRSA9IC0yO1xuICBMZXhlcjIuU0tJUCA9IC0zO1xuICBMZXhlcjIuTUlOX0NIQVJfVkFMVUUgPSAwO1xuICBMZXhlcjIuTUFYX0NIQVJfVkFMVUUgPSAxMTE0MTExO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXIyLnByb3RvdHlwZSwgXCJuZXh0VG9rZW5cIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBMZXhlcjIucHJvdG90eXBlLCBcInRva2VuRmFjdG9yeVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExleGVyMi5wcm90b3R5cGUsIFwiaW5wdXRTdHJlYW1cIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBMZXhlcjIucHJvdG90eXBlLCBcInNvdXJjZU5hbWVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBMZXhlcjIucHJvdG90eXBlLCBcImxpbmVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBMZXhlcjIucHJvdG90eXBlLCBcImNoYXJQb3NpdGlvbkluTGluZVwiLCBudWxsKTtcbiAgZXhwb3J0cy5MZXhlciA9IExleGVyMjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvbWlzYy9JbnRlcnZhbFNldC5qc1xudmFyIHJlcXVpcmVfSW50ZXJ2YWxTZXQgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuSW50ZXJ2YWxTZXQgPSB2b2lkIDA7XG4gIHZhciBBcnJheUVxdWFsaXR5Q29tcGFyYXRvcl8xID0gcmVxdWlyZV9BcnJheUVxdWFsaXR5Q29tcGFyYXRvcigpO1xuICB2YXIgSW50ZWdlckxpc3RfMSA9IHJlcXVpcmVfSW50ZWdlckxpc3QoKTtcbiAgdmFyIEludGVydmFsXzEgPSByZXF1aXJlX0ludGVydmFsKCk7XG4gIHZhciBMZXhlcl8xID0gcmVxdWlyZV9MZXhlcigpO1xuICB2YXIgTXVybXVySGFzaF8xID0gcmVxdWlyZV9NdXJtdXJIYXNoKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIFRva2VuXzEgPSByZXF1aXJlX1Rva2VuKCk7XG4gIHZhciBJbnRlcnZhbFNldCA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihpbnRlcnZhbHMpIHtcbiAgICAgIHRoaXMucmVhZG9ubHkgPSBmYWxzZTtcbiAgICAgIGlmIChpbnRlcnZhbHMgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9pbnRlcnZhbHMgPSBpbnRlcnZhbHMuc2xpY2UoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbnRlcnZhbHMgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldCBDT01QTEVURV9DSEFSX1NFVCgpIHtcbiAgICAgIGlmIChJbnRlcnZhbFNldC5fQ09NUExFVEVfQ0hBUl9TRVQgPT09IHZvaWQgMCkge1xuICAgICAgICBJbnRlcnZhbFNldC5fQ09NUExFVEVfQ0hBUl9TRVQgPSBJbnRlcnZhbFNldC5vZihMZXhlcl8xLkxleGVyLk1JTl9DSEFSX1ZBTFVFLCBMZXhlcl8xLkxleGVyLk1BWF9DSEFSX1ZBTFVFKTtcbiAgICAgICAgSW50ZXJ2YWxTZXQuX0NPTVBMRVRFX0NIQVJfU0VULnNldFJlYWRvbmx5KHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEludGVydmFsU2V0Ll9DT01QTEVURV9DSEFSX1NFVDtcbiAgICB9XG4gICAgc3RhdGljIGdldCBFTVBUWV9TRVQoKSB7XG4gICAgICBpZiAoSW50ZXJ2YWxTZXQuX0VNUFRZX1NFVCA9PSBudWxsKSB7XG4gICAgICAgIEludGVydmFsU2V0Ll9FTVBUWV9TRVQgPSBuZXcgSW50ZXJ2YWxTZXQoKTtcbiAgICAgICAgSW50ZXJ2YWxTZXQuX0VNUFRZX1NFVC5zZXRSZWFkb25seSh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBJbnRlcnZhbFNldC5fRU1QVFlfU0VUO1xuICAgIH1cbiAgICBzdGF0aWMgb2YoYSwgYiA9IGEpIHtcbiAgICAgIGxldCBzID0gbmV3IEludGVydmFsU2V0KCk7XG4gICAgICBzLmFkZChhLCBiKTtcbiAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgIGlmICh0aGlzLnJlYWRvbmx5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbid0IGFsdGVyIHJlYWRvbmx5IEludGVydmFsU2V0XCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5faW50ZXJ2YWxzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGFkZChhLCBiID0gYSkge1xuICAgICAgdGhpcy5hZGRSYW5nZShJbnRlcnZhbF8xLkludGVydmFsLm9mKGEsIGIpKTtcbiAgICB9XG4gICAgYWRkUmFuZ2UoYWRkaXRpb24pIHtcbiAgICAgIGlmICh0aGlzLnJlYWRvbmx5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbid0IGFsdGVyIHJlYWRvbmx5IEludGVydmFsU2V0XCIpO1xuICAgICAgfVxuICAgICAgaWYgKGFkZGl0aW9uLmIgPCBhZGRpdGlvbi5hKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faW50ZXJ2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCByID0gdGhpcy5faW50ZXJ2YWxzW2ldO1xuICAgICAgICBpZiAoYWRkaXRpb24uZXF1YWxzKHIpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRpdGlvbi5hZGphY2VudChyKSB8fCAhYWRkaXRpb24uZGlzam9pbnQocikpIHtcbiAgICAgICAgICBsZXQgYmlnZ2VyID0gYWRkaXRpb24udW5pb24ocik7XG4gICAgICAgICAgdGhpcy5faW50ZXJ2YWxzW2ldID0gYmlnZ2VyO1xuICAgICAgICAgIHdoaWxlIChpIDwgdGhpcy5faW50ZXJ2YWxzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5faW50ZXJ2YWxzW2ldO1xuICAgICAgICAgICAgaWYgKCFiaWdnZXIuYWRqYWNlbnQobmV4dCkgJiYgYmlnZ2VyLmRpc2pvaW50KG5leHQpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWxzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIHRoaXMuX2ludGVydmFsc1tpXSA9IGJpZ2dlci51bmlvbihuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRpdGlvbi5zdGFydHNCZWZvcmVEaXNqb2ludChyKSkge1xuICAgICAgICAgIHRoaXMuX2ludGVydmFscy5zcGxpY2UoaSwgMCwgYWRkaXRpb24pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faW50ZXJ2YWxzLnB1c2goYWRkaXRpb24pO1xuICAgIH1cbiAgICBzdGF0aWMgb3Ioc2V0cykge1xuICAgICAgbGV0IHIgPSBuZXcgSW50ZXJ2YWxTZXQoKTtcbiAgICAgIGZvciAobGV0IHMgb2Ygc2V0cykge1xuICAgICAgICByLmFkZEFsbChzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICBhZGRBbGwoc2V0KSB7XG4gICAgICBpZiAoc2V0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAoc2V0IGluc3RhbmNlb2YgSW50ZXJ2YWxTZXQpIHtcbiAgICAgICAgbGV0IG90aGVyID0gc2V0O1xuICAgICAgICBsZXQgbiA9IG90aGVyLl9pbnRlcnZhbHMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIGxldCBJID0gb3RoZXIuX2ludGVydmFsc1tpXTtcbiAgICAgICAgICB0aGlzLmFkZChJLmEsIEkuYik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IHZhbHVlIG9mIHNldC50b0FycmF5KCkpIHtcbiAgICAgICAgICB0aGlzLmFkZCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb21wbGVtZW50UmFuZ2UobWluRWxlbWVudCwgbWF4RWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGxlbWVudChJbnRlcnZhbFNldC5vZihtaW5FbGVtZW50LCBtYXhFbGVtZW50KSk7XG4gICAgfVxuICAgIGNvbXBsZW1lbnQodm9jYWJ1bGFyeSkge1xuICAgICAgaWYgKHZvY2FidWxhcnkuaXNOaWwpIHtcbiAgICAgICAgcmV0dXJuIEludGVydmFsU2V0LkVNUFRZX1NFVDtcbiAgICAgIH1cbiAgICAgIGxldCB2b2NhYnVsYXJ5SVM7XG4gICAgICBpZiAodm9jYWJ1bGFyeSBpbnN0YW5jZW9mIEludGVydmFsU2V0KSB7XG4gICAgICAgIHZvY2FidWxhcnlJUyA9IHZvY2FidWxhcnk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2b2NhYnVsYXJ5SVMgPSBuZXcgSW50ZXJ2YWxTZXQoKTtcbiAgICAgICAgdm9jYWJ1bGFyeUlTLmFkZEFsbCh2b2NhYnVsYXJ5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2NhYnVsYXJ5SVMuc3VidHJhY3QodGhpcyk7XG4gICAgfVxuICAgIHN1YnRyYWN0KGEpIHtcbiAgICAgIGlmIChhID09IG51bGwgfHwgYS5pc05pbCkge1xuICAgICAgICByZXR1cm4gbmV3IEludGVydmFsU2V0KHRoaXMuX2ludGVydmFscyk7XG4gICAgICB9XG4gICAgICBpZiAoYSBpbnN0YW5jZW9mIEludGVydmFsU2V0KSB7XG4gICAgICAgIHJldHVybiBJbnRlcnZhbFNldC5zdWJ0cmFjdCh0aGlzLCBhKTtcbiAgICAgIH1cbiAgICAgIGxldCBvdGhlciA9IG5ldyBJbnRlcnZhbFNldCgpO1xuICAgICAgb3RoZXIuYWRkQWxsKGEpO1xuICAgICAgcmV0dXJuIEludGVydmFsU2V0LnN1YnRyYWN0KHRoaXMsIG90aGVyKTtcbiAgICB9XG4gICAgc3RhdGljIHN1YnRyYWN0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICBpZiAobGVmdC5pc05pbCkge1xuICAgICAgICByZXR1cm4gbmV3IEludGVydmFsU2V0KCk7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdWx0ID0gbmV3IEludGVydmFsU2V0KGxlZnQuX2ludGVydmFscyk7XG4gICAgICBpZiAocmlnaHQuaXNOaWwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGxldCByZXN1bHRJID0gMDtcbiAgICAgIGxldCByaWdodEkgPSAwO1xuICAgICAgd2hpbGUgKHJlc3VsdEkgPCByZXN1bHQuX2ludGVydmFscy5sZW5ndGggJiYgcmlnaHRJIDwgcmlnaHQuX2ludGVydmFscy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHJlc3VsdEludGVydmFsID0gcmVzdWx0Ll9pbnRlcnZhbHNbcmVzdWx0SV07XG4gICAgICAgIGxldCByaWdodEludGVydmFsID0gcmlnaHQuX2ludGVydmFsc1tyaWdodEldO1xuICAgICAgICBpZiAocmlnaHRJbnRlcnZhbC5iIDwgcmVzdWx0SW50ZXJ2YWwuYSkge1xuICAgICAgICAgIHJpZ2h0SSsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodEludGVydmFsLmEgPiByZXN1bHRJbnRlcnZhbC5iKSB7XG4gICAgICAgICAgcmVzdWx0SSsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBiZWZvcmVDdXJyZW50O1xuICAgICAgICBsZXQgYWZ0ZXJDdXJyZW50O1xuICAgICAgICBpZiAocmlnaHRJbnRlcnZhbC5hID4gcmVzdWx0SW50ZXJ2YWwuYSkge1xuICAgICAgICAgIGJlZm9yZUN1cnJlbnQgPSBuZXcgSW50ZXJ2YWxfMS5JbnRlcnZhbChyZXN1bHRJbnRlcnZhbC5hLCByaWdodEludGVydmFsLmEgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmlnaHRJbnRlcnZhbC5iIDwgcmVzdWx0SW50ZXJ2YWwuYikge1xuICAgICAgICAgIGFmdGVyQ3VycmVudCA9IG5ldyBJbnRlcnZhbF8xLkludGVydmFsKHJpZ2h0SW50ZXJ2YWwuYiArIDEsIHJlc3VsdEludGVydmFsLmIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiZWZvcmVDdXJyZW50KSB7XG4gICAgICAgICAgaWYgKGFmdGVyQ3VycmVudCkge1xuICAgICAgICAgICAgcmVzdWx0Ll9pbnRlcnZhbHNbcmVzdWx0SV0gPSBiZWZvcmVDdXJyZW50O1xuICAgICAgICAgICAgcmVzdWx0Ll9pbnRlcnZhbHMuc3BsaWNlKHJlc3VsdEkgKyAxLCAwLCBhZnRlckN1cnJlbnQpO1xuICAgICAgICAgICAgcmVzdWx0SSsrO1xuICAgICAgICAgICAgcmlnaHRJKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0Ll9pbnRlcnZhbHNbcmVzdWx0SV0gPSBiZWZvcmVDdXJyZW50O1xuICAgICAgICAgICAgcmVzdWx0SSsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhZnRlckN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5faW50ZXJ2YWxzW3Jlc3VsdEldID0gYWZ0ZXJDdXJyZW50O1xuICAgICAgICAgICAgcmlnaHRJKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0Ll9pbnRlcnZhbHMuc3BsaWNlKHJlc3VsdEksIDEpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBvcihhKSB7XG4gICAgICBsZXQgbyA9IG5ldyBJbnRlcnZhbFNldCgpO1xuICAgICAgby5hZGRBbGwodGhpcyk7XG4gICAgICBvLmFkZEFsbChhKTtcbiAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgICBhbmQob3RoZXIpIHtcbiAgICAgIGlmIChvdGhlci5pc05pbCkge1xuICAgICAgICByZXR1cm4gbmV3IEludGVydmFsU2V0KCk7XG4gICAgICB9XG4gICAgICBsZXQgbXlJbnRlcnZhbHMgPSB0aGlzLl9pbnRlcnZhbHM7XG4gICAgICBsZXQgdGhlaXJJbnRlcnZhbHMgPSBvdGhlci5faW50ZXJ2YWxzO1xuICAgICAgbGV0IGludGVyc2VjdGlvbjtcbiAgICAgIGxldCBteVNpemUgPSBteUludGVydmFscy5sZW5ndGg7XG4gICAgICBsZXQgdGhlaXJTaXplID0gdGhlaXJJbnRlcnZhbHMubGVuZ3RoO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgbGV0IGogPSAwO1xuICAgICAgd2hpbGUgKGkgPCBteVNpemUgJiYgaiA8IHRoZWlyU2l6ZSkge1xuICAgICAgICBsZXQgbWluZSA9IG15SW50ZXJ2YWxzW2ldO1xuICAgICAgICBsZXQgdGhlaXJzID0gdGhlaXJJbnRlcnZhbHNbal07XG4gICAgICAgIGlmIChtaW5lLnN0YXJ0c0JlZm9yZURpc2pvaW50KHRoZWlycykpIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH0gZWxzZSBpZiAodGhlaXJzLnN0YXJ0c0JlZm9yZURpc2pvaW50KG1pbmUpKSB7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9IGVsc2UgaWYgKG1pbmUucHJvcGVybHlDb250YWlucyh0aGVpcnMpKSB7XG4gICAgICAgICAgaWYgKCFpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvbiA9IG5ldyBJbnRlcnZhbFNldCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnRlcnNlY3Rpb24uYWRkUmFuZ2UobWluZS5pbnRlcnNlY3Rpb24odGhlaXJzKSk7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9IGVsc2UgaWYgKHRoZWlycy5wcm9wZXJseUNvbnRhaW5zKG1pbmUpKSB7XG4gICAgICAgICAgaWYgKCFpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvbiA9IG5ldyBJbnRlcnZhbFNldCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnRlcnNlY3Rpb24uYWRkUmFuZ2UobWluZS5pbnRlcnNlY3Rpb24odGhlaXJzKSk7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9IGVsc2UgaWYgKCFtaW5lLmRpc2pvaW50KHRoZWlycykpIHtcbiAgICAgICAgICBpZiAoIWludGVyc2VjdGlvbikge1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uID0gbmV3IEludGVydmFsU2V0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGludGVyc2VjdGlvbi5hZGRSYW5nZShtaW5lLmludGVyc2VjdGlvbih0aGVpcnMpKTtcbiAgICAgICAgICBpZiAobWluZS5zdGFydHNBZnRlck5vbkRpc2pvaW50KHRoZWlycykpIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZWlycy5zdGFydHNBZnRlck5vbkRpc2pvaW50KG1pbmUpKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWludGVyc2VjdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IEludGVydmFsU2V0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW50ZXJzZWN0aW9uO1xuICAgIH1cbiAgICBjb250YWlucyhlbCkge1xuICAgICAgbGV0IG4gPSB0aGlzLl9pbnRlcnZhbHMubGVuZ3RoO1xuICAgICAgbGV0IGwgPSAwO1xuICAgICAgbGV0IHIgPSBuIC0gMTtcbiAgICAgIHdoaWxlIChsIDw9IHIpIHtcbiAgICAgICAgbGV0IG0gPSBsICsgciA+PiAxO1xuICAgICAgICBsZXQgSSA9IHRoaXMuX2ludGVydmFsc1ttXTtcbiAgICAgICAgbGV0IGEgPSBJLmE7XG4gICAgICAgIGxldCBiID0gSS5iO1xuICAgICAgICBpZiAoYiA8IGVsKSB7XG4gICAgICAgICAgbCA9IG0gKyAxO1xuICAgICAgICB9IGVsc2UgaWYgKGEgPiBlbCkge1xuICAgICAgICAgIHIgPSBtIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgaXNOaWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW50ZXJ2YWxzID09IG51bGwgfHwgdGhpcy5faW50ZXJ2YWxzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgZ2V0IG1heEVsZW1lbnQoKSB7XG4gICAgICBpZiAodGhpcy5pc05pbCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNldCBpcyBlbXB0eVwiKTtcbiAgICAgIH1cbiAgICAgIGxldCBsYXN0ID0gdGhpcy5faW50ZXJ2YWxzW3RoaXMuX2ludGVydmFscy5sZW5ndGggLSAxXTtcbiAgICAgIHJldHVybiBsYXN0LmI7XG4gICAgfVxuICAgIGdldCBtaW5FbGVtZW50KCkge1xuICAgICAgaWYgKHRoaXMuaXNOaWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzZXQgaXMgZW1wdHlcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5faW50ZXJ2YWxzWzBdLmE7XG4gICAgfVxuICAgIGdldCBpbnRlcnZhbHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW50ZXJ2YWxzO1xuICAgIH1cbiAgICBoYXNoQ29kZSgpIHtcbiAgICAgIGxldCBoYXNoID0gTXVybXVySGFzaF8xLk11cm11ckhhc2guaW5pdGlhbGl6ZSgpO1xuICAgICAgZm9yIChsZXQgSSBvZiB0aGlzLl9pbnRlcnZhbHMpIHtcbiAgICAgICAgaGFzaCA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCBJLmEpO1xuICAgICAgICBoYXNoID0gTXVybXVySGFzaF8xLk11cm11ckhhc2gudXBkYXRlKGhhc2gsIEkuYik7XG4gICAgICB9XG4gICAgICBoYXNoID0gTXVybXVySGFzaF8xLk11cm11ckhhc2guZmluaXNoKGhhc2gsIHRoaXMuX2ludGVydmFscy5sZW5ndGggKiAyKTtcbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgICBlcXVhbHMobykge1xuICAgICAgaWYgKG8gPT0gbnVsbCB8fCAhKG8gaW5zdGFuY2VvZiBJbnRlcnZhbFNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFycmF5RXF1YWxpdHlDb21wYXJhdG9yXzEuQXJyYXlFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UuZXF1YWxzKHRoaXMuX2ludGVydmFscywgby5faW50ZXJ2YWxzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoZWxlbUFyZUNoYXIgPSBmYWxzZSkge1xuICAgICAgbGV0IGJ1ZiA9IFwiXCI7XG4gICAgICBpZiAodGhpcy5faW50ZXJ2YWxzID09IG51bGwgfHwgdGhpcy5faW50ZXJ2YWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gXCJ7fVwiO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2l6ZSA+IDEpIHtcbiAgICAgICAgYnVmICs9IFwie1wiO1xuICAgICAgfVxuICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICAgIGZvciAobGV0IEkgb2YgdGhpcy5faW50ZXJ2YWxzKSB7XG4gICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmICs9IFwiLCBcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYSA9IEkuYTtcbiAgICAgICAgbGV0IGIgPSBJLmI7XG4gICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgaWYgKGEgPT09IFRva2VuXzEuVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICBidWYgKz0gXCI8RU9GPlwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbUFyZUNoYXIpIHtcbiAgICAgICAgICAgIGJ1ZiArPSBcIidcIiArIFN0cmluZy5mcm9tQ29kZVBvaW50KGEpICsgXCInXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZiArPSBhO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZWxlbUFyZUNoYXIpIHtcbiAgICAgICAgICAgIGJ1ZiArPSBcIidcIiArIFN0cmluZy5mcm9tQ29kZVBvaW50KGEpICsgXCInLi4nXCIgKyBTdHJpbmcuZnJvbUNvZGVQb2ludChiKSArIFwiJ1wiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWYgKz0gYSArIFwiLi5cIiArIGI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaXplID4gMSkge1xuICAgICAgICBidWYgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICB0b1N0cmluZ1ZvY2FidWxhcnkodm9jYWJ1bGFyeSkge1xuICAgICAgaWYgKHRoaXMuX2ludGVydmFscyA9PSBudWxsIHx8IHRoaXMuX2ludGVydmFscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFwie31cIjtcbiAgICAgIH1cbiAgICAgIGxldCBidWYgPSBcIlwiO1xuICAgICAgaWYgKHRoaXMuc2l6ZSA+IDEpIHtcbiAgICAgICAgYnVmICs9IFwie1wiO1xuICAgICAgfVxuICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICAgIGZvciAobGV0IEkgb2YgdGhpcy5faW50ZXJ2YWxzKSB7XG4gICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmICs9IFwiLCBcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYSA9IEkuYTtcbiAgICAgICAgbGV0IGIgPSBJLmI7XG4gICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgYnVmICs9IHRoaXMuZWxlbWVudE5hbWUodm9jYWJ1bGFyeSwgYSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IGE7IGkgPD0gYjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA+IGEpIHtcbiAgICAgICAgICAgICAgYnVmICs9IFwiLCBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZiArPSB0aGlzLmVsZW1lbnROYW1lKHZvY2FidWxhcnksIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2l6ZSA+IDEpIHtcbiAgICAgICAgYnVmICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgZWxlbWVudE5hbWUodm9jYWJ1bGFyeSwgYSkge1xuICAgICAgaWYgKGEgPT09IFRva2VuXzEuVG9rZW4uRU9GKSB7XG4gICAgICAgIHJldHVybiBcIjxFT0Y+XCI7XG4gICAgICB9IGVsc2UgaWYgKGEgPT09IFRva2VuXzEuVG9rZW4uRVBTSUxPTikge1xuICAgICAgICByZXR1cm4gXCI8RVBTSUxPTj5cIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2b2NhYnVsYXJ5LmdldERpc3BsYXlOYW1lKGEpO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIGxldCBuID0gMDtcbiAgICAgIGxldCBudW1JbnRlcnZhbHMgPSB0aGlzLl9pbnRlcnZhbHMubGVuZ3RoO1xuICAgICAgaWYgKG51bUludGVydmFscyA9PT0gMSkge1xuICAgICAgICBsZXQgZmlyc3RJbnRlcnZhbCA9IHRoaXMuX2ludGVydmFsc1swXTtcbiAgICAgICAgcmV0dXJuIGZpcnN0SW50ZXJ2YWwuYiAtIGZpcnN0SW50ZXJ2YWwuYSArIDE7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUludGVydmFsczsgaSsrKSB7XG4gICAgICAgIGxldCBJID0gdGhpcy5faW50ZXJ2YWxzW2ldO1xuICAgICAgICBuICs9IEkuYiAtIEkuYSArIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgdG9JbnRlZ2VyTGlzdCgpIHtcbiAgICAgIGxldCB2YWx1ZXMgPSBuZXcgSW50ZWdlckxpc3RfMS5JbnRlZ2VyTGlzdCh0aGlzLnNpemUpO1xuICAgICAgbGV0IG4gPSB0aGlzLl9pbnRlcnZhbHMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgbGV0IEkgPSB0aGlzLl9pbnRlcnZhbHNbaV07XG4gICAgICAgIGxldCBhID0gSS5hO1xuICAgICAgICBsZXQgYiA9IEkuYjtcbiAgICAgICAgZm9yIChsZXQgdiA9IGE7IHYgPD0gYjsgdisrKSB7XG4gICAgICAgICAgdmFsdWVzLmFkZCh2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgdG9TZXQoKSB7XG4gICAgICBsZXQgcyA9IG5ldyBTZXQoKTtcbiAgICAgIGZvciAobGV0IEkgb2YgdGhpcy5faW50ZXJ2YWxzKSB7XG4gICAgICAgIGxldCBhID0gSS5hO1xuICAgICAgICBsZXQgYiA9IEkuYjtcbiAgICAgICAgZm9yIChsZXQgdiA9IGE7IHYgPD0gYjsgdisrKSB7XG4gICAgICAgICAgcy5hZGQodik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICB0b0FycmF5KCkge1xuICAgICAgbGV0IHZhbHVlcyA9IG5ldyBBcnJheSgpO1xuICAgICAgbGV0IG4gPSB0aGlzLl9pbnRlcnZhbHMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgbGV0IEkgPSB0aGlzLl9pbnRlcnZhbHNbaV07XG4gICAgICAgIGxldCBhID0gSS5hO1xuICAgICAgICBsZXQgYiA9IEkuYjtcbiAgICAgICAgZm9yIChsZXQgdiA9IGE7IHYgPD0gYjsgdisrKSB7XG4gICAgICAgICAgdmFsdWVzLnB1c2godik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICAgIHJlbW92ZShlbCkge1xuICAgICAgaWYgKHRoaXMucmVhZG9ubHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuJ3QgYWx0ZXIgcmVhZG9ubHkgSW50ZXJ2YWxTZXRcIik7XG4gICAgICB9XG4gICAgICBsZXQgbiA9IHRoaXMuX2ludGVydmFscy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBsZXQgSSA9IHRoaXMuX2ludGVydmFsc1tpXTtcbiAgICAgICAgbGV0IGEgPSBJLmE7XG4gICAgICAgIGxldCBiID0gSS5iO1xuICAgICAgICBpZiAoZWwgPCBhKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsID09PSBhICYmIGVsID09PSBiKSB7XG4gICAgICAgICAgdGhpcy5faW50ZXJ2YWxzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwgPT09IGEpIHtcbiAgICAgICAgICB0aGlzLl9pbnRlcnZhbHNbaV0gPSBJbnRlcnZhbF8xLkludGVydmFsLm9mKEkuYSArIDEsIEkuYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsID09PSBiKSB7XG4gICAgICAgICAgdGhpcy5faW50ZXJ2YWxzW2ldID0gSW50ZXJ2YWxfMS5JbnRlcnZhbC5vZihJLmEsIEkuYiAtIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbCA+IGEgJiYgZWwgPCBiKSB7XG4gICAgICAgICAgbGV0IG9sZGIgPSBJLmI7XG4gICAgICAgICAgdGhpcy5faW50ZXJ2YWxzW2ldID0gSW50ZXJ2YWxfMS5JbnRlcnZhbC5vZihJLmEsIGVsIC0gMSk7XG4gICAgICAgICAgdGhpcy5hZGQoZWwgKyAxLCBvbGRiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNSZWFkb25seSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRvbmx5O1xuICAgIH1cbiAgICBzZXRSZWFkb25seShyZWFkb25seSkge1xuICAgICAgaWYgKHRoaXMucmVhZG9ubHkgJiYgIXJlYWRvbmx5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbid0IGFsdGVyIHJlYWRvbmx5IEludGVydmFsU2V0XCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWFkb25seSA9IHJlYWRvbmx5O1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEludGVydmFsU2V0LnByb3RvdHlwZSwgXCJhZGRBbGxcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBJbnRlcnZhbFNldC5wcm90b3R5cGUsIFwiY29tcGxlbWVudFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEludGVydmFsU2V0LnByb3RvdHlwZSwgXCJzdWJ0cmFjdFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEludGVydmFsU2V0LnByb3RvdHlwZSwgXCJvclwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEludGVydmFsU2V0LnByb3RvdHlwZSwgXCJhbmRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBJbnRlcnZhbFNldC5wcm90b3R5cGUsIFwiY29udGFpbnNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBJbnRlcnZhbFNldC5wcm90b3R5cGUsIFwiaXNOaWxcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBJbnRlcnZhbFNldC5wcm90b3R5cGUsIFwiaGFzaENvZGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBJbnRlcnZhbFNldC5wcm90b3R5cGUsIFwiZXF1YWxzXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBJbnRlcnZhbFNldC5wcm90b3R5cGUsIFwidG9TdHJpbmdWb2NhYnVsYXJ5XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbCxcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBJbnRlcnZhbFNldC5wcm90b3R5cGUsIFwiZWxlbWVudE5hbWVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBJbnRlcnZhbFNldC5wcm90b3R5cGUsIFwic2l6ZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEludGVydmFsU2V0LnByb3RvdHlwZSwgXCJyZW1vdmVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIEludGVydmFsU2V0LCBcIm9mXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBJbnRlcnZhbFNldCwgXCJzdWJ0cmFjdFwiLCBudWxsKTtcbiAgZXhwb3J0cy5JbnRlcnZhbFNldCA9IEludGVydmFsU2V0O1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9hdG4vQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucy5qc1xudmFyIHJlcXVpcmVfQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucyA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5BVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zID0gdm9pZCAwO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMucmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5QVROID0gb3B0aW9ucy52ZXJpZnlBVE47XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbnMgPSBvcHRpb25zLmdlbmVyYXRlUnVsZUJ5cGFzc1RyYW5zaXRpb25zO1xuICAgICAgICB0aGlzLm9wdGltaXplID0gb3B0aW9ucy5vcHRpbWl6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudmVyaWZ5QVROID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9ucyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9wdGltaXplID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldCBkZWZhdWx0T3B0aW9ucygpIHtcbiAgICAgIGlmIChBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zLl9kZWZhdWx0T3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMuX2RlZmF1bHRPcHRpb25zID0gbmV3IEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMoKTtcbiAgICAgICAgQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucy5fZGVmYXVsdE9wdGlvbnMubWFrZVJlYWRPbmx5KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucy5fZGVmYXVsdE9wdGlvbnM7XG4gICAgfVxuICAgIGdldCBpc1JlYWRPbmx5KCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZE9ubHk7XG4gICAgfVxuICAgIG1ha2VSZWFkT25seSgpIHtcbiAgICAgIHRoaXMucmVhZE9ubHkgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgaXNWZXJpZnlBVE4oKSB7XG4gICAgICByZXR1cm4gdGhpcy52ZXJpZnlBVE47XG4gICAgfVxuICAgIHNldCBpc1ZlcmlmeUFUTih2ZXJpZnlBVE4pIHtcbiAgICAgIHRoaXMudGhyb3dJZlJlYWRPbmx5KCk7XG4gICAgICB0aGlzLnZlcmlmeUFUTiA9IHZlcmlmeUFUTjtcbiAgICB9XG4gICAgZ2V0IGlzR2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9ucztcbiAgICB9XG4gICAgc2V0IGlzR2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbnMoZ2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbnMpIHtcbiAgICAgIHRoaXMudGhyb3dJZlJlYWRPbmx5KCk7XG4gICAgICB0aGlzLmdlbmVyYXRlUnVsZUJ5cGFzc1RyYW5zaXRpb25zID0gZ2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbnM7XG4gICAgfVxuICAgIGdldCBpc09wdGltaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW1pemU7XG4gICAgfVxuICAgIHNldCBpc09wdGltaXplKG9wdGltaXplKSB7XG4gICAgICB0aGlzLnRocm93SWZSZWFkT25seSgpO1xuICAgICAgdGhpcy5vcHRpbWl6ZSA9IG9wdGltaXplO1xuICAgIH1cbiAgICB0aHJvd0lmUmVhZE9ubHkoKSB7XG4gICAgICBpZiAodGhpcy5pc1JlYWRPbmx5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBvYmplY3QgaXMgcmVhZCBvbmx5LlwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMsIFwiZGVmYXVsdE9wdGlvbnNcIiwgbnVsbCk7XG4gIGV4cG9ydHMuQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucyA9IEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnM7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9BY3Rpb25UcmFuc2l0aW9uLmpzXG52YXIgcmVxdWlyZV9BY3Rpb25UcmFuc2l0aW9uID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkFjdGlvblRyYW5zaXRpb24gPSB2b2lkIDA7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIFRyYW5zaXRpb25fMSA9IHJlcXVpcmVfVHJhbnNpdGlvbigpO1xuICB2YXIgQWN0aW9uVHJhbnNpdGlvbiA9IGNsYXNzIEFjdGlvblRyYW5zaXRpb24gZXh0ZW5kcyBUcmFuc2l0aW9uXzEuVHJhbnNpdGlvbiB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBydWxlSW5kZXgsIGFjdGlvbkluZGV4ID0gLTEsIGlzQ3R4RGVwZW5kZW50ID0gZmFsc2UpIHtcbiAgICAgIHN1cGVyKHRhcmdldCk7XG4gICAgICB0aGlzLnJ1bGVJbmRleCA9IHJ1bGVJbmRleDtcbiAgICAgIHRoaXMuYWN0aW9uSW5kZXggPSBhY3Rpb25JbmRleDtcbiAgICAgIHRoaXMuaXNDdHhEZXBlbmRlbnQgPSBpc0N0eERlcGVuZGVudDtcbiAgICB9XG4gICAgZ2V0IHNlcmlhbGl6YXRpb25UeXBlKCkge1xuICAgICAgcmV0dXJuIDY7XG4gICAgfVxuICAgIGdldCBpc0Vwc2lsb24oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbWF0Y2hlcyhzeW1ib2wsIG1pblZvY2FiU3ltYm9sLCBtYXhWb2NhYlN5bWJvbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcImFjdGlvbl9cIiArIHRoaXMucnVsZUluZGV4ICsgXCI6XCIgKyB0aGlzLmFjdGlvbkluZGV4O1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEFjdGlvblRyYW5zaXRpb24ucHJvdG90eXBlLCBcInNlcmlhbGl6YXRpb25UeXBlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQWN0aW9uVHJhbnNpdGlvbi5wcm90b3R5cGUsIFwiaXNFcHNpbG9uXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQWN0aW9uVHJhbnNpdGlvbi5wcm90b3R5cGUsIFwibWF0Y2hlc1wiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEFjdGlvblRyYW5zaXRpb24ucHJvdG90eXBlLCBcInRvU3RyaW5nXCIsIG51bGwpO1xuICBBY3Rpb25UcmFuc2l0aW9uID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgQWN0aW9uVHJhbnNpdGlvbik7XG4gIGV4cG9ydHMuQWN0aW9uVHJhbnNpdGlvbiA9IEFjdGlvblRyYW5zaXRpb247XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9BdG9tVHJhbnNpdGlvbi5qc1xudmFyIHJlcXVpcmVfQXRvbVRyYW5zaXRpb24gPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuQXRvbVRyYW5zaXRpb24gPSB2b2lkIDA7XG4gIHZhciBJbnRlcnZhbFNldF8xID0gcmVxdWlyZV9JbnRlcnZhbFNldCgpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBUcmFuc2l0aW9uXzEgPSByZXF1aXJlX1RyYW5zaXRpb24oKTtcbiAgdmFyIEF0b21UcmFuc2l0aW9uMiA9IGNsYXNzIEF0b21UcmFuc2l0aW9uIGV4dGVuZHMgVHJhbnNpdGlvbl8xLlRyYW5zaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgbGFiZWwpIHtcbiAgICAgIHN1cGVyKHRhcmdldCk7XG4gICAgICB0aGlzLl9sYWJlbCA9IGxhYmVsO1xuICAgIH1cbiAgICBnZXQgc2VyaWFsaXphdGlvblR5cGUoKSB7XG4gICAgICByZXR1cm4gNTtcbiAgICB9XG4gICAgZ2V0IGxhYmVsKCkge1xuICAgICAgcmV0dXJuIEludGVydmFsU2V0XzEuSW50ZXJ2YWxTZXQub2YodGhpcy5fbGFiZWwpO1xuICAgIH1cbiAgICBtYXRjaGVzKHN5bWJvbCwgbWluVm9jYWJTeW1ib2wsIG1heFZvY2FiU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGFiZWwgPT09IHN5bWJvbDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKHRoaXMubGFiZWwpO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEF0b21UcmFuc2l0aW9uMi5wcm90b3R5cGUsIFwic2VyaWFsaXphdGlvblR5cGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZSxcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBBdG9tVHJhbnNpdGlvbjIucHJvdG90eXBlLCBcImxhYmVsXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQXRvbVRyYW5zaXRpb24yLnByb3RvdHlwZSwgXCJtYXRjaGVzXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGUsXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgQXRvbVRyYW5zaXRpb24yLnByb3RvdHlwZSwgXCJ0b1N0cmluZ1wiLCBudWxsKTtcbiAgQXRvbVRyYW5zaXRpb24yID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgQXRvbVRyYW5zaXRpb24yKTtcbiAgZXhwb3J0cy5BdG9tVHJhbnNpdGlvbiA9IEF0b21UcmFuc2l0aW9uMjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvYXRuL0Jsb2NrU3RhcnRTdGF0ZS5qc1xudmFyIHJlcXVpcmVfQmxvY2tTdGFydFN0YXRlID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5CbG9ja1N0YXJ0U3RhdGUgPSB2b2lkIDA7XG4gIHZhciBEZWNpc2lvblN0YXRlXzEgPSByZXF1aXJlX0RlY2lzaW9uU3RhdGUoKTtcbiAgdmFyIEJsb2NrU3RhcnRTdGF0ZSA9IGNsYXNzIGV4dGVuZHMgRGVjaXNpb25TdGF0ZV8xLkRlY2lzaW9uU3RhdGUge1xuICB9O1xuICBleHBvcnRzLkJsb2NrU3RhcnRTdGF0ZSA9IEJsb2NrU3RhcnRTdGF0ZTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvYXRuL0Jhc2ljQmxvY2tTdGFydFN0YXRlLmpzXG52YXIgcmVxdWlyZV9CYXNpY0Jsb2NrU3RhcnRTdGF0ZSA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5CYXNpY0Jsb2NrU3RhcnRTdGF0ZSA9IHZvaWQgMDtcbiAgdmFyIEFUTlN0YXRlVHlwZV8xID0gcmVxdWlyZV9BVE5TdGF0ZVR5cGUoKTtcbiAgdmFyIEJsb2NrU3RhcnRTdGF0ZV8xID0gcmVxdWlyZV9CbG9ja1N0YXJ0U3RhdGUoKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgQmFzaWNCbG9ja1N0YXJ0U3RhdGUgPSBjbGFzcyBleHRlbmRzIEJsb2NrU3RhcnRTdGF0ZV8xLkJsb2NrU3RhcnRTdGF0ZSB7XG4gICAgZ2V0IHN0YXRlVHlwZSgpIHtcbiAgICAgIHJldHVybiBBVE5TdGF0ZVR5cGVfMS5BVE5TdGF0ZVR5cGUuQkxPQ0tfU1RBUlQ7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQmFzaWNCbG9ja1N0YXJ0U3RhdGUucHJvdG90eXBlLCBcInN0YXRlVHlwZVwiLCBudWxsKTtcbiAgZXhwb3J0cy5CYXNpY0Jsb2NrU3RhcnRTdGF0ZSA9IEJhc2ljQmxvY2tTdGFydFN0YXRlO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9hdG4vQmxvY2tFbmRTdGF0ZS5qc1xudmFyIHJlcXVpcmVfQmxvY2tFbmRTdGF0ZSA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5CbG9ja0VuZFN0YXRlID0gdm9pZCAwO1xuICB2YXIgQVROU3RhdGVfMSA9IHJlcXVpcmVfQVROU3RhdGUoKTtcbiAgdmFyIEFUTlN0YXRlVHlwZV8xID0gcmVxdWlyZV9BVE5TdGF0ZVR5cGUoKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgQmxvY2tFbmRTdGF0ZSA9IGNsYXNzIGV4dGVuZHMgQVROU3RhdGVfMS5BVE5TdGF0ZSB7XG4gICAgZ2V0IHN0YXRlVHlwZSgpIHtcbiAgICAgIHJldHVybiBBVE5TdGF0ZVR5cGVfMS5BVE5TdGF0ZVR5cGUuQkxPQ0tfRU5EO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEJsb2NrRW5kU3RhdGUucHJvdG90eXBlLCBcInN0YXRlVHlwZVwiLCBudWxsKTtcbiAgZXhwb3J0cy5CbG9ja0VuZFN0YXRlID0gQmxvY2tFbmRTdGF0ZTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvYXRuL0Vwc2lsb25UcmFuc2l0aW9uLmpzXG52YXIgcmVxdWlyZV9FcHNpbG9uVHJhbnNpdGlvbiA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgdmFyIF9fcGFyYW0gPSBleHBvcnRzICYmIGV4cG9ydHMuX19wYXJhbSB8fCBmdW5jdGlvbihwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7XG4gICAgfTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5FcHNpbG9uVHJhbnNpdGlvbiA9IHZvaWQgMDtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgVHJhbnNpdGlvbl8xID0gcmVxdWlyZV9UcmFuc2l0aW9uKCk7XG4gIHZhciBFcHNpbG9uVHJhbnNpdGlvbiA9IGNsYXNzIEVwc2lsb25UcmFuc2l0aW9uIGV4dGVuZHMgVHJhbnNpdGlvbl8xLlRyYW5zaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgb3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybiA9IC0xKSB7XG4gICAgICBzdXBlcih0YXJnZXQpO1xuICAgICAgdGhpcy5fb3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybiA9IG91dGVybW9zdFByZWNlZGVuY2VSZXR1cm47XG4gICAgfVxuICAgIGdldCBvdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX291dGVybW9zdFByZWNlZGVuY2VSZXR1cm47XG4gICAgfVxuICAgIGdldCBzZXJpYWxpemF0aW9uVHlwZSgpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBnZXQgaXNFcHNpbG9uKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG1hdGNoZXMoc3ltYm9sLCBtaW5Wb2NhYlN5bWJvbCwgbWF4Vm9jYWJTeW1ib2wpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJlcHNpbG9uXCI7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgRXBzaWxvblRyYW5zaXRpb24ucHJvdG90eXBlLCBcInNlcmlhbGl6YXRpb25UeXBlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgRXBzaWxvblRyYW5zaXRpb24ucHJvdG90eXBlLCBcImlzRXBzaWxvblwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEVwc2lsb25UcmFuc2l0aW9uLnByb3RvdHlwZSwgXCJtYXRjaGVzXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGUsXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgRXBzaWxvblRyYW5zaXRpb24ucHJvdG90eXBlLCBcInRvU3RyaW5nXCIsIG51bGwpO1xuICBFcHNpbG9uVHJhbnNpdGlvbiA9IF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIEVwc2lsb25UcmFuc2l0aW9uKTtcbiAgZXhwb3J0cy5FcHNpbG9uVHJhbnNpdGlvbiA9IEVwc2lsb25UcmFuc2l0aW9uO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9hdG4vTGV4ZXJDaGFubmVsQWN0aW9uLmpzXG52YXIgcmVxdWlyZV9MZXhlckNoYW5uZWxBY3Rpb24gPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuTGV4ZXJDaGFubmVsQWN0aW9uID0gdm9pZCAwO1xuICB2YXIgTXVybXVySGFzaF8xID0gcmVxdWlyZV9NdXJtdXJIYXNoKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIExleGVyQ2hhbm5lbEFjdGlvbiA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsKSB7XG4gICAgICB0aGlzLl9jaGFubmVsID0gY2hhbm5lbDtcbiAgICB9XG4gICAgZ2V0IGNoYW5uZWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2hhbm5lbDtcbiAgICB9XG4gICAgZ2V0IGFjdGlvblR5cGUoKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZ2V0IGlzUG9zaXRpb25EZXBlbmRlbnQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGV4ZWN1dGUobGV4ZXIpIHtcbiAgICAgIGxleGVyLmNoYW5uZWwgPSB0aGlzLl9jaGFubmVsO1xuICAgIH1cbiAgICBoYXNoQ29kZSgpIHtcbiAgICAgIGxldCBoYXNoID0gTXVybXVySGFzaF8xLk11cm11ckhhc2guaW5pdGlhbGl6ZSgpO1xuICAgICAgaGFzaCA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLmFjdGlvblR5cGUpO1xuICAgICAgaGFzaCA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLl9jaGFubmVsKTtcbiAgICAgIHJldHVybiBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC5maW5pc2goaGFzaCwgMik7XG4gICAgfVxuICAgIGVxdWFscyhvYmopIHtcbiAgICAgIGlmIChvYmogPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCEob2JqIGluc3RhbmNlb2YgTGV4ZXJDaGFubmVsQWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fY2hhbm5lbCA9PT0gb2JqLl9jaGFubmVsO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgY2hhbm5lbCgke3RoaXMuX2NoYW5uZWx9KWA7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJDaGFubmVsQWN0aW9uLnByb3RvdHlwZSwgXCJhY3Rpb25UeXBlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJDaGFubmVsQWN0aW9uLnByb3RvdHlwZSwgXCJpc1Bvc2l0aW9uRGVwZW5kZW50XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGUsXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgTGV4ZXJDaGFubmVsQWN0aW9uLnByb3RvdHlwZSwgXCJleGVjdXRlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJDaGFubmVsQWN0aW9uLnByb3RvdHlwZSwgXCJoYXNoQ29kZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExleGVyQ2hhbm5lbEFjdGlvbi5wcm90b3R5cGUsIFwiZXF1YWxzXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJDaGFubmVsQWN0aW9uLnByb3RvdHlwZSwgXCJ0b1N0cmluZ1wiLCBudWxsKTtcbiAgZXhwb3J0cy5MZXhlckNoYW5uZWxBY3Rpb24gPSBMZXhlckNoYW5uZWxBY3Rpb247XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9MZXhlckN1c3RvbUFjdGlvbi5qc1xudmFyIHJlcXVpcmVfTGV4ZXJDdXN0b21BY3Rpb24gPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuTGV4ZXJDdXN0b21BY3Rpb24gPSB2b2lkIDA7XG4gIHZhciBNdXJtdXJIYXNoXzEgPSByZXF1aXJlX011cm11ckhhc2goKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgTGV4ZXJDdXN0b21BY3Rpb24gPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IocnVsZUluZGV4LCBhY3Rpb25JbmRleCkge1xuICAgICAgdGhpcy5fcnVsZUluZGV4ID0gcnVsZUluZGV4O1xuICAgICAgdGhpcy5fYWN0aW9uSW5kZXggPSBhY3Rpb25JbmRleDtcbiAgICB9XG4gICAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydWxlSW5kZXg7XG4gICAgfVxuICAgIGdldCBhY3Rpb25JbmRleCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hY3Rpb25JbmRleDtcbiAgICB9XG4gICAgZ2V0IGFjdGlvblR5cGUoKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZ2V0IGlzUG9zaXRpb25EZXBlbmRlbnQoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZXhlY3V0ZShsZXhlcikge1xuICAgICAgbGV4ZXIuYWN0aW9uKHZvaWQgMCwgdGhpcy5fcnVsZUluZGV4LCB0aGlzLl9hY3Rpb25JbmRleCk7XG4gICAgfVxuICAgIGhhc2hDb2RlKCkge1xuICAgICAgbGV0IGhhc2ggPSBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC5pbml0aWFsaXplKCk7XG4gICAgICBoYXNoID0gTXVybXVySGFzaF8xLk11cm11ckhhc2gudXBkYXRlKGhhc2gsIHRoaXMuYWN0aW9uVHlwZSk7XG4gICAgICBoYXNoID0gTXVybXVySGFzaF8xLk11cm11ckhhc2gudXBkYXRlKGhhc2gsIHRoaXMuX3J1bGVJbmRleCk7XG4gICAgICBoYXNoID0gTXVybXVySGFzaF8xLk11cm11ckhhc2gudXBkYXRlKGhhc2gsIHRoaXMuX2FjdGlvbkluZGV4KTtcbiAgICAgIHJldHVybiBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC5maW5pc2goaGFzaCwgMyk7XG4gICAgfVxuICAgIGVxdWFscyhvYmopIHtcbiAgICAgIGlmIChvYmogPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCEob2JqIGluc3RhbmNlb2YgTGV4ZXJDdXN0b21BY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9ydWxlSW5kZXggPT09IG9iai5fcnVsZUluZGV4ICYmIHRoaXMuX2FjdGlvbkluZGV4ID09PSBvYmouX2FjdGlvbkluZGV4O1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExleGVyQ3VzdG9tQWN0aW9uLnByb3RvdHlwZSwgXCJhY3Rpb25UeXBlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJDdXN0b21BY3Rpb24ucHJvdG90eXBlLCBcImlzUG9zaXRpb25EZXBlbmRlbnRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZSxcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBMZXhlckN1c3RvbUFjdGlvbi5wcm90b3R5cGUsIFwiZXhlY3V0ZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExleGVyQ3VzdG9tQWN0aW9uLnByb3RvdHlwZSwgXCJoYXNoQ29kZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExleGVyQ3VzdG9tQWN0aW9uLnByb3RvdHlwZSwgXCJlcXVhbHNcIiwgbnVsbCk7XG4gIGV4cG9ydHMuTGV4ZXJDdXN0b21BY3Rpb24gPSBMZXhlckN1c3RvbUFjdGlvbjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvYXRuL0xleGVyTW9kZUFjdGlvbi5qc1xudmFyIHJlcXVpcmVfTGV4ZXJNb2RlQWN0aW9uID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkxleGVyTW9kZUFjdGlvbiA9IHZvaWQgMDtcbiAgdmFyIE11cm11ckhhc2hfMSA9IHJlcXVpcmVfTXVybXVySGFzaCgpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBMZXhlck1vZGVBY3Rpb24gPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IobW9kZSkge1xuICAgICAgdGhpcy5fbW9kZSA9IG1vZGU7XG4gICAgfVxuICAgIGdldCBtb2RlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vZGU7XG4gICAgfVxuICAgIGdldCBhY3Rpb25UeXBlKCkge1xuICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICAgIGdldCBpc1Bvc2l0aW9uRGVwZW5kZW50KCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBleGVjdXRlKGxleGVyKSB7XG4gICAgICBsZXhlci5tb2RlKHRoaXMuX21vZGUpO1xuICAgIH1cbiAgICBoYXNoQ29kZSgpIHtcbiAgICAgIGxldCBoYXNoID0gTXVybXVySGFzaF8xLk11cm11ckhhc2guaW5pdGlhbGl6ZSgpO1xuICAgICAgaGFzaCA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLmFjdGlvblR5cGUpO1xuICAgICAgaGFzaCA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLl9tb2RlKTtcbiAgICAgIHJldHVybiBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC5maW5pc2goaGFzaCwgMik7XG4gICAgfVxuICAgIGVxdWFscyhvYmopIHtcbiAgICAgIGlmIChvYmogPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCEob2JqIGluc3RhbmNlb2YgTGV4ZXJNb2RlQWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fbW9kZSA9PT0gb2JqLl9tb2RlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgbW9kZSgke3RoaXMuX21vZGV9KWA7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJNb2RlQWN0aW9uLnByb3RvdHlwZSwgXCJhY3Rpb25UeXBlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJNb2RlQWN0aW9uLnByb3RvdHlwZSwgXCJpc1Bvc2l0aW9uRGVwZW5kZW50XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGUsXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgTGV4ZXJNb2RlQWN0aW9uLnByb3RvdHlwZSwgXCJleGVjdXRlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJNb2RlQWN0aW9uLnByb3RvdHlwZSwgXCJoYXNoQ29kZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExleGVyTW9kZUFjdGlvbi5wcm90b3R5cGUsIFwiZXF1YWxzXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJNb2RlQWN0aW9uLnByb3RvdHlwZSwgXCJ0b1N0cmluZ1wiLCBudWxsKTtcbiAgZXhwb3J0cy5MZXhlck1vZGVBY3Rpb24gPSBMZXhlck1vZGVBY3Rpb247XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9MZXhlck1vcmVBY3Rpb24uanNcbnZhciByZXF1aXJlX0xleGVyTW9yZUFjdGlvbiA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgdmFyIF9fcGFyYW0gPSBleHBvcnRzICYmIGV4cG9ydHMuX19wYXJhbSB8fCBmdW5jdGlvbihwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7XG4gICAgfTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5MZXhlck1vcmVBY3Rpb24gPSB2b2lkIDA7XG4gIHZhciBNdXJtdXJIYXNoXzEgPSByZXF1aXJlX011cm11ckhhc2goKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgTGV4ZXJNb3JlQWN0aW9uID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgIH1cbiAgICBnZXQgYWN0aW9uVHlwZSgpIHtcbiAgICAgIHJldHVybiAzO1xuICAgIH1cbiAgICBnZXQgaXNQb3NpdGlvbkRlcGVuZGVudCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZXhlY3V0ZShsZXhlcikge1xuICAgICAgbGV4ZXIubW9yZSgpO1xuICAgIH1cbiAgICBoYXNoQ29kZSgpIHtcbiAgICAgIGxldCBoYXNoID0gTXVybXVySGFzaF8xLk11cm11ckhhc2guaW5pdGlhbGl6ZSgpO1xuICAgICAgaGFzaCA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLmFjdGlvblR5cGUpO1xuICAgICAgcmV0dXJuIE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLmZpbmlzaChoYXNoLCAxKTtcbiAgICB9XG4gICAgZXF1YWxzKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJtb3JlXCI7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJNb3JlQWN0aW9uLnByb3RvdHlwZSwgXCJhY3Rpb25UeXBlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJNb3JlQWN0aW9uLnByb3RvdHlwZSwgXCJpc1Bvc2l0aW9uRGVwZW5kZW50XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGUsXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgTGV4ZXJNb3JlQWN0aW9uLnByb3RvdHlwZSwgXCJleGVjdXRlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJNb3JlQWN0aW9uLnByb3RvdHlwZSwgXCJoYXNoQ29kZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExleGVyTW9yZUFjdGlvbi5wcm90b3R5cGUsIFwiZXF1YWxzXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJNb3JlQWN0aW9uLnByb3RvdHlwZSwgXCJ0b1N0cmluZ1wiLCBudWxsKTtcbiAgZXhwb3J0cy5MZXhlck1vcmVBY3Rpb24gPSBMZXhlck1vcmVBY3Rpb247XG4gIChmdW5jdGlvbihMZXhlck1vcmVBY3Rpb24yKSB7XG4gICAgTGV4ZXJNb3JlQWN0aW9uMi5JTlNUQU5DRSA9IG5ldyBMZXhlck1vcmVBY3Rpb24yKCk7XG4gIH0pKExleGVyTW9yZUFjdGlvbiA9IGV4cG9ydHMuTGV4ZXJNb3JlQWN0aW9uIHx8IChleHBvcnRzLkxleGVyTW9yZUFjdGlvbiA9IHt9KSk7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9MZXhlclBvcE1vZGVBY3Rpb24uanNcbnZhciByZXF1aXJlX0xleGVyUG9wTW9kZUFjdGlvbiA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgdmFyIF9fcGFyYW0gPSBleHBvcnRzICYmIGV4cG9ydHMuX19wYXJhbSB8fCBmdW5jdGlvbihwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7XG4gICAgfTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5MZXhlclBvcE1vZGVBY3Rpb24gPSB2b2lkIDA7XG4gIHZhciBNdXJtdXJIYXNoXzEgPSByZXF1aXJlX011cm11ckhhc2goKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgTGV4ZXJQb3BNb2RlQWN0aW9uID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgIH1cbiAgICBnZXQgYWN0aW9uVHlwZSgpIHtcbiAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgICBnZXQgaXNQb3NpdGlvbkRlcGVuZGVudCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZXhlY3V0ZShsZXhlcikge1xuICAgICAgbGV4ZXIucG9wTW9kZSgpO1xuICAgIH1cbiAgICBoYXNoQ29kZSgpIHtcbiAgICAgIGxldCBoYXNoID0gTXVybXVySGFzaF8xLk11cm11ckhhc2guaW5pdGlhbGl6ZSgpO1xuICAgICAgaGFzaCA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLmFjdGlvblR5cGUpO1xuICAgICAgcmV0dXJuIE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLmZpbmlzaChoYXNoLCAxKTtcbiAgICB9XG4gICAgZXF1YWxzKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJwb3BNb2RlXCI7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJQb3BNb2RlQWN0aW9uLnByb3RvdHlwZSwgXCJhY3Rpb25UeXBlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJQb3BNb2RlQWN0aW9uLnByb3RvdHlwZSwgXCJpc1Bvc2l0aW9uRGVwZW5kZW50XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGUsXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgTGV4ZXJQb3BNb2RlQWN0aW9uLnByb3RvdHlwZSwgXCJleGVjdXRlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJQb3BNb2RlQWN0aW9uLnByb3RvdHlwZSwgXCJoYXNoQ29kZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExleGVyUG9wTW9kZUFjdGlvbi5wcm90b3R5cGUsIFwiZXF1YWxzXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJQb3BNb2RlQWN0aW9uLnByb3RvdHlwZSwgXCJ0b1N0cmluZ1wiLCBudWxsKTtcbiAgZXhwb3J0cy5MZXhlclBvcE1vZGVBY3Rpb24gPSBMZXhlclBvcE1vZGVBY3Rpb247XG4gIChmdW5jdGlvbihMZXhlclBvcE1vZGVBY3Rpb24yKSB7XG4gICAgTGV4ZXJQb3BNb2RlQWN0aW9uMi5JTlNUQU5DRSA9IG5ldyBMZXhlclBvcE1vZGVBY3Rpb24yKCk7XG4gIH0pKExleGVyUG9wTW9kZUFjdGlvbiA9IGV4cG9ydHMuTGV4ZXJQb3BNb2RlQWN0aW9uIHx8IChleHBvcnRzLkxleGVyUG9wTW9kZUFjdGlvbiA9IHt9KSk7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9MZXhlclB1c2hNb2RlQWN0aW9uLmpzXG52YXIgcmVxdWlyZV9MZXhlclB1c2hNb2RlQWN0aW9uID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkxleGVyUHVzaE1vZGVBY3Rpb24gPSB2b2lkIDA7XG4gIHZhciBNdXJtdXJIYXNoXzEgPSByZXF1aXJlX011cm11ckhhc2goKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgTGV4ZXJQdXNoTW9kZUFjdGlvbiA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlKSB7XG4gICAgICB0aGlzLl9tb2RlID0gbW9kZTtcbiAgICB9XG4gICAgZ2V0IG1vZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW9kZTtcbiAgICB9XG4gICAgZ2V0IGFjdGlvblR5cGUoKSB7XG4gICAgICByZXR1cm4gNTtcbiAgICB9XG4gICAgZ2V0IGlzUG9zaXRpb25EZXBlbmRlbnQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGV4ZWN1dGUobGV4ZXIpIHtcbiAgICAgIGxleGVyLnB1c2hNb2RlKHRoaXMuX21vZGUpO1xuICAgIH1cbiAgICBoYXNoQ29kZSgpIHtcbiAgICAgIGxldCBoYXNoID0gTXVybXVySGFzaF8xLk11cm11ckhhc2guaW5pdGlhbGl6ZSgpO1xuICAgICAgaGFzaCA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLmFjdGlvblR5cGUpO1xuICAgICAgaGFzaCA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLl9tb2RlKTtcbiAgICAgIHJldHVybiBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC5maW5pc2goaGFzaCwgMik7XG4gICAgfVxuICAgIGVxdWFscyhvYmopIHtcbiAgICAgIGlmIChvYmogPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCEob2JqIGluc3RhbmNlb2YgTGV4ZXJQdXNoTW9kZUFjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX21vZGUgPT09IG9iai5fbW9kZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYHB1c2hNb2RlKCR7dGhpcy5fbW9kZX0pYDtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBMZXhlclB1c2hNb2RlQWN0aW9uLnByb3RvdHlwZSwgXCJhY3Rpb25UeXBlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJQdXNoTW9kZUFjdGlvbi5wcm90b3R5cGUsIFwiaXNQb3NpdGlvbkRlcGVuZGVudFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlLFxuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIExleGVyUHVzaE1vZGVBY3Rpb24ucHJvdG90eXBlLCBcImV4ZWN1dGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBMZXhlclB1c2hNb2RlQWN0aW9uLnByb3RvdHlwZSwgXCJoYXNoQ29kZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExleGVyUHVzaE1vZGVBY3Rpb24ucHJvdG90eXBlLCBcImVxdWFsc1wiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExleGVyUHVzaE1vZGVBY3Rpb24ucHJvdG90eXBlLCBcInRvU3RyaW5nXCIsIG51bGwpO1xuICBleHBvcnRzLkxleGVyUHVzaE1vZGVBY3Rpb24gPSBMZXhlclB1c2hNb2RlQWN0aW9uO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9hdG4vTGV4ZXJTa2lwQWN0aW9uLmpzXG52YXIgcmVxdWlyZV9MZXhlclNraXBBY3Rpb24gPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuTGV4ZXJTa2lwQWN0aW9uID0gdm9pZCAwO1xuICB2YXIgTXVybXVySGFzaF8xID0gcmVxdWlyZV9NdXJtdXJIYXNoKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIExleGVyU2tpcEFjdGlvbiA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICB9XG4gICAgZ2V0IGFjdGlvblR5cGUoKSB7XG4gICAgICByZXR1cm4gNjtcbiAgICB9XG4gICAgZ2V0IGlzUG9zaXRpb25EZXBlbmRlbnQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGV4ZWN1dGUobGV4ZXIpIHtcbiAgICAgIGxleGVyLnNraXAoKTtcbiAgICB9XG4gICAgaGFzaENvZGUoKSB7XG4gICAgICBsZXQgaGFzaCA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLmluaXRpYWxpemUoKTtcbiAgICAgIGhhc2ggPSBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC51cGRhdGUoaGFzaCwgdGhpcy5hY3Rpb25UeXBlKTtcbiAgICAgIHJldHVybiBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC5maW5pc2goaGFzaCwgMSk7XG4gICAgfVxuICAgIGVxdWFscyhvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwic2tpcFwiO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExleGVyU2tpcEFjdGlvbi5wcm90b3R5cGUsIFwiYWN0aW9uVHlwZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExleGVyU2tpcEFjdGlvbi5wcm90b3R5cGUsIFwiaXNQb3NpdGlvbkRlcGVuZGVudFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlLFxuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIExleGVyU2tpcEFjdGlvbi5wcm90b3R5cGUsIFwiZXhlY3V0ZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExleGVyU2tpcEFjdGlvbi5wcm90b3R5cGUsIFwiaGFzaENvZGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBMZXhlclNraXBBY3Rpb24ucHJvdG90eXBlLCBcImVxdWFsc1wiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExleGVyU2tpcEFjdGlvbi5wcm90b3R5cGUsIFwidG9TdHJpbmdcIiwgbnVsbCk7XG4gIGV4cG9ydHMuTGV4ZXJTa2lwQWN0aW9uID0gTGV4ZXJTa2lwQWN0aW9uO1xuICAoZnVuY3Rpb24oTGV4ZXJTa2lwQWN0aW9uMikge1xuICAgIExleGVyU2tpcEFjdGlvbjIuSU5TVEFOQ0UgPSBuZXcgTGV4ZXJTa2lwQWN0aW9uMigpO1xuICB9KShMZXhlclNraXBBY3Rpb24gPSBleHBvcnRzLkxleGVyU2tpcEFjdGlvbiB8fCAoZXhwb3J0cy5MZXhlclNraXBBY3Rpb24gPSB7fSkpO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9hdG4vTGV4ZXJUeXBlQWN0aW9uLmpzXG52YXIgcmVxdWlyZV9MZXhlclR5cGVBY3Rpb24gPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuTGV4ZXJUeXBlQWN0aW9uID0gdm9pZCAwO1xuICB2YXIgTXVybXVySGFzaF8xID0gcmVxdWlyZV9NdXJtdXJIYXNoKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIExleGVyVHlwZUFjdGlvbiA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgICB0aGlzLl90eXBlID0gdHlwZTtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICB9XG4gICAgZ2V0IGFjdGlvblR5cGUoKSB7XG4gICAgICByZXR1cm4gNztcbiAgICB9XG4gICAgZ2V0IGlzUG9zaXRpb25EZXBlbmRlbnQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGV4ZWN1dGUobGV4ZXIpIHtcbiAgICAgIGxleGVyLnR5cGUgPSB0aGlzLl90eXBlO1xuICAgIH1cbiAgICBoYXNoQ29kZSgpIHtcbiAgICAgIGxldCBoYXNoID0gTXVybXVySGFzaF8xLk11cm11ckhhc2guaW5pdGlhbGl6ZSgpO1xuICAgICAgaGFzaCA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLmFjdGlvblR5cGUpO1xuICAgICAgaGFzaCA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLnVwZGF0ZShoYXNoLCB0aGlzLl90eXBlKTtcbiAgICAgIHJldHVybiBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC5maW5pc2goaGFzaCwgMik7XG4gICAgfVxuICAgIGVxdWFscyhvYmopIHtcbiAgICAgIGlmIChvYmogPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCEob2JqIGluc3RhbmNlb2YgTGV4ZXJUeXBlQWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fdHlwZSA9PT0gb2JqLl90eXBlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgdHlwZSgke3RoaXMuX3R5cGV9KWA7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJUeXBlQWN0aW9uLnByb3RvdHlwZSwgXCJhY3Rpb25UeXBlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJUeXBlQWN0aW9uLnByb3RvdHlwZSwgXCJpc1Bvc2l0aW9uRGVwZW5kZW50XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGUsXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgTGV4ZXJUeXBlQWN0aW9uLnByb3RvdHlwZSwgXCJleGVjdXRlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJUeXBlQWN0aW9uLnByb3RvdHlwZSwgXCJoYXNoQ29kZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExleGVyVHlwZUFjdGlvbi5wcm90b3R5cGUsIFwiZXF1YWxzXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGV4ZXJUeXBlQWN0aW9uLnByb3RvdHlwZSwgXCJ0b1N0cmluZ1wiLCBudWxsKTtcbiAgZXhwb3J0cy5MZXhlclR5cGVBY3Rpb24gPSBMZXhlclR5cGVBY3Rpb247XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9Mb29wRW5kU3RhdGUuanNcbnZhciByZXF1aXJlX0xvb3BFbmRTdGF0ZSA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5Mb29wRW5kU3RhdGUgPSB2b2lkIDA7XG4gIHZhciBBVE5TdGF0ZV8xID0gcmVxdWlyZV9BVE5TdGF0ZSgpO1xuICB2YXIgQVROU3RhdGVUeXBlXzEgPSByZXF1aXJlX0FUTlN0YXRlVHlwZSgpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBMb29wRW5kU3RhdGUgPSBjbGFzcyBleHRlbmRzIEFUTlN0YXRlXzEuQVROU3RhdGUge1xuICAgIGdldCBzdGF0ZVR5cGUoKSB7XG4gICAgICByZXR1cm4gQVROU3RhdGVUeXBlXzEuQVROU3RhdGVUeXBlLkxPT1BfRU5EO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExvb3BFbmRTdGF0ZS5wcm90b3R5cGUsIFwic3RhdGVUeXBlXCIsIG51bGwpO1xuICBleHBvcnRzLkxvb3BFbmRTdGF0ZSA9IExvb3BFbmRTdGF0ZTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvYXRuL0NvbmZsaWN0SW5mby5qc1xudmFyIHJlcXVpcmVfQ29uZmxpY3RJbmZvID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkNvbmZsaWN0SW5mbyA9IHZvaWQgMDtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgVXRpbHMzID0gcmVxdWlyZV9VdGlscygpO1xuICB2YXIgQ29uZmxpY3RJbmZvID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZsaWN0ZWRBbHRzLCBleGFjdCkge1xuICAgICAgdGhpcy5fY29uZmxpY3RlZEFsdHMgPSBjb25mbGljdGVkQWx0cztcbiAgICAgIHRoaXMuZXhhY3QgPSBleGFjdDtcbiAgICB9XG4gICAgZ2V0IGNvbmZsaWN0ZWRBbHRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbmZsaWN0ZWRBbHRzO1xuICAgIH1cbiAgICBnZXQgaXNFeGFjdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmV4YWN0O1xuICAgIH1cbiAgICBlcXVhbHMob2JqKSB7XG4gICAgICBpZiAob2JqID09PSB0aGlzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmICghKG9iaiBpbnN0YW5jZW9mIENvbmZsaWN0SW5mbykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaXNFeGFjdCA9PT0gb2JqLmlzRXhhY3QgJiYgVXRpbHMzLmVxdWFscyh0aGlzLmNvbmZsaWN0ZWRBbHRzLCBvYmouY29uZmxpY3RlZEFsdHMpO1xuICAgIH1cbiAgICBoYXNoQ29kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZsaWN0ZWRBbHRzLmhhc2hDb2RlKCk7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQ29uZmxpY3RJbmZvLnByb3RvdHlwZSwgXCJlcXVhbHNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBDb25mbGljdEluZm8ucHJvdG90eXBlLCBcImhhc2hDb2RlXCIsIG51bGwpO1xuICBleHBvcnRzLkNvbmZsaWN0SW5mbyA9IENvbmZsaWN0SW5mbztcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvdHJlZS9UZXJtaW5hbE5vZGUuanNcbnZhciByZXF1aXJlX1Rlcm1pbmFsTm9kZSA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5UZXJtaW5hbE5vZGUgPSB2b2lkIDA7XG4gIHZhciBJbnRlcnZhbF8xID0gcmVxdWlyZV9JbnRlcnZhbCgpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBUb2tlbl8xID0gcmVxdWlyZV9Ub2tlbigpO1xuICB2YXIgVGVybWluYWxOb2RlID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHN5bWJvbCkge1xuICAgICAgdGhpcy5fc3ltYm9sID0gc3ltYm9sO1xuICAgIH1cbiAgICBnZXRDaGlsZChpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRlcm1pbmFsIE5vZGUgaGFzIG5vIGNoaWxkcmVuLlwiKTtcbiAgICB9XG4gICAgZ2V0IHN5bWJvbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zeW1ib2w7XG4gICAgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICAgIH1cbiAgICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIGdldCBwYXlsb2FkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N5bWJvbDtcbiAgICB9XG4gICAgZ2V0IHNvdXJjZUludGVydmFsKCkge1xuICAgICAgbGV0IHRva2VuSW5kZXggPSB0aGlzLl9zeW1ib2wudG9rZW5JbmRleDtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWxfMS5JbnRlcnZhbCh0b2tlbkluZGV4LCB0b2tlbkluZGV4KTtcbiAgICB9XG4gICAgZ2V0IGNoaWxkQ291bnQoKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGVybWluYWwodGhpcyk7XG4gICAgfVxuICAgIGdldCB0ZXh0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N5bWJvbC50ZXh0IHx8IFwiXCI7XG4gICAgfVxuICAgIHRvU3RyaW5nVHJlZShwYXJzZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgaWYgKHRoaXMuX3N5bWJvbC50eXBlID09PSBUb2tlbl8xLlRva2VuLkVPRikge1xuICAgICAgICByZXR1cm4gXCI8RU9GPlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3N5bWJvbC50ZXh0IHx8IFwiXCI7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgVGVybWluYWxOb2RlLnByb3RvdHlwZSwgXCJnZXRDaGlsZFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFRlcm1pbmFsTm9kZS5wcm90b3R5cGUsIFwicGFyZW50XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgVGVybWluYWxOb2RlLnByb3RvdHlwZSwgXCJzZXRQYXJlbnRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBUZXJtaW5hbE5vZGUucHJvdG90eXBlLCBcInBheWxvYWRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBUZXJtaW5hbE5vZGUucHJvdG90eXBlLCBcInNvdXJjZUludGVydmFsXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgVGVybWluYWxOb2RlLnByb3RvdHlwZSwgXCJjaGlsZENvdW50XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgVGVybWluYWxOb2RlLnByb3RvdHlwZSwgXCJhY2NlcHRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBUZXJtaW5hbE5vZGUucHJvdG90eXBlLCBcInRleHRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBUZXJtaW5hbE5vZGUucHJvdG90eXBlLCBcInRvU3RyaW5nVHJlZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFRlcm1pbmFsTm9kZS5wcm90b3R5cGUsIFwidG9TdHJpbmdcIiwgbnVsbCk7XG4gIGV4cG9ydHMuVGVybWluYWxOb2RlID0gVGVybWluYWxOb2RlO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy90cmVlL0Vycm9yTm9kZS5qc1xudmFyIHJlcXVpcmVfRXJyb3JOb2RlID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkVycm9yTm9kZSA9IHZvaWQgMDtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgVGVybWluYWxOb2RlXzEgPSByZXF1aXJlX1Rlcm1pbmFsTm9kZSgpO1xuICB2YXIgRXJyb3JOb2RlMiA9IGNsYXNzIGV4dGVuZHMgVGVybWluYWxOb2RlXzEuVGVybWluYWxOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbikge1xuICAgICAgc3VwZXIodG9rZW4pO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFcnJvck5vZGUodGhpcyk7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgRXJyb3JOb2RlMi5wcm90b3R5cGUsIFwiYWNjZXB0XCIsIG51bGwpO1xuICBleHBvcnRzLkVycm9yTm9kZSA9IEVycm9yTm9kZTI7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL3RyZWUvUnVsZU5vZGUuanNcbnZhciByZXF1aXJlX1J1bGVOb2RlID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5SdWxlTm9kZSA9IHZvaWQgMDtcbiAgdmFyIFJ1bGVOb2RlID0gY2xhc3Mge1xuICB9O1xuICBleHBvcnRzLlJ1bGVOb2RlID0gUnVsZU5vZGU7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL3RyZWUvVHJlZXMuanNcbnZhciByZXF1aXJlX1RyZWVzID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLlRyZWVzID0gdm9pZCAwO1xuICB2YXIgQVROXzEgPSByZXF1aXJlX0FUTigpO1xuICB2YXIgQ29tbW9uVG9rZW5fMSA9IHJlcXVpcmVfQ29tbW9uVG9rZW4oKTtcbiAgdmFyIEVycm9yTm9kZV8xID0gcmVxdWlyZV9FcnJvck5vZGUoKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgUGFyc2VyXzEgPSByZXF1aXJlX1BhcnNlcigpO1xuICB2YXIgUGFyc2VyUnVsZUNvbnRleHRfMSA9IHJlcXVpcmVfUGFyc2VyUnVsZUNvbnRleHQoKTtcbiAgdmFyIFJ1bGVOb2RlXzEgPSByZXF1aXJlX1J1bGVOb2RlKCk7XG4gIHZhciBUZXJtaW5hbE5vZGVfMSA9IHJlcXVpcmVfVGVybWluYWxOb2RlKCk7XG4gIHZhciBUb2tlbl8xID0gcmVxdWlyZV9Ub2tlbigpO1xuICB2YXIgVXRpbHMzID0gcmVxdWlyZV9VdGlscygpO1xuICB2YXIgVHJlZXMgPSBjbGFzcyB7XG4gICAgc3RhdGljIHRvU3RyaW5nVHJlZSh0LCBhcmcyKSB7XG4gICAgICBsZXQgcnVsZU5hbWVzO1xuICAgICAgaWYgKGFyZzIgaW5zdGFuY2VvZiBQYXJzZXJfMS5QYXJzZXIpIHtcbiAgICAgICAgcnVsZU5hbWVzID0gYXJnMi5ydWxlTmFtZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydWxlTmFtZXMgPSBhcmcyO1xuICAgICAgfVxuICAgICAgbGV0IHMgPSBVdGlsczMuZXNjYXBlV2hpdGVzcGFjZSh0aGlzLmdldE5vZGVUZXh0KHQsIHJ1bGVOYW1lcyksIGZhbHNlKTtcbiAgICAgIGlmICh0LmNoaWxkQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9XG4gICAgICBsZXQgYnVmID0gXCJcIjtcbiAgICAgIGJ1ZiArPSBcIihcIjtcbiAgICAgIHMgPSBVdGlsczMuZXNjYXBlV2hpdGVzcGFjZSh0aGlzLmdldE5vZGVUZXh0KHQsIHJ1bGVOYW1lcyksIGZhbHNlKTtcbiAgICAgIGJ1ZiArPSBzO1xuICAgICAgYnVmICs9IFwiIFwiO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0LmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBidWYgKz0gXCIgXCI7XG4gICAgICAgIH1cbiAgICAgICAgYnVmICs9IHRoaXMudG9TdHJpbmdUcmVlKHQuZ2V0Q2hpbGQoaSksIHJ1bGVOYW1lcyk7XG4gICAgICB9XG4gICAgICBidWYgKz0gXCIpXCI7XG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Tm9kZVRleHQodCwgYXJnMikge1xuICAgICAgbGV0IHJ1bGVOYW1lcztcbiAgICAgIGlmIChhcmcyIGluc3RhbmNlb2YgUGFyc2VyXzEuUGFyc2VyKSB7XG4gICAgICAgIHJ1bGVOYW1lcyA9IGFyZzIucnVsZU5hbWVzO1xuICAgICAgfSBlbHNlIGlmIChhcmcyKSB7XG4gICAgICAgIHJ1bGVOYW1lcyA9IGFyZzI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHQucGF5bG9hZDtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkLnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gcGF5bG9hZC50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0LnBheWxvYWQudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0IGluc3RhbmNlb2YgUnVsZU5vZGVfMS5SdWxlTm9kZSkge1xuICAgICAgICBsZXQgcnVsZUNvbnRleHQgPSB0LnJ1bGVDb250ZXh0O1xuICAgICAgICBsZXQgcnVsZUluZGV4ID0gcnVsZUNvbnRleHQucnVsZUluZGV4O1xuICAgICAgICBsZXQgcnVsZU5hbWUgPSBydWxlTmFtZXNbcnVsZUluZGV4XTtcbiAgICAgICAgbGV0IGFsdE51bWJlciA9IHJ1bGVDb250ZXh0LmFsdE51bWJlcjtcbiAgICAgICAgaWYgKGFsdE51bWJlciAhPT0gQVROXzEuQVROLklOVkFMSURfQUxUX05VTUJFUikge1xuICAgICAgICAgIHJldHVybiBydWxlTmFtZSArIFwiOlwiICsgYWx0TnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydWxlTmFtZTtcbiAgICAgIH0gZWxzZSBpZiAodCBpbnN0YW5jZW9mIEVycm9yTm9kZV8xLkVycm9yTm9kZSkge1xuICAgICAgICByZXR1cm4gdC50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIGlmICh0IGluc3RhbmNlb2YgVGVybWluYWxOb2RlXzEuVGVybWluYWxOb2RlKSB7XG4gICAgICAgIGxldCBzeW1ib2wgPSB0LnN5bWJvbDtcbiAgICAgICAgcmV0dXJuIHN5bWJvbC50ZXh0IHx8IFwiXCI7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBub2RlIHR5cGVcIik7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRDaGlsZHJlbih0KSB7XG4gICAgICBsZXQga2lkcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0LmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICBraWRzLnB1c2godC5nZXRDaGlsZChpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2lkcztcbiAgICB9XG4gICAgc3RhdGljIGdldEFuY2VzdG9ycyh0KSB7XG4gICAgICBsZXQgYW5jZXN0b3JzID0gW107XG4gICAgICBsZXQgcCA9IHQucGFyZW50O1xuICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgYW5jZXN0b3JzLnVuc2hpZnQocCk7XG4gICAgICAgIHAgPSBwLnBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbmNlc3RvcnM7XG4gICAgfVxuICAgIHN0YXRpYyBpc0FuY2VzdG9yT2YodCwgdSkge1xuICAgICAgaWYgKCF0IHx8ICF1IHx8ICF0LnBhcmVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBsZXQgcCA9IHUucGFyZW50O1xuICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgaWYgKHQgPT09IHApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBwID0gcC5wYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN0YXRpYyBmaW5kQWxsVG9rZW5Ob2Rlcyh0LCB0dHlwZSkge1xuICAgICAgcmV0dXJuIFRyZWVzLmZpbmRBbGxOb2Rlcyh0LCB0dHlwZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmaW5kQWxsUnVsZU5vZGVzKHQsIHJ1bGVJbmRleCkge1xuICAgICAgcmV0dXJuIFRyZWVzLmZpbmRBbGxOb2Rlcyh0LCBydWxlSW5kZXgsIGZhbHNlKTtcbiAgICB9XG4gICAgc3RhdGljIGZpbmRBbGxOb2Rlcyh0LCBpbmRleCwgZmluZFRva2Vucykge1xuICAgICAgbGV0IG5vZGVzID0gW107XG4gICAgICBUcmVlcy5fZmluZEFsbE5vZGVzKHQsIGluZGV4LCBmaW5kVG9rZW5zLCBub2Rlcyk7XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHN0YXRpYyBfZmluZEFsbE5vZGVzKHQsIGluZGV4LCBmaW5kVG9rZW5zLCBub2Rlcykge1xuICAgICAgaWYgKGZpbmRUb2tlbnMgJiYgdCBpbnN0YW5jZW9mIFRlcm1pbmFsTm9kZV8xLlRlcm1pbmFsTm9kZSkge1xuICAgICAgICBpZiAodC5zeW1ib2wudHlwZSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFmaW5kVG9rZW5zICYmIHQgaW5zdGFuY2VvZiBQYXJzZXJSdWxlQ29udGV4dF8xLlBhcnNlclJ1bGVDb250ZXh0KSB7XG4gICAgICAgIGlmICh0LnJ1bGVJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHQuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgIFRyZWVzLl9maW5kQWxsTm9kZXModC5nZXRDaGlsZChpKSwgaW5kZXgsIGZpbmRUb2tlbnMsIG5vZGVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldERlc2NlbmRhbnRzKHQpIHtcbiAgICAgIGxldCBub2RlcyA9IFtdO1xuICAgICAgZnVuY3Rpb24gcmVjdXJzZShlKSB7XG4gICAgICAgIG5vZGVzLnB1c2goZSk7XG4gICAgICAgIGNvbnN0IG4gPSBlLmNoaWxkQ291bnQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgcmVjdXJzZShlLmdldENoaWxkKGkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVjdXJzZSh0KTtcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgc3RhdGljIGdldFJvb3RPZlN1YnRyZWVFbmNsb3NpbmdSZWdpb24odCwgc3RhcnRUb2tlbkluZGV4LCBzdG9wVG9rZW5JbmRleCkge1xuICAgICAgbGV0IG4gPSB0LmNoaWxkQ291bnQ7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSB0LmdldENoaWxkKGkpO1xuICAgICAgICBsZXQgciA9IFRyZWVzLmdldFJvb3RPZlN1YnRyZWVFbmNsb3NpbmdSZWdpb24oY2hpbGQsIHN0YXJ0VG9rZW5JbmRleCwgc3RvcFRva2VuSW5kZXgpO1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodCBpbnN0YW5jZW9mIFBhcnNlclJ1bGVDb250ZXh0XzEuUGFyc2VyUnVsZUNvbnRleHQpIHtcbiAgICAgICAgbGV0IHN0b3BUb2tlbiA9IHQuc3RvcDtcbiAgICAgICAgaWYgKHN0YXJ0VG9rZW5JbmRleCA+PSB0LnN0YXJ0LnRva2VuSW5kZXggJiYgKHN0b3BUb2tlbiA9PSBudWxsIHx8IHN0b3BUb2tlbkluZGV4IDw9IHN0b3BUb2tlbi50b2tlbkluZGV4KSkge1xuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBzdGF0aWMgc3RyaXBDaGlsZHJlbk91dE9mUmFuZ2UodCwgcm9vdCwgc3RhcnRJbmRleCwgc3RvcEluZGV4KSB7XG4gICAgICBpZiAoIXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGNvdW50ID0gdC5jaGlsZENvdW50O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IHQuZ2V0Q2hpbGQoaSk7XG4gICAgICAgIGxldCByYW5nZSA9IGNoaWxkLnNvdXJjZUludGVydmFsO1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBQYXJzZXJSdWxlQ29udGV4dF8xLlBhcnNlclJ1bGVDb250ZXh0ICYmIChyYW5nZS5iIDwgc3RhcnRJbmRleCB8fCByYW5nZS5hID4gc3RvcEluZGV4KSkge1xuICAgICAgICAgIGlmIChUcmVlcy5pc0FuY2VzdG9yT2YoY2hpbGQsIHJvb3QpKSB7XG4gICAgICAgICAgICBsZXQgYWJicmV2ID0gbmV3IENvbW1vblRva2VuXzEuQ29tbW9uVG9rZW4oVG9rZW5fMS5Ub2tlbi5JTlZBTElEX1RZUEUsIFwiLi4uXCIpO1xuICAgICAgICAgICAgdC5jaGlsZHJlbltpXSA9IG5ldyBUZXJtaW5hbE5vZGVfMS5UZXJtaW5hbE5vZGUoYWJicmV2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZpbmROb2RlU3VjaFRoYXQodCwgcHJlZCkge1xuICAgICAgaWYgKHByZWQodCkpIHtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9XG4gICAgICBsZXQgbiA9IHQuY2hpbGRDb3VudDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGxldCB1ID0gVHJlZXMuZmluZE5vZGVTdWNoVGhhdCh0LmdldENoaWxkKGkpLCBwcmVkKTtcbiAgICAgICAgaWYgKHUgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB1O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgVHJlZXMsIFwidG9TdHJpbmdUcmVlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbCxcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBUcmVlcywgXCJnZXRBbmNlc3RvcnNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIFRyZWVzLCBcImdldFJvb3RPZlN1YnRyZWVFbmNsb3NpbmdSZWdpb25cIiwgbnVsbCk7XG4gIGV4cG9ydHMuVHJlZXMgPSBUcmVlcztcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvUnVsZUNvbnRleHQuanNcbnZhciByZXF1aXJlX1J1bGVDb250ZXh0ID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLlJ1bGVDb250ZXh0ID0gdm9pZCAwO1xuICB2YXIgQVROXzEgPSByZXF1aXJlX0FUTigpO1xuICB2YXIgUmVjb2duaXplcl8xID0gcmVxdWlyZV9SZWNvZ25pemVyKCk7XG4gIHZhciBSdWxlTm9kZV8xID0gcmVxdWlyZV9SdWxlTm9kZSgpO1xuICB2YXIgSW50ZXJ2YWxfMSA9IHJlcXVpcmVfSW50ZXJ2YWwoKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgVHJlZXNfMSA9IHJlcXVpcmVfVHJlZXMoKTtcbiAgdmFyIFBhcnNlclJ1bGVDb250ZXh0XzEgPSByZXF1aXJlX1BhcnNlclJ1bGVDb250ZXh0KCk7XG4gIHZhciBSdWxlQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgUnVsZU5vZGVfMS5SdWxlTm9kZSB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgdGhpcy5pbnZva2luZ1N0YXRlID0gaW52b2tpbmdTdGF0ZSAhPSBudWxsID8gaW52b2tpbmdTdGF0ZSA6IC0xO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q2hpbGRDb250ZXh0KHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgICAgcmV0dXJuIG5ldyBSdWxlQ29udGV4dChwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICAgIH1cbiAgICBkZXB0aCgpIHtcbiAgICAgIGxldCBuID0gMDtcbiAgICAgIGxldCBwID0gdGhpcztcbiAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgIHAgPSBwLl9wYXJlbnQ7XG4gICAgICAgIG4rKztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICBnZXQgaXNFbXB0eSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmludm9raW5nU3RhdGUgPT09IC0xO1xuICAgIH1cbiAgICBnZXQgc291cmNlSW50ZXJ2YWwoKSB7XG4gICAgICByZXR1cm4gSW50ZXJ2YWxfMS5JbnRlcnZhbC5JTlZBTElEO1xuICAgIH1cbiAgICBnZXQgcnVsZUNvbnRleHQoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gICAgfVxuICAgIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgZ2V0IHBheWxvYWQoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZENvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgbGV0IGJ1aWxkZXIgPSBcIlwiO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICBidWlsZGVyICs9IHRoaXMuZ2V0Q2hpbGQoaSkudGV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGdldCBydWxlSW5kZXgoKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGdldCBhbHROdW1iZXIoKSB7XG4gICAgICByZXR1cm4gQVROXzEuQVROLklOVkFMSURfQUxUX05VTUJFUjtcbiAgICB9XG4gICAgc2V0IGFsdE51bWJlcihhbHROdW1iZXIpIHtcbiAgICB9XG4gICAgZ2V0Q2hpbGQoaSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAgYW5kIGxlc3MgdGhhbiBjaGlsZENvdW50XCIpO1xuICAgIH1cbiAgICBnZXQgY2hpbGRDb3VudCgpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmdUcmVlKHJlY29nKSB7XG4gICAgICByZXR1cm4gVHJlZXNfMS5UcmVlcy50b1N0cmluZ1RyZWUodGhpcywgcmVjb2cpO1xuICAgIH1cbiAgICB0b1N0cmluZyhhcmcxLCBzdG9wKSB7XG4gICAgICBjb25zdCBydWxlTmFtZXMgPSBhcmcxIGluc3RhbmNlb2YgUmVjb2duaXplcl8xLlJlY29nbml6ZXIgPyBhcmcxLnJ1bGVOYW1lcyA6IGFyZzE7XG4gICAgICBzdG9wID0gc3RvcCB8fCBQYXJzZXJSdWxlQ29udGV4dF8xLlBhcnNlclJ1bGVDb250ZXh0LmVtcHR5Q29udGV4dCgpO1xuICAgICAgbGV0IGJ1ZiA9IFwiXCI7XG4gICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICBidWYgKz0gXCJbXCI7XG4gICAgICB3aGlsZSAocCAmJiBwICE9PSBzdG9wKSB7XG4gICAgICAgIGlmICghcnVsZU5hbWVzKSB7XG4gICAgICAgICAgaWYgKCFwLmlzRW1wdHkpIHtcbiAgICAgICAgICAgIGJ1ZiArPSBwLmludm9raW5nU3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBydWxlSW5kZXggPSBwLnJ1bGVJbmRleDtcbiAgICAgICAgICBsZXQgcnVsZU5hbWUgPSBydWxlSW5kZXggPj0gMCAmJiBydWxlSW5kZXggPCBydWxlTmFtZXMubGVuZ3RoID8gcnVsZU5hbWVzW3J1bGVJbmRleF0gOiBydWxlSW5kZXgudG9TdHJpbmcoKTtcbiAgICAgICAgICBidWYgKz0gcnVsZU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAuX3BhcmVudCAmJiAocnVsZU5hbWVzIHx8ICFwLl9wYXJlbnQuaXNFbXB0eSkpIHtcbiAgICAgICAgICBidWYgKz0gXCIgXCI7XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAuX3BhcmVudDtcbiAgICAgIH1cbiAgICAgIGJ1ZiArPSBcIl1cIjtcbiAgICAgIHJldHVybiBidWYudG9TdHJpbmcoKTtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBSdWxlQ29udGV4dC5wcm90b3R5cGUsIFwic291cmNlSW50ZXJ2YWxcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBSdWxlQ29udGV4dC5wcm90b3R5cGUsIFwicnVsZUNvbnRleHRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBSdWxlQ29udGV4dC5wcm90b3R5cGUsIFwicGFyZW50XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgUnVsZUNvbnRleHQucHJvdG90eXBlLCBcInNldFBhcmVudFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFJ1bGVDb250ZXh0LnByb3RvdHlwZSwgXCJwYXlsb2FkXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgUnVsZUNvbnRleHQucHJvdG90eXBlLCBcInRleHRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBSdWxlQ29udGV4dC5wcm90b3R5cGUsIFwiZ2V0Q2hpbGRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBSdWxlQ29udGV4dC5wcm90b3R5cGUsIFwiY2hpbGRDb3VudFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFJ1bGVDb250ZXh0LnByb3RvdHlwZSwgXCJhY2NlcHRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBSdWxlQ29udGV4dC5wcm90b3R5cGUsIFwidG9TdHJpbmdUcmVlXCIsIG51bGwpO1xuICBleHBvcnRzLlJ1bGVDb250ZXh0ID0gUnVsZUNvbnRleHQ7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL1BhcnNlclJ1bGVDb250ZXh0LmpzXG52YXIgcmVxdWlyZV9QYXJzZXJSdWxlQ29udGV4dCA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5QYXJzZXJSdWxlQ29udGV4dCA9IHZvaWQgMDtcbiAgdmFyIEVycm9yTm9kZV8xID0gcmVxdWlyZV9FcnJvck5vZGUoKTtcbiAgdmFyIEludGVydmFsXzEgPSByZXF1aXJlX0ludGVydmFsKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIFJ1bGVDb250ZXh0XzEgPSByZXF1aXJlX1J1bGVDb250ZXh0KCk7XG4gIHZhciBUZXJtaW5hbE5vZGVfMSA9IHJlcXVpcmVfVGVybWluYWxOb2RlKCk7XG4gIHZhciBQYXJzZXJSdWxlQ29udGV4dDIgPSBjbGFzcyBleHRlbmRzIFJ1bGVDb250ZXh0XzEuUnVsZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZU51bWJlcikge1xuICAgICAgaWYgKGludm9raW5nU3RhdGVOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlTnVtYmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGVtcHR5Q29udGV4dCgpIHtcbiAgICAgIHJldHVybiBQYXJzZXJSdWxlQ29udGV4dDIuRU1QVFk7XG4gICAgfVxuICAgIGNvcHlGcm9tKGN0eCkge1xuICAgICAgdGhpcy5fcGFyZW50ID0gY3R4Ll9wYXJlbnQ7XG4gICAgICB0aGlzLmludm9raW5nU3RhdGUgPSBjdHguaW52b2tpbmdTdGF0ZTtcbiAgICAgIHRoaXMuX3N0YXJ0ID0gY3R4Ll9zdGFydDtcbiAgICAgIHRoaXMuX3N0b3AgPSBjdHguX3N0b3A7XG4gICAgICBpZiAoY3R4LmNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgY3R4LmNoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgRXJyb3JOb2RlXzEuRXJyb3JOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZENoaWxkKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgfVxuICAgIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgfVxuICAgIGFkZEFueUNoaWxkKHQpIHtcbiAgICAgIGlmICghdGhpcy5jaGlsZHJlbikge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW3RdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICAgIGFkZENoaWxkKHQpIHtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICBpZiAodCBpbnN0YW5jZW9mIFRlcm1pbmFsTm9kZV8xLlRlcm1pbmFsTm9kZSkge1xuICAgICAgICB0LnNldFBhcmVudCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRBbnlDaGlsZCh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICh0IGluc3RhbmNlb2YgUnVsZUNvbnRleHRfMS5SdWxlQ29udGV4dCkge1xuICAgICAgICB0aGlzLmFkZEFueUNoaWxkKHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ID0gbmV3IFRlcm1pbmFsTm9kZV8xLlRlcm1pbmFsTm9kZSh0KTtcbiAgICAgICAgdGhpcy5hZGRBbnlDaGlsZCh0KTtcbiAgICAgICAgdC5zZXRQYXJlbnQodGhpcyk7XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfVxuICAgIH1cbiAgICBhZGRFcnJvck5vZGUobm9kZSkge1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFcnJvck5vZGVfMS5FcnJvck5vZGUpIHtcbiAgICAgICAgY29uc3QgZXJyb3JOb2RlID0gbm9kZTtcbiAgICAgICAgZXJyb3JOb2RlLnNldFBhcmVudCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkQW55Q2hpbGQoZXJyb3JOb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJhZFRva2VuID0gbm9kZTtcbiAgICAgICAgbGV0IHQgPSBuZXcgRXJyb3JOb2RlXzEuRXJyb3JOb2RlKGJhZFRva2VuKTtcbiAgICAgICAgdGhpcy5hZGRBbnlDaGlsZCh0KTtcbiAgICAgICAgdC5zZXRQYXJlbnQodGhpcyk7XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVMYXN0Q2hpbGQoKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbikge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgbGV0IHBhcmVudCA9IHN1cGVyLnBhcmVudDtcbiAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCB8fCBwYXJlbnQgaW5zdGFuY2VvZiBQYXJzZXJSdWxlQ29udGV4dDIpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHBhcmVudCB0eXBlIGZvciBQYXJzZXJSdWxlQ29udGV4dFwiKTtcbiAgICB9XG4gICAgZ2V0Q2hpbGQoaSwgY3R4VHlwZSkge1xuICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuIHx8IGkgPCAwIHx8IGkgPj0gdGhpcy5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbmRleCBwYXJhbWV0ZXIgbXVzdCBiZSBiZXR3ZWVuID49IDAgYW5kIDw9IG51bWJlciBvZiBjaGlsZHJlbi5cIik7XG4gICAgICB9XG4gICAgICBpZiAoY3R4VHlwZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgfVxuICAgICAgbGV0IHJlc3VsdCA9IHRoaXMudHJ5R2V0Q2hpbGQoaSwgY3R4VHlwZSk7XG4gICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNwZWNpZmllZCBub2RlIGRvZXMgbm90IGV4aXN0XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdHJ5R2V0Q2hpbGQoaSwgY3R4VHlwZSkge1xuICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuIHx8IGkgPCAwIHx8IGkgPj0gdGhpcy5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGxldCBqID0gLTE7XG4gICAgICBmb3IgKGxldCBvIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKG8gaW5zdGFuY2VvZiBjdHhUeXBlKSB7XG4gICAgICAgICAgaisrO1xuICAgICAgICAgIGlmIChqID09PSBpKSB7XG4gICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGdldFRva2VuKHR0eXBlLCBpKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gdGhpcy50cnlHZXRUb2tlbih0dHlwZSwgaSk7XG4gICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNwZWNpZmllZCB0b2tlbiBkb2VzIG5vdCBleGlzdFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRyeUdldFRva2VuKHR0eXBlLCBpKSB7XG4gICAgICBpZiAoIXRoaXMuY2hpbGRyZW4gfHwgaSA8IDAgfHwgaSA+PSB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgbGV0IGogPSAtMTtcbiAgICAgIGZvciAobGV0IG8gb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICBpZiAobyBpbnN0YW5jZW9mIFRlcm1pbmFsTm9kZV8xLlRlcm1pbmFsTm9kZSkge1xuICAgICAgICAgIGxldCBzeW1ib2wgPSBvLnN5bWJvbDtcbiAgICAgICAgICBpZiAoc3ltYm9sLnR5cGUgPT09IHR0eXBlKSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgICAgICBpZiAoaiA9PT0gaSkge1xuICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGdldFRva2Vucyh0dHlwZSkge1xuICAgICAgbGV0IHRva2VuczIgPSBbXTtcbiAgICAgIGlmICghdGhpcy5jaGlsZHJlbikge1xuICAgICAgICByZXR1cm4gdG9rZW5zMjtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IG8gb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICBpZiAobyBpbnN0YW5jZW9mIFRlcm1pbmFsTm9kZV8xLlRlcm1pbmFsTm9kZSkge1xuICAgICAgICAgIGxldCBzeW1ib2wgPSBvLnN5bWJvbDtcbiAgICAgICAgICBpZiAoc3ltYm9sLnR5cGUgPT09IHR0eXBlKSB7XG4gICAgICAgICAgICB0b2tlbnMyLnB1c2gobyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9rZW5zMjtcbiAgICB9XG4gICAgZ2V0IHJ1bGVDb250ZXh0KCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldFJ1bGVDb250ZXh0KGksIGN0eFR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldENoaWxkKGksIGN0eFR5cGUpO1xuICAgIH1cbiAgICB0cnlHZXRSdWxlQ29udGV4dChpLCBjdHhUeXBlKSB7XG4gICAgICByZXR1cm4gdGhpcy50cnlHZXRDaGlsZChpLCBjdHhUeXBlKTtcbiAgICB9XG4gICAgZ2V0UnVsZUNvbnRleHRzKGN0eFR5cGUpIHtcbiAgICAgIGxldCBjb250ZXh0cyA9IFtdO1xuICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0cztcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IG8gb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICBpZiAobyBpbnN0YW5jZW9mIGN0eFR5cGUpIHtcbiAgICAgICAgICBjb250ZXh0cy5wdXNoKG8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGV4dHM7XG4gICAgfVxuICAgIGdldCBjaGlsZENvdW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4gPyB0aGlzLmNoaWxkcmVuLmxlbmd0aCA6IDA7XG4gICAgfVxuICAgIGdldCBzb3VyY2VJbnRlcnZhbCgpIHtcbiAgICAgIGlmICghdGhpcy5fc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIEludGVydmFsXzEuSW50ZXJ2YWwuSU5WQUxJRDtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fc3RvcCB8fCB0aGlzLl9zdG9wLnRva2VuSW5kZXggPCB0aGlzLl9zdGFydC50b2tlbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBJbnRlcnZhbF8xLkludGVydmFsLm9mKHRoaXMuX3N0YXJ0LnRva2VuSW5kZXgsIHRoaXMuX3N0YXJ0LnRva2VuSW5kZXggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBJbnRlcnZhbF8xLkludGVydmFsLm9mKHRoaXMuX3N0YXJ0LnRva2VuSW5kZXgsIHRoaXMuX3N0b3AudG9rZW5JbmRleCk7XG4gICAgfVxuICAgIGdldCBzdGFydCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGFydDtcbiAgICB9XG4gICAgZ2V0IHN0b3AoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RvcDtcbiAgICB9XG4gICAgdG9JbmZvU3RyaW5nKHJlY29nbml6ZXIpIHtcbiAgICAgIGxldCBydWxlcyA9IHJlY29nbml6ZXIuZ2V0UnVsZUludm9jYXRpb25TdGFjayh0aGlzKS5yZXZlcnNlKCk7XG4gICAgICByZXR1cm4gXCJQYXJzZXJSdWxlQ29udGV4dFwiICsgcnVsZXMgKyBcIntzdGFydD1cIiArIHRoaXMuX3N0YXJ0ICsgXCIsIHN0b3A9XCIgKyB0aGlzLl9zdG9wICsgXCJ9XCI7XG4gICAgfVxuICB9O1xuICBQYXJzZXJSdWxlQ29udGV4dDIuRU1QVFkgPSBuZXcgUGFyc2VyUnVsZUNvbnRleHQyKCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBQYXJzZXJSdWxlQ29udGV4dDIucHJvdG90eXBlLCBcInBhcmVudFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFBhcnNlclJ1bGVDb250ZXh0Mi5wcm90b3R5cGUsIFwiY2hpbGRDb3VudFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFBhcnNlclJ1bGVDb250ZXh0Mi5wcm90b3R5cGUsIFwic291cmNlSW50ZXJ2YWxcIiwgbnVsbCk7XG4gIGV4cG9ydHMuUGFyc2VyUnVsZUNvbnRleHQgPSBQYXJzZXJSdWxlQ29udGV4dDI7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9QcmVkaWN0aW9uTW9kZS5qc1xudmFyIHJlcXVpcmVfUHJlZGljdGlvbk1vZGUgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuUHJlZGljdGlvbk1vZGUgPSB2b2lkIDA7XG4gIHZhciBBcnJheTJESGFzaE1hcF8xID0gcmVxdWlyZV9BcnJheTJESGFzaE1hcCgpO1xuICB2YXIgTXVybXVySGFzaF8xID0gcmVxdWlyZV9NdXJtdXJIYXNoKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIFJ1bGVTdG9wU3RhdGVfMSA9IHJlcXVpcmVfUnVsZVN0b3BTdGF0ZSgpO1xuICB2YXIgUHJlZGljdGlvbk1vZGU7XG4gIChmdW5jdGlvbihQcmVkaWN0aW9uTW9kZTIpIHtcbiAgICBQcmVkaWN0aW9uTW9kZTJbUHJlZGljdGlvbk1vZGUyW1wiU0xMXCJdID0gMF0gPSBcIlNMTFwiO1xuICAgIFByZWRpY3Rpb25Nb2RlMltQcmVkaWN0aW9uTW9kZTJbXCJMTFwiXSA9IDFdID0gXCJMTFwiO1xuICAgIFByZWRpY3Rpb25Nb2RlMltQcmVkaWN0aW9uTW9kZTJbXCJMTF9FWEFDVF9BTUJJR19ERVRFQ1RJT05cIl0gPSAyXSA9IFwiTExfRVhBQ1RfQU1CSUdfREVURUNUSU9OXCI7XG4gIH0pKFByZWRpY3Rpb25Nb2RlID0gZXhwb3J0cy5QcmVkaWN0aW9uTW9kZSB8fCAoZXhwb3J0cy5QcmVkaWN0aW9uTW9kZSA9IHt9KSk7XG4gIChmdW5jdGlvbihQcmVkaWN0aW9uTW9kZTIpIHtcbiAgICBjbGFzcyBBbHRBbmRDb250ZXh0TWFwIGV4dGVuZHMgQXJyYXkyREhhc2hNYXBfMS5BcnJheTJESGFzaE1hcCB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoQWx0QW5kQ29udGV4dENvbmZpZ0VxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNsYXNzIEFsdEFuZENvbnRleHRDb25maWdFcXVhbGl0eUNvbXBhcmF0b3Ige1xuICAgICAgQWx0QW5kQ29udGV4dENvbmZpZ0VxdWFsaXR5Q29tcGFyYXRvcigpIHtcbiAgICAgIH1cbiAgICAgIGhhc2hDb2RlKG8pIHtcbiAgICAgICAgbGV0IGhhc2hDb2RlID0gTXVybXVySGFzaF8xLk11cm11ckhhc2guaW5pdGlhbGl6ZSg3KTtcbiAgICAgICAgaGFzaENvZGUgPSBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC51cGRhdGUoaGFzaENvZGUsIG8uc3RhdGUuc3RhdGVOdW1iZXIpO1xuICAgICAgICBoYXNoQ29kZSA9IE11cm11ckhhc2hfMS5NdXJtdXJIYXNoLnVwZGF0ZShoYXNoQ29kZSwgby5jb250ZXh0KTtcbiAgICAgICAgaGFzaENvZGUgPSBNdXJtdXJIYXNoXzEuTXVybXVySGFzaC5maW5pc2goaGFzaENvZGUsIDIpO1xuICAgICAgICByZXR1cm4gaGFzaENvZGU7XG4gICAgICB9XG4gICAgICBlcXVhbHMoYSwgYikge1xuICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhLnN0YXRlLnN0YXRlTnVtYmVyID09PSBiLnN0YXRlLnN0YXRlTnVtYmVyICYmIGEuY29udGV4dC5lcXVhbHMoYi5jb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgQWx0QW5kQ29udGV4dENvbmZpZ0VxdWFsaXR5Q29tcGFyYXRvci5JTlNUQU5DRSA9IG5ldyBBbHRBbmRDb250ZXh0Q29uZmlnRXF1YWxpdHlDb21wYXJhdG9yKCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgICBdLCBBbHRBbmRDb250ZXh0Q29uZmlnRXF1YWxpdHlDb21wYXJhdG9yLnByb3RvdHlwZSwgXCJoYXNoQ29kZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICAgIF0sIEFsdEFuZENvbnRleHRDb25maWdFcXVhbGl0eUNvbXBhcmF0b3IucHJvdG90eXBlLCBcImVxdWFsc1wiLCBudWxsKTtcbiAgICBmdW5jdGlvbiBoYXNDb25maWdJblJ1bGVTdG9wU3RhdGUoY29uZmlncykge1xuICAgICAgZm9yIChsZXQgYyBvZiBjb25maWdzKSB7XG4gICAgICAgIGlmIChjLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZV8xLlJ1bGVTdG9wU3RhdGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBQcmVkaWN0aW9uTW9kZTIuaGFzQ29uZmlnSW5SdWxlU3RvcFN0YXRlID0gaGFzQ29uZmlnSW5SdWxlU3RvcFN0YXRlO1xuICAgIGZ1bmN0aW9uIGFsbENvbmZpZ3NJblJ1bGVTdG9wU3RhdGVzKGNvbmZpZ3MpIHtcbiAgICAgIGZvciAobGV0IGNvbmZpZyBvZiBjb25maWdzKSB7XG4gICAgICAgIGlmICghKGNvbmZpZy5zdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGVfMS5SdWxlU3RvcFN0YXRlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFByZWRpY3Rpb25Nb2RlMi5hbGxDb25maWdzSW5SdWxlU3RvcFN0YXRlcyA9IGFsbENvbmZpZ3NJblJ1bGVTdG9wU3RhdGVzO1xuICB9KShQcmVkaWN0aW9uTW9kZSA9IGV4cG9ydHMuUHJlZGljdGlvbk1vZGUgfHwgKGV4cG9ydHMuUHJlZGljdGlvbk1vZGUgPSB7fSkpO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9hdG4vU2ltdWxhdG9yU3RhdGUuanNcbnZhciByZXF1aXJlX1NpbXVsYXRvclN0YXRlID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLlNpbXVsYXRvclN0YXRlID0gdm9pZCAwO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBQYXJzZXJSdWxlQ29udGV4dF8xID0gcmVxdWlyZV9QYXJzZXJSdWxlQ29udGV4dCgpO1xuICB2YXIgU2ltdWxhdG9yU3RhdGUgPSBjbGFzcyBTaW11bGF0b3JTdGF0ZSB7XG4gICAgY29uc3RydWN0b3Iob3V0ZXJDb250ZXh0LCBzMCwgdXNlQ29udGV4dCwgcmVtYWluaW5nT3V0ZXJDb250ZXh0KSB7XG4gICAgICB0aGlzLm91dGVyQ29udGV4dCA9IG91dGVyQ29udGV4dCAhPSBudWxsID8gb3V0ZXJDb250ZXh0IDogUGFyc2VyUnVsZUNvbnRleHRfMS5QYXJzZXJSdWxlQ29udGV4dC5lbXB0eUNvbnRleHQoKTtcbiAgICAgIHRoaXMuczAgPSBzMDtcbiAgICAgIHRoaXMudXNlQ29udGV4dCA9IHVzZUNvbnRleHQ7XG4gICAgICB0aGlzLnJlbWFpbmluZ091dGVyQ29udGV4dCA9IHJlbWFpbmluZ091dGVyQ29udGV4dDtcbiAgICB9XG4gIH07XG4gIFNpbXVsYXRvclN0YXRlID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgU2ltdWxhdG9yU3RhdGUpO1xuICBleHBvcnRzLlNpbXVsYXRvclN0YXRlID0gU2ltdWxhdG9yU3RhdGU7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9QYXJzZXJBVE5TaW11bGF0b3IuanNcbnZhciByZXF1aXJlX1BhcnNlckFUTlNpbXVsYXRvciA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgdmFyIF9fcGFyYW0gPSBleHBvcnRzICYmIGV4cG9ydHMuX19wYXJhbSB8fCBmdW5jdGlvbihwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7XG4gICAgfTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5QYXJzZXJBVE5TaW11bGF0b3IgPSB2b2lkIDA7XG4gIHZhciBBY2NlcHRTdGF0ZUluZm9fMSA9IHJlcXVpcmVfQWNjZXB0U3RhdGVJbmZvKCk7XG4gIHZhciBBY3Rpb25UcmFuc2l0aW9uXzEgPSByZXF1aXJlX0FjdGlvblRyYW5zaXRpb24oKTtcbiAgdmFyIEFycmF5MkRIYXNoU2V0XzEgPSByZXF1aXJlX0FycmF5MkRIYXNoU2V0KCk7XG4gIHZhciBBcnJheXNfMSA9IHJlcXVpcmVfQXJyYXlzKCk7XG4gIHZhciBBVE5fMSA9IHJlcXVpcmVfQVROKCk7XG4gIHZhciBBVE5Db25maWdfMSA9IHJlcXVpcmVfQVROQ29uZmlnKCk7XG4gIHZhciBBVE5Db25maWdTZXRfMSA9IHJlcXVpcmVfQVROQ29uZmlnU2V0KCk7XG4gIHZhciBBVE5TaW11bGF0b3JfMSA9IHJlcXVpcmVfQVROU2ltdWxhdG9yKCk7XG4gIHZhciBBVE5TdGF0ZVR5cGVfMSA9IHJlcXVpcmVfQVROU3RhdGVUeXBlKCk7XG4gIHZhciBBdG9tVHJhbnNpdGlvbl8xID0gcmVxdWlyZV9BdG9tVHJhbnNpdGlvbigpO1xuICB2YXIgQml0U2V0XzEgPSByZXF1aXJlX0JpdFNldCgpO1xuICB2YXIgQ29uZmxpY3RJbmZvXzEgPSByZXF1aXJlX0NvbmZsaWN0SW5mbygpO1xuICB2YXIgRGVjaXNpb25TdGF0ZV8xID0gcmVxdWlyZV9EZWNpc2lvblN0YXRlKCk7XG4gIHZhciBERkFTdGF0ZV8xID0gcmVxdWlyZV9ERkFTdGF0ZSgpO1xuICB2YXIgSW50ZWdlckxpc3RfMSA9IHJlcXVpcmVfSW50ZWdlckxpc3QoKTtcbiAgdmFyIEludGVydmFsXzEgPSByZXF1aXJlX0ludGVydmFsKCk7XG4gIHZhciBJbnRTdHJlYW1fMSA9IHJlcXVpcmVfSW50U3RyZWFtKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIE5vdFNldFRyYW5zaXRpb25fMSA9IHJlcXVpcmVfTm90U2V0VHJhbnNpdGlvbigpO1xuICB2YXIgTm9WaWFibGVBbHRFeGNlcHRpb25fMSA9IHJlcXVpcmVfTm9WaWFibGVBbHRFeGNlcHRpb24oKTtcbiAgdmFyIE9iamVjdEVxdWFsaXR5Q29tcGFyYXRvcl8xID0gcmVxdWlyZV9PYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IoKTtcbiAgdmFyIFBhcnNlclJ1bGVDb250ZXh0XzEgPSByZXF1aXJlX1BhcnNlclJ1bGVDb250ZXh0KCk7XG4gIHZhciBQcmVkaWN0aW9uQ29udGV4dF8xID0gcmVxdWlyZV9QcmVkaWN0aW9uQ29udGV4dCgpO1xuICB2YXIgUHJlZGljdGlvbkNvbnRleHRDYWNoZV8xID0gcmVxdWlyZV9QcmVkaWN0aW9uQ29udGV4dENhY2hlKCk7XG4gIHZhciBQcmVkaWN0aW9uTW9kZV8xID0gcmVxdWlyZV9QcmVkaWN0aW9uTW9kZSgpO1xuICB2YXIgUnVsZVN0b3BTdGF0ZV8xID0gcmVxdWlyZV9SdWxlU3RvcFN0YXRlKCk7XG4gIHZhciBSdWxlVHJhbnNpdGlvbl8xID0gcmVxdWlyZV9SdWxlVHJhbnNpdGlvbigpO1xuICB2YXIgU2VtYW50aWNDb250ZXh0XzEgPSByZXF1aXJlX1NlbWFudGljQ29udGV4dCgpO1xuICB2YXIgU2V0VHJhbnNpdGlvbl8xID0gcmVxdWlyZV9TZXRUcmFuc2l0aW9uKCk7XG4gIHZhciBTaW11bGF0b3JTdGF0ZV8xID0gcmVxdWlyZV9TaW11bGF0b3JTdGF0ZSgpO1xuICB2YXIgVG9rZW5fMSA9IHJlcXVpcmVfVG9rZW4oKTtcbiAgdmFyIFZvY2FidWxhcnlJbXBsXzEgPSByZXF1aXJlX1ZvY2FidWxhcnlJbXBsKCk7XG4gIHZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuICB2YXIgTUFYX1NIT1JUX1ZBTFVFID0gNjU1MzU7XG4gIHZhciBNSU5fSU5URUdFUl9WQUxVRSA9IC0oMSA8PCAzMSA+Pj4gMCk7XG4gIHZhciBQYXJzZXJBVE5TaW11bGF0b3IyID0gY2xhc3MgUGFyc2VyQVROU2ltdWxhdG9yMyBleHRlbmRzIEFUTlNpbXVsYXRvcl8xLkFUTlNpbXVsYXRvciB7XG4gICAgY29uc3RydWN0b3IoYXRuLCBwYXJzZXIpIHtcbiAgICAgIHN1cGVyKGF0bik7XG4gICAgICB0aGlzLnByZWRpY3Rpb25Nb2RlID0gUHJlZGljdGlvbk1vZGVfMS5QcmVkaWN0aW9uTW9kZS5MTDtcbiAgICAgIHRoaXMuZm9yY2VfZ2xvYmFsX2NvbnRleHQgPSBmYWxzZTtcbiAgICAgIHRoaXMuYWx3YXlzX3RyeV9sb2NhbF9jb250ZXh0ID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW5hYmxlX2dsb2JhbF9jb250ZXh0X2RmYSA9IGZhbHNlO1xuICAgICAgdGhpcy5vcHRpbWl6ZV91bmlxdWVfY2xvc3VyZSA9IHRydWU7XG4gICAgICB0aGlzLm9wdGltaXplX2xsMSA9IHRydWU7XG4gICAgICB0aGlzLm9wdGltaXplX3RhaWxfY2FsbHMgPSB0cnVlO1xuICAgICAgdGhpcy50YWlsX2NhbGxfcHJlc2VydmVzX3NsbCA9IHRydWU7XG4gICAgICB0aGlzLnRyZWF0X3NsbGsxX2NvbmZsaWN0X2FzX2FtYmlndWl0eSA9IGZhbHNlO1xuICAgICAgdGhpcy5yZXBvcnRBbWJpZ3VpdGllcyA9IGZhbHNlO1xuICAgICAgdGhpcy51c2VyV2FudHNDdHhTZW5zaXRpdmUgPSB0cnVlO1xuICAgICAgdGhpcy5fcGFyc2VyID0gcGFyc2VyO1xuICAgIH1cbiAgICBnZXRQcmVkaWN0aW9uTW9kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY3Rpb25Nb2RlO1xuICAgIH1cbiAgICBzZXRQcmVkaWN0aW9uTW9kZShwcmVkaWN0aW9uTW9kZSkge1xuICAgICAgdGhpcy5wcmVkaWN0aW9uTW9kZSA9IHByZWRpY3Rpb25Nb2RlO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICB9XG4gICAgYWRhcHRpdmVQcmVkaWN0KGlucHV0LCBkZWNpc2lvbiwgb3V0ZXJDb250ZXh0LCB1c2VDb250ZXh0KSB7XG4gICAgICBpZiAodXNlQ29udGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHVzZUNvbnRleHQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxldCBkZmEgPSB0aGlzLmF0bi5kZWNpc2lvblRvREZBW2RlY2lzaW9uXTtcbiAgICAgIGFzc2VydChkZmEgIT0gbnVsbCk7XG4gICAgICBpZiAodGhpcy5vcHRpbWl6ZV9sbDEgJiYgIWRmYS5pc1ByZWNlZGVuY2VEZmEgJiYgIWRmYS5pc0VtcHR5KSB7XG4gICAgICAgIGxldCBsbF8xID0gaW5wdXQuTEEoMSk7XG4gICAgICAgIGlmIChsbF8xID49IDAgJiYgbGxfMSA8PSA2NTUzNSkge1xuICAgICAgICAgIGxldCBrZXkgPSAoZGVjaXNpb24gPDwgMTYgPj4+IDApICsgbGxfMTtcbiAgICAgICAgICBsZXQgYWx0ID0gdGhpcy5hdG4uTEwxVGFibGUuZ2V0KGtleSk7XG4gICAgICAgICAgaWYgKGFsdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5kZmEgPSBkZmE7XG4gICAgICBpZiAodGhpcy5mb3JjZV9nbG9iYWxfY29udGV4dCkge1xuICAgICAgICB1c2VDb250ZXh0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuYWx3YXlzX3RyeV9sb2NhbF9jb250ZXh0KSB7XG4gICAgICAgIHVzZUNvbnRleHQgPSB1c2VDb250ZXh0IHx8IGRmYS5pc0NvbnRleHRTZW5zaXRpdmU7XG4gICAgICB9XG4gICAgICB0aGlzLnVzZXJXYW50c0N0eFNlbnNpdGl2ZSA9IHVzZUNvbnRleHQgfHwgdGhpcy5wcmVkaWN0aW9uTW9kZSAhPT0gUHJlZGljdGlvbk1vZGVfMS5QcmVkaWN0aW9uTW9kZS5TTEwgJiYgb3V0ZXJDb250ZXh0ICE9IG51bGwgJiYgIXRoaXMuYXRuLmRlY2lzaW9uVG9TdGF0ZVtkZWNpc2lvbl0uc2xsO1xuICAgICAgaWYgKG91dGVyQ29udGV4dCA9PSBudWxsKSB7XG4gICAgICAgIG91dGVyQ29udGV4dCA9IFBhcnNlclJ1bGVDb250ZXh0XzEuUGFyc2VyUnVsZUNvbnRleHQuZW1wdHlDb250ZXh0KCk7XG4gICAgICB9XG4gICAgICBsZXQgc3RhdGU7XG4gICAgICBpZiAoIWRmYS5pc0VtcHR5KSB7XG4gICAgICAgIHN0YXRlID0gdGhpcy5nZXRTdGFydFN0YXRlKGRmYSwgaW5wdXQsIG91dGVyQ29udGV4dCwgdXNlQ29udGV4dCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUgPT0gbnVsbCkge1xuICAgICAgICBpZiAob3V0ZXJDb250ZXh0ID09IG51bGwpIHtcbiAgICAgICAgICBvdXRlckNvbnRleHQgPSBQYXJzZXJSdWxlQ29udGV4dF8xLlBhcnNlclJ1bGVDb250ZXh0LmVtcHR5Q29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChQYXJzZXJBVE5TaW11bGF0b3IzLmRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJBVE4gZGVjaXNpb24gXCIgKyBkZmEuZGVjaXNpb24gKyBcIiBleGVjIExBKDEpPT1cIiArIHRoaXMuZ2V0TG9va2FoZWFkTmFtZShpbnB1dCkgKyBcIiwgb3V0ZXJDb250ZXh0PVwiICsgb3V0ZXJDb250ZXh0LnRvU3RyaW5nKHRoaXMuX3BhcnNlcikpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlID0gdGhpcy5jb21wdXRlU3RhcnRTdGF0ZShkZmEsIG91dGVyQ29udGV4dCwgdXNlQ29udGV4dCk7XG4gICAgICB9XG4gICAgICBsZXQgbSA9IGlucHV0Lm1hcmsoKTtcbiAgICAgIGxldCBpbmRleCA9IGlucHV0LmluZGV4O1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGFsdCA9IHRoaXMuZXhlY0RGQShkZmEsIGlucHV0LCBpbmRleCwgc3RhdGUpO1xuICAgICAgICBpZiAoUGFyc2VyQVROU2ltdWxhdG9yMy5kZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiREZBIGFmdGVyIHByZWRpY3RBVE46IFwiICsgZGZhLnRvU3RyaW5nKHRoaXMuX3BhcnNlci52b2NhYnVsYXJ5LCB0aGlzLl9wYXJzZXIucnVsZU5hbWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsdDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuZGZhID0gdm9pZCAwO1xuICAgICAgICBpbnB1dC5zZWVrKGluZGV4KTtcbiAgICAgICAgaW5wdXQucmVsZWFzZShtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0U3RhcnRTdGF0ZShkZmEsIGlucHV0LCBvdXRlckNvbnRleHQsIHVzZUNvbnRleHQpIHtcbiAgICAgIGlmICghdXNlQ29udGV4dCkge1xuICAgICAgICBpZiAoZGZhLmlzUHJlY2VkZW5jZURmYSkge1xuICAgICAgICAgIGxldCBzdGF0ZSA9IGRmYS5nZXRQcmVjZWRlbmNlU3RhcnRTdGF0ZSh0aGlzLl9wYXJzZXIucHJlY2VkZW5jZSwgZmFsc2UpO1xuICAgICAgICAgIGlmIChzdGF0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFNpbXVsYXRvclN0YXRlXzEuU2ltdWxhdG9yU3RhdGUob3V0ZXJDb250ZXh0LCBzdGF0ZSwgZmFsc2UsIG91dGVyQ29udGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGRmYS5zMCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFNpbXVsYXRvclN0YXRlXzEuU2ltdWxhdG9yU3RhdGUob3V0ZXJDb250ZXh0LCBkZmEuczAsIGZhbHNlLCBvdXRlckNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlX2dsb2JhbF9jb250ZXh0X2RmYSkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgbGV0IHJlbWFpbmluZ0NvbnRleHQgPSBvdXRlckNvbnRleHQ7XG4gICAgICBhc3NlcnQob3V0ZXJDb250ZXh0ICE9IG51bGwpO1xuICAgICAgbGV0IHMwO1xuICAgICAgaWYgKGRmYS5pc1ByZWNlZGVuY2VEZmEpIHtcbiAgICAgICAgczAgPSBkZmEuZ2V0UHJlY2VkZW5jZVN0YXJ0U3RhdGUodGhpcy5fcGFyc2VyLnByZWNlZGVuY2UsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczAgPSBkZmEuczBmdWxsO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHJlbWFpbmluZ0NvbnRleHQgIT0gbnVsbCAmJiBzMCAhPSBudWxsICYmIHMwLmlzQ29udGV4dFNlbnNpdGl2ZSkge1xuICAgICAgICByZW1haW5pbmdDb250ZXh0ID0gdGhpcy5za2lwVGFpbENhbGxzKHJlbWFpbmluZ0NvbnRleHQpO1xuICAgICAgICBzMCA9IHMwLmdldENvbnRleHRUYXJnZXQodGhpcy5nZXRSZXR1cm5TdGF0ZShyZW1haW5pbmdDb250ZXh0KSk7XG4gICAgICAgIGlmIChyZW1haW5pbmdDb250ZXh0LmlzRW1wdHkpIHtcbiAgICAgICAgICBhc3NlcnQoczAgPT0gbnVsbCB8fCAhczAuaXNDb250ZXh0U2Vuc2l0aXZlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1haW5pbmdDb250ZXh0ID0gcmVtYWluaW5nQ29udGV4dC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzMCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFNpbXVsYXRvclN0YXRlXzEuU2ltdWxhdG9yU3RhdGUob3V0ZXJDb250ZXh0LCBzMCwgdXNlQ29udGV4dCwgcmVtYWluaW5nQ29udGV4dCk7XG4gICAgfVxuICAgIGV4ZWNERkEoZGZhLCBpbnB1dCwgc3RhcnRJbmRleCwgc3RhdGUpIHtcbiAgICAgIGxldCBvdXRlckNvbnRleHQgPSBzdGF0ZS5vdXRlckNvbnRleHQ7XG4gICAgICBpZiAoUGFyc2VyQVROU2ltdWxhdG9yMy5kZmFfZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJERkEgZGVjaXNpb24gXCIgKyBkZmEuZGVjaXNpb24gKyBcIiBleGVjIExBKDEpPT1cIiArIHRoaXMuZ2V0TG9va2FoZWFkTmFtZShpbnB1dCkgKyBcIiwgb3V0ZXJDb250ZXh0PVwiICsgb3V0ZXJDb250ZXh0LnRvU3RyaW5nKHRoaXMuX3BhcnNlcikpO1xuICAgICAgfVxuICAgICAgaWYgKFBhcnNlckFUTlNpbXVsYXRvcjMuZGZhX2RlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGRmYS50b1N0cmluZyh0aGlzLl9wYXJzZXIudm9jYWJ1bGFyeSwgdGhpcy5fcGFyc2VyLnJ1bGVOYW1lcykpO1xuICAgICAgfVxuICAgICAgbGV0IHMgPSBzdGF0ZS5zMDtcbiAgICAgIGxldCB0ID0gaW5wdXQuTEEoMSk7XG4gICAgICBsZXQgcmVtYWluaW5nT3V0ZXJDb250ZXh0ID0gc3RhdGUucmVtYWluaW5nT3V0ZXJDb250ZXh0O1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKFBhcnNlckFUTlNpbXVsYXRvcjMuZGZhX2RlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJERkEgc3RhdGUgXCIgKyBzLnN0YXRlTnVtYmVyICsgXCIgTEEoMSk9PVwiICsgdGhpcy5nZXRMb29rYWhlYWROYW1lKGlucHV0KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLnVzZUNvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAocy5pc0NvbnRleHRTeW1ib2wodCkpIHtcbiAgICAgICAgICAgIGxldCBuZXh0O1xuICAgICAgICAgICAgaWYgKHJlbWFpbmluZ091dGVyQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlbWFpbmluZ091dGVyQ29udGV4dCA9IHRoaXMuc2tpcFRhaWxDYWxscyhyZW1haW5pbmdPdXRlckNvbnRleHQpO1xuICAgICAgICAgICAgICBuZXh0ID0gcy5nZXRDb250ZXh0VGFyZ2V0KHRoaXMuZ2V0UmV0dXJuU3RhdGUocmVtYWluaW5nT3V0ZXJDb250ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGxldCBpbml0aWFsU3RhdGUgPSBuZXcgU2ltdWxhdG9yU3RhdGVfMS5TaW11bGF0b3JTdGF0ZShzdGF0ZS5vdXRlckNvbnRleHQsIHMsIHN0YXRlLnVzZUNvbnRleHQsIHJlbWFpbmluZ091dGVyQ29udGV4dCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4ZWNBVE4oZGZhLCBpbnB1dCwgc3RhcnRJbmRleCwgaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydChyZW1haW5pbmdPdXRlckNvbnRleHQgIT0gbnVsbCk7XG4gICAgICAgICAgICByZW1haW5pbmdPdXRlckNvbnRleHQgPSByZW1haW5pbmdPdXRlckNvbnRleHQucGFyZW50O1xuICAgICAgICAgICAgcyA9IG5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzQWNjZXB0U3RhdGUocywgc3RhdGUudXNlQ29udGV4dCkpIHtcbiAgICAgICAgICBpZiAocy5wcmVkaWNhdGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChQYXJzZXJBVE5TaW11bGF0b3IzLmRmYV9kZWJ1Zykge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImFjY2VwdCBcIiArIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoUGFyc2VyQVROU2ltdWxhdG9yMy5kZmFfZGVidWcpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJhY2NlcHQ7IHByZWRpY3QgXCIgKyBzLnByZWRpY3Rpb24gKyBcIiBpbiBzdGF0ZSBcIiArIHMuc3RhdGVOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoIXRoaXMuaXNBY2NlcHRTdGF0ZShzLCBzdGF0ZS51c2VDb250ZXh0KSk7XG4gICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLmdldEV4aXN0aW5nVGFyZ2V0U3RhdGUocywgdCk7XG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChQYXJzZXJBVE5TaW11bGF0b3IzLmRmYV9kZWJ1ZyAmJiB0ID49IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibm8gZWRnZSBmb3IgXCIgKyB0aGlzLl9wYXJzZXIudm9jYWJ1bGFyeS5nZXREaXNwbGF5TmFtZSh0KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBhbHQ7XG4gICAgICAgICAgaWYgKFBhcnNlckFUTlNpbXVsYXRvcjMuZGZhX2RlYnVnKSB7XG4gICAgICAgICAgICBsZXQgaW50ZXJ2YWwgPSBJbnRlcnZhbF8xLkludGVydmFsLm9mKHN0YXJ0SW5kZXgsIHRoaXMuX3BhcnNlci5pbnB1dFN0cmVhbS5pbmRleCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkFUTiBleGVjIHVwb24gXCIgKyB0aGlzLl9wYXJzZXIuaW5wdXRTdHJlYW0uZ2V0VGV4dChpbnRlcnZhbCkgKyBcIiBhdCBERkEgc3RhdGUgXCIgKyBzLnN0YXRlTnVtYmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGluaXRpYWxTdGF0ZSA9IG5ldyBTaW11bGF0b3JTdGF0ZV8xLlNpbXVsYXRvclN0YXRlKG91dGVyQ29udGV4dCwgcywgc3RhdGUudXNlQ29udGV4dCwgcmVtYWluaW5nT3V0ZXJDb250ZXh0KTtcbiAgICAgICAgICBhbHQgPSB0aGlzLmV4ZWNBVE4oZGZhLCBpbnB1dCwgc3RhcnRJbmRleCwgaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgICBpZiAoUGFyc2VyQVROU2ltdWxhdG9yMy5kZmFfZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYmFjayBmcm9tIERGQSB1cGRhdGUsIGFsdD1cIiArIGFsdCArIFwiLCBkZmE9XFxuXCIgKyBkZmEudG9TdHJpbmcodGhpcy5fcGFyc2VyLnZvY2FidWxhcnksIHRoaXMuX3BhcnNlci5ydWxlTmFtZXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFBhcnNlckFUTlNpbXVsYXRvcjMuZGZhX2RlYnVnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRGQSBkZWNpc2lvbiBcIiArIGRmYS5kZWNpc2lvbiArIFwiIHByZWRpY3RzIFwiICsgYWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFsdDtcbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgPT09IEFUTlNpbXVsYXRvcl8xLkFUTlNpbXVsYXRvci5FUlJPUikge1xuICAgICAgICAgIGxldCBlcnJvclN0YXRlID0gbmV3IFNpbXVsYXRvclN0YXRlXzEuU2ltdWxhdG9yU3RhdGUob3V0ZXJDb250ZXh0LCBzLCBzdGF0ZS51c2VDb250ZXh0LCByZW1haW5pbmdPdXRlckNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZU5vVmlhYmxlQWx0KGlucHV0LCBzdGFydEluZGV4LCBlcnJvclN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBzID0gdGFyZ2V0O1xuICAgICAgICBpZiAoIXRoaXMuaXNBY2NlcHRTdGF0ZShzLCBzdGF0ZS51c2VDb250ZXh0KSAmJiB0ICE9PSBJbnRTdHJlYW1fMS5JbnRTdHJlYW0uRU9GKSB7XG4gICAgICAgICAgaW5wdXQuY29uc3VtZSgpO1xuICAgICAgICAgIHQgPSBpbnB1dC5MQSgxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFzdGF0ZS51c2VDb250ZXh0ICYmIHMuY29uZmlncy5jb25mbGljdEluZm8gIT0gbnVsbCkge1xuICAgICAgICBpZiAoZGZhLmF0blN0YXJ0U3RhdGUgaW5zdGFuY2VvZiBEZWNpc2lvblN0YXRlXzEuRGVjaXNpb25TdGF0ZSkge1xuICAgICAgICAgIGlmICghdGhpcy51c2VyV2FudHNDdHhTZW5zaXRpdmUgfHwgIXMuY29uZmlncy5kaXBzSW50b091dGVyQ29udGV4dCAmJiBzLmNvbmZpZ3MuaXNFeGFjdENvbmZsaWN0IHx8IHRoaXMudHJlYXRfc2xsazFfY29uZmxpY3RfYXNfYW1iaWd1aXR5ICYmIGlucHV0LmluZGV4ID09PSBzdGFydEluZGV4KSB7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydCghc3RhdGUudXNlQ29udGV4dCk7XG4gICAgICAgICAgICBsZXQgY29uZmxpY3RpbmdBbHRzO1xuICAgICAgICAgICAgbGV0IHByZWRpY2F0ZXMyID0gcy5wcmVkaWNhdGVzO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXMyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgbGV0IGNvbmZsaWN0SW5kZXggPSBpbnB1dC5pbmRleDtcbiAgICAgICAgICAgICAgaWYgKGNvbmZsaWN0SW5kZXggIT09IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5zZWVrKHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbmZsaWN0aW5nQWx0cyA9IHRoaXMuZXZhbFNlbWFudGljQ29udGV4dChwcmVkaWNhdGVzMiwgb3V0ZXJDb250ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgICAgaWYgKGNvbmZsaWN0aW5nQWx0cy5jYXJkaW5hbGl0eSgpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZsaWN0aW5nQWx0cy5uZXh0U2V0Qml0KDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb25mbGljdEluZGV4ICE9PSBzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuc2Vlayhjb25mbGljdEluZGV4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucmVwb3J0QW1iaWd1aXRpZXMpIHtcbiAgICAgICAgICAgICAgbGV0IGNvbmZsaWN0U3RhdGUgPSBuZXcgU2ltdWxhdG9yU3RhdGVfMS5TaW11bGF0b3JTdGF0ZShvdXRlckNvbnRleHQsIHMsIHN0YXRlLnVzZUNvbnRleHQsIHJlbWFpbmluZ091dGVyQ29udGV4dCk7XG4gICAgICAgICAgICAgIHRoaXMucmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0KGRmYSwgY29uZmxpY3RpbmdBbHRzLCBjb25mbGljdFN0YXRlLCBzdGFydEluZGV4LCBpbnB1dC5pbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dC5zZWVrKHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRpdmVQcmVkaWN0KGlucHV0LCBkZmEuZGVjaXNpb24sIG91dGVyQ29udGV4dCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgcHJlZGljYXRlcyA9IHMucHJlZGljYXRlcztcbiAgICAgIGlmIChwcmVkaWNhdGVzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHN0b3BJbmRleCA9IGlucHV0LmluZGV4O1xuICAgICAgICBpZiAoc3RhcnRJbmRleCAhPT0gc3RvcEluZGV4KSB7XG4gICAgICAgICAgaW5wdXQuc2VlayhzdGFydEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWx0cyA9IHRoaXMuZXZhbFNlbWFudGljQ29udGV4dChwcmVkaWNhdGVzLCBvdXRlckNvbnRleHQsIHRoaXMucmVwb3J0QW1iaWd1aXRpZXMgJiYgdGhpcy5wcmVkaWN0aW9uTW9kZSA9PT0gUHJlZGljdGlvbk1vZGVfMS5QcmVkaWN0aW9uTW9kZS5MTF9FWEFDVF9BTUJJR19ERVRFQ1RJT04pO1xuICAgICAgICBzd2l0Y2ggKGFsdHMuY2FyZGluYWxpdHkoKSkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHRocm93IHRoaXMubm9WaWFibGVBbHQoaW5wdXQsIG91dGVyQ29udGV4dCwgcy5jb25maWdzLCBzdGFydEluZGV4KTtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gYWx0cy5uZXh0U2V0Qml0KDApO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoc3RhcnRJbmRleCAhPT0gc3RvcEluZGV4KSB7XG4gICAgICAgICAgICAgIGlucHV0LnNlZWsoc3RvcEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVwb3J0QW1iaWd1aXR5KGRmYSwgcywgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBzLmNvbmZpZ3MuaXNFeGFjdENvbmZsaWN0LCBhbHRzLCBzLmNvbmZpZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIGFsdHMubmV4dFNldEJpdCgwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKFBhcnNlckFUTlNpbXVsYXRvcjMuZGZhX2RlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiREZBIGRlY2lzaW9uIFwiICsgZGZhLmRlY2lzaW9uICsgXCIgcHJlZGljdHMgXCIgKyBzLnByZWRpY3Rpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHMucHJlZGljdGlvbjtcbiAgICB9XG4gICAgaXNBY2NlcHRTdGF0ZShzdGF0ZSwgdXNlQ29udGV4dCkge1xuICAgICAgaWYgKCFzdGF0ZS5pc0FjY2VwdFN0YXRlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5jb25maWdzLmNvbmZsaWN0aW5nQWx0cyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHVzZUNvbnRleHQgJiYgdGhpcy5wcmVkaWN0aW9uTW9kZSA9PT0gUHJlZGljdGlvbk1vZGVfMS5QcmVkaWN0aW9uTW9kZS5MTF9FWEFDVF9BTUJJR19ERVRFQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmNvbmZpZ3MuaXNFeGFjdENvbmZsaWN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGV4ZWNBVE4oZGZhLCBpbnB1dCwgc3RhcnRJbmRleCwgaW5pdGlhbFN0YXRlKSB7XG4gICAgICBpZiAoUGFyc2VyQVROU2ltdWxhdG9yMy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcImV4ZWNBVE4gZGVjaXNpb24gXCIgKyBkZmEuZGVjaXNpb24gKyBcIiBleGVjIExBKDEpPT1cIiArIHRoaXMuZ2V0TG9va2FoZWFkTmFtZShpbnB1dCkpO1xuICAgICAgfVxuICAgICAgbGV0IG91dGVyQ29udGV4dCA9IGluaXRpYWxTdGF0ZS5vdXRlckNvbnRleHQ7XG4gICAgICBsZXQgdXNlQ29udGV4dCA9IGluaXRpYWxTdGF0ZS51c2VDb250ZXh0O1xuICAgICAgbGV0IHQgPSBpbnB1dC5MQSgxKTtcbiAgICAgIGxldCBwcmV2aW91cyA9IGluaXRpYWxTdGF0ZTtcbiAgICAgIGxldCBjb250ZXh0Q2FjaGUgPSBuZXcgUHJlZGljdGlvbkNvbnRleHRDYWNoZV8xLlByZWRpY3Rpb25Db250ZXh0Q2FjaGUoKTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBuZXh0U3RhdGUgPSB0aGlzLmNvbXB1dGVSZWFjaFNldChkZmEsIHByZXZpb3VzLCB0LCBjb250ZXh0Q2FjaGUpO1xuICAgICAgICBpZiAobmV4dFN0YXRlID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnNldERGQUVkZ2UocHJldmlvdXMuczAsIGlucHV0LkxBKDEpLCBBVE5TaW11bGF0b3JfMS5BVE5TaW11bGF0b3IuRVJST1IpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZU5vVmlhYmxlQWx0KGlucHV0LCBzdGFydEluZGV4LCBwcmV2aW91cyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IEQgPSBuZXh0U3RhdGUuczA7XG4gICAgICAgIGFzc2VydChELmlzQWNjZXB0U3RhdGUgfHwgRC5wcmVkaWN0aW9uID09PSBBVE5fMS5BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKTtcbiAgICAgICAgYXNzZXJ0KEQuaXNBY2NlcHRTdGF0ZSB8fCBELmNvbmZpZ3MuY29uZmxpY3RJbmZvID09IG51bGwpO1xuICAgICAgICBpZiAodGhpcy5pc0FjY2VwdFN0YXRlKEQsIHVzZUNvbnRleHQpKSB7XG4gICAgICAgICAgbGV0IGNvbmZsaWN0aW5nQWx0cyA9IEQuY29uZmlncy5jb25mbGljdGluZ0FsdHM7XG4gICAgICAgICAgbGV0IHByZWRpY3RlZEFsdCA9IGNvbmZsaWN0aW5nQWx0cyA9PSBudWxsID8gRC5wcmVkaWN0aW9uIDogQVROXzEuQVROLklOVkFMSURfQUxUX05VTUJFUjtcbiAgICAgICAgICBpZiAocHJlZGljdGVkQWx0ICE9PSBBVE5fMS5BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpbWl6ZV9sbDEgJiYgaW5wdXQuaW5kZXggPT09IHN0YXJ0SW5kZXggJiYgIWRmYS5pc1ByZWNlZGVuY2VEZmEgJiYgbmV4dFN0YXRlLm91dGVyQ29udGV4dCA9PT0gbmV4dFN0YXRlLnJlbWFpbmluZ091dGVyQ29udGV4dCAmJiBkZmEuZGVjaXNpb24gPj0gMCAmJiAhRC5jb25maWdzLmhhc1NlbWFudGljQ29udGV4dCkge1xuICAgICAgICAgICAgICBpZiAodCA+PSAwICYmIHQgPD0gTUFYX1NIT1JUX1ZBTFVFKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IChkZmEuZGVjaXNpb24gPDwgMTYgPj4+IDApICsgdDtcbiAgICAgICAgICAgICAgICB0aGlzLmF0bi5MTDFUYWJsZS5zZXQoa2V5LCBwcmVkaWN0ZWRBbHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXNlQ29udGV4dCAmJiB0aGlzLmFsd2F5c190cnlfbG9jYWxfY29udGV4dCkge1xuICAgICAgICAgICAgICB0aGlzLnJlcG9ydENvbnRleHRTZW5zaXRpdml0eShkZmEsIHByZWRpY3RlZEFsdCwgbmV4dFN0YXRlLCBzdGFydEluZGV4LCBpbnB1dC5pbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZWRpY3RlZEFsdCA9IEQucHJlZGljdGlvbjtcbiAgICAgICAgICBsZXQgYXR0ZW1wdEZ1bGxDb250ZXh0ID0gY29uZmxpY3RpbmdBbHRzICE9IG51bGwgJiYgdGhpcy51c2VyV2FudHNDdHhTZW5zaXRpdmU7XG4gICAgICAgICAgaWYgKGF0dGVtcHRGdWxsQ29udGV4dCkge1xuICAgICAgICAgICAgYXR0ZW1wdEZ1bGxDb250ZXh0ID0gIXVzZUNvbnRleHQgJiYgKEQuY29uZmlncy5kaXBzSW50b091dGVyQ29udGV4dCB8fCAhRC5jb25maWdzLmlzRXhhY3RDb25mbGljdCkgJiYgKCF0aGlzLnRyZWF0X3NsbGsxX2NvbmZsaWN0X2FzX2FtYmlndWl0eSB8fCBpbnB1dC5pbmRleCAhPT0gc3RhcnRJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChELmNvbmZpZ3MuaGFzU2VtYW50aWNDb250ZXh0KSB7XG4gICAgICAgICAgICBsZXQgcHJlZFByZWRpY3Rpb25zID0gRC5wcmVkaWNhdGVzO1xuICAgICAgICAgICAgaWYgKHByZWRQcmVkaWN0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGxldCBjb25mbGljdEluZGV4ID0gaW5wdXQuaW5kZXg7XG4gICAgICAgICAgICAgIGlmIChjb25mbGljdEluZGV4ICE9PSBzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuc2VlayhzdGFydEluZGV4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25mbGljdGluZ0FsdHMgPSB0aGlzLmV2YWxTZW1hbnRpY0NvbnRleHQocHJlZFByZWRpY3Rpb25zLCBvdXRlckNvbnRleHQsIGF0dGVtcHRGdWxsQ29udGV4dCB8fCB0aGlzLnJlcG9ydEFtYmlndWl0aWVzKTtcbiAgICAgICAgICAgICAgc3dpdGNoIChjb25mbGljdGluZ0FsdHMuY2FyZGluYWxpdHkoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMubm9WaWFibGVBbHQoaW5wdXQsIG91dGVyQ29udGV4dCwgRC5jb25maWdzLCBzdGFydEluZGV4KTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmxpY3RpbmdBbHRzLm5leHRTZXRCaXQoMCk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb25mbGljdEluZGV4ICE9PSBzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuc2Vlayhjb25mbGljdEluZGV4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWF0dGVtcHRGdWxsQ29udGV4dCkge1xuICAgICAgICAgICAgaWYgKGNvbmZsaWN0aW5nQWx0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnJlcG9ydEFtYmlndWl0aWVzICYmIGNvbmZsaWN0aW5nQWx0cy5jYXJkaW5hbGl0eSgpID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0QW1iaWd1aXR5KGRmYSwgRCwgc3RhcnRJbmRleCwgaW5wdXQuaW5kZXgsIEQuY29uZmlncy5pc0V4YWN0Q29uZmxpY3QsIGNvbmZsaWN0aW5nQWx0cywgRC5jb25maWdzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwcmVkaWN0ZWRBbHQgPSBjb25mbGljdGluZ0FsdHMubmV4dFNldEJpdCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmVkaWN0ZWRBbHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydCghdXNlQ29udGV4dCk7XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5pc0FjY2VwdFN0YXRlKEQsIGZhbHNlKSk7XG4gICAgICAgICAgICBpZiAoUGFyc2VyQVROU2ltdWxhdG9yMy5kZWJ1Zykge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlJFVFJZIHdpdGggb3V0ZXJDb250ZXh0PVwiICsgb3V0ZXJDb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmdWxsQ29udGV4dFN0YXRlID0gdGhpcy5jb21wdXRlU3RhcnRTdGF0ZShkZmEsIG91dGVyQ29udGV4dCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXBvcnRBbWJpZ3VpdGllcykge1xuICAgICAgICAgICAgICB0aGlzLnJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dChkZmEsIGNvbmZsaWN0aW5nQWx0cywgbmV4dFN0YXRlLCBzdGFydEluZGV4LCBpbnB1dC5pbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dC5zZWVrKHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhlY0FUTihkZmEsIGlucHV0LCBzdGFydEluZGV4LCBmdWxsQ29udGV4dFN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXMgPSBuZXh0U3RhdGU7XG4gICAgICAgIGlmICh0ICE9PSBJbnRTdHJlYW1fMS5JbnRTdHJlYW0uRU9GKSB7XG4gICAgICAgICAgaW5wdXQuY29uc3VtZSgpO1xuICAgICAgICAgIHQgPSBpbnB1dC5MQSgxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVOb1ZpYWJsZUFsdChpbnB1dCwgc3RhcnRJbmRleCwgcHJldmlvdXMpIHtcbiAgICAgIGlmIChwcmV2aW91cy5zMCAhPSBudWxsKSB7XG4gICAgICAgIGxldCBhbHRzID0gbmV3IEJpdFNldF8xLkJpdFNldCgpO1xuICAgICAgICBsZXQgbWF4QWx0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgY29uZmlnIG9mIHByZXZpb3VzLnMwLmNvbmZpZ3MpIHtcbiAgICAgICAgICBpZiAoY29uZmlnLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0IHx8IGNvbmZpZy5zdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGVfMS5SdWxlU3RvcFN0YXRlKSB7XG4gICAgICAgICAgICBhbHRzLnNldChjb25maWcuYWx0KTtcbiAgICAgICAgICAgIG1heEFsdCA9IE1hdGgubWF4KG1heEFsdCwgY29uZmlnLmFsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYWx0cy5jYXJkaW5hbGl0eSgpKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGFsdHMubmV4dFNldEJpdCgwKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKCFwcmV2aW91cy5zMC5jb25maWdzLmhhc1NlbWFudGljQ29udGV4dCkge1xuICAgICAgICAgICAgICByZXR1cm4gYWx0cy5uZXh0U2V0Qml0KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZpbHRlcmVkQ29uZmlncyA9IG5ldyBBVE5Db25maWdTZXRfMS5BVE5Db25maWdTZXQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbmZpZyBvZiBwcmV2aW91cy5zMC5jb25maWdzKSB7XG4gICAgICAgICAgICAgIGlmIChjb25maWcucmVhY2hlc0ludG9PdXRlckNvbnRleHQgfHwgY29uZmlnLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZV8xLlJ1bGVTdG9wU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZENvbmZpZ3MuYWRkKGNvbmZpZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhbHRUb1ByZWQgPSB0aGlzLmdldFByZWRzRm9yQW1iaWdBbHRzKGFsdHMsIGZpbHRlcmVkQ29uZmlncywgbWF4QWx0KTtcbiAgICAgICAgICAgIGlmIChhbHRUb1ByZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBsZXQgcHJlZGljYXRlcyA9IHRoaXMuZ2V0UHJlZGljYXRlUHJlZGljdGlvbnMoYWx0cywgYWx0VG9QcmVkKTtcbiAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBzdG9wSW5kZXggPSBpbnB1dC5pbmRleDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgaW5wdXQuc2VlayhzdGFydEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGxldCBmaWx0ZXJlZEFsdHMgPSB0aGlzLmV2YWxTZW1hbnRpY0NvbnRleHQocHJlZGljYXRlcywgcHJldmlvdXMub3V0ZXJDb250ZXh0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIWZpbHRlcmVkQWx0cy5pc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZEFsdHMubmV4dFNldEJpdCgwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgaW5wdXQuc2VlayhzdG9wSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFsdHMubmV4dFNldEJpdCgwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgdGhpcy5ub1ZpYWJsZUFsdChpbnB1dCwgcHJldmlvdXMub3V0ZXJDb250ZXh0LCBwcmV2aW91cy5zMC5jb25maWdzLCBzdGFydEluZGV4KTtcbiAgICB9XG4gICAgY29tcHV0ZVJlYWNoU2V0KGRmYSwgcHJldmlvdXMsIHQsIGNvbnRleHRDYWNoZSkge1xuICAgICAgbGV0IHVzZUNvbnRleHQgPSBwcmV2aW91cy51c2VDb250ZXh0O1xuICAgICAgbGV0IHJlbWFpbmluZ0dsb2JhbENvbnRleHQgPSBwcmV2aW91cy5yZW1haW5pbmdPdXRlckNvbnRleHQ7XG4gICAgICBsZXQgcyA9IHByZXZpb3VzLnMwO1xuICAgICAgaWYgKHVzZUNvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKHMuaXNDb250ZXh0U3ltYm9sKHQpKSB7XG4gICAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgICAgaWYgKHJlbWFpbmluZ0dsb2JhbENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVtYWluaW5nR2xvYmFsQ29udGV4dCA9IHRoaXMuc2tpcFRhaWxDYWxscyhyZW1haW5pbmdHbG9iYWxDb250ZXh0KTtcbiAgICAgICAgICAgIG5leHQgPSBzLmdldENvbnRleHRUYXJnZXQodGhpcy5nZXRSZXR1cm5TdGF0ZShyZW1haW5pbmdHbG9iYWxDb250ZXh0KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXh0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NlcnQocmVtYWluaW5nR2xvYmFsQ29udGV4dCAhPSBudWxsKTtcbiAgICAgICAgICByZW1haW5pbmdHbG9iYWxDb250ZXh0ID0gcmVtYWluaW5nR2xvYmFsQ29udGV4dC5wYXJlbnQ7XG4gICAgICAgICAgcyA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFzc2VydCghdGhpcy5pc0FjY2VwdFN0YXRlKHMsIHVzZUNvbnRleHQpKTtcbiAgICAgIGlmICh0aGlzLmlzQWNjZXB0U3RhdGUocywgdXNlQ29udGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaW11bGF0b3JTdGF0ZV8xLlNpbXVsYXRvclN0YXRlKHByZXZpb3VzLm91dGVyQ29udGV4dCwgcywgdXNlQ29udGV4dCwgcmVtYWluaW5nR2xvYmFsQ29udGV4dCk7XG4gICAgICB9XG4gICAgICBsZXQgczAgPSBzO1xuICAgICAgbGV0IHRhcmdldCA9IHRoaXMuZ2V0RXhpc3RpbmdUYXJnZXRTdGF0ZShzMCwgdCk7XG4gICAgICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuY29tcHV0ZVRhcmdldFN0YXRlKGRmYSwgczAsIHJlbWFpbmluZ0dsb2JhbENvbnRleHQsIHQsIHVzZUNvbnRleHQsIGNvbnRleHRDYWNoZSk7XG4gICAgICAgIHRhcmdldCA9IHJlc3VsdFswXTtcbiAgICAgICAgcmVtYWluaW5nR2xvYmFsQ29udGV4dCA9IHJlc3VsdFsxXTtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXQgPT09IEFUTlNpbXVsYXRvcl8xLkFUTlNpbXVsYXRvci5FUlJPUikge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KCF1c2VDb250ZXh0IHx8ICF0YXJnZXQuY29uZmlncy5kaXBzSW50b091dGVyQ29udGV4dCk7XG4gICAgICByZXR1cm4gbmV3IFNpbXVsYXRvclN0YXRlXzEuU2ltdWxhdG9yU3RhdGUocHJldmlvdXMub3V0ZXJDb250ZXh0LCB0YXJnZXQsIHVzZUNvbnRleHQsIHJlbWFpbmluZ0dsb2JhbENvbnRleHQpO1xuICAgIH1cbiAgICBnZXRFeGlzdGluZ1RhcmdldFN0YXRlKHMsIHQpIHtcbiAgICAgIHJldHVybiBzLmdldFRhcmdldCh0KTtcbiAgICB9XG4gICAgY29tcHV0ZVRhcmdldFN0YXRlKGRmYSwgcywgcmVtYWluaW5nR2xvYmFsQ29udGV4dCwgdCwgdXNlQ29udGV4dCwgY29udGV4dENhY2hlKSB7XG4gICAgICBsZXQgY2xvc3VyZUNvbmZpZ3MgPSBzLmNvbmZpZ3MudG9BcnJheSgpO1xuICAgICAgbGV0IGNvbnRleHRFbGVtZW50cztcbiAgICAgIGxldCByZWFjaCA9IG5ldyBBVE5Db25maWdTZXRfMS5BVE5Db25maWdTZXQoKTtcbiAgICAgIGxldCBzdGVwSW50b0dsb2JhbDtcbiAgICAgIGRvIHtcbiAgICAgICAgbGV0IGhhc01vcmVDb250ZXh0ID0gIXVzZUNvbnRleHQgfHwgcmVtYWluaW5nR2xvYmFsQ29udGV4dCAhPSBudWxsO1xuICAgICAgICBpZiAoIWhhc01vcmVDb250ZXh0KSB7XG4gICAgICAgICAgcmVhY2guaXNPdXRlcm1vc3RDb25maWdTZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZWFjaEludGVybWVkaWF0ZSA9IG5ldyBBVE5Db25maWdTZXRfMS5BVE5Db25maWdTZXQoKTtcbiAgICAgICAgbGV0IHNraXBwZWRTdG9wU3RhdGVzO1xuICAgICAgICBmb3IgKGxldCBjIG9mIGNsb3N1cmVDb25maWdzKSB7XG4gICAgICAgICAgaWYgKFBhcnNlckFUTlNpbXVsYXRvcjMuZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidGVzdGluZyBcIiArIHRoaXMuZ2V0VG9rZW5OYW1lKHQpICsgXCIgYXQgXCIgKyBjLnRvU3RyaW5nKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYy5zdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGVfMS5SdWxlU3RvcFN0YXRlKSB7XG4gICAgICAgICAgICBhc3NlcnQoYy5jb250ZXh0LmlzRW1wdHkpO1xuICAgICAgICAgICAgaWYgKHVzZUNvbnRleHQgJiYgIWMucmVhY2hlc0ludG9PdXRlckNvbnRleHQgfHwgdCA9PT0gSW50U3RyZWFtXzEuSW50U3RyZWFtLkVPRikge1xuICAgICAgICAgICAgICBpZiAoc2tpcHBlZFN0b3BTdGF0ZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWRTdG9wU3RhdGVzID0gW107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2tpcHBlZFN0b3BTdGF0ZXMucHVzaChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgbiA9IGMuc3RhdGUubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9ucztcbiAgICAgICAgICBmb3IgKGxldCB0aSA9IDA7IHRpIDwgbjsgdGkrKykge1xuICAgICAgICAgICAgbGV0IHRyYW5zID0gYy5zdGF0ZS5nZXRPcHRpbWl6ZWRUcmFuc2l0aW9uKHRpKTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLmdldFJlYWNoYWJsZVRhcmdldChjLCB0cmFucywgdCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVhY2hJbnRlcm1lZGlhdGUuYWRkKGMudHJhbnNmb3JtKHRhcmdldCwgZmFsc2UpLCBjb250ZXh0Q2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpbWl6ZV91bmlxdWVfY2xvc3VyZSAmJiBza2lwcGVkU3RvcFN0YXRlcyA9PSBudWxsICYmIHQgIT09IFRva2VuXzEuVG9rZW4uRU9GICYmIHJlYWNoSW50ZXJtZWRpYXRlLnVuaXF1ZUFsdCAhPT0gQVROXzEuQVROLklOVkFMSURfQUxUX05VTUJFUikge1xuICAgICAgICAgIHJlYWNoSW50ZXJtZWRpYXRlLmlzT3V0ZXJtb3N0Q29uZmlnU2V0ID0gcmVhY2guaXNPdXRlcm1vc3RDb25maWdTZXQ7XG4gICAgICAgICAgcmVhY2ggPSByZWFjaEludGVybWVkaWF0ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29sbGVjdFByZWRpY2F0ZXMgPSBmYWxzZTtcbiAgICAgICAgbGV0IHRyZWF0RW9mQXNFcHNpbG9uID0gdCA9PT0gVG9rZW5fMS5Ub2tlbi5FT0Y7XG4gICAgICAgIHRoaXMuY2xvc3VyZShyZWFjaEludGVybWVkaWF0ZSwgcmVhY2gsIGNvbGxlY3RQcmVkaWNhdGVzLCBoYXNNb3JlQ29udGV4dCwgY29udGV4dENhY2hlLCB0cmVhdEVvZkFzRXBzaWxvbik7XG4gICAgICAgIHN0ZXBJbnRvR2xvYmFsID0gcmVhY2guZGlwc0ludG9PdXRlckNvbnRleHQ7XG4gICAgICAgIGlmICh0ID09PSBJbnRTdHJlYW1fMS5JbnRTdHJlYW0uRU9GKSB7XG4gICAgICAgICAgcmVhY2ggPSB0aGlzLnJlbW92ZUFsbENvbmZpZ3NOb3RJblJ1bGVTdG9wU3RhdGUocmVhY2gsIGNvbnRleHRDYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXBwZWRTdG9wU3RhdGVzICE9IG51bGwgJiYgKCF1c2VDb250ZXh0IHx8ICFQcmVkaWN0aW9uTW9kZV8xLlByZWRpY3Rpb25Nb2RlLmhhc0NvbmZpZ0luUnVsZVN0b3BTdGF0ZShyZWFjaCkpKSB7XG4gICAgICAgICAgYXNzZXJ0KHNraXBwZWRTdG9wU3RhdGVzLmxlbmd0aCA+IDApO1xuICAgICAgICAgIGZvciAobGV0IGMgb2Ygc2tpcHBlZFN0b3BTdGF0ZXMpIHtcbiAgICAgICAgICAgIHJlYWNoLmFkZChjLCBjb250ZXh0Q2FjaGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlQ29udGV4dCAmJiBzdGVwSW50b0dsb2JhbCkge1xuICAgICAgICAgIHJlYWNoLmNsZWFyKCk7XG4gICAgICAgICAgcmVtYWluaW5nR2xvYmFsQ29udGV4dCA9IHJlbWFpbmluZ0dsb2JhbENvbnRleHQ7XG4gICAgICAgICAgcmVtYWluaW5nR2xvYmFsQ29udGV4dCA9IHRoaXMuc2tpcFRhaWxDYWxscyhyZW1haW5pbmdHbG9iYWxDb250ZXh0KTtcbiAgICAgICAgICBsZXQgbmV4dENvbnRleHRFbGVtZW50ID0gdGhpcy5nZXRSZXR1cm5TdGF0ZShyZW1haW5pbmdHbG9iYWxDb250ZXh0KTtcbiAgICAgICAgICBpZiAoY29udGV4dEVsZW1lbnRzID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRleHRFbGVtZW50cyA9IG5ldyBJbnRlZ2VyTGlzdF8xLkludGVnZXJMaXN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZW1haW5pbmdHbG9iYWxDb250ZXh0LmlzRW1wdHkpIHtcbiAgICAgICAgICAgIHJlbWFpbmluZ0dsb2JhbENvbnRleHQgPSB2b2lkIDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbWFpbmluZ0dsb2JhbENvbnRleHQgPSByZW1haW5pbmdHbG9iYWxDb250ZXh0LnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGV4dEVsZW1lbnRzLmFkZChuZXh0Q29udGV4dEVsZW1lbnQpO1xuICAgICAgICAgIGlmIChuZXh0Q29udGV4dEVsZW1lbnQgIT09IFByZWRpY3Rpb25Db250ZXh0XzEuUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTF9TVEFURV9LRVkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xvc3VyZUNvbmZpZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY2xvc3VyZUNvbmZpZ3NbaV0gPSBjbG9zdXJlQ29uZmlnc1tpXS5hcHBlbmRDb250ZXh0KG5leHRDb250ZXh0RWxlbWVudCwgY29udGV4dENhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKHVzZUNvbnRleHQgJiYgc3RlcEludG9HbG9iYWwpO1xuICAgICAgaWYgKHJlYWNoLmlzRW1wdHkpIHtcbiAgICAgICAgdGhpcy5zZXRERkFFZGdlKHMsIHQsIEFUTlNpbXVsYXRvcl8xLkFUTlNpbXVsYXRvci5FUlJPUik7XG4gICAgICAgIHJldHVybiBbQVROU2ltdWxhdG9yXzEuQVROU2ltdWxhdG9yLkVSUk9SLCByZW1haW5pbmdHbG9iYWxDb250ZXh0XTtcbiAgICAgIH1cbiAgICAgIGxldCByZXN1bHQgPSB0aGlzLmFkZERGQUVkZ2UoZGZhLCBzLCB0LCBjb250ZXh0RWxlbWVudHMsIHJlYWNoLCBjb250ZXh0Q2FjaGUpO1xuICAgICAgcmV0dXJuIFtyZXN1bHQsIHJlbWFpbmluZ0dsb2JhbENvbnRleHRdO1xuICAgIH1cbiAgICByZW1vdmVBbGxDb25maWdzTm90SW5SdWxlU3RvcFN0YXRlKGNvbmZpZ3MsIGNvbnRleHRDYWNoZSkge1xuICAgICAgaWYgKFByZWRpY3Rpb25Nb2RlXzEuUHJlZGljdGlvbk1vZGUuYWxsQ29uZmlnc0luUnVsZVN0b3BTdGF0ZXMoY29uZmlncykpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZ3M7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdWx0ID0gbmV3IEFUTkNvbmZpZ1NldF8xLkFUTkNvbmZpZ1NldCgpO1xuICAgICAgZm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpIHtcbiAgICAgICAgaWYgKCEoY29uZmlnLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZV8xLlJ1bGVTdG9wU3RhdGUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LmFkZChjb25maWcsIGNvbnRleHRDYWNoZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb21wdXRlU3RhcnRTdGF0ZShkZmEsIGdsb2JhbENvbnRleHQsIHVzZUNvbnRleHQpIHtcbiAgICAgIGxldCBzMCA9IGRmYS5pc1ByZWNlZGVuY2VEZmEgPyBkZmEuZ2V0UHJlY2VkZW5jZVN0YXJ0U3RhdGUodGhpcy5fcGFyc2VyLnByZWNlZGVuY2UsIHVzZUNvbnRleHQpIDogdXNlQ29udGV4dCA/IGRmYS5zMGZ1bGwgOiBkZmEuczA7XG4gICAgICBpZiAoczAgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIXVzZUNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFNpbXVsYXRvclN0YXRlXzEuU2ltdWxhdG9yU3RhdGUoZ2xvYmFsQ29udGV4dCwgczAsIHVzZUNvbnRleHQsIGdsb2JhbENvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHMwLnNldENvbnRleHRTZW5zaXRpdmUodGhpcy5hdG4pO1xuICAgICAgfVxuICAgICAgbGV0IGRlY2lzaW9uID0gZGZhLmRlY2lzaW9uO1xuICAgICAgbGV0IHAgPSBkZmEuYXRuU3RhcnRTdGF0ZTtcbiAgICAgIGxldCBwcmV2aW91c0NvbnRleHQgPSAwO1xuICAgICAgbGV0IHJlbWFpbmluZ0dsb2JhbENvbnRleHQgPSBnbG9iYWxDb250ZXh0O1xuICAgICAgbGV0IGluaXRpYWxDb250ZXh0ID0gdXNlQ29udGV4dCA/IFByZWRpY3Rpb25Db250ZXh0XzEuUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTCA6IFByZWRpY3Rpb25Db250ZXh0XzEuUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfTE9DQUw7XG4gICAgICBsZXQgY29udGV4dENhY2hlID0gbmV3IFByZWRpY3Rpb25Db250ZXh0Q2FjaGVfMS5QcmVkaWN0aW9uQ29udGV4dENhY2hlKCk7XG4gICAgICBpZiAodXNlQ29udGV4dCkge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlX2dsb2JhbF9jb250ZXh0X2RmYSkge1xuICAgICAgICAgIHdoaWxlIChyZW1haW5pbmdHbG9iYWxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmdHbG9iYWxDb250ZXh0LmlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgcHJldmlvdXNDb250ZXh0ID0gUHJlZGljdGlvbkNvbnRleHRfMS5QcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWTtcbiAgICAgICAgICAgICAgcmVtYWluaW5nR2xvYmFsQ29udGV4dCA9IHZvaWQgMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHByZXZpb3VzQ29udGV4dCA9IHRoaXMuZ2V0UmV0dXJuU3RhdGUocmVtYWluaW5nR2xvYmFsQ29udGV4dCk7XG4gICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0ID0gaW5pdGlhbENvbnRleHQuYXBwZW5kU2luZ2xlQ29udGV4dChwcmV2aW91c0NvbnRleHQsIGNvbnRleHRDYWNoZSk7XG4gICAgICAgICAgICAgIHJlbWFpbmluZ0dsb2JhbENvbnRleHQgPSByZW1haW5pbmdHbG9iYWxDb250ZXh0LnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHMwICE9IG51bGwgJiYgczAuaXNDb250ZXh0U2Vuc2l0aXZlICYmIHJlbWFpbmluZ0dsb2JhbENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgIGxldCBuZXh0O1xuICAgICAgICAgIHJlbWFpbmluZ0dsb2JhbENvbnRleHQgPSB0aGlzLnNraXBUYWlsQ2FsbHMocmVtYWluaW5nR2xvYmFsQ29udGV4dCk7XG4gICAgICAgICAgaWYgKHJlbWFpbmluZ0dsb2JhbENvbnRleHQuaXNFbXB0eSkge1xuICAgICAgICAgICAgbmV4dCA9IHMwLmdldENvbnRleHRUYXJnZXQoUHJlZGljdGlvbkNvbnRleHRfMS5QcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMX1NUQVRFX0tFWSk7XG4gICAgICAgICAgICBwcmV2aW91c0NvbnRleHQgPSBQcmVkaWN0aW9uQ29udGV4dF8xLlByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZO1xuICAgICAgICAgICAgcmVtYWluaW5nR2xvYmFsQ29udGV4dCA9IHZvaWQgMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJldmlvdXNDb250ZXh0ID0gdGhpcy5nZXRSZXR1cm5TdGF0ZShyZW1haW5pbmdHbG9iYWxDb250ZXh0KTtcbiAgICAgICAgICAgIG5leHQgPSBzMC5nZXRDb250ZXh0VGFyZ2V0KHByZXZpb3VzQ29udGV4dCk7XG4gICAgICAgICAgICBpbml0aWFsQ29udGV4dCA9IGluaXRpYWxDb250ZXh0LmFwcGVuZFNpbmdsZUNvbnRleHQocHJldmlvdXNDb250ZXh0LCBjb250ZXh0Q2FjaGUpO1xuICAgICAgICAgICAgcmVtYWluaW5nR2xvYmFsQ29udGV4dCA9IHJlbWFpbmluZ0dsb2JhbENvbnRleHQucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgczAgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoczAgIT0gbnVsbCAmJiAhczAuaXNDb250ZXh0U2Vuc2l0aXZlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2ltdWxhdG9yU3RhdGVfMS5TaW11bGF0b3JTdGF0ZShnbG9iYWxDb250ZXh0LCBzMCwgdXNlQ29udGV4dCwgcmVtYWluaW5nR2xvYmFsQ29udGV4dCk7XG4gICAgICB9XG4gICAgICBsZXQgY29uZmlncyA9IG5ldyBBVE5Db25maWdTZXRfMS5BVE5Db25maWdTZXQoKTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCByZWFjaEludGVybWVkaWF0ZSA9IG5ldyBBVE5Db25maWdTZXRfMS5BVE5Db25maWdTZXQoKTtcbiAgICAgICAgbGV0IG4gPSBwLm51bWJlck9mVHJhbnNpdGlvbnM7XG4gICAgICAgIGZvciAobGV0IHRpID0gMDsgdGkgPCBuOyB0aSsrKSB7XG4gICAgICAgICAgbGV0IHRhcmdldCA9IHAudHJhbnNpdGlvbih0aSkudGFyZ2V0O1xuICAgICAgICAgIHJlYWNoSW50ZXJtZWRpYXRlLmFkZChBVE5Db25maWdfMS5BVE5Db25maWcuY3JlYXRlKHRhcmdldCwgdGkgKyAxLCBpbml0aWFsQ29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBoYXNNb3JlQ29udGV4dCA9IHJlbWFpbmluZ0dsb2JhbENvbnRleHQgIT0gbnVsbDtcbiAgICAgICAgaWYgKCFoYXNNb3JlQ29udGV4dCkge1xuICAgICAgICAgIGNvbmZpZ3MuaXNPdXRlcm1vc3RDb25maWdTZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb2xsZWN0UHJlZGljYXRlcyA9IHRydWU7XG4gICAgICAgIHRoaXMuY2xvc3VyZShyZWFjaEludGVybWVkaWF0ZSwgY29uZmlncywgY29sbGVjdFByZWRpY2F0ZXMsIGhhc01vcmVDb250ZXh0LCBjb250ZXh0Q2FjaGUsIGZhbHNlKTtcbiAgICAgICAgbGV0IHN0ZXBJbnRvR2xvYmFsID0gY29uZmlncy5kaXBzSW50b091dGVyQ29udGV4dDtcbiAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgIGlmICh1c2VDb250ZXh0ICYmICF0aGlzLmVuYWJsZV9nbG9iYWxfY29udGV4dF9kZmEpIHtcbiAgICAgICAgICBzMCA9IHRoaXMuYWRkREZBU3RhdGUoZGZhLCBjb25maWdzLCBjb250ZXh0Q2FjaGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKHMwID09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIWRmYS5pc1ByZWNlZGVuY2VEZmEpIHtcbiAgICAgICAgICAgIG5leHQgPSB0aGlzLmFkZERGQVN0YXRlKGRmYSwgY29uZmlncywgY29udGV4dENhY2hlKTtcbiAgICAgICAgICAgIGlmICh1c2VDb250ZXh0KSB7XG4gICAgICAgICAgICAgIGlmICghZGZhLnMwZnVsbCkge1xuICAgICAgICAgICAgICAgIGRmYS5zMGZ1bGwgPSBuZXh0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5leHQgPSBkZmEuczBmdWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIWRmYS5zMCkge1xuICAgICAgICAgICAgICAgIGRmYS5zMCA9IG5leHQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IGRmYS5zMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWdzID0gdGhpcy5hcHBseVByZWNlZGVuY2VGaWx0ZXIoY29uZmlncywgZ2xvYmFsQ29udGV4dCwgY29udGV4dENhY2hlKTtcbiAgICAgICAgICAgIG5leHQgPSB0aGlzLmFkZERGQVN0YXRlKGRmYSwgY29uZmlncywgY29udGV4dENhY2hlKTtcbiAgICAgICAgICAgIGRmYS5zZXRQcmVjZWRlbmNlU3RhcnRTdGF0ZSh0aGlzLl9wYXJzZXIucHJlY2VkZW5jZSwgdXNlQ29udGV4dCwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChkZmEuaXNQcmVjZWRlbmNlRGZhKSB7XG4gICAgICAgICAgICBjb25maWdzID0gdGhpcy5hcHBseVByZWNlZGVuY2VGaWx0ZXIoY29uZmlncywgZ2xvYmFsQ29udGV4dCwgY29udGV4dENhY2hlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dCA9IHRoaXMuYWRkREZBU3RhdGUoZGZhLCBjb25maWdzLCBjb250ZXh0Q2FjaGUpO1xuICAgICAgICAgIHMwLnNldENvbnRleHRUYXJnZXQocHJldmlvdXNDb250ZXh0LCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBzMCA9IG5leHQ7XG4gICAgICAgIGlmICghdXNlQ29udGV4dCB8fCAhc3RlcEludG9HbG9iYWwpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBuZXh0LnNldENvbnRleHRTZW5zaXRpdmUodGhpcy5hdG4pO1xuICAgICAgICByZW1haW5pbmdHbG9iYWxDb250ZXh0ID0gcmVtYWluaW5nR2xvYmFsQ29udGV4dDtcbiAgICAgICAgY29uZmlncy5jbGVhcigpO1xuICAgICAgICByZW1haW5pbmdHbG9iYWxDb250ZXh0ID0gdGhpcy5za2lwVGFpbENhbGxzKHJlbWFpbmluZ0dsb2JhbENvbnRleHQpO1xuICAgICAgICBsZXQgbmV4dENvbnRleHRFbGVtZW50ID0gdGhpcy5nZXRSZXR1cm5TdGF0ZShyZW1haW5pbmdHbG9iYWxDb250ZXh0KTtcbiAgICAgICAgaWYgKHJlbWFpbmluZ0dsb2JhbENvbnRleHQuaXNFbXB0eSkge1xuICAgICAgICAgIHJlbWFpbmluZ0dsb2JhbENvbnRleHQgPSB2b2lkIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtYWluaW5nR2xvYmFsQ29udGV4dCA9IHJlbWFpbmluZ0dsb2JhbENvbnRleHQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0Q29udGV4dEVsZW1lbnQgIT09IFByZWRpY3Rpb25Db250ZXh0XzEuUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTF9TVEFURV9LRVkpIHtcbiAgICAgICAgICBpbml0aWFsQ29udGV4dCA9IGluaXRpYWxDb250ZXh0LmFwcGVuZFNpbmdsZUNvbnRleHQobmV4dENvbnRleHRFbGVtZW50LCBjb250ZXh0Q2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzQ29udGV4dCA9IG5leHRDb250ZXh0RWxlbWVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgU2ltdWxhdG9yU3RhdGVfMS5TaW11bGF0b3JTdGF0ZShnbG9iYWxDb250ZXh0LCBzMCwgdXNlQ29udGV4dCwgcmVtYWluaW5nR2xvYmFsQ29udGV4dCk7XG4gICAgfVxuICAgIGFwcGx5UHJlY2VkZW5jZUZpbHRlcihjb25maWdzLCBnbG9iYWxDb250ZXh0LCBjb250ZXh0Q2FjaGUpIHtcbiAgICAgIGxldCBzdGF0ZXNGcm9tQWx0MSA9IG5ldyBNYXAoKTtcbiAgICAgIGxldCBjb25maWdTZXQgPSBuZXcgQVROQ29uZmlnU2V0XzEuQVROQ29uZmlnU2V0KCk7XG4gICAgICBmb3IgKGxldCBjb25maWcgb2YgY29uZmlncykge1xuICAgICAgICBpZiAoY29uZmlnLmFsdCAhPT0gMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB1cGRhdGVkQ29udGV4dCA9IGNvbmZpZy5zZW1hbnRpY0NvbnRleHQuZXZhbFByZWNlZGVuY2UodGhpcy5fcGFyc2VyLCBnbG9iYWxDb250ZXh0KTtcbiAgICAgICAgaWYgKHVwZGF0ZWRDb250ZXh0ID09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZXNGcm9tQWx0MS5zZXQoY29uZmlnLnN0YXRlLnN0YXRlTnVtYmVyLCBjb25maWcuY29udGV4dCk7XG4gICAgICAgIGlmICh1cGRhdGVkQ29udGV4dCAhPT0gY29uZmlnLnNlbWFudGljQ29udGV4dCkge1xuICAgICAgICAgIGNvbmZpZ1NldC5hZGQoY29uZmlnLnRyYW5zZm9ybShjb25maWcuc3RhdGUsIGZhbHNlLCB1cGRhdGVkQ29udGV4dCksIGNvbnRleHRDYWNoZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uZmlnU2V0LmFkZChjb25maWcsIGNvbnRleHRDYWNoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGNvbmZpZyBvZiBjb25maWdzKSB7XG4gICAgICAgIGlmIChjb25maWcuYWx0ID09PSAxKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25maWcuaXNQcmVjZWRlbmNlRmlsdGVyU3VwcHJlc3NlZCkge1xuICAgICAgICAgIGxldCBjb250ZXh0ID0gc3RhdGVzRnJvbUFsdDEuZ2V0KGNvbmZpZy5zdGF0ZS5zdGF0ZU51bWJlcik7XG4gICAgICAgICAgaWYgKGNvbnRleHQgIT0gbnVsbCAmJiBjb250ZXh0LmVxdWFscyhjb25maWcuY29udGV4dCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25maWdTZXQuYWRkKGNvbmZpZywgY29udGV4dENhY2hlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25maWdTZXQ7XG4gICAgfVxuICAgIGdldFJlYWNoYWJsZVRhcmdldChzb3VyY2UsIHRyYW5zLCB0dHlwZSkge1xuICAgICAgaWYgKHRyYW5zLm1hdGNoZXModHR5cGUsIDAsIHRoaXMuYXRuLm1heFRva2VuVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zLnRhcmdldDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHByZWRpY2F0ZURGQVN0YXRlKEQsIGNvbmZpZ3MsIG5hbHRzKSB7XG4gICAgICBsZXQgY29uZmxpY3RpbmdBbHRzID0gdGhpcy5nZXRDb25mbGljdGluZ0FsdHNGcm9tQ29uZmlnU2V0KGNvbmZpZ3MpO1xuICAgICAgaWYgKCFjb25mbGljdGluZ0FsdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyB1bmhhbmRsZWQgc2NlbmFyaW8gaXMgaW50ZW5kZWQgdG8gYmUgdW5yZWFjaGFibGUsIGJ1dCBJJ20gY3VycmVudGx5IG5vdCBzdXJlIG9mIHdoeSB3ZSBrbm93IHRoYXQncyB0aGUgY2FzZS5cIik7XG4gICAgICB9XG4gICAgICBpZiAoUGFyc2VyQVROU2ltdWxhdG9yMy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcInByZWRpY2F0ZURGQVN0YXRlIFwiICsgRCk7XG4gICAgICB9XG4gICAgICBsZXQgYWx0VG9QcmVkID0gdGhpcy5nZXRQcmVkc0ZvckFtYmlnQWx0cyhjb25mbGljdGluZ0FsdHMsIGNvbmZpZ3MsIG5hbHRzKTtcbiAgICAgIGxldCBwcmVkUHJlZGljdGlvbnM7XG4gICAgICBpZiAoYWx0VG9QcmVkICE9IG51bGwpIHtcbiAgICAgICAgcHJlZFByZWRpY3Rpb25zID0gdGhpcy5nZXRQcmVkaWNhdGVQcmVkaWN0aW9ucyhjb25mbGljdGluZ0FsdHMsIGFsdFRvUHJlZCk7XG4gICAgICAgIEQucHJlZGljYXRlcyA9IHByZWRQcmVkaWN0aW9ucztcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmVkUHJlZGljdGlvbnM7XG4gICAgfVxuICAgIGdldFByZWRzRm9yQW1iaWdBbHRzKGFtYmlnQWx0cywgY29uZmlncywgbmFsdHMpIHtcbiAgICAgIGxldCBhbHRUb1ByZWQgPSBuZXcgQXJyYXkobmFsdHMgKyAxKTtcbiAgICAgIGxldCBuID0gYWx0VG9QcmVkLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGMgb2YgY29uZmlncykge1xuICAgICAgICBpZiAoYW1iaWdBbHRzLmdldChjLmFsdCkpIHtcbiAgICAgICAgICBhbHRUb1ByZWRbYy5hbHRdID0gU2VtYW50aWNDb250ZXh0XzEuU2VtYW50aWNDb250ZXh0Lm9yKGFsdFRvUHJlZFtjLmFsdF0sIGMuc2VtYW50aWNDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IG5QcmVkQWx0cyA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBpZiAoYWx0VG9QcmVkW2ldID09IG51bGwpIHtcbiAgICAgICAgICBhbHRUb1ByZWRbaV0gPSBTZW1hbnRpY0NvbnRleHRfMS5TZW1hbnRpY0NvbnRleHQuTk9ORTtcbiAgICAgICAgfSBlbHNlIGlmIChhbHRUb1ByZWRbaV0gIT09IFNlbWFudGljQ29udGV4dF8xLlNlbWFudGljQ29udGV4dC5OT05FKSB7XG4gICAgICAgICAgblByZWRBbHRzKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCByZXN1bHQgPSBhbHRUb1ByZWQ7XG4gICAgICBpZiAoblByZWRBbHRzID09PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmIChQYXJzZXJBVE5TaW11bGF0b3IzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiZ2V0UHJlZHNGb3JBbWJpZ0FsdHMgcmVzdWx0IFwiICsgKHJlc3VsdCA/IEFycmF5c18xLkFycmF5cy50b1N0cmluZyhyZXN1bHQpIDogXCJ1bmRlZmluZWRcIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0UHJlZGljYXRlUHJlZGljdGlvbnMoYW1iaWdBbHRzLCBhbHRUb1ByZWQpIHtcbiAgICAgIGxldCBwYWlycyA9IFtdO1xuICAgICAgbGV0IGNvbnRhaW5zUHJlZGljYXRlID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFsdFRvUHJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcHJlZCA9IGFsdFRvUHJlZFtpXTtcbiAgICAgICAgYXNzZXJ0KHByZWQgIT0gbnVsbCk7XG4gICAgICAgIGlmIChhbWJpZ0FsdHMgIT0gbnVsbCAmJiBhbWJpZ0FsdHMuZ2V0KGkpICYmIHByZWQgPT09IFNlbWFudGljQ29udGV4dF8xLlNlbWFudGljQ29udGV4dC5OT05FKSB7XG4gICAgICAgICAgcGFpcnMucHVzaChuZXcgREZBU3RhdGVfMS5ERkFTdGF0ZS5QcmVkUHJlZGljdGlvbihwcmVkLCBpKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJlZCAhPT0gU2VtYW50aWNDb250ZXh0XzEuU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcbiAgICAgICAgICBjb250YWluc1ByZWRpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgcGFpcnMucHVzaChuZXcgREZBU3RhdGVfMS5ERkFTdGF0ZS5QcmVkUHJlZGljdGlvbihwcmVkLCBpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY29udGFpbnNQcmVkaWNhdGUpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYWlycztcbiAgICB9XG4gICAgZXZhbFNlbWFudGljQ29udGV4dChwcmVkUHJlZGljdGlvbnMsIG91dGVyQ29udGV4dCwgY29tcGxldGUpIHtcbiAgICAgIGxldCBwcmVkaWN0aW9ucyA9IG5ldyBCaXRTZXRfMS5CaXRTZXQoKTtcbiAgICAgIGZvciAobGV0IHBhaXIgb2YgcHJlZFByZWRpY3Rpb25zKSB7XG4gICAgICAgIGlmIChwYWlyLnByZWQgPT09IFNlbWFudGljQ29udGV4dF8xLlNlbWFudGljQ29udGV4dC5OT05FKSB7XG4gICAgICAgICAgcHJlZGljdGlvbnMuc2V0KHBhaXIuYWx0KTtcbiAgICAgICAgICBpZiAoIWNvbXBsZXRlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV2YWx1YXRlZFJlc3VsdCA9IHRoaXMuZXZhbFNlbWFudGljQ29udGV4dEltcGwocGFpci5wcmVkLCBvdXRlckNvbnRleHQsIHBhaXIuYWx0KTtcbiAgICAgICAgaWYgKFBhcnNlckFUTlNpbXVsYXRvcjMuZGVidWcgfHwgUGFyc2VyQVROU2ltdWxhdG9yMy5kZmFfZGVidWcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcImV2YWwgcHJlZCBcIiArIHBhaXIgKyBcIj1cIiArIGV2YWx1YXRlZFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2YWx1YXRlZFJlc3VsdCkge1xuICAgICAgICAgIGlmIChQYXJzZXJBVE5TaW11bGF0b3IzLmRlYnVnIHx8IFBhcnNlckFUTlNpbXVsYXRvcjMuZGZhX2RlYnVnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlBSRURJQ1QgXCIgKyBwYWlyLmFsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZWRpY3Rpb25zLnNldChwYWlyLmFsdCk7XG4gICAgICAgICAgaWYgKCFjb21wbGV0ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJlZGljdGlvbnM7XG4gICAgfVxuICAgIGV2YWxTZW1hbnRpY0NvbnRleHRJbXBsKHByZWQsIHBhcnNlckNhbGxTdGFjaywgYWx0KSB7XG4gICAgICByZXR1cm4gcHJlZC5ldmFsKHRoaXMuX3BhcnNlciwgcGFyc2VyQ2FsbFN0YWNrKTtcbiAgICB9XG4gICAgY2xvc3VyZShzb3VyY2VDb25maWdzLCBjb25maWdzLCBjb2xsZWN0UHJlZGljYXRlcywgaGFzTW9yZUNvbnRleHQsIGNvbnRleHRDYWNoZSwgdHJlYXRFb2ZBc0Vwc2lsb24pIHtcbiAgICAgIGlmIChjb250ZXh0Q2FjaGUgPT0gbnVsbCkge1xuICAgICAgICBjb250ZXh0Q2FjaGUgPSBQcmVkaWN0aW9uQ29udGV4dENhY2hlXzEuUHJlZGljdGlvbkNvbnRleHRDYWNoZS5VTkNBQ0hFRDtcbiAgICAgIH1cbiAgICAgIGxldCBjdXJyZW50Q29uZmlncyA9IHNvdXJjZUNvbmZpZ3M7XG4gICAgICBsZXQgY2xvc3VyZUJ1c3kgPSBuZXcgQXJyYXkyREhhc2hTZXRfMS5BcnJheTJESGFzaFNldChPYmplY3RFcXVhbGl0eUNvbXBhcmF0b3JfMS5PYmplY3RFcXVhbGl0eUNvbXBhcmF0b3IuSU5TVEFOQ0UpO1xuICAgICAgd2hpbGUgKGN1cnJlbnRDb25maWdzLnNpemUgPiAwKSB7XG4gICAgICAgIGxldCBpbnRlcm1lZGlhdGUgPSBuZXcgQVROQ29uZmlnU2V0XzEuQVROQ29uZmlnU2V0KCk7XG4gICAgICAgIGZvciAobGV0IGNvbmZpZyBvZiBjdXJyZW50Q29uZmlncykge1xuICAgICAgICAgIHRoaXMuY2xvc3VyZUltcGwoY29uZmlnLCBjb25maWdzLCBpbnRlcm1lZGlhdGUsIGNsb3N1cmVCdXN5LCBjb2xsZWN0UHJlZGljYXRlcywgaGFzTW9yZUNvbnRleHQsIGNvbnRleHRDYWNoZSwgMCwgdHJlYXRFb2ZBc0Vwc2lsb24pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRDb25maWdzID0gaW50ZXJtZWRpYXRlO1xuICAgICAgfVxuICAgIH1cbiAgICBjbG9zdXJlSW1wbChjb25maWcsIGNvbmZpZ3MsIGludGVybWVkaWF0ZSwgY2xvc3VyZUJ1c3ksIGNvbGxlY3RQcmVkaWNhdGVzLCBoYXNNb3JlQ29udGV4dHMsIGNvbnRleHRDYWNoZSwgZGVwdGgsIHRyZWF0RW9mQXNFcHNpbG9uKSB7XG4gICAgICBpZiAoUGFyc2VyQVROU2ltdWxhdG9yMy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcImNsb3N1cmUoXCIgKyBjb25maWcudG9TdHJpbmcodGhpcy5fcGFyc2VyLCB0cnVlKSArIFwiKVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb25maWcuc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlXzEuUnVsZVN0b3BTdGF0ZSkge1xuICAgICAgICBpZiAoIWNvbmZpZy5jb250ZXh0LmlzRW1wdHkpIHtcbiAgICAgICAgICBsZXQgaGFzRW1wdHkgPSBjb25maWcuY29udGV4dC5oYXNFbXB0eTtcbiAgICAgICAgICBsZXQgbm9uRW1wdHlTaXplID0gY29uZmlnLmNvbnRleHQuc2l6ZSAtIChoYXNFbXB0eSA/IDEgOiAwKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vbkVtcHR5U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV3Q29udGV4dCA9IGNvbmZpZy5jb250ZXh0LmdldFBhcmVudChpKTtcbiAgICAgICAgICAgIGxldCByZXR1cm5TdGF0ZSA9IHRoaXMuYXRuLnN0YXRlc1tjb25maWcuY29udGV4dC5nZXRSZXR1cm5TdGF0ZShpKV07XG4gICAgICAgICAgICBsZXQgYyA9IEFUTkNvbmZpZ18xLkFUTkNvbmZpZy5jcmVhdGUocmV0dXJuU3RhdGUsIGNvbmZpZy5hbHQsIG5ld0NvbnRleHQsIGNvbmZpZy5zZW1hbnRpY0NvbnRleHQpO1xuICAgICAgICAgICAgYy5vdXRlckNvbnRleHREZXB0aCA9IGNvbmZpZy5vdXRlckNvbnRleHREZXB0aDtcbiAgICAgICAgICAgIGMuaXNQcmVjZWRlbmNlRmlsdGVyU3VwcHJlc3NlZCA9IGNvbmZpZy5pc1ByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkO1xuICAgICAgICAgICAgYXNzZXJ0KGRlcHRoID4gTUlOX0lOVEVHRVJfVkFMVUUpO1xuICAgICAgICAgICAgdGhpcy5jbG9zdXJlSW1wbChjLCBjb25maWdzLCBpbnRlcm1lZGlhdGUsIGNsb3N1cmVCdXN5LCBjb2xsZWN0UHJlZGljYXRlcywgaGFzTW9yZUNvbnRleHRzLCBjb250ZXh0Q2FjaGUsIGRlcHRoIC0gMSwgdHJlYXRFb2ZBc0Vwc2lsb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWhhc0VtcHR5IHx8ICFoYXNNb3JlQ29udGV4dHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uZmlnID0gY29uZmlnLnRyYW5zZm9ybShjb25maWcuc3RhdGUsIGZhbHNlLCBQcmVkaWN0aW9uQ29udGV4dF8xLlByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0xPQ0FMKTtcbiAgICAgICAgfSBlbHNlIGlmICghaGFzTW9yZUNvbnRleHRzKSB7XG4gICAgICAgICAgY29uZmlncy5hZGQoY29uZmlnLCBjb250ZXh0Q2FjaGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoUGFyc2VyQVROU2ltdWxhdG9yMy5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJGQUxMSU5HIG9mZiBydWxlIFwiICsgdGhpcy5nZXRSdWxlTmFtZShjb25maWcuc3RhdGUucnVsZUluZGV4KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb25maWcuY29udGV4dCA9PT0gUHJlZGljdGlvbkNvbnRleHRfMS5QcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9GVUxMKSB7XG4gICAgICAgICAgICBjb25maWcgPSBjb25maWcudHJhbnNmb3JtKGNvbmZpZy5zdGF0ZSwgZmFsc2UsIFByZWRpY3Rpb25Db250ZXh0XzEuUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfTE9DQUwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWNvbmZpZy5yZWFjaGVzSW50b091dGVyQ29udGV4dCAmJiBQcmVkaWN0aW9uQ29udGV4dF8xLlByZWRpY3Rpb25Db250ZXh0LmlzRW1wdHlMb2NhbChjb25maWcuY29udGV4dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ3MuYWRkKGNvbmZpZywgY29udGV4dENhY2hlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBwID0gY29uZmlnLnN0YXRlO1xuICAgICAgaWYgKCFwLm9ubHlIYXNFcHNpbG9uVHJhbnNpdGlvbnMpIHtcbiAgICAgICAgY29uZmlncy5hZGQoY29uZmlnLCBjb250ZXh0Q2FjaGUpO1xuICAgICAgICBpZiAoUGFyc2VyQVROU2ltdWxhdG9yMy5kZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiYWRkZWQgY29uZmlnIFwiICsgY29uZmlncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcC5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPT09IDAgJiYgcC5zdGF0ZVR5cGUgPT09IEFUTlN0YXRlVHlwZV8xLkFUTlN0YXRlVHlwZS5TVEFSX0xPT1BfRU5UUlkgJiYgcC5wcmVjZWRlbmNlUnVsZURlY2lzaW9uICYmICFjb25maWcuY29udGV4dC5oYXNFbXB0eSkge1xuICAgICAgICAgIGxldCBwcmVjZWRlbmNlRGVjaXNpb24gPSBwO1xuICAgICAgICAgIGxldCBzdXBwcmVzcyA9IHRydWU7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb25maWcuY29udGV4dC5zaXplOyBqKyspIHtcbiAgICAgICAgICAgIGlmICghcHJlY2VkZW5jZURlY2lzaW9uLnByZWNlZGVuY2VMb29wYmFja1N0YXRlcy5nZXQoY29uZmlnLmNvbnRleHQuZ2V0UmV0dXJuU3RhdGUoaikpKSB7XG4gICAgICAgICAgICAgIHN1cHByZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3VwcHJlc3MpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdCA9IHAuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbihpKTtcbiAgICAgICAgbGV0IGNvbnRpbnVlQ29sbGVjdGluZyA9ICEodCBpbnN0YW5jZW9mIEFjdGlvblRyYW5zaXRpb25fMS5BY3Rpb25UcmFuc2l0aW9uKSAmJiBjb2xsZWN0UHJlZGljYXRlcztcbiAgICAgICAgbGV0IGMgPSB0aGlzLmdldEVwc2lsb25UYXJnZXQoY29uZmlnLCB0LCBjb250aW51ZUNvbGxlY3RpbmcsIGRlcHRoID09PSAwLCBjb250ZXh0Q2FjaGUsIHRyZWF0RW9mQXNFcHNpbG9uKTtcbiAgICAgICAgaWYgKGMgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0IGluc3RhbmNlb2YgUnVsZVRyYW5zaXRpb25fMS5SdWxlVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgaWYgKGludGVybWVkaWF0ZSAhPSBudWxsICYmICFjb2xsZWN0UHJlZGljYXRlcykge1xuICAgICAgICAgICAgICBpbnRlcm1lZGlhdGUuYWRkKGMsIGNvbnRleHRDYWNoZSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgbmV3RGVwdGggPSBkZXB0aDtcbiAgICAgICAgICBpZiAoY29uZmlnLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZV8xLlJ1bGVTdG9wU3RhdGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRmYSAhPSBudWxsICYmIHRoaXMuZGZhLmlzUHJlY2VkZW5jZURmYSkge1xuICAgICAgICAgICAgICBsZXQgb3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybiA9IHQub3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybjtcbiAgICAgICAgICAgICAgaWYgKG91dGVybW9zdFByZWNlZGVuY2VSZXR1cm4gPT09IHRoaXMuZGZhLmF0blN0YXJ0U3RhdGUucnVsZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgYy5pc1ByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYy5vdXRlckNvbnRleHREZXB0aCA9IGMub3V0ZXJDb250ZXh0RGVwdGggKyAxO1xuICAgICAgICAgICAgaWYgKCFjbG9zdXJlQnVzeS5hZGQoYykpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQobmV3RGVwdGggPiBNSU5fSU5URUdFUl9WQUxVRSk7XG4gICAgICAgICAgICBuZXdEZXB0aC0tO1xuICAgICAgICAgICAgaWYgKFBhcnNlckFUTlNpbXVsYXRvcjMuZGVidWcpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJkaXBzIGludG8gb3V0ZXIgY3R4OiBcIiArIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodCBpbnN0YW5jZW9mIFJ1bGVUcmFuc2l0aW9uXzEuUnVsZVRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGltaXplX3RhaWxfY2FsbHMgJiYgdC5vcHRpbWl6ZWRUYWlsQ2FsbCAmJiAoIXRoaXMudGFpbF9jYWxsX3ByZXNlcnZlc19zbGwgfHwgIVByZWRpY3Rpb25Db250ZXh0XzEuUHJlZGljdGlvbkNvbnRleHQuaXNFbXB0eUxvY2FsKGNvbmZpZy5jb250ZXh0KSkpIHtcbiAgICAgICAgICAgICAgYXNzZXJ0KGMuY29udGV4dCA9PT0gY29uZmlnLmNvbnRleHQpO1xuICAgICAgICAgICAgICBpZiAobmV3RGVwdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBuZXdEZXB0aC0tO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy50YWlsX2NhbGxfcHJlc2VydmVzX3NsbCAmJiBQcmVkaWN0aW9uQ29udGV4dF8xLlByZWRpY3Rpb25Db250ZXh0LmlzRW1wdHlMb2NhbChjb25maWcuY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgIGMub3V0ZXJDb250ZXh0RGVwdGggPSBjLm91dGVyQ29udGV4dERlcHRoICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChuZXdEZXB0aCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbmV3RGVwdGgrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXQuaXNFcHNpbG9uICYmICFjbG9zdXJlQnVzeS5hZGQoYykpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY2xvc3VyZUltcGwoYywgY29uZmlncywgaW50ZXJtZWRpYXRlLCBjbG9zdXJlQnVzeSwgY29udGludWVDb2xsZWN0aW5nLCBoYXNNb3JlQ29udGV4dHMsIGNvbnRleHRDYWNoZSwgbmV3RGVwdGgsIHRyZWF0RW9mQXNFcHNpbG9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBnZXRSdWxlTmFtZShpbmRleCkge1xuICAgICAgaWYgKHRoaXMuX3BhcnNlciAhPSBudWxsICYmIGluZGV4ID49IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlci5ydWxlTmFtZXNbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiPHJ1bGUgXCIgKyBpbmRleCArIFwiPlwiO1xuICAgIH1cbiAgICBnZXRFcHNpbG9uVGFyZ2V0KGNvbmZpZywgdCwgY29sbGVjdFByZWRpY2F0ZXMsIGluQ29udGV4dCwgY29udGV4dENhY2hlLCB0cmVhdEVvZkFzRXBzaWxvbikge1xuICAgICAgc3dpdGNoICh0LnNlcmlhbGl6YXRpb25UeXBlKSB7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5ydWxlVHJhbnNpdGlvbihjb25maWcsIHQsIGNvbnRleHRDYWNoZSk7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHJlY2VkZW5jZVRyYW5zaXRpb24oY29uZmlnLCB0LCBjb2xsZWN0UHJlZGljYXRlcywgaW5Db250ZXh0KTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiB0aGlzLnByZWRUcmFuc2l0aW9uKGNvbmZpZywgdCwgY29sbGVjdFByZWRpY2F0ZXMsIGluQ29udGV4dCk7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb25UcmFuc2l0aW9uKGNvbmZpZywgdCk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gY29uZmlnLnRyYW5zZm9ybSh0LnRhcmdldCwgZmFsc2UpO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIGlmICh0cmVhdEVvZkFzRXBzaWxvbikge1xuICAgICAgICAgICAgaWYgKHQubWF0Y2hlcyhUb2tlbl8xLlRva2VuLkVPRiwgMCwgMSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy50cmFuc2Zvcm0odC50YXJnZXQsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBhY3Rpb25UcmFuc2l0aW9uKGNvbmZpZywgdCkge1xuICAgICAgaWYgKFBhcnNlckFUTlNpbXVsYXRvcjMuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJBQ1RJT04gZWRnZSBcIiArIHQucnVsZUluZGV4ICsgXCI6XCIgKyB0LmFjdGlvbkluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25maWcudHJhbnNmb3JtKHQudGFyZ2V0LCBmYWxzZSk7XG4gICAgfVxuICAgIHByZWNlZGVuY2VUcmFuc2l0aW9uKGNvbmZpZywgcHQsIGNvbGxlY3RQcmVkaWNhdGVzLCBpbkNvbnRleHQpIHtcbiAgICAgIGlmIChQYXJzZXJBVE5TaW11bGF0b3IzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiUFJFRCAoY29sbGVjdFByZWRpY2F0ZXM9XCIgKyBjb2xsZWN0UHJlZGljYXRlcyArIFwiKSBcIiArIHB0LnByZWNlZGVuY2UgKyBcIj49X3AsIGN0eCBkZXBlbmRlbnQ9dHJ1ZVwiKTtcbiAgICAgICAgaWYgKHRoaXMuX3BhcnNlciAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJjb250ZXh0IHN1cnJvdW5kaW5nIHByZWQgaXMgXCIgKyB0aGlzLl9wYXJzZXIuZ2V0UnVsZUludm9jYXRpb25TdGFjaygpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGM7XG4gICAgICBpZiAoY29sbGVjdFByZWRpY2F0ZXMgJiYgaW5Db250ZXh0KSB7XG4gICAgICAgIGxldCBuZXdTZW1DdHggPSBTZW1hbnRpY0NvbnRleHRfMS5TZW1hbnRpY0NvbnRleHQuYW5kKGNvbmZpZy5zZW1hbnRpY0NvbnRleHQsIHB0LnByZWRpY2F0ZSk7XG4gICAgICAgIGMgPSBjb25maWcudHJhbnNmb3JtKHB0LnRhcmdldCwgZmFsc2UsIG5ld1NlbUN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjID0gY29uZmlnLnRyYW5zZm9ybShwdC50YXJnZXQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChQYXJzZXJBVE5TaW11bGF0b3IzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiY29uZmlnIGZyb20gcHJlZCB0cmFuc2l0aW9uPVwiICsgYyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgcHJlZFRyYW5zaXRpb24oY29uZmlnLCBwdCwgY29sbGVjdFByZWRpY2F0ZXMsIGluQ29udGV4dCkge1xuICAgICAgaWYgKFBhcnNlckFUTlNpbXVsYXRvcjMuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJQUkVEIChjb2xsZWN0UHJlZGljYXRlcz1cIiArIGNvbGxlY3RQcmVkaWNhdGVzICsgXCIpIFwiICsgcHQucnVsZUluZGV4ICsgXCI6XCIgKyBwdC5wcmVkSW5kZXggKyBcIiwgY3R4IGRlcGVuZGVudD1cIiArIHB0LmlzQ3R4RGVwZW5kZW50KTtcbiAgICAgICAgaWYgKHRoaXMuX3BhcnNlciAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJjb250ZXh0IHN1cnJvdW5kaW5nIHByZWQgaXMgXCIgKyB0aGlzLl9wYXJzZXIuZ2V0UnVsZUludm9jYXRpb25TdGFjaygpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGM7XG4gICAgICBpZiAoY29sbGVjdFByZWRpY2F0ZXMgJiYgKCFwdC5pc0N0eERlcGVuZGVudCB8fCBwdC5pc0N0eERlcGVuZGVudCAmJiBpbkNvbnRleHQpKSB7XG4gICAgICAgIGxldCBuZXdTZW1DdHggPSBTZW1hbnRpY0NvbnRleHRfMS5TZW1hbnRpY0NvbnRleHQuYW5kKGNvbmZpZy5zZW1hbnRpY0NvbnRleHQsIHB0LnByZWRpY2F0ZSk7XG4gICAgICAgIGMgPSBjb25maWcudHJhbnNmb3JtKHB0LnRhcmdldCwgZmFsc2UsIG5ld1NlbUN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjID0gY29uZmlnLnRyYW5zZm9ybShwdC50YXJnZXQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChQYXJzZXJBVE5TaW11bGF0b3IzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiY29uZmlnIGZyb20gcHJlZCB0cmFuc2l0aW9uPVwiICsgYyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgcnVsZVRyYW5zaXRpb24oY29uZmlnLCB0LCBjb250ZXh0Q2FjaGUpIHtcbiAgICAgIGlmIChQYXJzZXJBVE5TaW11bGF0b3IzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ0FMTCBydWxlIFwiICsgdGhpcy5nZXRSdWxlTmFtZSh0LnRhcmdldC5ydWxlSW5kZXgpICsgXCIsIGN0eD1cIiArIGNvbmZpZy5jb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGxldCByZXR1cm5TdGF0ZSA9IHQuZm9sbG93U3RhdGU7XG4gICAgICBsZXQgbmV3Q29udGV4dDtcbiAgICAgIGlmICh0aGlzLm9wdGltaXplX3RhaWxfY2FsbHMgJiYgdC5vcHRpbWl6ZWRUYWlsQ2FsbCAmJiAoIXRoaXMudGFpbF9jYWxsX3ByZXNlcnZlc19zbGwgfHwgIVByZWRpY3Rpb25Db250ZXh0XzEuUHJlZGljdGlvbkNvbnRleHQuaXNFbXB0eUxvY2FsKGNvbmZpZy5jb250ZXh0KSkpIHtcbiAgICAgICAgbmV3Q29udGV4dCA9IGNvbmZpZy5jb250ZXh0O1xuICAgICAgfSBlbHNlIGlmIChjb250ZXh0Q2FjaGUgIT0gbnVsbCkge1xuICAgICAgICBuZXdDb250ZXh0ID0gY29udGV4dENhY2hlLmdldENoaWxkKGNvbmZpZy5jb250ZXh0LCByZXR1cm5TdGF0ZS5zdGF0ZU51bWJlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdDb250ZXh0ID0gY29uZmlnLmNvbnRleHQuZ2V0Q2hpbGQocmV0dXJuU3RhdGUuc3RhdGVOdW1iZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmZpZy50cmFuc2Zvcm0odC50YXJnZXQsIGZhbHNlLCBuZXdDb250ZXh0KTtcbiAgICB9XG4gICAgaXNDb25mbGljdGVkKGNvbmZpZ3NldCwgY29udGV4dENhY2hlKSB7XG4gICAgICBpZiAoY29uZmlnc2V0LnVuaXF1ZUFsdCAhPT0gQVROXzEuQVROLklOVkFMSURfQUxUX05VTUJFUiB8fCBjb25maWdzZXQuc2l6ZSA8PSAxKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBsZXQgY29uZmlncyA9IGNvbmZpZ3NldC50b0FycmF5KCk7XG4gICAgICBjb25maWdzLnNvcnQoUGFyc2VyQVROU2ltdWxhdG9yMy5TVEFURV9BTFRfU09SVF9DT01QQVJBVE9SKTtcbiAgICAgIGxldCBleGFjdCA9ICFjb25maWdzZXQuZGlwc0ludG9PdXRlckNvbnRleHQ7XG4gICAgICBsZXQgYWx0cyA9IG5ldyBCaXRTZXRfMS5CaXRTZXQoKTtcbiAgICAgIGxldCBtaW5BbHQgPSBjb25maWdzWzBdLmFsdDtcbiAgICAgIGFsdHMuc2V0KG1pbkFsdCk7XG4gICAgICBsZXQgY3VycmVudFN0YXRlID0gY29uZmlnc1swXS5zdGF0ZS5ub25TdG9wU3RhdGVOdW1iZXI7XG4gICAgICBmb3IgKGxldCBjb25maWcgb2YgY29uZmlncykge1xuICAgICAgICBsZXQgc3RhdGVOdW1iZXIgPSBjb25maWcuc3RhdGUubm9uU3RvcFN0YXRlTnVtYmVyO1xuICAgICAgICBpZiAoc3RhdGVOdW1iZXIgIT09IGN1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgIGlmIChjb25maWcuYWx0ICE9PSBtaW5BbHQpIHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IHN0YXRlTnVtYmVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgcmVwcmVzZW50ZWRBbHRzO1xuICAgICAgaWYgKGV4YWN0KSB7XG4gICAgICAgIGN1cnJlbnRTdGF0ZSA9IGNvbmZpZ3NbMF0uc3RhdGUubm9uU3RvcFN0YXRlTnVtYmVyO1xuICAgICAgICByZXByZXNlbnRlZEFsdHMgPSBuZXcgQml0U2V0XzEuQml0U2V0KCk7XG4gICAgICAgIGxldCBtYXhBbHQgPSBtaW5BbHQ7XG4gICAgICAgIGZvciAobGV0IGNvbmZpZyBvZiBjb25maWdzKSB7XG4gICAgICAgICAgaWYgKGNvbmZpZy5zdGF0ZS5ub25TdG9wU3RhdGVOdW1iZXIgIT09IGN1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBhbHQgPSBjb25maWcuYWx0O1xuICAgICAgICAgIHJlcHJlc2VudGVkQWx0cy5zZXQoYWx0KTtcbiAgICAgICAgICBtYXhBbHQgPSBhbHQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFN0YXRlID0gY29uZmlnc1swXS5zdGF0ZS5ub25TdG9wU3RhdGVOdW1iZXI7XG4gICAgICAgIGxldCBjdXJyZW50QWx0ID0gbWluQWx0O1xuICAgICAgICBmb3IgKGxldCBjb25maWcgb2YgY29uZmlncykge1xuICAgICAgICAgIGxldCBzdGF0ZU51bWJlciA9IGNvbmZpZy5zdGF0ZS5ub25TdG9wU3RhdGVOdW1iZXI7XG4gICAgICAgICAgbGV0IGFsdCA9IGNvbmZpZy5hbHQ7XG4gICAgICAgICAgaWYgKHN0YXRlTnVtYmVyICE9PSBjdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50QWx0ICE9PSBtYXhBbHQpIHtcbiAgICAgICAgICAgICAgZXhhY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBzdGF0ZU51bWJlcjtcbiAgICAgICAgICAgIGN1cnJlbnRBbHQgPSBtaW5BbHQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChhbHQgIT09IGN1cnJlbnRBbHQpIHtcbiAgICAgICAgICAgIGlmIChhbHQgIT09IHJlcHJlc2VudGVkQWx0cy5uZXh0U2V0Qml0KGN1cnJlbnRBbHQgKyAxKSkge1xuICAgICAgICAgICAgICBleGFjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRBbHQgPSBhbHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdXJyZW50U3RhdGUgPSBjb25maWdzWzBdLnN0YXRlLm5vblN0b3BTdGF0ZU51bWJlcjtcbiAgICAgIGxldCBmaXJzdEluZGV4Q3VycmVudFN0YXRlID0gMDtcbiAgICAgIGxldCBsYXN0SW5kZXhDdXJyZW50U3RhdGVNaW5BbHQgPSAwO1xuICAgICAgbGV0IGpvaW5lZENoZWNrQ29udGV4dCA9IGNvbmZpZ3NbMF0uY29udGV4dDtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY29uZmlncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY29uZmlnID0gY29uZmlnc1tpXTtcbiAgICAgICAgaWYgKGNvbmZpZy5hbHQgIT09IG1pbkFsdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuc3RhdGUubm9uU3RvcFN0YXRlTnVtYmVyICE9PSBjdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsYXN0SW5kZXhDdXJyZW50U3RhdGVNaW5BbHQgPSBpO1xuICAgICAgICBqb2luZWRDaGVja0NvbnRleHQgPSBjb250ZXh0Q2FjaGUuam9pbihqb2luZWRDaGVja0NvbnRleHQsIGNvbmZpZ3NbaV0uY29udGV4dCk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gbGFzdEluZGV4Q3VycmVudFN0YXRlTWluQWx0ICsgMTsgaSA8IGNvbmZpZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IGNvbmZpZ3NbaV07XG4gICAgICAgIGxldCBzdGF0ZSA9IGNvbmZpZy5zdGF0ZTtcbiAgICAgICAgYWx0cy5zZXQoY29uZmlnLmFsdCk7XG4gICAgICAgIGlmIChzdGF0ZS5ub25TdG9wU3RhdGVOdW1iZXIgIT09IGN1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IHN0YXRlLm5vblN0b3BTdGF0ZU51bWJlcjtcbiAgICAgICAgICBmaXJzdEluZGV4Q3VycmVudFN0YXRlID0gaTtcbiAgICAgICAgICBsYXN0SW5kZXhDdXJyZW50U3RhdGVNaW5BbHQgPSBpO1xuICAgICAgICAgIGpvaW5lZENoZWNrQ29udGV4dCA9IGNvbmZpZy5jb250ZXh0O1xuICAgICAgICAgIGZvciAobGV0IGogPSBmaXJzdEluZGV4Q3VycmVudFN0YXRlICsgMTsgaiA8IGNvbmZpZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCBjb25maWcyID0gY29uZmlnc1tqXTtcbiAgICAgICAgICAgIGlmIChjb25maWcyLmFsdCAhPT0gbWluQWx0KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuc3RhdGUubm9uU3RvcFN0YXRlTnVtYmVyICE9PSBjdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0SW5kZXhDdXJyZW50U3RhdGVNaW5BbHQgPSBqO1xuICAgICAgICAgICAgam9pbmVkQ2hlY2tDb250ZXh0ID0gY29udGV4dENhY2hlLmpvaW4oam9pbmVkQ2hlY2tDb250ZXh0LCBjb25maWcyLmNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpID0gbGFzdEluZGV4Q3VycmVudFN0YXRlTWluQWx0O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBqb2luZWRDaGVja0NvbnRleHQyID0gY29uZmlnLmNvbnRleHQ7XG4gICAgICAgIGxldCBjdXJyZW50QWx0ID0gY29uZmlnLmFsdDtcbiAgICAgICAgbGV0IGxhc3RJbmRleEN1cnJlbnRTdGF0ZUN1cnJlbnRBbHQgPSBpO1xuICAgICAgICBmb3IgKGxldCBqID0gbGFzdEluZGV4Q3VycmVudFN0YXRlQ3VycmVudEFsdCArIDE7IGogPCBjb25maWdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgbGV0IGNvbmZpZzIgPSBjb25maWdzW2pdO1xuICAgICAgICAgIGlmIChjb25maWcyLmFsdCAhPT0gY3VycmVudEFsdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb25maWcyLnN0YXRlLm5vblN0b3BTdGF0ZU51bWJlciAhPT0gY3VycmVudFN0YXRlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdEluZGV4Q3VycmVudFN0YXRlQ3VycmVudEFsdCA9IGo7XG4gICAgICAgICAgam9pbmVkQ2hlY2tDb250ZXh0MiA9IGNvbnRleHRDYWNoZS5qb2luKGpvaW5lZENoZWNrQ29udGV4dDIsIGNvbmZpZzIuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaSA9IGxhc3RJbmRleEN1cnJlbnRTdGF0ZUN1cnJlbnRBbHQ7XG4gICAgICAgIGxldCBjaGVjayA9IGNvbnRleHRDYWNoZS5qb2luKGpvaW5lZENoZWNrQ29udGV4dCwgam9pbmVkQ2hlY2tDb250ZXh0Mik7XG4gICAgICAgIGlmICgham9pbmVkQ2hlY2tDb250ZXh0LmVxdWFscyhjaGVjaykpIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGV4YWN0ID0gZXhhY3QgJiYgam9pbmVkQ2hlY2tDb250ZXh0LmVxdWFscyhqb2luZWRDaGVja0NvbnRleHQyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ29uZmxpY3RJbmZvXzEuQ29uZmxpY3RJbmZvKGFsdHMsIGV4YWN0KTtcbiAgICB9XG4gICAgZ2V0Q29uZmxpY3RpbmdBbHRzRnJvbUNvbmZpZ1NldChjb25maWdzKSB7XG4gICAgICBsZXQgY29uZmxpY3RpbmdBbHRzID0gY29uZmlncy5jb25mbGljdGluZ0FsdHM7XG4gICAgICBpZiAoY29uZmxpY3RpbmdBbHRzID09IG51bGwgJiYgY29uZmlncy51bmlxdWVBbHQgIT09IEFUTl8xLkFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcbiAgICAgICAgY29uZmxpY3RpbmdBbHRzID0gbmV3IEJpdFNldF8xLkJpdFNldCgpO1xuICAgICAgICBjb25mbGljdGluZ0FsdHMuc2V0KGNvbmZpZ3MudW5pcXVlQWx0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25mbGljdGluZ0FsdHM7XG4gICAgfVxuICAgIGdldFRva2VuTmFtZSh0KSB7XG4gICAgICBpZiAodCA9PT0gVG9rZW5fMS5Ub2tlbi5FT0YpIHtcbiAgICAgICAgcmV0dXJuIFwiRU9GXCI7XG4gICAgICB9XG4gICAgICBsZXQgdm9jYWJ1bGFyeSA9IHRoaXMuX3BhcnNlciAhPSBudWxsID8gdGhpcy5fcGFyc2VyLnZvY2FidWxhcnkgOiBWb2NhYnVsYXJ5SW1wbF8xLlZvY2FidWxhcnlJbXBsLkVNUFRZX1ZPQ0FCVUxBUlk7XG4gICAgICBsZXQgZGlzcGxheU5hbWUgPSB2b2NhYnVsYXJ5LmdldERpc3BsYXlOYW1lKHQpO1xuICAgICAgaWYgKGRpc3BsYXlOYW1lID09PSBTdHJpbmcodCkpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpc3BsYXlOYW1lICsgXCI8XCIgKyB0ICsgXCI+XCI7XG4gICAgfVxuICAgIGdldExvb2thaGVhZE5hbWUoaW5wdXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRva2VuTmFtZShpbnB1dC5MQSgxKSk7XG4gICAgfVxuICAgIGR1bXBEZWFkRW5kQ29uZmlncyhudmFlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImRlYWQgZW5kIGNvbmZpZ3M6IFwiKTtcbiAgICAgIGxldCBkZWFkRW5kQ29uZmlncyA9IG52YWUuZGVhZEVuZENvbmZpZ3M7XG4gICAgICBpZiAoIWRlYWRFbmRDb25maWdzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGMgb2YgZGVhZEVuZENvbmZpZ3MpIHtcbiAgICAgICAgbGV0IHRyYW5zID0gXCJubyBlZGdlc1wiO1xuICAgICAgICBpZiAoYy5zdGF0ZS5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zID4gMCkge1xuICAgICAgICAgIGxldCB0ID0gYy5zdGF0ZS5nZXRPcHRpbWl6ZWRUcmFuc2l0aW9uKDApO1xuICAgICAgICAgIGlmICh0IGluc3RhbmNlb2YgQXRvbVRyYW5zaXRpb25fMS5BdG9tVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgdHJhbnMgPSBcIkF0b20gXCIgKyB0aGlzLmdldFRva2VuTmFtZSh0Ll9sYWJlbCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0IGluc3RhbmNlb2YgU2V0VHJhbnNpdGlvbl8xLlNldFRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGxldCBub3QgPSB0IGluc3RhbmNlb2YgTm90U2V0VHJhbnNpdGlvbl8xLk5vdFNldFRyYW5zaXRpb247XG4gICAgICAgICAgICB0cmFucyA9IChub3QgPyBcIn5cIiA6IFwiXCIpICsgXCJTZXQgXCIgKyB0LnNldC50b1N0cmluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhjLnRvU3RyaW5nKHRoaXMuX3BhcnNlciwgdHJ1ZSkgKyBcIjpcIiArIHRyYW5zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbm9WaWFibGVBbHQoaW5wdXQsIG91dGVyQ29udGV4dCwgY29uZmlncywgc3RhcnRJbmRleCkge1xuICAgICAgcmV0dXJuIG5ldyBOb1ZpYWJsZUFsdEV4Y2VwdGlvbl8xLk5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMuX3BhcnNlciwgaW5wdXQsIGlucHV0LmdldChzdGFydEluZGV4KSwgaW5wdXQuTFQoMSksIGNvbmZpZ3MsIG91dGVyQ29udGV4dCk7XG4gICAgfVxuICAgIGdldFVuaXF1ZUFsdChjb25maWdzKSB7XG4gICAgICBsZXQgYWx0ID0gQVROXzEuQVROLklOVkFMSURfQUxUX05VTUJFUjtcbiAgICAgIGZvciAobGV0IGMgb2YgY29uZmlncykge1xuICAgICAgICBpZiAoYWx0ID09PSBBVE5fMS5BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XG4gICAgICAgICAgYWx0ID0gYy5hbHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYy5hbHQgIT09IGFsdCkge1xuICAgICAgICAgIHJldHVybiBBVE5fMS5BVE4uSU5WQUxJRF9BTFRfTlVNQkVSO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYWx0O1xuICAgIH1cbiAgICBjb25maWdXaXRoQWx0QXRTdG9wU3RhdGUoY29uZmlncywgYWx0KSB7XG4gICAgICBmb3IgKGxldCBjIG9mIGNvbmZpZ3MpIHtcbiAgICAgICAgaWYgKGMuYWx0ID09PSBhbHQpIHtcbiAgICAgICAgICBpZiAoYy5zdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGVfMS5SdWxlU3RvcFN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYWRkREZBRWRnZShkZmEsIGZyb21TdGF0ZSwgdCwgY29udGV4dFRyYW5zaXRpb25zLCB0b0NvbmZpZ3MsIGNvbnRleHRDYWNoZSkge1xuICAgICAgYXNzZXJ0KGNvbnRleHRUcmFuc2l0aW9ucyA9PSBudWxsIHx8IGNvbnRleHRUcmFuc2l0aW9ucy5pc0VtcHR5IHx8IGRmYS5pc0NvbnRleHRTZW5zaXRpdmUpO1xuICAgICAgbGV0IGZyb20gPSBmcm9tU3RhdGU7XG4gICAgICBsZXQgdG8gPSB0aGlzLmFkZERGQVN0YXRlKGRmYSwgdG9Db25maWdzLCBjb250ZXh0Q2FjaGUpO1xuICAgICAgaWYgKGNvbnRleHRUcmFuc2l0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGZvciAobGV0IGNvbnRleHQgb2YgY29udGV4dFRyYW5zaXRpb25zLnRvQXJyYXkoKSkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSBQcmVkaWN0aW9uQ29udGV4dF8xLlByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZKSB7XG4gICAgICAgICAgICBpZiAoZnJvbS5jb25maWdzLmlzT3V0ZXJtb3N0Q29uZmlnU2V0KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmcm9tLnNldENvbnRleHRTZW5zaXRpdmUodGhpcy5hdG4pO1xuICAgICAgICAgIGZyb20uc2V0Q29udGV4dFN5bWJvbCh0KTtcbiAgICAgICAgICBsZXQgbmV4dCA9IGZyb20uZ2V0Q29udGV4dFRhcmdldChjb250ZXh0KTtcbiAgICAgICAgICBpZiAobmV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBmcm9tID0gbmV4dDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0ID0gdGhpcy5hZGRERkFDb250ZXh0U3RhdGUoZGZhLCBmcm9tLmNvbmZpZ3MsIGNvbnRleHQsIGNvbnRleHRDYWNoZSk7XG4gICAgICAgICAgYXNzZXJ0KGNvbnRleHQgIT09IFByZWRpY3Rpb25Db250ZXh0XzEuUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTF9TVEFURV9LRVkgfHwgbmV4dC5jb25maWdzLmlzT3V0ZXJtb3N0Q29uZmlnU2V0KTtcbiAgICAgICAgICBmcm9tLnNldENvbnRleHRUYXJnZXQoY29udGV4dCwgbmV4dCk7XG4gICAgICAgICAgZnJvbSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChQYXJzZXJBVE5TaW11bGF0b3IzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRURHRSBcIiArIGZyb20gKyBcIiAtPiBcIiArIHRvICsgXCIgdXBvbiBcIiArIHRoaXMuZ2V0VG9rZW5OYW1lKHQpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0REZBRWRnZShmcm9tLCB0LCB0byk7XG4gICAgICBpZiAoUGFyc2VyQVROU2ltdWxhdG9yMy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkRGQT1cXG5cIiArIGRmYS50b1N0cmluZyh0aGlzLl9wYXJzZXIgIT0gbnVsbCA/IHRoaXMuX3BhcnNlci52b2NhYnVsYXJ5IDogVm9jYWJ1bGFyeUltcGxfMS5Wb2NhYnVsYXJ5SW1wbC5FTVBUWV9WT0NBQlVMQVJZLCB0aGlzLl9wYXJzZXIgIT0gbnVsbCA/IHRoaXMuX3BhcnNlci5ydWxlTmFtZXMgOiB2b2lkIDApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgc2V0REZBRWRnZShwLCB0LCBxKSB7XG4gICAgICBpZiAocCAhPSBudWxsKSB7XG4gICAgICAgIHAuc2V0VGFyZ2V0KHQsIHEpO1xuICAgICAgfVxuICAgIH1cbiAgICBhZGRERkFDb250ZXh0U3RhdGUoZGZhLCBjb25maWdzLCByZXR1cm5Db250ZXh0LCBjb250ZXh0Q2FjaGUpIHtcbiAgICAgIGlmIChyZXR1cm5Db250ZXh0ICE9PSBQcmVkaWN0aW9uQ29udGV4dF8xLlByZWRpY3Rpb25Db250ZXh0LkVNUFRZX0ZVTExfU1RBVEVfS0VZKSB7XG4gICAgICAgIGxldCBjb250ZXh0Q29uZmlncyA9IG5ldyBBVE5Db25maWdTZXRfMS5BVE5Db25maWdTZXQoKTtcbiAgICAgICAgZm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpIHtcbiAgICAgICAgICBjb250ZXh0Q29uZmlncy5hZGQoY29uZmlnLmFwcGVuZENvbnRleHQocmV0dXJuQ29udGV4dCwgY29udGV4dENhY2hlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkREZBU3RhdGUoZGZhLCBjb250ZXh0Q29uZmlncywgY29udGV4dENhY2hlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2VydCghY29uZmlncy5pc091dGVybW9zdENvbmZpZ1NldCwgXCJTaG91bGRuJ3QgYmUgYWRkaW5nIGEgZHVwbGljYXRlIGVkZ2UuXCIpO1xuICAgICAgICBjb25maWdzID0gY29uZmlncy5jbG9uZSh0cnVlKTtcbiAgICAgICAgY29uZmlncy5pc091dGVybW9zdENvbmZpZ1NldCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZERGQVN0YXRlKGRmYSwgY29uZmlncywgY29udGV4dENhY2hlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYWRkREZBU3RhdGUoZGZhLCBjb25maWdzLCBjb250ZXh0Q2FjaGUpIHtcbiAgICAgIGxldCBlbmFibGVEZmEgPSB0aGlzLmVuYWJsZV9nbG9iYWxfY29udGV4dF9kZmEgfHwgIWNvbmZpZ3MuaXNPdXRlcm1vc3RDb25maWdTZXQ7XG4gICAgICBpZiAoZW5hYmxlRGZhKSB7XG4gICAgICAgIGlmICghY29uZmlncy5pc1JlYWRPbmx5KSB7XG4gICAgICAgICAgY29uZmlncy5vcHRpbWl6ZUNvbmZpZ3ModGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByb3Bvc2VkID0gdGhpcy5jcmVhdGVERkFTdGF0ZShkZmEsIGNvbmZpZ3MpO1xuICAgICAgICBsZXQgZXhpc3RpbmcgPSBkZmEuc3RhdGVzLmdldChwcm9wb3NlZCk7XG4gICAgICAgIGlmIChleGlzdGluZyAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNvbmZpZ3MuaXNSZWFkT25seSkge1xuICAgICAgICBpZiAoY29uZmlncy5jb25mbGljdEluZm8gPT0gbnVsbCkge1xuICAgICAgICAgIGNvbmZpZ3MuY29uZmxpY3RJbmZvID0gdGhpcy5pc0NvbmZsaWN0ZWQoY29uZmlncywgY29udGV4dENhY2hlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IG5ld1N0YXRlID0gdGhpcy5jcmVhdGVERkFTdGF0ZShkZmEsIGNvbmZpZ3MuY2xvbmUodHJ1ZSkpO1xuICAgICAgbGV0IGRlY2lzaW9uU3RhdGUgPSB0aGlzLmF0bi5nZXREZWNpc2lvblN0YXRlKGRmYS5kZWNpc2lvbik7XG4gICAgICBsZXQgcHJlZGljdGVkQWx0ID0gdGhpcy5nZXRVbmlxdWVBbHQoY29uZmlncyk7XG4gICAgICBpZiAocHJlZGljdGVkQWx0ICE9PSBBVE5fMS5BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XG4gICAgICAgIG5ld1N0YXRlLmFjY2VwdFN0YXRlSW5mbyA9IG5ldyBBY2NlcHRTdGF0ZUluZm9fMS5BY2NlcHRTdGF0ZUluZm8ocHJlZGljdGVkQWx0KTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlncy5jb25mbGljdGluZ0FsdHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgY29uZmxpY3RpbmdBbHRzID0gY29uZmlncy5jb25mbGljdGluZ0FsdHM7XG4gICAgICAgIGlmIChjb25mbGljdGluZ0FsdHMpIHtcbiAgICAgICAgICBuZXdTdGF0ZS5hY2NlcHRTdGF0ZUluZm8gPSBuZXcgQWNjZXB0U3RhdGVJbmZvXzEuQWNjZXB0U3RhdGVJbmZvKGNvbmZsaWN0aW5nQWx0cy5uZXh0U2V0Qml0KDApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5ld1N0YXRlLmlzQWNjZXB0U3RhdGUgJiYgY29uZmlncy5oYXNTZW1hbnRpY0NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGVERkFTdGF0ZShuZXdTdGF0ZSwgY29uZmlncywgZGVjaXNpb25TdGF0ZS5udW1iZXJPZlRyYW5zaXRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICghZW5hYmxlRGZhKSB7XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGxldCBhZGRlZCA9IGRmYS5hZGRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICBpZiAoUGFyc2VyQVROU2ltdWxhdG9yMy5kZWJ1ZyAmJiBhZGRlZCA9PT0gbmV3U3RhdGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJhZGRpbmcgbmV3IERGQSBzdGF0ZTogXCIgKyBuZXdTdGF0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWRkZWQ7XG4gICAgfVxuICAgIGNyZWF0ZURGQVN0YXRlKGRmYSwgY29uZmlncykge1xuICAgICAgcmV0dXJuIG5ldyBERkFTdGF0ZV8xLkRGQVN0YXRlKGNvbmZpZ3MpO1xuICAgIH1cbiAgICByZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHQoZGZhLCBjb25mbGljdGluZ0FsdHMsIGNvbmZsaWN0U3RhdGUsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCkge1xuICAgICAgaWYgKFBhcnNlckFUTlNpbXVsYXRvcjMuZGVidWcgfHwgUGFyc2VyQVROU2ltdWxhdG9yMy5yZXRyeV9kZWJ1Zykge1xuICAgICAgICBsZXQgaW50ZXJ2YWwgPSBJbnRlcnZhbF8xLkludGVydmFsLm9mKHN0YXJ0SW5kZXgsIHN0b3BJbmRleCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwicmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0IGRlY2lzaW9uPVwiICsgZGZhLmRlY2lzaW9uICsgXCI6XCIgKyBjb25mbGljdFN0YXRlLnMwLmNvbmZpZ3MgKyBcIiwgaW5wdXQ9XCIgKyB0aGlzLl9wYXJzZXIuaW5wdXRTdHJlYW0uZ2V0VGV4dChpbnRlcnZhbCkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3BhcnNlciAhPSBudWxsKSB7XG4gICAgICAgIGxldCBsaXN0ZW5lciA9IHRoaXMuX3BhcnNlci5nZXRFcnJvckxpc3RlbmVyRGlzcGF0Y2goKTtcbiAgICAgICAgaWYgKGxpc3RlbmVyLnJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dCkge1xuICAgICAgICAgIGxpc3RlbmVyLnJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dCh0aGlzLl9wYXJzZXIsIGRmYSwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBjb25mbGljdGluZ0FsdHMsIGNvbmZsaWN0U3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlcG9ydENvbnRleHRTZW5zaXRpdml0eShkZmEsIHByZWRpY3Rpb24sIGFjY2VwdFN0YXRlLCBzdGFydEluZGV4LCBzdG9wSW5kZXgpIHtcbiAgICAgIGlmIChQYXJzZXJBVE5TaW11bGF0b3IzLmRlYnVnIHx8IFBhcnNlckFUTlNpbXVsYXRvcjMucmV0cnlfZGVidWcpIHtcbiAgICAgICAgbGV0IGludGVydmFsID0gSW50ZXJ2YWxfMS5JbnRlcnZhbC5vZihzdGFydEluZGV4LCBzdG9wSW5kZXgpO1xuICAgICAgICBjb25zb2xlLmxvZyhcInJlcG9ydENvbnRleHRTZW5zaXRpdml0eSBkZWNpc2lvbj1cIiArIGRmYS5kZWNpc2lvbiArIFwiOlwiICsgYWNjZXB0U3RhdGUuczAuY29uZmlncyArIFwiLCBpbnB1dD1cIiArIHRoaXMuX3BhcnNlci5pbnB1dFN0cmVhbS5nZXRUZXh0KGludGVydmFsKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcGFyc2VyICE9IG51bGwpIHtcbiAgICAgICAgbGV0IGxpc3RlbmVyID0gdGhpcy5fcGFyc2VyLmdldEVycm9yTGlzdGVuZXJEaXNwYXRjaCgpO1xuICAgICAgICBpZiAobGlzdGVuZXIucmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5KSB7XG4gICAgICAgICAgbGlzdGVuZXIucmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5KHRoaXMuX3BhcnNlciwgZGZhLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIHByZWRpY3Rpb24sIGFjY2VwdFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXBvcnRBbWJpZ3VpdHkoZGZhLCBELCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIGV4YWN0LCBhbWJpZ0FsdHMsIGNvbmZpZ3MpIHtcbiAgICAgIGlmIChQYXJzZXJBVE5TaW11bGF0b3IzLmRlYnVnIHx8IFBhcnNlckFUTlNpbXVsYXRvcjMucmV0cnlfZGVidWcpIHtcbiAgICAgICAgbGV0IGludGVydmFsID0gSW50ZXJ2YWxfMS5JbnRlcnZhbC5vZihzdGFydEluZGV4LCBzdG9wSW5kZXgpO1xuICAgICAgICBjb25zb2xlLmxvZyhcInJlcG9ydEFtYmlndWl0eSBcIiArIGFtYmlnQWx0cyArIFwiOlwiICsgY29uZmlncyArIFwiLCBpbnB1dD1cIiArIHRoaXMuX3BhcnNlci5pbnB1dFN0cmVhbS5nZXRUZXh0KGludGVydmFsKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcGFyc2VyICE9IG51bGwpIHtcbiAgICAgICAgbGV0IGxpc3RlbmVyID0gdGhpcy5fcGFyc2VyLmdldEVycm9yTGlzdGVuZXJEaXNwYXRjaCgpO1xuICAgICAgICBpZiAobGlzdGVuZXIucmVwb3J0QW1iaWd1aXR5KSB7XG4gICAgICAgICAgbGlzdGVuZXIucmVwb3J0QW1iaWd1aXR5KHRoaXMuX3BhcnNlciwgZGZhLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIGV4YWN0LCBhbWJpZ0FsdHMsIGNvbmZpZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGdldFJldHVyblN0YXRlKGNvbnRleHQpIHtcbiAgICAgIGlmIChjb250ZXh0LmlzRW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIFByZWRpY3Rpb25Db250ZXh0XzEuUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfRlVMTF9TVEFURV9LRVk7XG4gICAgICB9XG4gICAgICBsZXQgc3RhdGUgPSB0aGlzLmF0bi5zdGF0ZXNbY29udGV4dC5pbnZva2luZ1N0YXRlXTtcbiAgICAgIGxldCB0cmFuc2l0aW9uID0gc3RhdGUudHJhbnNpdGlvbigwKTtcbiAgICAgIHJldHVybiB0cmFuc2l0aW9uLmZvbGxvd1N0YXRlLnN0YXRlTnVtYmVyO1xuICAgIH1cbiAgICBza2lwVGFpbENhbGxzKGNvbnRleHQpIHtcbiAgICAgIGlmICghdGhpcy5vcHRpbWl6ZV90YWlsX2NhbGxzKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKCFjb250ZXh0LmlzRW1wdHkpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5hdG4uc3RhdGVzW2NvbnRleHQuaW52b2tpbmdTdGF0ZV07XG4gICAgICAgIGFzc2VydChzdGF0ZS5udW1iZXJPZlRyYW5zaXRpb25zID09PSAxICYmIHN0YXRlLnRyYW5zaXRpb24oMCkuc2VyaWFsaXphdGlvblR5cGUgPT09IDMpO1xuICAgICAgICBsZXQgdHJhbnNpdGlvbiA9IHN0YXRlLnRyYW5zaXRpb24oMCk7XG4gICAgICAgIGlmICghdHJhbnNpdGlvbi50YWlsQ2FsbCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICBnZXQgcGFyc2VyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlcjtcbiAgICB9XG4gIH07XG4gIFBhcnNlckFUTlNpbXVsYXRvcjIuZGVidWcgPSBmYWxzZTtcbiAgUGFyc2VyQVROU2ltdWxhdG9yMi5kZmFfZGVidWcgPSBmYWxzZTtcbiAgUGFyc2VyQVROU2ltdWxhdG9yMi5yZXRyeV9kZWJ1ZyA9IGZhbHNlO1xuICBQYXJzZXJBVE5TaW11bGF0b3IyLlNUQVRFX0FMVF9TT1JUX0NPTVBBUkFUT1IgPSAobzEsIG8yKSA9PiB7XG4gICAgbGV0IGRpZmYgPSBvMS5zdGF0ZS5ub25TdG9wU3RhdGVOdW1iZXIgLSBvMi5zdGF0ZS5ub25TdG9wU3RhdGVOdW1iZXI7XG4gICAgaWYgKGRpZmYgIT09IDApIHtcbiAgICAgIHJldHVybiBkaWZmO1xuICAgIH1cbiAgICBkaWZmID0gbzEuYWx0IC0gbzIuYWx0O1xuICAgIGlmIChkaWZmICE9PSAwKSB7XG4gICAgICByZXR1cm4gZGlmZjtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIFBhcnNlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcInByZWRpY3Rpb25Nb2RlXCIsIHZvaWQgMCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIFBhcnNlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcImdldFByZWRpY3Rpb25Nb2RlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBQYXJzZXJBVE5TaW11bGF0b3IyLnByb3RvdHlwZSwgXCJzZXRQcmVkaWN0aW9uTW9kZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFBhcnNlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcInJlc2V0XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBQYXJzZXJBVE5TaW11bGF0b3IyLnByb3RvdHlwZSwgXCJhZGFwdGl2ZVByZWRpY3RcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMSwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMiwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIFBhcnNlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcImdldFN0YXJ0U3RhdGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMSwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMywgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIFBhcnNlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcImV4ZWNERkFcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMSwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMywgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIFBhcnNlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcImV4ZWNBVE5cIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMiwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIFBhcnNlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcImhhbmRsZU5vVmlhYmxlQWx0XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBQYXJzZXJBVE5TaW11bGF0b3IyLnByb3RvdHlwZSwgXCJnZXRFeGlzdGluZ1RhcmdldFN0YXRlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbCxcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDEsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBQYXJzZXJBVE5TaW11bGF0b3IyLnByb3RvdHlwZSwgXCJjb21wdXRlVGFyZ2V0U3RhdGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsLFxuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIFBhcnNlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcInJlbW92ZUFsbENvbmZpZ3NOb3RJblJ1bGVTdG9wU3RhdGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIFBhcnNlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcImNvbXB1dGVTdGFydFN0YXRlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbCxcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBQYXJzZXJBVE5TaW11bGF0b3IyLnByb3RvdHlwZSwgXCJhcHBseVByZWNlZGVuY2VGaWx0ZXJcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMSwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIFBhcnNlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcImdldFJlYWNoYWJsZVRhcmdldFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgUGFyc2VyQVROU2ltdWxhdG9yMi5wcm90b3R5cGUsIFwiZ2V0UHJlZHNGb3JBbWJpZ0FsdHNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIFBhcnNlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcImV2YWxTZW1hbnRpY0NvbnRleHRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIFBhcnNlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcImV2YWxTZW1hbnRpY0NvbnRleHRJbXBsXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDEsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDQsIERlY29yYXRvcnNfMS5OdWxsYWJsZSlcbiAgXSwgUGFyc2VyQVROU2ltdWxhdG9yMi5wcm90b3R5cGUsIFwiY2xvc3VyZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgyLCBEZWNvcmF0b3JzXzEuTnVsbGFibGUpLFxuICAgIF9fcGFyYW0oMywgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oNiwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIFBhcnNlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcImNsb3N1cmVJbXBsXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBQYXJzZXJBVE5TaW11bGF0b3IyLnByb3RvdHlwZSwgXCJnZXRSdWxlTmFtZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgUGFyc2VyQVROU2ltdWxhdG9yMi5wcm90b3R5cGUsIFwiZ2V0RXBzaWxvblRhcmdldFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGwsXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgUGFyc2VyQVROU2ltdWxhdG9yMi5wcm90b3R5cGUsIFwiYWN0aW9uVHJhbnNpdGlvblwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk51bGxhYmxlLFxuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMSwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIFBhcnNlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcInByZWNlZGVuY2VUcmFuc2l0aW9uXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTnVsbGFibGUsXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgUGFyc2VyQVROU2ltdWxhdG9yMi5wcm90b3R5cGUsIFwicHJlZFRyYW5zaXRpb25cIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsLFxuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMSwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMiwgRGVjb3JhdG9yc18xLk51bGxhYmxlKVxuICBdLCBQYXJzZXJBVE5TaW11bGF0b3IyLnByb3RvdHlwZSwgXCJydWxlVHJhbnNpdGlvblwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgUGFyc2VyQVROU2ltdWxhdG9yMi5wcm90b3R5cGUsIFwiaXNDb25mbGljdGVkXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBQYXJzZXJBVE5TaW11bGF0b3IyLnByb3RvdHlwZSwgXCJnZXRUb2tlbk5hbWVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIFBhcnNlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcImR1bXBEZWFkRW5kQ29uZmlnc1wiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGwsXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgyLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgUGFyc2VyQVROU2ltdWxhdG9yMi5wcm90b3R5cGUsIFwibm9WaWFibGVBbHRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIFBhcnNlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcImdldFVuaXF1ZUFsdFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgUGFyc2VyQVROU2ltdWxhdG9yMi5wcm90b3R5cGUsIFwiY29uZmlnV2l0aEFsdEF0U3RvcFN0YXRlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbCxcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDEsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDQsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBQYXJzZXJBVE5TaW11bGF0b3IyLnByb3RvdHlwZSwgXCJhZGRERkFFZGdlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5OdWxsYWJsZSksXG4gICAgX19wYXJhbSgyLCBEZWNvcmF0b3JzXzEuTnVsbGFibGUpXG4gIF0sIFBhcnNlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcInNldERGQUVkZ2VcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsLFxuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMSwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIFBhcnNlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcImFkZERGQUNvbnRleHRTdGF0ZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGwsXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgUGFyc2VyQVROU2ltdWxhdG9yMi5wcm90b3R5cGUsIFwiYWRkREZBU3RhdGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsLFxuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMSwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIFBhcnNlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcImNyZWF0ZURGQVN0YXRlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDIsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBQYXJzZXJBVE5TaW11bGF0b3IyLnByb3RvdHlwZSwgXCJyZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMiwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIFBhcnNlckFUTlNpbXVsYXRvcjIucHJvdG90eXBlLCBcInJlcG9ydENvbnRleHRTZW5zaXRpdml0eVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSg1LCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSg2LCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgUGFyc2VyQVROU2ltdWxhdG9yMi5wcm90b3R5cGUsIFwicmVwb3J0QW1iaWd1aXR5XCIsIG51bGwpO1xuICBQYXJzZXJBVE5TaW11bGF0b3IyID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgUGFyc2VyQVROU2ltdWxhdG9yMik7XG4gIGV4cG9ydHMuUGFyc2VyQVROU2ltdWxhdG9yID0gUGFyc2VyQVROU2ltdWxhdG9yMjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvYXRuL1BsdXNCbG9ja1N0YXJ0U3RhdGUuanNcbnZhciByZXF1aXJlX1BsdXNCbG9ja1N0YXJ0U3RhdGUgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuUGx1c0Jsb2NrU3RhcnRTdGF0ZSA9IHZvaWQgMDtcbiAgdmFyIEFUTlN0YXRlVHlwZV8xID0gcmVxdWlyZV9BVE5TdGF0ZVR5cGUoKTtcbiAgdmFyIEJsb2NrU3RhcnRTdGF0ZV8xID0gcmVxdWlyZV9CbG9ja1N0YXJ0U3RhdGUoKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgUGx1c0Jsb2NrU3RhcnRTdGF0ZSA9IGNsYXNzIGV4dGVuZHMgQmxvY2tTdGFydFN0YXRlXzEuQmxvY2tTdGFydFN0YXRlIHtcbiAgICBnZXQgc3RhdGVUeXBlKCkge1xuICAgICAgcmV0dXJuIEFUTlN0YXRlVHlwZV8xLkFUTlN0YXRlVHlwZS5QTFVTX0JMT0NLX1NUQVJUO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFBsdXNCbG9ja1N0YXJ0U3RhdGUucHJvdG90eXBlLCBcInN0YXRlVHlwZVwiLCBudWxsKTtcbiAgZXhwb3J0cy5QbHVzQmxvY2tTdGFydFN0YXRlID0gUGx1c0Jsb2NrU3RhcnRTdGF0ZTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvYXRuL1BsdXNMb29wYmFja1N0YXRlLmpzXG52YXIgcmVxdWlyZV9QbHVzTG9vcGJhY2tTdGF0ZSA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5QbHVzTG9vcGJhY2tTdGF0ZSA9IHZvaWQgMDtcbiAgdmFyIEFUTlN0YXRlVHlwZV8xID0gcmVxdWlyZV9BVE5TdGF0ZVR5cGUoKTtcbiAgdmFyIERlY2lzaW9uU3RhdGVfMSA9IHJlcXVpcmVfRGVjaXNpb25TdGF0ZSgpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBQbHVzTG9vcGJhY2tTdGF0ZSA9IGNsYXNzIGV4dGVuZHMgRGVjaXNpb25TdGF0ZV8xLkRlY2lzaW9uU3RhdGUge1xuICAgIGdldCBzdGF0ZVR5cGUoKSB7XG4gICAgICByZXR1cm4gQVROU3RhdGVUeXBlXzEuQVROU3RhdGVUeXBlLlBMVVNfTE9PUF9CQUNLO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFBsdXNMb29wYmFja1N0YXRlLnByb3RvdHlwZSwgXCJzdGF0ZVR5cGVcIiwgbnVsbCk7XG4gIGV4cG9ydHMuUGx1c0xvb3BiYWNrU3RhdGUgPSBQbHVzTG9vcGJhY2tTdGF0ZTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvYXRuL1ByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uLmpzXG52YXIgcmVxdWlyZV9QcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbiA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgdmFyIF9fcGFyYW0gPSBleHBvcnRzICYmIGV4cG9ydHMuX19wYXJhbSB8fCBmdW5jdGlvbihwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7XG4gICAgfTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5QcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbiA9IHZvaWQgMDtcbiAgdmFyIEFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbl8xID0gcmVxdWlyZV9BYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb24oKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgU2VtYW50aWNDb250ZXh0XzEgPSByZXF1aXJlX1NlbWFudGljQ29udGV4dCgpO1xuICB2YXIgUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb24gPSBjbGFzcyBQcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbiBleHRlbmRzIEFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbl8xLkFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbiB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBwcmVjZWRlbmNlKSB7XG4gICAgICBzdXBlcih0YXJnZXQpO1xuICAgICAgdGhpcy5wcmVjZWRlbmNlID0gcHJlY2VkZW5jZTtcbiAgICB9XG4gICAgZ2V0IHNlcmlhbGl6YXRpb25UeXBlKCkge1xuICAgICAgcmV0dXJuIDEwO1xuICAgIH1cbiAgICBnZXQgaXNFcHNpbG9uKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG1hdGNoZXMoc3ltYm9sLCBtaW5Wb2NhYlN5bWJvbCwgbWF4Vm9jYWJTeW1ib2wpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHByZWRpY2F0ZSgpIHtcbiAgICAgIHJldHVybiBuZXcgU2VtYW50aWNDb250ZXh0XzEuU2VtYW50aWNDb250ZXh0LlByZWNlZGVuY2VQcmVkaWNhdGUodGhpcy5wcmVjZWRlbmNlKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVjZWRlbmNlICsgXCIgPj0gX3BcIjtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBQcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbi5wcm90b3R5cGUsIFwic2VyaWFsaXphdGlvblR5cGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBQcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbi5wcm90b3R5cGUsIFwiaXNFcHNpbG9uXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb24ucHJvdG90eXBlLCBcIm1hdGNoZXNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBQcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbi5wcm90b3R5cGUsIFwidG9TdHJpbmdcIiwgbnVsbCk7XG4gIFByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb24pO1xuICBleHBvcnRzLlByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uID0gUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb247XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9SYW5nZVRyYW5zaXRpb24uanNcbnZhciByZXF1aXJlX1JhbmdlVHJhbnNpdGlvbiA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgdmFyIF9fcGFyYW0gPSBleHBvcnRzICYmIGV4cG9ydHMuX19wYXJhbSB8fCBmdW5jdGlvbihwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7XG4gICAgfTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5SYW5nZVRyYW5zaXRpb24gPSB2b2lkIDA7XG4gIHZhciBJbnRlcnZhbFNldF8xID0gcmVxdWlyZV9JbnRlcnZhbFNldCgpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBUcmFuc2l0aW9uXzEgPSByZXF1aXJlX1RyYW5zaXRpb24oKTtcbiAgdmFyIFJhbmdlVHJhbnNpdGlvbiA9IGNsYXNzIFJhbmdlVHJhbnNpdGlvbiBleHRlbmRzIFRyYW5zaXRpb25fMS5UcmFuc2l0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGZyb20sIHRvKSB7XG4gICAgICBzdXBlcih0YXJnZXQpO1xuICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgZ2V0IHNlcmlhbGl6YXRpb25UeXBlKCkge1xuICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICAgIGdldCBsYWJlbCgpIHtcbiAgICAgIHJldHVybiBJbnRlcnZhbFNldF8xLkludGVydmFsU2V0Lm9mKHRoaXMuZnJvbSwgdGhpcy50byk7XG4gICAgfVxuICAgIG1hdGNoZXMoc3ltYm9sLCBtaW5Wb2NhYlN5bWJvbCwgbWF4Vm9jYWJTeW1ib2wpIHtcbiAgICAgIHJldHVybiBzeW1ib2wgPj0gdGhpcy5mcm9tICYmIHN5bWJvbCA8PSB0aGlzLnRvO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIidcIiArIFN0cmluZy5mcm9tQ29kZVBvaW50KHRoaXMuZnJvbSkgKyBcIicuLidcIiArIFN0cmluZy5mcm9tQ29kZVBvaW50KHRoaXMudG8pICsgXCInXCI7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgUmFuZ2VUcmFuc2l0aW9uLnByb3RvdHlwZSwgXCJzZXJpYWxpemF0aW9uVHlwZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlLFxuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIFJhbmdlVHJhbnNpdGlvbi5wcm90b3R5cGUsIFwibGFiZWxcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBSYW5nZVRyYW5zaXRpb24ucHJvdG90eXBlLCBcIm1hdGNoZXNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZSxcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBSYW5nZVRyYW5zaXRpb24ucHJvdG90eXBlLCBcInRvU3RyaW5nXCIsIG51bGwpO1xuICBSYW5nZVRyYW5zaXRpb24gPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBSYW5nZVRyYW5zaXRpb24pO1xuICBleHBvcnRzLlJhbmdlVHJhbnNpdGlvbiA9IFJhbmdlVHJhbnNpdGlvbjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvYXRuL1J1bGVTdGFydFN0YXRlLmpzXG52YXIgcmVxdWlyZV9SdWxlU3RhcnRTdGF0ZSA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5SdWxlU3RhcnRTdGF0ZSA9IHZvaWQgMDtcbiAgdmFyIEFUTlN0YXRlXzEgPSByZXF1aXJlX0FUTlN0YXRlKCk7XG4gIHZhciBBVE5TdGF0ZVR5cGVfMSA9IHJlcXVpcmVfQVROU3RhdGVUeXBlKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIFJ1bGVTdGFydFN0YXRlID0gY2xhc3MgZXh0ZW5kcyBBVE5TdGF0ZV8xLkFUTlN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICB0aGlzLmlzUHJlY2VkZW5jZVJ1bGUgPSBmYWxzZTtcbiAgICAgIHRoaXMubGVmdEZhY3RvcmVkID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBzdGF0ZVR5cGUoKSB7XG4gICAgICByZXR1cm4gQVROU3RhdGVUeXBlXzEuQVROU3RhdGVUeXBlLlJVTEVfU1RBUlQ7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgUnVsZVN0YXJ0U3RhdGUucHJvdG90eXBlLCBcInN0YXRlVHlwZVwiLCBudWxsKTtcbiAgZXhwb3J0cy5SdWxlU3RhcnRTdGF0ZSA9IFJ1bGVTdGFydFN0YXRlO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9hdG4vU3RhckJsb2NrU3RhcnRTdGF0ZS5qc1xudmFyIHJlcXVpcmVfU3RhckJsb2NrU3RhcnRTdGF0ZSA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5TdGFyQmxvY2tTdGFydFN0YXRlID0gdm9pZCAwO1xuICB2YXIgQVROU3RhdGVUeXBlXzEgPSByZXF1aXJlX0FUTlN0YXRlVHlwZSgpO1xuICB2YXIgQmxvY2tTdGFydFN0YXRlXzEgPSByZXF1aXJlX0Jsb2NrU3RhcnRTdGF0ZSgpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBTdGFyQmxvY2tTdGFydFN0YXRlID0gY2xhc3MgZXh0ZW5kcyBCbG9ja1N0YXJ0U3RhdGVfMS5CbG9ja1N0YXJ0U3RhdGUge1xuICAgIGdldCBzdGF0ZVR5cGUoKSB7XG4gICAgICByZXR1cm4gQVROU3RhdGVUeXBlXzEuQVROU3RhdGVUeXBlLlNUQVJfQkxPQ0tfU1RBUlQ7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgU3RhckJsb2NrU3RhcnRTdGF0ZS5wcm90b3R5cGUsIFwic3RhdGVUeXBlXCIsIG51bGwpO1xuICBleHBvcnRzLlN0YXJCbG9ja1N0YXJ0U3RhdGUgPSBTdGFyQmxvY2tTdGFydFN0YXRlO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9hdG4vU3Rhckxvb3BiYWNrU3RhdGUuanNcbnZhciByZXF1aXJlX1N0YXJMb29wYmFja1N0YXRlID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLlN0YXJMb29wYmFja1N0YXRlID0gdm9pZCAwO1xuICB2YXIgQVROU3RhdGVfMSA9IHJlcXVpcmVfQVROU3RhdGUoKTtcbiAgdmFyIEFUTlN0YXRlVHlwZV8xID0gcmVxdWlyZV9BVE5TdGF0ZVR5cGUoKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgU3Rhckxvb3BiYWNrU3RhdGUgPSBjbGFzcyBleHRlbmRzIEFUTlN0YXRlXzEuQVROU3RhdGUge1xuICAgIGdldCBsb29wRW50cnlTdGF0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb24oMCkudGFyZ2V0O1xuICAgIH1cbiAgICBnZXQgc3RhdGVUeXBlKCkge1xuICAgICAgcmV0dXJuIEFUTlN0YXRlVHlwZV8xLkFUTlN0YXRlVHlwZS5TVEFSX0xPT1BfQkFDSztcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBTdGFyTG9vcGJhY2tTdGF0ZS5wcm90b3R5cGUsIFwic3RhdGVUeXBlXCIsIG51bGwpO1xuICBleHBvcnRzLlN0YXJMb29wYmFja1N0YXRlID0gU3Rhckxvb3BiYWNrU3RhdGU7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9Ub2tlbnNTdGFydFN0YXRlLmpzXG52YXIgcmVxdWlyZV9Ub2tlbnNTdGFydFN0YXRlID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLlRva2Vuc1N0YXJ0U3RhdGUgPSB2b2lkIDA7XG4gIHZhciBBVE5TdGF0ZVR5cGVfMSA9IHJlcXVpcmVfQVROU3RhdGVUeXBlKCk7XG4gIHZhciBEZWNpc2lvblN0YXRlXzEgPSByZXF1aXJlX0RlY2lzaW9uU3RhdGUoKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgVG9rZW5zU3RhcnRTdGF0ZSA9IGNsYXNzIGV4dGVuZHMgRGVjaXNpb25TdGF0ZV8xLkRlY2lzaW9uU3RhdGUge1xuICAgIGdldCBzdGF0ZVR5cGUoKSB7XG4gICAgICByZXR1cm4gQVROU3RhdGVUeXBlXzEuQVROU3RhdGVUeXBlLlRPS0VOX1NUQVJUO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFRva2Vuc1N0YXJ0U3RhdGUucHJvdG90eXBlLCBcInN0YXRlVHlwZVwiLCBudWxsKTtcbiAgZXhwb3J0cy5Ub2tlbnNTdGFydFN0YXRlID0gVG9rZW5zU3RhcnRTdGF0ZTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvbWlzYy9VVUlELmpzXG52YXIgcmVxdWlyZV9VVUlEID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5VVUlEID0gdm9pZCAwO1xuICB2YXIgTXVybXVySGFzaF8xID0gcmVxdWlyZV9NdXJtdXJIYXNoKCk7XG4gIHZhciBVVUlEID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKG1vc3RTaWdCaXRzLCBtb3JlU2lnQml0cywgbGVzc1NpZ0JpdHMsIGxlYXN0U2lnQml0cykge1xuICAgICAgdGhpcy5kYXRhID0gbmV3IFVpbnQzMkFycmF5KDQpO1xuICAgICAgdGhpcy5kYXRhWzBdID0gbW9zdFNpZ0JpdHM7XG4gICAgICB0aGlzLmRhdGFbMV0gPSBtb3JlU2lnQml0cztcbiAgICAgIHRoaXMuZGF0YVsyXSA9IGxlc3NTaWdCaXRzO1xuICAgICAgdGhpcy5kYXRhWzNdID0gbGVhc3RTaWdCaXRzO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhkYXRhKSB7XG4gICAgICBpZiAoIS9eW2EtZkEtRjAtOV17OH0tW2EtZkEtRjAtOV17NH0tW2EtZkEtRjAtOV17NH0tW2EtZkEtRjAtOV17NH0tW2EtZkEtRjAtOV17MTJ9JC8udGVzdChkYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvcnJlY3RseSBmb3JtYXR0ZWQgVVVJRFwiKTtcbiAgICAgIH1cbiAgICAgIGxldCBzZWdtZW50cyA9IGRhdGEuc3BsaXQoXCItXCIpO1xuICAgICAgbGV0IG1vc3RTaWdCaXRzID0gcGFyc2VJbnQoc2VnbWVudHNbMF0sIDE2KTtcbiAgICAgIGxldCBtb3JlU2lnQml0cyA9IChwYXJzZUludChzZWdtZW50c1sxXSwgMTYpIDw8IDE2ID4+PiAwKSArIHBhcnNlSW50KHNlZ21lbnRzWzJdLCAxNik7XG4gICAgICBsZXQgbGVzc1NpZ0JpdHMgPSAocGFyc2VJbnQoc2VnbWVudHNbM10sIDE2KSA8PCAxNiA+Pj4gMCkgKyBwYXJzZUludChzZWdtZW50c1s0XS5zdWJzdHIoMCwgNCksIDE2KTtcbiAgICAgIGxldCBsZWFzdFNpZ0JpdHMgPSBwYXJzZUludChzZWdtZW50c1s0XS5zdWJzdHIoLTgpLCAxNik7XG4gICAgICByZXR1cm4gbmV3IFVVSUQobW9zdFNpZ0JpdHMsIG1vcmVTaWdCaXRzLCBsZXNzU2lnQml0cywgbGVhc3RTaWdCaXRzKTtcbiAgICB9XG4gICAgaGFzaENvZGUoKSB7XG4gICAgICByZXR1cm4gTXVybXVySGFzaF8xLk11cm11ckhhc2guaGFzaENvZGUoW3RoaXMuZGF0YVswXSwgdGhpcy5kYXRhWzFdLCB0aGlzLmRhdGFbMl0sIHRoaXMuZGF0YVszXV0pO1xuICAgIH1cbiAgICBlcXVhbHMob2JqKSB7XG4gICAgICBpZiAob2JqID09PSB0aGlzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmICghKG9iaiBpbnN0YW5jZW9mIFVVSUQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmRhdGFbMF0gPT09IG9iai5kYXRhWzBdICYmIHRoaXMuZGF0YVsxXSA9PT0gb2JqLmRhdGFbMV0gJiYgdGhpcy5kYXRhWzJdID09PSBvYmouZGF0YVsyXSAmJiB0aGlzLmRhdGFbM10gPT09IG9iai5kYXRhWzNdO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAoXCIwMDAwMDAwMFwiICsgdGhpcy5kYXRhWzBdLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC04KSArIFwiLVwiICsgKFwiMDAwMFwiICsgKHRoaXMuZGF0YVsxXSA+Pj4gMTYpLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC00KSArIFwiLVwiICsgKFwiMDAwMFwiICsgdGhpcy5kYXRhWzFdLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC00KSArIFwiLVwiICsgKFwiMDAwMFwiICsgKHRoaXMuZGF0YVsyXSA+Pj4gMTYpLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC00KSArIFwiLVwiICsgKFwiMDAwMFwiICsgdGhpcy5kYXRhWzJdLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC00KSArIChcIjAwMDAwMDAwXCIgKyB0aGlzLmRhdGFbM10udG9TdHJpbmcoMTYpKS5zdWJzdHIoLTgpO1xuICAgIH1cbiAgfTtcbiAgZXhwb3J0cy5VVUlEID0gVVVJRDtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvYXRuL0FUTkRlc2VyaWFsaXplci5qc1xudmFyIHJlcXVpcmVfQVRORGVzZXJpYWxpemVyID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkFUTkRlc2VyaWFsaXplciA9IHZvaWQgMDtcbiAgdmFyIEFjdGlvblRyYW5zaXRpb25fMSA9IHJlcXVpcmVfQWN0aW9uVHJhbnNpdGlvbigpO1xuICB2YXIgQXJyYXkyREhhc2hTZXRfMSA9IHJlcXVpcmVfQXJyYXkyREhhc2hTZXQoKTtcbiAgdmFyIEFUTl8xID0gcmVxdWlyZV9BVE4oKTtcbiAgdmFyIEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnNfMSA9IHJlcXVpcmVfQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucygpO1xuICB2YXIgQVROU3RhdGVUeXBlXzEgPSByZXF1aXJlX0FUTlN0YXRlVHlwZSgpO1xuICB2YXIgQXRvbVRyYW5zaXRpb25fMSA9IHJlcXVpcmVfQXRvbVRyYW5zaXRpb24oKTtcbiAgdmFyIEJhc2ljQmxvY2tTdGFydFN0YXRlXzEgPSByZXF1aXJlX0Jhc2ljQmxvY2tTdGFydFN0YXRlKCk7XG4gIHZhciBCYXNpY1N0YXRlXzEgPSByZXF1aXJlX0Jhc2ljU3RhdGUoKTtcbiAgdmFyIEJpdFNldF8xID0gcmVxdWlyZV9CaXRTZXQoKTtcbiAgdmFyIEJsb2NrRW5kU3RhdGVfMSA9IHJlcXVpcmVfQmxvY2tFbmRTdGF0ZSgpO1xuICB2YXIgQmxvY2tTdGFydFN0YXRlXzEgPSByZXF1aXJlX0Jsb2NrU3RhcnRTdGF0ZSgpO1xuICB2YXIgRGVjaXNpb25TdGF0ZV8xID0gcmVxdWlyZV9EZWNpc2lvblN0YXRlKCk7XG4gIHZhciBERkFfMSA9IHJlcXVpcmVfREZBKCk7XG4gIHZhciBFcHNpbG9uVHJhbnNpdGlvbl8xID0gcmVxdWlyZV9FcHNpbG9uVHJhbnNpdGlvbigpO1xuICB2YXIgSW50ZXJ2YWxTZXRfMSA9IHJlcXVpcmVfSW50ZXJ2YWxTZXQoKTtcbiAgdmFyIEludmFsaWRTdGF0ZV8xID0gcmVxdWlyZV9JbnZhbGlkU3RhdGUoKTtcbiAgdmFyIExleGVyQ2hhbm5lbEFjdGlvbl8xID0gcmVxdWlyZV9MZXhlckNoYW5uZWxBY3Rpb24oKTtcbiAgdmFyIExleGVyQ3VzdG9tQWN0aW9uXzEgPSByZXF1aXJlX0xleGVyQ3VzdG9tQWN0aW9uKCk7XG4gIHZhciBMZXhlck1vZGVBY3Rpb25fMSA9IHJlcXVpcmVfTGV4ZXJNb2RlQWN0aW9uKCk7XG4gIHZhciBMZXhlck1vcmVBY3Rpb25fMSA9IHJlcXVpcmVfTGV4ZXJNb3JlQWN0aW9uKCk7XG4gIHZhciBMZXhlclBvcE1vZGVBY3Rpb25fMSA9IHJlcXVpcmVfTGV4ZXJQb3BNb2RlQWN0aW9uKCk7XG4gIHZhciBMZXhlclB1c2hNb2RlQWN0aW9uXzEgPSByZXF1aXJlX0xleGVyUHVzaE1vZGVBY3Rpb24oKTtcbiAgdmFyIExleGVyU2tpcEFjdGlvbl8xID0gcmVxdWlyZV9MZXhlclNraXBBY3Rpb24oKTtcbiAgdmFyIExleGVyVHlwZUFjdGlvbl8xID0gcmVxdWlyZV9MZXhlclR5cGVBY3Rpb24oKTtcbiAgdmFyIExvb3BFbmRTdGF0ZV8xID0gcmVxdWlyZV9Mb29wRW5kU3RhdGUoKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgTm90U2V0VHJhbnNpdGlvbl8xID0gcmVxdWlyZV9Ob3RTZXRUcmFuc2l0aW9uKCk7XG4gIHZhciBQYXJzZXJBVE5TaW11bGF0b3JfMSA9IHJlcXVpcmVfUGFyc2VyQVROU2ltdWxhdG9yKCk7XG4gIHZhciBQbHVzQmxvY2tTdGFydFN0YXRlXzEgPSByZXF1aXJlX1BsdXNCbG9ja1N0YXJ0U3RhdGUoKTtcbiAgdmFyIFBsdXNMb29wYmFja1N0YXRlXzEgPSByZXF1aXJlX1BsdXNMb29wYmFja1N0YXRlKCk7XG4gIHZhciBQcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbl8xID0gcmVxdWlyZV9QcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbigpO1xuICB2YXIgUHJlZGljYXRlVHJhbnNpdGlvbl8xID0gcmVxdWlyZV9QcmVkaWNhdGVUcmFuc2l0aW9uKCk7XG4gIHZhciBSYW5nZVRyYW5zaXRpb25fMSA9IHJlcXVpcmVfUmFuZ2VUcmFuc2l0aW9uKCk7XG4gIHZhciBSdWxlU3RhcnRTdGF0ZV8xID0gcmVxdWlyZV9SdWxlU3RhcnRTdGF0ZSgpO1xuICB2YXIgUnVsZVN0b3BTdGF0ZV8xID0gcmVxdWlyZV9SdWxlU3RvcFN0YXRlKCk7XG4gIHZhciBSdWxlVHJhbnNpdGlvbl8xID0gcmVxdWlyZV9SdWxlVHJhbnNpdGlvbigpO1xuICB2YXIgU2V0VHJhbnNpdGlvbl8xID0gcmVxdWlyZV9TZXRUcmFuc2l0aW9uKCk7XG4gIHZhciBTdGFyQmxvY2tTdGFydFN0YXRlXzEgPSByZXF1aXJlX1N0YXJCbG9ja1N0YXJ0U3RhdGUoKTtcbiAgdmFyIFN0YXJMb29wYmFja1N0YXRlXzEgPSByZXF1aXJlX1N0YXJMb29wYmFja1N0YXRlKCk7XG4gIHZhciBTdGFyTG9vcEVudHJ5U3RhdGVfMSA9IHJlcXVpcmVfU3Rhckxvb3BFbnRyeVN0YXRlKCk7XG4gIHZhciBUb2tlbl8xID0gcmVxdWlyZV9Ub2tlbigpO1xuICB2YXIgVG9rZW5zU3RhcnRTdGF0ZV8xID0gcmVxdWlyZV9Ub2tlbnNTdGFydFN0YXRlKCk7XG4gIHZhciBVVUlEXzEgPSByZXF1aXJlX1VVSUQoKTtcbiAgdmFyIFdpbGRjYXJkVHJhbnNpdGlvbl8xID0gcmVxdWlyZV9XaWxkY2FyZFRyYW5zaXRpb24oKTtcbiAgdmFyIFVuaWNvZGVEZXNlcmlhbGl6aW5nTW9kZTtcbiAgKGZ1bmN0aW9uKFVuaWNvZGVEZXNlcmlhbGl6aW5nTW9kZTIpIHtcbiAgICBVbmljb2RlRGVzZXJpYWxpemluZ01vZGUyW1VuaWNvZGVEZXNlcmlhbGl6aW5nTW9kZTJbXCJVTklDT0RFX0JNUFwiXSA9IDBdID0gXCJVTklDT0RFX0JNUFwiO1xuICAgIFVuaWNvZGVEZXNlcmlhbGl6aW5nTW9kZTJbVW5pY29kZURlc2VyaWFsaXppbmdNb2RlMltcIlVOSUNPREVfU01QXCJdID0gMV0gPSBcIlVOSUNPREVfU01QXCI7XG4gIH0pKFVuaWNvZGVEZXNlcmlhbGl6aW5nTW9kZSB8fCAoVW5pY29kZURlc2VyaWFsaXppbmdNb2RlID0ge30pKTtcbiAgdmFyIEFUTkRlc2VyaWFsaXplcjMgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoZGVzZXJpYWxpemF0aW9uT3B0aW9ucykge1xuICAgICAgaWYgKGRlc2VyaWFsaXphdGlvbk9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICBkZXNlcmlhbGl6YXRpb25PcHRpb25zID0gQVRORGVzZXJpYWxpemF0aW9uT3B0aW9uc18xLkFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMuZGVmYXVsdE9wdGlvbnM7XG4gICAgICB9XG4gICAgICB0aGlzLmRlc2VyaWFsaXphdGlvbk9wdGlvbnMgPSBkZXNlcmlhbGl6YXRpb25PcHRpb25zO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IFNFUklBTElaRURfVkVSU0lPTigpIHtcbiAgICAgIHJldHVybiAzO1xuICAgIH1cbiAgICBzdGF0aWMgaXNGZWF0dXJlU3VwcG9ydGVkKGZlYXR1cmUsIGFjdHVhbFV1aWQpIHtcbiAgICAgIGxldCBmZWF0dXJlSW5kZXggPSBBVE5EZXNlcmlhbGl6ZXIzLlNVUFBPUlRFRF9VVUlEUy5maW5kSW5kZXgoKGUpID0+IGUuZXF1YWxzKGZlYXR1cmUpKTtcbiAgICAgIGlmIChmZWF0dXJlSW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBVE5EZXNlcmlhbGl6ZXIzLlNVUFBPUlRFRF9VVUlEUy5maW5kSW5kZXgoKGUpID0+IGUuZXF1YWxzKGFjdHVhbFV1aWQpKSA+PSBmZWF0dXJlSW5kZXg7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRVbmljb2RlRGVzZXJpYWxpemVyKG1vZGUpIHtcbiAgICAgIGlmIChtb2RlID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVhZFVuaWNvZGU6IChkYXRhLCBwKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gQVRORGVzZXJpYWxpemVyMy50b0ludChkYXRhW3BdKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNpemU6IDFcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVhZFVuaWNvZGU6IChkYXRhLCBwKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gQVRORGVzZXJpYWxpemVyMy50b0ludDMyKGRhdGEsIHApO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2l6ZTogMlxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBkZXNlcmlhbGl6ZShkYXRhKSB7XG4gICAgICBkYXRhID0gZGF0YS5zbGljZSgwKTtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhW2ldID0gZGF0YVtpXSAtIDIgJiA2NTUzNTtcbiAgICAgIH1cbiAgICAgIGxldCBwID0gMDtcbiAgICAgIGxldCB2ZXJzaW9uID0gQVRORGVzZXJpYWxpemVyMy50b0ludChkYXRhW3ArK10pO1xuICAgICAgaWYgKHZlcnNpb24gIT09IEFUTkRlc2VyaWFsaXplcjMuU0VSSUFMSVpFRF9WRVJTSU9OKSB7XG4gICAgICAgIGxldCByZWFzb24gPSBgQ291bGQgbm90IGRlc2VyaWFsaXplIEFUTiB3aXRoIHZlcnNpb24gJHt2ZXJzaW9ufSAoZXhwZWN0ZWQgJHtBVE5EZXNlcmlhbGl6ZXIzLlNFUklBTElaRURfVkVSU0lPTn0pLmA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgfVxuICAgICAgbGV0IHV1aWQgPSBBVE5EZXNlcmlhbGl6ZXIzLnRvVVVJRChkYXRhLCBwKTtcbiAgICAgIHAgKz0gODtcbiAgICAgIGlmIChBVE5EZXNlcmlhbGl6ZXIzLlNVUFBPUlRFRF9VVUlEUy5maW5kSW5kZXgoKGUpID0+IGUuZXF1YWxzKHV1aWQpKSA8IDApIHtcbiAgICAgICAgbGV0IHJlYXNvbiA9IGBDb3VsZCBub3QgZGVzZXJpYWxpemUgQVROIHdpdGggVVVJRCAke3V1aWR9IChleHBlY3RlZCAke0FUTkRlc2VyaWFsaXplcjMuU0VSSUFMSVpFRF9VVUlEfSBvciBhIGxlZ2FjeSBVVUlEKS5gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhc29uKTtcbiAgICAgIH1cbiAgICAgIGxldCBzdXBwb3J0c0xleGVyQWN0aW9ucyA9IEFUTkRlc2VyaWFsaXplcjMuaXNGZWF0dXJlU3VwcG9ydGVkKEFUTkRlc2VyaWFsaXplcjMuQURERURfTEVYRVJfQUNUSU9OUywgdXVpZCk7XG4gICAgICBsZXQgZ3JhbW1hclR5cGUgPSBBVE5EZXNlcmlhbGl6ZXIzLnRvSW50KGRhdGFbcCsrXSk7XG4gICAgICBsZXQgbWF4VG9rZW5UeXBlID0gQVRORGVzZXJpYWxpemVyMy50b0ludChkYXRhW3ArK10pO1xuICAgICAgbGV0IGF0biA9IG5ldyBBVE5fMS5BVE4oZ3JhbW1hclR5cGUsIG1heFRva2VuVHlwZSk7XG4gICAgICBsZXQgbG9vcEJhY2tTdGF0ZU51bWJlcnMgPSBbXTtcbiAgICAgIGxldCBlbmRTdGF0ZU51bWJlcnMgPSBbXTtcbiAgICAgIGxldCBuc3RhdGVzID0gQVRORGVzZXJpYWxpemVyMy50b0ludChkYXRhW3ArK10pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuc3RhdGVzOyBpKyspIHtcbiAgICAgICAgbGV0IHN0eXBlID0gQVRORGVzZXJpYWxpemVyMy50b0ludChkYXRhW3ArK10pO1xuICAgICAgICBpZiAoc3R5cGUgPT09IEFUTlN0YXRlVHlwZV8xLkFUTlN0YXRlVHlwZS5JTlZBTElEX1RZUEUpIHtcbiAgICAgICAgICBhdG4uYWRkU3RhdGUobmV3IEludmFsaWRTdGF0ZV8xLkludmFsaWRTdGF0ZSgpKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcnVsZUluZGV4ID0gQVRORGVzZXJpYWxpemVyMy50b0ludChkYXRhW3ArK10pO1xuICAgICAgICBpZiAocnVsZUluZGV4ID09PSA2NTUzNSkge1xuICAgICAgICAgIHJ1bGVJbmRleCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzID0gdGhpcy5zdGF0ZUZhY3Rvcnkoc3R5cGUsIHJ1bGVJbmRleCk7XG4gICAgICAgIGlmIChzdHlwZSA9PT0gQVROU3RhdGVUeXBlXzEuQVROU3RhdGVUeXBlLkxPT1BfRU5EKSB7XG4gICAgICAgICAgbGV0IGxvb3BCYWNrU3RhdGVOdW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIzLnRvSW50KGRhdGFbcCsrXSk7XG4gICAgICAgICAgbG9vcEJhY2tTdGF0ZU51bWJlcnMucHVzaChbcywgbG9vcEJhY2tTdGF0ZU51bWJlcl0pO1xuICAgICAgICB9IGVsc2UgaWYgKHMgaW5zdGFuY2VvZiBCbG9ja1N0YXJ0U3RhdGVfMS5CbG9ja1N0YXJ0U3RhdGUpIHtcbiAgICAgICAgICBsZXQgZW5kU3RhdGVOdW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIzLnRvSW50KGRhdGFbcCsrXSk7XG4gICAgICAgICAgZW5kU3RhdGVOdW1iZXJzLnB1c2goW3MsIGVuZFN0YXRlTnVtYmVyXSk7XG4gICAgICAgIH1cbiAgICAgICAgYXRuLmFkZFN0YXRlKHMpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgcGFpciBvZiBsb29wQmFja1N0YXRlTnVtYmVycykge1xuICAgICAgICBwYWlyWzBdLmxvb3BCYWNrU3RhdGUgPSBhdG4uc3RhdGVzW3BhaXJbMV1dO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgcGFpciBvZiBlbmRTdGF0ZU51bWJlcnMpIHtcbiAgICAgICAgcGFpclswXS5lbmRTdGF0ZSA9IGF0bi5zdGF0ZXNbcGFpclsxXV07XG4gICAgICB9XG4gICAgICBsZXQgbnVtTm9uR3JlZWR5U3RhdGVzID0gQVRORGVzZXJpYWxpemVyMy50b0ludChkYXRhW3ArK10pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Ob25HcmVlZHlTdGF0ZXM7IGkrKykge1xuICAgICAgICBsZXQgc3RhdGVOdW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIzLnRvSW50KGRhdGFbcCsrXSk7XG4gICAgICAgIGF0bi5zdGF0ZXNbc3RhdGVOdW1iZXJdLm5vbkdyZWVkeSA9IHRydWU7XG4gICAgICB9XG4gICAgICBsZXQgbnVtU2xsRGVjaXNpb25zID0gQVRORGVzZXJpYWxpemVyMy50b0ludChkYXRhW3ArK10pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1TbGxEZWNpc2lvbnM7IGkrKykge1xuICAgICAgICBsZXQgc3RhdGVOdW1iZXIgPSBBVE5EZXNlcmlhbGl6ZXIzLnRvSW50KGRhdGFbcCsrXSk7XG4gICAgICAgIGF0bi5zdGF0ZXNbc3RhdGVOdW1iZXJdLnNsbCA9IHRydWU7XG4gICAgICB9XG4gICAgICBsZXQgbnVtUHJlY2VkZW5jZVN0YXRlcyA9IEFUTkRlc2VyaWFsaXplcjMudG9JbnQoZGF0YVtwKytdKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUHJlY2VkZW5jZVN0YXRlczsgaSsrKSB7XG4gICAgICAgIGxldCBzdGF0ZU51bWJlciA9IEFUTkRlc2VyaWFsaXplcjMudG9JbnQoZGF0YVtwKytdKTtcbiAgICAgICAgYXRuLnN0YXRlc1tzdGF0ZU51bWJlcl0uaXNQcmVjZWRlbmNlUnVsZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBsZXQgbnJ1bGVzID0gQVRORGVzZXJpYWxpemVyMy50b0ludChkYXRhW3ArK10pO1xuICAgICAgaWYgKGF0bi5ncmFtbWFyVHlwZSA9PT0gMCkge1xuICAgICAgICBhdG4ucnVsZVRvVG9rZW5UeXBlID0gbmV3IEludDMyQXJyYXkobnJ1bGVzKTtcbiAgICAgIH1cbiAgICAgIGF0bi5ydWxlVG9TdGFydFN0YXRlID0gbmV3IEFycmF5KG5ydWxlcyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ydWxlczsgaSsrKSB7XG4gICAgICAgIGxldCBzID0gQVRORGVzZXJpYWxpemVyMy50b0ludChkYXRhW3ArK10pO1xuICAgICAgICBsZXQgc3RhcnRTdGF0ZSA9IGF0bi5zdGF0ZXNbc107XG4gICAgICAgIHN0YXJ0U3RhdGUubGVmdEZhY3RvcmVkID0gQVRORGVzZXJpYWxpemVyMy50b0ludChkYXRhW3ArK10pICE9PSAwO1xuICAgICAgICBhdG4ucnVsZVRvU3RhcnRTdGF0ZVtpXSA9IHN0YXJ0U3RhdGU7XG4gICAgICAgIGlmIChhdG4uZ3JhbW1hclR5cGUgPT09IDApIHtcbiAgICAgICAgICBsZXQgdG9rZW5UeXBlID0gQVRORGVzZXJpYWxpemVyMy50b0ludChkYXRhW3ArK10pO1xuICAgICAgICAgIGlmICh0b2tlblR5cGUgPT09IDY1NTM1KSB7XG4gICAgICAgICAgICB0b2tlblR5cGUgPSBUb2tlbl8xLlRva2VuLkVPRjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXRuLnJ1bGVUb1Rva2VuVHlwZVtpXSA9IHRva2VuVHlwZTtcbiAgICAgICAgICBpZiAoIUFUTkRlc2VyaWFsaXplcjMuaXNGZWF0dXJlU3VwcG9ydGVkKEFUTkRlc2VyaWFsaXplcjMuQURERURfTEVYRVJfQUNUSU9OUywgdXVpZCkpIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb25JbmRleElnbm9yZWQgPSBBVE5EZXNlcmlhbGl6ZXIzLnRvSW50KGRhdGFbcCsrXSk7XG4gICAgICAgICAgICBpZiAoYWN0aW9uSW5kZXhJZ25vcmVkID09PSA2NTUzNSkge1xuICAgICAgICAgICAgICBhY3Rpb25JbmRleElnbm9yZWQgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGF0bi5ydWxlVG9TdG9wU3RhdGUgPSBuZXcgQXJyYXkobnJ1bGVzKTtcbiAgICAgIGZvciAobGV0IHN0YXRlIG9mIGF0bi5zdGF0ZXMpIHtcbiAgICAgICAgaWYgKCEoc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlXzEuUnVsZVN0b3BTdGF0ZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBhdG4ucnVsZVRvU3RvcFN0YXRlW3N0YXRlLnJ1bGVJbmRleF0gPSBzdGF0ZTtcbiAgICAgICAgYXRuLnJ1bGVUb1N0YXJ0U3RhdGVbc3RhdGUucnVsZUluZGV4XS5zdG9wU3RhdGUgPSBzdGF0ZTtcbiAgICAgIH1cbiAgICAgIGxldCBubW9kZXMgPSBBVE5EZXNlcmlhbGl6ZXIzLnRvSW50KGRhdGFbcCsrXSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5tb2RlczsgaSsrKSB7XG4gICAgICAgIGxldCBzID0gQVRORGVzZXJpYWxpemVyMy50b0ludChkYXRhW3ArK10pO1xuICAgICAgICBhdG4ubW9kZVRvU3RhcnRTdGF0ZS5wdXNoKGF0bi5zdGF0ZXNbc10pO1xuICAgICAgfVxuICAgICAgYXRuLm1vZGVUb0RGQSA9IG5ldyBBcnJheShubW9kZXMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBubW9kZXM7IGkrKykge1xuICAgICAgICBhdG4ubW9kZVRvREZBW2ldID0gbmV3IERGQV8xLkRGQShhdG4ubW9kZVRvU3RhcnRTdGF0ZVtpXSk7XG4gICAgICB9XG4gICAgICBsZXQgc2V0cyA9IFtdO1xuICAgICAgcCA9IHRoaXMuZGVzZXJpYWxpemVTZXRzKGRhdGEsIHAsIHNldHMsIEFUTkRlc2VyaWFsaXplcjMuZ2V0VW5pY29kZURlc2VyaWFsaXplcigwKSk7XG4gICAgICBpZiAoQVRORGVzZXJpYWxpemVyMy5pc0ZlYXR1cmVTdXBwb3J0ZWQoQVRORGVzZXJpYWxpemVyMy5BRERFRF9VTklDT0RFX1NNUCwgdXVpZCkpIHtcbiAgICAgICAgcCA9IHRoaXMuZGVzZXJpYWxpemVTZXRzKGRhdGEsIHAsIHNldHMsIEFUTkRlc2VyaWFsaXplcjMuZ2V0VW5pY29kZURlc2VyaWFsaXplcigxKSk7XG4gICAgICB9XG4gICAgICBsZXQgbmVkZ2VzID0gQVRORGVzZXJpYWxpemVyMy50b0ludChkYXRhW3ArK10pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZWRnZXM7IGkrKykge1xuICAgICAgICBsZXQgc3JjID0gQVRORGVzZXJpYWxpemVyMy50b0ludChkYXRhW3BdKTtcbiAgICAgICAgbGV0IHRyZyA9IEFUTkRlc2VyaWFsaXplcjMudG9JbnQoZGF0YVtwICsgMV0pO1xuICAgICAgICBsZXQgdHR5cGUgPSBBVE5EZXNlcmlhbGl6ZXIzLnRvSW50KGRhdGFbcCArIDJdKTtcbiAgICAgICAgbGV0IGFyZzEgPSBBVE5EZXNlcmlhbGl6ZXIzLnRvSW50KGRhdGFbcCArIDNdKTtcbiAgICAgICAgbGV0IGFyZzIgPSBBVE5EZXNlcmlhbGl6ZXIzLnRvSW50KGRhdGFbcCArIDRdKTtcbiAgICAgICAgbGV0IGFyZzMgPSBBVE5EZXNlcmlhbGl6ZXIzLnRvSW50KGRhdGFbcCArIDVdKTtcbiAgICAgICAgbGV0IHRyYW5zID0gdGhpcy5lZGdlRmFjdG9yeShhdG4sIHR0eXBlLCBzcmMsIHRyZywgYXJnMSwgYXJnMiwgYXJnMywgc2V0cyk7XG4gICAgICAgIGxldCBzcmNTdGF0ZSA9IGF0bi5zdGF0ZXNbc3JjXTtcbiAgICAgICAgc3JjU3RhdGUuYWRkVHJhbnNpdGlvbih0cmFucyk7XG4gICAgICAgIHAgKz0gNjtcbiAgICAgIH1cbiAgICAgIGxldCByZXR1cm5UcmFuc2l0aW9uc1NldCA9IG5ldyBBcnJheTJESGFzaFNldF8xLkFycmF5MkRIYXNoU2V0KHtcbiAgICAgICAgaGFzaENvZGU6IChvKSA9PiBvLnN0b3BTdGF0ZSBeIG8ucmV0dXJuU3RhdGUgXiBvLm91dGVybW9zdFByZWNlZGVuY2VSZXR1cm4sXG4gICAgICAgIGVxdWFsczogKGEsIGIpID0+IHtcbiAgICAgICAgICByZXR1cm4gYS5zdG9wU3RhdGUgPT09IGIuc3RvcFN0YXRlICYmIGEucmV0dXJuU3RhdGUgPT09IGIucmV0dXJuU3RhdGUgJiYgYS5vdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuID09PSBiLm91dGVybW9zdFByZWNlZGVuY2VSZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbGV0IHJldHVyblRyYW5zaXRpb25zID0gW107XG4gICAgICBmb3IgKGxldCBzdGF0ZSBvZiBhdG4uc3RhdGVzKSB7XG4gICAgICAgIGxldCByZXR1cm5pbmdUb0xlZnRGYWN0b3JlZCA9IHN0YXRlLnJ1bGVJbmRleCA+PSAwICYmIGF0bi5ydWxlVG9TdGFydFN0YXRlW3N0YXRlLnJ1bGVJbmRleF0ubGVmdEZhY3RvcmVkO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLm51bWJlck9mVHJhbnNpdGlvbnM7IGkrKykge1xuICAgICAgICAgIGxldCB0ID0gc3RhdGUudHJhbnNpdGlvbihpKTtcbiAgICAgICAgICBpZiAoISh0IGluc3RhbmNlb2YgUnVsZVRyYW5zaXRpb25fMS5SdWxlVHJhbnNpdGlvbikpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcnVsZVRyYW5zaXRpb24gPSB0O1xuICAgICAgICAgIGxldCByZXR1cm5pbmdGcm9tTGVmdEZhY3RvcmVkID0gYXRuLnJ1bGVUb1N0YXJ0U3RhdGVbcnVsZVRyYW5zaXRpb24udGFyZ2V0LnJ1bGVJbmRleF0ubGVmdEZhY3RvcmVkO1xuICAgICAgICAgIGlmICghcmV0dXJuaW5nRnJvbUxlZnRGYWN0b3JlZCAmJiByZXR1cm5pbmdUb0xlZnRGYWN0b3JlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBvdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuID0gLTE7XG4gICAgICAgICAgaWYgKGF0bi5ydWxlVG9TdGFydFN0YXRlW3J1bGVUcmFuc2l0aW9uLnRhcmdldC5ydWxlSW5kZXhdLmlzUHJlY2VkZW5jZVJ1bGUpIHtcbiAgICAgICAgICAgIGlmIChydWxlVHJhbnNpdGlvbi5wcmVjZWRlbmNlID09PSAwKSB7XG4gICAgICAgICAgICAgIG91dGVybW9zdFByZWNlZGVuY2VSZXR1cm4gPSBydWxlVHJhbnNpdGlvbi50YXJnZXQucnVsZUluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgY3VycmVudCA9IHtzdG9wU3RhdGU6IHJ1bGVUcmFuc2l0aW9uLnRhcmdldC5ydWxlSW5kZXgsIHJldHVyblN0YXRlOiBydWxlVHJhbnNpdGlvbi5mb2xsb3dTdGF0ZS5zdGF0ZU51bWJlciwgb3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybn07XG4gICAgICAgICAgaWYgKHJldHVyblRyYW5zaXRpb25zU2V0LmFkZChjdXJyZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuVHJhbnNpdGlvbnMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHJldHVyblRyYW5zaXRpb24gb2YgcmV0dXJuVHJhbnNpdGlvbnMpIHtcbiAgICAgICAgbGV0IHRyYW5zaXRpb24gPSBuZXcgRXBzaWxvblRyYW5zaXRpb25fMS5FcHNpbG9uVHJhbnNpdGlvbihhdG4uc3RhdGVzW3JldHVyblRyYW5zaXRpb24ucmV0dXJuU3RhdGVdLCByZXR1cm5UcmFuc2l0aW9uLm91dGVybW9zdFByZWNlZGVuY2VSZXR1cm4pO1xuICAgICAgICBhdG4ucnVsZVRvU3RvcFN0YXRlW3JldHVyblRyYW5zaXRpb24uc3RvcFN0YXRlXS5hZGRUcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgc3RhdGUgb2YgYXRuLnN0YXRlcykge1xuICAgICAgICBpZiAoc3RhdGUgaW5zdGFuY2VvZiBCbG9ja1N0YXJ0U3RhdGVfMS5CbG9ja1N0YXJ0U3RhdGUpIHtcbiAgICAgICAgICBpZiAoc3RhdGUuZW5kU3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbFN0YXRlRXhjZXB0aW9uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuZW5kU3RhdGUuc3RhcnRTdGF0ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsU3RhdGVFeGNlcHRpb25cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlLmVuZFN0YXRlLnN0YXJ0U3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUgaW5zdGFuY2VvZiBQbHVzTG9vcGJhY2tTdGF0ZV8xLlBsdXNMb29wYmFja1N0YXRlKSB7XG4gICAgICAgICAgbGV0IGxvb3BiYWNrU3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvb3BiYWNrU3RhdGUubnVtYmVyT2ZUcmFuc2l0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gbG9vcGJhY2tTdGF0ZS50cmFuc2l0aW9uKGkpLnRhcmdldDtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBQbHVzQmxvY2tTdGFydFN0YXRlXzEuUGx1c0Jsb2NrU3RhcnRTdGF0ZSkge1xuICAgICAgICAgICAgICB0YXJnZXQubG9vcEJhY2tTdGF0ZSA9IGxvb3BiYWNrU3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlIGluc3RhbmNlb2YgU3Rhckxvb3BiYWNrU3RhdGVfMS5TdGFyTG9vcGJhY2tTdGF0ZSkge1xuICAgICAgICAgIGxldCBsb29wYmFja1N0YXRlID0gc3RhdGU7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb29wYmFja1N0YXRlLm51bWJlck9mVHJhbnNpdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGxvb3BiYWNrU3RhdGUudHJhbnNpdGlvbihpKS50YXJnZXQ7XG4gICAgICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgU3Rhckxvb3BFbnRyeVN0YXRlXzEuU3Rhckxvb3BFbnRyeVN0YXRlKSB7XG4gICAgICAgICAgICAgIHRhcmdldC5sb29wQmFja1N0YXRlID0gbG9vcGJhY2tTdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBuZGVjaXNpb25zID0gQVRORGVzZXJpYWxpemVyMy50b0ludChkYXRhW3ArK10pO1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbmRlY2lzaW9uczsgaSsrKSB7XG4gICAgICAgIGxldCBzID0gQVRORGVzZXJpYWxpemVyMy50b0ludChkYXRhW3ArK10pO1xuICAgICAgICBsZXQgZGVjU3RhdGUgPSBhdG4uc3RhdGVzW3NdO1xuICAgICAgICBhdG4uZGVjaXNpb25Ub1N0YXRlLnB1c2goZGVjU3RhdGUpO1xuICAgICAgICBkZWNTdGF0ZS5kZWNpc2lvbiA9IGkgLSAxO1xuICAgICAgfVxuICAgICAgaWYgKGF0bi5ncmFtbWFyVHlwZSA9PT0gMCkge1xuICAgICAgICBpZiAoc3VwcG9ydHNMZXhlckFjdGlvbnMpIHtcbiAgICAgICAgICBhdG4ubGV4ZXJBY3Rpb25zID0gbmV3IEFycmF5KEFUTkRlc2VyaWFsaXplcjMudG9JbnQoZGF0YVtwKytdKSk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdG4ubGV4ZXJBY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYWN0aW9uVHlwZSA9IEFUTkRlc2VyaWFsaXplcjMudG9JbnQoZGF0YVtwKytdKTtcbiAgICAgICAgICAgIGxldCBkYXRhMSA9IEFUTkRlc2VyaWFsaXplcjMudG9JbnQoZGF0YVtwKytdKTtcbiAgICAgICAgICAgIGlmIChkYXRhMSA9PT0gNjU1MzUpIHtcbiAgICAgICAgICAgICAgZGF0YTEgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkYXRhMiA9IEFUTkRlc2VyaWFsaXplcjMudG9JbnQoZGF0YVtwKytdKTtcbiAgICAgICAgICAgIGlmIChkYXRhMiA9PT0gNjU1MzUpIHtcbiAgICAgICAgICAgICAgZGF0YTIgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsZXhlckFjdGlvbiA9IHRoaXMubGV4ZXJBY3Rpb25GYWN0b3J5KGFjdGlvblR5cGUsIGRhdGExLCBkYXRhMik7XG4gICAgICAgICAgICBhdG4ubGV4ZXJBY3Rpb25zW2ldID0gbGV4ZXJBY3Rpb247XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBsZWdhY3lMZXhlckFjdGlvbnMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBzdGF0ZSBvZiBhdG4uc3RhdGVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLm51bWJlck9mVHJhbnNpdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgICBsZXQgdHJhbnNpdGlvbiA9IHN0YXRlLnRyYW5zaXRpb24oaSk7XG4gICAgICAgICAgICAgIGlmICghKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBBY3Rpb25UcmFuc2l0aW9uXzEuQWN0aW9uVHJhbnNpdGlvbikpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgcnVsZUluZGV4ID0gdHJhbnNpdGlvbi5ydWxlSW5kZXg7XG4gICAgICAgICAgICAgIGxldCBhY3Rpb25JbmRleCA9IHRyYW5zaXRpb24uYWN0aW9uSW5kZXg7XG4gICAgICAgICAgICAgIGxldCBsZXhlckFjdGlvbiA9IG5ldyBMZXhlckN1c3RvbUFjdGlvbl8xLkxleGVyQ3VzdG9tQWN0aW9uKHJ1bGVJbmRleCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICAgICAgICBzdGF0ZS5zZXRUcmFuc2l0aW9uKGksIG5ldyBBY3Rpb25UcmFuc2l0aW9uXzEuQWN0aW9uVHJhbnNpdGlvbih0cmFuc2l0aW9uLnRhcmdldCwgcnVsZUluZGV4LCBsZWdhY3lMZXhlckFjdGlvbnMubGVuZ3RoLCBmYWxzZSkpO1xuICAgICAgICAgICAgICBsZWdhY3lMZXhlckFjdGlvbnMucHVzaChsZXhlckFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0bi5sZXhlckFjdGlvbnMgPSBsZWdhY3lMZXhlckFjdGlvbnM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubWFya1ByZWNlZGVuY2VEZWNpc2lvbnMoYXRuKTtcbiAgICAgIGF0bi5kZWNpc2lvblRvREZBID0gbmV3IEFycmF5KG5kZWNpc2lvbnMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZGVjaXNpb25zOyBpKyspIHtcbiAgICAgICAgYXRuLmRlY2lzaW9uVG9ERkFbaV0gPSBuZXcgREZBXzEuREZBKGF0bi5kZWNpc2lvblRvU3RhdGVbaV0sIGkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGVzZXJpYWxpemF0aW9uT3B0aW9ucy5pc1ZlcmlmeUFUTikge1xuICAgICAgICB0aGlzLnZlcmlmeUFUTihhdG4pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGVzZXJpYWxpemF0aW9uT3B0aW9ucy5pc0dlbmVyYXRlUnVsZUJ5cGFzc1RyYW5zaXRpb25zICYmIGF0bi5ncmFtbWFyVHlwZSA9PT0gMSkge1xuICAgICAgICBhdG4ucnVsZVRvVG9rZW5UeXBlID0gbmV3IEludDMyQXJyYXkoYXRuLnJ1bGVUb1N0YXJ0U3RhdGUubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdG4ucnVsZVRvU3RhcnRTdGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGF0bi5ydWxlVG9Ub2tlblR5cGVbaV0gPSBhdG4ubWF4VG9rZW5UeXBlICsgaSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdG4ucnVsZVRvU3RhcnRTdGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBieXBhc3NTdGFydCA9IG5ldyBCYXNpY0Jsb2NrU3RhcnRTdGF0ZV8xLkJhc2ljQmxvY2tTdGFydFN0YXRlKCk7XG4gICAgICAgICAgYnlwYXNzU3RhcnQucnVsZUluZGV4ID0gaTtcbiAgICAgICAgICBhdG4uYWRkU3RhdGUoYnlwYXNzU3RhcnQpO1xuICAgICAgICAgIGxldCBieXBhc3NTdG9wID0gbmV3IEJsb2NrRW5kU3RhdGVfMS5CbG9ja0VuZFN0YXRlKCk7XG4gICAgICAgICAgYnlwYXNzU3RvcC5ydWxlSW5kZXggPSBpO1xuICAgICAgICAgIGF0bi5hZGRTdGF0ZShieXBhc3NTdG9wKTtcbiAgICAgICAgICBieXBhc3NTdGFydC5lbmRTdGF0ZSA9IGJ5cGFzc1N0b3A7XG4gICAgICAgICAgYXRuLmRlZmluZURlY2lzaW9uU3RhdGUoYnlwYXNzU3RhcnQpO1xuICAgICAgICAgIGJ5cGFzc1N0b3Auc3RhcnRTdGF0ZSA9IGJ5cGFzc1N0YXJ0O1xuICAgICAgICAgIGxldCBlbmRTdGF0ZTtcbiAgICAgICAgICBsZXQgZXhjbHVkZVRyYW5zaXRpb247XG4gICAgICAgICAgaWYgKGF0bi5ydWxlVG9TdGFydFN0YXRlW2ldLmlzUHJlY2VkZW5jZVJ1bGUpIHtcbiAgICAgICAgICAgIGVuZFN0YXRlID0gdm9pZCAwO1xuICAgICAgICAgICAgZm9yIChsZXQgc3RhdGUgb2YgYXRuLnN0YXRlcykge1xuICAgICAgICAgICAgICBpZiAoc3RhdGUucnVsZUluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCEoc3RhdGUgaW5zdGFuY2VvZiBTdGFyTG9vcEVudHJ5U3RhdGVfMS5TdGFyTG9vcEVudHJ5U3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IG1heWJlTG9vcEVuZFN0YXRlID0gc3RhdGUudHJhbnNpdGlvbihzdGF0ZS5udW1iZXJPZlRyYW5zaXRpb25zIC0gMSkudGFyZ2V0O1xuICAgICAgICAgICAgICBpZiAoIShtYXliZUxvb3BFbmRTdGF0ZSBpbnN0YW5jZW9mIExvb3BFbmRTdGF0ZV8xLkxvb3BFbmRTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobWF5YmVMb29wRW5kU3RhdGUuZXBzaWxvbk9ubHlUcmFuc2l0aW9ucyAmJiBtYXliZUxvb3BFbmRTdGF0ZS50cmFuc2l0aW9uKDApLnRhcmdldCBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGVfMS5SdWxlU3RvcFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgZW5kU3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFlbmRTdGF0ZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBpZGVudGlmeSBmaW5hbCBzdGF0ZSBvZiB0aGUgcHJlY2VkZW5jZSBydWxlIHByZWZpeCBzZWN0aW9uLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4Y2x1ZGVUcmFuc2l0aW9uID0gZW5kU3RhdGUubG9vcEJhY2tTdGF0ZS50cmFuc2l0aW9uKDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmRTdGF0ZSA9IGF0bi5ydWxlVG9TdG9wU3RhdGVbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IHN0YXRlIG9mIGF0bi5zdGF0ZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBzdGF0ZS5udW1iZXJPZlRyYW5zaXRpb25zOyBpMisrKSB7XG4gICAgICAgICAgICAgIGxldCB0cmFuc2l0aW9uID0gc3RhdGUudHJhbnNpdGlvbihpMik7XG4gICAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uID09PSBleGNsdWRlVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uLnRhcmdldCA9PT0gZW5kU3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLnRhcmdldCA9IGJ5cGFzc1N0b3A7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKGF0bi5ydWxlVG9TdGFydFN0YXRlW2ldLm51bWJlck9mVHJhbnNpdGlvbnMgPiAwKSB7XG4gICAgICAgICAgICBsZXQgdHJhbnNpdGlvbiA9IGF0bi5ydWxlVG9TdGFydFN0YXRlW2ldLnJlbW92ZVRyYW5zaXRpb24oYXRuLnJ1bGVUb1N0YXJ0U3RhdGVbaV0ubnVtYmVyT2ZUcmFuc2l0aW9ucyAtIDEpO1xuICAgICAgICAgICAgYnlwYXNzU3RhcnQuYWRkVHJhbnNpdGlvbih0cmFuc2l0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXRuLnJ1bGVUb1N0YXJ0U3RhdGVbaV0uYWRkVHJhbnNpdGlvbihuZXcgRXBzaWxvblRyYW5zaXRpb25fMS5FcHNpbG9uVHJhbnNpdGlvbihieXBhc3NTdGFydCkpO1xuICAgICAgICAgIGJ5cGFzc1N0b3AuYWRkVHJhbnNpdGlvbihuZXcgRXBzaWxvblRyYW5zaXRpb25fMS5FcHNpbG9uVHJhbnNpdGlvbihlbmRTdGF0ZSkpO1xuICAgICAgICAgIGxldCBtYXRjaFN0YXRlID0gbmV3IEJhc2ljU3RhdGVfMS5CYXNpY1N0YXRlKCk7XG4gICAgICAgICAgYXRuLmFkZFN0YXRlKG1hdGNoU3RhdGUpO1xuICAgICAgICAgIG1hdGNoU3RhdGUuYWRkVHJhbnNpdGlvbihuZXcgQXRvbVRyYW5zaXRpb25fMS5BdG9tVHJhbnNpdGlvbihieXBhc3NTdG9wLCBhdG4ucnVsZVRvVG9rZW5UeXBlW2ldKSk7XG4gICAgICAgICAgYnlwYXNzU3RhcnQuYWRkVHJhbnNpdGlvbihuZXcgRXBzaWxvblRyYW5zaXRpb25fMS5FcHNpbG9uVHJhbnNpdGlvbihtYXRjaFN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVzZXJpYWxpemF0aW9uT3B0aW9ucy5pc1ZlcmlmeUFUTikge1xuICAgICAgICAgIHRoaXMudmVyaWZ5QVROKGF0bik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRlc2VyaWFsaXphdGlvbk9wdGlvbnMuaXNPcHRpbWl6ZSkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGxldCBvcHRpbWl6YXRpb25Db3VudCA9IDA7XG4gICAgICAgICAgb3B0aW1pemF0aW9uQ291bnQgKz0gQVRORGVzZXJpYWxpemVyMy5pbmxpbmVTZXRSdWxlcyhhdG4pO1xuICAgICAgICAgIG9wdGltaXphdGlvbkNvdW50ICs9IEFUTkRlc2VyaWFsaXplcjMuY29tYmluZUNoYWluZWRFcHNpbG9ucyhhdG4pO1xuICAgICAgICAgIGxldCBwcmVzZXJ2ZU9yZGVyID0gYXRuLmdyYW1tYXJUeXBlID09PSAwO1xuICAgICAgICAgIG9wdGltaXphdGlvbkNvdW50ICs9IEFUTkRlc2VyaWFsaXplcjMub3B0aW1pemVTZXRzKGF0biwgcHJlc2VydmVPcmRlcik7XG4gICAgICAgICAgaWYgKG9wdGltaXphdGlvbkNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVzZXJpYWxpemF0aW9uT3B0aW9ucy5pc1ZlcmlmeUFUTikge1xuICAgICAgICAgIHRoaXMudmVyaWZ5QVROKGF0bik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIEFUTkRlc2VyaWFsaXplcjMuaWRlbnRpZnlUYWlsQ2FsbHMoYXRuKTtcbiAgICAgIHJldHVybiBhdG47XG4gICAgfVxuICAgIGRlc2VyaWFsaXplU2V0cyhkYXRhLCBwLCBzZXRzLCB1bmljb2RlRGVzZXJpYWxpemVyKSB7XG4gICAgICBsZXQgbnNldHMgPSBBVE5EZXNlcmlhbGl6ZXIzLnRvSW50KGRhdGFbcCsrXSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5zZXRzOyBpKyspIHtcbiAgICAgICAgbGV0IG5pbnRlcnZhbHMgPSBBVE5EZXNlcmlhbGl6ZXIzLnRvSW50KGRhdGFbcF0pO1xuICAgICAgICBwKys7XG4gICAgICAgIGxldCBzZXQgPSBuZXcgSW50ZXJ2YWxTZXRfMS5JbnRlcnZhbFNldCgpO1xuICAgICAgICBzZXRzLnB1c2goc2V0KTtcbiAgICAgICAgbGV0IGNvbnRhaW5zRW9mID0gQVRORGVzZXJpYWxpemVyMy50b0ludChkYXRhW3ArK10pICE9PSAwO1xuICAgICAgICBpZiAoY29udGFpbnNFb2YpIHtcbiAgICAgICAgICBzZXQuYWRkKC0xKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5pbnRlcnZhbHM7IGorKykge1xuICAgICAgICAgIGxldCBhID0gdW5pY29kZURlc2VyaWFsaXplci5yZWFkVW5pY29kZShkYXRhLCBwKTtcbiAgICAgICAgICBwICs9IHVuaWNvZGVEZXNlcmlhbGl6ZXIuc2l6ZTtcbiAgICAgICAgICBsZXQgYiA9IHVuaWNvZGVEZXNlcmlhbGl6ZXIucmVhZFVuaWNvZGUoZGF0YSwgcCk7XG4gICAgICAgICAgcCArPSB1bmljb2RlRGVzZXJpYWxpemVyLnNpemU7XG4gICAgICAgICAgc2V0LmFkZChhLCBiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIG1hcmtQcmVjZWRlbmNlRGVjaXNpb25zKGF0bikge1xuICAgICAgbGV0IHJ1bGVQcmVjZWRlbmNlRGVjaXNpb25zID0gbmV3IE1hcCgpO1xuICAgICAgZm9yIChsZXQgc3RhdGUgb2YgYXRuLnN0YXRlcykge1xuICAgICAgICBpZiAoIShzdGF0ZSBpbnN0YW5jZW9mIFN0YXJMb29wRW50cnlTdGF0ZV8xLlN0YXJMb29wRW50cnlTdGF0ZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXRuLnJ1bGVUb1N0YXJ0U3RhdGVbc3RhdGUucnVsZUluZGV4XS5pc1ByZWNlZGVuY2VSdWxlKSB7XG4gICAgICAgICAgbGV0IG1heWJlTG9vcEVuZFN0YXRlID0gc3RhdGUudHJhbnNpdGlvbihzdGF0ZS5udW1iZXJPZlRyYW5zaXRpb25zIC0gMSkudGFyZ2V0O1xuICAgICAgICAgIGlmIChtYXliZUxvb3BFbmRTdGF0ZSBpbnN0YW5jZW9mIExvb3BFbmRTdGF0ZV8xLkxvb3BFbmRTdGF0ZSkge1xuICAgICAgICAgICAgaWYgKG1heWJlTG9vcEVuZFN0YXRlLmVwc2lsb25Pbmx5VHJhbnNpdGlvbnMgJiYgbWF5YmVMb29wRW5kU3RhdGUudHJhbnNpdGlvbigwKS50YXJnZXQgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlXzEuUnVsZVN0b3BTdGF0ZSkge1xuICAgICAgICAgICAgICBydWxlUHJlY2VkZW5jZURlY2lzaW9ucy5zZXQoc3RhdGUucnVsZUluZGV4LCBzdGF0ZSk7XG4gICAgICAgICAgICAgIHN0YXRlLnByZWNlZGVuY2VSdWxlRGVjaXNpb24gPSB0cnVlO1xuICAgICAgICAgICAgICBzdGF0ZS5wcmVjZWRlbmNlTG9vcGJhY2tTdGF0ZXMgPSBuZXcgQml0U2V0XzEuQml0U2V0KGF0bi5zdGF0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHByZWNlZGVuY2VEZWNpc2lvbiBvZiBydWxlUHJlY2VkZW5jZURlY2lzaW9ucykge1xuICAgICAgICBmb3IgKGxldCB0cmFuc2l0aW9uIG9mIGF0bi5ydWxlVG9TdG9wU3RhdGVbcHJlY2VkZW5jZURlY2lzaW9uWzBdXS5nZXRUcmFuc2l0aW9ucygpKSB7XG4gICAgICAgICAgaWYgKHRyYW5zaXRpb24uc2VyaWFsaXphdGlvblR5cGUgIT09IDEpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgZXBzaWxvblRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgICAgICAgIGlmIChlcHNpbG9uVHJhbnNpdGlvbi5vdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuICE9PSAtMSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZWNlZGVuY2VEZWNpc2lvblsxXS5wcmVjZWRlbmNlTG9vcGJhY2tTdGF0ZXMuc2V0KHRyYW5zaXRpb24udGFyZ2V0LnN0YXRlTnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2ZXJpZnlBVE4oYXRuKSB7XG4gICAgICBmb3IgKGxldCBzdGF0ZSBvZiBhdG4uc3RhdGVzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUgIT09IHZvaWQgMCwgXCJBVE4gc3RhdGVzIHNob3VsZCBub3QgYmUgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgaWYgKHN0YXRlLnN0YXRlVHlwZSA9PT0gQVROU3RhdGVUeXBlXzEuQVROU3RhdGVUeXBlLklOVkFMSURfVFlQRSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUub25seUhhc0Vwc2lsb25UcmFuc2l0aW9ucyB8fCBzdGF0ZS5udW1iZXJPZlRyYW5zaXRpb25zIDw9IDEpO1xuICAgICAgICBpZiAoc3RhdGUgaW5zdGFuY2VvZiBQbHVzQmxvY2tTdGFydFN0YXRlXzEuUGx1c0Jsb2NrU3RhcnRTdGF0ZSkge1xuICAgICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUubG9vcEJhY2tTdGF0ZSAhPT0gdm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUgaW5zdGFuY2VvZiBTdGFyTG9vcEVudHJ5U3RhdGVfMS5TdGFyTG9vcEVudHJ5U3RhdGUpIHtcbiAgICAgICAgICBsZXQgc3Rhckxvb3BFbnRyeVN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbihzdGFyTG9vcEVudHJ5U3RhdGUubG9vcEJhY2tTdGF0ZSAhPT0gdm9pZCAwKTtcbiAgICAgICAgICB0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXJMb29wRW50cnlTdGF0ZS5udW1iZXJPZlRyYW5zaXRpb25zID09PSAyKTtcbiAgICAgICAgICBpZiAoc3Rhckxvb3BFbnRyeVN0YXRlLnRyYW5zaXRpb24oMCkudGFyZ2V0IGluc3RhbmNlb2YgU3RhckJsb2NrU3RhcnRTdGF0ZV8xLlN0YXJCbG9ja1N0YXJ0U3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3Rhckxvb3BFbnRyeVN0YXRlLnRyYW5zaXRpb24oMSkudGFyZ2V0IGluc3RhbmNlb2YgTG9vcEVuZFN0YXRlXzEuTG9vcEVuZFN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oIXN0YXJMb29wRW50cnlTdGF0ZS5ub25HcmVlZHkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3Rhckxvb3BFbnRyeVN0YXRlLnRyYW5zaXRpb24oMCkudGFyZ2V0IGluc3RhbmNlb2YgTG9vcEVuZFN0YXRlXzEuTG9vcEVuZFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXJMb29wRW50cnlTdGF0ZS50cmFuc2l0aW9uKDEpLnRhcmdldCBpbnN0YW5jZW9mIFN0YXJCbG9ja1N0YXJ0U3RhdGVfMS5TdGFyQmxvY2tTdGFydFN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3Rhckxvb3BFbnRyeVN0YXRlLm5vbkdyZWVkeSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWxTdGF0ZUV4Y2VwdGlvblwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlIGluc3RhbmNlb2YgU3Rhckxvb3BiYWNrU3RhdGVfMS5TdGFyTG9vcGJhY2tTdGF0ZSkge1xuICAgICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUubnVtYmVyT2ZUcmFuc2l0aW9ucyA9PT0gMSk7XG4gICAgICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS50cmFuc2l0aW9uKDApLnRhcmdldCBpbnN0YW5jZW9mIFN0YXJMb29wRW50cnlTdGF0ZV8xLlN0YXJMb29wRW50cnlTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlIGluc3RhbmNlb2YgTG9vcEVuZFN0YXRlXzEuTG9vcEVuZFN0YXRlKSB7XG4gICAgICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS5sb29wQmFja1N0YXRlICE9PSB2b2lkIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdGFydFN0YXRlXzEuUnVsZVN0YXJ0U3RhdGUpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXRlLnN0b3BTdGF0ZSAhPT0gdm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUgaW5zdGFuY2VvZiBCbG9ja1N0YXJ0U3RhdGVfMS5CbG9ja1N0YXJ0U3RhdGUpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXRlLmVuZFN0YXRlICE9PSB2b2lkIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSBpbnN0YW5jZW9mIEJsb2NrRW5kU3RhdGVfMS5CbG9ja0VuZFN0YXRlKSB7XG4gICAgICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS5zdGFydFN0YXRlICE9PSB2b2lkIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSBpbnN0YW5jZW9mIERlY2lzaW9uU3RhdGVfMS5EZWNpc2lvblN0YXRlKSB7XG4gICAgICAgICAgbGV0IGRlY2lzaW9uU3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICB0aGlzLmNoZWNrQ29uZGl0aW9uKGRlY2lzaW9uU3RhdGUubnVtYmVyT2ZUcmFuc2l0aW9ucyA8PSAxIHx8IGRlY2lzaW9uU3RhdGUuZGVjaXNpb24gPj0gMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS5udW1iZXJPZlRyYW5zaXRpb25zIDw9IDEgfHwgc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlXzEuUnVsZVN0b3BTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tDb25kaXRpb24oY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsU3RhdGVFeGNlcHRpb246IFwiICsgbWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBpbmxpbmVTZXRSdWxlcyhhdG4pIHtcbiAgICAgIGxldCBpbmxpbmVkQ2FsbHMgPSAwO1xuICAgICAgbGV0IHJ1bGVUb0lubGluZVRyYW5zaXRpb24gPSBuZXcgQXJyYXkoYXRuLnJ1bGVUb1N0YXJ0U3RhdGUubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXRuLnJ1bGVUb1N0YXJ0U3RhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHN0YXJ0U3RhdGUgPSBhdG4ucnVsZVRvU3RhcnRTdGF0ZVtpXTtcbiAgICAgICAgbGV0IG1pZGRsZVN0YXRlID0gc3RhcnRTdGF0ZTtcbiAgICAgICAgd2hpbGUgKG1pZGRsZVN0YXRlLm9ubHlIYXNFcHNpbG9uVHJhbnNpdGlvbnMgJiYgbWlkZGxlU3RhdGUubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9ucyA9PT0gMSAmJiBtaWRkbGVTdGF0ZS5nZXRPcHRpbWl6ZWRUcmFuc2l0aW9uKDApLnNlcmlhbGl6YXRpb25UeXBlID09PSAxKSB7XG4gICAgICAgICAgbWlkZGxlU3RhdGUgPSBtaWRkbGVTdGF0ZS5nZXRPcHRpbWl6ZWRUcmFuc2l0aW9uKDApLnRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWlkZGxlU3RhdGUubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9ucyAhPT0gMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXRjaFRyYW5zaXRpb24gPSBtaWRkbGVTdGF0ZS5nZXRPcHRpbWl6ZWRUcmFuc2l0aW9uKDApO1xuICAgICAgICBsZXQgbWF0Y2hUYXJnZXQgPSBtYXRjaFRyYW5zaXRpb24udGFyZ2V0O1xuICAgICAgICBpZiAobWF0Y2hUcmFuc2l0aW9uLmlzRXBzaWxvbiB8fCAhbWF0Y2hUYXJnZXQub25seUhhc0Vwc2lsb25UcmFuc2l0aW9ucyB8fCBtYXRjaFRhcmdldC5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zICE9PSAxIHx8ICEobWF0Y2hUYXJnZXQuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbigwKS50YXJnZXQgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlXzEuUnVsZVN0b3BTdGF0ZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG1hdGNoVHJhbnNpdGlvbi5zZXJpYWxpemF0aW9uVHlwZSkge1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcnVsZVRvSW5saW5lVHJhbnNpdGlvbltpXSA9IG1hdGNoVHJhbnNpdGlvbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHN0YXRlIG9mIGF0bi5zdGF0ZXMpIHtcbiAgICAgICAgaWYgKHN0YXRlLnJ1bGVJbmRleCA8IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3B0aW1pemVkVHJhbnNpdGlvbnM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9uczsgaSsrKSB7XG4gICAgICAgICAgbGV0IHRyYW5zaXRpb24gPSBzdGF0ZS5nZXRPcHRpbWl6ZWRUcmFuc2l0aW9uKGkpO1xuICAgICAgICAgIGlmICghKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBSdWxlVHJhbnNpdGlvbl8xLlJ1bGVUcmFuc2l0aW9uKSkge1xuICAgICAgICAgICAgaWYgKG9wdGltaXplZFRyYW5zaXRpb25zICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgb3B0aW1pemVkVHJhbnNpdGlvbnMucHVzaCh0cmFuc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcnVsZVRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgICAgICAgIGxldCBlZmZlY3RpdmUgPSBydWxlVG9JbmxpbmVUcmFuc2l0aW9uW3J1bGVUcmFuc2l0aW9uLnRhcmdldC5ydWxlSW5kZXhdO1xuICAgICAgICAgIGlmIChlZmZlY3RpdmUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKG9wdGltaXplZFRyYW5zaXRpb25zICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgb3B0aW1pemVkVHJhbnNpdGlvbnMucHVzaCh0cmFuc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW1pemVkVHJhbnNpdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgb3B0aW1pemVkVHJhbnNpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaTsgaisrKSB7XG4gICAgICAgICAgICAgIG9wdGltaXplZFRyYW5zaXRpb25zLnB1c2goc3RhdGUuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbihpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlubGluZWRDYWxscysrO1xuICAgICAgICAgIGxldCB0YXJnZXQgPSBydWxlVHJhbnNpdGlvbi5mb2xsb3dTdGF0ZTtcbiAgICAgICAgICBsZXQgaW50ZXJtZWRpYXRlU3RhdGUgPSBuZXcgQmFzaWNTdGF0ZV8xLkJhc2ljU3RhdGUoKTtcbiAgICAgICAgICBpbnRlcm1lZGlhdGVTdGF0ZS5zZXRSdWxlSW5kZXgodGFyZ2V0LnJ1bGVJbmRleCk7XG4gICAgICAgICAgYXRuLmFkZFN0YXRlKGludGVybWVkaWF0ZVN0YXRlKTtcbiAgICAgICAgICBvcHRpbWl6ZWRUcmFuc2l0aW9ucy5wdXNoKG5ldyBFcHNpbG9uVHJhbnNpdGlvbl8xLkVwc2lsb25UcmFuc2l0aW9uKGludGVybWVkaWF0ZVN0YXRlKSk7XG4gICAgICAgICAgc3dpdGNoIChlZmZlY3RpdmUuc2VyaWFsaXphdGlvblR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlU3RhdGUuYWRkVHJhbnNpdGlvbihuZXcgQXRvbVRyYW5zaXRpb25fMS5BdG9tVHJhbnNpdGlvbih0YXJnZXQsIGVmZmVjdGl2ZS5fbGFiZWwpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGludGVybWVkaWF0ZVN0YXRlLmFkZFRyYW5zaXRpb24obmV3IFJhbmdlVHJhbnNpdGlvbl8xLlJhbmdlVHJhbnNpdGlvbih0YXJnZXQsIGVmZmVjdGl2ZS5mcm9tLCBlZmZlY3RpdmUudG8pKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGludGVybWVkaWF0ZVN0YXRlLmFkZFRyYW5zaXRpb24obmV3IFNldFRyYW5zaXRpb25fMS5TZXRUcmFuc2l0aW9uKHRhcmdldCwgZWZmZWN0aXZlLmxhYmVsKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb25cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpbWl6ZWRUcmFuc2l0aW9ucyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLmlzT3B0aW1pemVkKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhdGUubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9ucyA+IDApIHtcbiAgICAgICAgICAgICAgc3RhdGUucmVtb3ZlT3B0aW1pemVkVHJhbnNpdGlvbihzdGF0ZS5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IHRyYW5zaXRpb24gb2Ygb3B0aW1pemVkVHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICAgIHN0YXRlLmFkZE9wdGltaXplZFRyYW5zaXRpb24odHJhbnNpdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoUGFyc2VyQVROU2ltdWxhdG9yXzEuUGFyc2VyQVROU2ltdWxhdG9yLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQVROIHJ1bnRpbWUgb3B0aW1pemVyIHJlbW92ZWQgXCIgKyBpbmxpbmVkQ2FsbHMgKyBcIiBydWxlIGludm9jYXRpb25zIGJ5IGlubGluaW5nIHNldHMuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlubGluZWRDYWxscztcbiAgICB9XG4gICAgc3RhdGljIGNvbWJpbmVDaGFpbmVkRXBzaWxvbnMoYXRuKSB7XG4gICAgICBsZXQgcmVtb3ZlZEVkZ2VzID0gMDtcbiAgICAgIGZvciAobGV0IHN0YXRlIG9mIGF0bi5zdGF0ZXMpIHtcbiAgICAgICAgaWYgKCFzdGF0ZS5vbmx5SGFzRXBzaWxvblRyYW5zaXRpb25zIHx8IHN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZV8xLlJ1bGVTdG9wU3RhdGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3B0aW1pemVkVHJhbnNpdGlvbnM7XG4gICAgICAgIG5leHRUcmFuc2l0aW9uOlxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdHJhbnNpdGlvbiA9IHN0YXRlLmdldE9wdGltaXplZFRyYW5zaXRpb24oaSk7XG4gICAgICAgICAgICBsZXQgaW50ZXJtZWRpYXRlID0gdHJhbnNpdGlvbi50YXJnZXQ7XG4gICAgICAgICAgICBpZiAodHJhbnNpdGlvbi5zZXJpYWxpemF0aW9uVHlwZSAhPT0gMSB8fCB0cmFuc2l0aW9uLm91dGVybW9zdFByZWNlZGVuY2VSZXR1cm4gIT09IC0xIHx8IGludGVybWVkaWF0ZS5zdGF0ZVR5cGUgIT09IEFUTlN0YXRlVHlwZV8xLkFUTlN0YXRlVHlwZS5CQVNJQyB8fCAhaW50ZXJtZWRpYXRlLm9ubHlIYXNFcHNpbG9uVHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICAgICAgaWYgKG9wdGltaXplZFRyYW5zaXRpb25zICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBvcHRpbWl6ZWRUcmFuc2l0aW9ucy5wdXNoKHRyYW5zaXRpb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG5leHRUcmFuc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbnRlcm1lZGlhdGUubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9uczsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChpbnRlcm1lZGlhdGUuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbihqKS5zZXJpYWxpemF0aW9uVHlwZSAhPT0gMSB8fCBpbnRlcm1lZGlhdGUuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbihqKS5vdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpbWl6ZWRUcmFuc2l0aW9ucyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICBvcHRpbWl6ZWRUcmFuc2l0aW9ucy5wdXNoKHRyYW5zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZSBuZXh0VHJhbnNpdGlvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtb3ZlZEVkZ2VzKys7XG4gICAgICAgICAgICBpZiAob3B0aW1pemVkVHJhbnNpdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBvcHRpbWl6ZWRUcmFuc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICAgICAgICAgIG9wdGltaXplZFRyYW5zaXRpb25zLnB1c2goc3RhdGUuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbihqKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW50ZXJtZWRpYXRlLm51bWJlck9mT3B0aW1pemVkVHJhbnNpdGlvbnM7IGorKykge1xuICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gaW50ZXJtZWRpYXRlLmdldE9wdGltaXplZFRyYW5zaXRpb24oaikudGFyZ2V0O1xuICAgICAgICAgICAgICBvcHRpbWl6ZWRUcmFuc2l0aW9ucy5wdXNoKG5ldyBFcHNpbG9uVHJhbnNpdGlvbl8xLkVwc2lsb25UcmFuc2l0aW9uKHRhcmdldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGltaXplZFRyYW5zaXRpb25zICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBpZiAoc3RhdGUuaXNPcHRpbWl6ZWQpIHtcbiAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zID4gMCkge1xuICAgICAgICAgICAgICBzdGF0ZS5yZW1vdmVPcHRpbWl6ZWRUcmFuc2l0aW9uKHN0YXRlLm51bWJlck9mT3B0aW1pemVkVHJhbnNpdGlvbnMgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgdHJhbnNpdGlvbiBvZiBvcHRpbWl6ZWRUcmFuc2l0aW9ucykge1xuICAgICAgICAgICAgc3RhdGUuYWRkT3B0aW1pemVkVHJhbnNpdGlvbih0cmFuc2l0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChQYXJzZXJBVE5TaW11bGF0b3JfMS5QYXJzZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJBVE4gcnVudGltZSBvcHRpbWl6ZXIgcmVtb3ZlZCBcIiArIHJlbW92ZWRFZGdlcyArIFwiIHRyYW5zaXRpb25zIGJ5IGNvbWJpbmluZyBjaGFpbmVkIGVwc2lsb24gdHJhbnNpdGlvbnMuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbW92ZWRFZGdlcztcbiAgICB9XG4gICAgc3RhdGljIG9wdGltaXplU2V0cyhhdG4sIHByZXNlcnZlT3JkZXIpIHtcbiAgICAgIGlmIChwcmVzZXJ2ZU9yZGVyKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgbGV0IHJlbW92ZWRQYXRocyA9IDA7XG4gICAgICBsZXQgZGVjaXNpb25zID0gYXRuLmRlY2lzaW9uVG9TdGF0ZTtcbiAgICAgIGZvciAobGV0IGRlY2lzaW9uIG9mIGRlY2lzaW9ucykge1xuICAgICAgICBsZXQgc2V0VHJhbnNpdGlvbnMgPSBuZXcgSW50ZXJ2YWxTZXRfMS5JbnRlcnZhbFNldCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY2lzaW9uLm51bWJlck9mT3B0aW1pemVkVHJhbnNpdGlvbnM7IGkrKykge1xuICAgICAgICAgIGxldCBlcHNUcmFuc2l0aW9uID0gZGVjaXNpb24uZ2V0T3B0aW1pemVkVHJhbnNpdGlvbihpKTtcbiAgICAgICAgICBpZiAoIShlcHNUcmFuc2l0aW9uIGluc3RhbmNlb2YgRXBzaWxvblRyYW5zaXRpb25fMS5FcHNpbG9uVHJhbnNpdGlvbikpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXBzVHJhbnNpdGlvbi50YXJnZXQubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9ucyAhPT0gMSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCB0cmFuc2l0aW9uID0gZXBzVHJhbnNpdGlvbi50YXJnZXQuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbigwKTtcbiAgICAgICAgICBpZiAoISh0cmFuc2l0aW9uLnRhcmdldCBpbnN0YW5jZW9mIEJsb2NrRW5kU3RhdGVfMS5CbG9ja0VuZFN0YXRlKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0cmFuc2l0aW9uIGluc3RhbmNlb2YgTm90U2V0VHJhbnNpdGlvbl8xLk5vdFNldFRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHJhbnNpdGlvbiBpbnN0YW5jZW9mIEF0b21UcmFuc2l0aW9uXzEuQXRvbVRyYW5zaXRpb24gfHwgdHJhbnNpdGlvbiBpbnN0YW5jZW9mIFJhbmdlVHJhbnNpdGlvbl8xLlJhbmdlVHJhbnNpdGlvbiB8fCB0cmFuc2l0aW9uIGluc3RhbmNlb2YgU2V0VHJhbnNpdGlvbl8xLlNldFRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIHNldFRyYW5zaXRpb25zLmFkZChpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldFRyYW5zaXRpb25zLnNpemUgPD0gMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcHRpbWl6ZWRUcmFuc2l0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY2lzaW9uLm51bWJlck9mT3B0aW1pemVkVHJhbnNpdGlvbnM7IGkrKykge1xuICAgICAgICAgIGlmICghc2V0VHJhbnNpdGlvbnMuY29udGFpbnMoaSkpIHtcbiAgICAgICAgICAgIG9wdGltaXplZFRyYW5zaXRpb25zLnB1c2goZGVjaXNpb24uZ2V0T3B0aW1pemVkVHJhbnNpdGlvbihpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBibG9ja0VuZFN0YXRlID0gZGVjaXNpb24uZ2V0T3B0aW1pemVkVHJhbnNpdGlvbihzZXRUcmFuc2l0aW9ucy5taW5FbGVtZW50KS50YXJnZXQuZ2V0T3B0aW1pemVkVHJhbnNpdGlvbigwKS50YXJnZXQ7XG4gICAgICAgIGxldCBtYXRjaFNldCA9IG5ldyBJbnRlcnZhbFNldF8xLkludGVydmFsU2V0KCk7XG4gICAgICAgIGZvciAobGV0IGludGVydmFsIG9mIHNldFRyYW5zaXRpb25zLmludGVydmFscykge1xuICAgICAgICAgIGZvciAobGV0IGogPSBpbnRlcnZhbC5hOyBqIDw9IGludGVydmFsLmI7IGorKykge1xuICAgICAgICAgICAgbGV0IG1hdGNoVHJhbnNpdGlvbiA9IGRlY2lzaW9uLmdldE9wdGltaXplZFRyYW5zaXRpb24oaikudGFyZ2V0LmdldE9wdGltaXplZFRyYW5zaXRpb24oMCk7XG4gICAgICAgICAgICBpZiAobWF0Y2hUcmFuc2l0aW9uIGluc3RhbmNlb2YgTm90U2V0VHJhbnNpdGlvbl8xLk5vdFNldFRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZC5cIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXRjaFNldC5hZGRBbGwobWF0Y2hUcmFuc2l0aW9uLmxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1RyYW5zaXRpb247XG4gICAgICAgIGlmIChtYXRjaFNldC5pbnRlcnZhbHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgaWYgKG1hdGNoU2V0LnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgIG5ld1RyYW5zaXRpb24gPSBuZXcgQXRvbVRyYW5zaXRpb25fMS5BdG9tVHJhbnNpdGlvbihibG9ja0VuZFN0YXRlLCBtYXRjaFNldC5taW5FbGVtZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1hdGNoSW50ZXJ2YWwgPSBtYXRjaFNldC5pbnRlcnZhbHNbMF07XG4gICAgICAgICAgICBuZXdUcmFuc2l0aW9uID0gbmV3IFJhbmdlVHJhbnNpdGlvbl8xLlJhbmdlVHJhbnNpdGlvbihibG9ja0VuZFN0YXRlLCBtYXRjaEludGVydmFsLmEsIG1hdGNoSW50ZXJ2YWwuYik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1RyYW5zaXRpb24gPSBuZXcgU2V0VHJhbnNpdGlvbl8xLlNldFRyYW5zaXRpb24oYmxvY2tFbmRTdGF0ZSwgbWF0Y2hTZXQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZXRPcHRpbWl6ZWRTdGF0ZSA9IG5ldyBCYXNpY1N0YXRlXzEuQmFzaWNTdGF0ZSgpO1xuICAgICAgICBzZXRPcHRpbWl6ZWRTdGF0ZS5zZXRSdWxlSW5kZXgoZGVjaXNpb24ucnVsZUluZGV4KTtcbiAgICAgICAgYXRuLmFkZFN0YXRlKHNldE9wdGltaXplZFN0YXRlKTtcbiAgICAgICAgc2V0T3B0aW1pemVkU3RhdGUuYWRkVHJhbnNpdGlvbihuZXdUcmFuc2l0aW9uKTtcbiAgICAgICAgb3B0aW1pemVkVHJhbnNpdGlvbnMucHVzaChuZXcgRXBzaWxvblRyYW5zaXRpb25fMS5FcHNpbG9uVHJhbnNpdGlvbihzZXRPcHRpbWl6ZWRTdGF0ZSkpO1xuICAgICAgICByZW1vdmVkUGF0aHMgKz0gZGVjaXNpb24ubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9ucyAtIG9wdGltaXplZFRyYW5zaXRpb25zLmxlbmd0aDtcbiAgICAgICAgaWYgKGRlY2lzaW9uLmlzT3B0aW1pemVkKSB7XG4gICAgICAgICAgd2hpbGUgKGRlY2lzaW9uLm51bWJlck9mT3B0aW1pemVkVHJhbnNpdGlvbnMgPiAwKSB7XG4gICAgICAgICAgICBkZWNpc2lvbi5yZW1vdmVPcHRpbWl6ZWRUcmFuc2l0aW9uKGRlY2lzaW9uLm51bWJlck9mT3B0aW1pemVkVHJhbnNpdGlvbnMgLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdHJhbnNpdGlvbiBvZiBvcHRpbWl6ZWRUcmFuc2l0aW9ucykge1xuICAgICAgICAgIGRlY2lzaW9uLmFkZE9wdGltaXplZFRyYW5zaXRpb24odHJhbnNpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChQYXJzZXJBVE5TaW11bGF0b3JfMS5QYXJzZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJBVE4gcnVudGltZSBvcHRpbWl6ZXIgcmVtb3ZlZCBcIiArIHJlbW92ZWRQYXRocyArIFwiIHBhdGhzIGJ5IGNvbGxhcHNpbmcgc2V0cy5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVtb3ZlZFBhdGhzO1xuICAgIH1cbiAgICBzdGF0aWMgaWRlbnRpZnlUYWlsQ2FsbHMoYXRuKSB7XG4gICAgICBmb3IgKGxldCBzdGF0ZSBvZiBhdG4uc3RhdGVzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUubnVtYmVyT2ZUcmFuc2l0aW9uczsgaSsrKSB7XG4gICAgICAgICAgbGV0IHRyYW5zaXRpb24gPSBzdGF0ZS50cmFuc2l0aW9uKGkpO1xuICAgICAgICAgIGlmICghKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBSdWxlVHJhbnNpdGlvbl8xLlJ1bGVUcmFuc2l0aW9uKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyYW5zaXRpb24udGFpbENhbGwgPSB0aGlzLnRlc3RUYWlsQ2FsbChhdG4sIHRyYW5zaXRpb24sIGZhbHNlKTtcbiAgICAgICAgICB0cmFuc2l0aW9uLm9wdGltaXplZFRhaWxDYWxsID0gdGhpcy50ZXN0VGFpbENhbGwoYXRuLCB0cmFuc2l0aW9uLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YXRlLmlzT3B0aW1pemVkKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5udW1iZXJPZk9wdGltaXplZFRyYW5zaXRpb25zOyBpKyspIHtcbiAgICAgICAgICBsZXQgdHJhbnNpdGlvbiA9IHN0YXRlLmdldE9wdGltaXplZFRyYW5zaXRpb24oaSk7XG4gICAgICAgICAgaWYgKCEodHJhbnNpdGlvbiBpbnN0YW5jZW9mIFJ1bGVUcmFuc2l0aW9uXzEuUnVsZVRyYW5zaXRpb24pKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhbnNpdGlvbi50YWlsQ2FsbCA9IHRoaXMudGVzdFRhaWxDYWxsKGF0biwgdHJhbnNpdGlvbiwgZmFsc2UpO1xuICAgICAgICAgIHRyYW5zaXRpb24ub3B0aW1pemVkVGFpbENhbGwgPSB0aGlzLnRlc3RUYWlsQ2FsbChhdG4sIHRyYW5zaXRpb24sIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyB0ZXN0VGFpbENhbGwoYXRuLCB0cmFuc2l0aW9uLCBvcHRpbWl6ZWRQYXRoKSB7XG4gICAgICBpZiAoIW9wdGltaXplZFBhdGggJiYgdHJhbnNpdGlvbi50YWlsQ2FsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpbWl6ZWRQYXRoICYmIHRyYW5zaXRpb24ub3B0aW1pemVkVGFpbENhbGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBsZXQgcmVhY2hhYmxlID0gbmV3IEJpdFNldF8xLkJpdFNldChhdG4uc3RhdGVzLmxlbmd0aCk7XG4gICAgICBsZXQgd29ya2xpc3QgPSBbXTtcbiAgICAgIHdvcmtsaXN0LnB1c2godHJhbnNpdGlvbi5mb2xsb3dTdGF0ZSk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgc3RhdGUgPSB3b3JrbGlzdC5wb3AoKTtcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWFjaGFibGUuZ2V0KHN0YXRlLnN0YXRlTnVtYmVyKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGVfMS5SdWxlU3RvcFN0YXRlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdGF0ZS5vbmx5SGFzRXBzaWxvblRyYW5zaXRpb25zKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0cmFuc2l0aW9uQ291bnQgPSBvcHRpbWl6ZWRQYXRoID8gc3RhdGUubnVtYmVyT2ZPcHRpbWl6ZWRUcmFuc2l0aW9ucyA6IHN0YXRlLm51bWJlck9mVHJhbnNpdGlvbnM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNpdGlvbkNvdW50OyBpKyspIHtcbiAgICAgICAgICBsZXQgdCA9IG9wdGltaXplZFBhdGggPyBzdGF0ZS5nZXRPcHRpbWl6ZWRUcmFuc2l0aW9uKGkpIDogc3RhdGUudHJhbnNpdGlvbihpKTtcbiAgICAgICAgICBpZiAodC5zZXJpYWxpemF0aW9uVHlwZSAhPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrbGlzdC5wdXNoKHQudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHN0YXRpYyB0b0ludChjKSB7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgc3RhdGljIHRvSW50MzIoZGF0YSwgb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gKGRhdGFbb2Zmc2V0XSB8IGRhdGFbb2Zmc2V0ICsgMV0gPDwgMTYpID4+PiAwO1xuICAgIH1cbiAgICBzdGF0aWMgdG9VVUlEKGRhdGEsIG9mZnNldCkge1xuICAgICAgbGV0IGxlYXN0U2lnQml0cyA9IEFUTkRlc2VyaWFsaXplcjMudG9JbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgICAgbGV0IGxlc3NTaWdCaXRzID0gQVRORGVzZXJpYWxpemVyMy50b0ludDMyKGRhdGEsIG9mZnNldCArIDIpO1xuICAgICAgbGV0IG1vcmVTaWdCaXRzID0gQVRORGVzZXJpYWxpemVyMy50b0ludDMyKGRhdGEsIG9mZnNldCArIDQpO1xuICAgICAgbGV0IG1vc3RTaWdCaXRzID0gQVRORGVzZXJpYWxpemVyMy50b0ludDMyKGRhdGEsIG9mZnNldCArIDYpO1xuICAgICAgcmV0dXJuIG5ldyBVVUlEXzEuVVVJRChtb3N0U2lnQml0cywgbW9yZVNpZ0JpdHMsIGxlc3NTaWdCaXRzLCBsZWFzdFNpZ0JpdHMpO1xuICAgIH1cbiAgICBlZGdlRmFjdG9yeShhdG4sIHR5cGUsIHNyYywgdHJnLCBhcmcxLCBhcmcyLCBhcmczLCBzZXRzKSB7XG4gICAgICBsZXQgdGFyZ2V0ID0gYXRuLnN0YXRlc1t0cmddO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gbmV3IEVwc2lsb25UcmFuc2l0aW9uXzEuRXBzaWxvblRyYW5zaXRpb24odGFyZ2V0KTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGlmIChhcmczICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlVHJhbnNpdGlvbl8xLlJhbmdlVHJhbnNpdGlvbih0YXJnZXQsIFRva2VuXzEuVG9rZW4uRU9GLCBhcmcyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZVRyYW5zaXRpb25fMS5SYW5nZVRyYW5zaXRpb24odGFyZ2V0LCBhcmcxLCBhcmcyKTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBsZXQgcnQgPSBuZXcgUnVsZVRyYW5zaXRpb25fMS5SdWxlVHJhbnNpdGlvbihhdG4uc3RhdGVzW2FyZzFdLCBhcmcyLCBhcmczLCB0YXJnZXQpO1xuICAgICAgICAgIHJldHVybiBydDtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGxldCBwdCA9IG5ldyBQcmVkaWNhdGVUcmFuc2l0aW9uXzEuUHJlZGljYXRlVHJhbnNpdGlvbih0YXJnZXQsIGFyZzEsIGFyZzIsIGFyZzMgIT09IDApO1xuICAgICAgICAgIHJldHVybiBwdDtcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICByZXR1cm4gbmV3IFByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uXzEuUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb24odGFyZ2V0LCBhcmcxKTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGlmIChhcmczICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEF0b21UcmFuc2l0aW9uXzEuQXRvbVRyYW5zaXRpb24odGFyZ2V0LCBUb2tlbl8xLlRva2VuLkVPRik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXRvbVRyYW5zaXRpb25fMS5BdG9tVHJhbnNpdGlvbih0YXJnZXQsIGFyZzEpO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIGxldCBhID0gbmV3IEFjdGlvblRyYW5zaXRpb25fMS5BY3Rpb25UcmFuc2l0aW9uKHRhcmdldCwgYXJnMSwgYXJnMiwgYXJnMyAhPT0gMCk7XG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICByZXR1cm4gbmV3IFNldFRyYW5zaXRpb25fMS5TZXRUcmFuc2l0aW9uKHRhcmdldCwgc2V0c1thcmcxXSk7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByZXR1cm4gbmV3IE5vdFNldFRyYW5zaXRpb25fMS5Ob3RTZXRUcmFuc2l0aW9uKHRhcmdldCwgc2V0c1thcmcxXSk7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICByZXR1cm4gbmV3IFdpbGRjYXJkVHJhbnNpdGlvbl8xLldpbGRjYXJkVHJhbnNpdGlvbih0YXJnZXQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNwZWNpZmllZCB0cmFuc2l0aW9uIHR5cGUgaXMgbm90IHZhbGlkLlwiKTtcbiAgICB9XG4gICAgc3RhdGVGYWN0b3J5KHR5cGUsIHJ1bGVJbmRleCkge1xuICAgICAgbGV0IHM7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBBVE5TdGF0ZVR5cGVfMS5BVE5TdGF0ZVR5cGUuSU5WQUxJRF9UWVBFOlxuICAgICAgICAgIHJldHVybiBuZXcgSW52YWxpZFN0YXRlXzEuSW52YWxpZFN0YXRlKCk7XG4gICAgICAgIGNhc2UgQVROU3RhdGVUeXBlXzEuQVROU3RhdGVUeXBlLkJBU0lDOlxuICAgICAgICAgIHMgPSBuZXcgQmFzaWNTdGF0ZV8xLkJhc2ljU3RhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBVE5TdGF0ZVR5cGVfMS5BVE5TdGF0ZVR5cGUuUlVMRV9TVEFSVDpcbiAgICAgICAgICBzID0gbmV3IFJ1bGVTdGFydFN0YXRlXzEuUnVsZVN0YXJ0U3RhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBVE5TdGF0ZVR5cGVfMS5BVE5TdGF0ZVR5cGUuQkxPQ0tfU1RBUlQ6XG4gICAgICAgICAgcyA9IG5ldyBCYXNpY0Jsb2NrU3RhcnRTdGF0ZV8xLkJhc2ljQmxvY2tTdGFydFN0YXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQVROU3RhdGVUeXBlXzEuQVROU3RhdGVUeXBlLlBMVVNfQkxPQ0tfU1RBUlQ6XG4gICAgICAgICAgcyA9IG5ldyBQbHVzQmxvY2tTdGFydFN0YXRlXzEuUGx1c0Jsb2NrU3RhcnRTdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFUTlN0YXRlVHlwZV8xLkFUTlN0YXRlVHlwZS5TVEFSX0JMT0NLX1NUQVJUOlxuICAgICAgICAgIHMgPSBuZXcgU3RhckJsb2NrU3RhcnRTdGF0ZV8xLlN0YXJCbG9ja1N0YXJ0U3RhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBVE5TdGF0ZVR5cGVfMS5BVE5TdGF0ZVR5cGUuVE9LRU5fU1RBUlQ6XG4gICAgICAgICAgcyA9IG5ldyBUb2tlbnNTdGFydFN0YXRlXzEuVG9rZW5zU3RhcnRTdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFUTlN0YXRlVHlwZV8xLkFUTlN0YXRlVHlwZS5SVUxFX1NUT1A6XG4gICAgICAgICAgcyA9IG5ldyBSdWxlU3RvcFN0YXRlXzEuUnVsZVN0b3BTdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFUTlN0YXRlVHlwZV8xLkFUTlN0YXRlVHlwZS5CTE9DS19FTkQ6XG4gICAgICAgICAgcyA9IG5ldyBCbG9ja0VuZFN0YXRlXzEuQmxvY2tFbmRTdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFUTlN0YXRlVHlwZV8xLkFUTlN0YXRlVHlwZS5TVEFSX0xPT1BfQkFDSzpcbiAgICAgICAgICBzID0gbmV3IFN0YXJMb29wYmFja1N0YXRlXzEuU3Rhckxvb3BiYWNrU3RhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBVE5TdGF0ZVR5cGVfMS5BVE5TdGF0ZVR5cGUuU1RBUl9MT09QX0VOVFJZOlxuICAgICAgICAgIHMgPSBuZXcgU3Rhckxvb3BFbnRyeVN0YXRlXzEuU3Rhckxvb3BFbnRyeVN0YXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQVROU3RhdGVUeXBlXzEuQVROU3RhdGVUeXBlLlBMVVNfTE9PUF9CQUNLOlxuICAgICAgICAgIHMgPSBuZXcgUGx1c0xvb3BiYWNrU3RhdGVfMS5QbHVzTG9vcGJhY2tTdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFUTlN0YXRlVHlwZV8xLkFUTlN0YXRlVHlwZS5MT09QX0VORDpcbiAgICAgICAgICBzID0gbmV3IExvb3BFbmRTdGF0ZV8xLkxvb3BFbmRTdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCBtZXNzYWdlID0gYFRoZSBzcGVjaWZpZWQgc3RhdGUgdHlwZSAke3R5cGV9IGlzIG5vdCB2YWxpZC5gO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHMucnVsZUluZGV4ID0gcnVsZUluZGV4O1xuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGxleGVyQWN0aW9uRmFjdG9yeSh0eXBlLCBkYXRhMSwgZGF0YTIpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG5ldyBMZXhlckNoYW5uZWxBY3Rpb25fMS5MZXhlckNoYW5uZWxBY3Rpb24oZGF0YTEpO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIG5ldyBMZXhlckN1c3RvbUFjdGlvbl8xLkxleGVyQ3VzdG9tQWN0aW9uKGRhdGExLCBkYXRhMik7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gbmV3IExleGVyTW9kZUFjdGlvbl8xLkxleGVyTW9kZUFjdGlvbihkYXRhMSk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gTGV4ZXJNb3JlQWN0aW9uXzEuTGV4ZXJNb3JlQWN0aW9uLklOU1RBTkNFO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIExleGVyUG9wTW9kZUFjdGlvbl8xLkxleGVyUG9wTW9kZUFjdGlvbi5JTlNUQU5DRTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiBuZXcgTGV4ZXJQdXNoTW9kZUFjdGlvbl8xLkxleGVyUHVzaE1vZGVBY3Rpb24oZGF0YTEpO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgcmV0dXJuIExleGVyU2tpcEFjdGlvbl8xLkxleGVyU2tpcEFjdGlvbi5JTlNUQU5DRTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIHJldHVybiBuZXcgTGV4ZXJUeXBlQWN0aW9uXzEuTGV4ZXJUeXBlQWN0aW9uKGRhdGExKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsZXQgbWVzc2FnZSA9IGBUaGUgc3BlY2lmaWVkIGxleGVyIGFjdGlvbiB0eXBlICR7dHlwZX0gaXMgbm90IHZhbGlkLmA7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgQVRORGVzZXJpYWxpemVyMy5CQVNFX1NFUklBTElaRURfVVVJRCA9IFVVSURfMS5VVUlELmZyb21TdHJpbmcoXCJFNDE3ODQ2OC1ERjk1LTQ0RDAtQUQ4Ny1GMjJBNUQ1RkI2RDNcIik7XG4gIEFUTkRlc2VyaWFsaXplcjMuQURERURfTEVYRVJfQUNUSU9OUyA9IFVVSURfMS5VVUlELmZyb21TdHJpbmcoXCJBQjM1MTkxQS0xNjAzLTQ4N0UtQjc1QS00NzlCODMxRUFGNkRcIik7XG4gIEFUTkRlc2VyaWFsaXplcjMuQURERURfVU5JQ09ERV9TTVAgPSBVVUlEXzEuVVVJRC5mcm9tU3RyaW5nKFwiQzIzRkVBODktMDYwNS00ZjUxLUFGQjgtMDU4QkNBQjhDOTFCXCIpO1xuICBBVE5EZXNlcmlhbGl6ZXIzLlNVUFBPUlRFRF9VVUlEUyA9IFtcbiAgICBBVE5EZXNlcmlhbGl6ZXIzLkJBU0VfU0VSSUFMSVpFRF9VVUlELFxuICAgIEFUTkRlc2VyaWFsaXplcjMuQURERURfTEVYRVJfQUNUSU9OUyxcbiAgICBBVE5EZXNlcmlhbGl6ZXIzLkFEREVEX1VOSUNPREVfU01QXG4gIF07XG4gIEFUTkRlc2VyaWFsaXplcjMuU0VSSUFMSVpFRF9VVUlEID0gQVRORGVzZXJpYWxpemVyMy5BRERFRF9VTklDT0RFX1NNUDtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgQVRORGVzZXJpYWxpemVyMy5wcm90b3R5cGUsIFwiZGVzZXJpYWxpemF0aW9uT3B0aW9uc1wiLCB2b2lkIDApO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBBVE5EZXNlcmlhbGl6ZXIzLnByb3RvdHlwZSwgXCJkZXNlcmlhbGl6ZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgQVRORGVzZXJpYWxpemVyMy5wcm90b3R5cGUsIFwibWFya1ByZWNlZGVuY2VEZWNpc2lvbnNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsLFxuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIEFUTkRlc2VyaWFsaXplcjMucHJvdG90eXBlLCBcImVkZ2VGYWN0b3J5XCIsIG51bGwpO1xuICBleHBvcnRzLkFUTkRlc2VyaWFsaXplciA9IEFUTkRlc2VyaWFsaXplcjM7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9QYXJzZUluZm8uanNcbnZhciByZXF1aXJlX1BhcnNlSW5mbyA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgdmFyIF9fcGFyYW0gPSBleHBvcnRzICYmIGV4cG9ydHMuX19wYXJhbSB8fCBmdW5jdGlvbihwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7XG4gICAgfTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5QYXJzZUluZm8gPSB2b2lkIDA7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIFBhcnNlSW5mbyA9IGNsYXNzIFBhcnNlSW5mbyB7XG4gICAgY29uc3RydWN0b3IoYXRuU2ltdWxhdG9yKSB7XG4gICAgICB0aGlzLmF0blNpbXVsYXRvciA9IGF0blNpbXVsYXRvcjtcbiAgICB9XG4gICAgZ2V0RGVjaXNpb25JbmZvKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXRuU2ltdWxhdG9yLmdldERlY2lzaW9uSW5mbygpO1xuICAgIH1cbiAgICBnZXRMTERlY2lzaW9ucygpIHtcbiAgICAgIGxldCBkZWNpc2lvbnMgPSB0aGlzLmF0blNpbXVsYXRvci5nZXREZWNpc2lvbkluZm8oKTtcbiAgICAgIGxldCBMTCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNpc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGZhbGxCYWNrID0gZGVjaXNpb25zW2ldLkxMX0ZhbGxiYWNrO1xuICAgICAgICBpZiAoZmFsbEJhY2sgPiAwKSB7XG4gICAgICAgICAgTEwucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIExMO1xuICAgIH1cbiAgICBnZXRUb3RhbFRpbWVJblByZWRpY3Rpb24oKSB7XG4gICAgICBsZXQgZGVjaXNpb25zID0gdGhpcy5hdG5TaW11bGF0b3IuZ2V0RGVjaXNpb25JbmZvKCk7XG4gICAgICBsZXQgdCA9IDA7XG4gICAgICBmb3IgKGxldCBkZWNpc2lvbiBvZiBkZWNpc2lvbnMpIHtcbiAgICAgICAgdCArPSBkZWNpc2lvbi50aW1lSW5QcmVkaWN0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICAgIGdldFRvdGFsU0xMTG9va2FoZWFkT3BzKCkge1xuICAgICAgbGV0IGRlY2lzaW9ucyA9IHRoaXMuYXRuU2ltdWxhdG9yLmdldERlY2lzaW9uSW5mbygpO1xuICAgICAgbGV0IGsgPSAwO1xuICAgICAgZm9yIChsZXQgZGVjaXNpb24gb2YgZGVjaXNpb25zKSB7XG4gICAgICAgIGsgKz0gZGVjaXNpb24uU0xMX1RvdGFsTG9vaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBrO1xuICAgIH1cbiAgICBnZXRUb3RhbExMTG9va2FoZWFkT3BzKCkge1xuICAgICAgbGV0IGRlY2lzaW9ucyA9IHRoaXMuYXRuU2ltdWxhdG9yLmdldERlY2lzaW9uSW5mbygpO1xuICAgICAgbGV0IGsgPSAwO1xuICAgICAgZm9yIChsZXQgZGVjaXNpb24gb2YgZGVjaXNpb25zKSB7XG4gICAgICAgIGsgKz0gZGVjaXNpb24uTExfVG90YWxMb29rO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGs7XG4gICAgfVxuICAgIGdldFRvdGFsU0xMQVROTG9va2FoZWFkT3BzKCkge1xuICAgICAgbGV0IGRlY2lzaW9ucyA9IHRoaXMuYXRuU2ltdWxhdG9yLmdldERlY2lzaW9uSW5mbygpO1xuICAgICAgbGV0IGsgPSAwO1xuICAgICAgZm9yIChsZXQgZGVjaXNpb24gb2YgZGVjaXNpb25zKSB7XG4gICAgICAgIGsgKz0gZGVjaXNpb24uU0xMX0FUTlRyYW5zaXRpb25zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGs7XG4gICAgfVxuICAgIGdldFRvdGFsTExBVE5Mb29rYWhlYWRPcHMoKSB7XG4gICAgICBsZXQgZGVjaXNpb25zID0gdGhpcy5hdG5TaW11bGF0b3IuZ2V0RGVjaXNpb25JbmZvKCk7XG4gICAgICBsZXQgayA9IDA7XG4gICAgICBmb3IgKGxldCBkZWNpc2lvbiBvZiBkZWNpc2lvbnMpIHtcbiAgICAgICAgayArPSBkZWNpc2lvbi5MTF9BVE5UcmFuc2l0aW9ucztcbiAgICAgIH1cbiAgICAgIHJldHVybiBrO1xuICAgIH1cbiAgICBnZXRUb3RhbEFUTkxvb2thaGVhZE9wcygpIHtcbiAgICAgIGxldCBkZWNpc2lvbnMgPSB0aGlzLmF0blNpbXVsYXRvci5nZXREZWNpc2lvbkluZm8oKTtcbiAgICAgIGxldCBrID0gMDtcbiAgICAgIGZvciAobGV0IGRlY2lzaW9uIG9mIGRlY2lzaW9ucykge1xuICAgICAgICBrICs9IGRlY2lzaW9uLlNMTF9BVE5UcmFuc2l0aW9ucztcbiAgICAgICAgayArPSBkZWNpc2lvbi5MTF9BVE5UcmFuc2l0aW9ucztcbiAgICAgIH1cbiAgICAgIHJldHVybiBrO1xuICAgIH1cbiAgICBnZXRERkFTaXplKGRlY2lzaW9uKSB7XG4gICAgICBpZiAoZGVjaXNpb24pIHtcbiAgICAgICAgbGV0IGRlY2lzaW9uVG9ERkEgPSB0aGlzLmF0blNpbXVsYXRvci5hdG4uZGVjaXNpb25Ub0RGQVtkZWNpc2lvbl07XG4gICAgICAgIHJldHVybiBkZWNpc2lvblRvREZBLnN0YXRlcy5zaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICBsZXQgZGVjaXNpb25Ub0RGQSA9IHRoaXMuYXRuU2ltdWxhdG9yLmF0bi5kZWNpc2lvblRvREZBO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY2lzaW9uVG9ERkEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBuICs9IHRoaXMuZ2V0REZBU2l6ZShpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIFBhcnNlSW5mby5wcm90b3R5cGUsIFwiZ2V0RGVjaXNpb25JbmZvXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBQYXJzZUluZm8ucHJvdG90eXBlLCBcImdldExMRGVjaXNpb25zXCIsIG51bGwpO1xuICBQYXJzZUluZm8gPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBQYXJzZUluZm8pO1xuICBleHBvcnRzLlBhcnNlSW5mbyA9IFBhcnNlSW5mbztcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvUHJveHlQYXJzZXJFcnJvckxpc3RlbmVyLmpzXG52YXIgcmVxdWlyZV9Qcm94eVBhcnNlckVycm9yTGlzdGVuZXIgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuUHJveHlQYXJzZXJFcnJvckxpc3RlbmVyID0gdm9pZCAwO1xuICB2YXIgUHJveHlFcnJvckxpc3RlbmVyXzEgPSByZXF1aXJlX1Byb3h5RXJyb3JMaXN0ZW5lcigpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBQcm94eVBhcnNlckVycm9yTGlzdGVuZXIgPSBjbGFzcyBleHRlbmRzIFByb3h5RXJyb3JMaXN0ZW5lcl8xLlByb3h5RXJyb3JMaXN0ZW5lciB7XG4gICAgY29uc3RydWN0b3IoZGVsZWdhdGVzKSB7XG4gICAgICBzdXBlcihkZWxlZ2F0ZXMpO1xuICAgIH1cbiAgICByZXBvcnRBbWJpZ3VpdHkocmVjb2duaXplciwgZGZhLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIGV4YWN0LCBhbWJpZ0FsdHMsIGNvbmZpZ3MpIHtcbiAgICAgIHRoaXMuZ2V0RGVsZWdhdGVzKCkuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgICAgaWYgKGxpc3RlbmVyLnJlcG9ydEFtYmlndWl0eSkge1xuICAgICAgICAgIGxpc3RlbmVyLnJlcG9ydEFtYmlndWl0eShyZWNvZ25pemVyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgZXhhY3QsIGFtYmlnQWx0cywgY29uZmlncyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHQocmVjb2duaXplciwgZGZhLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIGNvbmZsaWN0aW5nQWx0cywgY29uZmxpY3RTdGF0ZSkge1xuICAgICAgdGhpcy5nZXREZWxlZ2F0ZXMoKS5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICBpZiAobGlzdGVuZXIucmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0KSB7XG4gICAgICAgICAgbGlzdGVuZXIucmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0KHJlY29nbml6ZXIsIGRmYSwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBjb25mbGljdGluZ0FsdHMsIGNvbmZsaWN0U3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5KHJlY29nbml6ZXIsIGRmYSwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBwcmVkaWN0aW9uLCBhY2NlcHRTdGF0ZSkge1xuICAgICAgdGhpcy5nZXREZWxlZ2F0ZXMoKS5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICBpZiAobGlzdGVuZXIucmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5KSB7XG4gICAgICAgICAgbGlzdGVuZXIucmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5KHJlY29nbml6ZXIsIGRmYSwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBwcmVkaWN0aW9uLCBhY2NlcHRTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFByb3h5UGFyc2VyRXJyb3JMaXN0ZW5lci5wcm90b3R5cGUsIFwicmVwb3J0QW1iaWd1aXR5XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgUHJveHlQYXJzZXJFcnJvckxpc3RlbmVyLnByb3RvdHlwZSwgXCJyZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBQcm94eVBhcnNlckVycm9yTGlzdGVuZXIucHJvdG90eXBlLCBcInJlcG9ydENvbnRleHRTZW5zaXRpdml0eVwiLCBudWxsKTtcbiAgZXhwb3J0cy5Qcm94eVBhcnNlckVycm9yTGlzdGVuZXIgPSBQcm94eVBhcnNlckVycm9yTGlzdGVuZXI7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL21pc2MvQ2hhcmFjdGVyLmpzXG52YXIgcmVxdWlyZV9DaGFyYWN0ZXIgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLmlzU3VwcGxlbWVudGFyeUNvZGVQb2ludCA9IGV4cG9ydHMuaXNMb3dTdXJyb2dhdGUgPSBleHBvcnRzLmlzSGlnaFN1cnJvZ2F0ZSA9IHZvaWQgMDtcbiAgZnVuY3Rpb24gaXNIaWdoU3Vycm9nYXRlKGNoKSB7XG4gICAgcmV0dXJuIGNoID49IDU1Mjk2ICYmIGNoIDw9IDU2MzE5O1xuICB9XG4gIGV4cG9ydHMuaXNIaWdoU3Vycm9nYXRlID0gaXNIaWdoU3Vycm9nYXRlO1xuICBmdW5jdGlvbiBpc0xvd1N1cnJvZ2F0ZShjaCkge1xuICAgIHJldHVybiBjaCA+PSA1NjMyMCAmJiBjaCA8PSA1NzM0MztcbiAgfVxuICBleHBvcnRzLmlzTG93U3Vycm9nYXRlID0gaXNMb3dTdXJyb2dhdGU7XG4gIGZ1bmN0aW9uIGlzU3VwcGxlbWVudGFyeUNvZGVQb2ludChjaCkge1xuICAgIHJldHVybiBjaCA+PSA2NTUzNjtcbiAgfVxuICBleHBvcnRzLmlzU3VwcGxlbWVudGFyeUNvZGVQb2ludCA9IGlzU3VwcGxlbWVudGFyeUNvZGVQb2ludDtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvQ29kZVBvaW50QnVmZmVyLmpzXG52YXIgcmVxdWlyZV9Db2RlUG9pbnRCdWZmZXIgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkNvZGVQb2ludEJ1ZmZlciA9IHZvaWQgMDtcbiAgdmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG4gIHZhciBDaGFyYWN0ZXIgPSByZXF1aXJlX0NoYXJhY3RlcigpO1xuICB2YXIgQ29kZVBvaW50QnVmZmVyID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlciwgc2l6ZSkge1xuICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICB0aGlzLl9wb3NpdGlvbiA9IDA7XG4gICAgICB0aGlzLl9zaXplID0gc2l6ZTtcbiAgICB9XG4gICAgc3RhdGljIHdpdGhBcnJheShidWZmZXIpIHtcbiAgICAgIHJldHVybiBuZXcgQ29kZVBvaW50QnVmZmVyKGJ1ZmZlciwgYnVmZmVyLmxlbmd0aCk7XG4gICAgfVxuICAgIGdldCBwb3NpdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvbjtcbiAgICB9XG4gICAgc2V0IHBvc2l0aW9uKG5ld1Bvc2l0aW9uKSB7XG4gICAgICBpZiAobmV3UG9zaXRpb24gPCAwIHx8IG5ld1Bvc2l0aW9uID4gdGhpcy5fc2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcG9zaXRpb24gPSBuZXdQb3NpdGlvbjtcbiAgICB9XG4gICAgZ2V0IHJlbWFpbmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zaXplIC0gdGhpcy5wb3NpdGlvbjtcbiAgICB9XG4gICAgZ2V0KG9mZnNldCkge1xuICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyW29mZnNldF07XG4gICAgfVxuICAgIGFycmF5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNsaWNlKDAsIHRoaXMuX3NpemUpO1xuICAgIH1cbiAgICBzdGF0aWMgYnVpbGRlcihpbml0aWFsQnVmZmVyU2l6ZSkge1xuICAgICAgcmV0dXJuIG5ldyBDb2RlUG9pbnRCdWZmZXIuQnVpbGRlcihpbml0aWFsQnVmZmVyU2l6ZSk7XG4gICAgfVxuICB9O1xuICBleHBvcnRzLkNvZGVQb2ludEJ1ZmZlciA9IENvZGVQb2ludEJ1ZmZlcjtcbiAgKGZ1bmN0aW9uKENvZGVQb2ludEJ1ZmZlcjIpIHtcbiAgICBsZXQgVHlwZTtcbiAgICAoZnVuY3Rpb24oVHlwZTIpIHtcbiAgICAgIFR5cGUyW1R5cGUyW1wiQllURVwiXSA9IDBdID0gXCJCWVRFXCI7XG4gICAgICBUeXBlMltUeXBlMltcIkNIQVJcIl0gPSAxXSA9IFwiQ0hBUlwiO1xuICAgICAgVHlwZTJbVHlwZTJbXCJJTlRcIl0gPSAyXSA9IFwiSU5UXCI7XG4gICAgfSkoVHlwZSB8fCAoVHlwZSA9IHt9KSk7XG4gICAgY2xhc3MgQnVpbGRlciB7XG4gICAgICBjb25zdHJ1Y3Rvcihpbml0aWFsQnVmZmVyU2l6ZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGluaXRpYWxCdWZmZXJTaXplKTtcbiAgICAgICAgdGhpcy5wcmV2SGlnaFN1cnJvZ2F0ZSA9IC0xO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgICAgIH1cbiAgICAgIGJ1aWxkKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvZGVQb2ludEJ1ZmZlcjIodGhpcy5idWZmZXIsIHRoaXMucG9zaXRpb24pO1xuICAgICAgfVxuICAgICAgc3RhdGljIHJvdW5kVXBUb05leHRQb3dlck9mVHdvKGkpIHtcbiAgICAgICAgbGV0IG5leHRQb3dlck9mVHdvID0gMzIgLSBNYXRoLmNsejMyKGkgLSAxKTtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KDIsIG5leHRQb3dlck9mVHdvKTtcbiAgICAgIH1cbiAgICAgIGVuc3VyZVJlbWFpbmluZyhyZW1haW5pbmdOZWVkZWQpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoIC0gdGhpcy5wb3NpdGlvbiA8IHJlbWFpbmluZ05lZWRlZCkge1xuICAgICAgICAgICAgICBsZXQgbmV3Q2FwYWNpdHkgPSBCdWlsZGVyLnJvdW5kVXBUb05leHRQb3dlck9mVHdvKHRoaXMuYnVmZmVyLmxlbmd0aCArIHJlbWFpbmluZ05lZWRlZCk7XG4gICAgICAgICAgICAgIGxldCBuZXdCdWZmZXIgPSBuZXcgVWludDhBcnJheShuZXdDYXBhY2l0eSk7XG4gICAgICAgICAgICAgIG5ld0J1ZmZlci5zZXQodGhpcy5idWZmZXIuc3ViYXJyYXkoMCwgdGhpcy5wb3NpdGlvbiksIDApO1xuICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ld0J1ZmZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggLSB0aGlzLnBvc2l0aW9uIDwgcmVtYWluaW5nTmVlZGVkKSB7XG4gICAgICAgICAgICAgIGxldCBuZXdDYXBhY2l0eSA9IEJ1aWxkZXIucm91bmRVcFRvTmV4dFBvd2VyT2ZUd28odGhpcy5idWZmZXIubGVuZ3RoICsgcmVtYWluaW5nTmVlZGVkKTtcbiAgICAgICAgICAgICAgbGV0IG5ld0J1ZmZlciA9IG5ldyBVaW50MTZBcnJheShuZXdDYXBhY2l0eSk7XG4gICAgICAgICAgICAgIG5ld0J1ZmZlci5zZXQodGhpcy5idWZmZXIuc3ViYXJyYXkoMCwgdGhpcy5wb3NpdGlvbiksIDApO1xuICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ld0J1ZmZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggLSB0aGlzLnBvc2l0aW9uIDwgcmVtYWluaW5nTmVlZGVkKSB7XG4gICAgICAgICAgICAgIGxldCBuZXdDYXBhY2l0eSA9IEJ1aWxkZXIucm91bmRVcFRvTmV4dFBvd2VyT2ZUd28odGhpcy5idWZmZXIubGVuZ3RoICsgcmVtYWluaW5nTmVlZGVkKTtcbiAgICAgICAgICAgICAgbGV0IG5ld0J1ZmZlciA9IG5ldyBJbnQzMkFycmF5KG5ld0NhcGFjaXR5KTtcbiAgICAgICAgICAgICAgbmV3QnVmZmVyLnNldCh0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCB0aGlzLnBvc2l0aW9uKSwgMCk7XG4gICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3QnVmZmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFwcGVuZCh1dGYxNkluKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmVtYWluaW5nKHV0ZjE2SW4ubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5hcHBlbmRBcnJheSh1dGYxNkluKTtcbiAgICAgIH1cbiAgICAgIGFwcGVuZEFycmF5KHV0ZjE2SW4pIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB0aGlzLmFwcGVuZEFycmF5Qnl0ZSh1dGYxNkluKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQXJyYXlDaGFyKHV0ZjE2SW4pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy5hcHBlbmRBcnJheUludCh1dGYxNkluKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcHBlbmRBcnJheUJ5dGUodXRmMTZJbikge1xuICAgICAgICBhc3NlcnQodGhpcy5wcmV2SGlnaFN1cnJvZ2F0ZSA9PT0gLTEpO1xuICAgICAgICBsZXQgaW5wdXQgPSB1dGYxNkluO1xuICAgICAgICBsZXQgaW5PZmZzZXQgPSAwO1xuICAgICAgICBsZXQgaW5MaW1pdCA9IHV0ZjE2SW4ubGVuZ3RoO1xuICAgICAgICBsZXQgb3V0Qnl0ZSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBsZXQgb3V0T2Zmc2V0ID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgd2hpbGUgKGluT2Zmc2V0IDwgaW5MaW1pdCkge1xuICAgICAgICAgIGxldCBjID0gaW5wdXRbaW5PZmZzZXRdO1xuICAgICAgICAgIGlmIChjIDw9IDI1NSkge1xuICAgICAgICAgICAgb3V0Qnl0ZVtvdXRPZmZzZXRdID0gYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXRmMTZJbiA9IHV0ZjE2SW4uc3ViYXJyYXkoaW5PZmZzZXQsIGluTGltaXQpO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG91dE9mZnNldDtcbiAgICAgICAgICAgIGlmICghQ2hhcmFjdGVyLmlzSGlnaFN1cnJvZ2F0ZShjKSkge1xuICAgICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJCdWZmZXIodXRmMTZJbi5sZW5ndGgpO1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZEFycmF5Q2hhcih1dGYxNkluKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5ieXRlVG9JbnRCdWZmZXIodXRmMTZJbi5sZW5ndGgpO1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZEFycmF5SW50KHV0ZjE2SW4pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGluT2Zmc2V0Kys7XG4gICAgICAgICAgb3V0T2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG91dE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGFwcGVuZEFycmF5Q2hhcih1dGYxNkluKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLnByZXZIaWdoU3Vycm9nYXRlID09PSAtMSk7XG4gICAgICAgIGxldCBpbnB1dCA9IHV0ZjE2SW47XG4gICAgICAgIGxldCBpbk9mZnNldCA9IDA7XG4gICAgICAgIGxldCBpbkxpbWl0ID0gdXRmMTZJbi5sZW5ndGg7XG4gICAgICAgIGxldCBvdXRDaGFyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGxldCBvdXRPZmZzZXQgPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB3aGlsZSAoaW5PZmZzZXQgPCBpbkxpbWl0KSB7XG4gICAgICAgICAgbGV0IGMgPSBpbnB1dFtpbk9mZnNldF07XG4gICAgICAgICAgaWYgKCFDaGFyYWN0ZXIuaXNIaWdoU3Vycm9nYXRlKGMpKSB7XG4gICAgICAgICAgICBvdXRDaGFyW291dE9mZnNldF0gPSBjO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGYxNkluID0gdXRmMTZJbi5zdWJhcnJheShpbk9mZnNldCwgaW5MaW1pdCk7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gb3V0T2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy5jaGFyVG9JbnRCdWZmZXIodXRmMTZJbi5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRBcnJheUludCh1dGYxNkluKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5PZmZzZXQrKztcbiAgICAgICAgICBvdXRPZmZzZXQrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gb3V0T2Zmc2V0O1xuICAgICAgfVxuICAgICAgYXBwZW5kQXJyYXlJbnQodXRmMTZJbikge1xuICAgICAgICBsZXQgaW5wdXQgPSB1dGYxNkluO1xuICAgICAgICBsZXQgaW5PZmZzZXQgPSAwO1xuICAgICAgICBsZXQgaW5MaW1pdCA9IHV0ZjE2SW4ubGVuZ3RoO1xuICAgICAgICBsZXQgb3V0SW50ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGxldCBvdXRPZmZzZXQgPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB3aGlsZSAoaW5PZmZzZXQgPCBpbkxpbWl0KSB7XG4gICAgICAgICAgbGV0IGMgPSBpbnB1dFtpbk9mZnNldF07XG4gICAgICAgICAgaW5PZmZzZXQrKztcbiAgICAgICAgICBpZiAodGhpcy5wcmV2SGlnaFN1cnJvZ2F0ZSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChDaGFyYWN0ZXIuaXNMb3dTdXJyb2dhdGUoYykpIHtcbiAgICAgICAgICAgICAgb3V0SW50W291dE9mZnNldF0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMucHJldkhpZ2hTdXJyb2dhdGUsIGMpLmNvZGVQb2ludEF0KDApO1xuICAgICAgICAgICAgICBvdXRPZmZzZXQrKztcbiAgICAgICAgICAgICAgdGhpcy5wcmV2SGlnaFN1cnJvZ2F0ZSA9IC0xO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0SW50W291dE9mZnNldF0gPSB0aGlzLnByZXZIaWdoU3Vycm9nYXRlO1xuICAgICAgICAgICAgICBvdXRPZmZzZXQrKztcbiAgICAgICAgICAgICAgaWYgKENoYXJhY3Rlci5pc0hpZ2hTdXJyb2dhdGUoYykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZIaWdoU3Vycm9nYXRlID0gYztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRJbnRbb3V0T2Zmc2V0XSA9IGM7XG4gICAgICAgICAgICAgICAgb3V0T2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2SGlnaFN1cnJvZ2F0ZSA9IC0xO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChDaGFyYWN0ZXIuaXNIaWdoU3Vycm9nYXRlKGMpKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZIaWdoU3Vycm9nYXRlID0gYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0SW50W291dE9mZnNldF0gPSBjO1xuICAgICAgICAgICAgb3V0T2Zmc2V0Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByZXZIaWdoU3Vycm9nYXRlICE9PSAtMSkge1xuICAgICAgICAgIG91dEludFtvdXRPZmZzZXRdID0gdGhpcy5wcmV2SGlnaFN1cnJvZ2F0ZTtcbiAgICAgICAgICBvdXRPZmZzZXQrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gb3V0T2Zmc2V0O1xuICAgICAgfVxuICAgICAgYnl0ZVRvQ2hhckJ1ZmZlcih0b0FwcGVuZCkge1xuICAgICAgICBsZXQgbmV3QnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KE1hdGgubWF4KHRoaXMucG9zaXRpb24gKyB0b0FwcGVuZCwgdGhpcy5idWZmZXIubGVuZ3RoID4+IDEpKTtcbiAgICAgICAgbmV3QnVmZmVyLnNldCh0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCB0aGlzLnBvc2l0aW9uKSwgMCk7XG4gICAgICAgIHRoaXMudHlwZSA9IDE7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3QnVmZmVyO1xuICAgICAgfVxuICAgICAgYnl0ZVRvSW50QnVmZmVyKHRvQXBwZW5kKSB7XG4gICAgICAgIGxldCBuZXdCdWZmZXIgPSBuZXcgSW50MzJBcnJheShNYXRoLm1heCh0aGlzLnBvc2l0aW9uICsgdG9BcHBlbmQsIHRoaXMuYnVmZmVyLmxlbmd0aCA+PiAyKSk7XG4gICAgICAgIG5ld0J1ZmZlci5zZXQodGhpcy5idWZmZXIuc3ViYXJyYXkoMCwgdGhpcy5wb3NpdGlvbiksIDApO1xuICAgICAgICB0aGlzLnR5cGUgPSAyO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ld0J1ZmZlcjtcbiAgICAgIH1cbiAgICAgIGNoYXJUb0ludEJ1ZmZlcih0b0FwcGVuZCkge1xuICAgICAgICBsZXQgbmV3QnVmZmVyID0gbmV3IEludDMyQXJyYXkoTWF0aC5tYXgodGhpcy5wb3NpdGlvbiArIHRvQXBwZW5kLCB0aGlzLmJ1ZmZlci5sZW5ndGggPj4gMSkpO1xuICAgICAgICBuZXdCdWZmZXIuc2V0KHRoaXMuYnVmZmVyLnN1YmFycmF5KDAsIHRoaXMucG9zaXRpb24pLCAwKTtcbiAgICAgICAgdGhpcy50eXBlID0gMjtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXdCdWZmZXI7XG4gICAgICB9XG4gICAgfVxuICAgIENvZGVQb2ludEJ1ZmZlcjIuQnVpbGRlciA9IEJ1aWxkZXI7XG4gIH0pKENvZGVQb2ludEJ1ZmZlciA9IGV4cG9ydHMuQ29kZVBvaW50QnVmZmVyIHx8IChleHBvcnRzLkNvZGVQb2ludEJ1ZmZlciA9IHt9KSk7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL0NvZGVQb2ludENoYXJTdHJlYW0uanNcbnZhciByZXF1aXJlX0NvZGVQb2ludENoYXJTdHJlYW0gPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuQ29kZVBvaW50Q2hhclN0cmVhbSA9IHZvaWQgMDtcbiAgdmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG4gIHZhciBJbnRTdHJlYW1fMSA9IHJlcXVpcmVfSW50U3RyZWFtKCk7XG4gIHZhciBJbnRlcnZhbF8xID0gcmVxdWlyZV9JbnRlcnZhbCgpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBDb2RlUG9pbnRDaGFyU3RyZWFtID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGFycmF5LCBwb3NpdGlvbiwgcmVtYWluaW5nLCBuYW1lKSB7XG4gICAgICBhc3NlcnQocG9zaXRpb24gPT09IDApO1xuICAgICAgdGhpcy5fYXJyYXkgPSBhcnJheTtcbiAgICAgIHRoaXMuX3NpemUgPSByZW1haW5pbmc7XG4gICAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uID0gMDtcbiAgICB9XG4gICAgZ2V0IGludGVybmFsU3RvcmFnZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcnJheTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CdWZmZXIoY29kZVBvaW50QnVmZmVyLCBuYW1lKSB7XG4gICAgICBpZiAobmFtZSA9PT0gdm9pZCAwIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG5hbWUgPSBJbnRTdHJlYW1fMS5JbnRTdHJlYW0uVU5LTk9XTl9TT1VSQ0VfTkFNRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ29kZVBvaW50Q2hhclN0cmVhbShjb2RlUG9pbnRCdWZmZXIuYXJyYXkoKSwgY29kZVBvaW50QnVmZmVyLnBvc2l0aW9uLCBjb2RlUG9pbnRCdWZmZXIucmVtYWluaW5nLCBuYW1lKTtcbiAgICB9XG4gICAgY29uc3VtZSgpIHtcbiAgICAgIGlmICh0aGlzLl9zaXplIC0gdGhpcy5fcG9zaXRpb24gPT09IDApIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuTEEoMSkgPT09IEludFN0cmVhbV8xLkludFN0cmVhbS5FT0YpO1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImNhbm5vdCBjb25zdW1lIEVPRlwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Bvc2l0aW9uKys7XG4gICAgfVxuICAgIGdldCBpbmRleCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvbjtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgbWFyaygpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmVsZWFzZShtYXJrZXIpIHtcbiAgICB9XG4gICAgc2VlayhpbmRleCkge1xuICAgICAgdGhpcy5fcG9zaXRpb24gPSBpbmRleDtcbiAgICB9XG4gICAgZ2V0IHNvdXJjZU5hbWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUZXh0KEludGVydmFsXzEuSW50ZXJ2YWwub2YoMCwgdGhpcy5zaXplIC0gMSkpO1xuICAgIH1cbiAgICBMQShpKSB7XG4gICAgICBsZXQgb2Zmc2V0O1xuICAgICAgc3dpdGNoIChNYXRoLnNpZ24oaSkpIHtcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICBvZmZzZXQgPSB0aGlzLmluZGV4ICsgaTtcbiAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIEludFN0cmVhbV8xLkludFN0cmVhbS5FT0Y7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9hcnJheVtvZmZzZXRdO1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBvZmZzZXQgPSB0aGlzLmluZGV4ICsgaSAtIDE7XG4gICAgICAgICAgaWYgKG9mZnNldCA+PSB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBJbnRTdHJlYW1fMS5JbnRTdHJlYW0uRU9GO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5fYXJyYXlbb2Zmc2V0XTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm90IHJlYWNoZWRcIik7XG4gICAgfVxuICAgIGdldFRleHQoaW50ZXJ2YWwpIHtcbiAgICAgIGNvbnN0IHN0YXJ0SWR4ID0gTWF0aC5taW4oaW50ZXJ2YWwuYSwgdGhpcy5zaXplKTtcbiAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWluKGludGVydmFsLmIgLSBpbnRlcnZhbC5hICsgMSwgdGhpcy5zaXplIC0gc3RhcnRJZHgpO1xuICAgICAgaWYgKHRoaXMuX2FycmF5IGluc3RhbmNlb2YgSW50MzJBcnJheSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uQXJyYXkuZnJvbSh0aGlzLl9hcnJheS5zdWJhcnJheShzdGFydElkeCwgc3RhcnRJZHggKyBsZW4pKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5BcnJheS5mcm9tKHRoaXMuX2FycmF5LnN1YmFycmF5KHN0YXJ0SWR4LCBzdGFydElkeCArIGxlbikpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBDb2RlUG9pbnRDaGFyU3RyZWFtLnByb3RvdHlwZSwgXCJjb25zdW1lXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQ29kZVBvaW50Q2hhclN0cmVhbS5wcm90b3R5cGUsIFwiaW5kZXhcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBDb2RlUG9pbnRDaGFyU3RyZWFtLnByb3RvdHlwZSwgXCJzaXplXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQ29kZVBvaW50Q2hhclN0cmVhbS5wcm90b3R5cGUsIFwibWFya1wiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIENvZGVQb2ludENoYXJTdHJlYW0ucHJvdG90eXBlLCBcInJlbGVhc2VcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBDb2RlUG9pbnRDaGFyU3RyZWFtLnByb3RvdHlwZSwgXCJzZWVrXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQ29kZVBvaW50Q2hhclN0cmVhbS5wcm90b3R5cGUsIFwic291cmNlTmFtZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIENvZGVQb2ludENoYXJTdHJlYW0ucHJvdG90eXBlLCBcInRvU3RyaW5nXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQ29kZVBvaW50Q2hhclN0cmVhbS5wcm90b3R5cGUsIFwiTEFcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBDb2RlUG9pbnRDaGFyU3RyZWFtLnByb3RvdHlwZSwgXCJnZXRUZXh0XCIsIG51bGwpO1xuICBleHBvcnRzLkNvZGVQb2ludENoYXJTdHJlYW0gPSBDb2RlUG9pbnRDaGFyU3RyZWFtO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9DaGFyU3RyZWFtcy5qc1xudmFyIHJlcXVpcmVfQ2hhclN0cmVhbXMgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkNoYXJTdHJlYW1zID0gdm9pZCAwO1xuICB2YXIgQ29kZVBvaW50QnVmZmVyXzEgPSByZXF1aXJlX0NvZGVQb2ludEJ1ZmZlcigpO1xuICB2YXIgQ29kZVBvaW50Q2hhclN0cmVhbV8xID0gcmVxdWlyZV9Db2RlUG9pbnRDaGFyU3RyZWFtKCk7XG4gIHZhciBJbnRTdHJlYW1fMSA9IHJlcXVpcmVfSW50U3RyZWFtKCk7XG4gIHZhciBDaGFyU3RyZWFtcztcbiAgKGZ1bmN0aW9uKENoYXJTdHJlYW1zMikge1xuICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcocywgc291cmNlTmFtZSkge1xuICAgICAgaWYgKHNvdXJjZU5hbWUgPT09IHZvaWQgMCB8fCBzb3VyY2VOYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzb3VyY2VOYW1lID0gSW50U3RyZWFtXzEuSW50U3RyZWFtLlVOS05PV05fU09VUkNFX05BTUU7XG4gICAgICB9XG4gICAgICBsZXQgY29kZVBvaW50QnVmZmVyQnVpbGRlciA9IENvZGVQb2ludEJ1ZmZlcl8xLkNvZGVQb2ludEJ1ZmZlci5idWlsZGVyKHMubGVuZ3RoKTtcbiAgICAgIGxldCBjYiA9IG5ldyBVaW50MTZBcnJheShzLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2JbaV0gPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG4gICAgICBjb2RlUG9pbnRCdWZmZXJCdWlsZGVyLmFwcGVuZChjYik7XG4gICAgICByZXR1cm4gQ29kZVBvaW50Q2hhclN0cmVhbV8xLkNvZGVQb2ludENoYXJTdHJlYW0uZnJvbUJ1ZmZlcihjb2RlUG9pbnRCdWZmZXJCdWlsZGVyLmJ1aWxkKCksIHNvdXJjZU5hbWUpO1xuICAgIH1cbiAgICBDaGFyU3RyZWFtczIuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XG4gIH0pKENoYXJTdHJlYW1zID0gZXhwb3J0cy5DaGFyU3RyZWFtcyB8fCAoZXhwb3J0cy5DaGFyU3RyZWFtcyA9IHt9KSk7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL0J1ZmZlcmVkVG9rZW5TdHJlYW0uanNcbnZhciByZXF1aXJlX0J1ZmZlcmVkVG9rZW5TdHJlYW0gPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuQnVmZmVyZWRUb2tlblN0cmVhbSA9IHZvaWQgMDtcbiAgdmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG4gIHZhciBDb21tb25Ub2tlbl8xID0gcmVxdWlyZV9Db21tb25Ub2tlbigpO1xuICB2YXIgSW50ZXJ2YWxfMSA9IHJlcXVpcmVfSW50ZXJ2YWwoKTtcbiAgdmFyIExleGVyXzEgPSByZXF1aXJlX0xleGVyKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIFRva2VuXzEgPSByZXF1aXJlX1Rva2VuKCk7XG4gIHZhciBCdWZmZXJlZFRva2VuU3RyZWFtID0gY2xhc3MgQnVmZmVyZWRUb2tlblN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IodG9rZW5Tb3VyY2UpIHtcbiAgICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgICB0aGlzLnAgPSAtMTtcbiAgICAgIHRoaXMuZmV0Y2hlZEVPRiA9IGZhbHNlO1xuICAgICAgaWYgKHRva2VuU291cmNlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidG9rZW5Tb3VyY2UgY2Fubm90IGJlIG51bGxcIik7XG4gICAgICB9XG4gICAgICB0aGlzLl90b2tlblNvdXJjZSA9IHRva2VuU291cmNlO1xuICAgIH1cbiAgICBnZXQgdG9rZW5Tb3VyY2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdG9rZW5Tb3VyY2U7XG4gICAgfVxuICAgIHNldCB0b2tlblNvdXJjZSh0b2tlblNvdXJjZSkge1xuICAgICAgdGhpcy5fdG9rZW5Tb3VyY2UgPSB0b2tlblNvdXJjZTtcbiAgICAgIHRoaXMudG9rZW5zLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLnAgPSAtMTtcbiAgICAgIHRoaXMuZmV0Y2hlZEVPRiA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgaW5kZXgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wO1xuICAgIH1cbiAgICBtYXJrKCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJlbGVhc2UobWFya2VyKSB7XG4gICAgfVxuICAgIHNlZWsoaW5kZXgpIHtcbiAgICAgIHRoaXMubGF6eUluaXQoKTtcbiAgICAgIHRoaXMucCA9IHRoaXMuYWRqdXN0U2Vla0luZGV4KGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnMubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdW1lKCkge1xuICAgICAgbGV0IHNraXBFb2ZDaGVjaztcbiAgICAgIGlmICh0aGlzLnAgPj0gMCkge1xuICAgICAgICBpZiAodGhpcy5mZXRjaGVkRU9GKSB7XG4gICAgICAgICAgc2tpcEVvZkNoZWNrID0gdGhpcy5wIDwgdGhpcy50b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBza2lwRW9mQ2hlY2sgPSB0aGlzLnAgPCB0aGlzLnRva2Vucy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNraXBFb2ZDaGVjayA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFza2lwRW9mQ2hlY2sgJiYgdGhpcy5MQSgxKSA9PT0gVG9rZW5fMS5Ub2tlbi5FT0YpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGNvbnN1bWUgRU9GXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3luYyh0aGlzLnAgKyAxKSkge1xuICAgICAgICB0aGlzLnAgPSB0aGlzLmFkanVzdFNlZWtJbmRleCh0aGlzLnAgKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3luYyhpKSB7XG4gICAgICBhc3NlcnQoaSA+PSAwKTtcbiAgICAgIGxldCBuID0gaSAtIHRoaXMudG9rZW5zLmxlbmd0aCArIDE7XG4gICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgbGV0IGZldGNoZWQgPSB0aGlzLmZldGNoKG4pO1xuICAgICAgICByZXR1cm4gZmV0Y2hlZCA+PSBuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZldGNoKG4pIHtcbiAgICAgIGlmICh0aGlzLmZldGNoZWRFT0YpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBsZXQgdCA9IHRoaXMudG9rZW5Tb3VyY2UubmV4dFRva2VuKCk7XG4gICAgICAgIGlmICh0aGlzLmlzV3JpdGFibGVUb2tlbih0KSkge1xuICAgICAgICAgIHQudG9rZW5JbmRleCA9IHRoaXMudG9rZW5zLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHQpO1xuICAgICAgICBpZiAodC50eXBlID09PSBUb2tlbl8xLlRva2VuLkVPRikge1xuICAgICAgICAgIHRoaXMuZmV0Y2hlZEVPRiA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgZ2V0KGkpIHtcbiAgICAgIGlmIChpIDwgMCB8fCBpID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInRva2VuIGluZGV4IFwiICsgaSArIFwiIG91dCBvZiByYW5nZSAwLi5cIiArICh0aGlzLnRva2Vucy5sZW5ndGggLSAxKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnNbaV07XG4gICAgfVxuICAgIGdldFJhbmdlKHN0YXJ0LCBzdG9wKSB7XG4gICAgICBpZiAoc3RhcnQgPCAwIHx8IHN0b3AgPCAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGF6eUluaXQoKTtcbiAgICAgIGxldCBzdWJzZXQgPSBuZXcgQXJyYXkoKTtcbiAgICAgIGlmIChzdG9wID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICBzdG9wID0gdGhpcy50b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8PSBzdG9wOyBpKyspIHtcbiAgICAgICAgbGV0IHQgPSB0aGlzLnRva2Vuc1tpXTtcbiAgICAgICAgaWYgKHQudHlwZSA9PT0gVG9rZW5fMS5Ub2tlbi5FT0YpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdWJzZXQucHVzaCh0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdWJzZXQ7XG4gICAgfVxuICAgIExBKGkpIHtcbiAgICAgIGxldCB0b2tlbiA9IHRoaXMuTFQoaSk7XG4gICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgIHJldHVybiBUb2tlbl8xLlRva2VuLklOVkFMSURfVFlQRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b2tlbi50eXBlO1xuICAgIH1cbiAgICB0cnlMQihrKSB7XG4gICAgICBpZiAodGhpcy5wIC0gayA8IDApIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLnAgLSBrXTtcbiAgICB9XG4gICAgTFQoaykge1xuICAgICAgbGV0IHJlc3VsdCA9IHRoaXMudHJ5TFQoayk7XG4gICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJyZXF1ZXN0ZWQgbG9va2JhY2sgaW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdHJ5TFQoaykge1xuICAgICAgdGhpcy5sYXp5SW5pdCgpO1xuICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCIwIGlzIG5vdCBhIHZhbGlkIGxvb2thaGVhZCBpbmRleFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cnlMQigtayk7XG4gICAgICB9XG4gICAgICBsZXQgaSA9IHRoaXMucCArIGsgLSAxO1xuICAgICAgdGhpcy5zeW5jKGkpO1xuICAgICAgaWYgKGkgPj0gdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLnRva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRva2Vuc1tpXTtcbiAgICB9XG4gICAgYWRqdXN0U2Vla0luZGV4KGkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICBsYXp5SW5pdCgpIHtcbiAgICAgIGlmICh0aGlzLnAgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuc2V0dXAoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0dXAoKSB7XG4gICAgICB0aGlzLnN5bmMoMCk7XG4gICAgICB0aGlzLnAgPSB0aGlzLmFkanVzdFNlZWtJbmRleCgwKTtcbiAgICB9XG4gICAgZ2V0VG9rZW5zKHN0YXJ0LCBzdG9wLCB0eXBlcykge1xuICAgICAgdGhpcy5sYXp5SW5pdCgpO1xuICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHtcbiAgICAgICAgYXNzZXJ0KHN0b3AgPT09IHZvaWQgMCAmJiB0eXBlcyA9PT0gdm9pZCAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zO1xuICAgICAgfSBlbHNlIGlmIChzdG9wID09PSB2b2lkIDApIHtcbiAgICAgICAgc3RvcCA9IHRoaXMudG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPCAwIHx8IHN0b3AgPj0gdGhpcy50b2tlbnMubGVuZ3RoIHx8IHN0b3AgPCAwIHx8IHN0YXJ0ID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInN0YXJ0IFwiICsgc3RhcnQgKyBcIiBvciBzdG9wIFwiICsgc3RvcCArIFwiIG5vdCBpbiAwLi5cIiArICh0aGlzLnRva2Vucy5sZW5ndGggLSAxKSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPiBzdG9wKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2Vucy5zbGljZShzdGFydCwgc3RvcCArIDEpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdHlwZXMgPSBuZXcgU2V0KCkuYWRkKHR5cGVzKTtcbiAgICAgIH1cbiAgICAgIGxldCB0eXBlc1NldCA9IHR5cGVzO1xuICAgICAgbGV0IGZpbHRlcmVkVG9rZW5zID0gdGhpcy50b2tlbnMuc2xpY2Uoc3RhcnQsIHN0b3AgKyAxKTtcbiAgICAgIGZpbHRlcmVkVG9rZW5zID0gZmlsdGVyZWRUb2tlbnMuZmlsdGVyKCh2YWx1ZSkgPT4gdHlwZXNTZXQuaGFzKHZhbHVlLnR5cGUpKTtcbiAgICAgIHJldHVybiBmaWx0ZXJlZFRva2VucztcbiAgICB9XG4gICAgbmV4dFRva2VuT25DaGFubmVsKGksIGNoYW5uZWwpIHtcbiAgICAgIHRoaXMuc3luYyhpKTtcbiAgICAgIGlmIChpID49IHRoaXMuc2l6ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplIC0gMTtcbiAgICAgIH1cbiAgICAgIGxldCB0b2tlbiA9IHRoaXMudG9rZW5zW2ldO1xuICAgICAgd2hpbGUgKHRva2VuLmNoYW5uZWwgIT09IGNoYW5uZWwpIHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuXzEuVG9rZW4uRU9GKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgICAgICB0aGlzLnN5bmMoaSk7XG4gICAgICAgIHRva2VuID0gdGhpcy50b2tlbnNbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgcHJldmlvdXNUb2tlbk9uQ2hhbm5lbChpLCBjaGFubmVsKSB7XG4gICAgICB0aGlzLnN5bmMoaSk7XG4gICAgICBpZiAoaSA+PSB0aGlzLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSAtIDE7XG4gICAgICB9XG4gICAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICAgIGxldCB0b2tlbiA9IHRoaXMudG9rZW5zW2ldO1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5fMS5Ub2tlbi5FT0YgfHwgdG9rZW4uY2hhbm5lbCA9PT0gY2hhbm5lbCkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICBnZXRIaWRkZW5Ub2tlbnNUb1JpZ2h0KHRva2VuSW5kZXgsIGNoYW5uZWwgPSAtMSkge1xuICAgICAgdGhpcy5sYXp5SW5pdCgpO1xuICAgICAgaWYgKHRva2VuSW5kZXggPCAwIHx8IHRva2VuSW5kZXggPj0gdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHRva2VuSW5kZXggKyBcIiBub3QgaW4gMC4uXCIgKyAodGhpcy50b2tlbnMubGVuZ3RoIC0gMSkpO1xuICAgICAgfVxuICAgICAgbGV0IG5leHRPbkNoYW5uZWwgPSB0aGlzLm5leHRUb2tlbk9uQ2hhbm5lbCh0b2tlbkluZGV4ICsgMSwgTGV4ZXJfMS5MZXhlci5ERUZBVUxUX1RPS0VOX0NIQU5ORUwpO1xuICAgICAgbGV0IHRvO1xuICAgICAgbGV0IGZyb20gPSB0b2tlbkluZGV4ICsgMTtcbiAgICAgIGlmIChuZXh0T25DaGFubmVsID09PSAtMSkge1xuICAgICAgICB0byA9IHRoaXMuc2l6ZSAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0byA9IG5leHRPbkNoYW5uZWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXJGb3JDaGFubmVsKGZyb20sIHRvLCBjaGFubmVsKTtcbiAgICB9XG4gICAgZ2V0SGlkZGVuVG9rZW5zVG9MZWZ0KHRva2VuSW5kZXgsIGNoYW5uZWwgPSAtMSkge1xuICAgICAgdGhpcy5sYXp5SW5pdCgpO1xuICAgICAgaWYgKHRva2VuSW5kZXggPCAwIHx8IHRva2VuSW5kZXggPj0gdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHRva2VuSW5kZXggKyBcIiBub3QgaW4gMC4uXCIgKyAodGhpcy50b2tlbnMubGVuZ3RoIC0gMSkpO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuSW5kZXggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbGV0IHByZXZPbkNoYW5uZWwgPSB0aGlzLnByZXZpb3VzVG9rZW5PbkNoYW5uZWwodG9rZW5JbmRleCAtIDEsIExleGVyXzEuTGV4ZXIuREVGQVVMVF9UT0tFTl9DSEFOTkVMKTtcbiAgICAgIGlmIChwcmV2T25DaGFubmVsID09PSB0b2tlbkluZGV4IC0gMSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBsZXQgZnJvbSA9IHByZXZPbkNoYW5uZWwgKyAxO1xuICAgICAgbGV0IHRvID0gdG9rZW5JbmRleCAtIDE7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXJGb3JDaGFubmVsKGZyb20sIHRvLCBjaGFubmVsKTtcbiAgICB9XG4gICAgZmlsdGVyRm9yQ2hhbm5lbChmcm9tLCB0bywgY2hhbm5lbCkge1xuICAgICAgbGV0IGhpZGRlbiA9IG5ldyBBcnJheSgpO1xuICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPD0gdG87IGkrKykge1xuICAgICAgICBsZXQgdCA9IHRoaXMudG9rZW5zW2ldO1xuICAgICAgICBpZiAoY2hhbm5lbCA9PT0gLTEpIHtcbiAgICAgICAgICBpZiAodC5jaGFubmVsICE9PSBMZXhlcl8xLkxleGVyLkRFRkFVTFRfVE9LRU5fQ0hBTk5FTCkge1xuICAgICAgICAgICAgaGlkZGVuLnB1c2godCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0LmNoYW5uZWwgPT09IGNoYW5uZWwpIHtcbiAgICAgICAgICAgIGhpZGRlbi5wdXNoKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhpZGRlbjtcbiAgICB9XG4gICAgZ2V0IHNvdXJjZU5hbWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlblNvdXJjZS5zb3VyY2VOYW1lO1xuICAgIH1cbiAgICBnZXRUZXh0KGludGVydmFsKSB7XG4gICAgICBpZiAoaW50ZXJ2YWwgPT09IHZvaWQgMCkge1xuICAgICAgICBpbnRlcnZhbCA9IEludGVydmFsXzEuSW50ZXJ2YWwub2YoMCwgdGhpcy5zaXplIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKCEoaW50ZXJ2YWwgaW5zdGFuY2VvZiBJbnRlcnZhbF8xLkludGVydmFsKSkge1xuICAgICAgICBpbnRlcnZhbCA9IGludGVydmFsLnNvdXJjZUludGVydmFsO1xuICAgICAgfVxuICAgICAgbGV0IHN0YXJ0ID0gaW50ZXJ2YWwuYTtcbiAgICAgIGxldCBzdG9wID0gaW50ZXJ2YWwuYjtcbiAgICAgIGlmIChzdGFydCA8IDAgfHwgc3RvcCA8IDApIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICB0aGlzLmZpbGwoKTtcbiAgICAgIGlmIChzdG9wID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICBzdG9wID0gdGhpcy50b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICAgIGxldCBidWYgPSBcIlwiO1xuICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IHN0b3A7IGkrKykge1xuICAgICAgICBsZXQgdCA9IHRoaXMudG9rZW5zW2ldO1xuICAgICAgICBpZiAodC50eXBlID09PSBUb2tlbl8xLlRva2VuLkVPRikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZiArPSB0LnRleHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGdldFRleHRGcm9tUmFuZ2Uoc3RhcnQsIHN0b3ApIHtcbiAgICAgIGlmICh0aGlzLmlzVG9rZW4oc3RhcnQpICYmIHRoaXMuaXNUb2tlbihzdG9wKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUZXh0KEludGVydmFsXzEuSW50ZXJ2YWwub2Yoc3RhcnQudG9rZW5JbmRleCwgc3RvcC50b2tlbkluZGV4KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZmlsbCgpIHtcbiAgICAgIHRoaXMubGF6eUluaXQoKTtcbiAgICAgIGNvbnN0IGJsb2NrU2l6ZSA9IDFlMztcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBmZXRjaGVkID0gdGhpcy5mZXRjaChibG9ja1NpemUpO1xuICAgICAgICBpZiAoZmV0Y2hlZCA8IGJsb2NrU2l6ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpc1dyaXRhYmxlVG9rZW4odCkge1xuICAgICAgcmV0dXJuIHQgaW5zdGFuY2VvZiBDb21tb25Ub2tlbl8xLkNvbW1vblRva2VuO1xuICAgIH1cbiAgICBpc1Rva2VuKHQpIHtcbiAgICAgIHJldHVybiB0IGluc3RhbmNlb2YgQ29tbW9uVG9rZW5fMS5Db21tb25Ub2tlbjtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIEJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlLCBcIl90b2tlblNvdXJjZVwiLCB2b2lkIDApO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQnVmZmVyZWRUb2tlblN0cmVhbS5wcm90b3R5cGUsIFwidG9rZW5Tb3VyY2VcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBCdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZSwgXCJpbmRleFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlLCBcIm1hcmtcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBCdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZSwgXCJyZWxlYXNlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQnVmZmVyZWRUb2tlblN0cmVhbS5wcm90b3R5cGUsIFwic2Vla1wiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlLCBcInNpemVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBCdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZSwgXCJjb25zdW1lXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQnVmZmVyZWRUb2tlblN0cmVhbS5wcm90b3R5cGUsIFwiZ2V0XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQnVmZmVyZWRUb2tlblN0cmVhbS5wcm90b3R5cGUsIFwiTEFcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsLFxuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBCdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZSwgXCJMVFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlLCBcInNvdXJjZU5hbWVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsLFxuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBCdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZSwgXCJnZXRUZXh0XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbCxcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQnVmZmVyZWRUb2tlblN0cmVhbS5wcm90b3R5cGUsIFwiZ2V0VGV4dEZyb21SYW5nZVwiLCBudWxsKTtcbiAgQnVmZmVyZWRUb2tlblN0cmVhbSA9IF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIEJ1ZmZlcmVkVG9rZW5TdHJlYW0pO1xuICBleHBvcnRzLkJ1ZmZlcmVkVG9rZW5TdHJlYW0gPSBCdWZmZXJlZFRva2VuU3RyZWFtO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9Db21tb25Ub2tlblN0cmVhbS5qc1xudmFyIHJlcXVpcmVfQ29tbW9uVG9rZW5TdHJlYW0gPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuQ29tbW9uVG9rZW5TdHJlYW0gPSB2b2lkIDA7XG4gIHZhciBCdWZmZXJlZFRva2VuU3RyZWFtXzEgPSByZXF1aXJlX0J1ZmZlcmVkVG9rZW5TdHJlYW0oKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgVG9rZW5fMSA9IHJlcXVpcmVfVG9rZW4oKTtcbiAgdmFyIENvbW1vblRva2VuU3RyZWFtMiA9IGNsYXNzIENvbW1vblRva2VuU3RyZWFtIGV4dGVuZHMgQnVmZmVyZWRUb2tlblN0cmVhbV8xLkJ1ZmZlcmVkVG9rZW5TdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKHRva2VuU291cmNlLCBjaGFubmVsID0gVG9rZW5fMS5Ub2tlbi5ERUZBVUxUX0NIQU5ORUwpIHtcbiAgICAgIHN1cGVyKHRva2VuU291cmNlKTtcbiAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgfVxuICAgIGFkanVzdFNlZWtJbmRleChpKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW5PbkNoYW5uZWwoaSwgdGhpcy5jaGFubmVsKTtcbiAgICB9XG4gICAgdHJ5TEIoaykge1xuICAgICAgaWYgKHRoaXMucCAtIGsgPCAwKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBsZXQgaSA9IHRoaXMucDtcbiAgICAgIGxldCBuID0gMTtcbiAgICAgIHdoaWxlIChuIDw9IGsgJiYgaSA+IDApIHtcbiAgICAgICAgaSA9IHRoaXMucHJldmlvdXNUb2tlbk9uQ2hhbm5lbChpIC0gMSwgdGhpcy5jaGFubmVsKTtcbiAgICAgICAgbisrO1xuICAgICAgfVxuICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnNbaV07XG4gICAgfVxuICAgIHRyeUxUKGspIHtcbiAgICAgIHRoaXMubGF6eUluaXQoKTtcbiAgICAgIGlmIChrID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiMCBpcyBub3QgYSB2YWxpZCBsb29rYWhlYWQgaW5kZXhcIik7XG4gICAgICB9XG4gICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJ5TEIoLWspO1xuICAgICAgfVxuICAgICAgbGV0IGkgPSB0aGlzLnA7XG4gICAgICBsZXQgbiA9IDE7XG4gICAgICB3aGlsZSAobiA8IGspIHtcbiAgICAgICAgaWYgKHRoaXMuc3luYyhpICsgMSkpIHtcbiAgICAgICAgICBpID0gdGhpcy5uZXh0VG9rZW5PbkNoYW5uZWwoaSArIDEsIHRoaXMuY2hhbm5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgbisrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW2ldO1xuICAgIH1cbiAgICBnZXROdW1iZXJPZk9uQ2hhbm5lbFRva2VucygpIHtcbiAgICAgIGxldCBuID0gMDtcbiAgICAgIHRoaXMuZmlsbCgpO1xuICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLnRva2Vucykge1xuICAgICAgICBpZiAodC5jaGFubmVsID09PSB0aGlzLmNoYW5uZWwpIHtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQudHlwZSA9PT0gVG9rZW5fMS5Ub2tlbi5FT0YpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQ29tbW9uVG9rZW5TdHJlYW0yLnByb3RvdHlwZSwgXCJhZGp1c3RTZWVrSW5kZXhcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBDb21tb25Ub2tlblN0cmVhbTIucHJvdG90eXBlLCBcInRyeUxCXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQ29tbW9uVG9rZW5TdHJlYW0yLnByb3RvdHlwZSwgXCJ0cnlMVFwiLCBudWxsKTtcbiAgQ29tbW9uVG9rZW5TdHJlYW0yID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgQ29tbW9uVG9rZW5TdHJlYW0yKTtcbiAgZXhwb3J0cy5Db21tb25Ub2tlblN0cmVhbSA9IENvbW1vblRva2VuU3RyZWFtMjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvTGlzdFRva2VuU291cmNlLmpzXG52YXIgcmVxdWlyZV9MaXN0VG9rZW5Tb3VyY2UgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuTGlzdFRva2VuU291cmNlID0gdm9pZCAwO1xuICB2YXIgQ29tbW9uVG9rZW5GYWN0b3J5XzEgPSByZXF1aXJlX0NvbW1vblRva2VuRmFjdG9yeSgpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBUb2tlbl8xID0gcmVxdWlyZV9Ub2tlbigpO1xuICB2YXIgTGlzdFRva2VuU291cmNlID0gY2xhc3MgTGlzdFRva2VuU291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbnMyLCBzb3VyY2VOYW1lKSB7XG4gICAgICB0aGlzLmkgPSAwO1xuICAgICAgdGhpcy5fZmFjdG9yeSA9IENvbW1vblRva2VuRmFjdG9yeV8xLkNvbW1vblRva2VuRmFjdG9yeS5ERUZBVUxUO1xuICAgICAgaWYgKHRva2VuczIgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b2tlbnMgY2Fubm90IGJlIG51bGxcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnRva2VucyA9IHRva2VuczI7XG4gICAgICB0aGlzLl9zb3VyY2VOYW1lID0gc291cmNlTmFtZTtcbiAgICB9XG4gICAgZ2V0IGNoYXJQb3NpdGlvbkluTGluZSgpIHtcbiAgICAgIGlmICh0aGlzLmkgPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuaV0uY2hhclBvc2l0aW9uSW5MaW5lO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmVvZlRva2VuICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW9mVG9rZW4uY2hhclBvc2l0aW9uSW5MaW5lO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBsYXN0VG9rZW4gPSB0aGlzLnRva2Vuc1t0aGlzLnRva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgbGV0IHRva2VuVGV4dCA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICBpZiAodG9rZW5UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICBsZXQgbGFzdE5ld0xpbmUgPSB0b2tlblRleHQubGFzdEluZGV4T2YoXCJcXG5cIik7XG4gICAgICAgICAgaWYgKGxhc3ROZXdMaW5lID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlblRleHQubGVuZ3RoIC0gbGFzdE5ld0xpbmUgLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFzdFRva2VuLmNoYXJQb3NpdGlvbkluTGluZSArIGxhc3RUb2tlbi5zdG9wSW5kZXggLSBsYXN0VG9rZW4uc3RhcnRJbmRleCArIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgbmV4dFRva2VuKCkge1xuICAgICAgaWYgKHRoaXMuaSA+PSB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuZW9mVG9rZW4gPT0gbnVsbCkge1xuICAgICAgICAgIGxldCBzdGFydCA9IC0xO1xuICAgICAgICAgIGlmICh0aGlzLnRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNTdG9wID0gdGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV0uc3RvcEluZGV4O1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzU3RvcCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBwcmV2aW91c1N0b3AgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgc3RvcCA9IE1hdGgubWF4KC0xLCBzdGFydCAtIDEpO1xuICAgICAgICAgIHRoaXMuZW9mVG9rZW4gPSB0aGlzLl9mYWN0b3J5LmNyZWF0ZSh7c291cmNlOiB0aGlzLCBzdHJlYW06IHRoaXMuaW5wdXRTdHJlYW19LCBUb2tlbl8xLlRva2VuLkVPRiwgXCJFT0ZcIiwgVG9rZW5fMS5Ub2tlbi5ERUZBVUxUX0NIQU5ORUwsIHN0YXJ0LCBzdG9wLCB0aGlzLmxpbmUsIHRoaXMuY2hhclBvc2l0aW9uSW5MaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lb2ZUb2tlbjtcbiAgICAgIH1cbiAgICAgIGxldCB0ID0gdGhpcy50b2tlbnNbdGhpcy5pXTtcbiAgICAgIGlmICh0aGlzLmkgPT09IHRoaXMudG9rZW5zLmxlbmd0aCAtIDEgJiYgdC50eXBlID09PSBUb2tlbl8xLlRva2VuLkVPRikge1xuICAgICAgICB0aGlzLmVvZlRva2VuID0gdDtcbiAgICAgIH1cbiAgICAgIHRoaXMuaSsrO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICAgIGdldCBsaW5lKCkge1xuICAgICAgaWYgKHRoaXMuaSA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5pXS5saW5lO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmVvZlRva2VuICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW9mVG9rZW4ubGluZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgbGFzdFRva2VuID0gdGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGxldCBsaW5lID0gbGFzdFRva2VuLmxpbmU7XG4gICAgICAgIGxldCB0b2tlblRleHQgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgaWYgKHRva2VuVGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlblRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0b2tlblRleHQuY2hhckF0KGkpID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICB9XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZ2V0IGlucHV0U3RyZWFtKCkge1xuICAgICAgaWYgKHRoaXMuaSA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5pXS5pbnB1dFN0cmVhbTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5lb2ZUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVvZlRva2VuLmlucHV0U3RyZWFtO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLnRva2Vucy5sZW5ndGggLSAxXS5pbnB1dFN0cmVhbTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGdldCBzb3VyY2VOYW1lKCkge1xuICAgICAgaWYgKHRoaXMuX3NvdXJjZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZU5hbWU7XG4gICAgICB9XG4gICAgICBsZXQgaW5wdXRTdHJlYW0gPSB0aGlzLmlucHV0U3RyZWFtO1xuICAgICAgaWYgKGlucHV0U3RyZWFtICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0U3RyZWFtLnNvdXJjZU5hbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJMaXN0XCI7XG4gICAgfVxuICAgIHNldCB0b2tlbkZhY3RvcnkoZmFjdG9yeSkge1xuICAgICAgdGhpcy5fZmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgfVxuICAgIGdldCB0b2tlbkZhY3RvcnkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmFjdG9yeTtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBMaXN0VG9rZW5Tb3VyY2UucHJvdG90eXBlLCBcImNoYXJQb3NpdGlvbkluTGluZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExpc3RUb2tlblNvdXJjZS5wcm90b3R5cGUsIFwibmV4dFRva2VuXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGlzdFRva2VuU291cmNlLnByb3RvdHlwZSwgXCJsaW5lXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgTGlzdFRva2VuU291cmNlLnByb3RvdHlwZSwgXCJpbnB1dFN0cmVhbVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIExpc3RUb2tlblNvdXJjZS5wcm90b3R5cGUsIFwic291cmNlTmFtZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlLFxuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsLFxuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIExpc3RUb2tlblNvdXJjZS5wcm90b3R5cGUsIFwidG9rZW5GYWN0b3J5XCIsIG51bGwpO1xuICBMaXN0VG9rZW5Tb3VyY2UgPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBMaXN0VG9rZW5Tb3VyY2UpO1xuICBleHBvcnRzLkxpc3RUb2tlblNvdXJjZSA9IExpc3RUb2tlblNvdXJjZTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvbWlzYy9NdWx0aU1hcC5qc1xudmFyIHJlcXVpcmVfTXVsdGlNYXAgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLk11bHRpTWFwID0gdm9pZCAwO1xuICB2YXIgTXVsdGlNYXAgPSBjbGFzcyBleHRlbmRzIE1hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgIH1cbiAgICBtYXAoa2V5LCB2YWx1ZSkge1xuICAgICAgbGV0IGVsZW1lbnRzRm9yS2V5ID0gc3VwZXIuZ2V0KGtleSk7XG4gICAgICBpZiAoIWVsZW1lbnRzRm9yS2V5KSB7XG4gICAgICAgIGVsZW1lbnRzRm9yS2V5ID0gW107XG4gICAgICAgIHN1cGVyLnNldChrZXksIGVsZW1lbnRzRm9yS2V5KTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnRzRm9yS2V5LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBnZXRQYWlycygpIHtcbiAgICAgIGxldCBwYWlycyA9IFtdO1xuICAgICAgdGhpcy5mb3JFYWNoKCh2YWx1ZXMsIGtleSkgPT4ge1xuICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgdl0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBhaXJzO1xuICAgIH1cbiAgfTtcbiAgZXhwb3J0cy5NdWx0aU1hcCA9IE11bHRpTWFwO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9taXNjL1BhcnNlQ2FuY2VsbGF0aW9uRXhjZXB0aW9uLmpzXG52YXIgcmVxdWlyZV9QYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbiA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb24gPSB2b2lkIDA7XG4gIHZhciBQYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbiA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNhdXNlKSB7XG4gICAgICBzdXBlcihjYXVzZS5tZXNzYWdlKTtcbiAgICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICAgIHRoaXMuc3RhY2sgPSBjYXVzZS5zdGFjaztcbiAgICB9XG4gICAgZ2V0Q2F1c2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYXVzZTtcbiAgICB9XG4gIH07XG4gIGV4cG9ydHMuUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb24gPSBQYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvSW50ZXJwcmV0ZXJSdWxlQ29udGV4dC5qc1xudmFyIHJlcXVpcmVfSW50ZXJwcmV0ZXJSdWxlQ29udGV4dCA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5JbnRlcnByZXRlclJ1bGVDb250ZXh0ID0gdm9pZCAwO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBQYXJzZXJSdWxlQ29udGV4dF8xID0gcmVxdWlyZV9QYXJzZXJSdWxlQ29udGV4dCgpO1xuICB2YXIgSW50ZXJwcmV0ZXJSdWxlQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgUGFyc2VyUnVsZUNvbnRleHRfMS5QYXJzZXJSdWxlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocnVsZUluZGV4LCBwYXJlbnQsIGludm9raW5nU3RhdGVOdW1iZXIpIHtcbiAgICAgIGlmIChpbnZva2luZ1N0YXRlTnVtYmVyICE9PSB2b2lkIDApIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlTnVtYmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9ydWxlSW5kZXggPSBydWxlSW5kZXg7XG4gICAgfVxuICAgIGdldCBydWxlSW5kZXgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVsZUluZGV4O1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEludGVycHJldGVyUnVsZUNvbnRleHQucHJvdG90eXBlLCBcInJ1bGVJbmRleFwiLCBudWxsKTtcbiAgZXhwb3J0cy5JbnRlcnByZXRlclJ1bGVDb250ZXh0ID0gSW50ZXJwcmV0ZXJSdWxlQ29udGV4dDtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvUGFyc2VySW50ZXJwcmV0ZXIuanNcbnZhciByZXF1aXJlX1BhcnNlckludGVycHJldGVyID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLlBhcnNlckludGVycHJldGVyID0gdm9pZCAwO1xuICB2YXIgQVROU3RhdGVfMSA9IHJlcXVpcmVfQVROU3RhdGUoKTtcbiAgdmFyIEFUTlN0YXRlVHlwZV8xID0gcmVxdWlyZV9BVE5TdGF0ZVR5cGUoKTtcbiAgdmFyIEJpdFNldF8xID0gcmVxdWlyZV9CaXRTZXQoKTtcbiAgdmFyIEZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbl8xID0gcmVxdWlyZV9GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24oKTtcbiAgdmFyIElucHV0TWlzbWF0Y2hFeGNlcHRpb25fMSA9IHJlcXVpcmVfSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbigpO1xuICB2YXIgSW50ZXJwcmV0ZXJSdWxlQ29udGV4dF8xID0gcmVxdWlyZV9JbnRlcnByZXRlclJ1bGVDb250ZXh0KCk7XG4gIHZhciBMb29wRW5kU3RhdGVfMSA9IHJlcXVpcmVfTG9vcEVuZFN0YXRlKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIERlY29yYXRvcnNfMiA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgUGFyc2VyXzEgPSByZXF1aXJlX1BhcnNlcigpO1xuICB2YXIgUGFyc2VyQVROU2ltdWxhdG9yXzEgPSByZXF1aXJlX1BhcnNlckFUTlNpbXVsYXRvcigpO1xuICB2YXIgUmVjb2duaXRpb25FeGNlcHRpb25fMSA9IHJlcXVpcmVfUmVjb2duaXRpb25FeGNlcHRpb24oKTtcbiAgdmFyIFN0YXJMb29wRW50cnlTdGF0ZV8xID0gcmVxdWlyZV9TdGFyTG9vcEVudHJ5U3RhdGUoKTtcbiAgdmFyIFRva2VuXzEgPSByZXF1aXJlX1Rva2VuKCk7XG4gIHZhciBQYXJzZXJJbnRlcnByZXRlciA9IGNsYXNzIFBhcnNlckludGVycHJldGVyMiBleHRlbmRzIFBhcnNlcl8xLlBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoZ3JhbW1hckZpbGVOYW1lLCB2b2NhYnVsYXJ5LCBydWxlTmFtZXMsIGF0biwgaW5wdXQpIHtcbiAgICAgIHN1cGVyKGdyYW1tYXJGaWxlTmFtZSBpbnN0YW5jZW9mIFBhcnNlckludGVycHJldGVyMiA/IGdyYW1tYXJGaWxlTmFtZS5pbnB1dFN0cmVhbSA6IGlucHV0KTtcbiAgICAgIHRoaXMuX3BhcmVudENvbnRleHRTdGFjayA9IFtdO1xuICAgICAgdGhpcy5vdmVycmlkZURlY2lzaW9uID0gLTE7XG4gICAgICB0aGlzLm92ZXJyaWRlRGVjaXNpb25JbnB1dEluZGV4ID0gLTE7XG4gICAgICB0aGlzLm92ZXJyaWRlRGVjaXNpb25BbHQgPSAtMTtcbiAgICAgIHRoaXMub3ZlcnJpZGVEZWNpc2lvblJlYWNoZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX292ZXJyaWRlRGVjaXNpb25Sb290ID0gdm9pZCAwO1xuICAgICAgaWYgKGdyYW1tYXJGaWxlTmFtZSBpbnN0YW5jZW9mIFBhcnNlckludGVycHJldGVyMikge1xuICAgICAgICBsZXQgb2xkID0gZ3JhbW1hckZpbGVOYW1lO1xuICAgICAgICB0aGlzLl9ncmFtbWFyRmlsZU5hbWUgPSBvbGQuX2dyYW1tYXJGaWxlTmFtZTtcbiAgICAgICAgdGhpcy5fYXRuID0gb2xkLl9hdG47XG4gICAgICAgIHRoaXMucHVzaFJlY3Vyc2lvbkNvbnRleHRTdGF0ZXMgPSBvbGQucHVzaFJlY3Vyc2lvbkNvbnRleHRTdGF0ZXM7XG4gICAgICAgIHRoaXMuX3J1bGVOYW1lcyA9IG9sZC5fcnVsZU5hbWVzO1xuICAgICAgICB0aGlzLl92b2NhYnVsYXJ5ID0gb2xkLl92b2NhYnVsYXJ5O1xuICAgICAgICB0aGlzLmludGVycHJldGVyID0gbmV3IFBhcnNlckFUTlNpbXVsYXRvcl8xLlBhcnNlckFUTlNpbXVsYXRvcih0aGlzLl9hdG4sIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm9jYWJ1bGFyeSA9IHZvY2FidWxhcnk7XG4gICAgICAgIHJ1bGVOYW1lcyA9IHJ1bGVOYW1lcztcbiAgICAgICAgYXRuID0gYXRuO1xuICAgICAgICB0aGlzLl9ncmFtbWFyRmlsZU5hbWUgPSBncmFtbWFyRmlsZU5hbWU7XG4gICAgICAgIHRoaXMuX2F0biA9IGF0bjtcbiAgICAgICAgdGhpcy5fcnVsZU5hbWVzID0gcnVsZU5hbWVzLnNsaWNlKDApO1xuICAgICAgICB0aGlzLl92b2NhYnVsYXJ5ID0gdm9jYWJ1bGFyeTtcbiAgICAgICAgdGhpcy5wdXNoUmVjdXJzaW9uQ29udGV4dFN0YXRlcyA9IG5ldyBCaXRTZXRfMS5CaXRTZXQoYXRuLnN0YXRlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBzdGF0ZSBvZiBhdG4uc3RhdGVzKSB7XG4gICAgICAgICAgaWYgKCEoc3RhdGUgaW5zdGFuY2VvZiBTdGFyTG9vcEVudHJ5U3RhdGVfMS5TdGFyTG9vcEVudHJ5U3RhdGUpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLnByZWNlZGVuY2VSdWxlRGVjaXNpb24pIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFJlY3Vyc2lvbkNvbnRleHRTdGF0ZXMuc2V0KHN0YXRlLnN0YXRlTnVtYmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnRlcnByZXRlciA9IG5ldyBQYXJzZXJBVE5TaW11bGF0b3JfMS5QYXJzZXJBVE5TaW11bGF0b3IoYXRuLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzZXQocmVzZXRJbnB1dCkge1xuICAgICAgaWYgKHJlc2V0SW5wdXQgPT09IHZvaWQgMCkge1xuICAgICAgICBzdXBlci5yZXNldCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VwZXIucmVzZXQocmVzZXRJbnB1dCk7XG4gICAgICB9XG4gICAgICB0aGlzLm92ZXJyaWRlRGVjaXNpb25SZWFjaGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9vdmVycmlkZURlY2lzaW9uUm9vdCA9IHZvaWQgMDtcbiAgICB9XG4gICAgZ2V0IGF0bigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hdG47XG4gICAgfVxuICAgIGdldCB2b2NhYnVsYXJ5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZvY2FidWxhcnk7XG4gICAgfVxuICAgIGdldCBydWxlTmFtZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVsZU5hbWVzO1xuICAgIH1cbiAgICBnZXQgZ3JhbW1hckZpbGVOYW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dyYW1tYXJGaWxlTmFtZTtcbiAgICB9XG4gICAgcGFyc2Uoc3RhcnRSdWxlSW5kZXgpIHtcbiAgICAgIGxldCBzdGFydFJ1bGVTdGFydFN0YXRlID0gdGhpcy5fYXRuLnJ1bGVUb1N0YXJ0U3RhdGVbc3RhcnRSdWxlSW5kZXhdO1xuICAgICAgdGhpcy5fcm9vdENvbnRleHQgPSB0aGlzLmNyZWF0ZUludGVycHJldGVyUnVsZUNvbnRleHQodm9pZCAwLCBBVE5TdGF0ZV8xLkFUTlN0YXRlLklOVkFMSURfU1RBVEVfTlVNQkVSLCBzdGFydFJ1bGVJbmRleCk7XG4gICAgICBpZiAoc3RhcnRSdWxlU3RhcnRTdGF0ZS5pc1ByZWNlZGVuY2VSdWxlKSB7XG4gICAgICAgIHRoaXMuZW50ZXJSZWN1cnNpb25SdWxlKHRoaXMuX3Jvb3RDb250ZXh0LCBzdGFydFJ1bGVTdGFydFN0YXRlLnN0YXRlTnVtYmVyLCBzdGFydFJ1bGVJbmRleCwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVudGVyUnVsZSh0aGlzLl9yb290Q29udGV4dCwgc3RhcnRSdWxlU3RhcnRTdGF0ZS5zdGF0ZU51bWJlciwgc3RhcnRSdWxlSW5kZXgpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IHAgPSB0aGlzLmF0blN0YXRlO1xuICAgICAgICBzd2l0Y2ggKHAuc3RhdGVUeXBlKSB7XG4gICAgICAgICAgY2FzZSBBVE5TdGF0ZVR5cGVfMS5BVE5TdGF0ZVR5cGUuUlVMRV9TVE9QOlxuICAgICAgICAgICAgaWYgKHRoaXMuX2N0eC5pc0VtcHR5KSB7XG4gICAgICAgICAgICAgIGlmIChzdGFydFJ1bGVTdGFydFN0YXRlLmlzUHJlY2VkZW5jZVJ1bGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnRDb250ZXh0ID0gdGhpcy5fcGFyZW50Q29udGV4dFN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMudW5yb2xsUmVjdXJzaW9uQ29udGV4dHMocGFyZW50Q29udGV4dFswXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RDb250ZXh0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpc2l0UnVsZVN0b3BTdGF0ZShwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0aGlzLnZpc2l0U3RhdGUocCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUmVjb2duaXRpb25FeGNlcHRpb25fMS5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLl9hdG4ucnVsZVRvU3RvcFN0YXRlW3AucnVsZUluZGV4XS5zdGF0ZU51bWJlcjtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZXhjZXB0aW9uID0gZTtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY292ZXIoZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZW50ZXJSZWN1cnNpb25SdWxlKGxvY2FsY3R4LCBzdGF0ZSwgcnVsZUluZGV4LCBwcmVjZWRlbmNlKSB7XG4gICAgICB0aGlzLl9wYXJlbnRDb250ZXh0U3RhY2sucHVzaChbdGhpcy5fY3R4LCBsb2NhbGN0eC5pbnZva2luZ1N0YXRlXSk7XG4gICAgICBzdXBlci5lbnRlclJlY3Vyc2lvblJ1bGUobG9jYWxjdHgsIHN0YXRlLCBydWxlSW5kZXgsIHByZWNlZGVuY2UpO1xuICAgIH1cbiAgICBnZXQgYXRuU3RhdGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXRuLnN0YXRlc1t0aGlzLnN0YXRlXTtcbiAgICB9XG4gICAgdmlzaXRTdGF0ZShwKSB7XG4gICAgICBsZXQgcHJlZGljdGVkQWx0ID0gMTtcbiAgICAgIGlmIChwLm51bWJlck9mVHJhbnNpdGlvbnMgPiAxKSB7XG4gICAgICAgIHByZWRpY3RlZEFsdCA9IHRoaXMudmlzaXREZWNpc2lvblN0YXRlKHApO1xuICAgICAgfVxuICAgICAgbGV0IHRyYW5zaXRpb24gPSBwLnRyYW5zaXRpb24ocHJlZGljdGVkQWx0IC0gMSk7XG4gICAgICBzd2l0Y2ggKHRyYW5zaXRpb24uc2VyaWFsaXphdGlvblR5cGUpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmICh0aGlzLnB1c2hSZWN1cnNpb25Db250ZXh0U3RhdGVzLmdldChwLnN0YXRlTnVtYmVyKSAmJiAhKHRyYW5zaXRpb24udGFyZ2V0IGluc3RhbmNlb2YgTG9vcEVuZFN0YXRlXzEuTG9vcEVuZFN0YXRlKSkge1xuICAgICAgICAgICAgbGV0IHBhcmVudENvbnRleHQgPSB0aGlzLl9wYXJlbnRDb250ZXh0U3RhY2tbdGhpcy5fcGFyZW50Q29udGV4dFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgbGV0IGxvY2FsY3R4ID0gdGhpcy5jcmVhdGVJbnRlcnByZXRlclJ1bGVDb250ZXh0KHBhcmVudENvbnRleHRbMF0sIHBhcmVudENvbnRleHRbMV0sIHRoaXMuX2N0eC5ydWxlSW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eCwgdGhpcy5fYXRuLnJ1bGVUb1N0YXJ0U3RhdGVbcC5ydWxlSW5kZXhdLnN0YXRlTnVtYmVyLCB0aGlzLl9jdHgucnVsZUluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICB0aGlzLm1hdGNoKHRyYW5zaXRpb24uX2xhYmVsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIDc6XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBpZiAoIXRyYW5zaXRpb24ubWF0Y2hlcyh0aGlzLl9pbnB1dC5MQSgxKSwgVG9rZW5fMS5Ub2tlbi5NSU5fVVNFUl9UT0tFTl9UWVBFLCA2NTUzNSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb3ZlcklubGluZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm1hdGNoV2lsZGNhcmQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIHRoaXMubWF0Y2hXaWxkY2FyZCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgbGV0IHJ1bGVTdGFydFN0YXRlID0gdHJhbnNpdGlvbi50YXJnZXQ7XG4gICAgICAgICAgbGV0IHJ1bGVJbmRleCA9IHJ1bGVTdGFydFN0YXRlLnJ1bGVJbmRleDtcbiAgICAgICAgICBsZXQgbmV3Y3R4ID0gdGhpcy5jcmVhdGVJbnRlcnByZXRlclJ1bGVDb250ZXh0KHRoaXMuX2N0eCwgcC5zdGF0ZU51bWJlciwgcnVsZUluZGV4KTtcbiAgICAgICAgICBpZiAocnVsZVN0YXJ0U3RhdGUuaXNQcmVjZWRlbmNlUnVsZSkge1xuICAgICAgICAgICAgdGhpcy5lbnRlclJlY3Vyc2lvblJ1bGUobmV3Y3R4LCBydWxlU3RhcnRTdGF0ZS5zdGF0ZU51bWJlciwgcnVsZUluZGV4LCB0cmFuc2l0aW9uLnByZWNlZGVuY2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVudGVyUnVsZShuZXdjdHgsIHRyYW5zaXRpb24udGFyZ2V0LnN0YXRlTnVtYmVyLCBydWxlSW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGxldCBwcmVkaWNhdGVUcmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgICAgICAgICBpZiAoIXRoaXMuc2VtcHJlZCh0aGlzLl9jdHgsIHByZWRpY2F0ZVRyYW5zaXRpb24ucnVsZUluZGV4LCBwcmVkaWNhdGVUcmFuc2l0aW9uLnByZWRJbmRleCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb25fMS5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgbGV0IGFjdGlvblRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgICAgICAgIHRoaXMuYWN0aW9uKHRoaXMuX2N0eCwgYWN0aW9uVHJhbnNpdGlvbi5ydWxlSW5kZXgsIGFjdGlvblRyYW5zaXRpb24uYWN0aW9uSW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIGlmICghdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIHRyYW5zaXRpb24ucHJlY2VkZW5jZSkpIHtcbiAgICAgICAgICAgIGxldCBwcmVjZWRlbmNlID0gdHJhbnNpdGlvbi5wcmVjZWRlbmNlO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbl8xLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBgcHJlY3ByZWQoX2N0eCwgJHtwcmVjZWRlbmNlfSlgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb246IFVucmVjb2duaXplZCBBVE4gdHJhbnNpdGlvbiB0eXBlLlwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUgPSB0cmFuc2l0aW9uLnRhcmdldC5zdGF0ZU51bWJlcjtcbiAgICB9XG4gICAgdmlzaXREZWNpc2lvblN0YXRlKHApIHtcbiAgICAgIGxldCBwcmVkaWN0ZWRBbHQ7XG4gICAgICB0aGlzLmVycm9ySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgbGV0IGRlY2lzaW9uID0gcC5kZWNpc2lvbjtcbiAgICAgIGlmIChkZWNpc2lvbiA9PT0gdGhpcy5vdmVycmlkZURlY2lzaW9uICYmIHRoaXMuX2lucHV0LmluZGV4ID09PSB0aGlzLm92ZXJyaWRlRGVjaXNpb25JbnB1dEluZGV4ICYmICF0aGlzLm92ZXJyaWRlRGVjaXNpb25SZWFjaGVkKSB7XG4gICAgICAgIHByZWRpY3RlZEFsdCA9IHRoaXMub3ZlcnJpZGVEZWNpc2lvbkFsdDtcbiAgICAgICAgdGhpcy5vdmVycmlkZURlY2lzaW9uUmVhY2hlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVkaWN0ZWRBbHQgPSB0aGlzLmludGVycHJldGVyLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwgZGVjaXNpb24sIHRoaXMuX2N0eCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJlZGljdGVkQWx0O1xuICAgIH1cbiAgICBjcmVhdGVJbnRlcnByZXRlclJ1bGVDb250ZXh0KHBhcmVudCwgaW52b2tpbmdTdGF0ZU51bWJlciwgcnVsZUluZGV4KSB7XG4gICAgICByZXR1cm4gbmV3IEludGVycHJldGVyUnVsZUNvbnRleHRfMS5JbnRlcnByZXRlclJ1bGVDb250ZXh0KHJ1bGVJbmRleCwgcGFyZW50LCBpbnZva2luZ1N0YXRlTnVtYmVyKTtcbiAgICB9XG4gICAgdmlzaXRSdWxlU3RvcFN0YXRlKHApIHtcbiAgICAgIGxldCBydWxlU3RhcnRTdGF0ZSA9IHRoaXMuX2F0bi5ydWxlVG9TdGFydFN0YXRlW3AucnVsZUluZGV4XTtcbiAgICAgIGlmIChydWxlU3RhcnRTdGF0ZS5pc1ByZWNlZGVuY2VSdWxlKSB7XG4gICAgICAgIGxldCBwYXJlbnRDb250ZXh0ID0gdGhpcy5fcGFyZW50Q29udGV4dFN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLnVucm9sbFJlY3Vyc2lvbkNvbnRleHRzKHBhcmVudENvbnRleHRbMF0pO1xuICAgICAgICB0aGlzLnN0YXRlID0gcGFyZW50Q29udGV4dFsxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICAgIH1cbiAgICAgIGxldCBydWxlVHJhbnNpdGlvbiA9IHRoaXMuX2F0bi5zdGF0ZXNbdGhpcy5zdGF0ZV0udHJhbnNpdGlvbigwKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBydWxlVHJhbnNpdGlvbi5mb2xsb3dTdGF0ZS5zdGF0ZU51bWJlcjtcbiAgICB9XG4gICAgYWRkRGVjaXNpb25PdmVycmlkZShkZWNpc2lvbiwgdG9rZW5JbmRleCwgZm9yY2VkQWx0KSB7XG4gICAgICB0aGlzLm92ZXJyaWRlRGVjaXNpb24gPSBkZWNpc2lvbjtcbiAgICAgIHRoaXMub3ZlcnJpZGVEZWNpc2lvbklucHV0SW5kZXggPSB0b2tlbkluZGV4O1xuICAgICAgdGhpcy5vdmVycmlkZURlY2lzaW9uQWx0ID0gZm9yY2VkQWx0O1xuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGVEZWNpc2lvblJvb3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb3ZlcnJpZGVEZWNpc2lvblJvb3Q7XG4gICAgfVxuICAgIHJlY292ZXIoZSkge1xuICAgICAgbGV0IGkgPSB0aGlzLl9pbnB1dC5pbmRleDtcbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyLnJlY292ZXIodGhpcywgZSk7XG4gICAgICBpZiAodGhpcy5faW5wdXQuaW5kZXggPT09IGkpIHtcbiAgICAgICAgbGV0IHRvayA9IGUuZ2V0T2ZmZW5kaW5nVG9rZW4oKTtcbiAgICAgICAgaWYgKCF0b2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBleGNlcHRpb24gdG8gaGF2ZSBhbiBvZmZlbmRpbmcgdG9rZW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNvdXJjZSA9IHRvay50b2tlblNvdXJjZTtcbiAgICAgICAgbGV0IHN0cmVhbSA9IHNvdXJjZSAhPT0gdm9pZCAwID8gc291cmNlLmlucHV0U3RyZWFtIDogdm9pZCAwO1xuICAgICAgICBsZXQgc291cmNlUGFpciA9IHtzb3VyY2UsIHN0cmVhbX07XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbl8xLklucHV0TWlzbWF0Y2hFeGNlcHRpb24pIHtcbiAgICAgICAgICBsZXQgZXhwZWN0ZWRUb2tlbnMgPSBlLmV4cGVjdGVkVG9rZW5zO1xuICAgICAgICAgIGlmIChleHBlY3RlZFRva2VucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCB0aGUgZXhjZXB0aW9uIHRvIHByb3ZpZGUgZXhwZWN0ZWQgdG9rZW5zXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgZXhwZWN0ZWRUb2tlblR5cGUgPSBUb2tlbl8xLlRva2VuLklOVkFMSURfVFlQRTtcbiAgICAgICAgICBpZiAoIWV4cGVjdGVkVG9rZW5zLmlzTmlsKSB7XG4gICAgICAgICAgICBleHBlY3RlZFRva2VuVHlwZSA9IGV4cGVjdGVkVG9rZW5zLm1pbkVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBlcnJUb2tlbiA9IHRoaXMudG9rZW5GYWN0b3J5LmNyZWF0ZShzb3VyY2VQYWlyLCBleHBlY3RlZFRva2VuVHlwZSwgdG9rLnRleHQsIFRva2VuXzEuVG9rZW4uREVGQVVMVF9DSEFOTkVMLCAtMSwgLTEsIHRvay5saW5lLCB0b2suY2hhclBvc2l0aW9uSW5MaW5lKTtcbiAgICAgICAgICB0aGlzLl9jdHguYWRkRXJyb3JOb2RlKHRoaXMuY3JlYXRlRXJyb3JOb2RlKHRoaXMuX2N0eCwgZXJyVG9rZW4pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgc291cmNlMiA9IHRvay50b2tlblNvdXJjZTtcbiAgICAgICAgICBsZXQgZXJyVG9rZW4gPSB0aGlzLnRva2VuRmFjdG9yeS5jcmVhdGUoc291cmNlUGFpciwgVG9rZW5fMS5Ub2tlbi5JTlZBTElEX1RZUEUsIHRvay50ZXh0LCBUb2tlbl8xLlRva2VuLkRFRkFVTFRfQ0hBTk5FTCwgLTEsIC0xLCB0b2subGluZSwgdG9rLmNoYXJQb3NpdGlvbkluTGluZSk7XG4gICAgICAgICAgdGhpcy5fY3R4LmFkZEVycm9yTm9kZSh0aGlzLmNyZWF0ZUVycm9yTm9kZSh0aGlzLl9jdHgsIGVyclRva2VuKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVjb3ZlcklubGluZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XG4gICAgfVxuICAgIGdldCByb290Q29udGV4dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb290Q29udGV4dDtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIFBhcnNlckludGVycHJldGVyLnByb3RvdHlwZSwgXCJfdm9jYWJ1bGFyeVwiLCB2b2lkIDApO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzIuT3ZlcnJpZGVcbiAgXSwgUGFyc2VySW50ZXJwcmV0ZXIucHJvdG90eXBlLCBcInJlc2V0XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzIuT3ZlcnJpZGVcbiAgXSwgUGFyc2VySW50ZXJwcmV0ZXIucHJvdG90eXBlLCBcImF0blwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18yLk92ZXJyaWRlXG4gIF0sIFBhcnNlckludGVycHJldGVyLnByb3RvdHlwZSwgXCJ2b2NhYnVsYXJ5XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzIuT3ZlcnJpZGVcbiAgXSwgUGFyc2VySW50ZXJwcmV0ZXIucHJvdG90eXBlLCBcInJ1bGVOYW1lc1wiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18yLk92ZXJyaWRlXG4gIF0sIFBhcnNlckludGVycHJldGVyLnByb3RvdHlwZSwgXCJncmFtbWFyRmlsZU5hbWVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMi5PdmVycmlkZVxuICBdLCBQYXJzZXJJbnRlcnByZXRlci5wcm90b3R5cGUsIFwiZW50ZXJSZWN1cnNpb25SdWxlXCIsIG51bGwpO1xuICBQYXJzZXJJbnRlcnByZXRlciA9IF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMSwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIFBhcnNlckludGVycHJldGVyKTtcbiAgZXhwb3J0cy5QYXJzZXJJbnRlcnByZXRlciA9IFBhcnNlckludGVycHJldGVyO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy90cmVlL3BhdHRlcm4vUGFyc2VUcmVlTWF0Y2guanNcbnZhciByZXF1aXJlX1BhcnNlVHJlZU1hdGNoID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLlBhcnNlVHJlZU1hdGNoID0gdm9pZCAwO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBQYXJzZVRyZWVNYXRjaCA9IGNsYXNzIFBhcnNlVHJlZU1hdGNoIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmVlLCBwYXR0ZXJuLCBsYWJlbHMsIG1pc21hdGNoZWROb2RlKSB7XG4gICAgICBpZiAoIXRyZWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJlZSBjYW5ub3QgYmUgbnVsbFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghcGF0dGVybikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYXR0ZXJuIGNhbm5vdCBiZSBudWxsXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFsYWJlbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibGFiZWxzIGNhbm5vdCBiZSBudWxsXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdHJlZSA9IHRyZWU7XG4gICAgICB0aGlzLl9wYXR0ZXJuID0gcGF0dGVybjtcbiAgICAgIHRoaXMuX2xhYmVscyA9IGxhYmVscztcbiAgICAgIHRoaXMuX21pc21hdGNoZWROb2RlID0gbWlzbWF0Y2hlZE5vZGU7XG4gICAgfVxuICAgIGdldChsYWJlbCkge1xuICAgICAgbGV0IHBhcnNlVHJlZXMgPSB0aGlzLl9sYWJlbHMuZ2V0KGxhYmVsKTtcbiAgICAgIGlmICghcGFyc2VUcmVlcyB8fCBwYXJzZVRyZWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlVHJlZXNbcGFyc2VUcmVlcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgZ2V0QWxsKGxhYmVsKSB7XG4gICAgICBjb25zdCBub2RlcyA9IHRoaXMuX2xhYmVscy5nZXQobGFiZWwpO1xuICAgICAgaWYgKCFub2Rlcykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIGdldCBsYWJlbHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGFiZWxzO1xuICAgIH1cbiAgICBnZXQgbWlzbWF0Y2hlZE5vZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWlzbWF0Y2hlZE5vZGU7XG4gICAgfVxuICAgIGdldCBzdWNjZWVkZWQoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuX21pc21hdGNoZWROb2RlO1xuICAgIH1cbiAgICBnZXQgcGF0dGVybigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXR0ZXJuO1xuICAgIH1cbiAgICBnZXQgdHJlZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmVlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgTWF0Y2ggJHt0aGlzLnN1Y2NlZWRlZCA/IFwic3VjY2VlZGVkXCIgOiBcImZhaWxlZFwifTsgZm91bmQgJHt0aGlzLmxhYmVscy5zaXplfSBsYWJlbHNgO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGwsXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgUGFyc2VUcmVlTWF0Y2gucHJvdG90eXBlLCBcImdldEFsbFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgUGFyc2VUcmVlTWF0Y2gucHJvdG90eXBlLCBcImxhYmVsc1wiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgUGFyc2VUcmVlTWF0Y2gucHJvdG90eXBlLCBcInBhdHRlcm5cIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIFBhcnNlVHJlZU1hdGNoLnByb3RvdHlwZSwgXCJ0cmVlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgUGFyc2VUcmVlTWF0Y2gucHJvdG90eXBlLCBcInRvU3RyaW5nXCIsIG51bGwpO1xuICBQYXJzZVRyZWVNYXRjaCA9IF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMSwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMiwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIFBhcnNlVHJlZU1hdGNoKTtcbiAgZXhwb3J0cy5QYXJzZVRyZWVNYXRjaCA9IFBhcnNlVHJlZU1hdGNoO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy90cmVlL3hwYXRoL1hQYXRoTGV4ZXIuanNcbnZhciByZXF1aXJlX1hQYXRoTGV4ZXIgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLlhQYXRoTGV4ZXIgPSB2b2lkIDA7XG4gIHZhciBBVE5EZXNlcmlhbGl6ZXJfMSA9IHJlcXVpcmVfQVRORGVzZXJpYWxpemVyKCk7XG4gIHZhciBMZXhlcl8xID0gcmVxdWlyZV9MZXhlcigpO1xuICB2YXIgTGV4ZXJBVE5TaW11bGF0b3JfMSA9IHJlcXVpcmVfTGV4ZXJBVE5TaW11bGF0b3IoKTtcbiAgdmFyIFZvY2FidWxhcnlJbXBsXzEgPSByZXF1aXJlX1ZvY2FidWxhcnlJbXBsKCk7XG4gIHZhciBVdGlsczMgPSByZXF1aXJlX1V0aWxzKCk7XG4gIHZhciBYUGF0aExleGVyID0gY2xhc3MgZXh0ZW5kcyBMZXhlcl8xLkxleGVyIHtcbiAgICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgICAgc3VwZXIoaW5wdXQpO1xuICAgICAgdGhpcy5faW50ZXJwID0gbmV3IExleGVyQVROU2ltdWxhdG9yXzEuTGV4ZXJBVE5TaW11bGF0b3IoWFBhdGhMZXhlci5fQVROLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHZvY2FidWxhcnkoKSB7XG4gICAgICByZXR1cm4gWFBhdGhMZXhlci5WT0NBQlVMQVJZO1xuICAgIH1cbiAgICBnZXQgZ3JhbW1hckZpbGVOYW1lKCkge1xuICAgICAgcmV0dXJuIFwiWFBhdGhMZXhlci5nNFwiO1xuICAgIH1cbiAgICBnZXQgcnVsZU5hbWVzKCkge1xuICAgICAgcmV0dXJuIFhQYXRoTGV4ZXIucnVsZU5hbWVzO1xuICAgIH1cbiAgICBnZXQgc2VyaWFsaXplZEFUTigpIHtcbiAgICAgIHJldHVybiBYUGF0aExleGVyLl9zZXJpYWxpemVkQVROO1xuICAgIH1cbiAgICBnZXQgY2hhbm5lbE5hbWVzKCkge1xuICAgICAgcmV0dXJuIFhQYXRoTGV4ZXIuY2hhbm5lbE5hbWVzO1xuICAgIH1cbiAgICBnZXQgbW9kZU5hbWVzKCkge1xuICAgICAgcmV0dXJuIFhQYXRoTGV4ZXIubW9kZU5hbWVzO1xuICAgIH1cbiAgICBhY3Rpb24oX2xvY2FsY3R4LCBydWxlSW5kZXgsIGFjdGlvbkluZGV4KSB7XG4gICAgICBzd2l0Y2ggKHJ1bGVJbmRleCkge1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgdGhpcy5JRF9hY3Rpb24oX2xvY2FsY3R4LCBhY3Rpb25JbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIElEX2FjdGlvbihfbG9jYWxjdHgsIGFjdGlvbkluZGV4KSB7XG4gICAgICBzd2l0Y2ggKGFjdGlvbkluZGV4KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBsZXQgdGV4dCA9IHRoaXMudGV4dDtcbiAgICAgICAgICBpZiAodGV4dC5jaGFyQXQoMCkgPT09IHRleHQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFhQYXRoTGV4ZXIuVE9LRU5fUkVGO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBYUGF0aExleGVyLlJVTEVfUkVGO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldCBfQVROKCkge1xuICAgICAgaWYgKCFYUGF0aExleGVyLl9fQVROKSB7XG4gICAgICAgIFhQYXRoTGV4ZXIuX19BVE4gPSBuZXcgQVRORGVzZXJpYWxpemVyXzEuQVRORGVzZXJpYWxpemVyKCkuZGVzZXJpYWxpemUoVXRpbHMzLnRvQ2hhckFycmF5KFhQYXRoTGV4ZXIuX3NlcmlhbGl6ZWRBVE4pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBYUGF0aExleGVyLl9fQVROO1xuICAgIH1cbiAgfTtcbiAgZXhwb3J0cy5YUGF0aExleGVyID0gWFBhdGhMZXhlcjtcbiAgWFBhdGhMZXhlci5UT0tFTl9SRUYgPSAxO1xuICBYUGF0aExleGVyLlJVTEVfUkVGID0gMjtcbiAgWFBhdGhMZXhlci5BTllXSEVSRSA9IDM7XG4gIFhQYXRoTGV4ZXIuUk9PVCA9IDQ7XG4gIFhQYXRoTGV4ZXIuV0lMRENBUkQgPSA1O1xuICBYUGF0aExleGVyLkJBTkcgPSA2O1xuICBYUGF0aExleGVyLklEID0gNztcbiAgWFBhdGhMZXhlci5TVFJJTkcgPSA4O1xuICBYUGF0aExleGVyLmNoYW5uZWxOYW1lcyA9IFtcbiAgICBcIkRFRkFVTFRfVE9LRU5fQ0hBTk5FTFwiLFxuICAgIFwiSElEREVOXCJcbiAgXTtcbiAgWFBhdGhMZXhlci5tb2RlTmFtZXMgPSBbXG4gICAgXCJERUZBVUxUX01PREVcIlxuICBdO1xuICBYUGF0aExleGVyLnJ1bGVOYW1lcyA9IFtcbiAgICBcIkFOWVdIRVJFXCIsXG4gICAgXCJST09UXCIsXG4gICAgXCJXSUxEQ0FSRFwiLFxuICAgIFwiQkFOR1wiLFxuICAgIFwiSURcIixcbiAgICBcIk5hbWVDaGFyXCIsXG4gICAgXCJOYW1lU3RhcnRDaGFyXCIsXG4gICAgXCJTVFJJTkdcIlxuICBdO1xuICBYUGF0aExleGVyLl9MSVRFUkFMX05BTUVTID0gW1xuICAgIHZvaWQgMCxcbiAgICB2b2lkIDAsXG4gICAgdm9pZCAwLFxuICAgIFwiJy8vJ1wiLFxuICAgIFwiJy8nXCIsXG4gICAgXCInKidcIixcbiAgICBcIichJ1wiXG4gIF07XG4gIFhQYXRoTGV4ZXIuX1NZTUJPTElDX05BTUVTID0gW1xuICAgIHZvaWQgMCxcbiAgICBcIlRPS0VOX1JFRlwiLFxuICAgIFwiUlVMRV9SRUZcIixcbiAgICBcIkFOWVdIRVJFXCIsXG4gICAgXCJST09UXCIsXG4gICAgXCJXSUxEQ0FSRFwiLFxuICAgIFwiQkFOR1wiLFxuICAgIFwiSURcIixcbiAgICBcIlNUUklOR1wiXG4gIF07XG4gIFhQYXRoTGV4ZXIuVk9DQUJVTEFSWSA9IG5ldyBWb2NhYnVsYXJ5SW1wbF8xLlZvY2FidWxhcnlJbXBsKFhQYXRoTGV4ZXIuX0xJVEVSQUxfTkFNRVMsIFhQYXRoTGV4ZXIuX1NZTUJPTElDX05BTUVTLCBbXSk7XG4gIFhQYXRoTGV4ZXIuX3NlcmlhbGl6ZWRBVE5TZWdtZW50cyA9IDI7XG4gIFhQYXRoTGV4ZXIuX3NlcmlhbGl6ZWRBVE5TZWdtZW50MCA9ICdcdTAwMDNcXHVDOTFEXFx1Q0FCQVxcdTA1OERcXHVBRkJBXFx1NEY1M1xcdTA2MDdcXHVFQThCXFx1QzI0MVx1MDAwMlxcbjJcXGJcdTAwMDFcdTAwMDRcdTAwMDJcdFx1MDAwMlx1MDAwNFx1MDAwM1x0XHUwMDAzXHUwMDA0XHUwMDA0XHRcdTAwMDRcdTAwMDRcdTAwMDVcdFx1MDAwNVx1MDAwNFx1MDAwNlx0XHUwMDA2XHUwMDA0XFx4MDdcdFxceDA3XHUwMDA0XFxiXHRcXGJcdTAwMDRcdFx0XHRcdTAwMDNcdTAwMDJcdTAwMDNcdTAwMDJcdTAwMDNcdTAwMDJcdTAwMDNcdTAwMDNcdTAwMDNcdTAwMDNcdTAwMDNcdTAwMDRcdTAwMDNcdTAwMDRcdTAwMDNcdTAwMDVcdTAwMDNcdTAwMDVcdTAwMDNcdTAwMDZcdTAwMDNcdTAwMDZcXHgwN1x1MDAwNlx1MDAxZlxcblx1MDAwNlxcZlx1MDAwNlx1MDAwZVx1MDAwNlwiXFx2XHUwMDA2XHUwMDAzXHUwMDA2XHUwMDAzXHUwMDA2XHUwMDAzXFx4MDdcdTAwMDNcXHgwN1x1MDAwM1xcYlx1MDAwM1xcYlx1MDAwM1x0XHUwMDAzXHRcXHgwN1x0LFxcblx0XFxmXHRcdTAwMGVcdC9cXHZcdFx1MDAwM1x0XHUwMDAzXHRcdTAwMDMtXHUwMDAyXHUwMDAyXFxuXHUwMDAzXHUwMDAyXHUwMDA1XHUwMDA1XHUwMDAyXHUwMDA2XFx4MDdcdTAwMDJcXHgwN1x0XHUwMDAyXFxiXFx2XHUwMDAyXHRcXHJcdTAwMDJcdTAwMDJcdTAwMGZcdTAwMDJcdTAwMDJcdTAwMTFcdTAwMDJcXG5cdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDRcXHUwMkI2XHUwMDAyXHUwMDAyXHUwMDAyXFxuXHUwMDAyXHUwMDEwXHUwMDAyXHUwMDFkXHUwMDAyMlx1MDAwMjtcdTAwMDJDXHUwMDAyXFxcXFx1MDAwMmFcdTAwMDJhXHUwMDAyY1x1MDAwMnxcdTAwMDJcXHg4MVx1MDAwMlxceEExXHUwMDAyXFx4QUNcdTAwMDJcXHhBQ1x1MDAwMlxceEFGXHUwMDAyXFx4QUZcdTAwMDJcXHhCN1x1MDAwMlxceEI3XHUwMDAyXFx4QkNcdTAwMDJcXHhCQ1x1MDAwMlxceEMyXHUwMDAyXFx4RDhcdTAwMDJcXHhEQVx1MDAwMlxceEY4XHUwMDAyXFx4RkFcdTAwMDJcXHUwMkMzXHUwMDAyXFx1MDJDOFx1MDAwMlxcdTAyRDNcdTAwMDJcXHUwMkUyXHUwMDAyXFx1MDJFNlx1MDAwMlxcdTAyRUVcdTAwMDJcXHUwMkVFXHUwMDAyXFx1MDJGMFx1MDAwMlxcdTAyRjBcdTAwMDJcXHUwMzAyXHUwMDAyXFx1MDM3Nlx1MDAwMlxcdTAzNzhcdTAwMDJcXHUwMzc5XHUwMDAyXFx1MDM3Q1x1MDAwMlxcdTAzN0ZcdTAwMDJcXHUwMzgxXHUwMDAyXFx1MDM4MVx1MDAwMlxcdTAzODhcdTAwMDJcXHUwMzg4XHUwMDAyXFx1MDM4QVx1MDAwMlxcdTAzOENcdTAwMDJcXHUwMzhFXHUwMDAyXFx1MDM4RVx1MDAwMlxcdTAzOTBcdTAwMDJcXHUwM0EzXHUwMDAyXFx1MDNBNVx1MDAwMlxcdTAzRjdcdTAwMDJcXHUwM0Y5XHUwMDAyXFx1MDQ4M1x1MDAwMlxcdTA0ODVcdTAwMDJcXHUwNDg5XHUwMDAyXFx1MDQ4Q1x1MDAwMlxcdTA1MzFcdTAwMDJcXHUwNTMzXHUwMDAyXFx1MDU1OFx1MDAwMlxcdTA1NUJcdTAwMDJcXHUwNTVCXHUwMDAyXFx1MDU2M1x1MDAwMlxcdTA1ODlcdTAwMDJcXHUwNTkzXHUwMDAyXFx1MDVCRlx1MDAwMlxcdTA1QzFcdTAwMDJcXHUwNUMxXHUwMDAyXFx1MDVDM1x1MDAwMlxcdTA1QzRcdTAwMDJcXHUwNUM2XHUwMDAyXFx1MDVDN1x1MDAwMlxcdTA1QzlcdTAwMDJcXHUwNUM5XHUwMDAyXFx1MDVEMlx1MDAwMlxcdTA1RUNcdTAwMDJcXHUwNUYyXHUwMDAyXFx1MDVGNFx1MDAwMlxcdTA2MDJcdTAwMDJcXHUwNjA3XHUwMDAyXFx1MDYxMlx1MDAwMlxcdTA2MUNcdTAwMDJcXHUwNjFFXHUwMDAyXFx1MDYxRVx1MDAwMlxcdTA2MjJcdTAwMDJcXHUwNjZCXHUwMDAyXFx1MDY3MFx1MDAwMlxcdTA2RDVcdTAwMDJcXHUwNkQ3XHUwMDAyXFx1MDZERlx1MDAwMlxcdTA2RTFcdTAwMDJcXHUwNkVBXHUwMDAyXFx1MDZFQ1x1MDAwMlxcdTA2RkVcdTAwMDJcXHUwNzAxXHUwMDAyXFx1MDcwMVx1MDAwMlxcdTA3MTFcdTAwMDJcXHUwNzRDXHUwMDAyXFx1MDc0Rlx1MDAwMlxcdTA3QjNcdTAwMDJcXHUwN0MyXHUwMDAyXFx1MDdGN1x1MDAwMlxcdTA3RkNcdTAwMDJcXHUwN0ZDXHUwMDAyXFx1MDgwMlx1MDAwMlxcdTA4MkZcdTAwMDJcXHUwODQyXHUwMDAyXFx1MDg1RFx1MDAwMlxcdTA4QTJcdTAwMDJcXHUwOEI2XHUwMDAyXFx1MDhCOFx1MDAwMlxcdTA4QkZcdTAwMDJcXHUwOEQ2XHUwMDAyXFx1MDk2NVx1MDAwMlxcdTA5NjhcdTAwMDJcXHUwOTcxXHUwMDAyXFx1MDk3M1x1MDAwMlxcdTA5ODVcdTAwMDJcXHUwOTg3XHUwMDAyXFx1MDk4RVx1MDAwMlxcdTA5OTFcdTAwMDJcXHUwOTkyXHUwMDAyXFx1MDk5NVx1MDAwMlxcdTA5QUFcdTAwMDJcXHUwOUFDXHUwMDAyXFx1MDlCMlx1MDAwMlxcdTA5QjRcdTAwMDJcXHUwOUI0XHUwMDAyXFx1MDlCOFx1MDAwMlxcdTA5QkJcdTAwMDJcXHUwOUJFXHUwMDAyXFx1MDlDNlx1MDAwMlxcdTA5QzlcdTAwMDJcXHUwOUNBXHUwMDAyXFx1MDlDRFx1MDAwMlxcdTA5RDBcdTAwMDJcXHUwOUQ5XHUwMDAyXFx1MDlEOVx1MDAwMlxcdTA5REVcdTAwMDJcXHUwOURGXHUwMDAyXFx1MDlFMVx1MDAwMlxcdTA5RTVcdTAwMDJcXHUwOUU4XHUwMDAyXFx1MDlGM1x1MDAwMlxcdTBBMDNcdTAwMDJcXHUwQTA1XHUwMDAyXFx1MEEwN1x1MDAwMlxcdTBBMENcdTAwMDJcXHUwQTExXHUwMDAyXFx1MEExMlx1MDAwMlxcdTBBMTVcdTAwMDJcXHUwQTJBXHUwMDAyXFx1MEEyQ1x1MDAwMlxcdTBBMzJcdTAwMDJcXHUwQTM0XHUwMDAyXFx1MEEzNVx1MDAwMlxcdTBBMzdcdTAwMDJcXHUwQTM4XHUwMDAyXFx1MEEzQVx1MDAwMlxcdTBBM0JcdTAwMDJcXHUwQTNFXHUwMDAyXFx1MEEzRVx1MDAwMlxcdTBBNDBcdTAwMDJcXHUwQTQ0XHUwMDAyXFx1MEE0OVx1MDAwMlxcdTBBNEFcdTAwMDJcXHUwQTREXHUwMDAyXFx1MEE0Rlx1MDAwMlxcdTBBNTNcdTAwMDJcXHUwQTUzXHUwMDAyXFx1MEE1Qlx1MDAwMlxcdTBBNUVcdTAwMDJcXHUwQTYwXHUwMDAyXFx1MEE2MFx1MDAwMlxcdTBBNjhcdTAwMDJcXHUwQTc3XHUwMDAyXFx1MEE4M1x1MDAwMlxcdTBBODVcdTAwMDJcXHUwQTg3XHUwMDAyXFx1MEE4Rlx1MDAwMlxcdTBBOTFcdTAwMDJcXHUwQTkzXHUwMDAyXFx1MEE5NVx1MDAwMlxcdTBBQUFcdTAwMDJcXHUwQUFDXHUwMDAyXFx1MEFCMlx1MDAwMlxcdTBBQjRcdTAwMDJcXHUwQUI1XHUwMDAyXFx1MEFCN1x1MDAwMlxcdTBBQkJcdTAwMDJcXHUwQUJFXHUwMDAyXFx1MEFDN1x1MDAwMlxcdTBBQzlcdTAwMDJcXHUwQUNCXHUwMDAyXFx1MEFDRFx1MDAwMlxcdTBBQ0ZcdTAwMDJcXHUwQUQyXHUwMDAyXFx1MEFEMlx1MDAwMlxcdTBBRTJcdTAwMDJcXHUwQUU1XHUwMDAyXFx1MEFFOFx1MDAwMlxcdTBBRjFcdTAwMDJcXHUwQUZCXHUwMDAyXFx1MEFGQlx1MDAwMlxcdTBCMDNcdTAwMDJcXHUwQjA1XHUwMDAyXFx1MEIwN1x1MDAwMlxcdTBCMEVcdTAwMDJcXHUwQjExXHUwMDAyXFx1MEIxMlx1MDAwMlxcdTBCMTVcdTAwMDJcXHUwQjJBXHUwMDAyXFx1MEIyQ1x1MDAwMlxcdTBCMzJcdTAwMDJcXHUwQjM0XHUwMDAyXFx1MEIzNVx1MDAwMlxcdTBCMzdcdTAwMDJcXHUwQjNCXHUwMDAyXFx1MEIzRVx1MDAwMlxcdTBCNDZcdTAwMDJcXHUwQjQ5XHUwMDAyXFx1MEI0QVx1MDAwMlxcdTBCNERcdTAwMDJcXHUwQjRGXHUwMDAyXFx1MEI1OFx1MDAwMlxcdTBCNTlcdTAwMDJcXHUwQjVFXHUwMDAyXFx1MEI1Rlx1MDAwMlxcdTBCNjFcdTAwMDJcXHUwQjY1XHUwMDAyXFx1MEI2OFx1MDAwMlxcdTBCNzFcdTAwMDJcXHUwQjczXHUwMDAyXFx1MEI3M1x1MDAwMlxcdTBCODRcdTAwMDJcXHUwQjg1XHUwMDAyXFx1MEI4N1x1MDAwMlxcdTBCOENcdTAwMDJcXHUwQjkwXHUwMDAyXFx1MEI5Mlx1MDAwMlxcdTBCOTRcdTAwMDJcXHUwQjk3XHUwMDAyXFx1MEI5Qlx1MDAwMlxcdTBCOUNcdTAwMDJcXHUwQjlFXHUwMDAyXFx1MEI5RVx1MDAwMlxcdTBCQTBcdTAwMDJcXHUwQkExXHUwMDAyXFx1MEJBNVx1MDAwMlxcdTBCQTZcdTAwMDJcXHUwQkFBXHUwMDAyXFx1MEJBQ1x1MDAwMlxcdTBCQjBcdTAwMDJcXHUwQkJCXHUwMDAyXFx1MEJDMFx1MDAwMlxcdTBCQzRcdTAwMDJcXHUwQkM4XHUwMDAyXFx1MEJDQVx1MDAwMlxcdTBCQ0NcdTAwMDJcXHUwQkNGXHUwMDAyXFx1MEJEMlx1MDAwMlxcdTBCRDJcdTAwMDJcXHUwQkQ5XHUwMDAyXFx1MEJEOVx1MDAwMlxcdTBCRThcdTAwMDJcXHUwQkYxXHUwMDAyXFx1MEMwMlx1MDAwMlxcdTBDMDVcdTAwMDJcXHUwQzA3XHUwMDAyXFx1MEMwRVx1MDAwMlxcdTBDMTBcdTAwMDJcXHUwQzEyXHUwMDAyXFx1MEMxNFx1MDAwMlxcdTBDMkFcdTAwMDJcXHUwQzJDXHUwMDAyXFx1MEMzQlx1MDAwMlxcdTBDM0ZcdTAwMDJcXHUwQzQ2XHUwMDAyXFx1MEM0OFx1MDAwMlxcdTBDNEFcdTAwMDJcXHUwQzRDXHUwMDAyXFx1MEM0Rlx1MDAwMlxcdTBDNTdcdTAwMDJcXHUwQzU4XHUwMDAyXFx1MEM1QVx1MDAwMlxcdTBDNUNcdTAwMDJcXHUwQzYyXHUwMDAyXFx1MEM2NVx1MDAwMlxcdTBDNjhcdTAwMDJcXHUwQzcxXHUwMDAyXFx1MEM4Mlx1MDAwMlxcdTBDODVcdTAwMDJcXHUwQzg3XHUwMDAyXFx1MEM4RVx1MDAwMlxcdTBDOTBcdTAwMDJcXHUwQzkyXHUwMDAyXFx1MEM5NFx1MDAwMlxcdTBDQUFcdTAwMDJcXHUwQ0FDXHUwMDAyXFx1MENCNVx1MDAwMlxcdTBDQjdcdTAwMDJcXHUwQ0JCXHUwMDAyXFx1MENCRVx1MDAwMlxcdTBDQzZcdTAwMDJcXHUwQ0M4XHUwMDAyXFx1MENDQVx1MDAwMlxcdTBDQ0NcdTAwMDJcXHUwQ0NGXHUwMDAyXFx1MENEN1x1MDAwMlxcdTBDRDhcdTAwMDJcXHUwQ0UwXHUwMDAyXFx1MENFMFx1MDAwMlxcdTBDRTJcdTAwMDJcXHUwQ0U1XHUwMDAyXFx1MENFOFx1MDAwMlxcdTBDRjFcdTAwMDJcXHUwQ0YzXHUwMDAyXFx1MENGNFx1MDAwMlxcdTBEMDNcdTAwMDJcXHUwRDA1XHUwMDAyXFx1MEQwN1x1MDAwMlxcdTBEMEVcdTAwMDJcXHUwRDEwXHUwMDAyXFx1MEQxMlx1MDAwMlxcdTBEMTRcdTAwMDJcXHUwRDNDXHUwMDAyXFx1MEQzRlx1MDAwMlxcdTBENDZcdTAwMDJcXHUwRDQ4XHUwMDAyXFx1MEQ0QVx1MDAwMlxcdTBENENcdTAwMDJcXHUwRDUwXHUwMDAyXFx1MEQ1Nlx1MDAwMlxcdTBENTlcdTAwMDJcXHUwRDYxXHUwMDAyXFx1MEQ2NVx1MDAwMlxcdTBENjhcdTAwMDJcXHUwRDcxXHUwMDAyXFx1MEQ3Q1x1MDAwMlxcdTBEODFcdTAwMDJcXHUwRDg0XHUwMDAyXFx1MEQ4NVx1MDAwMlxcdTBEODdcdTAwMDJcXHUwRDk4XHUwMDAyXFx1MEQ5Q1x1MDAwMlxcdTBEQjNcdTAwMDJcXHUwREI1XHUwMDAyXFx1MERCRFx1MDAwMlxcdTBEQkZcdTAwMDJcXHUwREJGXHUwMDAyXFx1MERDMlx1MDAwMlxcdTBEQzhcdTAwMDJcXHUwRENDXHUwMDAyXFx1MERDQ1x1MDAwMlxcdTBERDFcdTAwMDJcXHUwREQ2XHUwMDAyXFx1MEREOFx1MDAwMlxcdTBERDhcdTAwMDJcXHUwRERBXHUwMDAyXFx1MERFMVx1MDAwMlxcdTBERThcdTAwMDJcXHUwREYxXHUwMDAyXFx1MERGNFx1MDAwMlxcdTBERjVcdTAwMDJcXHUwRTAzXHUwMDAyXFx1MEUzQ1x1MDAwMlxcdTBFNDJcdTAwMDJcXHUwRTUwXHUwMDAyXFx1MEU1Mlx1MDAwMlxcdTBFNUJcdTAwMDJcXHUwRTgzXHUwMDAyXFx1MEU4NFx1MDAwMlxcdTBFODZcdTAwMDJcXHUwRTg2XHUwMDAyXFx1MEU4OVx1MDAwMlxcdTBFOEFcdTAwMDJcXHUwRThDXHUwMDAyXFx1MEU4Q1x1MDAwMlxcdTBFOEZcdTAwMDJcXHUwRThGXHUwMDAyXFx1MEU5Nlx1MDAwMlxcdTBFOTlcdTAwMDJcXHUwRTlCXHUwMDAyXFx1MEVBMVx1MDAwMlxcdTBFQTNcdTAwMDJcXHUwRUE1XHUwMDAyXFx1MEVBN1x1MDAwMlxcdTBFQTdcdTAwMDJcXHUwRUE5XHUwMDAyXFx1MEVBOVx1MDAwMlxcdTBFQUNcdTAwMDJcXHUwRUFEXHUwMDAyXFx1MEVBRlx1MDAwMlxcdTBFQkJcdTAwMDJcXHUwRUJEXHUwMDAyXFx1MEVCRlx1MDAwMlxcdTBFQzJcdTAwMDJcXHUwRUM2XHUwMDAyXFx1MEVDOFx1MDAwMlxcdTBFQzhcdTAwMDJcXHUwRUNBXHUwMDAyXFx1MEVDRlx1MDAwMlxcdTBFRDJcdTAwMDJcXHUwRURCXHUwMDAyXFx1MEVERVx1MDAwMlxcdTBFRTFcdTAwMDJcXHUwRjAyXHUwMDAyXFx1MEYwMlx1MDAwMlxcdTBGMUFcdTAwMDJcXHUwRjFCXHUwMDAyXFx1MEYyMlx1MDAwMlxcdTBGMkJcdTAwMDJcXHUwRjM3XHUwMDAyXFx1MEYzN1x1MDAwMlxcdTBGMzlcdTAwMDJcXHUwRjM5XHUwMDAyXFx1MEYzQlx1MDAwMlxcdTBGM0JcdTAwMDJcXHUwRjQwXHUwMDAyXFx1MEY0OVx1MDAwMlxcdTBGNEJcdTAwMDJcXHUwRjZFXHUwMDAyXFx1MEY3M1x1MDAwMlxcdTBGODZcdTAwMDJcXHUwRjg4XHUwMDAyXFx1MEY5OVx1MDAwMlxcdTBGOUJcdTAwMDJcXHUwRkJFXHUwMDAyXFx1MEZDOFx1MDAwMlxcdTBGQzhcdTAwMDJcXHUxMDAyXHUwMDAyXFx1MTA0Qlx1MDAwMlxcdTEwNTJcdTAwMDJcXHUxMDlGXHUwMDAyXFx1MTBBMlx1MDAwMlxcdTEwQzdcdTAwMDJcXHUxMEM5XHUwMDAyXFx1MTBDOVx1MDAwMlxcdTEwQ0ZcdTAwMDJcXHUxMENGXHUwMDAyXFx1MTBEMlx1MDAwMlxcdTEwRkNcdTAwMDJcXHUxMEZFXHUwMDAyXFx1MTI0QVx1MDAwMlxcdTEyNENcdTAwMDJcXHUxMjRGXHUwMDAyXFx1MTI1Mlx1MDAwMlxcdTEyNThcdTAwMDJcXHUxMjVBXHUwMDAyXFx1MTI1QVx1MDAwMlxcdTEyNUNcdTAwMDJcXHUxMjVGXHUwMDAyXFx1MTI2Mlx1MDAwMlxcdTEyOEFcdTAwMDJcXHUxMjhDXHUwMDAyXFx1MTI4Rlx1MDAwMlxcdTEyOTJcdTAwMDJcXHUxMkIyXHUwMDAyXFx1MTJCNFx1MDAwMlxcdTEyQjdcdTAwMDJcXHUxMkJBXHUwMDAyXFx1MTJDMFx1MDAwMlxcdTEyQzJcdTAwMDJcXHUxMkMyXHUwMDAyXFx1MTJDNFx1MDAwMlxcdTEyQzdcdTAwMDJcXHUxMkNBXHUwMDAyXFx1MTJEOFx1MDAwMlxcdTEyREFcdTAwMDJcXHUxMzEyXHUwMDAyXFx1MTMxNFx1MDAwMlxcdTEzMTdcdTAwMDJcXHUxMzFBXHUwMDAyXFx1MTM1Q1x1MDAwMlxcdTEzNUZcdTAwMDJcXHUxMzYxXHUwMDAyXFx1MTM4Mlx1MDAwMlxcdTEzOTFcdTAwMDJcXHUxM0EyXHUwMDAyXFx1MTNGN1x1MDAwMlxcdTEzRkFcdTAwMDJcXHUxM0ZGXHUwMDAyXFx1MTQwM1x1MDAwMlxcdTE2NkVcdTAwMDJcXHUxNjcxXHUwMDAyXFx1MTY4MVx1MDAwMlxcdTE2ODNcdTAwMDJcXHUxNjlDXHUwMDAyXFx1MTZBMlx1MDAwMlxcdTE2RUNcdTAwMDJcXHUxNkYwXHUwMDAyXFx1MTZGQVx1MDAwMlxcdTE3MDJcdTAwMDJcXHUxNzBFXHUwMDAyXFx1MTcxMFx1MDAwMlxcdTE3MTZcdTAwMDJcXHUxNzIyXHUwMDAyXFx1MTczNlx1MDAwMlxcdTE3NDJcdTAwMDJcXHUxNzU1XHUwMDAyXFx1MTc2Mlx1MDAwMlxcdTE3NkVcdTAwMDJcXHUxNzcwXHUwMDAyXFx1MTc3Mlx1MDAwMlxcdTE3NzRcdTAwMDJcXHUxNzc1XHUwMDAyXFx1MTc4Mlx1MDAwMlxcdTE3RDVcdTAwMDJcXHUxN0Q5XHUwMDAyXFx1MTdEOVx1MDAwMlxcdTE3REVcdTAwMDJcXHUxN0RGXHUwMDAyXFx1MTdFMlx1MDAwMlxcdTE3RUJcdTAwMDJcXHUxODBEXHUwMDAyXFx1MTgxMFx1MDAwMlxcdTE4MTJcdTAwMDJcXHUxODFCXHUwMDAyXFx1MTgyMlx1MDAwMlxcdTE4NzlcdTAwMDJcXHUxODgyXHUwMDAyXFx1MThBQ1x1MDAwMlxcdTE4QjJcdTAwMDJcXHUxOEY3XHUwMDAyXFx1MTkwMlx1MDAwMlxcdTE5MjBcdTAwMDJcXHUxOTIyXHUwMDAyXFx1MTkyRFx1MDAwMlxcdTE5MzJcdTAwMDJcXHUxOTNEXHUwMDAyXFx1MTk0OFx1MDAwMlxcdTE5NkZcdTAwMDJcXHUxOTcyXHUwMDAyXFx1MTk3Nlx1MDAwMlxcdTE5ODJcdTAwMDJcXHUxOUFEXHUwMDAyXFx1MTlCMlx1MDAwMlxcdTE5Q0JcdTAwMDJcXHUxOUQyXHUwMDAyXFx1MTlEQlx1MDAwMlxcdTFBMDJcdTAwMDJcXHUxQTFEXHUwMDAyXFx1MUEyMlx1MDAwMlxcdTFBNjBcdTAwMDJcXHUxQTYyXHUwMDAyXFx1MUE3RVx1MDAwMlxcdTFBODFcdTAwMDJcXHUxQThCXHUwMDAyXFx1MUE5Mlx1MDAwMlxcdTFBOUJcdTAwMDJcXHUxQUE5XHUwMDAyXFx1MUFBOVx1MDAwMlxcdTFBQjJcdTAwMDJcXHUxQUJGXHUwMDAyXFx1MUIwMlx1MDAwMlxcdTFCNERcdTAwMDJcXHUxQjUyXHUwMDAyXFx1MUI1Qlx1MDAwMlxcdTFCNkRcdTAwMDJcXHUxQjc1XHUwMDAyXFx1MUI4Mlx1MDAwMlxcdTFCRjVcdTAwMDJcXHUxQzAyXHUwMDAyXFx1MUMzOVx1MDAwMlxcdTFDNDJcdTAwMDJcXHUxQzRCXHUwMDAyXFx1MUM0Rlx1MDAwMlxcdTFDN0ZcdTAwMDJcXHUxQzgyXHUwMDAyXFx1MUM4QVx1MDAwMlxcdTFDRDJcdTAwMDJcXHUxQ0Q0XHUwMDAyXFx1MUNENlx1MDAwMlxcdTFDRjhcdTAwMDJcXHUxQ0ZBXHUwMDAyXFx1MUNGQlx1MDAwMlxcdTFEMDJcdTAwMDJcXHUxREY3XHUwMDAyXFx1MURGRFx1MDAwMlxcdTFGMTdcdTAwMDJcXHUxRjFBXHUwMDAyXFx1MUYxRlx1MDAwMlxcdTFGMjJcdTAwMDJcXHUxRjQ3XHUwMDAyXFx1MUY0QVx1MDAwMlxcdTFGNEZcdTAwMDJcXHUxRjUyXHUwMDAyXFx1MUY1OVx1MDAwMlxcdTFGNUJcdTAwMDJcXHUxRjVCXHUwMDAyXFx1MUY1RFx1MDAwMlxcdTFGNURcdTAwMDJcXHUxRjVGXHUwMDAyXFx1MUY1Rlx1MDAwMlxcdTFGNjFcdTAwMDJcXHUxRjdGXHUwMDAyXFx1MUY4Mlx1MDAwMlxcdTFGQjZcdTAwMDJcXHUxRkI4XHUwMDAyXFx1MUZCRVx1MDAwMlxcdTFGQzBcdTAwMDJcXHUxRkMwXHUwMDAyXFx1MUZDNFx1MDAwMlxcdTFGQzZcdTAwMDJcXHUxRkM4XHUwMDAyXFx1MUZDRVx1MDAwMlxcdTFGRDJcdTAwMDJcXHUxRkQ1XHUwMDAyXFx1MUZEOFx1MDAwMlxcdTFGRERcdTAwMDJcXHUxRkUyXHUwMDAyXFx1MUZFRVx1MDAwMlxcdTFGRjRcdTAwMDJcXHUxRkY2XHUwMDAyXFx1MUZGOFx1MDAwMlxcdTFGRkVcdTAwMDJcXHUyMDBEXHUwMDAyXFx1MjAxMVx1MDAwMlxcdTIwMkNcdTAwMDJcXHUyMDMwXHUwMDAyXFx1MjA0MVx1MDAwMlxcdTIwNDJcdTAwMDJcXHUyMDU2XHUwMDAyXFx1MjA1Nlx1MDAwMlxcdTIwNjJcdTAwMDJcXHUyMDY2XHUwMDAyXFx1MjA2OFx1MDAwMlxcdTIwNzFcdTAwMDJcXHUyMDczXHUwMDAyXFx1MjA3M1x1MDAwMlxcdTIwODFcdTAwMDJcXHUyMDgxXHUwMDAyXFx1MjA5Mlx1MDAwMlxcdTIwOUVcdTAwMDJcXHUyMEQyXHUwMDAyXFx1MjBERVx1MDAwMlxcdTIwRTNcdTAwMDJcXHUyMEUzXHUwMDAyXFx1MjBFN1x1MDAwMlxcdTIwRjJcdTAwMDJcXHUyMTA0XHUwMDAyXFx1MjEwNFx1MDAwMlxcdTIxMDlcdTAwMDJcXHUyMTA5XHUwMDAyXFx1MjEwQ1x1MDAwMlxcdTIxMTVcdTAwMDJcXHUyMTE3XHUwMDAyXFx1MjExN1x1MDAwMlxcdTIxMUJcdTAwMDJcXHUyMTFGXHUwMDAyXFx1MjEyNlx1MDAwMlxcdTIxMjZcdTAwMDJcXHUyMTI4XHUwMDAyXFx1MjEyOFx1MDAwMlxcdTIxMkFcdTAwMDJcXHUyMTJBXHUwMDAyXFx1MjEyQ1x1MDAwMlxcdTIxMkZcdTAwMDJcXHUyMTMxXHUwMDAyXFx1MjEzQlx1MDAwMlxcdTIxM0VcdTAwMDJcXHUyMTQxXHUwMDAyXFx1MjE0N1x1MDAwMlxcdTIxNEJcdTAwMDJcXHUyMTUwXHUwMDAyXFx1MjE1MFx1MDAwMlxcdTIxNjJcdTAwMDJcXHUyMThBXHUwMDAyXFx1MkMwMlx1MDAwMlxcdTJDMzBcdTAwMDJcXHUyQzMyXHUwMDAyXFx1MkM2MFx1MDAwMlxcdTJDNjJcdTAwMDJcXHUyQ0U2XHUwMDAyXFx1MkNFRFx1MDAwMlxcdTJDRjVcdTAwMDJcXHUyRDAyXHUwMDAyXFx1MkQyN1x1MDAwMlxcdTJEMjlcdTAwMDJcXHUyRDI5XHUwMDAyXFx1MkQyRlx1MDAwMlxcdTJEMkZcdTAwMDJcXHUyRDMyXHUwMDAyXFx1MkQ2OVx1MDAwMlxcdTJENzFcdTAwMDJcXHUyRDcxXHUwMDAyXFx1MkQ4MVx1MDAwMlxcdTJEOThcdTAwMDJcXHUyREEyXHUwMDAyXFx1MkRBOFx1MDAwMlxcdTJEQUFcdTAwMDJcXHUyREIwXHUwMDAyXFx1MkRCMlx1MDAwMlxcdTJEQjhcdTAwMDJcXHUyREJBXHUwMDAyXFx1MkRDMFx1MDAwMlxcdTJEQzJcdTAwMDJcXHUyREM4XHUwMDAyXFx1MkRDQVx1MDAwMlxcdTJERDBcdTAwMDJcXHUyREQyXHUwMDAyXFx1MkREOFx1MDAwMlxcdTJEREFcdTAwMDJcXHUyREUwXHUwMDAyXFx1MkRFMlx1MDAwMlxcdTJFMDFcdTAwMDJcXHUyRTMxXHUwMDAyXFx1MkUzMVx1MDAwMlxcdTMwMDdcdTAwMDJcXHUzMDA5XHUwMDAyXFx1MzAyM1x1MDAwMlxcdTMwMzFcdTAwMDJcXHUzMDMzXHUwMDAyXFx1MzAzN1x1MDAwMlxcdTMwM0FcdTAwMDJcXHUzMDNFXHUwMDAyXFx1MzA0M1x1MDAwMlxcdTMwOThcdTAwMDJcXHUzMDlCXHUwMDAyXFx1MzA5Q1x1MDAwMlxcdTMwOUZcdTAwMDJcXHUzMEExXHUwMDAyXFx1MzBBM1x1MDAwMlxcdTMwRkNcdTAwMDJcXHUzMEZFXHUwMDAyXFx1MzEwMVx1MDAwMlxcdTMxMDdcdTAwMDJcXHUzMTJGXHUwMDAyXFx1MzEzM1x1MDAwMlxcdTMxOTBcdTAwMDJcXHUzMUEyXHUwMDAyXFx1MzFCQ1x1MDAwMlxcdTMxRjJcdTAwMDJcXHUzMjAxXHUwMDAyXFx1MzQwMlx1MDAwMlxcdTREQjdcdTAwMDJcXHU0RTAyXHUwMDAyXFx1OUZEN1x1MDAwMlxcdUEwMDJcdTAwMDJcXHVBNDhFXHUwMDAyXFx1QTREMlx1MDAwMlxcdUE0RkZcdTAwMDJcXHVBNTAyXHUwMDAyXFx1QTYwRVx1MDAwMlxcdUE2MTJcdTAwMDJcXHVBNjJEXHUwMDAyXFx1QTY0Mlx1MDAwMlxcdUE2NzFcdTAwMDJcXHVBNjc2XHUwMDAyXFx1QTY3Rlx1MDAwMlxcdUE2ODFcdTAwMDJcXHVBNkYzXHUwMDAyXFx1QTcxOVx1MDAwMlxcdUE3MjFcdTAwMDJcXHVBNzI0XHUwMDAyXFx1QTc4QVx1MDAwMlxcdUE3OERcdTAwMDJcXHVBN0IwXHUwMDAyXFx1QTdCMlx1MDAwMlxcdUE3QjlcdTAwMDJcXHVBN0Y5XHUwMDAyXFx1QTgyOVx1MDAwMlxcdUE4NDJcdTAwMDJcXHVBODc1XHUwMDAyXFx1QTg4Mlx1MDAwMlxcdUE4QzdcdTAwMDJcXHVBOEQyXHUwMDAyXFx1QThEQlx1MDAwMlxcdUE4RTJcdTAwMDJcXHVBOEY5XHUwMDAyXFx1QThGRFx1MDAwMlxcdUE4RkRcdTAwMDJcXHVBOEZGXHUwMDAyXFx1QThGRlx1MDAwMlxcdUE5MDJcdTAwMDJcXHVBOTJGXHUwMDAyXFx1QTkzMlx1MDAwMlxcdUE5NTVcdTAwMDJcXHVBOTYyXHUwMDAyXFx1QTk3RVx1MDAwMlxcdUE5ODJcdTAwMDJcXHVBOUMyXHUwMDAyXFx1QTlEMVx1MDAwMlxcdUE5REJcdTAwMDJcXHVBOUUyXHUwMDAyXFx1QUEwMFx1MDAwMlxcdUFBMDJcdTAwMDJcXHVBQTM4XHUwMDAyXFx1QUE0Mlx1MDAwMlxcdUFBNEZcdTAwMDJcXHVBQTUyXHUwMDAyXFx1QUE1Qlx1MDAwMlxcdUFBNjJcdTAwMDJcXHVBQTc4XHUwMDAyXFx1QUE3Q1x1MDAwMlxcdUFBQzRcdTAwMDJcXHVBQUREXHUwMDAyXFx1QUFERlx1MDAwMlxcdUFBRTJcdTAwMDJcXHVBQUYxXHUwMDAyXFx1QUFGNFx1MDAwMlxcdUFBRjhcdTAwMDJcXHVBQjAzXHUwMDAyXFx1QUIwOFx1MDAwMlxcdUFCMEJcdTAwMDJcXHVBQjEwXHUwMDAyXFx1QUIxM1x1MDAwMlxcdUFCMThcdTAwMDJcXHVBQjIyXHUwMDAyXFx1QUIyOFx1MDAwMlxcdUFCMkFcdTAwMDJcXHVBQjMwXHUwMDAyXFx1QUIzMlx1MDAwMlxcdUFCNUNcdTAwMDJcXHVBQjVFXHUwMDAyXFx1QUI2N1x1MDAwMlxcdUFCNzJcdTAwMDJcXHVBQkVDXHUwMDAyXFx1QUJFRVx1MDAwMlxcdUFCRUZcdTAwMDJcXHVBQkYyXHUwMDAyXFx1QUJGQlx1MDAwMlxcdUFDMDJcdTAwMDJcXHVEN0E1XHUwMDAyXFx1RDdCMlx1MDAwMlxcdUQ3QzhcdTAwMDJcXHVEN0NEXHUwMDAyXFx1RDdGRFx1MDAwMlxcdUY5MDJcdTAwMDJcXHVGQTZGXHUwMDAyXFx1RkE3Mlx1MDAwMlxcdUZBREJcdTAwMDJcXHVGQjAyXHUwMDAyXFx1RkIwOFx1MDAwMlxcdUZCMTVcdTAwMDJcXHVGQjE5XHUwMDAyXFx1RkIxRlx1MDAwMlxcdUZCMkFcdTAwMDJcXHVGQjJDXHUwMDAyXFx1RkIzOFx1MDAwMlxcdUZCM0FcdTAwMDJcXHVGQjNFXHUwMDAyXFx1RkI0MFx1MDAwMlxcdUZCNDBcdTAwMDJcXHVGQjQyXHUwMDAyXFx1RkI0M1x1MDAwMlxcdUZCNDVcdTAwMDJcXHVGQjQ2XHUwMDAyXFx1RkI0OFx1MDAwMlxcdUZCQjNcdTAwMDJcXHVGQkQ1XHUwMDAyXFx1RkQzRlx1MDAwMlxcdUZENTJcdTAwMDJcXHVGRDkxXHUwMDAyXFx1RkQ5NFx1MDAwMlxcdUZEQzlcdTAwMDJcXHVGREYyXHUwMDAyXFx1RkRGRFx1MDAwMlxcdUZFMDJcdTAwMDJcXHVGRTExXHUwMDAyXFx1RkUyMlx1MDAwMlxcdUZFMzFcdTAwMDJcXHVGRTM1XHUwMDAyXFx1RkUzNlx1MDAwMlxcdUZFNEZcdTAwMDJcXHVGRTUxXHUwMDAyXFx1RkU3Mlx1MDAwMlxcdUZFNzZcdTAwMDJcXHVGRTc4XHUwMDAyXFx1RkVGRVx1MDAwMlxcdUZGMDFcdTAwMDJcXHVGRjAxXHUwMDAyXFx1RkYxMlx1MDAwMlxcdUZGMUJcdTAwMDJcXHVGRjIzXHUwMDAyXFx1RkYzQ1x1MDAwMlxcdUZGNDFcdTAwMDJcXHVGRjQxXHUwMDAyXFx1RkY0M1x1MDAwMlxcdUZGNUNcdTAwMDJcXHVGRjY4XHUwMDAyXFx1RkZDMFx1MDAwMlxcdUZGQzRcdTAwMDJcXHVGRkM5XHUwMDAyXFx1RkZDQ1x1MDAwMlxcdUZGRDFcdTAwMDJcXHVGRkQ0XHUwMDAyXFx1RkZEOVx1MDAwMlxcdUZGRENcdTAwMDJcXHVGRkRFXHUwMDAyXFx1RkZGQlx1MDAwMlxcdUZGRkRcdTAwMDJcdTAwMDJcdTAwMDNcXHJcdTAwMDNcdTAwMGZcdTAwMDMoXHUwMDAzKlx1MDAwMzxcdTAwMDM+XHUwMDAzP1x1MDAwM0FcdTAwMDNPXHUwMDAzUlx1MDAwM19cdTAwMDNcXHg4Mlx1MDAwM1xceEZDXHUwMDAzXFx1MDE0Mlx1MDAwM1xcdTAxNzZcdTAwMDNcXHUwMUZGXHUwMDAzXFx1MDFGRlx1MDAwM1xcdTAyODJcdTAwMDNcXHUwMjlFXHUwMDAzXFx1MDJBMlx1MDAwM1xcdTAyRDJcdTAwMDNcXHUwMkUyXHUwMDAzXFx1MDJFMlx1MDAwM1xcdTAzMDJcdTAwMDNcXHUwMzIxXHUwMDAzXFx1MDMzMlx1MDAwM1xcdTAzNENcdTAwMDNcXHUwMzUyXHUwMDAzXFx1MDM3Q1x1MDAwM1xcdTAzODJcdTAwMDNcXHUwMzlGXHUwMDAzXFx1MDNBMlx1MDAwM1xcdTAzQzVcdTAwMDNcXHUwM0NBXHUwMDAzXFx1MDNEMVx1MDAwM1xcdTAzRDNcdTAwMDNcXHUwM0Q3XHUwMDAzXFx1MDQwMlx1MDAwM1xcdTA0OUZcdTAwMDNcXHUwNEEyXHUwMDAzXFx1MDRBQlx1MDAwM1xcdTA0QjJcdTAwMDNcXHUwNEQ1XHUwMDAzXFx1MDREQVx1MDAwM1xcdTA0RkRcdTAwMDNcXHUwNTAyXHUwMDAzXFx1MDUyOVx1MDAwM1xcdTA1MzJcdTAwMDNcXHUwNTY1XHUwMDAzXFx1MDYwMlx1MDAwM1xcdTA3MzhcdTAwMDNcXHUwNzQyXHUwMDAzXFx1MDc1N1x1MDAwM1xcdTA3NjJcdTAwMDNcXHUwNzY5XHUwMDAzXFx1MDgwMlx1MDAwM1xcdTA4MDdcdTAwMDNcXHUwODBBXHUwMDAzXFx1MDgwQVx1MDAwM1xcdTA4MENcdTAwMDNcXHUwODM3XHUwMDAzXFx1MDgzOVx1MDAwM1xcdTA4M0FcdTAwMDNcXHUwODNFXHUwMDAzXFx1MDgzRVx1MDAwM1xcdTA4NDFcdTAwMDNcXHUwODU3XHUwMDAzXFx1MDg2Mlx1MDAwM1xcdTA4NzhcdTAwMDNcXHUwODgyXHUwMDAzXFx1MDhBMFx1MDAwM1xcdTA4RTJcdTAwMDNcXHUwOEY0XHUwMDAzXFx1MDhGNlx1MDAwM1xcdTA4RjdcdTAwMDNcXHUwOTAyXHUwMDAzXFx1MDkxN1x1MDAwM1xcdTA5MjJcdTAwMDNcXHUwOTNCXHUwMDAzXFx1MDk4Mlx1MDAwM1xcdTA5QjlcdTAwMDNcXHUwOUMwXHUwMDAzXFx1MDlDMVx1MDAwM1xcdTBBMDJcdTAwMDNcXHUwQTA1XHUwMDAzXFx1MEEwN1x1MDAwM1xcdTBBMDhcdTAwMDNcXHUwQTBFXHUwMDAzXFx1MEExNVx1MDAwM1xcdTBBMTdcdTAwMDNcXHUwQTE5XHUwMDAzXFx1MEExQlx1MDAwM1xcdTBBMzVcdTAwMDNcXHUwQTNBXHUwMDAzXFx1MEEzQ1x1MDAwM1xcdTBBNDFcdTAwMDNcXHUwQTQxXHUwMDAzXFx1MEE2Mlx1MDAwM1xcdTBBN0VcdTAwMDNcXHUwQTgyXHUwMDAzXFx1MEE5RVx1MDAwM1xcdTBBQzJcdTAwMDNcXHUwQUM5XHUwMDAzXFx1MEFDQlx1MDAwM1xcdTBBRThcdTAwMDNcXHUwQjAyXHUwMDAzXFx1MEIzN1x1MDAwM1xcdTBCNDJcdTAwMDNcXHUwQjU3XHUwMDAzXFx1MEI2Mlx1MDAwM1xcdTBCNzRcdTAwMDNcXHUwQjgyXHUwMDAzXFx1MEI5M1x1MDAwM1xcdTBDMDJcdTAwMDNcXHUwQzRBXHUwMDAzXFx1MEM4Mlx1MDAwM1xcdTBDQjRcdTAwMDNcXHUwQ0MyXHUwMDAzXFx1MENGNFx1MDAwM1xcdTEwMDJcdTAwMDNcXHUxMDQ4XHUwMDAzXFx1MTA2OFx1MDAwM1xcdTEwNzFcdTAwMDNcXHUxMDgxXHUwMDAzXFx1MTBCQ1x1MDAwM1xcdTEwQkZcdTAwMDNcXHUxMEJGXHUwMDAzXFx1MTBEMlx1MDAwM1xcdTEwRUFcdTAwMDNcXHUxMEYyXHUwMDAzXFx1MTBGQlx1MDAwM1xcdTExMDJcdTAwMDNcXHUxMTM2XHUwMDAzXFx1MTEzOFx1MDAwM1xcdTExNDFcdTAwMDNcXHUxMTUyXHUwMDAzXFx1MTE3NVx1MDAwM1xcdTExNzhcdTAwMDNcXHUxMTc4XHUwMDAzXFx1MTE4Mlx1MDAwM1xcdTExQzZcdTAwMDNcXHUxMUNDXHUwMDAzXFx1MTFDRVx1MDAwM1xcdTExRDJcdTAwMDNcXHUxMURDXHUwMDAzXFx1MTFERVx1MDAwM1xcdTExREVcdTAwMDNcXHUxMjAyXHUwMDAzXFx1MTIxM1x1MDAwM1xcdTEyMTVcdTAwMDNcXHUxMjM5XHUwMDAzXFx1MTI0MFx1MDAwM1xcdTEyNDBcdTAwMDNcXHUxMjgyXHUwMDAzXFx1MTI4OFx1MDAwM1xcdTEyOEFcdTAwMDNcXHUxMjhBXHUwMDAzXFx1MTI4Q1x1MDAwM1xcdTEyOEZcdTAwMDNcXHUxMjkxXHUwMDAzXFx1MTI5Rlx1MDAwM1xcdTEyQTFcdTAwMDNcXHUxMkFBXHUwMDAzXFx1MTJCMlx1MDAwM1xcdTEyRUNcdTAwMDNcXHUxMkYyXHUwMDAzXFx1MTJGQlx1MDAwM1xcdTEzMDJcdTAwMDNcXHUxMzA1XHUwMDAzXFx1MTMwN1x1MDAwM1xcdTEzMEVcdTAwMDNcXHUxMzExXHUwMDAzXFx1MTMxMlx1MDAwM1xcdTEzMTVcdTAwMDNcXHUxMzJBXHUwMDAzXFx1MTMyQ1x1MDAwM1xcdTEzMzJcdTAwMDNcXHUxMzM0XHUwMDAzXFx1MTMzNVx1MDAwM1xcdTEzMzdcdTAwMDNcXHUxMzNCXHUwMDAzXFx1MTMzRVx1MDAwM1xcdTEzNDZcdTAwMDNcXHUxMzQ5XHUwMDAzXFx1MTM0QVx1MDAwM1xcdTEzNERcdTAwMDNcXHUxMzRGXHUwMDAzXFx1MTM1Mlx1MDAwM1xcdTEzNTJcdTAwMDNcXHUxMzU5XHUwMDAzXFx1MTM1OVx1MDAwM1xcdTEzNUZcdTAwMDNcXHUxMzY1XHUwMDAzXFx1MTM2OFx1MDAwM1xcdTEzNkVcdTAwMDNcXHUxMzcyXHUwMDAzXFx1MTM3Nlx1MDAwM1xcdTE0MDJcdTAwMDNcXHUxNDRDXHUwMDAzXFx1MTQ1Mlx1MDAwM1xcdTE0NUJcdTAwMDNcXHUxNDgyXHUwMDAzXFx1MTRDN1x1MDAwM1xcdTE0QzlcdTAwMDNcXHUxNEM5XHUwMDAzXFx1MTREMlx1MDAwM1xcdTE0REJcdTAwMDNcXHUxNTgyXHUwMDAzXFx1MTVCN1x1MDAwM1xcdTE1QkFcdTAwMDNcXHUxNUMyXHUwMDAzXFx1MTVEQVx1MDAwM1xcdTE1REZcdTAwMDNcXHUxNjAyXHUwMDAzXFx1MTY0Mlx1MDAwM1xcdTE2NDZcdTAwMDNcXHUxNjQ2XHUwMDAzXFx1MTY1Mlx1MDAwM1xcdTE2NUJcdTAwMDNcXHUxNjgyXHUwMDAzXFx1MTZCOVx1MDAwM1xcdTE2QzJcdTAwMDNcXHUxNkNCXHUwMDAzXFx1MTcwMlx1MDAwM1xcdTE3MUJcdTAwMDNcXHUxNzFGXHUwMDAzXFx1MTcyRFx1MDAwM1xcdTE3MzJcdTAwMDNcXHUxNzNCXHUwMDAzXFx1MThBMlx1MDAwM1xcdTE4RUJcdTAwMDNcXHUxOTAxXHUwMDAzXFx1MTkwMVx1MDAwM1xcdTFBQzJcdTAwMDNcXHUxQUZBXHUwMDAzXFx1MUMwMlx1MDAwM1xcdTFDMEFcdTAwMDNcXHUxQzBDXHUwMDAzXFx1MUMzOFx1MDAwM1xcdTFDM0FcdTAwMDNcXHUxQzQyXHUwMDAzXFx1MUM1Mlx1MDAwM1xcdTFDNUJcdTAwMDNcXHUxQzc0XHUwMDAzXFx1MUM5MVx1MDAwM1xcdTFDOTRcdTAwMDNcXHUxQ0E5XHUwMDAzXFx1MUNBQlx1MDAwM1xcdTFDQjhcdTAwMDNcXHUyMDAyXHUwMDAzXFx1MjM5Qlx1MDAwM1xcdTI0MDJcdTAwMDNcXHUyNDcwXHUwMDAzXFx1MjQ4Mlx1MDAwM1xcdTI1NDVcdTAwMDNcXHUzMDAyXHUwMDAzXFx1MzQzMFx1MDAwM1xcdTQ0MDJcdTAwMDNcXHU0NjQ4XHUwMDAzXFx1NjgwMlx1MDAwM1xcdTZBM0FcdTAwMDNcXHU2QTQyXHUwMDAzXFx1NkE2MFx1MDAwM1xcdTZBNjJcdTAwMDNcXHU2QTZCXHUwMDAzXFx1NkFEMlx1MDAwM1xcdTZBRUZcdTAwMDNcXHU2QUYyXHUwMDAzXFx1NkFGNlx1MDAwM1xcdTZCMDJcdTAwMDNcXHU2QjM4XHUwMDAzXFx1NkI0Mlx1MDAwM1xcdTZCNDVcdTAwMDNcXHU2QjUyXHUwMDAzXFx1NkI1Qlx1MDAwM1xcdTZCNjVcdTAwMDNcXHU2Qjc5XHUwMDAzXFx1NkI3Rlx1MDAwM1xcdTZCOTFcdTAwMDNcXHU2RjAyXHUwMDAzXFx1NkY0Nlx1MDAwM1xcdTZGNTJcdTAwMDNcXHU2RjgwXHUwMDAzXFx1NkY5MVx1MDAwM1xcdTZGQTFcdTAwMDNcXHU2RkUyXHUwMDAzXFx1NkZFMlx1MDAwM1xcdTcwMDJcdTAwMDNcXHU4N0VFXHUwMDAzXFx1ODgwMlx1MDAwM1xcdThBRjRcdTAwMDNcXHVCMDAyXHUwMDAzXFx1QjAwM1x1MDAwM1xcdUJDMDJcdTAwMDNcXHVCQzZDXHUwMDAzXFx1QkM3Mlx1MDAwM1xcdUJDN0VcdTAwMDNcXHVCQzgyXHUwMDAzXFx1QkM4QVx1MDAwM1xcdUJDOTJcdTAwMDNcXHVCQzlCXHUwMDAzXFx1QkM5Rlx1MDAwM1xcdUJDQTBcdTAwMDNcXHVCQ0EyXHUwMDAzXFx1QkNBNVx1MDAwM1xcdUQxNjdcdTAwMDNcXHVEMTZCXHUwMDAzXFx1RDE2Rlx1MDAwM1xcdUQxODRcdTAwMDNcXHVEMTg3XHUwMDAzXFx1RDE4RFx1MDAwM1xcdUQxQUNcdTAwMDNcXHVEMUFGXHUwMDAzXFx1RDI0NFx1MDAwM1xcdUQyNDZcdTAwMDNcXHVENDAyXHUwMDAzXFx1RDQ1Nlx1MDAwM1xcdUQ0NThcdTAwMDNcXHVENDlFXHUwMDAzXFx1RDRBMFx1MDAwM1xcdUQ0QTFcdTAwMDNcXHVENEE0XHUwMDAzXFx1RDRBNFx1MDAwM1xcdUQ0QTdcdTAwMDNcXHVENEE4XHUwMDAzXFx1RDRBQlx1MDAwM1xcdUQ0QUVcdTAwMDNcXHVENEIwXHUwMDAzXFx1RDRCQlx1MDAwM1xcdUQ0QkRcdTAwMDNcXHVENEJEXHUwMDAzXFx1RDRCRlx1MDAwM1xcdUQ0QzVcdTAwMDNcXHVENEM3XHUwMDAzXFx1RDUwN1x1MDAwM1xcdUQ1MDlcdTAwMDNcXHVENTBDXHUwMDAzXFx1RDUwRlx1MDAwM1xcdUQ1MTZcdTAwMDNcXHVENTE4XHUwMDAzXFx1RDUxRVx1MDAwM1xcdUQ1MjBcdTAwMDNcXHVENTNCXHUwMDAzXFx1RDUzRFx1MDAwM1xcdUQ1NDBcdTAwMDNcXHVENTQyXHUwMDAzXFx1RDU0Nlx1MDAwM1xcdUQ1NDhcdTAwMDNcXHVENTQ4XHUwMDAzXFx1RDU0Q1x1MDAwM1xcdUQ1NTJcdTAwMDNcXHVENTU0XHUwMDAzXFx1RDZBN1x1MDAwM1xcdUQ2QUFcdTAwMDNcXHVENkMyXHUwMDAzXFx1RDZDNFx1MDAwM1xcdUQ2RENcdTAwMDNcXHVENkRFXHUwMDAzXFx1RDZGQ1x1MDAwM1xcdUQ2RkVcdTAwMDNcXHVENzE2XHUwMDAzXFx1RDcxOFx1MDAwM1xcdUQ3MzZcdTAwMDNcXHVENzM4XHUwMDAzXFx1RDc1MFx1MDAwM1xcdUQ3NTJcdTAwMDNcXHVENzcwXHUwMDAzXFx1RDc3Mlx1MDAwM1xcdUQ3OEFcdTAwMDNcXHVENzhDXHUwMDAzXFx1RDdBQVx1MDAwM1xcdUQ3QUNcdTAwMDNcXHVEN0M0XHUwMDAzXFx1RDdDNlx1MDAwM1xcdUQ3Q0RcdTAwMDNcXHVEN0QwXHUwMDAzXFx1RDgwMVx1MDAwM1xcdURBMDJcdTAwMDNcXHVEQTM4XHUwMDAzXFx1REEzRFx1MDAwM1xcdURBNkVcdTAwMDNcXHVEQTc3XHUwMDAzXFx1REE3N1x1MDAwM1xcdURBODZcdTAwMDNcXHVEQTg2XHUwMDAzXFx1REE5RFx1MDAwM1xcdURBQTFcdTAwMDNcXHVEQUEzXHUwMDAzXFx1REFCMVx1MDAwM1xcdUUwMDJcdTAwMDNcXHVFMDA4XHUwMDAzXFx1RTAwQVx1MDAwM1xcdUUwMUFcdTAwMDNcXHVFMDFEXHUwMDAzXFx1RTAyM1x1MDAwM1xcdUUwMjVcdTAwMDNcXHVFMDI2XHUwMDAzXFx1RTAyOFx1MDAwM1xcdUUwMkNcdTAwMDNcXHVFODAyXHUwMDAzXFx1RThDNlx1MDAwM1xcdUU4RDJcdTAwMDNcXHVFOEQ4XHUwMDAzXFx1RTkwMlx1MDAwM1xcdUU5NENcdTAwMDNcXHVFOTUyXHUwMDAzXFx1RTk1Qlx1MDAwM1xcdUVFMDJcdTAwMDNcXHVFRTA1XHUwMDAzXFx1RUUwN1x1MDAwM1xcdUVFMjFcdTAwMDNcXHVFRTIzXHUwMDAzXFx1RUUyNFx1MDAwM1xcdUVFMjZcdTAwMDNcXHVFRTI2XHUwMDAzXFx1RUUyOVx1MDAwM1xcdUVFMjlcdTAwMDNcXHVFRTJCXHUwMDAzXFx1RUUzNFx1MDAwM1xcdUVFMzZcdTAwMDNcXHVFRTM5XHUwMDAzXFx1RUUzQlx1MDAwM1xcdUVFM0JcdTAwMDNcXHVFRTNEXHUwMDAzXFx1RUUzRFx1MDAwM1xcdUVFNDRcdTAwMDNcXHVFRTQ0XHUwMDAzXFx1RUU0OVx1MDAwM1xcdUVFNDlcdTAwMDNcXHVFRTRCXHUwMDAzXFx1RUU0Qlx1MDAwM1xcdUVFNERcdTAwMDNcXHVFRTREXHUwMDAzXFx1RUU0Rlx1MDAwM1xcdUVFNTFcdTAwMDNcXHVFRTUzXHUwMDAzXFx1RUU1NFx1MDAwM1xcdUVFNTZcdTAwMDNcXHVFRTU2XHUwMDAzXFx1RUU1OVx1MDAwM1xcdUVFNTlcdTAwMDNcXHVFRTVCXHUwMDAzXFx1RUU1Qlx1MDAwM1xcdUVFNURcdTAwMDNcXHVFRTVEXHUwMDAzXFx1RUU1Rlx1MDAwM1xcdUVFNUZcdTAwMDNcXHVFRTYxXHUwMDAzXFx1RUU2MVx1MDAwM1xcdUVFNjNcdTAwMDNcXHVFRTY0XHUwMDAzXFx1RUU2Nlx1MDAwM1xcdUVFNjZcdTAwMDNcXHVFRTY5XHUwMDAzXFx1RUU2Q1x1MDAwM1xcdUVFNkVcdTAwMDNcXHVFRTc0XHUwMDAzXFx1RUU3Nlx1MDAwM1xcdUVFNzlcdTAwMDNcXHVFRTdCXHUwMDAzXFx1RUU3RVx1MDAwM1xcdUVFODBcdTAwMDNcXHVFRTgwXHUwMDAzXFx1RUU4Mlx1MDAwM1xcdUVFOEJcdTAwMDNcXHVFRThEXHUwMDAzXFx1RUU5RFx1MDAwM1xcdUVFQTNcdTAwMDNcXHVFRUE1XHUwMDAzXFx1RUVBN1x1MDAwM1xcdUVFQUJcdTAwMDNcXHVFRUFEXHUwMDAzXFx1RUVCRFx1MDAwM1x1MDAwMlx1MDAwNFxcdUE2RDhcdTAwMDRcXHVBNzAyXHUwMDA0XFx1QjczNlx1MDAwNFxcdUI3NDJcdTAwMDRcXHVCODFGXHUwMDA0XFx1QjgyMlx1MDAwNFxcdUNFQTNcdTAwMDRcXHVGODAyXHUwMDA0XFx1RkExRlx1MDAwNFx1MDAwM1x1MDAxMFx1MDAwM1x1MDAxMFwiXHUwMDEwXFx4ODFcdTAwMTBcXHUwMTAyXHUwMDEwXFx1MDFGMVx1MDAxMFxcdTAyNDBcdTAwMDJDXHUwMDAyXFxcXFx1MDAwMmNcdTAwMDJ8XHUwMDAyXFx4QUNcdTAwMDJcXHhBQ1x1MDAwMlxceEI3XHUwMDAyXFx4QjdcdTAwMDJcXHhCQ1x1MDAwMlxceEJDXHUwMDAyXFx4QzJcdTAwMDJcXHhEOFx1MDAwMlxceERBXHUwMDAyXFx4RjhcdTAwMDJcXHhGQVx1MDAwMlxcdTAyQzNcdTAwMDJcXHUwMkM4XHUwMDAyXFx1MDJEM1x1MDAwMlxcdTAyRTJcdTAwMDJcXHUwMkU2XHUwMDAyXFx1MDJFRVx1MDAwMlxcdTAyRUVcdTAwMDJcXHUwMkYwXHUwMDAyXFx1MDJGMFx1MDAwMlxcdTAzNzJcdTAwMDJcXHUwMzc2XHUwMDAyXFx1MDM3OFx1MDAwMlxcdTAzNzlcdTAwMDJcXHUwMzdDXHUwMDAyXFx1MDM3Rlx1MDAwMlxcdTAzODFcdTAwMDJcXHUwMzgxXHUwMDAyXFx1MDM4OFx1MDAwMlxcdTAzODhcdTAwMDJcXHUwMzhBXHUwMDAyXFx1MDM4Q1x1MDAwMlxcdTAzOEVcdTAwMDJcXHUwMzhFXHUwMDAyXFx1MDM5MFx1MDAwMlxcdTAzQTNcdTAwMDJcXHUwM0E1XHUwMDAyXFx1MDNGN1x1MDAwMlxcdTAzRjlcdTAwMDJcXHUwNDgzXHUwMDAyXFx1MDQ4Q1x1MDAwMlxcdTA1MzFcdTAwMDJcXHUwNTMzXHUwMDAyXFx1MDU1OFx1MDAwMlxcdTA1NUJcdTAwMDJcXHUwNTVCXHUwMDAyXFx1MDU2M1x1MDAwMlxcdTA1ODlcdTAwMDJcXHUwNUQyXHUwMDAyXFx1MDVFQ1x1MDAwMlxcdTA1RjJcdTAwMDJcXHUwNUY0XHUwMDAyXFx1MDYyMlx1MDAwMlxcdTA2NENcdTAwMDJcXHUwNjcwXHUwMDAyXFx1MDY3MVx1MDAwMlxcdTA2NzNcdTAwMDJcXHUwNkQ1XHUwMDAyXFx1MDZEN1x1MDAwMlxcdTA2RDdcdTAwMDJcXHUwNkU3XHUwMDAyXFx1MDZFOFx1MDAwMlxcdTA2RjBcdTAwMDJcXHUwNkYxXHUwMDAyXFx1MDZGQ1x1MDAwMlxcdTA2RkVcdTAwMDJcXHUwNzAxXHUwMDAyXFx1MDcwMVx1MDAwMlxcdTA3MTJcdTAwMDJcXHUwNzEyXHUwMDAyXFx1MDcxNFx1MDAwMlxcdTA3MzFcdTAwMDJcXHUwNzRGXHUwMDAyXFx1MDdBN1x1MDAwMlxcdTA3QjNcdTAwMDJcXHUwN0IzXHUwMDAyXFx1MDdDQ1x1MDAwMlxcdTA3RUNcdTAwMDJcXHUwN0Y2XHUwMDAyXFx1MDdGN1x1MDAwMlxcdTA3RkNcdTAwMDJcXHUwN0ZDXHUwMDAyXFx1MDgwMlx1MDAwMlxcdTA4MTdcdTAwMDJcXHUwODFDXHUwMDAyXFx1MDgxQ1x1MDAwMlxcdTA4MjZcdTAwMDJcXHUwODI2XHUwMDAyXFx1MDgyQVx1MDAwMlxcdTA4MkFcdTAwMDJcXHUwODQyXHUwMDAyXFx1MDg1QVx1MDAwMlxcdTA4QTJcdTAwMDJcXHUwOEI2XHUwMDAyXFx1MDhCOFx1MDAwMlxcdTA4QkZcdTAwMDJcXHUwOTA2XHUwMDAyXFx1MDkzQlx1MDAwMlxcdTA5M0ZcdTAwMDJcXHUwOTNGXHUwMDAyXFx1MDk1Mlx1MDAwMlxcdTA5NTJcdTAwMDJcXHUwOTVBXHUwMDAyXFx1MDk2M1x1MDAwMlxcdTA5NzNcdTAwMDJcXHUwOTgyXHUwMDAyXFx1MDk4N1x1MDAwMlxcdTA5OEVcdTAwMDJcXHUwOTkxXHUwMDAyXFx1MDk5Mlx1MDAwMlxcdTA5OTVcdTAwMDJcXHUwOUFBXHUwMDAyXFx1MDlBQ1x1MDAwMlxcdTA5QjJcdTAwMDJcXHUwOUI0XHUwMDAyXFx1MDlCNFx1MDAwMlxcdTA5QjhcdTAwMDJcXHUwOUJCXHUwMDAyXFx1MDlCRlx1MDAwMlxcdTA5QkZcdTAwMDJcXHUwOUQwXHUwMDAyXFx1MDlEMFx1MDAwMlxcdTA5REVcdTAwMDJcXHUwOURGXHUwMDAyXFx1MDlFMVx1MDAwMlxcdTA5RTNcdTAwMDJcXHUwOUYyXHUwMDAyXFx1MDlGM1x1MDAwMlxcdTBBMDdcdTAwMDJcXHUwQTBDXHUwMDAyXFx1MEExMVx1MDAwMlxcdTBBMTJcdTAwMDJcXHUwQTE1XHUwMDAyXFx1MEEyQVx1MDAwMlxcdTBBMkNcdTAwMDJcXHUwQTMyXHUwMDAyXFx1MEEzNFx1MDAwMlxcdTBBMzVcdTAwMDJcXHUwQTM3XHUwMDAyXFx1MEEzOFx1MDAwMlxcdTBBM0FcdTAwMDJcXHUwQTNCXHUwMDAyXFx1MEE1Qlx1MDAwMlxcdTBBNUVcdTAwMDJcXHUwQTYwXHUwMDAyXFx1MEE2MFx1MDAwMlxcdTBBNzRcdTAwMDJcXHUwQTc2XHUwMDAyXFx1MEE4N1x1MDAwMlxcdTBBOEZcdTAwMDJcXHUwQTkxXHUwMDAyXFx1MEE5M1x1MDAwMlxcdTBBOTVcdTAwMDJcXHUwQUFBXHUwMDAyXFx1MEFBQ1x1MDAwMlxcdTBBQjJcdTAwMDJcXHUwQUI0XHUwMDAyXFx1MEFCNVx1MDAwMlxcdTBBQjdcdTAwMDJcXHUwQUJCXHUwMDAyXFx1MEFCRlx1MDAwMlxcdTBBQkZcdTAwMDJcXHUwQUQyXHUwMDAyXFx1MEFEMlx1MDAwMlxcdTBBRTJcdTAwMDJcXHUwQUUzXHUwMDAyXFx1MEFGQlx1MDAwMlxcdTBBRkJcdTAwMDJcXHUwQjA3XHUwMDAyXFx1MEIwRVx1MDAwMlxcdTBCMTFcdTAwMDJcXHUwQjEyXHUwMDAyXFx1MEIxNVx1MDAwMlxcdTBCMkFcdTAwMDJcXHUwQjJDXHUwMDAyXFx1MEIzMlx1MDAwMlxcdTBCMzRcdTAwMDJcXHUwQjM1XHUwMDAyXFx1MEIzN1x1MDAwMlxcdTBCM0JcdTAwMDJcXHUwQjNGXHUwMDAyXFx1MEIzRlx1MDAwMlxcdTBCNUVcdTAwMDJcXHUwQjVGXHUwMDAyXFx1MEI2MVx1MDAwMlxcdTBCNjNcdTAwMDJcXHUwQjczXHUwMDAyXFx1MEI3M1x1MDAwMlxcdTBCODVcdTAwMDJcXHUwQjg1XHUwMDAyXFx1MEI4N1x1MDAwMlxcdTBCOENcdTAwMDJcXHUwQjkwXHUwMDAyXFx1MEI5Mlx1MDAwMlxcdTBCOTRcdTAwMDJcXHUwQjk3XHUwMDAyXFx1MEI5Qlx1MDAwMlxcdTBCOUNcdTAwMDJcXHUwQjlFXHUwMDAyXFx1MEI5RVx1MDAwMlxcdTBCQTBcdTAwMDJcXHUwQkExXHUwMDAyXFx1MEJBNVx1MDAwMlxcdTBCQTZcdTAwMDJcXHUwQkFBXHUwMDAyXFx1MEJBQ1x1MDAwMlxcdTBCQjBcdTAwMDJcXHUwQkJCXHUwMDAyXFx1MEJEMlx1MDAwMlxcdTBCRDJcdTAwMDJcXHUwQzA3XHUwMDAyXFx1MEMwRVx1MDAwMlxcdTBDMTBcdTAwMDJcXHUwQzEyXHUwMDAyXFx1MEMxNFx1MDAwMlxcdTBDMkFcdTAwMDJcXHUwQzJDXHUwMDAyXFx1MEMzQlx1MDAwMlxcdTBDM0ZcdTAwMDJcXHUwQzNGXHUwMDAyXFx1MEM1QVx1MDAwMlxcdTBDNUNcdTAwMDJcXHUwQzYyXHUwMDAyXFx1MEM2M1x1MDAwMlxcdTBDODJcdTAwMDJcXHUwQzgyXHUwMDAyXFx1MEM4N1x1MDAwMlxcdTBDOEVcdTAwMDJcXHUwQzkwXHUwMDAyXFx1MEM5Mlx1MDAwMlxcdTBDOTRcdTAwMDJcXHUwQ0FBXHUwMDAyXFx1MENBQ1x1MDAwMlxcdTBDQjVcdTAwMDJcXHUwQ0I3XHUwMDAyXFx1MENCQlx1MDAwMlxcdTBDQkZcdTAwMDJcXHUwQ0JGXHUwMDAyXFx1MENFMFx1MDAwMlxcdTBDRTBcdTAwMDJcXHUwQ0UyXHUwMDAyXFx1MENFM1x1MDAwMlxcdTBDRjNcdTAwMDJcXHUwQ0Y0XHUwMDAyXFx1MEQwN1x1MDAwMlxcdTBEMEVcdTAwMDJcXHUwRDEwXHUwMDAyXFx1MEQxMlx1MDAwMlxcdTBEMTRcdTAwMDJcXHUwRDNDXHUwMDAyXFx1MEQzRlx1MDAwMlxcdTBEM0ZcdTAwMDJcXHUwRDUwXHUwMDAyXFx1MEQ1MFx1MDAwMlxcdTBENTZcdTAwMDJcXHUwRDU4XHUwMDAyXFx1MEQ2MVx1MDAwMlxcdTBENjNcdTAwMDJcXHUwRDdDXHUwMDAyXFx1MEQ4MVx1MDAwMlxcdTBEODdcdTAwMDJcXHUwRDk4XHUwMDAyXFx1MEQ5Q1x1MDAwMlxcdTBEQjNcdTAwMDJcXHUwREI1XHUwMDAyXFx1MERCRFx1MDAwMlxcdTBEQkZcdTAwMDJcXHUwREJGXHUwMDAyXFx1MERDMlx1MDAwMlxcdTBEQzhcdTAwMDJcXHUwRTAzXHUwMDAyXFx1MEUzMlx1MDAwMlxcdTBFMzRcdTAwMDJcXHUwRTM1XHUwMDAyXFx1MEU0Mlx1MDAwMlxcdTBFNDhcdTAwMDJcXHUwRTgzXHUwMDAyXFx1MEU4NFx1MDAwMlxcdTBFODZcdTAwMDJcXHUwRTg2XHUwMDAyXFx1MEU4OVx1MDAwMlxcdTBFOEFcdTAwMDJcXHUwRThDXHUwMDAyXFx1MEU4Q1x1MDAwMlxcdTBFOEZcdTAwMDJcXHUwRThGXHUwMDAyXFx1MEU5Nlx1MDAwMlxcdTBFOTlcdTAwMDJcXHUwRTlCXHUwMDAyXFx1MEVBMVx1MDAwMlxcdTBFQTNcdTAwMDJcXHUwRUE1XHUwMDAyXFx1MEVBN1x1MDAwMlxcdTBFQTdcdTAwMDJcXHUwRUE5XHUwMDAyXFx1MEVBOVx1MDAwMlxcdTBFQUNcdTAwMDJcXHUwRUFEXHUwMDAyXFx1MEVBRlx1MDAwMlxcdTBFQjJcdTAwMDJcXHUwRUI0XHUwMDAyXFx1MEVCNVx1MDAwMlxcdTBFQkZcdTAwMDJcXHUwRUJGXHUwMDAyXFx1MEVDMlx1MDAwMlxcdTBFQzZcdTAwMDJcXHUwRUM4XHUwMDAyXFx1MEVDOFx1MDAwMlxcdTBFREVcdTAwMDJcXHUwRUUxXHUwMDAyXFx1MEYwMlx1MDAwMlxcdTBGMDJcdTAwMDJcXHUwRjQyXHUwMDAyXFx1MEY0OVx1MDAwMlxcdTBGNEJcdTAwMDJcXHUwRjZFXHUwMDAyXFx1MEY4QVx1MDAwMlxcdTBGOEVcdTAwMDJcXHUxMDAyXHUwMDAyXFx1MTAyQ1x1MDAwMlxcdTEwNDFcdTAwMDJcXHUxMDQxXHUwMDAyXFx1MTA1Mlx1MDAwMlxcdTEwNTdcdTAwMDJcXHUxMDVDXHUwMDAyXFx1MTA1Rlx1MDAwMlxcdTEwNjNcdTAwMDJcXHUxMDYzXHUwMDAyXFx1MTA2N1x1MDAwMlxcdTEwNjhcdTAwMDJcXHUxMDcwXHUwMDAyXFx1MTA3Mlx1MDAwMlxcdTEwNzdcdTAwMDJcXHUxMDgzXHUwMDAyXFx1MTA5MFx1MDAwMlxcdTEwOTBcdTAwMDJcXHUxMEEyXHUwMDAyXFx1MTBDN1x1MDAwMlxcdTEwQzlcdTAwMDJcXHUxMEM5XHUwMDAyXFx1MTBDRlx1MDAwMlxcdTEwQ0ZcdTAwMDJcXHUxMEQyXHUwMDAyXFx1MTBGQ1x1MDAwMlxcdTEwRkVcdTAwMDJcXHUxMjRBXHUwMDAyXFx1MTI0Q1x1MDAwMlxcdTEyNEZcdTAwMDJcXHUxMjUyXHUwMDAyXFx1MTI1OFx1MDAwMlxcdTEyNUFcdTAwMDJcXHUxMjVBXHUwMDAyXFx1MTI1Q1x1MDAwMlxcdTEyNUZcdTAwMDJcXHUxMjYyXHUwMDAyXFx1MTI4QVx1MDAwMlxcdTEyOENcdTAwMDJcXHUxMjhGXHUwMDAyXFx1MTI5Mlx1MDAwMlxcdTEyQjJcdTAwMDJcXHUxMkI0XHUwMDAyXFx1MTJCN1x1MDAwMlxcdTEyQkFcdTAwMDJcXHUxMkMwXHUwMDAyXFx1MTJDMlx1MDAwMlxcdTEyQzJcdTAwMDJcXHUxMkM0XHUwMDAyXFx1MTJDN1x1MDAwMlxcdTEyQ0FcdTAwMDJcXHUxMkQ4XHUwMDAyXFx1MTJEQVx1MDAwMlxcdTEzMTJcdTAwMDJcXHUxMzE0XHUwMDAyXFx1MTMxN1x1MDAwMlxcdTEzMUFcdTAwMDJcXHUxMzVDXHUwMDAyXFx1MTM4Mlx1MDAwMlxcdTEzOTFcdTAwMDJcXHUxM0EyXHUwMDAyXFx1MTNGN1x1MDAwMlxcdTEzRkFcdTAwMDJcXHUxM0ZGXHUwMDAyXFx1MTQwM1x1MDAwMlxcdTE2NkVcdTAwMDJcXHUxNjcxXHUwMDAyXFx1MTY4MVx1MDAwMlxcdTE2ODNcdTAwMDJcXHUxNjlDXHUwMDAyXFx1MTZBMlx1MDAwMlxcdTE2RUNcdTAwMDJcXHUxNkYwXHUwMDAyXFx1MTZGQVx1MDAwMlxcdTE3MDJcdTAwMDJcXHUxNzBFXHUwMDAyXFx1MTcxMFx1MDAwMlxcdTE3MTNcdTAwMDJcXHUxNzIyXHUwMDAyXFx1MTczM1x1MDAwMlxcdTE3NDJcdTAwMDJcXHUxNzUzXHUwMDAyXFx1MTc2Mlx1MDAwMlxcdTE3NkVcdTAwMDJcXHUxNzcwXHUwMDAyXFx1MTc3Mlx1MDAwMlxcdTE3ODJcdTAwMDJcXHUxN0I1XHUwMDAyXFx1MTdEOVx1MDAwMlxcdTE3RDlcdTAwMDJcXHUxN0RFXHUwMDAyXFx1MTdERVx1MDAwMlxcdTE4MjJcdTAwMDJcXHUxODc5XHUwMDAyXFx1MTg4Mlx1MDAwMlxcdTE4ODZcdTAwMDJcXHUxODg5XHUwMDAyXFx1MThBQVx1MDAwMlxcdTE4QUNcdTAwMDJcXHUxOEFDXHUwMDAyXFx1MThCMlx1MDAwMlxcdTE4RjdcdTAwMDJcXHUxOTAyXHUwMDAyXFx1MTkyMFx1MDAwMlxcdTE5NTJcdTAwMDJcXHUxOTZGXHUwMDAyXFx1MTk3Mlx1MDAwMlxcdTE5NzZcdTAwMDJcXHUxOTgyXHUwMDAyXFx1MTlBRFx1MDAwMlxcdTE5QjJcdTAwMDJcXHUxOUNCXHUwMDAyXFx1MUEwMlx1MDAwMlxcdTFBMThcdTAwMDJcXHUxQTIyXHUwMDAyXFx1MUE1Nlx1MDAwMlxcdTFBQTlcdTAwMDJcXHUxQUE5XHUwMDAyXFx1MUIwN1x1MDAwMlxcdTFCMzVcdTAwMDJcXHUxQjQ3XHUwMDAyXFx1MUI0RFx1MDAwMlxcdTFCODVcdTAwMDJcXHUxQkEyXHUwMDAyXFx1MUJCMFx1MDAwMlxcdTFCQjFcdTAwMDJcXHUxQkJDXHUwMDAyXFx1MUJFN1x1MDAwMlxcdTFDMDJcdTAwMDJcXHUxQzI1XHUwMDAyXFx1MUM0Rlx1MDAwMlxcdTFDNTFcdTAwMDJcXHUxQzVDXHUwMDAyXFx1MUM3Rlx1MDAwMlxcdTFDODJcdTAwMDJcXHUxQzhBXHUwMDAyXFx1MUNFQlx1MDAwMlxcdTFDRUVcdTAwMDJcXHUxQ0YwXHUwMDAyXFx1MUNGM1x1MDAwMlxcdTFDRjdcdTAwMDJcXHUxQ0Y4XHUwMDAyXFx1MUQwMlx1MDAwMlxcdTFEQzFcdTAwMDJcXHUxRTAyXHUwMDAyXFx1MUYxN1x1MDAwMlxcdTFGMUFcdTAwMDJcXHUxRjFGXHUwMDAyXFx1MUYyMlx1MDAwMlxcdTFGNDdcdTAwMDJcXHUxRjRBXHUwMDAyXFx1MUY0Rlx1MDAwMlxcdTFGNTJcdTAwMDJcXHUxRjU5XHUwMDAyXFx1MUY1Qlx1MDAwMlxcdTFGNUJcdTAwMDJcXHUxRjVEXHUwMDAyXFx1MUY1RFx1MDAwMlxcdTFGNUZcdTAwMDJcXHUxRjVGXHUwMDAyXFx1MUY2MVx1MDAwMlxcdTFGN0ZcdTAwMDJcXHUxRjgyXHUwMDAyXFx1MUZCNlx1MDAwMlxcdTFGQjhcdTAwMDJcXHUxRkJFXHUwMDAyXFx1MUZDMFx1MDAwMlxcdTFGQzBcdTAwMDJcXHUxRkM0XHUwMDAyXFx1MUZDNlx1MDAwMlxcdTFGQzhcdTAwMDJcXHUxRkNFXHUwMDAyXFx1MUZEMlx1MDAwMlxcdTFGRDVcdTAwMDJcXHUxRkQ4XHUwMDAyXFx1MUZERFx1MDAwMlxcdTFGRTJcdTAwMDJcXHUxRkVFXHUwMDAyXFx1MUZGNFx1MDAwMlxcdTFGRjZcdTAwMDJcXHUxRkY4XHUwMDAyXFx1MUZGRVx1MDAwMlxcdTIwNzNcdTAwMDJcXHUyMDczXHUwMDAyXFx1MjA4MVx1MDAwMlxcdTIwODFcdTAwMDJcXHUyMDkyXHUwMDAyXFx1MjA5RVx1MDAwMlxcdTIxMDRcdTAwMDJcXHUyMTA0XHUwMDAyXFx1MjEwOVx1MDAwMlxcdTIxMDlcdTAwMDJcXHUyMTBDXHUwMDAyXFx1MjExNVx1MDAwMlxcdTIxMTdcdTAwMDJcXHUyMTE3XHUwMDAyXFx1MjExQlx1MDAwMlxcdTIxMUZcdTAwMDJcXHUyMTI2XHUwMDAyXFx1MjEyNlx1MDAwMlxcdTIxMjhcdTAwMDJcXHUyMTI4XHUwMDAyXFx1MjEyQVx1MDAwMlxcdTIxMkFcdTAwMDJcXHUyMTJDXHUwMDAyXFx1MjEyRlx1MDAwMlxcdTIxMzFcdTAwMDJcXHUyMTNCXHUwMDAyXFx1MjEzRVx1MDAwMlxcdTIxNDFcdTAwMDJcXHUyMTQ3XHUwMDAyXFx1MjE0Qlx1MDAwMlxcdTIxNTBcdTAwMDJcXHUyMTUwXHUwMDAyXFx1MjE2Mlx1MDAwMlxcdTIxOEFcdTAwMDJcXHUyQzAyXHUwMDAyXFx1MkMzMFx1MDAwMlxcdTJDMzJcdTAwMDJcXHUyQzYwXHUwMDAyXFx1MkM2Mlx1MDAwMlxcdTJDRTZcdTAwMDJcXHUyQ0VEXHUwMDAyXFx1MkNGMFx1MDAwMlxcdTJDRjRcdTAwMDJcXHUyQ0Y1XHUwMDAyXFx1MkQwMlx1MDAwMlxcdTJEMjdcdTAwMDJcXHUyRDI5XHUwMDAyXFx1MkQyOVx1MDAwMlxcdTJEMkZcdTAwMDJcXHUyRDJGXHUwMDAyXFx1MkQzMlx1MDAwMlxcdTJENjlcdTAwMDJcXHUyRDcxXHUwMDAyXFx1MkQ3MVx1MDAwMlxcdTJEODJcdTAwMDJcXHUyRDk4XHUwMDAyXFx1MkRBMlx1MDAwMlxcdTJEQThcdTAwMDJcXHUyREFBXHUwMDAyXFx1MkRCMFx1MDAwMlxcdTJEQjJcdTAwMDJcXHUyREI4XHUwMDAyXFx1MkRCQVx1MDAwMlxcdTJEQzBcdTAwMDJcXHUyREMyXHUwMDAyXFx1MkRDOFx1MDAwMlxcdTJEQ0FcdTAwMDJcXHUyREQwXHUwMDAyXFx1MkREMlx1MDAwMlxcdTJERDhcdTAwMDJcXHUyRERBXHUwMDAyXFx1MkRFMFx1MDAwMlxcdTJFMzFcdTAwMDJcXHUyRTMxXHUwMDAyXFx1MzAwN1x1MDAwMlxcdTMwMDlcdTAwMDJcXHUzMDIzXHUwMDAyXFx1MzAyQlx1MDAwMlxcdTMwMzNcdTAwMDJcXHUzMDM3XHUwMDAyXFx1MzAzQVx1MDAwMlxcdTMwM0VcdTAwMDJcXHUzMDQzXHUwMDAyXFx1MzA5OFx1MDAwMlxcdTMwOUZcdTAwMDJcXHUzMEExXHUwMDAyXFx1MzBBM1x1MDAwMlxcdTMwRkNcdTAwMDJcXHUzMEZFXHUwMDAyXFx1MzEwMVx1MDAwMlxcdTMxMDdcdTAwMDJcXHUzMTJGXHUwMDAyXFx1MzEzM1x1MDAwMlxcdTMxOTBcdTAwMDJcXHUzMUEyXHUwMDAyXFx1MzFCQ1x1MDAwMlxcdTMxRjJcdTAwMDJcXHUzMjAxXHUwMDAyXFx1MzQwMlx1MDAwMlxcdTREQjdcdTAwMDJcXHU0RTAyXHUwMDAyXFx1OUZEN1x1MDAwMlxcdUEwMDJcdTAwMDJcXHVBNDhFXHUwMDAyXFx1QTREMlx1MDAwMlxcdUE0RkZcdTAwMDJcXHVBNTAyXHUwMDAyXFx1QTYwRVx1MDAwMlxcdUE2MTJcdTAwMDJcXHVBNjIxXHUwMDAyXFx1QTYyQ1x1MDAwMlxcdUE2MkRcdTAwMDJcXHVBNjQyXHUwMDAyXFx1QTY3MFx1MDAwMlxcdUE2ODFcdTAwMDJcXHVBNjlGXHUwMDAyXFx1QTZBMlx1MDAwMlxcdUE2RjFcdTAwMDJcXHVBNzE5XHUwMDAyXFx1QTcyMVx1MDAwMlxcdUE3MjRcdTAwMDJcXHVBNzhBXHUwMDAyXFx1QTc4RFx1MDAwMlxcdUE3QjBcdTAwMDJcXHVBN0IyXHUwMDAyXFx1QTdCOVx1MDAwMlxcdUE3RjlcdTAwMDJcXHVBODAzXHUwMDAyXFx1QTgwNVx1MDAwMlxcdUE4MDdcdTAwMDJcXHVBODA5XHUwMDAyXFx1QTgwQ1x1MDAwMlxcdUE4MEVcdTAwMDJcXHVBODI0XHUwMDAyXFx1QTg0Mlx1MDAwMlxcdUE4NzVcdTAwMDJcXHVBODg0XHUwMDAyXFx1QThCNVx1MDAwMlxcdUE4RjRcdTAwMDJcXHVBOEY5XHUwMDAyXFx1QThGRFx1MDAwMlxcdUE4RkRcdTAwMDJcXHVBOEZGXHUwMDAyXFx1QThGRlx1MDAwMlxcdUE5MENcdTAwMDJcXHVBOTI3XHUwMDAyXFx1QTkzMlx1MDAwMlxcdUE5NDhcdTAwMDJcXHVBOTYyXHUwMDAyXFx1QTk3RVx1MDAwMlxcdUE5ODZcdTAwMDJcXHVBOUI0XHUwMDAyXFx1QTlEMVx1MDAwMlxcdUE5RDFcdTAwMDJcXHVBOUUyXHUwMDAyXFx1QTlFNlx1MDAwMlxcdUE5RThcdTAwMDJcXHVBOUYxXHUwMDAyXFx1QTlGQ1x1MDAwMlxcdUFBMDBcdTAwMDJcXHVBQTAyXHUwMDAyXFx1QUEyQVx1MDAwMlxcdUFBNDJcdTAwMDJcXHVBQTQ0XHUwMDAyXFx1QUE0Nlx1MDAwMlxcdUFBNERcdTAwMDJcXHVBQTYyXHUwMDAyXFx1QUE3OFx1MDAwMlxcdUFBN0NcdTAwMDJcXHVBQTdDXHUwMDAyXFx1QUE4MFx1MDAwMlxcdUFBQjFcdTAwMDJcXHVBQUIzXHUwMDAyXFx1QUFCM1x1MDAwMlxcdUFBQjdcdTAwMDJcXHVBQUI4XHUwMDAyXFx1QUFCQlx1MDAwMlxcdUFBQkZcdTAwMDJcXHVBQUMyXHUwMDAyXFx1QUFDMlx1MDAwMlxcdUFBQzRcdTAwMDJcXHVBQUM0XHUwMDAyXFx1QUFERFx1MDAwMlxcdUFBREZcdTAwMDJcXHVBQUUyXHUwMDAyXFx1QUFFQ1x1MDAwMlxcdUFBRjRcdTAwMDJcXHVBQUY2XHUwMDAyXFx1QUIwM1x1MDAwMlxcdUFCMDhcdTAwMDJcXHVBQjBCXHUwMDAyXFx1QUIxMFx1MDAwMlxcdUFCMTNcdTAwMDJcXHVBQjE4XHUwMDAyXFx1QUIyMlx1MDAwMlxcdUFCMjhcdTAwMDJcXHVBQjJBXHUwMDAyXFx1QUIzMFx1MDAwMlxcdUFCMzJcdTAwMDJcXHVBQjVDXHUwMDAyXFx1QUI1RVx1MDAwMlxcdUFCNjdcdTAwMDJcXHVBQjcyXHUwMDAyXFx1QUJFNFx1MDAwMlxcdUFDMDJcdTAwMDJcXHVEN0E1XHUwMDAyXFx1RDdCMlx1MDAwMlxcdUQ3QzhcdTAwMDJcXHVEN0NEXHUwMDAyXFx1RDdGRFx1MDAwMlxcdUY5MDJcdTAwMDJcXHVGQTZGXHUwMDAyXFx1RkE3Mlx1MDAwMlxcdUZBREJcdTAwMDJcXHVGQjAyXHUwMDAyXFx1RkIwOFx1MDAwMlxcdUZCMTVcdTAwMDJcXHVGQjE5XHUwMDAyXFx1RkIxRlx1MDAwMlxcdUZCMUZcdTAwMDJcXHVGQjIxXHUwMDAyXFx1RkIyQVx1MDAwMlxcdUZCMkNcdTAwMDJcXHVGQjM4XHUwMDAyXFx1RkIzQVx1MDAwMlxcdUZCM0VcdTAwMDJcXHVGQjQwXHUwMDAyXFx1RkI0MFx1MDAwMlxcdUZCNDJcdTAwMDJcXHVGQjQzXHUwMDAyXFx1RkI0NVx1MDAwMlxcdUZCNDZcdTAwMDJcXHVGQjQ4XHUwMDAyXFx1RkJCM1x1MDAwMlxcdUZCRDVcdTAwMDJcXHVGRDNGXHUwMDAyXFx1RkQ1Mlx1MDAwMlxcdUZEOTFcdTAwMDJcXHVGRDk0XHUwMDAyXFx1RkRDOVx1MDAwMlxcdUZERjJcdTAwMDJcXHVGREZEXHUwMDAyXFx1RkU3Mlx1MDAwMlxcdUZFNzZcdTAwMDJcXHVGRTc4XHUwMDAyXFx1RkVGRVx1MDAwMlxcdUZGMjNcdTAwMDJcXHVGRjNDXHUwMDAyXFx1RkY0M1x1MDAwMlxcdUZGNUNcdTAwMDJcXHVGRjY4XHUwMDAyXFx1RkZDMFx1MDAwMlxcdUZGQzRcdTAwMDJcXHVGRkM5XHUwMDAyXFx1RkZDQ1x1MDAwMlxcdUZGRDFcdTAwMDJcXHVGRkQ0XHUwMDAyXFx1RkZEOVx1MDAwMlxcdUZGRENcdTAwMDJcXHVGRkRFXHUwMDAyXHUwMDAyXHUwMDAzXFxyXHUwMDAzXHUwMDBmXHUwMDAzKFx1MDAwMypcdTAwMDM8XHUwMDAzPlx1MDAwMz9cdTAwMDNBXHUwMDAzT1x1MDAwM1JcdTAwMDNfXHUwMDAzXFx4ODJcdTAwMDNcXHhGQ1x1MDAwM1xcdTAxNDJcdTAwMDNcXHUwMTc2XHUwMDAzXFx1MDI4Mlx1MDAwM1xcdTAyOUVcdTAwMDNcXHUwMkEyXHUwMDAzXFx1MDJEMlx1MDAwM1xcdTAzMDJcdTAwMDNcXHUwMzIxXHUwMDAzXFx1MDMzMlx1MDAwM1xcdTAzNENcdTAwMDNcXHUwMzUyXHUwMDAzXFx1MDM3N1x1MDAwM1xcdTAzODJcdTAwMDNcXHUwMzlGXHUwMDAzXFx1MDNBMlx1MDAwM1xcdTAzQzVcdTAwMDNcXHUwM0NBXHUwMDAzXFx1MDNEMVx1MDAwM1xcdTAzRDNcdTAwMDNcXHUwM0Q3XHUwMDAzXFx1MDQwMlx1MDAwM1xcdTA0OUZcdTAwMDNcXHUwNEIyXHUwMDAzXFx1MDRENVx1MDAwM1xcdTA0REFcdTAwMDNcXHUwNEZEXHUwMDAzXFx1MDUwMlx1MDAwM1xcdTA1MjlcdTAwMDNcXHUwNTMyXHUwMDAzXFx1MDU2NVx1MDAwM1xcdTA2MDJcdTAwMDNcXHUwNzM4XHUwMDAzXFx1MDc0Mlx1MDAwM1xcdTA3NTdcdTAwMDNcXHUwNzYyXHUwMDAzXFx1MDc2OVx1MDAwM1xcdTA4MDJcdTAwMDNcXHUwODA3XHUwMDAzXFx1MDgwQVx1MDAwM1xcdTA4MEFcdTAwMDNcXHUwODBDXHUwMDAzXFx1MDgzN1x1MDAwM1xcdTA4MzlcdTAwMDNcXHUwODNBXHUwMDAzXFx1MDgzRVx1MDAwM1xcdTA4M0VcdTAwMDNcXHUwODQxXHUwMDAzXFx1MDg1N1x1MDAwM1xcdTA4NjJcdTAwMDNcXHUwODc4XHUwMDAzXFx1MDg4Mlx1MDAwM1xcdTA4QTBcdTAwMDNcXHUwOEUyXHUwMDAzXFx1MDhGNFx1MDAwM1xcdTA4RjZcdTAwMDNcXHUwOEY3XHUwMDAzXFx1MDkwMlx1MDAwM1xcdTA5MTdcdTAwMDNcXHUwOTIyXHUwMDAzXFx1MDkzQlx1MDAwM1xcdTA5ODJcdTAwMDNcXHUwOUI5XHUwMDAzXFx1MDlDMFx1MDAwM1xcdTA5QzFcdTAwMDNcXHUwQTAyXHUwMDAzXFx1MEEwMlx1MDAwM1xcdTBBMTJcdTAwMDNcXHUwQTE1XHUwMDAzXFx1MEExN1x1MDAwM1xcdTBBMTlcdTAwMDNcXHUwQTFCXHUwMDAzXFx1MEEzNVx1MDAwM1xcdTBBNjJcdTAwMDNcXHUwQTdFXHUwMDAzXFx1MEE4Mlx1MDAwM1xcdTBBOUVcdTAwMDNcXHUwQUMyXHUwMDAzXFx1MEFDOVx1MDAwM1xcdTBBQ0JcdTAwMDNcXHUwQUU2XHUwMDAzXFx1MEIwMlx1MDAwM1xcdTBCMzdcdTAwMDNcXHUwQjQyXHUwMDAzXFx1MEI1N1x1MDAwM1xcdTBCNjJcdTAwMDNcXHUwQjc0XHUwMDAzXFx1MEI4Mlx1MDAwM1xcdTBCOTNcdTAwMDNcXHUwQzAyXHUwMDAzXFx1MEM0QVx1MDAwM1xcdTBDODJcdTAwMDNcXHUwQ0I0XHUwMDAzXFx1MENDMlx1MDAwM1xcdTBDRjRcdTAwMDNcXHUxMDA1XHUwMDAzXFx1MTAzOVx1MDAwM1xcdTEwODVcdTAwMDNcXHUxMEIxXHUwMDAzXFx1MTBEMlx1MDAwM1xcdTEwRUFcdTAwMDNcXHUxMTA1XHUwMDAzXFx1MTEyOFx1MDAwM1xcdTExNTJcdTAwMDNcXHUxMTc0XHUwMDAzXFx1MTE3OFx1MDAwM1xcdTExNzhcdTAwMDNcXHUxMTg1XHUwMDAzXFx1MTFCNFx1MDAwM1xcdTExQzNcdTAwMDNcXHUxMUM2XHUwMDAzXFx1MTFEQ1x1MDAwM1xcdTExRENcdTAwMDNcXHUxMURFXHUwMDAzXFx1MTFERVx1MDAwM1xcdTEyMDJcdTAwMDNcXHUxMjEzXHUwMDAzXFx1MTIxNVx1MDAwM1xcdTEyMkRcdTAwMDNcXHUxMjgyXHUwMDAzXFx1MTI4OFx1MDAwM1xcdTEyOEFcdTAwMDNcXHUxMjhBXHUwMDAzXFx1MTI4Q1x1MDAwM1xcdTEyOEZcdTAwMDNcXHUxMjkxXHUwMDAzXFx1MTI5Rlx1MDAwM1xcdTEyQTFcdTAwMDNcXHUxMkFBXHUwMDAzXFx1MTJCMlx1MDAwM1xcdTEyRTBcdTAwMDNcXHUxMzA3XHUwMDAzXFx1MTMwRVx1MDAwM1xcdTEzMTFcdTAwMDNcXHUxMzEyXHUwMDAzXFx1MTMxNVx1MDAwM1xcdTEzMkFcdTAwMDNcXHUxMzJDXHUwMDAzXFx1MTMzMlx1MDAwM1xcdTEzMzRcdTAwMDNcXHUxMzM1XHUwMDAzXFx1MTMzN1x1MDAwM1xcdTEzM0JcdTAwMDNcXHUxMzNGXHUwMDAzXFx1MTMzRlx1MDAwM1xcdTEzNTJcdTAwMDNcXHUxMzUyXHUwMDAzXFx1MTM1Rlx1MDAwM1xcdTEzNjNcdTAwMDNcXHUxNDAyXHUwMDAzXFx1MTQzNlx1MDAwM1xcdTE0NDlcdTAwMDNcXHUxNDRDXHUwMDAzXFx1MTQ4Mlx1MDAwM1xcdTE0QjFcdTAwMDNcXHUxNEM2XHUwMDAzXFx1MTRDN1x1MDAwM1xcdTE0QzlcdTAwMDNcXHUxNEM5XHUwMDAzXFx1MTU4Mlx1MDAwM1xcdTE1QjBcdTAwMDNcXHUxNURBXHUwMDAzXFx1MTVERFx1MDAwM1xcdTE2MDJcdTAwMDNcXHUxNjMxXHUwMDAzXFx1MTY0Nlx1MDAwM1xcdTE2NDZcdTAwMDNcXHUxNjgyXHUwMDAzXFx1MTZBQ1x1MDAwM1xcdTE3MDJcdTAwMDNcXHUxNzFCXHUwMDAzXFx1MThBMlx1MDAwM1xcdTE4RTFcdTAwMDNcXHUxOTAxXHUwMDAzXFx1MTkwMVx1MDAwM1xcdTFBQzJcdTAwMDNcXHUxQUZBXHUwMDAzXFx1MUMwMlx1MDAwM1xcdTFDMEFcdTAwMDNcXHUxQzBDXHUwMDAzXFx1MUMzMFx1MDAwM1xcdTFDNDJcdTAwMDNcXHUxQzQyXHUwMDAzXFx1MUM3NFx1MDAwM1xcdTFDOTFcdTAwMDNcXHUyMDAyXHUwMDAzXFx1MjM5Qlx1MDAwM1xcdTI0MDJcdTAwMDNcXHUyNDcwXHUwMDAzXFx1MjQ4Mlx1MDAwM1xcdTI1NDVcdTAwMDNcXHUzMDAyXHUwMDAzXFx1MzQzMFx1MDAwM1xcdTQ0MDJcdTAwMDNcXHU0NjQ4XHUwMDAzXFx1NjgwMlx1MDAwM1xcdTZBM0FcdTAwMDNcXHU2QTQyXHUwMDAzXFx1NkE2MFx1MDAwM1xcdTZBRDJcdTAwMDNcXHU2QUVGXHUwMDAzXFx1NkIwMlx1MDAwM1xcdTZCMzFcdTAwMDNcXHU2QjQyXHUwMDAzXFx1NkI0NVx1MDAwM1xcdTZCNjVcdTAwMDNcXHU2Qjc5XHUwMDAzXFx1NkI3Rlx1MDAwM1xcdTZCOTFcdTAwMDNcXHU2RjAyXHUwMDAzXFx1NkY0Nlx1MDAwM1xcdTZGNTJcdTAwMDNcXHU2RjUyXHUwMDAzXFx1NkY5NVx1MDAwM1xcdTZGQTFcdTAwMDNcXHU2RkUyXHUwMDAzXFx1NkZFMlx1MDAwM1xcdTcwMDJcdTAwMDNcXHU4N0VFXHUwMDAzXFx1ODgwMlx1MDAwM1xcdThBRjRcdTAwMDNcXHVCMDAyXHUwMDAzXFx1QjAwM1x1MDAwM1xcdUJDMDJcdTAwMDNcXHVCQzZDXHUwMDAzXFx1QkM3Mlx1MDAwM1xcdUJDN0VcdTAwMDNcXHVCQzgyXHUwMDAzXFx1QkM4QVx1MDAwM1xcdUJDOTJcdTAwMDNcXHVCQzlCXHUwMDAzXFx1RDQwMlx1MDAwM1xcdUQ0NTZcdTAwMDNcXHVENDU4XHUwMDAzXFx1RDQ5RVx1MDAwM1xcdUQ0QTBcdTAwMDNcXHVENEExXHUwMDAzXFx1RDRBNFx1MDAwM1xcdUQ0QTRcdTAwMDNcXHVENEE3XHUwMDAzXFx1RDRBOFx1MDAwM1xcdUQ0QUJcdTAwMDNcXHVENEFFXHUwMDAzXFx1RDRCMFx1MDAwM1xcdUQ0QkJcdTAwMDNcXHVENEJEXHUwMDAzXFx1RDRCRFx1MDAwM1xcdUQ0QkZcdTAwMDNcXHVENEM1XHUwMDAzXFx1RDRDN1x1MDAwM1xcdUQ1MDdcdTAwMDNcXHVENTA5XHUwMDAzXFx1RDUwQ1x1MDAwM1xcdUQ1MEZcdTAwMDNcXHVENTE2XHUwMDAzXFx1RDUxOFx1MDAwM1xcdUQ1MUVcdTAwMDNcXHVENTIwXHUwMDAzXFx1RDUzQlx1MDAwM1xcdUQ1M0RcdTAwMDNcXHVENTQwXHUwMDAzXFx1RDU0Mlx1MDAwM1xcdUQ1NDZcdTAwMDNcXHVENTQ4XHUwMDAzXFx1RDU0OCc7XG4gIFhQYXRoTGV4ZXIuX3NlcmlhbGl6ZWRBVE5TZWdtZW50MSA9IGBcdTAwMDNcXHVENTRDXHUwMDAzXFx1RDU1Mlx1MDAwM1xcdUQ1NTRcdTAwMDNcXHVENkE3XHUwMDAzXFx1RDZBQVx1MDAwM1xcdUQ2QzJcdTAwMDNcXHVENkM0XHUwMDAzXFx1RDZEQ1x1MDAwM1xcdUQ2REVcdTAwMDNcXHVENkZDXHUwMDAzXFx1RDZGRVx1MDAwM1xcdUQ3MTZcdTAwMDNcXHVENzE4XHUwMDAzXFx1RDczNlx1MDAwM1xcdUQ3MzhcdTAwMDNcXHVENzUwXHUwMDAzXFx1RDc1Mlx1MDAwM1xcdUQ3NzBcdTAwMDNcXHVENzcyXHUwMDAzXFx1RDc4QVx1MDAwM1xcdUQ3OENcdTAwMDNcXHVEN0FBXHUwMDAzXFx1RDdBQ1x1MDAwM1xcdUQ3QzRcdTAwMDNcXHVEN0M2XHUwMDAzXFx1RDdDRFx1MDAwM1xcdUU4MDJcdTAwMDNcXHVFOEM2XHUwMDAzXFx1RTkwMlx1MDAwM1xcdUU5NDVcdTAwMDNcXHVFRTAyXHUwMDAzXFx1RUUwNVx1MDAwM1xcdUVFMDdcdTAwMDNcXHVFRTIxXHUwMDAzXFx1RUUyM1x1MDAwM1xcdUVFMjRcdTAwMDNcXHVFRTI2XHUwMDAzXFx1RUUyNlx1MDAwM1xcdUVFMjlcdTAwMDNcXHVFRTI5XHUwMDAzXFx1RUUyQlx1MDAwM1xcdUVFMzRcdTAwMDNcXHVFRTM2XHUwMDAzXFx1RUUzOVx1MDAwM1xcdUVFM0JcdTAwMDNcXHVFRTNCXHUwMDAzXFx1RUUzRFx1MDAwM1xcdUVFM0RcdTAwMDNcXHVFRTQ0XHUwMDAzXFx1RUU0NFx1MDAwM1xcdUVFNDlcdTAwMDNcXHVFRTQ5XHUwMDAzXFx1RUU0Qlx1MDAwM1xcdUVFNEJcdTAwMDNcXHVFRTREXHUwMDAzXFx1RUU0RFx1MDAwM1xcdUVFNEZcdTAwMDNcXHVFRTUxXHUwMDAzXFx1RUU1M1x1MDAwM1xcdUVFNTRcdTAwMDNcXHVFRTU2XHUwMDAzXFx1RUU1Nlx1MDAwM1xcdUVFNTlcdTAwMDNcXHVFRTU5XHUwMDAzXFx1RUU1Qlx1MDAwM1xcdUVFNUJcdTAwMDNcXHVFRTVEXHUwMDAzXFx1RUU1RFx1MDAwM1xcdUVFNUZcdTAwMDNcXHVFRTVGXHUwMDAzXFx1RUU2MVx1MDAwM1xcdUVFNjFcdTAwMDNcXHVFRTYzXHUwMDAzXFx1RUU2NFx1MDAwM1xcdUVFNjZcdTAwMDNcXHVFRTY2XHUwMDAzXFx1RUU2OVx1MDAwM1xcdUVFNkNcdTAwMDNcXHVFRTZFXHUwMDAzXFx1RUU3NFx1MDAwM1xcdUVFNzZcdTAwMDNcXHVFRTc5XHUwMDAzXFx1RUU3Qlx1MDAwM1xcdUVFN0VcdTAwMDNcXHVFRTgwXHUwMDAzXFx1RUU4MFx1MDAwM1xcdUVFODJcdTAwMDNcXHVFRThCXHUwMDAzXFx1RUU4RFx1MDAwM1xcdUVFOURcdTAwMDNcXHVFRUEzXHUwMDAzXFx1RUVBNVx1MDAwM1xcdUVFQTdcdTAwMDNcXHVFRUFCXHUwMDAzXFx1RUVBRFx1MDAwM1xcdUVFQkRcdTAwMDNcdTAwMDJcdTAwMDRcXHVBNkQ4XHUwMDA0XFx1QTcwMlx1MDAwNFxcdUI3MzZcdTAwMDRcXHVCNzQyXHUwMDA0XFx1QjgxRlx1MDAwNFxcdUI4MjJcdTAwMDRcXHVDRUEzXHUwMDA0XFx1RjgwMlx1MDAwNFxcdUZBMUZcdTAwMDQxXHUwMDAyXHUwMDAzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDA1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx4MDdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcdFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxcdlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlx1MDAxMVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwM1x1MDAxM1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwNVx1MDAxNlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxceDA3XHUwMDE4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHRcdTAwMWFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHZcdTAwMWNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHIlXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDBmJ1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAxMSlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMTNcdTAwMTRcXHgwNzFcdTAwMDJcdTAwMDJcdTAwMTRcdTAwMTVcXHgwNzFcdTAwMDJcdTAwMDJcdTAwMTVcdTAwMDRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMTZcdTAwMTdcXHgwNzFcdTAwMDJcdTAwMDJcdTAwMTdcdTAwMDZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMThcdTAwMTlcXHgwNyxcdTAwMDJcdTAwMDJcdTAwMTlcXGJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMWFcdTAwMWJcXHgwNyNcdTAwMDJcdTAwMDJcdTAwMWJcblx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAxYyBcdTAwMDVcdTAwMGZcXGJcdTAwMDJcdTAwMWRcdTAwMWZcdTAwMDVcXHJcXHgwN1x1MDAwMlx1MDAxZVx1MDAxZFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAxZlwiXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyIFx1MDAxZVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMiAhXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyISNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcIiBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDIjJFxcYlx1MDAwNlx1MDAwMlx1MDAwMiRcXGZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDIlJlx0XHUwMDAyXHUwMDAyXHUwMDAyJlx1MDAwZVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMicoXHRcdTAwMDNcdTAwMDJcdTAwMDIoXHUwMDEwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyKS1cXHgwNylcdTAwMDJcdTAwMDIqLFxcdlx1MDAwMlx1MDAwMlx1MDAwMisqXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyLC9cdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDItLlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMi0rXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyLjBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDIvLVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMjAxXFx4MDcpXHUwMDAyXHUwMDAyMVx1MDAxMlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwNVx1MDAwMiAtXHUwMDAzXHUwMDAzXHUwMDA2XHUwMDAyYDtcbiAgWFBhdGhMZXhlci5fc2VyaWFsaXplZEFUTiA9IFV0aWxzMy5qb2luKFtcbiAgICBYUGF0aExleGVyLl9zZXJpYWxpemVkQVROU2VnbWVudDAsXG4gICAgWFBhdGhMZXhlci5fc2VyaWFsaXplZEFUTlNlZ21lbnQxXG4gIF0sIFwiXCIpO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy90cmVlL3hwYXRoL1hQYXRoTGV4ZXJFcnJvckxpc3RlbmVyLmpzXG52YXIgcmVxdWlyZV9YUGF0aExleGVyRXJyb3JMaXN0ZW5lciA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5YUGF0aExleGVyRXJyb3JMaXN0ZW5lciA9IHZvaWQgMDtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgWFBhdGhMZXhlckVycm9yTGlzdGVuZXIgPSBjbGFzcyB7XG4gICAgc3ludGF4RXJyb3IocmVjb2duaXplciwgb2ZmZW5kaW5nU3ltYm9sLCBsaW5lLCBjaGFyUG9zaXRpb25JbkxpbmUsIG1zZywgZSkge1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFhQYXRoTGV4ZXJFcnJvckxpc3RlbmVyLnByb3RvdHlwZSwgXCJzeW50YXhFcnJvclwiLCBudWxsKTtcbiAgZXhwb3J0cy5YUGF0aExleGVyRXJyb3JMaXN0ZW5lciA9IFhQYXRoTGV4ZXJFcnJvckxpc3RlbmVyO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy90cmVlL3hwYXRoL1hQYXRoRWxlbWVudC5qc1xudmFyIHJlcXVpcmVfWFBhdGhFbGVtZW50ID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLlhQYXRoRWxlbWVudCA9IHZvaWQgMDtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgWFBhdGhFbGVtZW50ID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKG5vZGVOYW1lKSB7XG4gICAgICB0aGlzLm5vZGVOYW1lID0gbm9kZU5hbWU7XG4gICAgICB0aGlzLmludmVydCA9IGZhbHNlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIGxldCBpbnYgPSB0aGlzLmludmVydCA/IFwiIVwiIDogXCJcIjtcbiAgICAgIGxldCBjbGFzc05hbWUgPSBPYmplY3QuY29uc3RydWN0b3IubmFtZTtcbiAgICAgIHJldHVybiBjbGFzc05hbWUgKyBcIltcIiArIGludiArIHRoaXMubm9kZU5hbWUgKyBcIl1cIjtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBYUGF0aEVsZW1lbnQucHJvdG90eXBlLCBcInRvU3RyaW5nXCIsIG51bGwpO1xuICBleHBvcnRzLlhQYXRoRWxlbWVudCA9IFhQYXRoRWxlbWVudDtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvdHJlZS94cGF0aC9YUGF0aFJ1bGVBbnl3aGVyZUVsZW1lbnQuanNcbnZhciByZXF1aXJlX1hQYXRoUnVsZUFueXdoZXJlRWxlbWVudCA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5YUGF0aFJ1bGVBbnl3aGVyZUVsZW1lbnQgPSB2b2lkIDA7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIFRyZWVzXzEgPSByZXF1aXJlX1RyZWVzKCk7XG4gIHZhciBYUGF0aEVsZW1lbnRfMSA9IHJlcXVpcmVfWFBhdGhFbGVtZW50KCk7XG4gIHZhciBYUGF0aFJ1bGVBbnl3aGVyZUVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIFhQYXRoRWxlbWVudF8xLlhQYXRoRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IocnVsZU5hbWUsIHJ1bGVJbmRleCkge1xuICAgICAgc3VwZXIocnVsZU5hbWUpO1xuICAgICAgdGhpcy5ydWxlSW5kZXggPSBydWxlSW5kZXg7XG4gICAgfVxuICAgIGV2YWx1YXRlKHQpIHtcbiAgICAgIHJldHVybiBUcmVlc18xLlRyZWVzLmZpbmRBbGxSdWxlTm9kZXModCwgdGhpcy5ydWxlSW5kZXgpO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFhQYXRoUnVsZUFueXdoZXJlRWxlbWVudC5wcm90b3R5cGUsIFwiZXZhbHVhdGVcIiwgbnVsbCk7XG4gIGV4cG9ydHMuWFBhdGhSdWxlQW55d2hlcmVFbGVtZW50ID0gWFBhdGhSdWxlQW55d2hlcmVFbGVtZW50O1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy90cmVlL3hwYXRoL1hQYXRoUnVsZUVsZW1lbnQuanNcbnZhciByZXF1aXJlX1hQYXRoUnVsZUVsZW1lbnQgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuWFBhdGhSdWxlRWxlbWVudCA9IHZvaWQgMDtcbiAgdmFyIFBhcnNlclJ1bGVDb250ZXh0XzEgPSByZXF1aXJlX1BhcnNlclJ1bGVDb250ZXh0KCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIFRyZWVzXzEgPSByZXF1aXJlX1RyZWVzKCk7XG4gIHZhciBYUGF0aEVsZW1lbnRfMSA9IHJlcXVpcmVfWFBhdGhFbGVtZW50KCk7XG4gIHZhciBYUGF0aFJ1bGVFbGVtZW50ID0gY2xhc3MgZXh0ZW5kcyBYUGF0aEVsZW1lbnRfMS5YUGF0aEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHJ1bGVOYW1lLCBydWxlSW5kZXgpIHtcbiAgICAgIHN1cGVyKHJ1bGVOYW1lKTtcbiAgICAgIHRoaXMucnVsZUluZGV4ID0gcnVsZUluZGV4O1xuICAgIH1cbiAgICBldmFsdWF0ZSh0KSB7XG4gICAgICBsZXQgbm9kZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGMgb2YgVHJlZXNfMS5UcmVlcy5nZXRDaGlsZHJlbih0KSkge1xuICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIFBhcnNlclJ1bGVDb250ZXh0XzEuUGFyc2VyUnVsZUNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoYy5ydWxlSW5kZXggPT09IHRoaXMucnVsZUluZGV4ICYmICF0aGlzLmludmVydCB8fCBjLnJ1bGVJbmRleCAhPT0gdGhpcy5ydWxlSW5kZXggJiYgdGhpcy5pbnZlcnQpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgWFBhdGhSdWxlRWxlbWVudC5wcm90b3R5cGUsIFwiZXZhbHVhdGVcIiwgbnVsbCk7XG4gIGV4cG9ydHMuWFBhdGhSdWxlRWxlbWVudCA9IFhQYXRoUnVsZUVsZW1lbnQ7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL3RyZWUveHBhdGgvWFBhdGhUb2tlbkFueXdoZXJlRWxlbWVudC5qc1xudmFyIHJlcXVpcmVfWFBhdGhUb2tlbkFueXdoZXJlRWxlbWVudCA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5YUGF0aFRva2VuQW55d2hlcmVFbGVtZW50ID0gdm9pZCAwO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBUcmVlc18xID0gcmVxdWlyZV9UcmVlcygpO1xuICB2YXIgWFBhdGhFbGVtZW50XzEgPSByZXF1aXJlX1hQYXRoRWxlbWVudCgpO1xuICB2YXIgWFBhdGhUb2tlbkFueXdoZXJlRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgWFBhdGhFbGVtZW50XzEuWFBhdGhFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbk5hbWUsIHRva2VuVHlwZSkge1xuICAgICAgc3VwZXIodG9rZW5OYW1lKTtcbiAgICAgIHRoaXMudG9rZW5UeXBlID0gdG9rZW5UeXBlO1xuICAgIH1cbiAgICBldmFsdWF0ZSh0KSB7XG4gICAgICByZXR1cm4gVHJlZXNfMS5UcmVlcy5maW5kQWxsVG9rZW5Ob2Rlcyh0LCB0aGlzLnRva2VuVHlwZSk7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgWFBhdGhUb2tlbkFueXdoZXJlRWxlbWVudC5wcm90b3R5cGUsIFwiZXZhbHVhdGVcIiwgbnVsbCk7XG4gIGV4cG9ydHMuWFBhdGhUb2tlbkFueXdoZXJlRWxlbWVudCA9IFhQYXRoVG9rZW5Bbnl3aGVyZUVsZW1lbnQ7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL3RyZWUveHBhdGgvWFBhdGhUb2tlbkVsZW1lbnQuanNcbnZhciByZXF1aXJlX1hQYXRoVG9rZW5FbGVtZW50ID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLlhQYXRoVG9rZW5FbGVtZW50ID0gdm9pZCAwO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBUZXJtaW5hbE5vZGVfMSA9IHJlcXVpcmVfVGVybWluYWxOb2RlKCk7XG4gIHZhciBUcmVlc18xID0gcmVxdWlyZV9UcmVlcygpO1xuICB2YXIgWFBhdGhFbGVtZW50XzEgPSByZXF1aXJlX1hQYXRoRWxlbWVudCgpO1xuICB2YXIgWFBhdGhUb2tlbkVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIFhQYXRoRWxlbWVudF8xLlhQYXRoRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IodG9rZW5OYW1lLCB0b2tlblR5cGUpIHtcbiAgICAgIHN1cGVyKHRva2VuTmFtZSk7XG4gICAgICB0aGlzLnRva2VuVHlwZSA9IHRva2VuVHlwZTtcbiAgICB9XG4gICAgZXZhbHVhdGUodCkge1xuICAgICAgbGV0IG5vZGVzID0gW107XG4gICAgICBmb3IgKGxldCBjIG9mIFRyZWVzXzEuVHJlZXMuZ2V0Q2hpbGRyZW4odCkpIHtcbiAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBUZXJtaW5hbE5vZGVfMS5UZXJtaW5hbE5vZGUpIHtcbiAgICAgICAgICBpZiAoYy5zeW1ib2wudHlwZSA9PT0gdGhpcy50b2tlblR5cGUgJiYgIXRoaXMuaW52ZXJ0IHx8IGMuc3ltYm9sLnR5cGUgIT09IHRoaXMudG9rZW5UeXBlICYmIHRoaXMuaW52ZXJ0KSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKGMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFhQYXRoVG9rZW5FbGVtZW50LnByb3RvdHlwZSwgXCJldmFsdWF0ZVwiLCBudWxsKTtcbiAgZXhwb3J0cy5YUGF0aFRva2VuRWxlbWVudCA9IFhQYXRoVG9rZW5FbGVtZW50O1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy90cmVlL3hwYXRoL1hQYXRoV2lsZGNhcmRBbnl3aGVyZUVsZW1lbnQuanNcbnZhciByZXF1aXJlX1hQYXRoV2lsZGNhcmRBbnl3aGVyZUVsZW1lbnQgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuWFBhdGhXaWxkY2FyZEFueXdoZXJlRWxlbWVudCA9IHZvaWQgMDtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgVHJlZXNfMSA9IHJlcXVpcmVfVHJlZXMoKTtcbiAgdmFyIFhQYXRoXzEgPSByZXF1aXJlX1hQYXRoKCk7XG4gIHZhciBYUGF0aEVsZW1lbnRfMSA9IHJlcXVpcmVfWFBhdGhFbGVtZW50KCk7XG4gIHZhciBYUGF0aFdpbGRjYXJkQW55d2hlcmVFbGVtZW50ID0gY2xhc3MgZXh0ZW5kcyBYUGF0aEVsZW1lbnRfMS5YUGF0aEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoWFBhdGhfMS5YUGF0aC5XSUxEQ0FSRCk7XG4gICAgfVxuICAgIGV2YWx1YXRlKHQpIHtcbiAgICAgIGlmICh0aGlzLmludmVydCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gVHJlZXNfMS5UcmVlcy5nZXREZXNjZW5kYW50cyh0KTtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBYUGF0aFdpbGRjYXJkQW55d2hlcmVFbGVtZW50LnByb3RvdHlwZSwgXCJldmFsdWF0ZVwiLCBudWxsKTtcbiAgZXhwb3J0cy5YUGF0aFdpbGRjYXJkQW55d2hlcmVFbGVtZW50ID0gWFBhdGhXaWxkY2FyZEFueXdoZXJlRWxlbWVudDtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvdHJlZS94cGF0aC9YUGF0aFdpbGRjYXJkRWxlbWVudC5qc1xudmFyIHJlcXVpcmVfWFBhdGhXaWxkY2FyZEVsZW1lbnQgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuWFBhdGhXaWxkY2FyZEVsZW1lbnQgPSB2b2lkIDA7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIFRyZWVzXzEgPSByZXF1aXJlX1RyZWVzKCk7XG4gIHZhciBYUGF0aF8xID0gcmVxdWlyZV9YUGF0aCgpO1xuICB2YXIgWFBhdGhFbGVtZW50XzEgPSByZXF1aXJlX1hQYXRoRWxlbWVudCgpO1xuICB2YXIgWFBhdGhXaWxkY2FyZEVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIFhQYXRoRWxlbWVudF8xLlhQYXRoRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcihYUGF0aF8xLlhQYXRoLldJTERDQVJEKTtcbiAgICB9XG4gICAgZXZhbHVhdGUodCkge1xuICAgICAgbGV0IGtpZHMgPSBbXTtcbiAgICAgIGlmICh0aGlzLmludmVydCkge1xuICAgICAgICByZXR1cm4ga2lkcztcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGMgb2YgVHJlZXNfMS5UcmVlcy5nZXRDaGlsZHJlbih0KSkge1xuICAgICAgICBraWRzLnB1c2goYyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2lkcztcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBYUGF0aFdpbGRjYXJkRWxlbWVudC5wcm90b3R5cGUsIFwiZXZhbHVhdGVcIiwgbnVsbCk7XG4gIGV4cG9ydHMuWFBhdGhXaWxkY2FyZEVsZW1lbnQgPSBYUGF0aFdpbGRjYXJkRWxlbWVudDtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvdHJlZS94cGF0aC9YUGF0aC5qc1xudmFyIHJlcXVpcmVfWFBhdGggPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLlhQYXRoID0gdm9pZCAwO1xuICB2YXIgQ2hhclN0cmVhbXNfMSA9IHJlcXVpcmVfQ2hhclN0cmVhbXMoKTtcbiAgdmFyIENvbW1vblRva2VuU3RyZWFtXzEgPSByZXF1aXJlX0NvbW1vblRva2VuU3RyZWFtKCk7XG4gIHZhciBMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uXzEgPSByZXF1aXJlX0xleGVyTm9WaWFibGVBbHRFeGNlcHRpb24oKTtcbiAgdmFyIFBhcnNlclJ1bGVDb250ZXh0XzEgPSByZXF1aXJlX1BhcnNlclJ1bGVDb250ZXh0KCk7XG4gIHZhciBUb2tlbl8xID0gcmVxdWlyZV9Ub2tlbigpO1xuICB2YXIgWFBhdGhMZXhlcl8xID0gcmVxdWlyZV9YUGF0aExleGVyKCk7XG4gIHZhciBYUGF0aExleGVyRXJyb3JMaXN0ZW5lcl8xID0gcmVxdWlyZV9YUGF0aExleGVyRXJyb3JMaXN0ZW5lcigpO1xuICB2YXIgWFBhdGhSdWxlQW55d2hlcmVFbGVtZW50XzEgPSByZXF1aXJlX1hQYXRoUnVsZUFueXdoZXJlRWxlbWVudCgpO1xuICB2YXIgWFBhdGhSdWxlRWxlbWVudF8xID0gcmVxdWlyZV9YUGF0aFJ1bGVFbGVtZW50KCk7XG4gIHZhciBYUGF0aFRva2VuQW55d2hlcmVFbGVtZW50XzEgPSByZXF1aXJlX1hQYXRoVG9rZW5Bbnl3aGVyZUVsZW1lbnQoKTtcbiAgdmFyIFhQYXRoVG9rZW5FbGVtZW50XzEgPSByZXF1aXJlX1hQYXRoVG9rZW5FbGVtZW50KCk7XG4gIHZhciBYUGF0aFdpbGRjYXJkQW55d2hlcmVFbGVtZW50XzEgPSByZXF1aXJlX1hQYXRoV2lsZGNhcmRBbnl3aGVyZUVsZW1lbnQoKTtcbiAgdmFyIFhQYXRoV2lsZGNhcmRFbGVtZW50XzEgPSByZXF1aXJlX1hQYXRoV2lsZGNhcmRFbGVtZW50KCk7XG4gIHZhciBYUGF0aCA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHBhdGgpIHtcbiAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgIHRoaXMuZWxlbWVudHMgPSB0aGlzLnNwbGl0KHBhdGgpO1xuICAgIH1cbiAgICBzcGxpdChwYXRoKSB7XG4gICAgICBsZXQgbGV4ZXIgPSBuZXcgWFBhdGhMZXhlcl8xLlhQYXRoTGV4ZXIoQ2hhclN0cmVhbXNfMS5DaGFyU3RyZWFtcy5mcm9tU3RyaW5nKHBhdGgpKTtcbiAgICAgIGxleGVyLnJlY292ZXIgPSAoZSkgPT4ge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfTtcbiAgICAgIGxleGVyLnJlbW92ZUVycm9yTGlzdGVuZXJzKCk7XG4gICAgICBsZXhlci5hZGRFcnJvckxpc3RlbmVyKG5ldyBYUGF0aExleGVyRXJyb3JMaXN0ZW5lcl8xLlhQYXRoTGV4ZXJFcnJvckxpc3RlbmVyKCkpO1xuICAgICAgbGV0IHRva2VuU3RyZWFtID0gbmV3IENvbW1vblRva2VuU3RyZWFtXzEuQ29tbW9uVG9rZW5TdHJlYW0obGV4ZXIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdG9rZW5TdHJlYW0uZmlsbCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIExleGVyTm9WaWFibGVBbHRFeGNlcHRpb25fMS5MZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uKSB7XG4gICAgICAgICAgbGV0IHBvcyA9IGxleGVyLmNoYXJQb3NpdGlvbkluTGluZTtcbiAgICAgICAgICBsZXQgbXNnID0gXCJJbnZhbGlkIHRva2VucyBvciBjaGFyYWN0ZXJzIGF0IGluZGV4IFwiICsgcG9zICsgXCIgaW4gcGF0aCAnXCIgKyBwYXRoICsgXCInIC0tIFwiICsgZS5tZXNzYWdlO1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIGxldCB0b2tlbnMyID0gdG9rZW5TdHJlYW0uZ2V0VG9rZW5zKCk7XG4gICAgICBsZXQgZWxlbWVudHMgPSBbXTtcbiAgICAgIGxldCBuID0gdG9rZW5zMi5sZW5ndGg7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBsb29wOlxuICAgICAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgICAgICBsZXQgZWwgPSB0b2tlbnMyW2ldO1xuICAgICAgICAgIGxldCBuZXh0O1xuICAgICAgICAgIHN3aXRjaCAoZWwudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBYUGF0aExleGVyXzEuWFBhdGhMZXhlci5ST09UOlxuICAgICAgICAgICAgY2FzZSBYUGF0aExleGVyXzEuWFBhdGhMZXhlci5BTllXSEVSRTpcbiAgICAgICAgICAgICAgbGV0IGFueXdoZXJlID0gZWwudHlwZSA9PT0gWFBhdGhMZXhlcl8xLlhQYXRoTGV4ZXIuQU5ZV0hFUkU7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgbmV4dCA9IHRva2VuczJbaV07XG4gICAgICAgICAgICAgIGxldCBpbnZlcnQgPSBuZXh0LnR5cGUgPT09IFhQYXRoTGV4ZXJfMS5YUGF0aExleGVyLkJBTkc7XG4gICAgICAgICAgICAgIGlmIChpbnZlcnQpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHRva2VuczJbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IHBhdGhFbGVtZW50ID0gdGhpcy5nZXRYUGF0aEVsZW1lbnQobmV4dCwgYW55d2hlcmUpO1xuICAgICAgICAgICAgICBwYXRoRWxlbWVudC5pbnZlcnQgPSBpbnZlcnQ7XG4gICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gocGF0aEVsZW1lbnQpO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBYUGF0aExleGVyXzEuWFBhdGhMZXhlci5UT0tFTl9SRUY6XG4gICAgICAgICAgICBjYXNlIFhQYXRoTGV4ZXJfMS5YUGF0aExleGVyLlJVTEVfUkVGOlxuICAgICAgICAgICAgY2FzZSBYUGF0aExleGVyXzEuWFBhdGhMZXhlci5XSUxEQ0FSRDpcbiAgICAgICAgICAgICAgZWxlbWVudHMucHVzaCh0aGlzLmdldFhQYXRoRWxlbWVudChlbCwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVG9rZW5fMS5Ub2tlbi5FT0Y6XG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3d0aCBwYXRoIGVsZW1lbnQgXCIgKyBlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfVxuICAgIGdldFhQYXRoRWxlbWVudCh3b3JkVG9rZW4sIGFueXdoZXJlKSB7XG4gICAgICBpZiAod29yZFRva2VuLnR5cGUgPT09IFRva2VuXzEuVG9rZW4uRU9GKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcGF0aCBlbGVtZW50IGF0IGVuZCBvZiBwYXRoXCIpO1xuICAgICAgfVxuICAgICAgbGV0IHdvcmQgPSB3b3JkVG9rZW4udGV4dDtcbiAgICAgIGlmICh3b3JkID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgd29yZFRva2VuIHRvIGhhdmUgdGV4dCBjb250ZW50LlwiKTtcbiAgICAgIH1cbiAgICAgIGxldCB0dHlwZSA9IHRoaXMucGFyc2VyLmdldFRva2VuVHlwZSh3b3JkKTtcbiAgICAgIGxldCBydWxlSW5kZXggPSB0aGlzLnBhcnNlci5nZXRSdWxlSW5kZXgod29yZCk7XG4gICAgICBzd2l0Y2ggKHdvcmRUb2tlbi50eXBlKSB7XG4gICAgICAgIGNhc2UgWFBhdGhMZXhlcl8xLlhQYXRoTGV4ZXIuV0lMRENBUkQ6XG4gICAgICAgICAgcmV0dXJuIGFueXdoZXJlID8gbmV3IFhQYXRoV2lsZGNhcmRBbnl3aGVyZUVsZW1lbnRfMS5YUGF0aFdpbGRjYXJkQW55d2hlcmVFbGVtZW50KCkgOiBuZXcgWFBhdGhXaWxkY2FyZEVsZW1lbnRfMS5YUGF0aFdpbGRjYXJkRWxlbWVudCgpO1xuICAgICAgICBjYXNlIFhQYXRoTGV4ZXJfMS5YUGF0aExleGVyLlRPS0VOX1JFRjpcbiAgICAgICAgY2FzZSBYUGF0aExleGVyXzEuWFBhdGhMZXhlci5TVFJJTkc6XG4gICAgICAgICAgaWYgKHR0eXBlID09PSBUb2tlbl8xLlRva2VuLklOVkFMSURfVFlQRSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHdvcmQgKyBcIiBhdCBpbmRleCBcIiArIHdvcmRUb2tlbi5zdGFydEluZGV4ICsgXCIgaXNuJ3QgYSB2YWxpZCB0b2tlbiBuYW1lXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYW55d2hlcmUgPyBuZXcgWFBhdGhUb2tlbkFueXdoZXJlRWxlbWVudF8xLlhQYXRoVG9rZW5Bbnl3aGVyZUVsZW1lbnQod29yZCwgdHR5cGUpIDogbmV3IFhQYXRoVG9rZW5FbGVtZW50XzEuWFBhdGhUb2tlbkVsZW1lbnQod29yZCwgdHR5cGUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChydWxlSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iod29yZCArIFwiIGF0IGluZGV4IFwiICsgd29yZFRva2VuLnN0YXJ0SW5kZXggKyBcIiBpc24ndCBhIHZhbGlkIHJ1bGUgbmFtZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFueXdoZXJlID8gbmV3IFhQYXRoUnVsZUFueXdoZXJlRWxlbWVudF8xLlhQYXRoUnVsZUFueXdoZXJlRWxlbWVudCh3b3JkLCBydWxlSW5kZXgpIDogbmV3IFhQYXRoUnVsZUVsZW1lbnRfMS5YUGF0aFJ1bGVFbGVtZW50KHdvcmQsIHJ1bGVJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmaW5kQWxsKHRyZWUsIHhwYXRoLCBwYXJzZXIpIHtcbiAgICAgIGxldCBwID0gbmV3IFhQYXRoKHBhcnNlciwgeHBhdGgpO1xuICAgICAgcmV0dXJuIHAuZXZhbHVhdGUodHJlZSk7XG4gICAgfVxuICAgIGV2YWx1YXRlKHQpIHtcbiAgICAgIGxldCBkdW1teVJvb3QgPSBuZXcgUGFyc2VyUnVsZUNvbnRleHRfMS5QYXJzZXJSdWxlQ29udGV4dCgpO1xuICAgICAgZHVtbXlSb290LmFkZENoaWxkKHQpO1xuICAgICAgbGV0IHdvcmsgPSBuZXcgU2V0KFtkdW1teVJvb3RdKTtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgdGhpcy5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IG5leHQgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAobGV0IG5vZGUgb2Ygd29yaykge1xuICAgICAgICAgIGlmIChub2RlLmNoaWxkQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2hpbmcgPSB0aGlzLmVsZW1lbnRzW2ldLmV2YWx1YXRlKG5vZGUpO1xuICAgICAgICAgICAgbWF0Y2hpbmcuZm9yRWFjaChuZXh0LmFkZCwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICAgICAgd29yayA9IG5leHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gd29yaztcbiAgICB9XG4gIH07XG4gIGV4cG9ydHMuWFBhdGggPSBYUGF0aDtcbiAgWFBhdGguV0lMRENBUkQgPSBcIipcIjtcbiAgWFBhdGguTk9UID0gXCIhXCI7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL3RyZWUvcGF0dGVybi9QYXJzZVRyZWVQYXR0ZXJuLmpzXG52YXIgcmVxdWlyZV9QYXJzZVRyZWVQYXR0ZXJuID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLlBhcnNlVHJlZVBhdHRlcm4gPSB2b2lkIDA7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIFhQYXRoXzEgPSByZXF1aXJlX1hQYXRoKCk7XG4gIHZhciBQYXJzZVRyZWVQYXR0ZXJuID0gY2xhc3MgUGFyc2VUcmVlUGF0dGVybiB7XG4gICAgY29uc3RydWN0b3IobWF0Y2hlciwgcGF0dGVybiwgcGF0dGVyblJ1bGVJbmRleCwgcGF0dGVyblRyZWUpIHtcbiAgICAgIHRoaXMuX21hdGNoZXIgPSBtYXRjaGVyO1xuICAgICAgdGhpcy5fcGF0dGVyblJ1bGVJbmRleCA9IHBhdHRlcm5SdWxlSW5kZXg7XG4gICAgICB0aGlzLl9wYXR0ZXJuID0gcGF0dGVybjtcbiAgICAgIHRoaXMuX3BhdHRlcm5UcmVlID0gcGF0dGVyblRyZWU7XG4gICAgfVxuICAgIG1hdGNoKHRyZWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXRjaGVyLm1hdGNoKHRyZWUsIHRoaXMpO1xuICAgIH1cbiAgICBtYXRjaGVzKHRyZWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXRjaGVyLm1hdGNoKHRyZWUsIHRoaXMpLnN1Y2NlZWRlZDtcbiAgICB9XG4gICAgZmluZEFsbCh0cmVlLCB4cGF0aCkge1xuICAgICAgbGV0IHN1YnRyZWVzID0gWFBhdGhfMS5YUGF0aC5maW5kQWxsKHRyZWUsIHhwYXRoLCB0aGlzLl9tYXRjaGVyLnBhcnNlcik7XG4gICAgICBsZXQgbWF0Y2hlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgdCBvZiBzdWJ0cmVlcykge1xuICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLm1hdGNoKHQpO1xuICAgICAgICBpZiAobWF0Y2guc3VjY2VlZGVkKSB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKG1hdGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgfVxuICAgIGdldCBtYXRjaGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hdGNoZXI7XG4gICAgfVxuICAgIGdldCBwYXR0ZXJuKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhdHRlcm47XG4gICAgfVxuICAgIGdldCBwYXR0ZXJuUnVsZUluZGV4KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhdHRlcm5SdWxlSW5kZXg7XG4gICAgfVxuICAgIGdldCBwYXR0ZXJuVHJlZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXR0ZXJuVHJlZTtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIFBhcnNlVHJlZVBhdHRlcm4ucHJvdG90eXBlLCBcIl9wYXR0ZXJuXCIsIHZvaWQgMCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIFBhcnNlVHJlZVBhdHRlcm4ucHJvdG90eXBlLCBcIl9wYXR0ZXJuVHJlZVwiLCB2b2lkIDApO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBQYXJzZVRyZWVQYXR0ZXJuLnByb3RvdHlwZSwgXCJfbWF0Y2hlclwiLCB2b2lkIDApO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbCxcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBQYXJzZVRyZWVQYXR0ZXJuLnByb3RvdHlwZSwgXCJtYXRjaFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgUGFyc2VUcmVlUGF0dGVybi5wcm90b3R5cGUsIFwibWF0Y2hlc1wiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGwsXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgUGFyc2VUcmVlUGF0dGVybi5wcm90b3R5cGUsIFwiZmluZEFsbFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgUGFyc2VUcmVlUGF0dGVybi5wcm90b3R5cGUsIFwibWF0Y2hlclwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgUGFyc2VUcmVlUGF0dGVybi5wcm90b3R5cGUsIFwicGF0dGVyblwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgUGFyc2VUcmVlUGF0dGVybi5wcm90b3R5cGUsIFwicGF0dGVyblRyZWVcIiwgbnVsbCk7XG4gIFBhcnNlVHJlZVBhdHRlcm4gPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDEsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDMsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBQYXJzZVRyZWVQYXR0ZXJuKTtcbiAgZXhwb3J0cy5QYXJzZVRyZWVQYXR0ZXJuID0gUGFyc2VUcmVlUGF0dGVybjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvdHJlZS9wYXR0ZXJuL1J1bGVUYWdUb2tlbi5qc1xudmFyIHJlcXVpcmVfUnVsZVRhZ1Rva2VuID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLlJ1bGVUYWdUb2tlbiA9IHZvaWQgMDtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgVG9rZW5fMSA9IHJlcXVpcmVfVG9rZW4oKTtcbiAgdmFyIFJ1bGVUYWdUb2tlbiA9IGNsYXNzIFJ1bGVUYWdUb2tlbiB7XG4gICAgY29uc3RydWN0b3IocnVsZU5hbWUsIGJ5cGFzc1Rva2VuVHlwZSwgbGFiZWwpIHtcbiAgICAgIGlmIChydWxlTmFtZSA9PSBudWxsIHx8IHJ1bGVOYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJydWxlTmFtZSBjYW5ub3QgYmUgbnVsbCBvciBlbXB0eS5cIik7XG4gICAgICB9XG4gICAgICB0aGlzLl9ydWxlTmFtZSA9IHJ1bGVOYW1lO1xuICAgICAgdGhpcy5ieXBhc3NUb2tlblR5cGUgPSBieXBhc3NUb2tlblR5cGU7XG4gICAgICB0aGlzLl9sYWJlbCA9IGxhYmVsO1xuICAgIH1cbiAgICBnZXQgcnVsZU5hbWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVsZU5hbWU7XG4gICAgfVxuICAgIGdldCBsYWJlbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sYWJlbDtcbiAgICB9XG4gICAgZ2V0IGNoYW5uZWwoKSB7XG4gICAgICByZXR1cm4gVG9rZW5fMS5Ub2tlbi5ERUZBVUxUX0NIQU5ORUw7XG4gICAgfVxuICAgIGdldCB0ZXh0KCkge1xuICAgICAgaWYgKHRoaXMuX2xhYmVsICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwiPFwiICsgdGhpcy5fbGFiZWwgKyBcIjpcIiArIHRoaXMuX3J1bGVOYW1lICsgXCI+XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCI8XCIgKyB0aGlzLl9ydWxlTmFtZSArIFwiPlwiO1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJ5cGFzc1Rva2VuVHlwZTtcbiAgICB9XG4gICAgZ2V0IGxpbmUoKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZ2V0IGNoYXJQb3NpdGlvbkluTGluZSgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZ2V0IHRva2VuSW5kZXgoKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGdldCBzdGFydEluZGV4KCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBnZXQgc3RvcEluZGV4KCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBnZXQgdG9rZW5Tb3VyY2UoKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBnZXQgaW5wdXRTdHJlYW0oKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydWxlTmFtZSArIFwiOlwiICsgdGhpcy5ieXBhc3NUb2tlblR5cGU7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBSdWxlVGFnVG9rZW4ucHJvdG90eXBlLCBcInJ1bGVOYW1lXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgUnVsZVRhZ1Rva2VuLnByb3RvdHlwZSwgXCJjaGFubmVsXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgUnVsZVRhZ1Rva2VuLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgUnVsZVRhZ1Rva2VuLnByb3RvdHlwZSwgXCJ0eXBlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgUnVsZVRhZ1Rva2VuLnByb3RvdHlwZSwgXCJsaW5lXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgUnVsZVRhZ1Rva2VuLnByb3RvdHlwZSwgXCJjaGFyUG9zaXRpb25JbkxpbmVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBSdWxlVGFnVG9rZW4ucHJvdG90eXBlLCBcInRva2VuSW5kZXhcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBSdWxlVGFnVG9rZW4ucHJvdG90eXBlLCBcInN0YXJ0SW5kZXhcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBSdWxlVGFnVG9rZW4ucHJvdG90eXBlLCBcInN0b3BJbmRleFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFJ1bGVUYWdUb2tlbi5wcm90b3R5cGUsIFwidG9rZW5Tb3VyY2VcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBSdWxlVGFnVG9rZW4ucHJvdG90eXBlLCBcImlucHV0U3RyZWFtXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgUnVsZVRhZ1Rva2VuLnByb3RvdHlwZSwgXCJ0b1N0cmluZ1wiLCBudWxsKTtcbiAgUnVsZVRhZ1Rva2VuID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgUnVsZVRhZ1Rva2VuKTtcbiAgZXhwb3J0cy5SdWxlVGFnVG9rZW4gPSBSdWxlVGFnVG9rZW47XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL3RyZWUvcGF0dGVybi9DaHVuay5qc1xudmFyIHJlcXVpcmVfQ2h1bmsgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkNodW5rID0gdm9pZCAwO1xuICB2YXIgQ2h1bmsgPSBjbGFzcyB7XG4gIH07XG4gIGV4cG9ydHMuQ2h1bmsgPSBDaHVuaztcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvdHJlZS9wYXR0ZXJuL1RhZ0NodW5rLmpzXG52YXIgcmVxdWlyZV9UYWdDaHVuayA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5UYWdDaHVuayA9IHZvaWQgMDtcbiAgdmFyIENodW5rXzEgPSByZXF1aXJlX0NodW5rKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIFRhZ0NodW5rID0gY2xhc3MgZXh0ZW5kcyBDaHVua18xLkNodW5rIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWcsIGxhYmVsKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgaWYgKHRhZyA9PSBudWxsIHx8IHRhZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGFnIGNhbm5vdCBiZSBudWxsIG9yIGVtcHR5XCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdGFnID0gdGFnO1xuICAgICAgdGhpcy5fbGFiZWwgPSBsYWJlbDtcbiAgICB9XG4gICAgZ2V0IHRhZygpIHtcbiAgICAgIHJldHVybiB0aGlzLl90YWc7XG4gICAgfVxuICAgIGdldCBsYWJlbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sYWJlbDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICBpZiAodGhpcy5fbGFiZWwgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGFiZWwgKyBcIjpcIiArIHRoaXMuX3RhZztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl90YWc7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBUYWdDaHVuay5wcm90b3R5cGUsIFwidGFnXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgVGFnQ2h1bmsucHJvdG90eXBlLCBcInRvU3RyaW5nXCIsIG51bGwpO1xuICBleHBvcnRzLlRhZ0NodW5rID0gVGFnQ2h1bms7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL3RyZWUvcGF0dGVybi9UZXh0Q2h1bmsuanNcbnZhciByZXF1aXJlX1RleHRDaHVuayA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgdmFyIF9fcGFyYW0gPSBleHBvcnRzICYmIGV4cG9ydHMuX19wYXJhbSB8fCBmdW5jdGlvbihwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7XG4gICAgfTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5UZXh0Q2h1bmsgPSB2b2lkIDA7XG4gIHZhciBDaHVua18xID0gcmVxdWlyZV9DaHVuaygpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBUZXh0Q2h1bmsgPSBjbGFzcyBUZXh0Q2h1bmsgZXh0ZW5kcyBDaHVua18xLkNodW5rIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgaWYgKHRleHQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0ZXh0IGNhbm5vdCBiZSBudWxsXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIGdldCB0ZXh0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RleHQ7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwiJ1wiICsgdGhpcy5fdGV4dCArIFwiJ1wiO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgVGV4dENodW5rLnByb3RvdHlwZSwgXCJfdGV4dFwiLCB2b2lkIDApO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBUZXh0Q2h1bmsucHJvdG90eXBlLCBcInRleHRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBUZXh0Q2h1bmsucHJvdG90eXBlLCBcInRvU3RyaW5nXCIsIG51bGwpO1xuICBUZXh0Q2h1bmsgPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBUZXh0Q2h1bmspO1xuICBleHBvcnRzLlRleHRDaHVuayA9IFRleHRDaHVuaztcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvdHJlZS9wYXR0ZXJuL1Rva2VuVGFnVG9rZW4uanNcbnZhciByZXF1aXJlX1Rva2VuVGFnVG9rZW4gPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuVG9rZW5UYWdUb2tlbiA9IHZvaWQgMDtcbiAgdmFyIENvbW1vblRva2VuXzEgPSByZXF1aXJlX0NvbW1vblRva2VuKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIFRva2VuVGFnVG9rZW4gPSBjbGFzcyBUb2tlblRhZ1Rva2VuIGV4dGVuZHMgQ29tbW9uVG9rZW5fMS5Db21tb25Ub2tlbiB7XG4gICAgY29uc3RydWN0b3IodG9rZW5OYW1lLCB0eXBlLCBsYWJlbCkge1xuICAgICAgc3VwZXIodHlwZSk7XG4gICAgICB0aGlzLl90b2tlbk5hbWUgPSB0b2tlbk5hbWU7XG4gICAgICB0aGlzLl9sYWJlbCA9IGxhYmVsO1xuICAgIH1cbiAgICBnZXQgdG9rZW5OYW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuTmFtZTtcbiAgICB9XG4gICAgZ2V0IGxhYmVsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xhYmVsO1xuICAgIH1cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgIGlmICh0aGlzLl9sYWJlbCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIjxcIiArIHRoaXMuX2xhYmVsICsgXCI6XCIgKyB0aGlzLl90b2tlbk5hbWUgKyBcIj5cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIjxcIiArIHRoaXMuX3Rva2VuTmFtZSArIFwiPlwiO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b2tlbk5hbWUgKyBcIjpcIiArIHRoaXMudHlwZTtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIFRva2VuVGFnVG9rZW4ucHJvdG90eXBlLCBcIl90b2tlbk5hbWVcIiwgdm9pZCAwKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgVG9rZW5UYWdUb2tlbi5wcm90b3R5cGUsIFwidG9rZW5OYW1lXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgVG9rZW5UYWdUb2tlbi5wcm90b3R5cGUsIFwidGV4dFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFRva2VuVGFnVG9rZW4ucHJvdG90eXBlLCBcInRvU3RyaW5nXCIsIG51bGwpO1xuICBUb2tlblRhZ1Rva2VuID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgVG9rZW5UYWdUb2tlbik7XG4gIGV4cG9ydHMuVG9rZW5UYWdUb2tlbiA9IFRva2VuVGFnVG9rZW47XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL3RyZWUvcGF0dGVybi9QYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlci5qc1xudmFyIHJlcXVpcmVfUGFyc2VUcmVlUGF0dGVybk1hdGNoZXIgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuUGFyc2VUcmVlUGF0dGVybk1hdGNoZXIgPSB2b2lkIDA7XG4gIHZhciBCYWlsRXJyb3JTdHJhdGVneV8xID0gcmVxdWlyZV9CYWlsRXJyb3JTdHJhdGVneSgpO1xuICB2YXIgQ2hhclN0cmVhbXNfMSA9IHJlcXVpcmVfQ2hhclN0cmVhbXMoKTtcbiAgdmFyIENvbW1vblRva2VuU3RyZWFtXzEgPSByZXF1aXJlX0NvbW1vblRva2VuU3RyZWFtKCk7XG4gIHZhciBMaXN0VG9rZW5Tb3VyY2VfMSA9IHJlcXVpcmVfTGlzdFRva2VuU291cmNlKCk7XG4gIHZhciBNdWx0aU1hcF8xID0gcmVxdWlyZV9NdWx0aU1hcCgpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBQYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbl8xID0gcmVxdWlyZV9QYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbigpO1xuICB2YXIgUGFyc2VySW50ZXJwcmV0ZXJfMSA9IHJlcXVpcmVfUGFyc2VySW50ZXJwcmV0ZXIoKTtcbiAgdmFyIFBhcnNlclJ1bGVDb250ZXh0XzEgPSByZXF1aXJlX1BhcnNlclJ1bGVDb250ZXh0KCk7XG4gIHZhciBQYXJzZVRyZWVNYXRjaF8xID0gcmVxdWlyZV9QYXJzZVRyZWVNYXRjaCgpO1xuICB2YXIgUGFyc2VUcmVlUGF0dGVybl8xID0gcmVxdWlyZV9QYXJzZVRyZWVQYXR0ZXJuKCk7XG4gIHZhciBSZWNvZ25pdGlvbkV4Y2VwdGlvbl8xID0gcmVxdWlyZV9SZWNvZ25pdGlvbkV4Y2VwdGlvbigpO1xuICB2YXIgUnVsZU5vZGVfMSA9IHJlcXVpcmVfUnVsZU5vZGUoKTtcbiAgdmFyIFJ1bGVUYWdUb2tlbl8xID0gcmVxdWlyZV9SdWxlVGFnVG9rZW4oKTtcbiAgdmFyIFRhZ0NodW5rXzEgPSByZXF1aXJlX1RhZ0NodW5rKCk7XG4gIHZhciBUZXJtaW5hbE5vZGVfMSA9IHJlcXVpcmVfVGVybWluYWxOb2RlKCk7XG4gIHZhciBUZXh0Q2h1bmtfMSA9IHJlcXVpcmVfVGV4dENodW5rKCk7XG4gIHZhciBUb2tlbl8xID0gcmVxdWlyZV9Ub2tlbigpO1xuICB2YXIgVG9rZW5UYWdUb2tlbl8xID0gcmVxdWlyZV9Ub2tlblRhZ1Rva2VuKCk7XG4gIHZhciBQYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlcjIgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IobGV4ZXIsIHBhcnNlcikge1xuICAgICAgdGhpcy5zdGFydCA9IFwiPFwiO1xuICAgICAgdGhpcy5zdG9wID0gXCI+XCI7XG4gICAgICB0aGlzLmVzY2FwZSA9IFwiXFxcXFwiO1xuICAgICAgdGhpcy5lc2NhcGVSRSA9IC9cXFxcL2c7XG4gICAgICB0aGlzLl9sZXhlciA9IGxleGVyO1xuICAgICAgdGhpcy5fcGFyc2VyID0gcGFyc2VyO1xuICAgIH1cbiAgICBzZXREZWxpbWl0ZXJzKHN0YXJ0LCBzdG9wLCBlc2NhcGVMZWZ0KSB7XG4gICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN0YXJ0IGNhbm5vdCBiZSBudWxsIG9yIGVtcHR5XCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdG9wKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN0b3AgY2Fubm90IGJlIG51bGwgb3IgZW1wdHlcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICB0aGlzLnN0b3AgPSBzdG9wO1xuICAgICAgdGhpcy5lc2NhcGUgPSBlc2NhcGVMZWZ0O1xuICAgICAgdGhpcy5lc2NhcGVSRSA9IG5ldyBSZWdFeHAoZXNjYXBlTGVmdC5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIiksIFwiZ1wiKTtcbiAgICB9XG4gICAgbWF0Y2hlcyh0cmVlLCBwYXR0ZXJuLCBwYXR0ZXJuUnVsZUluZGV4ID0gMCkge1xuICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGxldCBwID0gdGhpcy5jb21waWxlKHBhdHRlcm4sIHBhdHRlcm5SdWxlSW5kZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaGVzKHRyZWUsIHApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGxhYmVscyA9IG5ldyBNdWx0aU1hcF8xLk11bHRpTWFwKCk7XG4gICAgICAgIGxldCBtaXNtYXRjaGVkTm9kZSA9IHRoaXMubWF0Y2hJbXBsKHRyZWUsIHBhdHRlcm4ucGF0dGVyblRyZWUsIGxhYmVscyk7XG4gICAgICAgIHJldHVybiAhbWlzbWF0Y2hlZE5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIG1hdGNoKHRyZWUsIHBhdHRlcm4sIHBhdHRlcm5SdWxlSW5kZXggPSAwKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbGV0IHAgPSB0aGlzLmNvbXBpbGUocGF0dGVybiwgcGF0dGVyblJ1bGVJbmRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoKHRyZWUsIHApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGxhYmVscyA9IG5ldyBNdWx0aU1hcF8xLk11bHRpTWFwKCk7XG4gICAgICAgIGxldCBtaXNtYXRjaGVkTm9kZSA9IHRoaXMubWF0Y2hJbXBsKHRyZWUsIHBhdHRlcm4ucGF0dGVyblRyZWUsIGxhYmVscyk7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VUcmVlTWF0Y2hfMS5QYXJzZVRyZWVNYXRjaCh0cmVlLCBwYXR0ZXJuLCBsYWJlbHMsIG1pc21hdGNoZWROb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29tcGlsZShwYXR0ZXJuLCBwYXR0ZXJuUnVsZUluZGV4KSB7XG4gICAgICBsZXQgdG9rZW5MaXN0ID0gdGhpcy50b2tlbml6ZShwYXR0ZXJuKTtcbiAgICAgIGxldCB0b2tlblNyYyA9IG5ldyBMaXN0VG9rZW5Tb3VyY2VfMS5MaXN0VG9rZW5Tb3VyY2UodG9rZW5MaXN0KTtcbiAgICAgIGxldCB0b2tlbnMyID0gbmV3IENvbW1vblRva2VuU3RyZWFtXzEuQ29tbW9uVG9rZW5TdHJlYW0odG9rZW5TcmMpO1xuICAgICAgY29uc3QgcGFyc2VyID0gdGhpcy5fcGFyc2VyO1xuICAgICAgbGV0IHBhcnNlckludGVycCA9IG5ldyBQYXJzZXJJbnRlcnByZXRlcl8xLlBhcnNlckludGVycHJldGVyKHBhcnNlci5ncmFtbWFyRmlsZU5hbWUsIHBhcnNlci52b2NhYnVsYXJ5LCBwYXJzZXIucnVsZU5hbWVzLCBwYXJzZXIuZ2V0QVROV2l0aEJ5cGFzc0FsdHMoKSwgdG9rZW5zMik7XG4gICAgICBsZXQgdHJlZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlckludGVycC5lcnJvckhhbmRsZXIgPSBuZXcgQmFpbEVycm9yU3RyYXRlZ3lfMS5CYWlsRXJyb3JTdHJhdGVneSgpO1xuICAgICAgICB0cmVlID0gcGFyc2VySW50ZXJwLnBhcnNlKHBhdHRlcm5SdWxlSW5kZXgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFBhcnNlQ2FuY2VsbGF0aW9uRXhjZXB0aW9uXzEuUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgICB0aHJvdyBlLmdldENhdXNlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIFJlY29nbml0aW9uRXhjZXB0aW9uXzEuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlcjIuQ2Fubm90SW52b2tlU3RhcnRSdWxlKGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbnMyLkxBKDEpICE9PSBUb2tlbl8xLlRva2VuLkVPRikge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VUcmVlUGF0dGVybk1hdGNoZXIyLlN0YXJ0UnVsZURvZXNOb3RDb25zdW1lRnVsbFBhdHRlcm4oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUGFyc2VUcmVlUGF0dGVybl8xLlBhcnNlVHJlZVBhdHRlcm4odGhpcywgcGF0dGVybiwgcGF0dGVyblJ1bGVJbmRleCwgdHJlZSk7XG4gICAgfVxuICAgIGdldCBsZXhlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sZXhlcjtcbiAgICB9XG4gICAgZ2V0IHBhcnNlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJzZXI7XG4gICAgfVxuICAgIG1hdGNoSW1wbCh0cmVlLCBwYXR0ZXJuVHJlZSwgbGFiZWxzKSB7XG4gICAgICBpZiAoIXRyZWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRyZWUgY2Fubm90IGJlIG51bGxcIik7XG4gICAgICB9XG4gICAgICBpZiAoIXBhdHRlcm5UcmVlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJwYXR0ZXJuVHJlZSBjYW5ub3QgYmUgbnVsbFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmVlIGluc3RhbmNlb2YgVGVybWluYWxOb2RlXzEuVGVybWluYWxOb2RlICYmIHBhdHRlcm5UcmVlIGluc3RhbmNlb2YgVGVybWluYWxOb2RlXzEuVGVybWluYWxOb2RlKSB7XG4gICAgICAgIGxldCBtaXNtYXRjaGVkTm9kZTtcbiAgICAgICAgaWYgKHRyZWUuc3ltYm9sLnR5cGUgPT09IHBhdHRlcm5UcmVlLnN5bWJvbC50eXBlKSB7XG4gICAgICAgICAgaWYgKHBhdHRlcm5UcmVlLnN5bWJvbCBpbnN0YW5jZW9mIFRva2VuVGFnVG9rZW5fMS5Ub2tlblRhZ1Rva2VuKSB7XG4gICAgICAgICAgICBsZXQgdG9rZW5UYWdUb2tlbiA9IHBhdHRlcm5UcmVlLnN5bWJvbDtcbiAgICAgICAgICAgIGxhYmVscy5tYXAodG9rZW5UYWdUb2tlbi50b2tlbk5hbWUsIHRyZWUpO1xuICAgICAgICAgICAgY29uc3QgbCA9IHRva2VuVGFnVG9rZW4ubGFiZWw7XG4gICAgICAgICAgICBpZiAobCkge1xuICAgICAgICAgICAgICBsYWJlbHMubWFwKGwsIHRyZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodHJlZS50ZXh0ID09PSBwYXR0ZXJuVHJlZS50ZXh0KSB7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghbWlzbWF0Y2hlZE5vZGUpIHtcbiAgICAgICAgICAgICAgbWlzbWF0Y2hlZE5vZGUgPSB0cmVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW1pc21hdGNoZWROb2RlKSB7XG4gICAgICAgICAgICBtaXNtYXRjaGVkTm9kZSA9IHRyZWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaXNtYXRjaGVkTm9kZTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmVlIGluc3RhbmNlb2YgUGFyc2VyUnVsZUNvbnRleHRfMS5QYXJzZXJSdWxlQ29udGV4dCAmJiBwYXR0ZXJuVHJlZSBpbnN0YW5jZW9mIFBhcnNlclJ1bGVDb250ZXh0XzEuUGFyc2VyUnVsZUNvbnRleHQpIHtcbiAgICAgICAgbGV0IG1pc21hdGNoZWROb2RlO1xuICAgICAgICBsZXQgcnVsZVRhZ1Rva2VuID0gdGhpcy5nZXRSdWxlVGFnVG9rZW4ocGF0dGVyblRyZWUpO1xuICAgICAgICBpZiAocnVsZVRhZ1Rva2VuKSB7XG4gICAgICAgICAgbGV0IG07XG4gICAgICAgICAgaWYgKHRyZWUucnVsZUNvbnRleHQucnVsZUluZGV4ID09PSBwYXR0ZXJuVHJlZS5ydWxlQ29udGV4dC5ydWxlSW5kZXgpIHtcbiAgICAgICAgICAgIGxhYmVscy5tYXAocnVsZVRhZ1Rva2VuLnJ1bGVOYW1lLCB0cmVlKTtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBydWxlVGFnVG9rZW4ubGFiZWw7XG4gICAgICAgICAgICBpZiAobCkge1xuICAgICAgICAgICAgICBsYWJlbHMubWFwKGwsIHRyZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW1pc21hdGNoZWROb2RlKSB7XG4gICAgICAgICAgICAgIG1pc21hdGNoZWROb2RlID0gdHJlZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1pc21hdGNoZWROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmVlLmNoaWxkQ291bnQgIT09IHBhdHRlcm5UcmVlLmNoaWxkQ291bnQpIHtcbiAgICAgICAgICBpZiAoIW1pc21hdGNoZWROb2RlKSB7XG4gICAgICAgICAgICBtaXNtYXRjaGVkTm9kZSA9IHRyZWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtaXNtYXRjaGVkTm9kZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbiA9IHRyZWUuY2hpbGRDb3VudDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBsZXQgY2hpbGRNYXRjaCA9IHRoaXMubWF0Y2hJbXBsKHRyZWUuZ2V0Q2hpbGQoaSksIHBhdHRlcm5UcmVlLmdldENoaWxkKGkpLCBsYWJlbHMpO1xuICAgICAgICAgIGlmIChjaGlsZE1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRNYXRjaDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pc21hdGNoZWROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfVxuICAgIGdldFJ1bGVUYWdUb2tlbih0KSB7XG4gICAgICBpZiAodCBpbnN0YW5jZW9mIFJ1bGVOb2RlXzEuUnVsZU5vZGUpIHtcbiAgICAgICAgaWYgKHQuY2hpbGRDb3VudCA9PT0gMSAmJiB0LmdldENoaWxkKDApIGluc3RhbmNlb2YgVGVybWluYWxOb2RlXzEuVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgbGV0IGMgPSB0LmdldENoaWxkKDApO1xuICAgICAgICAgIGlmIChjLnN5bWJvbCBpbnN0YW5jZW9mIFJ1bGVUYWdUb2tlbl8xLlJ1bGVUYWdUb2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIGMuc3ltYm9sO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgdG9rZW5pemUocGF0dGVybikge1xuICAgICAgbGV0IGNodW5rcyA9IHRoaXMuc3BsaXQocGF0dGVybik7XG4gICAgICBsZXQgdG9rZW5zMiA9IFtdO1xuICAgICAgZm9yIChsZXQgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICAgIGlmIChjaHVuayBpbnN0YW5jZW9mIFRhZ0NodW5rXzEuVGFnQ2h1bmspIHtcbiAgICAgICAgICBsZXQgdGFnQ2h1bmsgPSBjaHVuaztcbiAgICAgICAgICBjb25zdCBmaXJzdENoYXIgPSB0YWdDaHVuay50YWcuc3Vic3RyKDAsIDEpO1xuICAgICAgICAgIGlmIChmaXJzdENoYXIgPT09IGZpcnN0Q2hhci50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICBsZXQgdHR5cGUgPSB0aGlzLl9wYXJzZXIuZ2V0VG9rZW5UeXBlKHRhZ0NodW5rLnRhZyk7XG4gICAgICAgICAgICBpZiAodHR5cGUgPT09IFRva2VuXzEuVG9rZW4uSU5WQUxJRF9UWVBFKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdG9rZW4gXCIgKyB0YWdDaHVuay50YWcgKyBcIiBpbiBwYXR0ZXJuOiBcIiArIHBhdHRlcm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHQgPSBuZXcgVG9rZW5UYWdUb2tlbl8xLlRva2VuVGFnVG9rZW4odGFnQ2h1bmsudGFnLCB0dHlwZSwgdGFnQ2h1bmsubGFiZWwpO1xuICAgICAgICAgICAgdG9rZW5zMi5wdXNoKHQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZmlyc3RDaGFyID09PSBmaXJzdENoYXIudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgbGV0IHJ1bGVJbmRleCA9IHRoaXMuX3BhcnNlci5nZXRSdWxlSW5kZXgodGFnQ2h1bmsudGFnKTtcbiAgICAgICAgICAgIGlmIChydWxlSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcnVsZSBcIiArIHRhZ0NodW5rLnRhZyArIFwiIGluIHBhdHRlcm46IFwiICsgcGF0dGVybik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcnVsZUltYWdpbmFyeVRva2VuVHlwZSA9IHRoaXMuX3BhcnNlci5nZXRBVE5XaXRoQnlwYXNzQWx0cygpLnJ1bGVUb1Rva2VuVHlwZVtydWxlSW5kZXhdO1xuICAgICAgICAgICAgdG9rZW5zMi5wdXNoKG5ldyBSdWxlVGFnVG9rZW5fMS5SdWxlVGFnVG9rZW4odGFnQ2h1bmsudGFnLCBydWxlSW1hZ2luYXJ5VG9rZW5UeXBlLCB0YWdDaHVuay5sYWJlbCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHRhZzogXCIgKyB0YWdDaHVuay50YWcgKyBcIiBpbiBwYXR0ZXJuOiBcIiArIHBhdHRlcm4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgdGV4dENodW5rID0gY2h1bms7XG4gICAgICAgICAgdGhpcy5fbGV4ZXIuaW5wdXRTdHJlYW0gPSBDaGFyU3RyZWFtc18xLkNoYXJTdHJlYW1zLmZyb21TdHJpbmcodGV4dENodW5rLnRleHQpO1xuICAgICAgICAgIGxldCB0ID0gdGhpcy5fbGV4ZXIubmV4dFRva2VuKCk7XG4gICAgICAgICAgd2hpbGUgKHQudHlwZSAhPT0gVG9rZW5fMS5Ub2tlbi5FT0YpIHtcbiAgICAgICAgICAgIHRva2VuczIucHVzaCh0KTtcbiAgICAgICAgICAgIHQgPSB0aGlzLl9sZXhlci5uZXh0VG9rZW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0b2tlbnMyO1xuICAgIH1cbiAgICBzcGxpdChwYXR0ZXJuKSB7XG4gICAgICBsZXQgcCA9IDA7XG4gICAgICBsZXQgbiA9IHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgbGV0IGNodW5rcyA9IFtdO1xuICAgICAgbGV0IGJ1ZjtcbiAgICAgIGxldCBzdGFydHMgPSBbXTtcbiAgICAgIGxldCBzdG9wcyA9IFtdO1xuICAgICAgd2hpbGUgKHAgPCBuKSB7XG4gICAgICAgIGlmIChwID09PSBwYXR0ZXJuLmluZGV4T2YodGhpcy5lc2NhcGUgKyB0aGlzLnN0YXJ0LCBwKSkge1xuICAgICAgICAgIHAgKz0gdGhpcy5lc2NhcGUubGVuZ3RoICsgdGhpcy5zdGFydC5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAocCA9PT0gcGF0dGVybi5pbmRleE9mKHRoaXMuZXNjYXBlICsgdGhpcy5zdG9wLCBwKSkge1xuICAgICAgICAgIHAgKz0gdGhpcy5lc2NhcGUubGVuZ3RoICsgdGhpcy5zdG9wLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmIChwID09PSBwYXR0ZXJuLmluZGV4T2YodGhpcy5zdGFydCwgcCkpIHtcbiAgICAgICAgICBzdGFydHMucHVzaChwKTtcbiAgICAgICAgICBwICs9IHRoaXMuc3RhcnQubGVuZ3RoO1xuICAgICAgICB9IGVsc2UgaWYgKHAgPT09IHBhdHRlcm4uaW5kZXhPZih0aGlzLnN0b3AsIHApKSB7XG4gICAgICAgICAgc3RvcHMucHVzaChwKTtcbiAgICAgICAgICBwICs9IHRoaXMuc3RvcC5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnRzLmxlbmd0aCA+IHN0b3BzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnRlcm1pbmF0ZWQgdGFnIGluIHBhdHRlcm46IFwiICsgcGF0dGVybik7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnRzLmxlbmd0aCA8IHN0b3BzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHN0YXJ0IHRhZyBpbiBwYXR0ZXJuOiBcIiArIHBhdHRlcm4pO1xuICAgICAgfVxuICAgICAgbGV0IG50YWdzID0gc3RhcnRzLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnRhZ3M7IGkrKykge1xuICAgICAgICBpZiAoc3RhcnRzW2ldID49IHN0b3BzW2ldKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGFnIGRlbGltaXRlcnMgb3V0IG9mIG9yZGVyIGluIHBhdHRlcm46IFwiICsgcGF0dGVybik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChudGFncyA9PT0gMCkge1xuICAgICAgICBsZXQgdGV4dCA9IHBhdHRlcm4uc3Vic3RyaW5nKDAsIG4pO1xuICAgICAgICBjaHVua3MucHVzaChuZXcgVGV4dENodW5rXzEuVGV4dENodW5rKHRleHQpKTtcbiAgICAgIH1cbiAgICAgIGlmIChudGFncyA+IDAgJiYgc3RhcnRzWzBdID4gMCkge1xuICAgICAgICBsZXQgdGV4dCA9IHBhdHRlcm4uc3Vic3RyaW5nKDAsIHN0YXJ0c1swXSk7XG4gICAgICAgIGNodW5rcy5wdXNoKG5ldyBUZXh0Q2h1bmtfMS5UZXh0Q2h1bmsodGV4dCkpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudGFnczsgaSsrKSB7XG4gICAgICAgIGxldCB0YWcgPSBwYXR0ZXJuLnN1YnN0cmluZyhzdGFydHNbaV0gKyB0aGlzLnN0YXJ0Lmxlbmd0aCwgc3RvcHNbaV0pO1xuICAgICAgICBsZXQgcnVsZU9yVG9rZW4gPSB0YWc7XG4gICAgICAgIGxldCBsYWJlbDtcbiAgICAgICAgbGV0IGNvbG9uID0gdGFnLmluZGV4T2YoXCI6XCIpO1xuICAgICAgICBpZiAoY29sb24gPj0gMCkge1xuICAgICAgICAgIGxhYmVsID0gdGFnLnN1YnN0cmluZygwLCBjb2xvbik7XG4gICAgICAgICAgcnVsZU9yVG9rZW4gPSB0YWcuc3Vic3RyaW5nKGNvbG9uICsgMSwgdGFnLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmtzLnB1c2gobmV3IFRhZ0NodW5rXzEuVGFnQ2h1bmsocnVsZU9yVG9rZW4sIGxhYmVsKSk7XG4gICAgICAgIGlmIChpICsgMSA8IG50YWdzKSB7XG4gICAgICAgICAgbGV0IHRleHQgPSBwYXR0ZXJuLnN1YnN0cmluZyhzdG9wc1tpXSArIHRoaXMuc3RvcC5sZW5ndGgsIHN0YXJ0c1tpICsgMV0pO1xuICAgICAgICAgIGNodW5rcy5wdXNoKG5ldyBUZXh0Q2h1bmtfMS5UZXh0Q2h1bmsodGV4dCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobnRhZ3MgPiAwKSB7XG4gICAgICAgIGxldCBhZnRlckxhc3RUYWcgPSBzdG9wc1tudGFncyAtIDFdICsgdGhpcy5zdG9wLmxlbmd0aDtcbiAgICAgICAgaWYgKGFmdGVyTGFzdFRhZyA8IG4pIHtcbiAgICAgICAgICBsZXQgdGV4dCA9IHBhdHRlcm4uc3Vic3RyaW5nKGFmdGVyTGFzdFRhZywgbik7XG4gICAgICAgICAgY2h1bmtzLnB1c2gobmV3IFRleHRDaHVua18xLlRleHRDaHVuayh0ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjID0gY2h1bmtzW2ldO1xuICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIFRleHRDaHVua18xLlRleHRDaHVuaykge1xuICAgICAgICAgIGxldCB1bmVzY2FwZWQgPSBjLnRleHQucmVwbGFjZSh0aGlzLmVzY2FwZVJFLCBcIlwiKTtcbiAgICAgICAgICBpZiAodW5lc2NhcGVkLmxlbmd0aCA8IGMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNodW5rc1tpXSA9IG5ldyBUZXh0Q2h1bmtfMS5UZXh0Q2h1bmsodW5lc2NhcGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjaHVua3M7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbCxcbiAgICBfX3BhcmFtKDEsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBQYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlcjIucHJvdG90eXBlLCBcIm1hdGNoXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBQYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlcjIucHJvdG90eXBlLCBcImxleGVyXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBQYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlcjIucHJvdG90eXBlLCBcInBhcnNlclwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgyLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgUGFyc2VUcmVlUGF0dGVybk1hdGNoZXIyLnByb3RvdHlwZSwgXCJtYXRjaEltcGxcIiwgbnVsbCk7XG4gIGV4cG9ydHMuUGFyc2VUcmVlUGF0dGVybk1hdGNoZXIgPSBQYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlcjI7XG4gIChmdW5jdGlvbihQYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlcjMpIHtcbiAgICBjbGFzcyBDYW5ub3RJbnZva2VTdGFydFJ1bGUgZXh0ZW5kcyBFcnJvciB7XG4gICAgICBjb25zdHJ1Y3RvcihlcnJvcikge1xuICAgICAgICBzdXBlcihgQ2Fubm90SW52b2tlU3RhcnRSdWxlOiAke2Vycm9yfWApO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIFBhcnNlVHJlZVBhdHRlcm5NYXRjaGVyMy5DYW5ub3RJbnZva2VTdGFydFJ1bGUgPSBDYW5ub3RJbnZva2VTdGFydFJ1bGU7XG4gICAgY2xhc3MgU3RhcnRSdWxlRG9lc05vdENvbnN1bWVGdWxsUGF0dGVybiBleHRlbmRzIEVycm9yIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcIlN0YXJ0UnVsZURvZXNOb3RDb25zdW1lRnVsbFBhdHRlcm5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIFBhcnNlVHJlZVBhdHRlcm5NYXRjaGVyMy5TdGFydFJ1bGVEb2VzTm90Q29uc3VtZUZ1bGxQYXR0ZXJuID0gU3RhcnRSdWxlRG9lc05vdENvbnN1bWVGdWxsUGF0dGVybjtcbiAgfSkoUGFyc2VUcmVlUGF0dGVybk1hdGNoZXIyID0gZXhwb3J0cy5QYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlciB8fCAoZXhwb3J0cy5QYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlciA9IHt9KSk7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9EZWNpc2lvbkV2ZW50SW5mby5qc1xudmFyIHJlcXVpcmVfRGVjaXNpb25FdmVudEluZm8gPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuRGVjaXNpb25FdmVudEluZm8gPSB2b2lkIDA7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIERlY2lzaW9uRXZlbnRJbmZvID0gY2xhc3MgRGVjaXNpb25FdmVudEluZm8ge1xuICAgIGNvbnN0cnVjdG9yKGRlY2lzaW9uLCBzdGF0ZSwgaW5wdXQsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgZnVsbEN0eCkge1xuICAgICAgdGhpcy5kZWNpc2lvbiA9IGRlY2lzaW9uO1xuICAgICAgdGhpcy5mdWxsQ3R4ID0gZnVsbEN0eDtcbiAgICAgIHRoaXMuc3RvcEluZGV4ID0gc3RvcEluZGV4O1xuICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgdGhpcy5zdGFydEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIERlY2lzaW9uRXZlbnRJbmZvLnByb3RvdHlwZSwgXCJpbnB1dFwiLCB2b2lkIDApO1xuICBEZWNpc2lvbkV2ZW50SW5mbyA9IF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMiwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIERlY2lzaW9uRXZlbnRJbmZvKTtcbiAgZXhwb3J0cy5EZWNpc2lvbkV2ZW50SW5mbyA9IERlY2lzaW9uRXZlbnRJbmZvO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9hdG4vQW1iaWd1aXR5SW5mby5qc1xudmFyIHJlcXVpcmVfQW1iaWd1aXR5SW5mbyA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgdmFyIF9fcGFyYW0gPSBleHBvcnRzICYmIGV4cG9ydHMuX19wYXJhbSB8fCBmdW5jdGlvbihwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7XG4gICAgfTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5BbWJpZ3VpdHlJbmZvID0gdm9pZCAwO1xuICB2YXIgRGVjaXNpb25FdmVudEluZm9fMSA9IHJlcXVpcmVfRGVjaXNpb25FdmVudEluZm8oKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgQW1iaWd1aXR5SW5mbyA9IGNsYXNzIEFtYmlndWl0eUluZm8gZXh0ZW5kcyBEZWNpc2lvbkV2ZW50SW5mb18xLkRlY2lzaW9uRXZlbnRJbmZvIHtcbiAgICBjb25zdHJ1Y3RvcihkZWNpc2lvbiwgc3RhdGUsIGFtYmlnQWx0cywgaW5wdXQsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCkge1xuICAgICAgc3VwZXIoZGVjaXNpb24sIHN0YXRlLCBpbnB1dCwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBzdGF0ZS51c2VDb250ZXh0KTtcbiAgICAgIHRoaXMuYW1iaWdBbHRzID0gYW1iaWdBbHRzO1xuICAgIH1cbiAgICBnZXQgYW1iaWd1b3VzQWx0ZXJuYXRpdmVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYW1iaWdBbHRzO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgQW1iaWd1aXR5SW5mby5wcm90b3R5cGUsIFwiYW1iaWdBbHRzXCIsIHZvaWQgMCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIEFtYmlndWl0eUluZm8ucHJvdG90eXBlLCBcImFtYmlndW91c0FsdGVybmF0aXZlc1wiLCBudWxsKTtcbiAgQW1iaWd1aXR5SW5mbyA9IF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMSwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMiwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMywgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIEFtYmlndWl0eUluZm8pO1xuICBleHBvcnRzLkFtYmlndWl0eUluZm8gPSBBbWJpZ3VpdHlJbmZvO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9hdG4vQ29udGV4dFNlbnNpdGl2aXR5SW5mby5qc1xudmFyIHJlcXVpcmVfQ29udGV4dFNlbnNpdGl2aXR5SW5mbyA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgdmFyIF9fcGFyYW0gPSBleHBvcnRzICYmIGV4cG9ydHMuX19wYXJhbSB8fCBmdW5jdGlvbihwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7XG4gICAgfTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5Db250ZXh0U2Vuc2l0aXZpdHlJbmZvID0gdm9pZCAwO1xuICB2YXIgRGVjaXNpb25FdmVudEluZm9fMSA9IHJlcXVpcmVfRGVjaXNpb25FdmVudEluZm8oKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgQ29udGV4dFNlbnNpdGl2aXR5SW5mbyA9IGNsYXNzIENvbnRleHRTZW5zaXRpdml0eUluZm8gZXh0ZW5kcyBEZWNpc2lvbkV2ZW50SW5mb18xLkRlY2lzaW9uRXZlbnRJbmZvIHtcbiAgICBjb25zdHJ1Y3RvcihkZWNpc2lvbiwgc3RhdGUsIGlucHV0LCBzdGFydEluZGV4LCBzdG9wSW5kZXgpIHtcbiAgICAgIHN1cGVyKGRlY2lzaW9uLCBzdGF0ZSwgaW5wdXQsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgdHJ1ZSk7XG4gICAgfVxuICB9O1xuICBDb250ZXh0U2Vuc2l0aXZpdHlJbmZvID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgyLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgQ29udGV4dFNlbnNpdGl2aXR5SW5mbyk7XG4gIGV4cG9ydHMuQ29udGV4dFNlbnNpdGl2aXR5SW5mbyA9IENvbnRleHRTZW5zaXRpdml0eUluZm87XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9EZWNpc2lvbkluZm8uanNcbnZhciByZXF1aXJlX0RlY2lzaW9uSW5mbyA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5EZWNpc2lvbkluZm8gPSB2b2lkIDA7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIERlY2lzaW9uSW5mbyA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihkZWNpc2lvbikge1xuICAgICAgdGhpcy5pbnZvY2F0aW9ucyA9IDA7XG4gICAgICB0aGlzLnRpbWVJblByZWRpY3Rpb24gPSAwO1xuICAgICAgdGhpcy5TTExfVG90YWxMb29rID0gMDtcbiAgICAgIHRoaXMuU0xMX01pbkxvb2sgPSAwO1xuICAgICAgdGhpcy5TTExfTWF4TG9vayA9IDA7XG4gICAgICB0aGlzLkxMX1RvdGFsTG9vayA9IDA7XG4gICAgICB0aGlzLkxMX01pbkxvb2sgPSAwO1xuICAgICAgdGhpcy5MTF9NYXhMb29rID0gMDtcbiAgICAgIHRoaXMuY29udGV4dFNlbnNpdGl2aXRpZXMgPSBbXTtcbiAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICB0aGlzLmFtYmlndWl0aWVzID0gW107XG4gICAgICB0aGlzLnByZWRpY2F0ZUV2YWxzID0gW107XG4gICAgICB0aGlzLlNMTF9BVE5UcmFuc2l0aW9ucyA9IDA7XG4gICAgICB0aGlzLlNMTF9ERkFUcmFuc2l0aW9ucyA9IDA7XG4gICAgICB0aGlzLkxMX0ZhbGxiYWNrID0gMDtcbiAgICAgIHRoaXMuTExfQVROVHJhbnNpdGlvbnMgPSAwO1xuICAgICAgdGhpcy5MTF9ERkFUcmFuc2l0aW9ucyA9IDA7XG4gICAgICB0aGlzLmRlY2lzaW9uID0gZGVjaXNpb247XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwie2RlY2lzaW9uPVwiICsgdGhpcy5kZWNpc2lvbiArIFwiLCBjb250ZXh0U2Vuc2l0aXZpdGllcz1cIiArIHRoaXMuY29udGV4dFNlbnNpdGl2aXRpZXMubGVuZ3RoICsgXCIsIGVycm9ycz1cIiArIHRoaXMuZXJyb3JzLmxlbmd0aCArIFwiLCBhbWJpZ3VpdGllcz1cIiArIHRoaXMuYW1iaWd1aXRpZXMubGVuZ3RoICsgXCIsIFNMTF9sb29rYWhlYWQ9XCIgKyB0aGlzLlNMTF9Ub3RhbExvb2sgKyBcIiwgU0xMX0FUTlRyYW5zaXRpb25zPVwiICsgdGhpcy5TTExfQVROVHJhbnNpdGlvbnMgKyBcIiwgU0xMX0RGQVRyYW5zaXRpb25zPVwiICsgdGhpcy5TTExfREZBVHJhbnNpdGlvbnMgKyBcIiwgTExfRmFsbGJhY2s9XCIgKyB0aGlzLkxMX0ZhbGxiYWNrICsgXCIsIExMX2xvb2thaGVhZD1cIiArIHRoaXMuTExfVG90YWxMb29rICsgXCIsIExMX0FUTlRyYW5zaXRpb25zPVwiICsgdGhpcy5MTF9BVE5UcmFuc2l0aW9ucyArIFwifVwiO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIERlY2lzaW9uSW5mby5wcm90b3R5cGUsIFwidG9TdHJpbmdcIiwgbnVsbCk7XG4gIGV4cG9ydHMuRGVjaXNpb25JbmZvID0gRGVjaXNpb25JbmZvO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9hdG4vRXJyb3JJbmZvLmpzXG52YXIgcmVxdWlyZV9FcnJvckluZm8gPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuRXJyb3JJbmZvID0gdm9pZCAwO1xuICB2YXIgRGVjaXNpb25FdmVudEluZm9fMSA9IHJlcXVpcmVfRGVjaXNpb25FdmVudEluZm8oKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgRXJyb3JJbmZvID0gY2xhc3MgRXJyb3JJbmZvIGV4dGVuZHMgRGVjaXNpb25FdmVudEluZm9fMS5EZWNpc2lvbkV2ZW50SW5mbyB7XG4gICAgY29uc3RydWN0b3IoZGVjaXNpb24sIHN0YXRlLCBpbnB1dCwgc3RhcnRJbmRleCwgc3RvcEluZGV4KSB7XG4gICAgICBzdXBlcihkZWNpc2lvbiwgc3RhdGUsIGlucHV0LCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIHN0YXRlLnVzZUNvbnRleHQpO1xuICAgIH1cbiAgfTtcbiAgRXJyb3JJbmZvID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgyLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgRXJyb3JJbmZvKTtcbiAgZXhwb3J0cy5FcnJvckluZm8gPSBFcnJvckluZm87XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9Mb29rYWhlYWRFdmVudEluZm8uanNcbnZhciByZXF1aXJlX0xvb2thaGVhZEV2ZW50SW5mbyA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgdmFyIF9fcGFyYW0gPSBleHBvcnRzICYmIGV4cG9ydHMuX19wYXJhbSB8fCBmdW5jdGlvbihwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7XG4gICAgfTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5Mb29rYWhlYWRFdmVudEluZm8gPSB2b2lkIDA7XG4gIHZhciBEZWNpc2lvbkV2ZW50SW5mb18xID0gcmVxdWlyZV9EZWNpc2lvbkV2ZW50SW5mbygpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBMb29rYWhlYWRFdmVudEluZm8gPSBjbGFzcyBMb29rYWhlYWRFdmVudEluZm8gZXh0ZW5kcyBEZWNpc2lvbkV2ZW50SW5mb18xLkRlY2lzaW9uRXZlbnRJbmZvIHtcbiAgICBjb25zdHJ1Y3RvcihkZWNpc2lvbiwgc3RhdGUsIHByZWRpY3RlZEFsdCwgaW5wdXQsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgZnVsbEN0eCkge1xuICAgICAgc3VwZXIoZGVjaXNpb24sIHN0YXRlLCBpbnB1dCwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBmdWxsQ3R4KTtcbiAgICAgIHRoaXMucHJlZGljdGVkQWx0ID0gcHJlZGljdGVkQWx0O1xuICAgIH1cbiAgfTtcbiAgTG9va2FoZWFkRXZlbnRJbmZvID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgzLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgTG9va2FoZWFkRXZlbnRJbmZvKTtcbiAgZXhwb3J0cy5Mb29rYWhlYWRFdmVudEluZm8gPSBMb29rYWhlYWRFdmVudEluZm87XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2F0bi9QcmVkaWNhdGVFdmFsSW5mby5qc1xudmFyIHJlcXVpcmVfUHJlZGljYXRlRXZhbEluZm8gPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuUHJlZGljYXRlRXZhbEluZm8gPSB2b2lkIDA7XG4gIHZhciBEZWNpc2lvbkV2ZW50SW5mb18xID0gcmVxdWlyZV9EZWNpc2lvbkV2ZW50SW5mbygpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBQcmVkaWNhdGVFdmFsSW5mbyA9IGNsYXNzIFByZWRpY2F0ZUV2YWxJbmZvIGV4dGVuZHMgRGVjaXNpb25FdmVudEluZm9fMS5EZWNpc2lvbkV2ZW50SW5mbyB7XG4gICAgY29uc3RydWN0b3Ioc3RhdGUsIGRlY2lzaW9uLCBpbnB1dCwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBzZW1jdHgsIGV2YWxSZXN1bHQsIHByZWRpY3RlZEFsdCkge1xuICAgICAgc3VwZXIoZGVjaXNpb24sIHN0YXRlLCBpbnB1dCwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBzdGF0ZS51c2VDb250ZXh0KTtcbiAgICAgIHRoaXMuc2VtY3R4ID0gc2VtY3R4O1xuICAgICAgdGhpcy5ldmFsUmVzdWx0ID0gZXZhbFJlc3VsdDtcbiAgICAgIHRoaXMucHJlZGljdGVkQWx0ID0gcHJlZGljdGVkQWx0O1xuICAgIH1cbiAgfTtcbiAgUHJlZGljYXRlRXZhbEluZm8gPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDIsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDUsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBQcmVkaWNhdGVFdmFsSW5mbyk7XG4gIGV4cG9ydHMuUHJlZGljYXRlRXZhbEluZm8gPSBQcmVkaWNhdGVFdmFsSW5mbztcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvYXRuL1Byb2ZpbGluZ0FUTlNpbXVsYXRvci5qc1xudmFyIHJlcXVpcmVfUHJvZmlsaW5nQVROU2ltdWxhdG9yID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLlByb2ZpbGluZ0FUTlNpbXVsYXRvciA9IHZvaWQgMDtcbiAgdmFyIEFtYmlndWl0eUluZm9fMSA9IHJlcXVpcmVfQW1iaWd1aXR5SW5mbygpO1xuICB2YXIgQVROXzEgPSByZXF1aXJlX0FUTigpO1xuICB2YXIgQVROU2ltdWxhdG9yXzEgPSByZXF1aXJlX0FUTlNpbXVsYXRvcigpO1xuICB2YXIgQ29udGV4dFNlbnNpdGl2aXR5SW5mb18xID0gcmVxdWlyZV9Db250ZXh0U2Vuc2l0aXZpdHlJbmZvKCk7XG4gIHZhciBEZWNpc2lvbkluZm9fMSA9IHJlcXVpcmVfRGVjaXNpb25JbmZvKCk7XG4gIHZhciBFcnJvckluZm9fMSA9IHJlcXVpcmVfRXJyb3JJbmZvKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIExvb2thaGVhZEV2ZW50SW5mb18xID0gcmVxdWlyZV9Mb29rYWhlYWRFdmVudEluZm8oKTtcbiAgdmFyIFBhcnNlckFUTlNpbXVsYXRvcl8xID0gcmVxdWlyZV9QYXJzZXJBVE5TaW11bGF0b3IoKTtcbiAgdmFyIFByZWRpY2F0ZUV2YWxJbmZvXzEgPSByZXF1aXJlX1ByZWRpY2F0ZUV2YWxJbmZvKCk7XG4gIHZhciBTZW1hbnRpY0NvbnRleHRfMSA9IHJlcXVpcmVfU2VtYW50aWNDb250ZXh0KCk7XG4gIHZhciBTaW11bGF0b3JTdGF0ZV8xID0gcmVxdWlyZV9TaW11bGF0b3JTdGF0ZSgpO1xuICB2YXIgUHJvZmlsaW5nQVROU2ltdWxhdG9yID0gY2xhc3MgZXh0ZW5kcyBQYXJzZXJBVE5TaW11bGF0b3JfMS5QYXJzZXJBVE5TaW11bGF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgICAgc3VwZXIocGFyc2VyLmludGVycHJldGVyLmF0biwgcGFyc2VyKTtcbiAgICAgIHRoaXMuX3N0YXJ0SW5kZXggPSAwO1xuICAgICAgdGhpcy5fc2xsU3RvcEluZGV4ID0gMDtcbiAgICAgIHRoaXMuX2xsU3RvcEluZGV4ID0gMDtcbiAgICAgIHRoaXMuY3VycmVudERlY2lzaW9uID0gMDtcbiAgICAgIHRoaXMuY29uZmxpY3RpbmdBbHRSZXNvbHZlZEJ5U0xMID0gMDtcbiAgICAgIHRoaXMub3B0aW1pemVfbGwxID0gZmFsc2U7XG4gICAgICB0aGlzLnJlcG9ydEFtYmlndWl0aWVzID0gdHJ1ZTtcbiAgICAgIHRoaXMubnVtRGVjaXNpb25zID0gdGhpcy5hdG4uZGVjaXNpb25Ub1N0YXRlLmxlbmd0aDtcbiAgICAgIHRoaXMuZGVjaXNpb25zID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnVtRGVjaXNpb25zOyBpKyspIHtcbiAgICAgICAgdGhpcy5kZWNpc2lvbnMucHVzaChuZXcgRGVjaXNpb25JbmZvXzEuRGVjaXNpb25JbmZvKGkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYWRhcHRpdmVQcmVkaWN0KGlucHV0LCBkZWNpc2lvbiwgb3V0ZXJDb250ZXh0LCB1c2VDb250ZXh0KSB7XG4gICAgICBpZiAodXNlQ29udGV4dCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5hZGFwdGl2ZVByZWRpY3QoaW5wdXQsIGRlY2lzaW9uLCBvdXRlckNvbnRleHQsIHVzZUNvbnRleHQpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5fc3RhcnRJbmRleCA9IGlucHV0LmluZGV4O1xuICAgICAgICB0aGlzLl9zbGxTdG9wSW5kZXggPSB0aGlzLl9zdGFydEluZGV4IC0gMTtcbiAgICAgICAgdGhpcy5fbGxTdG9wSW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5jdXJyZW50RGVjaXNpb24gPSBkZWNpc2lvbjtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuY29uZmxpY3RpbmdBbHRSZXNvbHZlZEJ5U0xMID0gQVROXzEuQVROLklOVkFMSURfQUxUX05VTUJFUjtcbiAgICAgICAgbGV0IHN0YXJ0ID0gcHJvY2Vzcy5ocnRpbWUoKTtcbiAgICAgICAgbGV0IGFsdCA9IHN1cGVyLmFkYXB0aXZlUHJlZGljdChpbnB1dCwgZGVjaXNpb24sIG91dGVyQ29udGV4dCk7XG4gICAgICAgIGxldCBzdG9wID0gcHJvY2Vzcy5ocnRpbWUoKTtcbiAgICAgICAgbGV0IG5hbm9zZWNvbmRzID0gKHN0b3BbMF0gLSBzdGFydFswXSkgKiAxZTk7XG4gICAgICAgIGlmIChuYW5vc2Vjb25kcyA9PT0gMCkge1xuICAgICAgICAgIG5hbm9zZWNvbmRzID0gc3RvcFsxXSAtIHN0YXJ0WzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5hbm9zZWNvbmRzICs9IDFlOSAtIHN0YXJ0WzFdICsgc3RvcFsxXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlY2lzaW9uc1tkZWNpc2lvbl0udGltZUluUHJlZGljdGlvbiArPSBuYW5vc2Vjb25kcztcbiAgICAgICAgdGhpcy5kZWNpc2lvbnNbZGVjaXNpb25dLmludm9jYXRpb25zKys7XG4gICAgICAgIGxldCBTTExfayA9IHRoaXMuX3NsbFN0b3BJbmRleCAtIHRoaXMuX3N0YXJ0SW5kZXggKyAxO1xuICAgICAgICB0aGlzLmRlY2lzaW9uc1tkZWNpc2lvbl0uU0xMX1RvdGFsTG9vayArPSBTTExfaztcbiAgICAgICAgdGhpcy5kZWNpc2lvbnNbZGVjaXNpb25dLlNMTF9NaW5Mb29rID0gdGhpcy5kZWNpc2lvbnNbZGVjaXNpb25dLlNMTF9NaW5Mb29rID09PSAwID8gU0xMX2sgOiBNYXRoLm1pbih0aGlzLmRlY2lzaW9uc1tkZWNpc2lvbl0uU0xMX01pbkxvb2ssIFNMTF9rKTtcbiAgICAgICAgaWYgKFNMTF9rID4gdGhpcy5kZWNpc2lvbnNbZGVjaXNpb25dLlNMTF9NYXhMb29rKSB7XG4gICAgICAgICAgdGhpcy5kZWNpc2lvbnNbZGVjaXNpb25dLlNMTF9NYXhMb29rID0gU0xMX2s7XG4gICAgICAgICAgdGhpcy5kZWNpc2lvbnNbZGVjaXNpb25dLlNMTF9NYXhMb29rRXZlbnQgPSBuZXcgTG9va2FoZWFkRXZlbnRJbmZvXzEuTG9va2FoZWFkRXZlbnRJbmZvKGRlY2lzaW9uLCB2b2lkIDAsIGFsdCwgaW5wdXQsIHRoaXMuX3N0YXJ0SW5kZXgsIHRoaXMuX3NsbFN0b3BJbmRleCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9sbFN0b3BJbmRleCA+PSAwKSB7XG4gICAgICAgICAgbGV0IExMX2sgPSB0aGlzLl9sbFN0b3BJbmRleCAtIHRoaXMuX3N0YXJ0SW5kZXggKyAxO1xuICAgICAgICAgIHRoaXMuZGVjaXNpb25zW2RlY2lzaW9uXS5MTF9Ub3RhbExvb2sgKz0gTExfaztcbiAgICAgICAgICB0aGlzLmRlY2lzaW9uc1tkZWNpc2lvbl0uTExfTWluTG9vayA9IHRoaXMuZGVjaXNpb25zW2RlY2lzaW9uXS5MTF9NaW5Mb29rID09PSAwID8gTExfayA6IE1hdGgubWluKHRoaXMuZGVjaXNpb25zW2RlY2lzaW9uXS5MTF9NaW5Mb29rLCBMTF9rKTtcbiAgICAgICAgICBpZiAoTExfayA+IHRoaXMuZGVjaXNpb25zW2RlY2lzaW9uXS5MTF9NYXhMb29rKSB7XG4gICAgICAgICAgICB0aGlzLmRlY2lzaW9uc1tkZWNpc2lvbl0uTExfTWF4TG9vayA9IExMX2s7XG4gICAgICAgICAgICB0aGlzLmRlY2lzaW9uc1tkZWNpc2lvbl0uTExfTWF4TG9va0V2ZW50ID0gbmV3IExvb2thaGVhZEV2ZW50SW5mb18xLkxvb2thaGVhZEV2ZW50SW5mbyhkZWNpc2lvbiwgdm9pZCAwLCBhbHQsIGlucHV0LCB0aGlzLl9zdGFydEluZGV4LCB0aGlzLl9sbFN0b3BJbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbHQ7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLl9pbnB1dCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5jdXJyZW50RGVjaXNpb24gPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0U3RhcnRTdGF0ZShkZmEsIGlucHV0LCBvdXRlckNvbnRleHQsIHVzZUNvbnRleHQpIHtcbiAgICAgIGxldCBzdGF0ZSA9IHN1cGVyLmdldFN0YXJ0U3RhdGUoZGZhLCBpbnB1dCwgb3V0ZXJDb250ZXh0LCB1c2VDb250ZXh0KTtcbiAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gc3RhdGU7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGNvbXB1dGVTdGFydFN0YXRlKGRmYSwgZ2xvYmFsQ29udGV4dCwgdXNlQ29udGV4dCkge1xuICAgICAgbGV0IHN0YXRlID0gc3VwZXIuY29tcHV0ZVN0YXJ0U3RhdGUoZGZhLCBnbG9iYWxDb250ZXh0LCB1c2VDb250ZXh0KTtcbiAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gc3RhdGU7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGNvbXB1dGVSZWFjaFNldChkZmEsIHByZXZpb3VzLCB0LCBjb250ZXh0Q2FjaGUpIHtcbiAgICAgIGlmICh0aGlzLl9pbnB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdGVcIik7XG4gICAgICB9XG4gICAgICBsZXQgcmVhY2hTdGF0ZSA9IHN1cGVyLmNvbXB1dGVSZWFjaFNldChkZmEsIHByZXZpb3VzLCB0LCBjb250ZXh0Q2FjaGUpO1xuICAgICAgaWYgKHJlYWNoU3RhdGUgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmRlY2lzaW9uc1t0aGlzLmN1cnJlbnREZWNpc2lvbl0uZXJyb3JzLnB1c2gobmV3IEVycm9ySW5mb18xLkVycm9ySW5mbyh0aGlzLmN1cnJlbnREZWNpc2lvbiwgcHJldmlvdXMsIHRoaXMuX2lucHV0LCB0aGlzLl9zdGFydEluZGV4LCB0aGlzLl9pbnB1dC5pbmRleCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSByZWFjaFN0YXRlO1xuICAgICAgcmV0dXJuIHJlYWNoU3RhdGU7XG4gICAgfVxuICAgIGdldEV4aXN0aW5nVGFyZ2V0U3RhdGUocHJldmlvdXNELCB0KSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUgPT09IHZvaWQgMCB8fCB0aGlzLl9pbnB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdGVcIik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUudXNlQ29udGV4dCkge1xuICAgICAgICB0aGlzLl9sbFN0b3BJbmRleCA9IHRoaXMuX2lucHV0LmluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2xsU3RvcEluZGV4ID0gdGhpcy5faW5wdXQuaW5kZXg7XG4gICAgICB9XG4gICAgICBsZXQgZXhpc3RpbmdUYXJnZXRTdGF0ZSA9IHN1cGVyLmdldEV4aXN0aW5nVGFyZ2V0U3RhdGUocHJldmlvdXNELCB0KTtcbiAgICAgIGlmIChleGlzdGluZ1RhcmdldFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBuZXcgU2ltdWxhdG9yU3RhdGVfMS5TaW11bGF0b3JTdGF0ZSh0aGlzLmN1cnJlbnRTdGF0ZS5vdXRlckNvbnRleHQsIGV4aXN0aW5nVGFyZ2V0U3RhdGUsIHRoaXMuY3VycmVudFN0YXRlLnVzZUNvbnRleHQsIHRoaXMuY3VycmVudFN0YXRlLnJlbWFpbmluZ091dGVyQ29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0ZS51c2VDb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy5kZWNpc2lvbnNbdGhpcy5jdXJyZW50RGVjaXNpb25dLkxMX0RGQVRyYW5zaXRpb25zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZWNpc2lvbnNbdGhpcy5jdXJyZW50RGVjaXNpb25dLlNMTF9ERkFUcmFuc2l0aW9ucysrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleGlzdGluZ1RhcmdldFN0YXRlID09PSBBVE5TaW11bGF0b3JfMS5BVE5TaW11bGF0b3IuRVJST1IpIHtcbiAgICAgICAgICBsZXQgc3RhdGUgPSBuZXcgU2ltdWxhdG9yU3RhdGVfMS5TaW11bGF0b3JTdGF0ZSh0aGlzLmN1cnJlbnRTdGF0ZS5vdXRlckNvbnRleHQsIHByZXZpb3VzRCwgdGhpcy5jdXJyZW50U3RhdGUudXNlQ29udGV4dCwgdGhpcy5jdXJyZW50U3RhdGUucmVtYWluaW5nT3V0ZXJDb250ZXh0KTtcbiAgICAgICAgICB0aGlzLmRlY2lzaW9uc1t0aGlzLmN1cnJlbnREZWNpc2lvbl0uZXJyb3JzLnB1c2gobmV3IEVycm9ySW5mb18xLkVycm9ySW5mbyh0aGlzLmN1cnJlbnREZWNpc2lvbiwgc3RhdGUsIHRoaXMuX2lucHV0LCB0aGlzLl9zdGFydEluZGV4LCB0aGlzLl9pbnB1dC5pbmRleCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhpc3RpbmdUYXJnZXRTdGF0ZTtcbiAgICB9XG4gICAgY29tcHV0ZVRhcmdldFN0YXRlKGRmYSwgcywgcmVtYWluaW5nR2xvYmFsQ29udGV4dCwgdCwgdXNlQ29udGV4dCwgY29udGV4dENhY2hlKSB7XG4gICAgICBsZXQgdGFyZ2V0U3RhdGUgPSBzdXBlci5jb21wdXRlVGFyZ2V0U3RhdGUoZGZhLCBzLCByZW1haW5pbmdHbG9iYWxDb250ZXh0LCB0LCB1c2VDb250ZXh0LCBjb250ZXh0Q2FjaGUpO1xuICAgICAgaWYgKHVzZUNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5kZWNpc2lvbnNbdGhpcy5jdXJyZW50RGVjaXNpb25dLkxMX0FUTlRyYW5zaXRpb25zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlY2lzaW9uc1t0aGlzLmN1cnJlbnREZWNpc2lvbl0uU0xMX0FUTlRyYW5zaXRpb25zKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0U3RhdGU7XG4gICAgfVxuICAgIGV2YWxTZW1hbnRpY0NvbnRleHRJbXBsKHByZWQsIHBhcnNlckNhbGxTdGFjaywgYWx0KSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUgPT09IHZvaWQgMCB8fCB0aGlzLl9pbnB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdGVcIik7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdWx0ID0gc3VwZXIuZXZhbFNlbWFudGljQ29udGV4dEltcGwocHJlZCwgcGFyc2VyQ2FsbFN0YWNrLCBhbHQpO1xuICAgICAgaWYgKCEocHJlZCBpbnN0YW5jZW9mIFNlbWFudGljQ29udGV4dF8xLlNlbWFudGljQ29udGV4dC5QcmVjZWRlbmNlUHJlZGljYXRlKSkge1xuICAgICAgICBsZXQgZnVsbENvbnRleHQgPSB0aGlzLl9sbFN0b3BJbmRleCA+PSAwO1xuICAgICAgICBsZXQgc3RvcEluZGV4ID0gZnVsbENvbnRleHQgPyB0aGlzLl9sbFN0b3BJbmRleCA6IHRoaXMuX3NsbFN0b3BJbmRleDtcbiAgICAgICAgdGhpcy5kZWNpc2lvbnNbdGhpcy5jdXJyZW50RGVjaXNpb25dLnByZWRpY2F0ZUV2YWxzLnB1c2gobmV3IFByZWRpY2F0ZUV2YWxJbmZvXzEuUHJlZGljYXRlRXZhbEluZm8odGhpcy5jdXJyZW50U3RhdGUsIHRoaXMuY3VycmVudERlY2lzaW9uLCB0aGlzLl9pbnB1dCwgdGhpcy5fc3RhcnRJbmRleCwgc3RvcEluZGV4LCBwcmVkLCByZXN1bHQsIGFsdCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5KGRmYSwgcHJlZGljdGlvbiwgYWNjZXB0U3RhdGUsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCkge1xuICAgICAgaWYgKHRoaXMuX2lucHV0ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0ZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVkaWN0aW9uICE9PSB0aGlzLmNvbmZsaWN0aW5nQWx0UmVzb2x2ZWRCeVNMTCkge1xuICAgICAgICB0aGlzLmRlY2lzaW9uc1t0aGlzLmN1cnJlbnREZWNpc2lvbl0uY29udGV4dFNlbnNpdGl2aXRpZXMucHVzaChuZXcgQ29udGV4dFNlbnNpdGl2aXR5SW5mb18xLkNvbnRleHRTZW5zaXRpdml0eUluZm8odGhpcy5jdXJyZW50RGVjaXNpb24sIGFjY2VwdFN0YXRlLCB0aGlzLl9pbnB1dCwgc3RhcnRJbmRleCwgc3RvcEluZGV4KSk7XG4gICAgICB9XG4gICAgICBzdXBlci5yZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHkoZGZhLCBwcmVkaWN0aW9uLCBhY2NlcHRTdGF0ZSwgc3RhcnRJbmRleCwgc3RvcEluZGV4KTtcbiAgICB9XG4gICAgcmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0KGRmYSwgY29uZmxpY3RpbmdBbHRzLCBjb25mbGljdFN0YXRlLCBzdGFydEluZGV4LCBzdG9wSW5kZXgpIHtcbiAgICAgIGlmIChjb25mbGljdGluZ0FsdHMgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNvbmZsaWN0aW5nQWx0UmVzb2x2ZWRCeVNMTCA9IGNvbmZsaWN0aW5nQWx0cy5uZXh0U2V0Qml0KDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb25mbGljdGluZ0FsdFJlc29sdmVkQnlTTEwgPSBjb25mbGljdFN0YXRlLnMwLmNvbmZpZ3MuZ2V0UmVwcmVzZW50ZWRBbHRlcm5hdGl2ZXMoKS5uZXh0U2V0Qml0KDApO1xuICAgICAgfVxuICAgICAgdGhpcy5kZWNpc2lvbnNbdGhpcy5jdXJyZW50RGVjaXNpb25dLkxMX0ZhbGxiYWNrKys7XG4gICAgICBzdXBlci5yZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHQoZGZhLCBjb25mbGljdGluZ0FsdHMsIGNvbmZsaWN0U3RhdGUsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCk7XG4gICAgfVxuICAgIHJlcG9ydEFtYmlndWl0eShkZmEsIEQsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgZXhhY3QsIGFtYmlnQWx0cywgY29uZmlncykge1xuICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRlID09PSB2b2lkIDAgfHwgdGhpcy5faW5wdXQgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXRlXCIpO1xuICAgICAgfVxuICAgICAgbGV0IHByZWRpY3Rpb247XG4gICAgICBpZiAoYW1iaWdBbHRzICE9IG51bGwpIHtcbiAgICAgICAgcHJlZGljdGlvbiA9IGFtYmlnQWx0cy5uZXh0U2V0Qml0KDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZGljdGlvbiA9IGNvbmZpZ3MuZ2V0UmVwcmVzZW50ZWRBbHRlcm5hdGl2ZXMoKS5uZXh0U2V0Qml0KDApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29uZmxpY3RpbmdBbHRSZXNvbHZlZEJ5U0xMICE9PSBBVE5fMS5BVE4uSU5WQUxJRF9BTFRfTlVNQkVSICYmIHByZWRpY3Rpb24gIT09IHRoaXMuY29uZmxpY3RpbmdBbHRSZXNvbHZlZEJ5U0xMKSB7XG4gICAgICAgIHRoaXMuZGVjaXNpb25zW3RoaXMuY3VycmVudERlY2lzaW9uXS5jb250ZXh0U2Vuc2l0aXZpdGllcy5wdXNoKG5ldyBDb250ZXh0U2Vuc2l0aXZpdHlJbmZvXzEuQ29udGV4dFNlbnNpdGl2aXR5SW5mbyh0aGlzLmN1cnJlbnREZWNpc2lvbiwgdGhpcy5jdXJyZW50U3RhdGUsIHRoaXMuX2lucHV0LCBzdGFydEluZGV4LCBzdG9wSW5kZXgpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVjaXNpb25zW3RoaXMuY3VycmVudERlY2lzaW9uXS5hbWJpZ3VpdGllcy5wdXNoKG5ldyBBbWJpZ3VpdHlJbmZvXzEuQW1iaWd1aXR5SW5mbyh0aGlzLmN1cnJlbnREZWNpc2lvbiwgdGhpcy5jdXJyZW50U3RhdGUsIGFtYmlnQWx0cywgdGhpcy5faW5wdXQsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCkpO1xuICAgICAgc3VwZXIucmVwb3J0QW1iaWd1aXR5KGRmYSwgRCwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBleGFjdCwgYW1iaWdBbHRzLCBjb25maWdzKTtcbiAgICB9XG4gICAgZ2V0RGVjaXNpb25JbmZvKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjaXNpb25zO1xuICAgIH1cbiAgICBnZXRDdXJyZW50U3RhdGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50U3RhdGU7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGUsXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgUHJvZmlsaW5nQVROU2ltdWxhdG9yLnByb3RvdHlwZSwgXCJhZGFwdGl2ZVByZWRpY3RcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBQcm9maWxpbmdBVE5TaW11bGF0b3IucHJvdG90eXBlLCBcImdldFN0YXJ0U3RhdGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBQcm9maWxpbmdBVE5TaW11bGF0b3IucHJvdG90eXBlLCBcImNvbXB1dGVTdGFydFN0YXRlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgUHJvZmlsaW5nQVROU2ltdWxhdG9yLnByb3RvdHlwZSwgXCJjb21wdXRlUmVhY2hTZXRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBQcm9maWxpbmdBVE5TaW11bGF0b3IucHJvdG90eXBlLCBcImdldEV4aXN0aW5nVGFyZ2V0U3RhdGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBQcm9maWxpbmdBVE5TaW11bGF0b3IucHJvdG90eXBlLCBcImNvbXB1dGVUYXJnZXRTdGF0ZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFByb2ZpbGluZ0FUTlNpbXVsYXRvci5wcm90b3R5cGUsIFwiZXZhbFNlbWFudGljQ29udGV4dEltcGxcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBQcm9maWxpbmdBVE5TaW11bGF0b3IucHJvdG90eXBlLCBcInJlcG9ydENvbnRleHRTZW5zaXRpdml0eVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFByb2ZpbGluZ0FUTlNpbXVsYXRvci5wcm90b3R5cGUsIFwicmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGUsXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSg1LCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSg2LCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgUHJvZmlsaW5nQVROU2ltdWxhdG9yLnByb3RvdHlwZSwgXCJyZXBvcnRBbWJpZ3VpdHlcIiwgbnVsbCk7XG4gIGV4cG9ydHMuUHJvZmlsaW5nQVROU2ltdWxhdG9yID0gUHJvZmlsaW5nQVROU2ltdWxhdG9yO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9QYXJzZXIuanNcbnZhciByZXF1aXJlX1BhcnNlciA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgdmFyIF9fcGFyYW0gPSBleHBvcnRzICYmIGV4cG9ydHMuX19wYXJhbSB8fCBmdW5jdGlvbihwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7XG4gICAgfTtcbiAgfTtcbiAgdmFyIF9fYXdhaXRlciA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2F3YWl0ZXIgfHwgZnVuY3Rpb24odGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgICAgfVxuICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLlBhcnNlciA9IHZvaWQgMDtcbiAgdmFyIFV0aWxzMyA9IHJlcXVpcmVfVXRpbHMoKTtcbiAgdmFyIEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnNfMSA9IHJlcXVpcmVfQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucygpO1xuICB2YXIgQVRORGVzZXJpYWxpemVyXzEgPSByZXF1aXJlX0FUTkRlc2VyaWFsaXplcigpO1xuICB2YXIgRGVmYXVsdEVycm9yU3RyYXRlZ3lfMSA9IHJlcXVpcmVfRGVmYXVsdEVycm9yU3RyYXRlZ3koKTtcbiAgdmFyIEVycm9yTm9kZV8xID0gcmVxdWlyZV9FcnJvck5vZGUoKTtcbiAgdmFyIEludGVnZXJTdGFja18xID0gcmVxdWlyZV9JbnRlZ2VyU3RhY2soKTtcbiAgdmFyIExleGVyXzEgPSByZXF1aXJlX0xleGVyKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIFBhcnNlSW5mb18xID0gcmVxdWlyZV9QYXJzZUluZm8oKTtcbiAgdmFyIFBhcnNlckFUTlNpbXVsYXRvcl8xID0gcmVxdWlyZV9QYXJzZXJBVE5TaW11bGF0b3IoKTtcbiAgdmFyIFByb3h5UGFyc2VyRXJyb3JMaXN0ZW5lcl8xID0gcmVxdWlyZV9Qcm94eVBhcnNlckVycm9yTGlzdGVuZXIoKTtcbiAgdmFyIFJlY29nbml6ZXJfMSA9IHJlcXVpcmVfUmVjb2duaXplcigpO1xuICB2YXIgVGVybWluYWxOb2RlXzEgPSByZXF1aXJlX1Rlcm1pbmFsTm9kZSgpO1xuICB2YXIgVG9rZW5fMSA9IHJlcXVpcmVfVG9rZW4oKTtcbiAgdmFyIFRyYWNlTGlzdGVuZXIgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IocnVsZU5hbWVzLCB0b2tlblN0cmVhbSkge1xuICAgICAgdGhpcy5ydWxlTmFtZXMgPSBydWxlTmFtZXM7XG4gICAgICB0aGlzLnRva2VuU3RyZWFtID0gdG9rZW5TdHJlYW07XG4gICAgfVxuICAgIGVudGVyRXZlcnlSdWxlKGN0eCkge1xuICAgICAgY29uc29sZS5sb2coXCJlbnRlciAgIFwiICsgdGhpcy5ydWxlTmFtZXNbY3R4LnJ1bGVJbmRleF0gKyBcIiwgTFQoMSk9XCIgKyB0aGlzLnRva2VuU3RyZWFtLkxUKDEpLnRleHQpO1xuICAgIH1cbiAgICBleGl0RXZlcnlSdWxlKGN0eCkge1xuICAgICAgY29uc29sZS5sb2coXCJleGl0ICAgIFwiICsgdGhpcy5ydWxlTmFtZXNbY3R4LnJ1bGVJbmRleF0gKyBcIiwgTFQoMSk9XCIgKyB0aGlzLnRva2VuU3RyZWFtLkxUKDEpLnRleHQpO1xuICAgIH1cbiAgICB2aXNpdEVycm9yTm9kZShub2RlKSB7XG4gICAgfVxuICAgIHZpc2l0VGVybWluYWwobm9kZSkge1xuICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50LnJ1bGVDb250ZXh0O1xuICAgICAgbGV0IHRva2VuID0gbm9kZS5zeW1ib2w7XG4gICAgICBjb25zb2xlLmxvZyhcImNvbnN1bWUgXCIgKyB0b2tlbiArIFwiIHJ1bGUgXCIgKyB0aGlzLnJ1bGVOYW1lc1twYXJlbnQucnVsZUluZGV4XSk7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgVHJhY2VMaXN0ZW5lci5wcm90b3R5cGUsIFwiZW50ZXJFdmVyeVJ1bGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBUcmFjZUxpc3RlbmVyLnByb3RvdHlwZSwgXCJleGl0RXZlcnlSdWxlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgVHJhY2VMaXN0ZW5lci5wcm90b3R5cGUsIFwidmlzaXRFcnJvck5vZGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBUcmFjZUxpc3RlbmVyLnByb3RvdHlwZSwgXCJ2aXNpdFRlcm1pbmFsXCIsIG51bGwpO1xuICB2YXIgUGFyc2VyMiA9IGNsYXNzIGV4dGVuZHMgUmVjb2duaXplcl8xLlJlY29nbml6ZXIge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5fZXJySGFuZGxlciA9IG5ldyBEZWZhdWx0RXJyb3JTdHJhdGVneV8xLkRlZmF1bHRFcnJvclN0cmF0ZWd5KCk7XG4gICAgICB0aGlzLl9wcmVjZWRlbmNlU3RhY2sgPSBuZXcgSW50ZWdlclN0YWNrXzEuSW50ZWdlclN0YWNrKCk7XG4gICAgICB0aGlzLl9idWlsZFBhcnNlVHJlZXMgPSB0cnVlO1xuICAgICAgdGhpcy5fcGFyc2VMaXN0ZW5lcnMgPSBbXTtcbiAgICAgIHRoaXMuX3N5bnRheEVycm9ycyA9IDA7XG4gICAgICB0aGlzLm1hdGNoZWRFT0YgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3ByZWNlZGVuY2VTdGFjay5wdXNoKDApO1xuICAgICAgdGhpcy5pbnB1dFN0cmVhbSA9IGlucHV0O1xuICAgIH1cbiAgICByZXNldChyZXNldElucHV0KSB7XG4gICAgICBpZiAocmVzZXRJbnB1dCA9PT0gdm9pZCAwIHx8IHJlc2V0SW5wdXQpIHtcbiAgICAgICAgdGhpcy5pbnB1dFN0cmVhbS5zZWVrKDApO1xuICAgICAgfVxuICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXNldCh0aGlzKTtcbiAgICAgIHRoaXMuX2N0eCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX3N5bnRheEVycm9ycyA9IDA7XG4gICAgICB0aGlzLm1hdGNoZWRFT0YgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNUcmFjZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fcHJlY2VkZW5jZVN0YWNrLmNsZWFyKCk7XG4gICAgICB0aGlzLl9wcmVjZWRlbmNlU3RhY2sucHVzaCgwKTtcbiAgICAgIGxldCBpbnRlcnByZXRlciA9IHRoaXMuaW50ZXJwcmV0ZXI7XG4gICAgICBpZiAoaW50ZXJwcmV0ZXIgIT0gbnVsbCkge1xuICAgICAgICBpbnRlcnByZXRlci5yZXNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXRjaCh0dHlwZSkge1xuICAgICAgbGV0IHQgPSB0aGlzLmN1cnJlbnRUb2tlbjtcbiAgICAgIGlmICh0LnR5cGUgPT09IHR0eXBlKSB7XG4gICAgICAgIGlmICh0dHlwZSA9PT0gVG9rZW5fMS5Ub2tlbi5FT0YpIHtcbiAgICAgICAgICB0aGlzLm1hdGNoZWRFT0YgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IHRoaXMuX2VyckhhbmRsZXIucmVjb3ZlcklubGluZSh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuX2J1aWxkUGFyc2VUcmVlcyAmJiB0LnRva2VuSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5fY3R4LmFkZEVycm9yTm9kZSh0aGlzLmNyZWF0ZUVycm9yTm9kZSh0aGlzLl9jdHgsIHQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICAgIG1hdGNoV2lsZGNhcmQoKSB7XG4gICAgICBsZXQgdCA9IHRoaXMuY3VycmVudFRva2VuO1xuICAgICAgaWYgKHQudHlwZSA+IDApIHtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRNYXRjaCh0aGlzKTtcbiAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ID0gdGhpcy5fZXJySGFuZGxlci5yZWNvdmVySW5saW5lKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5fYnVpbGRQYXJzZVRyZWVzICYmIHQudG9rZW5JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9jdHguYWRkRXJyb3JOb2RlKHRoaXMuY3JlYXRlRXJyb3JOb2RlKHRoaXMuX2N0eCwgdCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgc2V0IGJ1aWxkUGFyc2VUcmVlKGJ1aWxkUGFyc2VUcmVlcykge1xuICAgICAgdGhpcy5fYnVpbGRQYXJzZVRyZWVzID0gYnVpbGRQYXJzZVRyZWVzO1xuICAgIH1cbiAgICBnZXQgYnVpbGRQYXJzZVRyZWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYnVpbGRQYXJzZVRyZWVzO1xuICAgIH1cbiAgICBnZXRQYXJzZUxpc3RlbmVycygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJzZUxpc3RlbmVycztcbiAgICB9XG4gICAgYWRkUGFyc2VMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxpc3RlbmVyIGNhbm5vdCBiZSBudWxsXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcGFyc2VMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJlbW92ZVBhcnNlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgIGxldCBpbmRleCA9IHRoaXMuX3BhcnNlTGlzdGVuZXJzLmZpbmRJbmRleCgobCkgPT4gbCA9PT0gbGlzdGVuZXIpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLl9wYXJzZUxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVQYXJzZUxpc3RlbmVycygpIHtcbiAgICAgIHRoaXMuX3BhcnNlTGlzdGVuZXJzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHRyaWdnZXJFbnRlclJ1bGVFdmVudCgpIHtcbiAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3BhcnNlTGlzdGVuZXJzKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lci5lbnRlckV2ZXJ5UnVsZSkge1xuICAgICAgICAgIGxpc3RlbmVyLmVudGVyRXZlcnlSdWxlKHRoaXMuX2N0eCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3R4LmVudGVyUnVsZShsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuICAgIHRyaWdnZXJFeGl0UnVsZUV2ZW50KCkge1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX3BhcnNlTGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBsaXN0ZW5lciA9IHRoaXMuX3BhcnNlTGlzdGVuZXJzW2ldO1xuICAgICAgICB0aGlzLl9jdHguZXhpdFJ1bGUobGlzdGVuZXIpO1xuICAgICAgICBpZiAobGlzdGVuZXIuZXhpdEV2ZXJ5UnVsZSkge1xuICAgICAgICAgIGxpc3RlbmVyLmV4aXRFdmVyeVJ1bGUodGhpcy5fY3R4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBnZXQgbnVtYmVyT2ZTeW50YXhFcnJvcnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3ludGF4RXJyb3JzO1xuICAgIH1cbiAgICBnZXQgdG9rZW5GYWN0b3J5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lucHV0LnRva2VuU291cmNlLnRva2VuRmFjdG9yeTtcbiAgICB9XG4gICAgZ2V0QVROV2l0aEJ5cGFzc0FsdHMoKSB7XG4gICAgICBsZXQgc2VyaWFsaXplZEF0biA9IHRoaXMuc2VyaWFsaXplZEFUTjtcbiAgICAgIGlmIChzZXJpYWxpemVkQXRuID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgcGFyc2VyIGRvZXMgbm90IHN1cHBvcnQgYW4gQVROIHdpdGggYnlwYXNzIGFsdGVybmF0aXZlcy5cIik7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdWx0ID0gUGFyc2VyMi5ieXBhc3NBbHRzQXRuQ2FjaGUuZ2V0KHNlcmlhbGl6ZWRBdG4pO1xuICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgIGxldCBkZXNlcmlhbGl6YXRpb25PcHRpb25zID0gbmV3IEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnNfMS5BVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zKCk7XG4gICAgICAgIGRlc2VyaWFsaXphdGlvbk9wdGlvbnMuaXNHZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9ucyA9IHRydWU7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBBVE5EZXNlcmlhbGl6ZXJfMS5BVE5EZXNlcmlhbGl6ZXIoZGVzZXJpYWxpemF0aW9uT3B0aW9ucykuZGVzZXJpYWxpemUoVXRpbHMzLnRvQ2hhckFycmF5KHNlcmlhbGl6ZWRBdG4pKTtcbiAgICAgICAgUGFyc2VyMi5ieXBhc3NBbHRzQXRuQ2FjaGUuc2V0KHNlcmlhbGl6ZWRBdG4sIHJlc3VsdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb21waWxlUGFyc2VUcmVlUGF0dGVybihwYXR0ZXJuLCBwYXR0ZXJuUnVsZUluZGV4LCBsZXhlcikge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKCFsZXhlcikge1xuICAgICAgICAgIGlmICh0aGlzLmlucHV0U3RyZWFtKSB7XG4gICAgICAgICAgICBsZXQgdG9rZW5Tb3VyY2UgPSB0aGlzLmlucHV0U3RyZWFtLnRva2VuU291cmNlO1xuICAgICAgICAgICAgaWYgKHRva2VuU291cmNlIGluc3RhbmNlb2YgTGV4ZXJfMS5MZXhlcikge1xuICAgICAgICAgICAgICBsZXhlciA9IHRva2VuU291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWxleGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJzZXIgY2FuJ3QgZGlzY292ZXIgYSBsZXhlciB0byB1c2VcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50TGV4ZXIgPSBsZXhlcjtcbiAgICAgICAgbGV0IG0gPSB5aWVsZCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHJlcXVpcmVfUGFyc2VUcmVlUGF0dGVybk1hdGNoZXIoKSk7XG4gICAgICAgIGxldCBtYXRjaGVyID0gbmV3IG0uUGFyc2VUcmVlUGF0dGVybk1hdGNoZXIoY3VycmVudExleGVyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIuY29tcGlsZShwYXR0ZXJuLCBwYXR0ZXJuUnVsZUluZGV4KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgZXJyb3JIYW5kbGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VyckhhbmRsZXI7XG4gICAgfVxuICAgIHNldCBlcnJvckhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgdGhpcy5fZXJySGFuZGxlciA9IGhhbmRsZXI7XG4gICAgfVxuICAgIGdldCBpbnB1dFN0cmVhbSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbnB1dDtcbiAgICB9XG4gICAgc2V0IGlucHV0U3RyZWFtKGlucHV0KSB7XG4gICAgICB0aGlzLnJlc2V0KGZhbHNlKTtcbiAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgfVxuICAgIGdldCBjdXJyZW50VG9rZW4oKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5wdXQuTFQoMSk7XG4gICAgfVxuICAgIG5vdGlmeUVycm9yTGlzdGVuZXJzKG1zZywgb2ZmZW5kaW5nVG9rZW4sIGUpIHtcbiAgICAgIGlmIChvZmZlbmRpbmdUb2tlbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9mZmVuZGluZ1Rva2VuID0gdGhpcy5jdXJyZW50VG9rZW47XG4gICAgICB9IGVsc2UgaWYgKG9mZmVuZGluZ1Rva2VuID09PSBudWxsKSB7XG4gICAgICAgIG9mZmVuZGluZ1Rva2VuID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3ludGF4RXJyb3JzKys7XG4gICAgICBsZXQgbGluZSA9IC0xO1xuICAgICAgbGV0IGNoYXJQb3NpdGlvbkluTGluZSA9IC0xO1xuICAgICAgaWYgKG9mZmVuZGluZ1Rva2VuICE9IG51bGwpIHtcbiAgICAgICAgbGluZSA9IG9mZmVuZGluZ1Rva2VuLmxpbmU7XG4gICAgICAgIGNoYXJQb3NpdGlvbkluTGluZSA9IG9mZmVuZGluZ1Rva2VuLmNoYXJQb3NpdGlvbkluTGluZTtcbiAgICAgIH1cbiAgICAgIGxldCBsaXN0ZW5lciA9IHRoaXMuZ2V0RXJyb3JMaXN0ZW5lckRpc3BhdGNoKCk7XG4gICAgICBpZiAobGlzdGVuZXIuc3ludGF4RXJyb3IpIHtcbiAgICAgICAgbGlzdGVuZXIuc3ludGF4RXJyb3IodGhpcywgb2ZmZW5kaW5nVG9rZW4sIGxpbmUsIGNoYXJQb3NpdGlvbkluTGluZSwgbXNnLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3VtZSgpIHtcbiAgICAgIGxldCBvID0gdGhpcy5jdXJyZW50VG9rZW47XG4gICAgICBpZiAoby50eXBlICE9PSBQYXJzZXIyLkVPRikge1xuICAgICAgICB0aGlzLmlucHV0U3RyZWFtLmNvbnN1bWUoKTtcbiAgICAgIH1cbiAgICAgIGxldCBoYXNMaXN0ZW5lciA9IHRoaXMuX3BhcnNlTGlzdGVuZXJzLmxlbmd0aCAhPT0gMDtcbiAgICAgIGlmICh0aGlzLl9idWlsZFBhcnNlVHJlZXMgfHwgaGFzTGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VyckhhbmRsZXIuaW5FcnJvclJlY292ZXJ5TW9kZSh0aGlzKSkge1xuICAgICAgICAgIGxldCBub2RlID0gdGhpcy5fY3R4LmFkZEVycm9yTm9kZSh0aGlzLmNyZWF0ZUVycm9yTm9kZSh0aGlzLl9jdHgsIG8pKTtcbiAgICAgICAgICBpZiAoaGFzTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3BhcnNlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgIGlmIChsaXN0ZW5lci52aXNpdEVycm9yTm9kZSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnZpc2l0RXJyb3JOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBub2RlID0gdGhpcy5jcmVhdGVUZXJtaW5hbE5vZGUodGhpcy5fY3R4LCBvKTtcbiAgICAgICAgICB0aGlzLl9jdHguYWRkQ2hpbGQobm9kZSk7XG4gICAgICAgICAgaWYgKGhhc0xpc3RlbmVyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9wYXJzZUxpc3RlbmVycykge1xuICAgICAgICAgICAgICBpZiAobGlzdGVuZXIudmlzaXRUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnZpc2l0VGVybWluYWwobm9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgICBjcmVhdGVUZXJtaW5hbE5vZGUocGFyZW50LCB0KSB7XG4gICAgICByZXR1cm4gbmV3IFRlcm1pbmFsTm9kZV8xLlRlcm1pbmFsTm9kZSh0KTtcbiAgICB9XG4gICAgY3JlYXRlRXJyb3JOb2RlKHBhcmVudCwgdCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvck5vZGVfMS5FcnJvck5vZGUodCk7XG4gICAgfVxuICAgIGFkZENvbnRleHRUb1BhcnNlVHJlZSgpIHtcbiAgICAgIGxldCBwYXJlbnQgPSB0aGlzLl9jdHguX3BhcmVudDtcbiAgICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnQuYWRkQ2hpbGQodGhpcy5fY3R4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZW50ZXJSdWxlKGxvY2FsY3R4LCBzdGF0ZSwgcnVsZUluZGV4KSB7XG4gICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICB0aGlzLl9jdHggPSBsb2NhbGN0eDtcbiAgICAgIHRoaXMuX2N0eC5fc3RhcnQgPSB0aGlzLl9pbnB1dC5MVCgxKTtcbiAgICAgIGlmICh0aGlzLl9idWlsZFBhcnNlVHJlZXMpIHtcbiAgICAgICAgdGhpcy5hZGRDb250ZXh0VG9QYXJzZVRyZWUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlckVudGVyUnVsZUV2ZW50KCk7XG4gICAgfVxuICAgIGVudGVyTGVmdEZhY3RvcmVkUnVsZShsb2NhbGN0eCwgc3RhdGUsIHJ1bGVJbmRleCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgaWYgKHRoaXMuX2J1aWxkUGFyc2VUcmVlcykge1xuICAgICAgICBsZXQgZmFjdG9yZWRDb250ZXh0ID0gdGhpcy5fY3R4LmdldENoaWxkKHRoaXMuX2N0eC5jaGlsZENvdW50IC0gMSk7XG4gICAgICAgIHRoaXMuX2N0eC5yZW1vdmVMYXN0Q2hpbGQoKTtcbiAgICAgICAgZmFjdG9yZWRDb250ZXh0Ll9wYXJlbnQgPSBsb2NhbGN0eDtcbiAgICAgICAgbG9jYWxjdHguYWRkQ2hpbGQoZmFjdG9yZWRDb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2N0eCA9IGxvY2FsY3R4O1xuICAgICAgdGhpcy5fY3R4Ll9zdGFydCA9IHRoaXMuX2lucHV0LkxUKDEpO1xuICAgICAgaWYgKHRoaXMuX2J1aWxkUGFyc2VUcmVlcykge1xuICAgICAgICB0aGlzLmFkZENvbnRleHRUb1BhcnNlVHJlZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyRW50ZXJSdWxlRXZlbnQoKTtcbiAgICB9XG4gICAgZXhpdFJ1bGUoKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaGVkRU9GKSB7XG4gICAgICAgIHRoaXMuX2N0eC5fc3RvcCA9IHRoaXMuX2lucHV0LkxUKDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY3R4Ll9zdG9wID0gdGhpcy5faW5wdXQudHJ5TFQoLTEpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyRXhpdFJ1bGVFdmVudCgpO1xuICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuX2N0eC5pbnZva2luZ1N0YXRlO1xuICAgICAgdGhpcy5fY3R4ID0gdGhpcy5fY3R4Ll9wYXJlbnQ7XG4gICAgfVxuICAgIGVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIGFsdE51bSkge1xuICAgICAgbG9jYWxjdHguYWx0TnVtYmVyID0gYWx0TnVtO1xuICAgICAgaWYgKHRoaXMuX2J1aWxkUGFyc2VUcmVlcyAmJiB0aGlzLl9jdHggIT09IGxvY2FsY3R4KSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLl9jdHguX3BhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgcGFyZW50LnJlbW92ZUxhc3RDaGlsZCgpO1xuICAgICAgICAgIHBhcmVudC5hZGRDaGlsZChsb2NhbGN0eCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2N0eCA9IGxvY2FsY3R4O1xuICAgIH1cbiAgICBnZXQgcHJlY2VkZW5jZSgpIHtcbiAgICAgIGlmICh0aGlzLl9wcmVjZWRlbmNlU3RhY2suaXNFbXB0eSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcHJlY2VkZW5jZVN0YWNrLnBlZWsoKTtcbiAgICB9XG4gICAgZW50ZXJSZWN1cnNpb25SdWxlKGxvY2FsY3R4LCBzdGF0ZSwgcnVsZUluZGV4LCBwcmVjZWRlbmNlKSB7XG4gICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICB0aGlzLl9wcmVjZWRlbmNlU3RhY2sucHVzaChwcmVjZWRlbmNlKTtcbiAgICAgIHRoaXMuX2N0eCA9IGxvY2FsY3R4O1xuICAgICAgdGhpcy5fY3R4Ll9zdGFydCA9IHRoaXMuX2lucHV0LkxUKDEpO1xuICAgICAgdGhpcy50cmlnZ2VyRW50ZXJSdWxlRXZlbnQoKTtcbiAgICB9XG4gICAgcHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIHN0YXRlLCBydWxlSW5kZXgpIHtcbiAgICAgIGxldCBwcmV2aW91cyA9IHRoaXMuX2N0eDtcbiAgICAgIHByZXZpb3VzLl9wYXJlbnQgPSBsb2NhbGN0eDtcbiAgICAgIHByZXZpb3VzLmludm9raW5nU3RhdGUgPSBzdGF0ZTtcbiAgICAgIHByZXZpb3VzLl9zdG9wID0gdGhpcy5faW5wdXQudHJ5TFQoLTEpO1xuICAgICAgdGhpcy5fY3R4ID0gbG9jYWxjdHg7XG4gICAgICB0aGlzLl9jdHguX3N0YXJ0ID0gcHJldmlvdXMuX3N0YXJ0O1xuICAgICAgaWYgKHRoaXMuX2J1aWxkUGFyc2VUcmVlcykge1xuICAgICAgICB0aGlzLl9jdHguYWRkQ2hpbGQocHJldmlvdXMpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyRW50ZXJSdWxlRXZlbnQoKTtcbiAgICB9XG4gICAgdW5yb2xsUmVjdXJzaW9uQ29udGV4dHMoX3BhcmVudGN0eCkge1xuICAgICAgdGhpcy5fcHJlY2VkZW5jZVN0YWNrLnBvcCgpO1xuICAgICAgdGhpcy5fY3R4Ll9zdG9wID0gdGhpcy5faW5wdXQudHJ5TFQoLTEpO1xuICAgICAgbGV0IHJldGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgIGlmICh0aGlzLl9wYXJzZUxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9jdHggIT09IF9wYXJlbnRjdHgpIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXJFeGl0UnVsZUV2ZW50KCk7XG4gICAgICAgICAgdGhpcy5fY3R4ID0gdGhpcy5fY3R4Ll9wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2N0eCA9IF9wYXJlbnRjdHg7XG4gICAgICB9XG4gICAgICByZXRjdHguX3BhcmVudCA9IF9wYXJlbnRjdHg7XG4gICAgICBpZiAodGhpcy5fYnVpbGRQYXJzZVRyZWVzICYmIF9wYXJlbnRjdHggIT0gbnVsbCkge1xuICAgICAgICBfcGFyZW50Y3R4LmFkZENoaWxkKHJldGN0eCk7XG4gICAgICB9XG4gICAgfVxuICAgIGdldEludm9raW5nQ29udGV4dChydWxlSW5kZXgpIHtcbiAgICAgIGxldCBwID0gdGhpcy5fY3R4O1xuICAgICAgd2hpbGUgKHAgJiYgcC5ydWxlSW5kZXggIT09IHJ1bGVJbmRleCkge1xuICAgICAgICBwID0gcC5fcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGdldCBjb250ZXh0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2N0eDtcbiAgICB9XG4gICAgc2V0IGNvbnRleHQoY3R4KSB7XG4gICAgICB0aGlzLl9jdHggPSBjdHg7XG4gICAgfVxuICAgIHByZWNwcmVkKGxvY2FsY3R4LCBwcmVjZWRlbmNlKSB7XG4gICAgICByZXR1cm4gcHJlY2VkZW5jZSA+PSB0aGlzLl9wcmVjZWRlbmNlU3RhY2sucGVlaygpO1xuICAgIH1cbiAgICBnZXRFcnJvckxpc3RlbmVyRGlzcGF0Y2goKSB7XG4gICAgICByZXR1cm4gbmV3IFByb3h5UGFyc2VyRXJyb3JMaXN0ZW5lcl8xLlByb3h5UGFyc2VyRXJyb3JMaXN0ZW5lcih0aGlzLmdldEVycm9yTGlzdGVuZXJzKCkpO1xuICAgIH1cbiAgICBpbkNvbnRleHQoY29udGV4dCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpc0V4cGVjdGVkVG9rZW4oc3ltYm9sKSB7XG4gICAgICBsZXQgYXRuID0gdGhpcy5pbnRlcnByZXRlci5hdG47XG4gICAgICBsZXQgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgbGV0IHMgPSBhdG4uc3RhdGVzW3RoaXMuc3RhdGVdO1xuICAgICAgbGV0IGZvbGxvd2luZyA9IGF0bi5uZXh0VG9rZW5zKHMpO1xuICAgICAgaWYgKGZvbGxvd2luZy5jb250YWlucyhzeW1ib2wpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFmb2xsb3dpbmcuY29udGFpbnMoVG9rZW5fMS5Ub2tlbi5FUFNJTE9OKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB3aGlsZSAoY3R4ICE9IG51bGwgJiYgY3R4Lmludm9raW5nU3RhdGUgPj0gMCAmJiBmb2xsb3dpbmcuY29udGFpbnMoVG9rZW5fMS5Ub2tlbi5FUFNJTE9OKSkge1xuICAgICAgICBsZXQgaW52b2tpbmdTdGF0ZSA9IGF0bi5zdGF0ZXNbY3R4Lmludm9raW5nU3RhdGVdO1xuICAgICAgICBsZXQgcnQgPSBpbnZva2luZ1N0YXRlLnRyYW5zaXRpb24oMCk7XG4gICAgICAgIGZvbGxvd2luZyA9IGF0bi5uZXh0VG9rZW5zKHJ0LmZvbGxvd1N0YXRlKTtcbiAgICAgICAgaWYgKGZvbGxvd2luZy5jb250YWlucyhzeW1ib2wpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY3R4ID0gY3R4Ll9wYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoZm9sbG93aW5nLmNvbnRhaW5zKFRva2VuXzEuVG9rZW4uRVBTSUxPTikgJiYgc3ltYm9sID09PSBUb2tlbl8xLlRva2VuLkVPRikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGlzTWF0Y2hlZEVPRigpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hdGNoZWRFT0Y7XG4gICAgfVxuICAgIGdldEV4cGVjdGVkVG9rZW5zKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXRuLmdldEV4cGVjdGVkVG9rZW5zKHRoaXMuc3RhdGUsIHRoaXMuY29udGV4dCk7XG4gICAgfVxuICAgIGdldEV4cGVjdGVkVG9rZW5zV2l0aGluQ3VycmVudFJ1bGUoKSB7XG4gICAgICBsZXQgYXRuID0gdGhpcy5pbnRlcnByZXRlci5hdG47XG4gICAgICBsZXQgcyA9IGF0bi5zdGF0ZXNbdGhpcy5zdGF0ZV07XG4gICAgICByZXR1cm4gYXRuLm5leHRUb2tlbnMocyk7XG4gICAgfVxuICAgIGdldFJ1bGVJbmRleChydWxlTmFtZSkge1xuICAgICAgbGV0IHJ1bGVJbmRleCA9IHRoaXMuZ2V0UnVsZUluZGV4TWFwKCkuZ2V0KHJ1bGVOYW1lKTtcbiAgICAgIGlmIChydWxlSW5kZXggIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcnVsZUluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBnZXQgcnVsZUNvbnRleHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3R4O1xuICAgIH1cbiAgICBnZXRSdWxlSW52b2NhdGlvblN0YWNrKGN0eCA9IHRoaXMuX2N0eCkge1xuICAgICAgbGV0IHAgPSBjdHg7XG4gICAgICBsZXQgcnVsZU5hbWVzID0gdGhpcy5ydWxlTmFtZXM7XG4gICAgICBsZXQgc3RhY2sgPSBbXTtcbiAgICAgIHdoaWxlIChwICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHJ1bGVJbmRleCA9IHAucnVsZUluZGV4O1xuICAgICAgICBpZiAocnVsZUluZGV4IDwgMCkge1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJuL2FcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhY2sucHVzaChydWxlTmFtZXNbcnVsZUluZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAuX3BhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9XG4gICAgZ2V0REZBU3RyaW5ncygpIHtcbiAgICAgIGxldCBzID0gW107XG4gICAgICBmb3IgKGxldCBkZmEgb2YgdGhpcy5faW50ZXJwLmF0bi5kZWNpc2lvblRvREZBKSB7XG4gICAgICAgIHMucHVzaChkZmEudG9TdHJpbmcodGhpcy52b2NhYnVsYXJ5LCB0aGlzLnJ1bGVOYW1lcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGR1bXBERkEoKSB7XG4gICAgICBsZXQgc2Vlbk9uZSA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgZGZhIG9mIHRoaXMuX2ludGVycC5hdG4uZGVjaXNpb25Ub0RGQSkge1xuICAgICAgICBpZiAoIWRmYS5pc0VtcHR5KSB7XG4gICAgICAgICAgaWYgKHNlZW5PbmUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiRGVjaXNpb24gXCIgKyBkZmEuZGVjaXNpb24gKyBcIjpcIik7XG4gICAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoZGZhLnRvU3RyaW5nKHRoaXMudm9jYWJ1bGFyeSwgdGhpcy5ydWxlTmFtZXMpKTtcbiAgICAgICAgICBzZWVuT25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBnZXQgc291cmNlTmFtZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbnB1dC5zb3VyY2VOYW1lO1xuICAgIH1cbiAgICBnZXQgcGFyc2VJbmZvKCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gcmVxdWlyZV9Qcm9maWxpbmdBVE5TaW11bGF0b3IoKSkudGhlbigobSkgPT4ge1xuICAgICAgICBsZXQgaW50ZXJwID0gdGhpcy5pbnRlcnByZXRlcjtcbiAgICAgICAgaWYgKGludGVycCBpbnN0YW5jZW9mIG0uUHJvZmlsaW5nQVROU2ltdWxhdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUluZm9fMS5QYXJzZUluZm8oaW50ZXJwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHNldFByb2ZpbGUocHJvZmlsZSkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbGV0IG0gPSB5aWVsZCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHJlcXVpcmVfUHJvZmlsaW5nQVROU2ltdWxhdG9yKCkpO1xuICAgICAgICBsZXQgaW50ZXJwID0gdGhpcy5pbnRlcnByZXRlcjtcbiAgICAgICAgaWYgKHByb2ZpbGUpIHtcbiAgICAgICAgICBpZiAoIShpbnRlcnAgaW5zdGFuY2VvZiBtLlByb2ZpbGluZ0FUTlNpbXVsYXRvcikpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJwcmV0ZXIgPSBuZXcgbS5Qcm9maWxpbmdBVE5TaW11bGF0b3IodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGludGVycCBpbnN0YW5jZW9mIG0uUHJvZmlsaW5nQVROU2ltdWxhdG9yKSB7XG4gICAgICAgICAgdGhpcy5pbnRlcnByZXRlciA9IG5ldyBQYXJzZXJBVE5TaW11bGF0b3JfMS5QYXJzZXJBVE5TaW11bGF0b3IodGhpcy5hdG4sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW50ZXJwcmV0ZXIuc2V0UHJlZGljdGlvbk1vZGUoaW50ZXJwLmdldFByZWRpY3Rpb25Nb2RlKCkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHNldCBpc1RyYWNlKHRyYWNlKSB7XG4gICAgICBpZiAoIXRyYWNlKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFjZXIpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZVBhcnNlTGlzdGVuZXIodGhpcy5fdHJhY2VyKTtcbiAgICAgICAgICB0aGlzLl90cmFjZXIgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFjZXIpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZVBhcnNlTGlzdGVuZXIodGhpcy5fdHJhY2VyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl90cmFjZXIgPSBuZXcgVHJhY2VMaXN0ZW5lcih0aGlzLnJ1bGVOYW1lcywgdGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkUGFyc2VMaXN0ZW5lcih0aGlzLl90cmFjZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNUcmFjZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFjZXIgIT0gbnVsbDtcbiAgICB9XG4gIH07XG4gIFBhcnNlcjIuYnlwYXNzQWx0c0F0bkNhY2hlID0gbmV3IE1hcCgpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBQYXJzZXIyLnByb3RvdHlwZSwgXCJfZXJySGFuZGxlclwiLCB2b2lkIDApO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBQYXJzZXIyLnByb3RvdHlwZSwgXCJtYXRjaFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgUGFyc2VyMi5wcm90b3R5cGUsIFwibWF0Y2hXaWxkY2FyZFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgUGFyc2VyMi5wcm90b3R5cGUsIFwiZ2V0UGFyc2VMaXN0ZW5lcnNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIFBhcnNlcjIucHJvdG90eXBlLCBcImFkZFBhcnNlTGlzdGVuZXJcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIFBhcnNlcjIucHJvdG90eXBlLCBcImdldEFUTldpdGhCeXBhc3NBbHRzXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbCxcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBQYXJzZXIyLnByb3RvdHlwZSwgXCJlcnJvckhhbmRsZXJcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBQYXJzZXIyLnByb3RvdHlwZSwgXCJpbnB1dFN0cmVhbVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGxcbiAgXSwgUGFyc2VyMi5wcm90b3R5cGUsIFwiY3VycmVudFRva2VuXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBQYXJzZXIyLnByb3RvdHlwZSwgXCJlbnRlclJ1bGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZSxcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5OdWxsYWJsZSlcbiAgXSwgUGFyc2VyMi5wcm90b3R5cGUsIFwicHJlY3ByZWRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBQYXJzZXIyLnByb3RvdHlwZSwgXCJnZXRFcnJvckxpc3RlbmVyRGlzcGF0Y2hcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIFBhcnNlcjIucHJvdG90eXBlLCBcImdldEV4cGVjdGVkVG9rZW5zXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbFxuICBdLCBQYXJzZXIyLnByb3RvdHlwZSwgXCJnZXRFeHBlY3RlZFRva2Vuc1dpdGhpbkN1cnJlbnRSdWxlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgUGFyc2VyMi5wcm90b3R5cGUsIFwicGFyc2VJbmZvXCIsIG51bGwpO1xuICBleHBvcnRzLlBhcnNlciA9IFBhcnNlcjI7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL05vVmlhYmxlQWx0RXhjZXB0aW9uLmpzXG52YXIgcmVxdWlyZV9Ob1ZpYWJsZUFsdEV4Y2VwdGlvbiA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbiA9IHZvaWQgMDtcbiAgdmFyIFBhcnNlcl8xID0gcmVxdWlyZV9QYXJzZXIoKTtcbiAgdmFyIFJlY29nbml0aW9uRXhjZXB0aW9uXzEgPSByZXF1aXJlX1JlY29nbml0aW9uRXhjZXB0aW9uKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIE5vVmlhYmxlQWx0RXhjZXB0aW9uMiA9IGNsYXNzIGV4dGVuZHMgUmVjb2duaXRpb25FeGNlcHRpb25fMS5SZWNvZ25pdGlvbkV4Y2VwdGlvbiB7XG4gICAgY29uc3RydWN0b3IocmVjb2duaXplciwgaW5wdXQsIHN0YXJ0VG9rZW4sIG9mZmVuZGluZ1Rva2VuLCBkZWFkRW5kQ29uZmlncywgY3R4KSB7XG4gICAgICBpZiAocmVjb2duaXplciBpbnN0YW5jZW9mIFBhcnNlcl8xLlBhcnNlcikge1xuICAgICAgICBpZiAoaW5wdXQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGlucHV0ID0gcmVjb2duaXplci5pbnB1dFN0cmVhbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRUb2tlbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgc3RhcnRUb2tlbiA9IHJlY29nbml6ZXIuY3VycmVudFRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZlbmRpbmdUb2tlbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgb2ZmZW5kaW5nVG9rZW4gPSByZWNvZ25pemVyLmN1cnJlbnRUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjdHggPSByZWNvZ25pemVyLmNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN1cGVyKHJlY29nbml6ZXIsIGlucHV0LCBjdHgpO1xuICAgICAgdGhpcy5fZGVhZEVuZENvbmZpZ3MgPSBkZWFkRW5kQ29uZmlncztcbiAgICAgIHRoaXMuX3N0YXJ0VG9rZW4gPSBzdGFydFRva2VuO1xuICAgICAgdGhpcy5zZXRPZmZlbmRpbmdUb2tlbihyZWNvZ25pemVyLCBvZmZlbmRpbmdUb2tlbik7XG4gICAgfVxuICAgIGdldCBzdGFydFRva2VuKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0VG9rZW47XG4gICAgfVxuICAgIGdldCBkZWFkRW5kQ29uZmlncygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWFkRW5kQ29uZmlncztcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIE5vVmlhYmxlQWx0RXhjZXB0aW9uMi5wcm90b3R5cGUsIFwiX3N0YXJ0VG9rZW5cIiwgdm9pZCAwKTtcbiAgZXhwb3J0cy5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbiA9IE5vVmlhYmxlQWx0RXhjZXB0aW9uMjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvRGVmYXVsdEVycm9yU3RyYXRlZ3kuanNcbnZhciByZXF1aXJlX0RlZmF1bHRFcnJvclN0cmF0ZWd5ID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkRlZmF1bHRFcnJvclN0cmF0ZWd5ID0gdm9pZCAwO1xuICB2YXIgQVROU3RhdGVfMSA9IHJlcXVpcmVfQVROU3RhdGUoKTtcbiAgdmFyIEFUTlN0YXRlVHlwZV8xID0gcmVxdWlyZV9BVE5TdGF0ZVR5cGUoKTtcbiAgdmFyIEZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbl8xID0gcmVxdWlyZV9GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24oKTtcbiAgdmFyIElucHV0TWlzbWF0Y2hFeGNlcHRpb25fMSA9IHJlcXVpcmVfSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbigpO1xuICB2YXIgSW50ZXJ2YWxTZXRfMSA9IHJlcXVpcmVfSW50ZXJ2YWxTZXQoKTtcbiAgdmFyIE5vVmlhYmxlQWx0RXhjZXB0aW9uXzEgPSByZXF1aXJlX05vVmlhYmxlQWx0RXhjZXB0aW9uKCk7XG4gIHZhciBQcmVkaWN0aW9uQ29udGV4dF8xID0gcmVxdWlyZV9QcmVkaWN0aW9uQ29udGV4dCgpO1xuICB2YXIgVG9rZW5fMSA9IHJlcXVpcmVfVG9rZW4oKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgRGVmYXVsdEVycm9yU3RyYXRlZ3kgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLmVycm9yUmVjb3ZlcnlNb2RlID0gZmFsc2U7XG4gICAgICB0aGlzLmxhc3RFcnJvckluZGV4ID0gLTE7XG4gICAgICB0aGlzLm5leHRUb2tlbnNTdGF0ZSA9IEFUTlN0YXRlXzEuQVROU3RhdGUuSU5WQUxJRF9TVEFURV9OVU1CRVI7XG4gICAgfVxuICAgIHJlc2V0KHJlY29nbml6ZXIpIHtcbiAgICAgIHRoaXMuZW5kRXJyb3JDb25kaXRpb24ocmVjb2duaXplcik7XG4gICAgfVxuICAgIGJlZ2luRXJyb3JDb25kaXRpb24ocmVjb2duaXplcikge1xuICAgICAgdGhpcy5lcnJvclJlY292ZXJ5TW9kZSA9IHRydWU7XG4gICAgfVxuICAgIGluRXJyb3JSZWNvdmVyeU1vZGUocmVjb2duaXplcikge1xuICAgICAgcmV0dXJuIHRoaXMuZXJyb3JSZWNvdmVyeU1vZGU7XG4gICAgfVxuICAgIGVuZEVycm9yQ29uZGl0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgIHRoaXMuZXJyb3JSZWNvdmVyeU1vZGUgPSBmYWxzZTtcbiAgICAgIHRoaXMubGFzdEVycm9yU3RhdGVzID0gdm9pZCAwO1xuICAgICAgdGhpcy5sYXN0RXJyb3JJbmRleCA9IC0xO1xuICAgIH1cbiAgICByZXBvcnRNYXRjaChyZWNvZ25pemVyKSB7XG4gICAgICB0aGlzLmVuZEVycm9yQ29uZGl0aW9uKHJlY29nbml6ZXIpO1xuICAgIH1cbiAgICByZXBvcnRFcnJvcihyZWNvZ25pemVyLCBlKSB7XG4gICAgICBpZiAodGhpcy5pbkVycm9yUmVjb3ZlcnlNb2RlKHJlY29nbml6ZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYmVnaW5FcnJvckNvbmRpdGlvbihyZWNvZ25pemVyKTtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgTm9WaWFibGVBbHRFeGNlcHRpb25fMS5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbikge1xuICAgICAgICB0aGlzLnJlcG9ydE5vVmlhYmxlQWx0ZXJuYXRpdmUocmVjb2duaXplciwgZSk7XG4gICAgICB9IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBJbnB1dE1pc21hdGNoRXhjZXB0aW9uXzEuSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbikge1xuICAgICAgICB0aGlzLnJlcG9ydElucHV0TWlzbWF0Y2gocmVjb2duaXplciwgZSk7XG4gICAgICB9IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb25fMS5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24pIHtcbiAgICAgICAgdGhpcy5yZXBvcnRGYWlsZWRQcmVkaWNhdGUocmVjb2duaXplciwgZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKGB1bmtub3duIHJlY29nbml0aW9uIGVycm9yIHR5cGU6ICR7ZX1gKTtcbiAgICAgICAgdGhpcy5ub3RpZnlFcnJvckxpc3RlbmVycyhyZWNvZ25pemVyLCBlLnRvU3RyaW5nKCksIGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBub3RpZnlFcnJvckxpc3RlbmVycyhyZWNvZ25pemVyLCBtZXNzYWdlLCBlKSB7XG4gICAgICBsZXQgb2ZmZW5kaW5nVG9rZW4gPSBlLmdldE9mZmVuZGluZ1Rva2VuKHJlY29nbml6ZXIpO1xuICAgICAgaWYgKG9mZmVuZGluZ1Rva2VuID09PSB2b2lkIDApIHtcbiAgICAgICAgb2ZmZW5kaW5nVG9rZW4gPSBudWxsO1xuICAgICAgfVxuICAgICAgcmVjb2duaXplci5ub3RpZnlFcnJvckxpc3RlbmVycyhtZXNzYWdlLCBvZmZlbmRpbmdUb2tlbiwgZSk7XG4gICAgfVxuICAgIHJlY292ZXIocmVjb2duaXplciwgZSkge1xuICAgICAgaWYgKHRoaXMubGFzdEVycm9ySW5kZXggPT09IHJlY29nbml6ZXIuaW5wdXRTdHJlYW0uaW5kZXggJiYgdGhpcy5sYXN0RXJyb3JTdGF0ZXMgJiYgdGhpcy5sYXN0RXJyb3JTdGF0ZXMuY29udGFpbnMocmVjb2duaXplci5zdGF0ZSkpIHtcbiAgICAgICAgcmVjb2duaXplci5jb25zdW1lKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RFcnJvckluZGV4ID0gcmVjb2duaXplci5pbnB1dFN0cmVhbS5pbmRleDtcbiAgICAgIGlmICghdGhpcy5sYXN0RXJyb3JTdGF0ZXMpIHtcbiAgICAgICAgdGhpcy5sYXN0RXJyb3JTdGF0ZXMgPSBuZXcgSW50ZXJ2YWxTZXRfMS5JbnRlcnZhbFNldCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5sYXN0RXJyb3JTdGF0ZXMuYWRkKHJlY29nbml6ZXIuc3RhdGUpO1xuICAgICAgbGV0IGZvbGxvd1NldCA9IHRoaXMuZ2V0RXJyb3JSZWNvdmVyeVNldChyZWNvZ25pemVyKTtcbiAgICAgIHRoaXMuY29uc3VtZVVudGlsKHJlY29nbml6ZXIsIGZvbGxvd1NldCk7XG4gICAgfVxuICAgIHN5bmMocmVjb2duaXplcikge1xuICAgICAgbGV0IHMgPSByZWNvZ25pemVyLmludGVycHJldGVyLmF0bi5zdGF0ZXNbcmVjb2duaXplci5zdGF0ZV07XG4gICAgICBpZiAodGhpcy5pbkVycm9yUmVjb3ZlcnlNb2RlKHJlY29nbml6ZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB0b2tlbnMyID0gcmVjb2duaXplci5pbnB1dFN0cmVhbTtcbiAgICAgIGxldCBsYSA9IHRva2VuczIuTEEoMSk7XG4gICAgICBsZXQgbmV4dFRva2VucyA9IHJlY29nbml6ZXIuYXRuLm5leHRUb2tlbnMocyk7XG4gICAgICBpZiAobmV4dFRva2Vucy5jb250YWlucyhsYSkpIHtcbiAgICAgICAgdGhpcy5uZXh0VG9rZW5zQ29udGV4dCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5uZXh0VG9rZW5zU3RhdGUgPSBBVE5TdGF0ZV8xLkFUTlN0YXRlLklOVkFMSURfU1RBVEVfTlVNQkVSO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobmV4dFRva2Vucy5jb250YWlucyhUb2tlbl8xLlRva2VuLkVQU0lMT04pKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHRUb2tlbnNDb250ZXh0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICB0aGlzLm5leHRUb2tlbnNDb250ZXh0ID0gcmVjb2duaXplci5jb250ZXh0O1xuICAgICAgICAgIHRoaXMubmV4dFRva2Vuc1N0YXRlID0gcmVjb2duaXplci5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHMuc3RhdGVUeXBlKSB7XG4gICAgICAgIGNhc2UgQVROU3RhdGVUeXBlXzEuQVROU3RhdGVUeXBlLkJMT0NLX1NUQVJUOlxuICAgICAgICBjYXNlIEFUTlN0YXRlVHlwZV8xLkFUTlN0YXRlVHlwZS5TVEFSX0JMT0NLX1NUQVJUOlxuICAgICAgICBjYXNlIEFUTlN0YXRlVHlwZV8xLkFUTlN0YXRlVHlwZS5QTFVTX0JMT0NLX1NUQVJUOlxuICAgICAgICBjYXNlIEFUTlN0YXRlVHlwZV8xLkFUTlN0YXRlVHlwZS5TVEFSX0xPT1BfRU5UUlk6XG4gICAgICAgICAgaWYgKHRoaXMuc2luZ2xlVG9rZW5EZWxldGlvbihyZWNvZ25pemVyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbl8xLklucHV0TWlzbWF0Y2hFeGNlcHRpb24ocmVjb2duaXplcik7XG4gICAgICAgIGNhc2UgQVROU3RhdGVUeXBlXzEuQVROU3RhdGVUeXBlLlBMVVNfTE9PUF9CQUNLOlxuICAgICAgICBjYXNlIEFUTlN0YXRlVHlwZV8xLkFUTlN0YXRlVHlwZS5TVEFSX0xPT1BfQkFDSzpcbiAgICAgICAgICB0aGlzLnJlcG9ydFVud2FudGVkVG9rZW4ocmVjb2duaXplcik7XG4gICAgICAgICAgbGV0IGV4cGVjdGluZyA9IHJlY29nbml6ZXIuZ2V0RXhwZWN0ZWRUb2tlbnMoKTtcbiAgICAgICAgICBsZXQgd2hhdEZvbGxvd3NMb29wSXRlcmF0aW9uT3JSdWxlID0gZXhwZWN0aW5nLm9yKHRoaXMuZ2V0RXJyb3JSZWNvdmVyeVNldChyZWNvZ25pemVyKSk7XG4gICAgICAgICAgdGhpcy5jb25zdW1lVW50aWwocmVjb2duaXplciwgd2hhdEZvbGxvd3NMb29wSXRlcmF0aW9uT3JSdWxlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmVwb3J0Tm9WaWFibGVBbHRlcm5hdGl2ZShyZWNvZ25pemVyLCBlKSB7XG4gICAgICBsZXQgdG9rZW5zMiA9IHJlY29nbml6ZXIuaW5wdXRTdHJlYW07XG4gICAgICBsZXQgaW5wdXQ7XG4gICAgICBpZiAodG9rZW5zMikge1xuICAgICAgICBpZiAoZS5zdGFydFRva2VuLnR5cGUgPT09IFRva2VuXzEuVG9rZW4uRU9GKSB7XG4gICAgICAgICAgaW5wdXQgPSBcIjxFT0Y+XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5wdXQgPSB0b2tlbnMyLmdldFRleHRGcm9tUmFuZ2UoZS5zdGFydFRva2VuLCBlLmdldE9mZmVuZGluZ1Rva2VuKCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dCA9IFwiPHVua25vd24gaW5wdXQ+XCI7XG4gICAgICB9XG4gICAgICBsZXQgbXNnID0gXCJubyB2aWFibGUgYWx0ZXJuYXRpdmUgYXQgaW5wdXQgXCIgKyB0aGlzLmVzY2FwZVdTQW5kUXVvdGUoaW5wdXQpO1xuICAgICAgdGhpcy5ub3RpZnlFcnJvckxpc3RlbmVycyhyZWNvZ25pemVyLCBtc2csIGUpO1xuICAgIH1cbiAgICByZXBvcnRJbnB1dE1pc21hdGNoKHJlY29nbml6ZXIsIGUpIHtcbiAgICAgIGxldCBleHBlY3RlZCA9IGUuZXhwZWN0ZWRUb2tlbnM7XG4gICAgICBsZXQgZXhwZWN0ZWRTdHJpbmcgPSBleHBlY3RlZCA/IGV4cGVjdGVkLnRvU3RyaW5nVm9jYWJ1bGFyeShyZWNvZ25pemVyLnZvY2FidWxhcnkpIDogXCJcIjtcbiAgICAgIGxldCBtc2cgPSBcIm1pc21hdGNoZWQgaW5wdXQgXCIgKyB0aGlzLmdldFRva2VuRXJyb3JEaXNwbGF5KGUuZ2V0T2ZmZW5kaW5nVG9rZW4ocmVjb2duaXplcikpICsgXCIgZXhwZWN0aW5nIFwiICsgZXhwZWN0ZWRTdHJpbmc7XG4gICAgICB0aGlzLm5vdGlmeUVycm9yTGlzdGVuZXJzKHJlY29nbml6ZXIsIG1zZywgZSk7XG4gICAgfVxuICAgIHJlcG9ydEZhaWxlZFByZWRpY2F0ZShyZWNvZ25pemVyLCBlKSB7XG4gICAgICBsZXQgcnVsZU5hbWUgPSByZWNvZ25pemVyLnJ1bGVOYW1lc1tyZWNvZ25pemVyLmNvbnRleHQucnVsZUluZGV4XTtcbiAgICAgIGxldCBtc2cgPSBcInJ1bGUgXCIgKyBydWxlTmFtZSArIFwiIFwiICsgZS5tZXNzYWdlO1xuICAgICAgdGhpcy5ub3RpZnlFcnJvckxpc3RlbmVycyhyZWNvZ25pemVyLCBtc2csIGUpO1xuICAgIH1cbiAgICByZXBvcnRVbndhbnRlZFRva2VuKHJlY29nbml6ZXIpIHtcbiAgICAgIGlmICh0aGlzLmluRXJyb3JSZWNvdmVyeU1vZGUocmVjb2duaXplcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5iZWdpbkVycm9yQ29uZGl0aW9uKHJlY29nbml6ZXIpO1xuICAgICAgbGV0IHQgPSByZWNvZ25pemVyLmN1cnJlbnRUb2tlbjtcbiAgICAgIGxldCB0b2tlbk5hbWUgPSB0aGlzLmdldFRva2VuRXJyb3JEaXNwbGF5KHQpO1xuICAgICAgbGV0IGV4cGVjdGluZyA9IHRoaXMuZ2V0RXhwZWN0ZWRUb2tlbnMocmVjb2duaXplcik7XG4gICAgICBsZXQgbXNnID0gXCJleHRyYW5lb3VzIGlucHV0IFwiICsgdG9rZW5OYW1lICsgXCIgZXhwZWN0aW5nIFwiICsgZXhwZWN0aW5nLnRvU3RyaW5nVm9jYWJ1bGFyeShyZWNvZ25pemVyLnZvY2FidWxhcnkpO1xuICAgICAgcmVjb2duaXplci5ub3RpZnlFcnJvckxpc3RlbmVycyhtc2csIHQsIHZvaWQgMCk7XG4gICAgfVxuICAgIHJlcG9ydE1pc3NpbmdUb2tlbihyZWNvZ25pemVyKSB7XG4gICAgICBpZiAodGhpcy5pbkVycm9yUmVjb3ZlcnlNb2RlKHJlY29nbml6ZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYmVnaW5FcnJvckNvbmRpdGlvbihyZWNvZ25pemVyKTtcbiAgICAgIGxldCB0ID0gcmVjb2duaXplci5jdXJyZW50VG9rZW47XG4gICAgICBsZXQgZXhwZWN0aW5nID0gdGhpcy5nZXRFeHBlY3RlZFRva2VucyhyZWNvZ25pemVyKTtcbiAgICAgIGxldCBtc2cgPSBcIm1pc3NpbmcgXCIgKyBleHBlY3RpbmcudG9TdHJpbmdWb2NhYnVsYXJ5KHJlY29nbml6ZXIudm9jYWJ1bGFyeSkgKyBcIiBhdCBcIiArIHRoaXMuZ2V0VG9rZW5FcnJvckRpc3BsYXkodCk7XG4gICAgICByZWNvZ25pemVyLm5vdGlmeUVycm9yTGlzdGVuZXJzKG1zZywgdCwgdm9pZCAwKTtcbiAgICB9XG4gICAgcmVjb3ZlcklubGluZShyZWNvZ25pemVyKSB7XG4gICAgICBsZXQgbWF0Y2hlZFN5bWJvbCA9IHRoaXMuc2luZ2xlVG9rZW5EZWxldGlvbihyZWNvZ25pemVyKTtcbiAgICAgIGlmIChtYXRjaGVkU3ltYm9sKSB7XG4gICAgICAgIHJlY29nbml6ZXIuY29uc3VtZSgpO1xuICAgICAgICByZXR1cm4gbWF0Y2hlZFN5bWJvbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNpbmdsZVRva2VuSW5zZXJ0aW9uKHJlY29nbml6ZXIpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1pc3NpbmdTeW1ib2wocmVjb2duaXplcik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZXh0VG9rZW5zQ29udGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnB1dE1pc21hdGNoRXhjZXB0aW9uXzEuSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbihyZWNvZ25pemVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBJbnB1dE1pc21hdGNoRXhjZXB0aW9uXzEuSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbihyZWNvZ25pemVyLCB0aGlzLm5leHRUb2tlbnNTdGF0ZSwgdGhpcy5uZXh0VG9rZW5zQ29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHNpbmdsZVRva2VuSW5zZXJ0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgIGxldCBjdXJyZW50U3ltYm9sVHlwZSA9IHJlY29nbml6ZXIuaW5wdXRTdHJlYW0uTEEoMSk7XG4gICAgICBsZXQgY3VycmVudFN0YXRlID0gcmVjb2duaXplci5pbnRlcnByZXRlci5hdG4uc3RhdGVzW3JlY29nbml6ZXIuc3RhdGVdO1xuICAgICAgbGV0IG5leHQgPSBjdXJyZW50U3RhdGUudHJhbnNpdGlvbigwKS50YXJnZXQ7XG4gICAgICBsZXQgYXRuID0gcmVjb2duaXplci5pbnRlcnByZXRlci5hdG47XG4gICAgICBsZXQgZXhwZWN0aW5nQXRMTDIgPSBhdG4ubmV4dFRva2VucyhuZXh0LCBQcmVkaWN0aW9uQ29udGV4dF8xLlByZWRpY3Rpb25Db250ZXh0LmZyb21SdWxlQ29udGV4dChhdG4sIHJlY29nbml6ZXIuY29udGV4dCkpO1xuICAgICAgaWYgKGV4cGVjdGluZ0F0TEwyLmNvbnRhaW5zKGN1cnJlbnRTeW1ib2xUeXBlKSkge1xuICAgICAgICB0aGlzLnJlcG9ydE1pc3NpbmdUb2tlbihyZWNvZ25pemVyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNpbmdsZVRva2VuRGVsZXRpb24ocmVjb2duaXplcikge1xuICAgICAgbGV0IG5leHRUb2tlblR5cGUgPSByZWNvZ25pemVyLmlucHV0U3RyZWFtLkxBKDIpO1xuICAgICAgbGV0IGV4cGVjdGluZyA9IHRoaXMuZ2V0RXhwZWN0ZWRUb2tlbnMocmVjb2duaXplcik7XG4gICAgICBpZiAoZXhwZWN0aW5nLmNvbnRhaW5zKG5leHRUb2tlblR5cGUpKSB7XG4gICAgICAgIHRoaXMucmVwb3J0VW53YW50ZWRUb2tlbihyZWNvZ25pemVyKTtcbiAgICAgICAgcmVjb2duaXplci5jb25zdW1lKCk7XG4gICAgICAgIGxldCBtYXRjaGVkU3ltYm9sID0gcmVjb2duaXplci5jdXJyZW50VG9rZW47XG4gICAgICAgIHRoaXMucmVwb3J0TWF0Y2gocmVjb2duaXplcik7XG4gICAgICAgIHJldHVybiBtYXRjaGVkU3ltYm9sO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgZ2V0TWlzc2luZ1N5bWJvbChyZWNvZ25pemVyKSB7XG4gICAgICBsZXQgY3VycmVudFN5bWJvbCA9IHJlY29nbml6ZXIuY3VycmVudFRva2VuO1xuICAgICAgbGV0IGV4cGVjdGluZyA9IHRoaXMuZ2V0RXhwZWN0ZWRUb2tlbnMocmVjb2duaXplcik7XG4gICAgICBsZXQgZXhwZWN0ZWRUb2tlblR5cGUgPSBUb2tlbl8xLlRva2VuLklOVkFMSURfVFlQRTtcbiAgICAgIGlmICghZXhwZWN0aW5nLmlzTmlsKSB7XG4gICAgICAgIGV4cGVjdGVkVG9rZW5UeXBlID0gZXhwZWN0aW5nLm1pbkVsZW1lbnQ7XG4gICAgICB9XG4gICAgICBsZXQgdG9rZW5UZXh0O1xuICAgICAgaWYgKGV4cGVjdGVkVG9rZW5UeXBlID09PSBUb2tlbl8xLlRva2VuLkVPRikge1xuICAgICAgICB0b2tlblRleHQgPSBcIjxtaXNzaW5nIEVPRj5cIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2VuVGV4dCA9IFwiPG1pc3NpbmcgXCIgKyByZWNvZ25pemVyLnZvY2FidWxhcnkuZ2V0RGlzcGxheU5hbWUoZXhwZWN0ZWRUb2tlblR5cGUpICsgXCI+XCI7XG4gICAgICB9XG4gICAgICBsZXQgY3VycmVudCA9IGN1cnJlbnRTeW1ib2w7XG4gICAgICBsZXQgbG9va2JhY2sgPSByZWNvZ25pemVyLmlucHV0U3RyZWFtLnRyeUxUKC0xKTtcbiAgICAgIGlmIChjdXJyZW50LnR5cGUgPT09IFRva2VuXzEuVG9rZW4uRU9GICYmIGxvb2tiYWNrICE9IG51bGwpIHtcbiAgICAgICAgY3VycmVudCA9IGxvb2tiYWNrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0VG9rZW4ocmVjb2duaXplci5pbnB1dFN0cmVhbS50b2tlblNvdXJjZSwgZXhwZWN0ZWRUb2tlblR5cGUsIHRva2VuVGV4dCwgY3VycmVudCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdFRva2VuKHRva2VuU291cmNlLCBleHBlY3RlZFRva2VuVHlwZSwgdG9rZW5UZXh0LCBjdXJyZW50KSB7XG4gICAgICBsZXQgZmFjdG9yeSA9IHRva2VuU291cmNlLnRva2VuRmFjdG9yeTtcbiAgICAgIGxldCB4ID0gY3VycmVudC50b2tlblNvdXJjZTtcbiAgICAgIGxldCBzdHJlYW0gPSB4ID8geC5pbnB1dFN0cmVhbSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZSh7c291cmNlOiB0b2tlblNvdXJjZSwgc3RyZWFtfSwgZXhwZWN0ZWRUb2tlblR5cGUsIHRva2VuVGV4dCwgVG9rZW5fMS5Ub2tlbi5ERUZBVUxUX0NIQU5ORUwsIC0xLCAtMSwgY3VycmVudC5saW5lLCBjdXJyZW50LmNoYXJQb3NpdGlvbkluTGluZSk7XG4gICAgfVxuICAgIGdldEV4cGVjdGVkVG9rZW5zKHJlY29nbml6ZXIpIHtcbiAgICAgIHJldHVybiByZWNvZ25pemVyLmdldEV4cGVjdGVkVG9rZW5zKCk7XG4gICAgfVxuICAgIGdldFRva2VuRXJyb3JEaXNwbGF5KHQpIHtcbiAgICAgIGlmICghdCkge1xuICAgICAgICByZXR1cm4gXCI8bm8gdG9rZW4+XCI7XG4gICAgICB9XG4gICAgICBsZXQgcyA9IHRoaXMuZ2V0U3ltYm9sVGV4dCh0KTtcbiAgICAgIGlmICghcykge1xuICAgICAgICBpZiAodGhpcy5nZXRTeW1ib2xUeXBlKHQpID09PSBUb2tlbl8xLlRva2VuLkVPRikge1xuICAgICAgICAgIHMgPSBcIjxFT0Y+XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcyA9IGA8JHt0aGlzLmdldFN5bWJvbFR5cGUodCl9PmA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVzY2FwZVdTQW5kUXVvdGUocyk7XG4gICAgfVxuICAgIGdldFN5bWJvbFRleHQoc3ltYm9sKSB7XG4gICAgICByZXR1cm4gc3ltYm9sLnRleHQ7XG4gICAgfVxuICAgIGdldFN5bWJvbFR5cGUoc3ltYm9sKSB7XG4gICAgICByZXR1cm4gc3ltYm9sLnR5cGU7XG4gICAgfVxuICAgIGVzY2FwZVdTQW5kUXVvdGUocykge1xuICAgICAgcyA9IHMucmVwbGFjZShcIlxcblwiLCBcIlxcXFxuXCIpO1xuICAgICAgcyA9IHMucmVwbGFjZShcIlxcclwiLCBcIlxcXFxyXCIpO1xuICAgICAgcyA9IHMucmVwbGFjZShcIlx0XCIsIFwiXFxcXHRcIik7XG4gICAgICByZXR1cm4gXCInXCIgKyBzICsgXCInXCI7XG4gICAgfVxuICAgIGdldEVycm9yUmVjb3ZlcnlTZXQocmVjb2duaXplcikge1xuICAgICAgbGV0IGF0biA9IHJlY29nbml6ZXIuaW50ZXJwcmV0ZXIuYXRuO1xuICAgICAgbGV0IGN0eCA9IHJlY29nbml6ZXIuY29udGV4dDtcbiAgICAgIGxldCByZWNvdmVyU2V0ID0gbmV3IEludGVydmFsU2V0XzEuSW50ZXJ2YWxTZXQoKTtcbiAgICAgIHdoaWxlIChjdHggJiYgY3R4Lmludm9raW5nU3RhdGUgPj0gMCkge1xuICAgICAgICBsZXQgaW52b2tpbmdTdGF0ZSA9IGF0bi5zdGF0ZXNbY3R4Lmludm9raW5nU3RhdGVdO1xuICAgICAgICBsZXQgcnQgPSBpbnZva2luZ1N0YXRlLnRyYW5zaXRpb24oMCk7XG4gICAgICAgIGxldCBmb2xsb3cgPSBhdG4ubmV4dFRva2VucyhydC5mb2xsb3dTdGF0ZSk7XG4gICAgICAgIHJlY292ZXJTZXQuYWRkQWxsKGZvbGxvdyk7XG4gICAgICAgIGN0eCA9IGN0eC5fcGFyZW50O1xuICAgICAgfVxuICAgICAgcmVjb3ZlclNldC5yZW1vdmUoVG9rZW5fMS5Ub2tlbi5FUFNJTE9OKTtcbiAgICAgIHJldHVybiByZWNvdmVyU2V0O1xuICAgIH1cbiAgICBjb25zdW1lVW50aWwocmVjb2duaXplciwgc2V0KSB7XG4gICAgICBsZXQgdHR5cGUgPSByZWNvZ25pemVyLmlucHV0U3RyZWFtLkxBKDEpO1xuICAgICAgd2hpbGUgKHR0eXBlICE9PSBUb2tlbl8xLlRva2VuLkVPRiAmJiAhc2V0LmNvbnRhaW5zKHR0eXBlKSkge1xuICAgICAgICByZWNvZ25pemVyLmNvbnN1bWUoKTtcbiAgICAgICAgdHR5cGUgPSByZWNvZ25pemVyLmlucHV0U3RyZWFtLkxBKDEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIERlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZSwgXCJyZXNldFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLCBcImJlZ2luRXJyb3JDb25kaXRpb25cIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBEZWZhdWx0RXJyb3JTdHJhdGVneS5wcm90b3R5cGUsIFwiaW5FcnJvclJlY292ZXJ5TW9kZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLCBcImVuZEVycm9yQ29uZGl0aW9uXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLCBcInJlcG9ydE1hdGNoXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLCBcInJlcG9ydEVycm9yXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBEZWZhdWx0RXJyb3JTdHJhdGVneS5wcm90b3R5cGUsIFwibm90aWZ5RXJyb3JMaXN0ZW5lcnNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBEZWZhdWx0RXJyb3JTdHJhdGVneS5wcm90b3R5cGUsIFwicmVjb3ZlclwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIERlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZSwgXCJzeW5jXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDEsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBEZWZhdWx0RXJyb3JTdHJhdGVneS5wcm90b3R5cGUsIFwicmVwb3J0Tm9WaWFibGVBbHRlcm5hdGl2ZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLCBcInJlcG9ydElucHV0TWlzbWF0Y2hcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMSwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIERlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZSwgXCJyZXBvcnRGYWlsZWRQcmVkaWNhdGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIERlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZSwgXCJyZXBvcnRVbndhbnRlZFRva2VuXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBEZWZhdWx0RXJyb3JTdHJhdGVneS5wcm90b3R5cGUsIFwicmVwb3J0TWlzc2luZ1Rva2VuXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLCBcInJlY292ZXJJbmxpbmVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIERlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZSwgXCJzaW5nbGVUb2tlbkluc2VydGlvblwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLCBcInNpbmdsZVRva2VuRGVsZXRpb25cIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsLFxuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIERlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZSwgXCJnZXRNaXNzaW5nU3ltYm9sXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuTm90TnVsbCxcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBEZWZhdWx0RXJyb3JTdHJhdGVneS5wcm90b3R5cGUsIFwiZ2V0RXhwZWN0ZWRUb2tlbnNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIERlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZSwgXCJnZXRTeW1ib2xUZXh0XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBEZWZhdWx0RXJyb3JTdHJhdGVneS5wcm90b3R5cGUsIFwiZ2V0U3ltYm9sVHlwZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGwsXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLCBcImVzY2FwZVdTQW5kUXVvdGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsLFxuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIERlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZSwgXCJnZXRFcnJvclJlY292ZXJ5U2V0XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDEsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBEZWZhdWx0RXJyb3JTdHJhdGVneS5wcm90b3R5cGUsIFwiY29uc3VtZVVudGlsXCIsIG51bGwpO1xuICBleHBvcnRzLkRlZmF1bHRFcnJvclN0cmF0ZWd5ID0gRGVmYXVsdEVycm9yU3RyYXRlZ3k7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL0JhaWxFcnJvclN0cmF0ZWd5LmpzXG52YXIgcmVxdWlyZV9CYWlsRXJyb3JTdHJhdGVneSA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5CYWlsRXJyb3JTdHJhdGVneSA9IHZvaWQgMDtcbiAgdmFyIERlZmF1bHRFcnJvclN0cmF0ZWd5XzEgPSByZXF1aXJlX0RlZmF1bHRFcnJvclN0cmF0ZWd5KCk7XG4gIHZhciBJbnB1dE1pc21hdGNoRXhjZXB0aW9uXzEgPSByZXF1aXJlX0lucHV0TWlzbWF0Y2hFeGNlcHRpb24oKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb25fMSA9IHJlcXVpcmVfUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb24oKTtcbiAgdmFyIEJhaWxFcnJvclN0cmF0ZWd5ID0gY2xhc3MgZXh0ZW5kcyBEZWZhdWx0RXJyb3JTdHJhdGVneV8xLkRlZmF1bHRFcnJvclN0cmF0ZWd5IHtcbiAgICByZWNvdmVyKHJlY29nbml6ZXIsIGUpIHtcbiAgICAgIGZvciAobGV0IGNvbnRleHQgPSByZWNvZ25pemVyLmNvbnRleHQ7IGNvbnRleHQ7IGNvbnRleHQgPSBjb250ZXh0LnBhcmVudCkge1xuICAgICAgICBjb250ZXh0LmV4Y2VwdGlvbiA9IGU7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb25fMS5QYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbihlKTtcbiAgICB9XG4gICAgcmVjb3ZlcklubGluZShyZWNvZ25pemVyKSB7XG4gICAgICBsZXQgZSA9IG5ldyBJbnB1dE1pc21hdGNoRXhjZXB0aW9uXzEuSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbihyZWNvZ25pemVyKTtcbiAgICAgIGZvciAobGV0IGNvbnRleHQgPSByZWNvZ25pemVyLmNvbnRleHQ7IGNvbnRleHQ7IGNvbnRleHQgPSBjb250ZXh0LnBhcmVudCkge1xuICAgICAgICBjb250ZXh0LmV4Y2VwdGlvbiA9IGU7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb25fMS5QYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbihlKTtcbiAgICB9XG4gICAgc3luYyhyZWNvZ25pemVyKSB7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgQmFpbEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLCBcInJlY292ZXJcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBCYWlsRXJyb3JTdHJhdGVneS5wcm90b3R5cGUsIFwicmVjb3ZlcklubGluZVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIEJhaWxFcnJvclN0cmF0ZWd5LnByb3RvdHlwZSwgXCJzeW5jXCIsIG51bGwpO1xuICBleHBvcnRzLkJhaWxFcnJvclN0cmF0ZWd5ID0gQmFpbEVycm9yU3RyYXRlZ3k7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL0NoYXJTdHJlYW0uanNcbnZhciByZXF1aXJlX0NoYXJTdHJlYW0gPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9EZXBlbmRlbnRzLmpzXG52YXIgcmVxdWlyZV9EZXBlbmRlbnRzID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5EZXBlbmRlbnRzID0gdm9pZCAwO1xuICB2YXIgRGVwZW5kZW50cztcbiAgKGZ1bmN0aW9uKERlcGVuZGVudHMyKSB7XG4gICAgRGVwZW5kZW50czJbRGVwZW5kZW50czJbXCJTRUxGXCJdID0gMF0gPSBcIlNFTEZcIjtcbiAgICBEZXBlbmRlbnRzMltEZXBlbmRlbnRzMltcIlBBUkVOVFNcIl0gPSAxXSA9IFwiUEFSRU5UU1wiO1xuICAgIERlcGVuZGVudHMyW0RlcGVuZGVudHMyW1wiQ0hJTERSRU5cIl0gPSAyXSA9IFwiQ0hJTERSRU5cIjtcbiAgICBEZXBlbmRlbnRzMltEZXBlbmRlbnRzMltcIkFOQ0VTVE9SU1wiXSA9IDNdID0gXCJBTkNFU1RPUlNcIjtcbiAgICBEZXBlbmRlbnRzMltEZXBlbmRlbnRzMltcIkRFU0NFTkRBTlRTXCJdID0gNF0gPSBcIkRFU0NFTkRBTlRTXCI7XG4gICAgRGVwZW5kZW50czJbRGVwZW5kZW50czJbXCJTSUJMSU5HU1wiXSA9IDVdID0gXCJTSUJMSU5HU1wiO1xuICAgIERlcGVuZGVudHMyW0RlcGVuZGVudHMyW1wiUFJFQ0VFRElOR19TSUJMSU5HU1wiXSA9IDZdID0gXCJQUkVDRUVESU5HX1NJQkxJTkdTXCI7XG4gICAgRGVwZW5kZW50czJbRGVwZW5kZW50czJbXCJGT0xMT1dJTkdfU0lCTElOR1NcIl0gPSA3XSA9IFwiRk9MTE9XSU5HX1NJQkxJTkdTXCI7XG4gICAgRGVwZW5kZW50czJbRGVwZW5kZW50czJbXCJQUkVDRUVESU5HXCJdID0gOF0gPSBcIlBSRUNFRURJTkdcIjtcbiAgICBEZXBlbmRlbnRzMltEZXBlbmRlbnRzMltcIkZPTExPV0lOR1wiXSA9IDldID0gXCJGT0xMT1dJTkdcIjtcbiAgfSkoRGVwZW5kZW50cyA9IGV4cG9ydHMuRGVwZW5kZW50cyB8fCAoZXhwb3J0cy5EZXBlbmRlbnRzID0ge30pKTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvRGlhZ25vc3RpY0Vycm9yTGlzdGVuZXIuanNcbnZhciByZXF1aXJlX0RpYWdub3N0aWNFcnJvckxpc3RlbmVyID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkRpYWdub3N0aWNFcnJvckxpc3RlbmVyID0gdm9pZCAwO1xuICB2YXIgQml0U2V0XzEgPSByZXF1aXJlX0JpdFNldCgpO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBJbnRlcnZhbF8xID0gcmVxdWlyZV9JbnRlcnZhbCgpO1xuICB2YXIgRGlhZ25vc3RpY0Vycm9yTGlzdGVuZXIgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoZXhhY3RPbmx5ID0gdHJ1ZSkge1xuICAgICAgdGhpcy5leGFjdE9ubHkgPSBleGFjdE9ubHk7XG4gICAgICB0aGlzLmV4YWN0T25seSA9IGV4YWN0T25seTtcbiAgICB9XG4gICAgc3ludGF4RXJyb3IocmVjb2duaXplciwgb2ZmZW5kaW5nU3ltYm9sLCBsaW5lLCBjaGFyUG9zaXRpb25JbkxpbmUsIG1zZywgZSkge1xuICAgIH1cbiAgICByZXBvcnRBbWJpZ3VpdHkocmVjb2duaXplciwgZGZhLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIGV4YWN0LCBhbWJpZ0FsdHMsIGNvbmZpZ3MpIHtcbiAgICAgIGlmICh0aGlzLmV4YWN0T25seSAmJiAhZXhhY3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGRlY2lzaW9uID0gdGhpcy5nZXREZWNpc2lvbkRlc2NyaXB0aW9uKHJlY29nbml6ZXIsIGRmYSk7XG4gICAgICBsZXQgY29uZmxpY3RpbmdBbHRzID0gdGhpcy5nZXRDb25mbGljdGluZ0FsdHMoYW1iaWdBbHRzLCBjb25maWdzKTtcbiAgICAgIGxldCB0ZXh0ID0gcmVjb2duaXplci5pbnB1dFN0cmVhbS5nZXRUZXh0KEludGVydmFsXzEuSW50ZXJ2YWwub2Yoc3RhcnRJbmRleCwgc3RvcEluZGV4KSk7XG4gICAgICBsZXQgbWVzc2FnZSA9IGByZXBvcnRBbWJpZ3VpdHkgZD0ke2RlY2lzaW9ufTogYW1iaWdBbHRzPSR7Y29uZmxpY3RpbmdBbHRzfSwgaW5wdXQ9JyR7dGV4dH0nYDtcbiAgICAgIHJlY29nbml6ZXIubm90aWZ5RXJyb3JMaXN0ZW5lcnMobWVzc2FnZSk7XG4gICAgfVxuICAgIHJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dChyZWNvZ25pemVyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgY29uZmxpY3RpbmdBbHRzLCBjb25mbGljdFN0YXRlKSB7XG4gICAgICBsZXQgZm9ybWF0ID0gXCJyZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHQgZD0lcywgaW5wdXQ9JyVzJ1wiO1xuICAgICAgbGV0IGRlY2lzaW9uID0gdGhpcy5nZXREZWNpc2lvbkRlc2NyaXB0aW9uKHJlY29nbml6ZXIsIGRmYSk7XG4gICAgICBsZXQgdGV4dCA9IHJlY29nbml6ZXIuaW5wdXRTdHJlYW0uZ2V0VGV4dChJbnRlcnZhbF8xLkludGVydmFsLm9mKHN0YXJ0SW5kZXgsIHN0b3BJbmRleCkpO1xuICAgICAgbGV0IG1lc3NhZ2UgPSBgcmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0IGQ9JHtkZWNpc2lvbn0sIGlucHV0PScke3RleHR9J2A7XG4gICAgICByZWNvZ25pemVyLm5vdGlmeUVycm9yTGlzdGVuZXJzKG1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHkocmVjb2duaXplciwgZGZhLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIHByZWRpY3Rpb24sIGFjY2VwdFN0YXRlKSB7XG4gICAgICBsZXQgZm9ybWF0ID0gXCJyZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHkgZD0lcywgaW5wdXQ9JyVzJ1wiO1xuICAgICAgbGV0IGRlY2lzaW9uID0gdGhpcy5nZXREZWNpc2lvbkRlc2NyaXB0aW9uKHJlY29nbml6ZXIsIGRmYSk7XG4gICAgICBsZXQgdGV4dCA9IHJlY29nbml6ZXIuaW5wdXRTdHJlYW0uZ2V0VGV4dChJbnRlcnZhbF8xLkludGVydmFsLm9mKHN0YXJ0SW5kZXgsIHN0b3BJbmRleCkpO1xuICAgICAgbGV0IG1lc3NhZ2UgPSBgcmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5IGQ9JHtkZWNpc2lvbn0sIGlucHV0PScke3RleHR9J2A7XG4gICAgICByZWNvZ25pemVyLm5vdGlmeUVycm9yTGlzdGVuZXJzKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBnZXREZWNpc2lvbkRlc2NyaXB0aW9uKHJlY29nbml6ZXIsIGRmYSkge1xuICAgICAgbGV0IGRlY2lzaW9uID0gZGZhLmRlY2lzaW9uO1xuICAgICAgbGV0IHJ1bGVJbmRleCA9IGRmYS5hdG5TdGFydFN0YXRlLnJ1bGVJbmRleDtcbiAgICAgIGxldCBydWxlTmFtZXMgPSByZWNvZ25pemVyLnJ1bGVOYW1lcztcbiAgICAgIGlmIChydWxlSW5kZXggPCAwIHx8IHJ1bGVJbmRleCA+PSBydWxlTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBkZWNpc2lvbi50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgbGV0IHJ1bGVOYW1lID0gcnVsZU5hbWVzW3J1bGVJbmRleF07XG4gICAgICBpZiAoIXJ1bGVOYW1lKSB7XG4gICAgICAgIHJldHVybiBkZWNpc2lvbi50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGAke2RlY2lzaW9ufSAoJHtydWxlTmFtZX0pYDtcbiAgICB9XG4gICAgZ2V0Q29uZmxpY3RpbmdBbHRzKHJlcG9ydGVkQWx0cywgY29uZmlncykge1xuICAgICAgaWYgKHJlcG9ydGVkQWx0cyAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXBvcnRlZEFsdHM7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdWx0ID0gbmV3IEJpdFNldF8xLkJpdFNldCgpO1xuICAgICAgZm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpIHtcbiAgICAgICAgcmVzdWx0LnNldChjb25maWcuYWx0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgRGlhZ25vc3RpY0Vycm9yTGlzdGVuZXIucHJvdG90eXBlLCBcInN5bnRheEVycm9yXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGUsXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbCksXG4gICAgX19wYXJhbSg2LCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgRGlhZ25vc3RpY0Vycm9yTGlzdGVuZXIucHJvdG90eXBlLCBcInJlcG9ydEFtYmlndWl0eVwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlLFxuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oMSwgRGVjb3JhdG9yc18xLk5vdE51bGwpLFxuICAgIF9fcGFyYW0oNSwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIERpYWdub3N0aWNFcnJvckxpc3RlbmVyLnByb3RvdHlwZSwgXCJyZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZSxcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDEsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDUsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBEaWFnbm9zdGljRXJyb3JMaXN0ZW5lci5wcm90b3R5cGUsIFwicmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5XCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKSxcbiAgICBfX3BhcmFtKDEsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBEaWFnbm9zdGljRXJyb3JMaXN0ZW5lci5wcm90b3R5cGUsIFwiZ2V0RGVjaXNpb25EZXNjcmlwdGlvblwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk5vdE51bGwsXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgRGlhZ25vc3RpY0Vycm9yTGlzdGVuZXIucHJvdG90eXBlLCBcImdldENvbmZsaWN0aW5nQWx0c1wiLCBudWxsKTtcbiAgZXhwb3J0cy5EaWFnbm9zdGljRXJyb3JMaXN0ZW5lciA9IERpYWdub3N0aWNFcnJvckxpc3RlbmVyO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9MZXhlckludGVycHJldGVyLmpzXG52YXIgcmVxdWlyZV9MZXhlckludGVycHJldGVyID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZGVjb3JhdGUgPSBleHBvcnRzICYmIGV4cG9ydHMuX19kZWNvcmF0ZSB8fCBmdW5jdGlvbihkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9O1xuICB2YXIgX19wYXJhbSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX3BhcmFtIHx8IGZ1bmN0aW9uKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBleHBvcnRzLkxleGVySW50ZXJwcmV0ZXIgPSB2b2lkIDA7XG4gIHZhciBMZXhlcl8xID0gcmVxdWlyZV9MZXhlcigpO1xuICB2YXIgTGV4ZXJBVE5TaW11bGF0b3JfMSA9IHJlcXVpcmVfTGV4ZXJBVE5TaW11bGF0b3IoKTtcbiAgdmFyIERlY29yYXRvcnNfMSA9IHJlcXVpcmVfRGVjb3JhdG9ycygpO1xuICB2YXIgRGVjb3JhdG9yc18yID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBMZXhlckludGVycHJldGVyID0gY2xhc3MgTGV4ZXJJbnRlcnByZXRlciBleHRlbmRzIExleGVyXzEuTGV4ZXIge1xuICAgIGNvbnN0cnVjdG9yKGdyYW1tYXJGaWxlTmFtZSwgdm9jYWJ1bGFyeSwgcnVsZU5hbWVzLCBjaGFubmVsTmFtZXMsIG1vZGVOYW1lcywgYXRuLCBpbnB1dCkge1xuICAgICAgc3VwZXIoaW5wdXQpO1xuICAgICAgaWYgKGF0bi5ncmFtbWFyVHlwZSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb246IFRoZSBBVE4gbXVzdCBiZSBhIGxleGVyIEFUTi5cIik7XG4gICAgICB9XG4gICAgICB0aGlzLl9ncmFtbWFyRmlsZU5hbWUgPSBncmFtbWFyRmlsZU5hbWU7XG4gICAgICB0aGlzLl9hdG4gPSBhdG47XG4gICAgICB0aGlzLl9ydWxlTmFtZXMgPSBydWxlTmFtZXMuc2xpY2UoMCk7XG4gICAgICB0aGlzLl9jaGFubmVsTmFtZXMgPSBjaGFubmVsTmFtZXMuc2xpY2UoMCk7XG4gICAgICB0aGlzLl9tb2RlTmFtZXMgPSBtb2RlTmFtZXMuc2xpY2UoMCk7XG4gICAgICB0aGlzLl92b2NhYnVsYXJ5ID0gdm9jYWJ1bGFyeTtcbiAgICAgIHRoaXMuX2ludGVycCA9IG5ldyBMZXhlckFUTlNpbXVsYXRvcl8xLkxleGVyQVROU2ltdWxhdG9yKGF0biwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBhdG4oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXRuO1xuICAgIH1cbiAgICBnZXQgZ3JhbW1hckZpbGVOYW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dyYW1tYXJGaWxlTmFtZTtcbiAgICB9XG4gICAgZ2V0IHJ1bGVOYW1lcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydWxlTmFtZXM7XG4gICAgfVxuICAgIGdldCBjaGFubmVsTmFtZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2hhbm5lbE5hbWVzO1xuICAgIH1cbiAgICBnZXQgbW9kZU5hbWVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vZGVOYW1lcztcbiAgICB9XG4gICAgZ2V0IHZvY2FidWxhcnkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdm9jYWJ1bGFyeTtcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5Ob3ROdWxsXG4gIF0sIExleGVySW50ZXJwcmV0ZXIucHJvdG90eXBlLCBcIl92b2NhYnVsYXJ5XCIsIHZvaWQgMCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMi5PdmVycmlkZVxuICBdLCBMZXhlckludGVycHJldGVyLnByb3RvdHlwZSwgXCJhdG5cIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMi5PdmVycmlkZVxuICBdLCBMZXhlckludGVycHJldGVyLnByb3RvdHlwZSwgXCJncmFtbWFyRmlsZU5hbWVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMi5PdmVycmlkZVxuICBdLCBMZXhlckludGVycHJldGVyLnByb3RvdHlwZSwgXCJydWxlTmFtZXNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMi5PdmVycmlkZVxuICBdLCBMZXhlckludGVycHJldGVyLnByb3RvdHlwZSwgXCJjaGFubmVsTmFtZXNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMi5PdmVycmlkZVxuICBdLCBMZXhlckludGVycHJldGVyLnByb3RvdHlwZSwgXCJtb2RlTmFtZXNcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMi5PdmVycmlkZVxuICBdLCBMZXhlckludGVycHJldGVyLnByb3RvdHlwZSwgXCJ2b2NhYnVsYXJ5XCIsIG51bGwpO1xuICBMZXhlckludGVycHJldGVyID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgxLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgTGV4ZXJJbnRlcnByZXRlcik7XG4gIGV4cG9ydHMuTGV4ZXJJbnRlcnByZXRlciA9IExleGVySW50ZXJwcmV0ZXI7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL1BhcnNlckVycm9yTGlzdGVuZXIuanNcbnZhciByZXF1aXJlX1BhcnNlckVycm9yTGlzdGVuZXIgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9SdWxlQ29udGV4dFdpdGhBbHROdW0uanNcbnZhciByZXF1aXJlX1J1bGVDb250ZXh0V2l0aEFsdE51bSA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2RlY29yYXRlID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoZCA9IGRlY29yYXRvcnNbaV0pXG4gICAgICAgICAgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5SdWxlQ29udGV4dFdpdGhBbHROdW0gPSB2b2lkIDA7XG4gIHZhciBBVE5fMSA9IHJlcXVpcmVfQVROKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIFBhcnNlclJ1bGVDb250ZXh0XzEgPSByZXF1aXJlX1BhcnNlclJ1bGVDb250ZXh0KCk7XG4gIHZhciBSdWxlQ29udGV4dFdpdGhBbHROdW0gPSBjbGFzcyBleHRlbmRzIFBhcnNlclJ1bGVDb250ZXh0XzEuUGFyc2VyUnVsZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZU51bWJlcikge1xuICAgICAgaWYgKGludm9raW5nU3RhdGVOdW1iZXIgIT09IHZvaWQgMCkge1xuICAgICAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGVOdW1iZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FsdE51bWJlciA9IEFUTl8xLkFUTi5JTlZBTElEX0FMVF9OVU1CRVI7XG4gICAgfVxuICAgIGdldCBhbHROdW1iZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWx0TnVtYmVyO1xuICAgIH1cbiAgICBzZXQgYWx0TnVtYmVyKGFsdE51bSkge1xuICAgICAgdGhpcy5fYWx0TnVtYmVyID0gYWx0TnVtO1xuICAgIH1cbiAgfTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlXG4gIF0sIFJ1bGVDb250ZXh0V2l0aEFsdE51bS5wcm90b3R5cGUsIFwiYWx0TnVtYmVyXCIsIG51bGwpO1xuICBleHBvcnRzLlJ1bGVDb250ZXh0V2l0aEFsdE51bSA9IFJ1bGVDb250ZXh0V2l0aEFsdE51bTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvUnVsZURlcGVuZGVuY3kuanNcbnZhciByZXF1aXJlX1J1bGVEZXBlbmRlbmN5ID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgZXhwb3J0cy5SdWxlRGVwZW5kZW5jeSA9IHZvaWQgMDtcbiAgZnVuY3Rpb24gUnVsZURlcGVuZGVuY3koZGVwZW5kZW5jeSkge1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eUtleSwgcHJvcGVydHlEZXNjcmlwdG9yKSA9PiB7XG4gICAgfTtcbiAgfVxuICBleHBvcnRzLlJ1bGVEZXBlbmRlbmN5ID0gUnVsZURlcGVuZGVuY3k7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL1J1bGVWZXJzaW9uLmpzXG52YXIgcmVxdWlyZV9SdWxlVmVyc2lvbiA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuUnVsZVZlcnNpb24gPSB2b2lkIDA7XG4gIGZ1bmN0aW9uIFJ1bGVWZXJzaW9uKHZlcnNpb24pIHtcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlLZXksIHByb3BlcnR5RGVzY3JpcHRvcikgPT4ge1xuICAgIH07XG4gIH1cbiAgZXhwb3J0cy5SdWxlVmVyc2lvbiA9IFJ1bGVWZXJzaW9uO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9Ub2tlbkZhY3RvcnkuanNcbnZhciByZXF1aXJlX1Rva2VuRmFjdG9yeSA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL1Rva2VuU291cmNlLmpzXG52YXIgcmVxdWlyZV9Ub2tlblNvdXJjZSA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL1Rva2VuU3RyZWFtLmpzXG52YXIgcmVxdWlyZV9Ub2tlblN0cmVhbSA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL1Rva2VuU3RyZWFtUmV3cml0ZXIuanNcbnZhciByZXF1aXJlX1Rva2VuU3RyZWFtUmV3cml0ZXIgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuUmV3cml0ZU9wZXJhdGlvbiA9IGV4cG9ydHMuVG9rZW5TdHJlYW1SZXdyaXRlciA9IHZvaWQgMDtcbiAgdmFyIEludGVydmFsXzEgPSByZXF1aXJlX0ludGVydmFsKCk7XG4gIHZhciBEZWNvcmF0b3JzXzEgPSByZXF1aXJlX0RlY29yYXRvcnMoKTtcbiAgdmFyIFRva2VuXzEgPSByZXF1aXJlX1Rva2VuKCk7XG4gIHZhciBUb2tlblN0cmVhbVJld3JpdGVyID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHRva2VuczIpIHtcbiAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zMjtcbiAgICAgIHRoaXMucHJvZ3JhbXMgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLnByb2dyYW1zLnNldChUb2tlblN0cmVhbVJld3JpdGVyLkRFRkFVTFRfUFJPR1JBTV9OQU1FLCBbXSk7XG4gICAgICB0aGlzLmxhc3RSZXdyaXRlVG9rZW5JbmRleGVzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBnZXRUb2tlblN0cmVhbSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRva2VucztcbiAgICB9XG4gICAgcm9sbGJhY2soaW5zdHJ1Y3Rpb25JbmRleCwgcHJvZ3JhbU5hbWUgPSBUb2tlblN0cmVhbVJld3JpdGVyLkRFRkFVTFRfUFJPR1JBTV9OQU1FKSB7XG4gICAgICBsZXQgaXMgPSB0aGlzLnByb2dyYW1zLmdldChwcm9ncmFtTmFtZSk7XG4gICAgICBpZiAoaXMgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnByb2dyYW1zLnNldChwcm9ncmFtTmFtZSwgaXMuc2xpY2UoVG9rZW5TdHJlYW1SZXdyaXRlci5NSU5fVE9LRU5fSU5ERVgsIGluc3RydWN0aW9uSW5kZXgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlUHJvZ3JhbShwcm9ncmFtTmFtZSA9IFRva2VuU3RyZWFtUmV3cml0ZXIuREVGQVVMVF9QUk9HUkFNX05BTUUpIHtcbiAgICAgIHRoaXMucm9sbGJhY2soVG9rZW5TdHJlYW1SZXdyaXRlci5NSU5fVE9LRU5fSU5ERVgsIHByb2dyYW1OYW1lKTtcbiAgICB9XG4gICAgaW5zZXJ0QWZ0ZXIodG9rZW5PckluZGV4LCB0ZXh0LCBwcm9ncmFtTmFtZSA9IFRva2VuU3RyZWFtUmV3cml0ZXIuREVGQVVMVF9QUk9HUkFNX05BTUUpIHtcbiAgICAgIGxldCBpbmRleDtcbiAgICAgIGlmICh0eXBlb2YgdG9rZW5PckluZGV4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGluZGV4ID0gdG9rZW5PckluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXggPSB0b2tlbk9ySW5kZXgudG9rZW5JbmRleDtcbiAgICAgIH1cbiAgICAgIGxldCByZXdyaXRlcyA9IHRoaXMuZ2V0UHJvZ3JhbShwcm9ncmFtTmFtZSk7XG4gICAgICBsZXQgb3AgPSBuZXcgSW5zZXJ0QWZ0ZXJPcCh0aGlzLnRva2VucywgaW5kZXgsIHJld3JpdGVzLmxlbmd0aCwgdGV4dCk7XG4gICAgICByZXdyaXRlcy5wdXNoKG9wKTtcbiAgICB9XG4gICAgaW5zZXJ0QmVmb3JlKHRva2VuT3JJbmRleCwgdGV4dCwgcHJvZ3JhbU5hbWUgPSBUb2tlblN0cmVhbVJld3JpdGVyLkRFRkFVTFRfUFJPR1JBTV9OQU1FKSB7XG4gICAgICBsZXQgaW5kZXg7XG4gICAgICBpZiAodHlwZW9mIHRva2VuT3JJbmRleCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBpbmRleCA9IHRva2VuT3JJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ID0gdG9rZW5PckluZGV4LnRva2VuSW5kZXg7XG4gICAgICB9XG4gICAgICBsZXQgcmV3cml0ZXMgPSB0aGlzLmdldFByb2dyYW0ocHJvZ3JhbU5hbWUpO1xuICAgICAgbGV0IG9wID0gbmV3IEluc2VydEJlZm9yZU9wKHRoaXMudG9rZW5zLCBpbmRleCwgcmV3cml0ZXMubGVuZ3RoLCB0ZXh0KTtcbiAgICAgIHJld3JpdGVzLnB1c2gob3ApO1xuICAgIH1cbiAgICByZXBsYWNlU2luZ2xlKGluZGV4LCB0ZXh0KSB7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRoaXMucmVwbGFjZShpbmRleCwgaW5kZXgsIHRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXBsYWNlKGluZGV4LCBpbmRleCwgdGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHRleHQsIHByb2dyYW1OYW1lID0gVG9rZW5TdHJlYW1SZXdyaXRlci5ERUZBVUxUX1BST0dSQU1fTkFNRSkge1xuICAgICAgaWYgKHR5cGVvZiBmcm9tICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGZyb20gPSBmcm9tLnRva2VuSW5kZXg7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRvICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRvID0gdG8udG9rZW5JbmRleDtcbiAgICAgIH1cbiAgICAgIGlmIChmcm9tID4gdG8gfHwgZnJvbSA8IDAgfHwgdG8gPCAwIHx8IHRvID49IHRoaXMudG9rZW5zLnNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHJlcGxhY2U6IHJhbmdlIGludmFsaWQ6ICR7ZnJvbX0uLiR7dG99KHNpemU9JHt0aGlzLnRva2Vucy5zaXplfSlgKTtcbiAgICAgIH1cbiAgICAgIGxldCByZXdyaXRlcyA9IHRoaXMuZ2V0UHJvZ3JhbShwcm9ncmFtTmFtZSk7XG4gICAgICBsZXQgb3AgPSBuZXcgUmVwbGFjZU9wKHRoaXMudG9rZW5zLCBmcm9tLCB0bywgcmV3cml0ZXMubGVuZ3RoLCB0ZXh0KTtcbiAgICAgIHJld3JpdGVzLnB1c2gob3ApO1xuICAgIH1cbiAgICBkZWxldGUoZnJvbSwgdG8sIHByb2dyYW1OYW1lID0gVG9rZW5TdHJlYW1SZXdyaXRlci5ERUZBVUxUX1BST0dSQU1fTkFNRSkge1xuICAgICAgaWYgKHRvID09PSB2b2lkIDApIHtcbiAgICAgICAgdG8gPSBmcm9tO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBmcm9tID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRoaXMucmVwbGFjZShmcm9tLCB0bywgXCJcIiwgcHJvZ3JhbU5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXBsYWNlKGZyb20sIHRvLCBcIlwiLCBwcm9ncmFtTmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGdldExhc3RSZXdyaXRlVG9rZW5JbmRleChwcm9ncmFtTmFtZSA9IFRva2VuU3RyZWFtUmV3cml0ZXIuREVGQVVMVF9QUk9HUkFNX05BTUUpIHtcbiAgICAgIGxldCBJID0gdGhpcy5sYXN0UmV3cml0ZVRva2VuSW5kZXhlcy5nZXQocHJvZ3JhbU5hbWUpO1xuICAgICAgaWYgKEkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gSTtcbiAgICB9XG4gICAgc2V0TGFzdFJld3JpdGVUb2tlbkluZGV4KHByb2dyYW1OYW1lLCBpKSB7XG4gICAgICB0aGlzLmxhc3RSZXdyaXRlVG9rZW5JbmRleGVzLnNldChwcm9ncmFtTmFtZSwgaSk7XG4gICAgfVxuICAgIGdldFByb2dyYW0obmFtZSkge1xuICAgICAgbGV0IGlzID0gdGhpcy5wcm9ncmFtcy5nZXQobmFtZSk7XG4gICAgICBpZiAoaXMgPT0gbnVsbCkge1xuICAgICAgICBpcyA9IHRoaXMuaW5pdGlhbGl6ZVByb2dyYW0obmFtZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXM7XG4gICAgfVxuICAgIGluaXRpYWxpemVQcm9ncmFtKG5hbWUpIHtcbiAgICAgIGxldCBpcyA9IFtdO1xuICAgICAgdGhpcy5wcm9ncmFtcy5zZXQobmFtZSwgaXMpO1xuICAgICAgcmV0dXJuIGlzO1xuICAgIH1cbiAgICBnZXRUZXh0KGludGVydmFsT3JQcm9ncmFtLCBwcm9ncmFtTmFtZSA9IFRva2VuU3RyZWFtUmV3cml0ZXIuREVGQVVMVF9QUk9HUkFNX05BTUUpIHtcbiAgICAgIGxldCBpbnRlcnZhbDtcbiAgICAgIGlmIChpbnRlcnZhbE9yUHJvZ3JhbSBpbnN0YW5jZW9mIEludGVydmFsXzEuSW50ZXJ2YWwpIHtcbiAgICAgICAgaW50ZXJ2YWwgPSBpbnRlcnZhbE9yUHJvZ3JhbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVydmFsID0gSW50ZXJ2YWxfMS5JbnRlcnZhbC5vZigwLCB0aGlzLnRva2Vucy5zaXplIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGludGVydmFsT3JQcm9ncmFtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHByb2dyYW1OYW1lID0gaW50ZXJ2YWxPclByb2dyYW07XG4gICAgICB9XG4gICAgICBsZXQgcmV3cml0ZXMgPSB0aGlzLnByb2dyYW1zLmdldChwcm9ncmFtTmFtZSk7XG4gICAgICBsZXQgc3RhcnQgPSBpbnRlcnZhbC5hO1xuICAgICAgbGV0IHN0b3AgPSBpbnRlcnZhbC5iO1xuICAgICAgaWYgKHN0b3AgPiB0aGlzLnRva2Vucy5zaXplIC0gMSkge1xuICAgICAgICBzdG9wID0gdGhpcy50b2tlbnMuc2l6ZSAtIDE7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChyZXdyaXRlcyA9PSBudWxsIHx8IHJld3JpdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2tlbnMuZ2V0VGV4dChpbnRlcnZhbCk7XG4gICAgICB9XG4gICAgICBsZXQgYnVmID0gW107XG4gICAgICBsZXQgaW5kZXhUb09wID0gdGhpcy5yZWR1Y2VUb1NpbmdsZU9wZXJhdGlvblBlckluZGV4KHJld3JpdGVzKTtcbiAgICAgIGxldCBpID0gc3RhcnQ7XG4gICAgICB3aGlsZSAoaSA8PSBzdG9wICYmIGkgPCB0aGlzLnRva2Vucy5zaXplKSB7XG4gICAgICAgIGxldCBvcCA9IGluZGV4VG9PcC5nZXQoaSk7XG4gICAgICAgIGluZGV4VG9PcC5kZWxldGUoaSk7XG4gICAgICAgIGxldCB0ID0gdGhpcy50b2tlbnMuZ2V0KGkpO1xuICAgICAgICBpZiAob3AgPT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0LnR5cGUgIT09IFRva2VuXzEuVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICBidWYucHVzaChTdHJpbmcodC50ZXh0KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpID0gb3AuZXhlY3V0ZShidWYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RvcCA9PT0gdGhpcy50b2tlbnMuc2l6ZSAtIDEpIHtcbiAgICAgICAgZm9yIChsZXQgb3Agb2YgaW5kZXhUb09wLnZhbHVlcygpKSB7XG4gICAgICAgICAgaWYgKG9wLmluZGV4ID49IHRoaXMudG9rZW5zLnNpemUgLSAxKSB7XG4gICAgICAgICAgICBidWYucHVzaChvcC50ZXh0LnRvU3RyaW5nKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5qb2luKFwiXCIpO1xuICAgIH1cbiAgICByZWR1Y2VUb1NpbmdsZU9wZXJhdGlvblBlckluZGV4KHJld3JpdGVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJld3JpdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBvcCA9IHJld3JpdGVzW2ldO1xuICAgICAgICBpZiAob3AgPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKG9wIGluc3RhbmNlb2YgUmVwbGFjZU9wKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCByb3AgPSBvcDtcbiAgICAgICAgbGV0IGluc2VydHMgPSB0aGlzLmdldEtpbmRPZk9wcyhyZXdyaXRlcywgSW5zZXJ0QmVmb3JlT3AsIGkpO1xuICAgICAgICBmb3IgKGxldCBpb3Agb2YgaW5zZXJ0cykge1xuICAgICAgICAgIGlmIChpb3AuaW5kZXggPT09IHJvcC5pbmRleCkge1xuICAgICAgICAgICAgcmV3cml0ZXNbaW9wLmluc3RydWN0aW9uSW5kZXhdID0gdm9pZCAwO1xuICAgICAgICAgICAgcm9wLnRleHQgPSBpb3AudGV4dC50b1N0cmluZygpICsgKHJvcC50ZXh0ICE9IG51bGwgPyByb3AudGV4dC50b1N0cmluZygpIDogXCJcIik7XG4gICAgICAgICAgfSBlbHNlIGlmIChpb3AuaW5kZXggPiByb3AuaW5kZXggJiYgaW9wLmluZGV4IDw9IHJvcC5sYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIHJld3JpdGVzW2lvcC5pbnN0cnVjdGlvbkluZGV4XSA9IHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZXZSZXBsYWNlcyA9IHRoaXMuZ2V0S2luZE9mT3BzKHJld3JpdGVzLCBSZXBsYWNlT3AsIGkpO1xuICAgICAgICBmb3IgKGxldCBwcmV2Um9wIG9mIHByZXZSZXBsYWNlcykge1xuICAgICAgICAgIGlmIChwcmV2Um9wLmluZGV4ID49IHJvcC5pbmRleCAmJiBwcmV2Um9wLmxhc3RJbmRleCA8PSByb3AubGFzdEluZGV4KSB7XG4gICAgICAgICAgICByZXdyaXRlc1twcmV2Um9wLmluc3RydWN0aW9uSW5kZXhdID0gdm9pZCAwO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBkaXNqb2ludCA9IHByZXZSb3AubGFzdEluZGV4IDwgcm9wLmluZGV4IHx8IHByZXZSb3AuaW5kZXggPiByb3AubGFzdEluZGV4O1xuICAgICAgICAgIGlmIChwcmV2Um9wLnRleHQgPT0gbnVsbCAmJiByb3AudGV4dCA9PSBudWxsICYmICFkaXNqb2ludCkge1xuICAgICAgICAgICAgcmV3cml0ZXNbcHJldlJvcC5pbnN0cnVjdGlvbkluZGV4XSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJvcC5pbmRleCA9IE1hdGgubWluKHByZXZSb3AuaW5kZXgsIHJvcC5pbmRleCk7XG4gICAgICAgICAgICByb3AubGFzdEluZGV4ID0gTWF0aC5tYXgocHJldlJvcC5sYXN0SW5kZXgsIHJvcC5sYXN0SW5kZXgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWRpc2pvaW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlcGxhY2Ugb3AgYm91bmRhcmllcyBvZiAke3JvcH0gb3ZlcmxhcCB3aXRoIHByZXZpb3VzICR7cHJldlJvcH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV3cml0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG9wID0gcmV3cml0ZXNbaV07XG4gICAgICAgIGlmIChvcCA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEob3AgaW5zdGFuY2VvZiBJbnNlcnRCZWZvcmVPcCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW9wID0gb3A7XG4gICAgICAgIGxldCBwcmV2SW5zZXJ0cyA9IHRoaXMuZ2V0S2luZE9mT3BzKHJld3JpdGVzLCBJbnNlcnRCZWZvcmVPcCwgaSk7XG4gICAgICAgIGZvciAobGV0IHByZXZJb3Agb2YgcHJldkluc2VydHMpIHtcbiAgICAgICAgICBpZiAocHJldklvcC5pbmRleCA9PT0gaW9wLmluZGV4KSB7XG4gICAgICAgICAgICBpZiAocHJldklvcCBpbnN0YW5jZW9mIEluc2VydEFmdGVyT3ApIHtcbiAgICAgICAgICAgICAgaW9wLnRleHQgPSB0aGlzLmNhdE9wVGV4dChwcmV2SW9wLnRleHQsIGlvcC50ZXh0KTtcbiAgICAgICAgICAgICAgcmV3cml0ZXNbcHJldklvcC5pbnN0cnVjdGlvbkluZGV4XSA9IHZvaWQgMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldklvcCBpbnN0YW5jZW9mIEluc2VydEJlZm9yZU9wKSB7XG4gICAgICAgICAgICAgIGlvcC50ZXh0ID0gdGhpcy5jYXRPcFRleHQoaW9wLnRleHQsIHByZXZJb3AudGV4dCk7XG4gICAgICAgICAgICAgIHJld3JpdGVzW3ByZXZJb3AuaW5zdHJ1Y3Rpb25JbmRleF0gPSB2b2lkIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBwcmV2UmVwbGFjZXMgPSB0aGlzLmdldEtpbmRPZk9wcyhyZXdyaXRlcywgUmVwbGFjZU9wLCBpKTtcbiAgICAgICAgZm9yIChsZXQgcm9wIG9mIHByZXZSZXBsYWNlcykge1xuICAgICAgICAgIGlmIChpb3AuaW5kZXggPT09IHJvcC5pbmRleCkge1xuICAgICAgICAgICAgcm9wLnRleHQgPSB0aGlzLmNhdE9wVGV4dChpb3AudGV4dCwgcm9wLnRleHQpO1xuICAgICAgICAgICAgcmV3cml0ZXNbaV0gPSB2b2lkIDA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlvcC5pbmRleCA+PSByb3AuaW5kZXggJiYgaW9wLmluZGV4IDw9IHJvcC5sYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5zZXJ0IG9wICR7aW9wfSB3aXRoaW4gYm91bmRhcmllcyBvZiBwcmV2aW91cyAke3JvcH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBtID0gbmV3IE1hcCgpO1xuICAgICAgZm9yIChsZXQgb3Agb2YgcmV3cml0ZXMpIHtcbiAgICAgICAgaWYgKG9wID09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobS5nZXQob3AuaW5kZXgpICE9IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaG91bGQgb25seSBiZSBvbmUgb3AgcGVyIGluZGV4XCIpO1xuICAgICAgICB9XG4gICAgICAgIG0uc2V0KG9wLmluZGV4LCBvcCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbTtcbiAgICB9XG4gICAgY2F0T3BUZXh0KGEsIGIpIHtcbiAgICAgIGxldCB4ID0gXCJcIjtcbiAgICAgIGxldCB5ID0gXCJcIjtcbiAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgeCA9IGEudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgICAgeSA9IGIudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4ICsgeTtcbiAgICB9XG4gICAgZ2V0S2luZE9mT3BzKHJld3JpdGVzLCBraW5kLCBiZWZvcmUpIHtcbiAgICAgIGxldCBvcHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmVmb3JlICYmIGkgPCByZXdyaXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgb3AgPSByZXdyaXRlc1tpXTtcbiAgICAgICAgaWYgKG9wID09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3AgaW5zdGFuY2VvZiBraW5kKSB7XG4gICAgICAgICAgb3BzLnB1c2gob3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3BzO1xuICAgIH1cbiAgfTtcbiAgZXhwb3J0cy5Ub2tlblN0cmVhbVJld3JpdGVyID0gVG9rZW5TdHJlYW1SZXdyaXRlcjtcbiAgVG9rZW5TdHJlYW1SZXdyaXRlci5ERUZBVUxUX1BST0dSQU1fTkFNRSA9IFwiZGVmYXVsdFwiO1xuICBUb2tlblN0cmVhbVJld3JpdGVyLlBST0dSQU1fSU5JVF9TSVpFID0gMTAwO1xuICBUb2tlblN0cmVhbVJld3JpdGVyLk1JTl9UT0tFTl9JTkRFWCA9IDA7XG4gIHZhciBSZXdyaXRlT3BlcmF0aW9uID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHRva2VuczIsIGluZGV4LCBpbnN0cnVjdGlvbkluZGV4LCB0ZXh0KSB7XG4gICAgICB0aGlzLnRva2VucyA9IHRva2VuczI7XG4gICAgICB0aGlzLmluc3RydWN0aW9uSW5kZXggPSBpbnN0cnVjdGlvbkluZGV4O1xuICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgdGhpcy50ZXh0ID0gdGV4dCA9PT0gdm9pZCAwID8gXCJcIiA6IHRleHQ7XG4gICAgfVxuICAgIGV4ZWN1dGUoYnVmKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICBsZXQgb3BOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgbGV0ICRpbmRleCA9IG9wTmFtZS5pbmRleE9mKFwiJFwiKTtcbiAgICAgIG9wTmFtZSA9IG9wTmFtZS5zdWJzdHJpbmcoJGluZGV4ICsgMSwgb3BOYW1lLmxlbmd0aCk7XG4gICAgICByZXR1cm4gXCI8XCIgKyBvcE5hbWUgKyBcIkBcIiArIHRoaXMudG9rZW5zLmdldCh0aGlzLmluZGV4KSArICc6XCInICsgdGhpcy50ZXh0ICsgJ1wiPic7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgUmV3cml0ZU9wZXJhdGlvbi5wcm90b3R5cGUsIFwidG9TdHJpbmdcIiwgbnVsbCk7XG4gIGV4cG9ydHMuUmV3cml0ZU9wZXJhdGlvbiA9IFJld3JpdGVPcGVyYXRpb247XG4gIHZhciBJbnNlcnRCZWZvcmVPcCA9IGNsYXNzIGV4dGVuZHMgUmV3cml0ZU9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IodG9rZW5zMiwgaW5kZXgsIGluc3RydWN0aW9uSW5kZXgsIHRleHQpIHtcbiAgICAgIHN1cGVyKHRva2VuczIsIGluZGV4LCBpbnN0cnVjdGlvbkluZGV4LCB0ZXh0KTtcbiAgICB9XG4gICAgZXhlY3V0ZShidWYpIHtcbiAgICAgIGJ1Zi5wdXNoKHRoaXMudGV4dC50b1N0cmluZygpKTtcbiAgICAgIGlmICh0aGlzLnRva2Vucy5nZXQodGhpcy5pbmRleCkudHlwZSAhPT0gVG9rZW5fMS5Ub2tlbi5FT0YpIHtcbiAgICAgICAgYnVmLnB1c2goU3RyaW5nKHRoaXMudG9rZW5zLmdldCh0aGlzLmluZGV4KS50ZXh0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5pbmRleCArIDE7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGVcbiAgXSwgSW5zZXJ0QmVmb3JlT3AucHJvdG90eXBlLCBcImV4ZWN1dGVcIiwgbnVsbCk7XG4gIHZhciBJbnNlcnRBZnRlck9wID0gY2xhc3MgZXh0ZW5kcyBJbnNlcnRCZWZvcmVPcCB7XG4gICAgY29uc3RydWN0b3IodG9rZW5zMiwgaW5kZXgsIGluc3RydWN0aW9uSW5kZXgsIHRleHQpIHtcbiAgICAgIHN1cGVyKHRva2VuczIsIGluZGV4ICsgMSwgaW5zdHJ1Y3Rpb25JbmRleCwgdGV4dCk7XG4gICAgfVxuICB9O1xuICB2YXIgUmVwbGFjZU9wID0gY2xhc3MgZXh0ZW5kcyBSZXdyaXRlT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbnMyLCBmcm9tLCB0bywgaW5zdHJ1Y3Rpb25JbmRleCwgdGV4dCkge1xuICAgICAgc3VwZXIodG9rZW5zMiwgZnJvbSwgaW5zdHJ1Y3Rpb25JbmRleCwgdGV4dCk7XG4gICAgICB0aGlzLmxhc3RJbmRleCA9IHRvO1xuICAgIH1cbiAgICBleGVjdXRlKGJ1Zikge1xuICAgICAgaWYgKHRoaXMudGV4dCAhPSBudWxsKSB7XG4gICAgICAgIGJ1Zi5wdXNoKHRoaXMudGV4dC50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmxhc3RJbmRleCArIDE7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgaWYgKHRoaXMudGV4dCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIjxEZWxldGVPcEBcIiArIHRoaXMudG9rZW5zLmdldCh0aGlzLmluZGV4KSArIFwiLi5cIiArIHRoaXMudG9rZW5zLmdldCh0aGlzLmxhc3RJbmRleCkgKyBcIj5cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIjxSZXBsYWNlT3BAXCIgKyB0aGlzLnRva2Vucy5nZXQodGhpcy5pbmRleCkgKyBcIi4uXCIgKyB0aGlzLnRva2Vucy5nZXQodGhpcy5sYXN0SW5kZXgpICsgJzpcIicgKyB0aGlzLnRleHQgKyAnXCI+JztcbiAgICB9XG4gIH07XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBSZXBsYWNlT3AucHJvdG90eXBlLCBcImV4ZWN1dGVcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZVxuICBdLCBSZXBsYWNlT3AucHJvdG90eXBlLCBcInRvU3RyaW5nXCIsIG51bGwpO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjR0cy9Wb2NhYnVsYXJ5LmpzXG52YXIgcmVxdWlyZV9Wb2NhYnVsYXJ5ID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0dHMvV3JpdGFibGVUb2tlbi5qc1xudmFyIHJlcXVpcmVfV3JpdGFibGVUb2tlbiA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL2luZGV4LmpzXG52YXIgcmVxdWlyZV9hbnRscjR0cyA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBleHBvcnRzICYmIGV4cG9ydHMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHZvaWQgMClcbiAgICAgIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHtlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG1ba107XG4gICAgfX0pO1xuICB9IDogZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHZvaWQgMClcbiAgICAgIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG4gIH0pO1xuICB2YXIgX19leHBvcnRTdGFyID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZXhwb3J0U3RhciB8fCBmdW5jdGlvbihtLCBleHBvcnRzMikge1xuICAgIGZvciAodmFyIHAgaW4gbSlcbiAgICAgIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMyLCBwKSlcbiAgICAgICAgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMyLCBtLCBwKTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgX19leHBvcnRTdGFyKHJlcXVpcmVfQU5UTFJFcnJvckxpc3RlbmVyKCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9BTlRMUkVycm9yU3RyYXRlZ3koKSwgZXhwb3J0cyk7XG4gIF9fZXhwb3J0U3RhcihyZXF1aXJlX0FOVExSSW5wdXRTdHJlYW0oKSwgZXhwb3J0cyk7XG4gIF9fZXhwb3J0U3RhcihyZXF1aXJlX0JhaWxFcnJvclN0cmF0ZWd5KCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9CdWZmZXJlZFRva2VuU3RyZWFtKCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9DaGFyU3RyZWFtKCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9DaGFyU3RyZWFtcygpLCBleHBvcnRzKTtcbiAgX19leHBvcnRTdGFyKHJlcXVpcmVfQ29kZVBvaW50QnVmZmVyKCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9Db2RlUG9pbnRDaGFyU3RyZWFtKCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9Db21tb25Ub2tlbigpLCBleHBvcnRzKTtcbiAgX19leHBvcnRTdGFyKHJlcXVpcmVfQ29tbW9uVG9rZW5GYWN0b3J5KCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9Db21tb25Ub2tlblN0cmVhbSgpLCBleHBvcnRzKTtcbiAgX19leHBvcnRTdGFyKHJlcXVpcmVfQ29uc29sZUVycm9yTGlzdGVuZXIoKSwgZXhwb3J0cyk7XG4gIF9fZXhwb3J0U3RhcihyZXF1aXJlX0RlZmF1bHRFcnJvclN0cmF0ZWd5KCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9EZXBlbmRlbnRzKCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9EaWFnbm9zdGljRXJyb3JMaXN0ZW5lcigpLCBleHBvcnRzKTtcbiAgX19leHBvcnRTdGFyKHJlcXVpcmVfRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9JbnB1dE1pc21hdGNoRXhjZXB0aW9uKCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9JbnRlcnByZXRlclJ1bGVDb250ZXh0KCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9JbnRTdHJlYW0oKSwgZXhwb3J0cyk7XG4gIF9fZXhwb3J0U3RhcihyZXF1aXJlX0xleGVyKCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9MZXhlckludGVycHJldGVyKCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9MZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uKCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9MaXN0VG9rZW5Tb3VyY2UoKSwgZXhwb3J0cyk7XG4gIF9fZXhwb3J0U3RhcihyZXF1aXJlX05vVmlhYmxlQWx0RXhjZXB0aW9uKCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9QYXJzZXIoKSwgZXhwb3J0cyk7XG4gIF9fZXhwb3J0U3RhcihyZXF1aXJlX1BhcnNlckVycm9yTGlzdGVuZXIoKSwgZXhwb3J0cyk7XG4gIF9fZXhwb3J0U3RhcihyZXF1aXJlX1BhcnNlckludGVycHJldGVyKCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9QYXJzZXJSdWxlQ29udGV4dCgpLCBleHBvcnRzKTtcbiAgX19leHBvcnRTdGFyKHJlcXVpcmVfUHJveHlFcnJvckxpc3RlbmVyKCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9Qcm94eVBhcnNlckVycm9yTGlzdGVuZXIoKSwgZXhwb3J0cyk7XG4gIF9fZXhwb3J0U3RhcihyZXF1aXJlX1JlY29nbml0aW9uRXhjZXB0aW9uKCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9SZWNvZ25pemVyKCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9SdWxlQ29udGV4dCgpLCBleHBvcnRzKTtcbiAgX19leHBvcnRTdGFyKHJlcXVpcmVfUnVsZUNvbnRleHRXaXRoQWx0TnVtKCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9SdWxlRGVwZW5kZW5jeSgpLCBleHBvcnRzKTtcbiAgX19leHBvcnRTdGFyKHJlcXVpcmVfUnVsZVZlcnNpb24oKSwgZXhwb3J0cyk7XG4gIF9fZXhwb3J0U3RhcihyZXF1aXJlX1Rva2VuKCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9Ub2tlbkZhY3RvcnkoKSwgZXhwb3J0cyk7XG4gIF9fZXhwb3J0U3RhcihyZXF1aXJlX1Rva2VuU291cmNlKCksIGV4cG9ydHMpO1xuICBfX2V4cG9ydFN0YXIocmVxdWlyZV9Ub2tlblN0cmVhbSgpLCBleHBvcnRzKTtcbiAgX19leHBvcnRTdGFyKHJlcXVpcmVfVG9rZW5TdHJlYW1SZXdyaXRlcigpLCBleHBvcnRzKTtcbiAgX19leHBvcnRTdGFyKHJlcXVpcmVfVm9jYWJ1bGFyeSgpLCBleHBvcnRzKTtcbiAgX19leHBvcnRTdGFyKHJlcXVpcmVfVm9jYWJ1bGFyeUltcGwoKSwgZXhwb3J0cyk7XG4gIF9fZXhwb3J0U3RhcihyZXF1aXJlX1dyaXRhYmxlVG9rZW4oKSwgZXhwb3J0cyk7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNHRzL3RyZWUvQWJzdHJhY3RQYXJzZVRyZWVWaXNpdG9yLmpzXG52YXIgcmVxdWlyZV9BYnN0cmFjdFBhcnNlVHJlZVZpc2l0b3IgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19kZWNvcmF0ZSA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2RlY29yYXRlIHx8IGZ1bmN0aW9uKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKVxuICAgICAgICAgIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH07XG4gIHZhciBfX3BhcmFtID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fcGFyYW0gfHwgZnVuY3Rpb24ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5KSB7XG4gICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpO1xuICAgIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGV4cG9ydHMuQWJzdHJhY3RQYXJzZVRyZWVWaXNpdG9yID0gdm9pZCAwO1xuICB2YXIgRGVjb3JhdG9yc18xID0gcmVxdWlyZV9EZWNvcmF0b3JzKCk7XG4gIHZhciBBYnN0cmFjdFBhcnNlVHJlZVZpc2l0b3IyID0gY2xhc3Mge1xuICAgIHZpc2l0KHRyZWUpIHtcbiAgICAgIHJldHVybiB0cmVlLmFjY2VwdCh0aGlzKTtcbiAgICB9XG4gICAgdmlzaXRDaGlsZHJlbihub2RlKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gdGhpcy5kZWZhdWx0UmVzdWx0KCk7XG4gICAgICBsZXQgbiA9IG5vZGUuY2hpbGRDb3VudDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5zaG91bGRWaXNpdE5leHRDaGlsZChub2RlLCByZXN1bHQpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGMgPSBub2RlLmdldENoaWxkKGkpO1xuICAgICAgICBsZXQgY2hpbGRSZXN1bHQgPSBjLmFjY2VwdCh0aGlzKTtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5hZ2dyZWdhdGVSZXN1bHQocmVzdWx0LCBjaGlsZFJlc3VsdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB2aXNpdFRlcm1pbmFsKG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRSZXN1bHQoKTtcbiAgICB9XG4gICAgdmlzaXRFcnJvck5vZGUobm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdFJlc3VsdCgpO1xuICAgIH1cbiAgICBhZ2dyZWdhdGVSZXN1bHQoYWdncmVnYXRlLCBuZXh0UmVzdWx0KSB7XG4gICAgICByZXR1cm4gbmV4dFJlc3VsdDtcbiAgICB9XG4gICAgc2hvdWxkVmlzaXROZXh0Q2hpbGQobm9kZSwgY3VycmVudFJlc3VsdCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGUsXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgQWJzdHJhY3RQYXJzZVRyZWVWaXNpdG9yMi5wcm90b3R5cGUsIFwidmlzaXRcIiwgbnVsbCk7XG4gIF9fZGVjb3JhdGUoW1xuICAgIERlY29yYXRvcnNfMS5PdmVycmlkZSxcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBBYnN0cmFjdFBhcnNlVHJlZVZpc2l0b3IyLnByb3RvdHlwZSwgXCJ2aXNpdENoaWxkcmVuXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBEZWNvcmF0b3JzXzEuT3ZlcnJpZGUsXG4gICAgX19wYXJhbSgwLCBEZWNvcmF0b3JzXzEuTm90TnVsbClcbiAgXSwgQWJzdHJhY3RQYXJzZVRyZWVWaXNpdG9yMi5wcm90b3R5cGUsIFwidmlzaXRUZXJtaW5hbFwiLCBudWxsKTtcbiAgX19kZWNvcmF0ZShbXG4gICAgRGVjb3JhdG9yc18xLk92ZXJyaWRlLFxuICAgIF9fcGFyYW0oMCwgRGVjb3JhdG9yc18xLk5vdE51bGwpXG4gIF0sIEFic3RyYWN0UGFyc2VUcmVlVmlzaXRvcjIucHJvdG90eXBlLCBcInZpc2l0RXJyb3JOb2RlXCIsIG51bGwpO1xuICBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIERlY29yYXRvcnNfMS5Ob3ROdWxsKVxuICBdLCBBYnN0cmFjdFBhcnNlVHJlZVZpc2l0b3IyLnByb3RvdHlwZSwgXCJzaG91bGRWaXNpdE5leHRDaGlsZFwiLCBudWxsKTtcbiAgZXhwb3J0cy5BYnN0cmFjdFBhcnNlVHJlZVZpc2l0b3IgPSBBYnN0cmFjdFBhcnNlVHJlZVZpc2l0b3IyO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjQvc3JjL2FudGxyNC9VdGlscy5qc1xudmFyIHJlcXVpcmVfVXRpbHMyID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlMikgPT4ge1xuICBmdW5jdGlvbiBhcnJheVRvU3RyaW5nKGEpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhKSA/IFwiW1wiICsgYS5qb2luKFwiLCBcIikgKyBcIl1cIiA6IFwibnVsbFwiO1xuICB9XG4gIFN0cmluZy5wcm90b3R5cGUuc2VlZCA9IFN0cmluZy5wcm90b3R5cGUuc2VlZCB8fCBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCAzMikpO1xuICBTdHJpbmcucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3Qga2V5ID0gdGhpcy50b1N0cmluZygpO1xuICAgIGxldCBoMWIsIGsxO1xuICAgIGNvbnN0IHJlbWFpbmRlciA9IGtleS5sZW5ndGggJiAzO1xuICAgIGNvbnN0IGJ5dGVzID0ga2V5Lmxlbmd0aCAtIHJlbWFpbmRlcjtcbiAgICBsZXQgaDEgPSBTdHJpbmcucHJvdG90eXBlLnNlZWQ7XG4gICAgY29uc3QgYzEgPSAzNDMyOTE4MzUzO1xuICAgIGNvbnN0IGMyID0gNDYxODQ1OTA3O1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGJ5dGVzKSB7XG4gICAgICBrMSA9IGtleS5jaGFyQ29kZUF0KGkpICYgMjU1IHwgKGtleS5jaGFyQ29kZUF0KCsraSkgJiAyNTUpIDw8IDggfCAoa2V5LmNoYXJDb2RlQXQoKytpKSAmIDI1NSkgPDwgMTYgfCAoa2V5LmNoYXJDb2RlQXQoKytpKSAmIDI1NSkgPDwgMjQ7XG4gICAgICArK2k7XG4gICAgICBrMSA9IChrMSAmIDY1NTM1KSAqIGMxICsgKCgoazEgPj4+IDE2KSAqIGMxICYgNjU1MzUpIDw8IDE2KSAmIDQyOTQ5NjcyOTU7XG4gICAgICBrMSA9IGsxIDw8IDE1IHwgazEgPj4+IDE3O1xuICAgICAgazEgPSAoazEgJiA2NTUzNSkgKiBjMiArICgoKGsxID4+PiAxNikgKiBjMiAmIDY1NTM1KSA8PCAxNikgJiA0Mjk0OTY3Mjk1O1xuICAgICAgaDEgXj0gazE7XG4gICAgICBoMSA9IGgxIDw8IDEzIHwgaDEgPj4+IDE5O1xuICAgICAgaDFiID0gKGgxICYgNjU1MzUpICogNSArICgoKGgxID4+PiAxNikgKiA1ICYgNjU1MzUpIDw8IDE2KSAmIDQyOTQ5NjcyOTU7XG4gICAgICBoMSA9IChoMWIgJiA2NTUzNSkgKyAyNzQ5MiArICgoKGgxYiA+Pj4gMTYpICsgNTg5NjQgJiA2NTUzNSkgPDwgMTYpO1xuICAgIH1cbiAgICBrMSA9IDA7XG4gICAgc3dpdGNoIChyZW1haW5kZXIpIHtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgazEgXj0gKGtleS5jaGFyQ29kZUF0KGkgKyAyKSAmIDI1NSkgPDwgMTY7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGsxIF49IChrZXkuY2hhckNvZGVBdChpICsgMSkgJiAyNTUpIDw8IDg7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGsxIF49IGtleS5jaGFyQ29kZUF0KGkpICYgMjU1O1xuICAgICAgICBrMSA9IChrMSAmIDY1NTM1KSAqIGMxICsgKCgoazEgPj4+IDE2KSAqIGMxICYgNjU1MzUpIDw8IDE2KSAmIDQyOTQ5NjcyOTU7XG4gICAgICAgIGsxID0gazEgPDwgMTUgfCBrMSA+Pj4gMTc7XG4gICAgICAgIGsxID0gKGsxICYgNjU1MzUpICogYzIgKyAoKChrMSA+Pj4gMTYpICogYzIgJiA2NTUzNSkgPDwgMTYpICYgNDI5NDk2NzI5NTtcbiAgICAgICAgaDEgXj0gazE7XG4gICAgfVxuICAgIGgxIF49IGtleS5sZW5ndGg7XG4gICAgaDEgXj0gaDEgPj4+IDE2O1xuICAgIGgxID0gKGgxICYgNjU1MzUpICogMjI0NjgyMjUwNyArICgoKGgxID4+PiAxNikgKiAyMjQ2ODIyNTA3ICYgNjU1MzUpIDw8IDE2KSAmIDQyOTQ5NjcyOTU7XG4gICAgaDEgXj0gaDEgPj4+IDEzO1xuICAgIGgxID0gKGgxICYgNjU1MzUpICogMzI2NjQ4OTkwOSArICgoKGgxID4+PiAxNikgKiAzMjY2NDg5OTA5ICYgNjU1MzUpIDw8IDE2KSAmIDQyOTQ5NjcyOTU7XG4gICAgaDEgXj0gaDEgPj4+IDE2O1xuICAgIHJldHVybiBoMSA+Pj4gMDtcbiAgfTtcbiAgZnVuY3Rpb24gc3RhbmRhcmRFcXVhbHNGdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGEgPyBhLmVxdWFscyhiKSA6IGEgPT0gYjtcbiAgfVxuICBmdW5jdGlvbiBzdGFuZGFyZEhhc2hDb2RlRnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBhID8gYS5oYXNoQ29kZSgpIDogLTE7XG4gIH1cbiAgdmFyIFNldDIgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaGFzaEZ1bmN0aW9uLCBlcXVhbHNGdW5jdGlvbikge1xuICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgICB0aGlzLmhhc2hGdW5jdGlvbiA9IGhhc2hGdW5jdGlvbiB8fCBzdGFuZGFyZEhhc2hDb2RlRnVuY3Rpb247XG4gICAgICB0aGlzLmVxdWFsc0Z1bmN0aW9uID0gZXF1YWxzRnVuY3Rpb24gfHwgc3RhbmRhcmRFcXVhbHNGdW5jdGlvbjtcbiAgICB9XG4gICAgYWRkKHZhbHVlKSB7XG4gICAgICBjb25zdCBoYXNoID0gdGhpcy5oYXNoRnVuY3Rpb24odmFsdWUpO1xuICAgICAgY29uc3Qga2V5ID0gXCJoYXNoX1wiICsgaGFzaDtcbiAgICAgIGlmIChrZXkgaW4gdGhpcy5kYXRhKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuZGF0YVtrZXldO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLmVxdWFsc0Z1bmN0aW9uKHZhbHVlLCB2YWx1ZXNbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGF0YVtrZXldID0gW3ZhbHVlXTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb250YWlucyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KHZhbHVlKSAhPSBudWxsO1xuICAgIH1cbiAgICBnZXQodmFsdWUpIHtcbiAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLmhhc2hGdW5jdGlvbih2YWx1ZSk7XG4gICAgICBjb25zdCBrZXkgPSBcImhhc2hfXCIgKyBoYXNoO1xuICAgICAgaWYgKGtleSBpbiB0aGlzLmRhdGEpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5kYXRhW2tleV07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXF1YWxzRnVuY3Rpb24odmFsdWUsIHZhbHVlc1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgbGV0IGwgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuZGF0YSkge1xuICAgICAgICBpZiAoa2V5LmluZGV4T2YoXCJoYXNoX1wiKSA9PT0gMCkge1xuICAgICAgICAgIGwgPSBsLmNvbmNhdCh0aGlzLmRhdGFba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBhcnJheVRvU3RyaW5nKHRoaXMudmFsdWVzKCkpO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgbGV0IGwgPSAwO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5kYXRhKSB7XG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcImhhc2hfXCIpID09PSAwKSB7XG4gICAgICAgICAgbCA9IGwgKyB0aGlzLmRhdGFba2V5XS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsO1xuICAgIH1cbiAgfTtcbiAgdmFyIEJpdFNldCA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIH1cbiAgICBhZGQodmFsdWUpIHtcbiAgICAgIHRoaXMuZGF0YVt2YWx1ZV0gPSB0cnVlO1xuICAgIH1cbiAgICBvcihzZXQpIHtcbiAgICAgIGNvbnN0IGJpdHMgPSB0aGlzO1xuICAgICAgT2JqZWN0LmtleXMoc2V0LmRhdGEpLm1hcChmdW5jdGlvbihhbHQpIHtcbiAgICAgICAgYml0cy5hZGQoYWx0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmUodmFsdWUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmRhdGFbdmFsdWVdO1xuICAgIH1cbiAgICBjb250YWlucyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YVt2YWx1ZV0gPT09IHRydWU7XG4gICAgfVxuICAgIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmRhdGEpO1xuICAgIH1cbiAgICBtaW5WYWx1ZSgpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShudWxsLCB0aGlzLnZhbHVlcygpKTtcbiAgICB9XG4gICAgaGFzaENvZGUoKSB7XG4gICAgICBjb25zdCBoYXNoID0gbmV3IEhhc2gyKCk7XG4gICAgICBoYXNoLnVwZGF0ZSh0aGlzLnZhbHVlcygpKTtcbiAgICAgIHJldHVybiBoYXNoLmZpbmlzaCgpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgQml0U2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5oYXNoQ29kZSgpID09PSBvdGhlci5oYXNoQ29kZSgpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIntcIiArIHRoaXMudmFsdWVzKCkuam9pbihcIiwgXCIpICsgXCJ9XCI7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXMoKS5sZW5ndGg7XG4gICAgfVxuICB9O1xuICB2YXIgTWFwMiA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoRnVuY3Rpb24sIGVxdWFsc0Z1bmN0aW9uKSB7XG4gICAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICAgIHRoaXMuaGFzaEZ1bmN0aW9uID0gaGFzaEZ1bmN0aW9uIHx8IHN0YW5kYXJkSGFzaENvZGVGdW5jdGlvbjtcbiAgICAgIHRoaXMuZXF1YWxzRnVuY3Rpb24gPSBlcXVhbHNGdW5jdGlvbiB8fCBzdGFuZGFyZEVxdWFsc0Z1bmN0aW9uO1xuICAgIH1cbiAgICBwdXQoa2V5LCB2YWx1ZSkge1xuICAgICAgY29uc3QgaGFzaEtleSA9IFwiaGFzaF9cIiArIHRoaXMuaGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgICBpZiAoaGFzaEtleSBpbiB0aGlzLmRhdGEpIHtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IHRoaXMuZGF0YVtoYXNoS2V5XTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgZW50cnkgPSBlbnRyaWVzW2ldO1xuICAgICAgICAgIGlmICh0aGlzLmVxdWFsc0Z1bmN0aW9uKGtleSwgZW50cnkua2V5KSkge1xuICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgIGVudHJ5LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gb2xkVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVudHJpZXMucHVzaCh7a2V5LCB2YWx1ZX0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRhdGFbaGFzaEtleV0gPSBbe2tleSwgdmFsdWV9XTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb250YWluc0tleShrZXkpIHtcbiAgICAgIGNvbnN0IGhhc2hLZXkgPSBcImhhc2hfXCIgKyB0aGlzLmhhc2hGdW5jdGlvbihrZXkpO1xuICAgICAgaWYgKGhhc2hLZXkgaW4gdGhpcy5kYXRhKSB7XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSB0aGlzLmRhdGFbaGFzaEtleV07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1tpXTtcbiAgICAgICAgICBpZiAodGhpcy5lcXVhbHNGdW5jdGlvbihrZXksIGVudHJ5LmtleSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICBjb25zdCBoYXNoS2V5ID0gXCJoYXNoX1wiICsgdGhpcy5oYXNoRnVuY3Rpb24oa2V5KTtcbiAgICAgIGlmIChoYXNoS2V5IGluIHRoaXMuZGF0YSkge1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gdGhpcy5kYXRhW2hhc2hLZXldO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbaV07XG4gICAgICAgICAgaWYgKHRoaXMuZXF1YWxzRnVuY3Rpb24oa2V5LCBlbnRyeS5rZXkpKVxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgIGxldCBsID0gW107XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmRhdGEpIHtcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKFwiaGFzaF9cIikgPT09IDApIHtcbiAgICAgICAgICBsID0gbC5jb25jYXQodGhpcy5kYXRhW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbDtcbiAgICB9XG4gICAgZ2V0S2V5cygpIHtcbiAgICAgIHJldHVybiB0aGlzLmVudHJpZXMoKS5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gZS5rZXk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VmFsdWVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW50cmllcygpLm1hcChmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBlLnZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgY29uc3Qgc3MgPSB0aGlzLmVudHJpZXMoKS5tYXAoZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIFwie1wiICsgZW50cnkua2V5ICsgXCI6XCIgKyBlbnRyeS52YWx1ZSArIFwifVwiO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gXCJbXCIgKyBzcy5qb2luKFwiLCBcIikgKyBcIl1cIjtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgIGxldCBsID0gMDtcbiAgICAgIGZvciAoY29uc3QgaGFzaEtleSBpbiB0aGlzLmRhdGEpIHtcbiAgICAgICAgaWYgKGhhc2hLZXkuaW5kZXhPZihcImhhc2hfXCIpID09PSAwKSB7XG4gICAgICAgICAgbCA9IGwgKyB0aGlzLmRhdGFbaGFzaEtleV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbDtcbiAgICB9XG4gIH07XG4gIHZhciBBbHREaWN0ID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgIGtleSA9IFwiay1cIiArIGtleTtcbiAgICAgIGlmIChrZXkgaW4gdGhpcy5kYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBwdXQoa2V5LCB2YWx1ZSkge1xuICAgICAga2V5ID0gXCJrLVwiICsga2V5O1xuICAgICAgdGhpcy5kYXRhW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLmRhdGEpO1xuICAgICAgcmV0dXJuIGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICB2YXIgRG91YmxlRGljdCA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihkZWZhdWx0TWFwQ3Rvcikge1xuICAgICAgdGhpcy5kZWZhdWx0TWFwQ3RvciA9IGRlZmF1bHRNYXBDdG9yIHx8IE1hcDI7XG4gICAgICB0aGlzLmNhY2hlTWFwID0gbmV3IHRoaXMuZGVmYXVsdE1hcEN0b3IoKTtcbiAgICB9XG4gICAgZ2V0KGEsIGIpIHtcbiAgICAgIGNvbnN0IGQgPSB0aGlzLmNhY2hlTWFwLmdldChhKSB8fCBudWxsO1xuICAgICAgcmV0dXJuIGQgPT09IG51bGwgPyBudWxsIDogZC5nZXQoYikgfHwgbnVsbDtcbiAgICB9XG4gICAgc2V0KGEsIGIsIG8pIHtcbiAgICAgIGxldCBkID0gdGhpcy5jYWNoZU1hcC5nZXQoYSkgfHwgbnVsbDtcbiAgICAgIGlmIChkID09PSBudWxsKSB7XG4gICAgICAgIGQgPSBuZXcgdGhpcy5kZWZhdWx0TWFwQ3RvcigpO1xuICAgICAgICB0aGlzLmNhY2hlTWFwLnB1dChhLCBkKTtcbiAgICAgIH1cbiAgICAgIGQucHV0KGIsIG8pO1xuICAgIH1cbiAgfTtcbiAgdmFyIEhhc2gyID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICB0aGlzLmhhc2ggPSAwO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgICB0aGlzLnVwZGF0ZS5hcHBseSh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgayA9IHZhbHVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgayA9IHZhbHVlLmhhc2hDb2RlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaWYgKHZhbHVlLnVwZGF0ZUhhc2hDb2RlKVxuICAgICAgICAgICAgICAgIHZhbHVlLnVwZGF0ZUhhc2hDb2RlKHRoaXMpO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJObyB1cGRhdGVIYXNoQ29kZSBmb3IgXCIgKyB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGsgPSBrICogMzQzMjkxODM1MztcbiAgICAgICAgICBrID0gayA8PCAxNSB8IGsgPj4+IDMyIC0gMTU7XG4gICAgICAgICAgayA9IGsgKiA0NjE4NDU5MDc7XG4gICAgICAgICAgdGhpcy5jb3VudCA9IHRoaXMuY291bnQgKyAxO1xuICAgICAgICAgIGxldCBoYXNoID0gdGhpcy5oYXNoIF4gaztcbiAgICAgICAgICBoYXNoID0gaGFzaCA8PCAxMyB8IGhhc2ggPj4+IDMyIC0gMTM7XG4gICAgICAgICAgaGFzaCA9IGhhc2ggKiA1ICsgMzg2NDI5MjE5NjtcbiAgICAgICAgICB0aGlzLmhhc2ggPSBoYXNoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgIGxldCBoYXNoID0gdGhpcy5oYXNoIF4gdGhpcy5jb3VudCAqIDQ7XG4gICAgICBoYXNoID0gaGFzaCBeIGhhc2ggPj4+IDE2O1xuICAgICAgaGFzaCA9IGhhc2ggKiAyMjQ2ODIyNTA3O1xuICAgICAgaGFzaCA9IGhhc2ggXiBoYXNoID4+PiAxMztcbiAgICAgIGhhc2ggPSBoYXNoICogMzI2NjQ4OTkwOTtcbiAgICAgIGhhc2ggPSBoYXNoIF4gaGFzaCA+Pj4gMTY7XG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGhhc2hTdHVmZigpIHtcbiAgICBjb25zdCBoYXNoID0gbmV3IEhhc2gyKCk7XG4gICAgaGFzaC51cGRhdGUuYXBwbHkoaGFzaCwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gaGFzaC5maW5pc2goKTtcbiAgfVxuICBmdW5jdGlvbiBlc2NhcGVXaGl0ZXNwYWNlKHMsIGVzY2FwZVNwYWNlcykge1xuICAgIHMgPSBzLnJlcGxhY2UoL1xcdC9nLCBcIlxcXFx0XCIpLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLnJlcGxhY2UoL1xcci9nLCBcIlxcXFxyXCIpO1xuICAgIGlmIChlc2NhcGVTcGFjZXMpIHtcbiAgICAgIHMgPSBzLnJlcGxhY2UoLyAvZywgXCJcXHhCN1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgZnVuY3Rpb24gdGl0bGVDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFx3XFxTKi9nLCBmdW5jdGlvbih0eHQpIHtcbiAgICAgIHJldHVybiB0eHQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eHQuc3Vic3RyKDEpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGVxdWFsQXJyYXlzKGEsIGIpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYSkgfHwgIUFycmF5LmlzQXJyYXkoYikpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGEgPT09IGIpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gPT09IGJbaV0pXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKCFhW2ldLmVxdWFscyB8fCAhYVtpXS5lcXVhbHMoYltpXSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgIEhhc2g6IEhhc2gyLFxuICAgIFNldDogU2V0MixcbiAgICBNYXA6IE1hcDIsXG4gICAgQml0U2V0LFxuICAgIEFsdERpY3QsXG4gICAgRG91YmxlRGljdCxcbiAgICBoYXNoU3R1ZmYsXG4gICAgZXNjYXBlV2hpdGVzcGFjZSxcbiAgICBhcnJheVRvU3RyaW5nLFxuICAgIHRpdGxlQ2FzZSxcbiAgICBlcXVhbEFycmF5c1xuICB9O1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjQvc3JjL2FudGxyNC9Ub2tlbi5qc1xudmFyIHJlcXVpcmVfVG9rZW4yID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlMikgPT4ge1xuICB2YXIgVG9rZW4yID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICAgICAgdGhpcy50eXBlID0gbnVsbDtcbiAgICAgIHRoaXMuY2hhbm5lbCA9IG51bGw7XG4gICAgICB0aGlzLnN0YXJ0ID0gbnVsbDtcbiAgICAgIHRoaXMuc3RvcCA9IG51bGw7XG4gICAgICB0aGlzLnRva2VuSW5kZXggPSBudWxsO1xuICAgICAgdGhpcy5saW5lID0gbnVsbDtcbiAgICAgIHRoaXMuY29sdW1uID0gbnVsbDtcbiAgICAgIHRoaXMuX3RleHQgPSBudWxsO1xuICAgIH1cbiAgICBnZXRUb2tlblNvdXJjZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZVswXTtcbiAgICB9XG4gICAgZ2V0SW5wdXRTdHJlYW0oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VbMV07XG4gICAgfVxuICAgIGdldCB0ZXh0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RleHQ7XG4gICAgfVxuICAgIHNldCB0ZXh0KHRleHQpIHtcbiAgICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xuICAgIH1cbiAgfTtcbiAgVG9rZW4yLklOVkFMSURfVFlQRSA9IDA7XG4gIFRva2VuMi5FUFNJTE9OID0gLTI7XG4gIFRva2VuMi5NSU5fVVNFUl9UT0tFTl9UWVBFID0gMTtcbiAgVG9rZW4yLkVPRiA9IC0xO1xuICBUb2tlbjIuREVGQVVMVF9DSEFOTkVMID0gMDtcbiAgVG9rZW4yLkhJRERFTl9DSEFOTkVMID0gMTtcbiAgdmFyIENvbW1vblRva2VuID0gY2xhc3MgZXh0ZW5kcyBUb2tlbjIge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgdHlwZSwgY2hhbm5lbCwgc3RhcnQsIHN0b3ApIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZSAhPT0gdm9pZCAwID8gc291cmNlIDogQ29tbW9uVG9rZW4uRU1QVFlfU09VUkNFO1xuICAgICAgdGhpcy50eXBlID0gdHlwZSAhPT0gdm9pZCAwID8gdHlwZSA6IG51bGw7XG4gICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsICE9PSB2b2lkIDAgPyBjaGFubmVsIDogVG9rZW4yLkRFRkFVTFRfQ0hBTk5FTDtcbiAgICAgIHRoaXMuc3RhcnQgPSBzdGFydCAhPT0gdm9pZCAwID8gc3RhcnQgOiAtMTtcbiAgICAgIHRoaXMuc3RvcCA9IHN0b3AgIT09IHZvaWQgMCA/IHN0b3AgOiAtMTtcbiAgICAgIHRoaXMudG9rZW5JbmRleCA9IC0xO1xuICAgICAgaWYgKHRoaXMuc291cmNlWzBdICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMubGluZSA9IHNvdXJjZVswXS5saW5lO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IHNvdXJjZVswXS5jb2x1bW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbHVtbiA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgIGNvbnN0IHQgPSBuZXcgQ29tbW9uVG9rZW4odGhpcy5zb3VyY2UsIHRoaXMudHlwZSwgdGhpcy5jaGFubmVsLCB0aGlzLnN0YXJ0LCB0aGlzLnN0b3ApO1xuICAgICAgdC50b2tlbkluZGV4ID0gdGhpcy50b2tlbkluZGV4O1xuICAgICAgdC5saW5lID0gdGhpcy5saW5lO1xuICAgICAgdC5jb2x1bW4gPSB0aGlzLmNvbHVtbjtcbiAgICAgIHQudGV4dCA9IHRoaXMudGV4dDtcbiAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIGxldCB0eHQgPSB0aGlzLnRleHQ7XG4gICAgICBpZiAodHh0ICE9PSBudWxsKSB7XG4gICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKS5yZXBsYWNlKC9cXHIvZywgXCJcXFxcclwiKS5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR4dCA9IFwiPG5vIHRleHQ+XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJbQFwiICsgdGhpcy50b2tlbkluZGV4ICsgXCIsXCIgKyB0aGlzLnN0YXJ0ICsgXCI6XCIgKyB0aGlzLnN0b3AgKyBcIj0nXCIgKyB0eHQgKyBcIicsPFwiICsgdGhpcy50eXBlICsgXCI+XCIgKyAodGhpcy5jaGFubmVsID4gMCA/IFwiLGNoYW5uZWw9XCIgKyB0aGlzLmNoYW5uZWwgOiBcIlwiKSArIFwiLFwiICsgdGhpcy5saW5lICsgXCI6XCIgKyB0aGlzLmNvbHVtbiArIFwiXVwiO1xuICAgIH1cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgIGlmICh0aGlzLl90ZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0O1xuICAgICAgfVxuICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmdldElucHV0U3RyZWFtKCk7XG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBuID0gaW5wdXQuc2l6ZTtcbiAgICAgIGlmICh0aGlzLnN0YXJ0IDwgbiAmJiB0aGlzLnN0b3AgPCBuKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5nZXRUZXh0KHRoaXMuc3RhcnQsIHRoaXMuc3RvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCI8RU9GPlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXQgdGV4dCh0ZXh0KSB7XG4gICAgICB0aGlzLl90ZXh0ID0gdGV4dDtcbiAgICB9XG4gIH07XG4gIENvbW1vblRva2VuLkVNUFRZX1NPVVJDRSA9IFtudWxsLCBudWxsXTtcbiAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgIFRva2VuOiBUb2tlbjIsXG4gICAgQ29tbW9uVG9rZW5cbiAgfTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0L3NyYy9hbnRscjQvYXRuL0FUTlN0YXRlLmpzXG52YXIgcmVxdWlyZV9BVE5TdGF0ZTIgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUyKSA9PiB7XG4gIHZhciBBVE5TdGF0ZSA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMuYXRuID0gbnVsbDtcbiAgICAgIHRoaXMuc3RhdGVOdW1iZXIgPSBBVE5TdGF0ZS5JTlZBTElEX1NUQVRFX05VTUJFUjtcbiAgICAgIHRoaXMuc3RhdGVUeXBlID0gbnVsbDtcbiAgICAgIHRoaXMucnVsZUluZGV4ID0gMDtcbiAgICAgIHRoaXMuZXBzaWxvbk9ubHlUcmFuc2l0aW9ucyA9IGZhbHNlO1xuICAgICAgdGhpcy50cmFuc2l0aW9ucyA9IFtdO1xuICAgICAgdGhpcy5uZXh0VG9rZW5XaXRoaW5SdWxlID0gbnVsbDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZU51bWJlcjtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBBVE5TdGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZU51bWJlciA9PT0gb3RoZXIuc3RhdGVOdW1iZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlzTm9uR3JlZWR5RXhpdFN0YXRlKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhZGRUcmFuc2l0aW9uKHRyYW5zLCBpbmRleCkge1xuICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRyYW5zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmVwc2lsb25Pbmx5VHJhbnNpdGlvbnMgPSB0cmFucy5pc0Vwc2lsb247XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZXBzaWxvbk9ubHlUcmFuc2l0aW9ucyAhPT0gdHJhbnMuaXNFcHNpbG9uKSB7XG4gICAgICAgIHRoaXMuZXBzaWxvbk9ubHlUcmFuc2l0aW9ucyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25zLnB1c2godHJhbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9ucy5zcGxpY2UoaW5kZXgsIDEsIHRyYW5zKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIEFUTlN0YXRlLklOVkFMSURfVFlQRSA9IDA7XG4gIEFUTlN0YXRlLkJBU0lDID0gMTtcbiAgQVROU3RhdGUuUlVMRV9TVEFSVCA9IDI7XG4gIEFUTlN0YXRlLkJMT0NLX1NUQVJUID0gMztcbiAgQVROU3RhdGUuUExVU19CTE9DS19TVEFSVCA9IDQ7XG4gIEFUTlN0YXRlLlNUQVJfQkxPQ0tfU1RBUlQgPSA1O1xuICBBVE5TdGF0ZS5UT0tFTl9TVEFSVCA9IDY7XG4gIEFUTlN0YXRlLlJVTEVfU1RPUCA9IDc7XG4gIEFUTlN0YXRlLkJMT0NLX0VORCA9IDg7XG4gIEFUTlN0YXRlLlNUQVJfTE9PUF9CQUNLID0gOTtcbiAgQVROU3RhdGUuU1RBUl9MT09QX0VOVFJZID0gMTA7XG4gIEFUTlN0YXRlLlBMVVNfTE9PUF9CQUNLID0gMTE7XG4gIEFUTlN0YXRlLkxPT1BfRU5EID0gMTI7XG4gIEFUTlN0YXRlLnNlcmlhbGl6YXRpb25OYW1lcyA9IFtcbiAgICBcIklOVkFMSURcIixcbiAgICBcIkJBU0lDXCIsXG4gICAgXCJSVUxFX1NUQVJUXCIsXG4gICAgXCJCTE9DS19TVEFSVFwiLFxuICAgIFwiUExVU19CTE9DS19TVEFSVFwiLFxuICAgIFwiU1RBUl9CTE9DS19TVEFSVFwiLFxuICAgIFwiVE9LRU5fU1RBUlRcIixcbiAgICBcIlJVTEVfU1RPUFwiLFxuICAgIFwiQkxPQ0tfRU5EXCIsXG4gICAgXCJTVEFSX0xPT1BfQkFDS1wiLFxuICAgIFwiU1RBUl9MT09QX0VOVFJZXCIsXG4gICAgXCJQTFVTX0xPT1BfQkFDS1wiLFxuICAgIFwiTE9PUF9FTkRcIlxuICBdO1xuICBBVE5TdGF0ZS5JTlZBTElEX1NUQVRFX05VTUJFUiA9IC0xO1xuICB2YXIgQmFzaWNTdGF0ZSA9IGNsYXNzIGV4dGVuZHMgQVROU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuc3RhdGVUeXBlID0gQVROU3RhdGUuQkFTSUM7XG4gICAgfVxuICB9O1xuICB2YXIgRGVjaXNpb25TdGF0ZSA9IGNsYXNzIGV4dGVuZHMgQVROU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuZGVjaXNpb24gPSAtMTtcbiAgICAgIHRoaXMubm9uR3JlZWR5ID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIHZhciBCbG9ja1N0YXJ0U3RhdGUgPSBjbGFzcyBleHRlbmRzIERlY2lzaW9uU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuZW5kU3RhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICB2YXIgQmFzaWNCbG9ja1N0YXJ0U3RhdGUgPSBjbGFzcyBleHRlbmRzIEJsb2NrU3RhcnRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5zdGF0ZVR5cGUgPSBBVE5TdGF0ZS5CTE9DS19TVEFSVDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgdmFyIEJsb2NrRW5kU3RhdGUgPSBjbGFzcyBleHRlbmRzIEFUTlN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLnN0YXRlVHlwZSA9IEFUTlN0YXRlLkJMT0NLX0VORDtcbiAgICAgIHRoaXMuc3RhcnRTdGF0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIHZhciBSdWxlU3RvcFN0YXRlID0gY2xhc3MgZXh0ZW5kcyBBVE5TdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5zdGF0ZVR5cGUgPSBBVE5TdGF0ZS5SVUxFX1NUT1A7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIHZhciBSdWxlU3RhcnRTdGF0ZSA9IGNsYXNzIGV4dGVuZHMgQVROU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuc3RhdGVUeXBlID0gQVROU3RhdGUuUlVMRV9TVEFSVDtcbiAgICAgIHRoaXMuc3RvcFN0YXRlID0gbnVsbDtcbiAgICAgIHRoaXMuaXNQcmVjZWRlbmNlUnVsZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICB2YXIgUGx1c0xvb3BiYWNrU3RhdGUgPSBjbGFzcyBleHRlbmRzIERlY2lzaW9uU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuc3RhdGVUeXBlID0gQVROU3RhdGUuUExVU19MT09QX0JBQ0s7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIHZhciBQbHVzQmxvY2tTdGFydFN0YXRlID0gY2xhc3MgZXh0ZW5kcyBCbG9ja1N0YXJ0U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuc3RhdGVUeXBlID0gQVROU3RhdGUuUExVU19CTE9DS19TVEFSVDtcbiAgICAgIHRoaXMubG9vcEJhY2tTdGF0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIHZhciBTdGFyQmxvY2tTdGFydFN0YXRlID0gY2xhc3MgZXh0ZW5kcyBCbG9ja1N0YXJ0U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuc3RhdGVUeXBlID0gQVROU3RhdGUuU1RBUl9CTE9DS19TVEFSVDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgdmFyIFN0YXJMb29wYmFja1N0YXRlID0gY2xhc3MgZXh0ZW5kcyBBVE5TdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5zdGF0ZVR5cGUgPSBBVE5TdGF0ZS5TVEFSX0xPT1BfQkFDSztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgdmFyIFN0YXJMb29wRW50cnlTdGF0ZSA9IGNsYXNzIGV4dGVuZHMgRGVjaXNpb25TdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5zdGF0ZVR5cGUgPSBBVE5TdGF0ZS5TVEFSX0xPT1BfRU5UUlk7XG4gICAgICB0aGlzLmxvb3BCYWNrU3RhdGUgPSBudWxsO1xuICAgICAgdGhpcy5pc1ByZWNlZGVuY2VEZWNpc2lvbiA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIHZhciBMb29wRW5kU3RhdGUgPSBjbGFzcyBleHRlbmRzIEFUTlN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLnN0YXRlVHlwZSA9IEFUTlN0YXRlLkxPT1BfRU5EO1xuICAgICAgdGhpcy5sb29wQmFja1N0YXRlID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgdmFyIFRva2Vuc1N0YXJ0U3RhdGUgPSBjbGFzcyBleHRlbmRzIERlY2lzaW9uU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuc3RhdGVUeXBlID0gQVROU3RhdGUuVE9LRU5fU1RBUlQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICBBVE5TdGF0ZSxcbiAgICBCYXNpY1N0YXRlLFxuICAgIERlY2lzaW9uU3RhdGUsXG4gICAgQmxvY2tTdGFydFN0YXRlLFxuICAgIEJsb2NrRW5kU3RhdGUsXG4gICAgTG9vcEVuZFN0YXRlLFxuICAgIFJ1bGVTdGFydFN0YXRlLFxuICAgIFJ1bGVTdG9wU3RhdGUsXG4gICAgVG9rZW5zU3RhcnRTdGF0ZSxcbiAgICBQbHVzTG9vcGJhY2tTdGF0ZSxcbiAgICBTdGFyTG9vcGJhY2tTdGF0ZSxcbiAgICBTdGFyTG9vcEVudHJ5U3RhdGUsXG4gICAgUGx1c0Jsb2NrU3RhcnRTdGF0ZSxcbiAgICBTdGFyQmxvY2tTdGFydFN0YXRlLFxuICAgIEJhc2ljQmxvY2tTdGFydFN0YXRlXG4gIH07XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNC9zcmMvYW50bHI0L2F0bi9TZW1hbnRpY0NvbnRleHQuanNcbnZhciByZXF1aXJlX1NlbWFudGljQ29udGV4dDIgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUyKSA9PiB7XG4gIHZhciB7U2V0OiBTZXQyLCBIYXNoOiBIYXNoMiwgZXF1YWxBcnJheXN9ID0gcmVxdWlyZV9VdGlsczIoKTtcbiAgdmFyIFNlbWFudGljQ29udGV4dCA9IGNsYXNzIHtcbiAgICBoYXNoQ29kZSgpIHtcbiAgICAgIGNvbnN0IGhhc2ggPSBuZXcgSGFzaDIoKTtcbiAgICAgIHRoaXMudXBkYXRlSGFzaENvZGUoaGFzaCk7XG4gICAgICByZXR1cm4gaGFzaC5maW5pc2goKTtcbiAgICB9XG4gICAgZXZhbHVhdGUocGFyc2VyLCBvdXRlckNvbnRleHQpIHtcbiAgICB9XG4gICAgZXZhbFByZWNlZGVuY2UocGFyc2VyLCBvdXRlckNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGF0aWMgYW5kQ29udGV4dChhLCBiKSB7XG4gICAgICBpZiAoYSA9PT0gbnVsbCB8fCBhID09PSBTZW1hbnRpY0NvbnRleHQuTk9ORSkge1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH1cbiAgICAgIGlmIChiID09PSBudWxsIHx8IGIgPT09IFNlbWFudGljQ29udGV4dC5OT05FKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFORChhLCBiKTtcbiAgICAgIGlmIChyZXN1bHQub3BuZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQub3BuZHNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgb3JDb250ZXh0KGEsIGIpIHtcbiAgICAgIGlmIChhID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfVxuICAgICAgaWYgKGIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9XG4gICAgICBpZiAoYSA9PT0gU2VtYW50aWNDb250ZXh0Lk5PTkUgfHwgYiA9PT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcbiAgICAgICAgcmV0dXJuIFNlbWFudGljQ29udGV4dC5OT05FO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE9SKGEsIGIpO1xuICAgICAgaWYgKHJlc3VsdC5vcG5kcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5vcG5kc1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgUHJlZGljYXRlID0gY2xhc3MgZXh0ZW5kcyBTZW1hbnRpY0NvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHJ1bGVJbmRleCwgcHJlZEluZGV4LCBpc0N0eERlcGVuZGVudCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMucnVsZUluZGV4ID0gcnVsZUluZGV4ID09PSB2b2lkIDAgPyAtMSA6IHJ1bGVJbmRleDtcbiAgICAgIHRoaXMucHJlZEluZGV4ID0gcHJlZEluZGV4ID09PSB2b2lkIDAgPyAtMSA6IHByZWRJbmRleDtcbiAgICAgIHRoaXMuaXNDdHhEZXBlbmRlbnQgPSBpc0N0eERlcGVuZGVudCA9PT0gdm9pZCAwID8gZmFsc2UgOiBpc0N0eERlcGVuZGVudDtcbiAgICB9XG4gICAgZXZhbHVhdGUocGFyc2VyLCBvdXRlckNvbnRleHQpIHtcbiAgICAgIGNvbnN0IGxvY2FsY3R4ID0gdGhpcy5pc0N0eERlcGVuZGVudCA/IG91dGVyQ29udGV4dCA6IG51bGw7XG4gICAgICByZXR1cm4gcGFyc2VyLnNlbXByZWQobG9jYWxjdHgsIHRoaXMucnVsZUluZGV4LCB0aGlzLnByZWRJbmRleCk7XG4gICAgfVxuICAgIHVwZGF0ZUhhc2hDb2RlKGhhc2gpIHtcbiAgICAgIGhhc2gudXBkYXRlKHRoaXMucnVsZUluZGV4LCB0aGlzLnByZWRJbmRleCwgdGhpcy5pc0N0eERlcGVuZGVudCk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmICghKG90aGVyIGluc3RhbmNlb2YgUHJlZGljYXRlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5ydWxlSW5kZXggPT09IG90aGVyLnJ1bGVJbmRleCAmJiB0aGlzLnByZWRJbmRleCA9PT0gb3RoZXIucHJlZEluZGV4ICYmIHRoaXMuaXNDdHhEZXBlbmRlbnQgPT09IG90aGVyLmlzQ3R4RGVwZW5kZW50O1xuICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIntcIiArIHRoaXMucnVsZUluZGV4ICsgXCI6XCIgKyB0aGlzLnByZWRJbmRleCArIFwifT9cIjtcbiAgICB9XG4gIH07XG4gIFNlbWFudGljQ29udGV4dC5OT05FID0gbmV3IFByZWRpY2F0ZSgpO1xuICB2YXIgUHJlY2VkZW5jZVByZWRpY2F0ZSA9IGNsYXNzIGV4dGVuZHMgU2VtYW50aWNDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihwcmVjZWRlbmNlKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5wcmVjZWRlbmNlID0gcHJlY2VkZW5jZSA9PT0gdm9pZCAwID8gMCA6IHByZWNlZGVuY2U7XG4gICAgfVxuICAgIGV2YWx1YXRlKHBhcnNlciwgb3V0ZXJDb250ZXh0KSB7XG4gICAgICByZXR1cm4gcGFyc2VyLnByZWNwcmVkKG91dGVyQ29udGV4dCwgdGhpcy5wcmVjZWRlbmNlKTtcbiAgICB9XG4gICAgZXZhbFByZWNlZGVuY2UocGFyc2VyLCBvdXRlckNvbnRleHQpIHtcbiAgICAgIGlmIChwYXJzZXIucHJlY3ByZWQob3V0ZXJDb250ZXh0LCB0aGlzLnByZWNlZGVuY2UpKSB7XG4gICAgICAgIHJldHVybiBTZW1hbnRpY0NvbnRleHQuTk9ORTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWNlZGVuY2UgLSBvdGhlci5wcmVjZWRlbmNlO1xuICAgIH1cbiAgICB1cGRhdGVIYXNoQ29kZShoYXNoKSB7XG4gICAgICBoYXNoLnVwZGF0ZSh0aGlzLnByZWNlZGVuY2UpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFByZWNlZGVuY2VQcmVkaWNhdGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZWNlZGVuY2UgPT09IG90aGVyLnByZWNlZGVuY2U7XG4gICAgICB9XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwie1wiICsgdGhpcy5wcmVjZWRlbmNlICsgXCI+PXByZWN9P1wiO1xuICAgIH1cbiAgICBzdGF0aWMgZmlsdGVyUHJlY2VkZW5jZVByZWRpY2F0ZXMoc2V0KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgIHNldC52YWx1ZXMoKS5tYXAoZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCBpbnN0YW5jZW9mIFByZWNlZGVuY2VQcmVkaWNhdGUpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcbiAgdmFyIEFORCA9IGNsYXNzIGV4dGVuZHMgU2VtYW50aWNDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihhLCBiKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgY29uc3Qgb3BlcmFuZHMgPSBuZXcgU2V0MigpO1xuICAgICAgaWYgKGEgaW5zdGFuY2VvZiBBTkQpIHtcbiAgICAgICAgYS5vcG5kcy5tYXAoZnVuY3Rpb24obykge1xuICAgICAgICAgIG9wZXJhbmRzLmFkZChvKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcGVyYW5kcy5hZGQoYSk7XG4gICAgICB9XG4gICAgICBpZiAoYiBpbnN0YW5jZW9mIEFORCkge1xuICAgICAgICBiLm9wbmRzLm1hcChmdW5jdGlvbihvKSB7XG4gICAgICAgICAgb3BlcmFuZHMuYWRkKG8pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wZXJhbmRzLmFkZChiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZWNlZGVuY2VQcmVkaWNhdGVzID0gUHJlY2VkZW5jZVByZWRpY2F0ZS5maWx0ZXJQcmVjZWRlbmNlUHJlZGljYXRlcyhvcGVyYW5kcyk7XG4gICAgICBpZiAocHJlY2VkZW5jZVByZWRpY2F0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgcmVkdWNlZCA9IG51bGw7XG4gICAgICAgIHByZWNlZGVuY2VQcmVkaWNhdGVzLm1hcChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgaWYgKHJlZHVjZWQgPT09IG51bGwgfHwgcC5wcmVjZWRlbmNlIDwgcmVkdWNlZC5wcmVjZWRlbmNlKSB7XG4gICAgICAgICAgICByZWR1Y2VkID0gcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvcGVyYW5kcy5hZGQocmVkdWNlZCk7XG4gICAgICB9XG4gICAgICB0aGlzLm9wbmRzID0gQXJyYXkuZnJvbShvcGVyYW5kcy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmICghKG90aGVyIGluc3RhbmNlb2YgQU5EKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZXF1YWxBcnJheXModGhpcy5vcG5kcywgb3RoZXIub3BuZHMpO1xuICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVIYXNoQ29kZShoYXNoKSB7XG4gICAgICBoYXNoLnVwZGF0ZSh0aGlzLm9wbmRzLCBcIkFORFwiKTtcbiAgICB9XG4gICAgZXZhbHVhdGUocGFyc2VyLCBvdXRlckNvbnRleHQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vcG5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMub3BuZHNbaV0uZXZhbHVhdGUocGFyc2VyLCBvdXRlckNvbnRleHQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZXZhbFByZWNlZGVuY2UocGFyc2VyLCBvdXRlckNvbnRleHQpIHtcbiAgICAgIGxldCBkaWZmZXJzID0gZmFsc2U7XG4gICAgICBjb25zdCBvcGVyYW5kcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9wbmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLm9wbmRzW2ldO1xuICAgICAgICBjb25zdCBldmFsdWF0ZWQgPSBjb250ZXh0LmV2YWxQcmVjZWRlbmNlKHBhcnNlciwgb3V0ZXJDb250ZXh0KTtcbiAgICAgICAgZGlmZmVycyB8PSBldmFsdWF0ZWQgIT09IGNvbnRleHQ7XG4gICAgICAgIGlmIChldmFsdWF0ZWQgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChldmFsdWF0ZWQgIT09IFNlbWFudGljQ29udGV4dC5OT05FKSB7XG4gICAgICAgICAgb3BlcmFuZHMucHVzaChldmFsdWF0ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWRpZmZlcnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAob3BlcmFuZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBTZW1hbnRpY0NvbnRleHQuTk9ORTtcbiAgICAgIH1cbiAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgb3BlcmFuZHMubWFwKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSBudWxsID8gbyA6IFNlbWFudGljQ29udGV4dC5hbmRDb250ZXh0KHJlc3VsdCwgbyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgY29uc3QgcyA9IHRoaXMub3BuZHMubWFwKChvKSA9PiBvLnRvU3RyaW5nKCkpO1xuICAgICAgcmV0dXJuIChzLmxlbmd0aCA+IDMgPyBzLnNsaWNlKDMpIDogcykuam9pbihcIiYmXCIpO1xuICAgIH1cbiAgfTtcbiAgdmFyIE9SID0gY2xhc3MgZXh0ZW5kcyBTZW1hbnRpY0NvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKGEsIGIpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICBjb25zdCBvcGVyYW5kcyA9IG5ldyBTZXQyKCk7XG4gICAgICBpZiAoYSBpbnN0YW5jZW9mIE9SKSB7XG4gICAgICAgIGEub3BuZHMubWFwKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICBvcGVyYW5kcy5hZGQobyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3BlcmFuZHMuYWRkKGEpO1xuICAgICAgfVxuICAgICAgaWYgKGIgaW5zdGFuY2VvZiBPUikge1xuICAgICAgICBiLm9wbmRzLm1hcChmdW5jdGlvbihvKSB7XG4gICAgICAgICAgb3BlcmFuZHMuYWRkKG8pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wZXJhbmRzLmFkZChiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZWNlZGVuY2VQcmVkaWNhdGVzID0gUHJlY2VkZW5jZVByZWRpY2F0ZS5maWx0ZXJQcmVjZWRlbmNlUHJlZGljYXRlcyhvcGVyYW5kcyk7XG4gICAgICBpZiAocHJlY2VkZW5jZVByZWRpY2F0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBzID0gcHJlY2VkZW5jZVByZWRpY2F0ZXMuc29ydChmdW5jdGlvbihhMiwgYjIpIHtcbiAgICAgICAgICByZXR1cm4gYTIuY29tcGFyZVRvKGIyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlZHVjZWQgPSBzW3MubGVuZ3RoIC0gMV07XG4gICAgICAgIG9wZXJhbmRzLmFkZChyZWR1Y2VkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3BuZHMgPSBBcnJheS5mcm9tKG9wZXJhbmRzLnZhbHVlcygpKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBPUikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVxdWFsQXJyYXlzKHRoaXMub3BuZHMsIG90aGVyLm9wbmRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlSGFzaENvZGUoaGFzaCkge1xuICAgICAgaGFzaC51cGRhdGUodGhpcy5vcG5kcywgXCJPUlwiKTtcbiAgICB9XG4gICAgZXZhbHVhdGUocGFyc2VyLCBvdXRlckNvbnRleHQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vcG5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5vcG5kc1tpXS5ldmFsdWF0ZShwYXJzZXIsIG91dGVyQ29udGV4dCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBldmFsUHJlY2VkZW5jZShwYXJzZXIsIG91dGVyQ29udGV4dCkge1xuICAgICAgbGV0IGRpZmZlcnMgPSBmYWxzZTtcbiAgICAgIGNvbnN0IG9wZXJhbmRzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3BuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMub3BuZHNbaV07XG4gICAgICAgIGNvbnN0IGV2YWx1YXRlZCA9IGNvbnRleHQuZXZhbFByZWNlZGVuY2UocGFyc2VyLCBvdXRlckNvbnRleHQpO1xuICAgICAgICBkaWZmZXJzIHw9IGV2YWx1YXRlZCAhPT0gY29udGV4dDtcbiAgICAgICAgaWYgKGV2YWx1YXRlZCA9PT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcbiAgICAgICAgICByZXR1cm4gU2VtYW50aWNDb250ZXh0Lk5PTkU7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZhbHVhdGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgb3BlcmFuZHMucHVzaChldmFsdWF0ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWRpZmZlcnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAob3BlcmFuZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gbnVsbDtcbiAgICAgIG9wZXJhbmRzLm1hcChmdW5jdGlvbihvKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IG51bGwgPyBvIDogU2VtYW50aWNDb250ZXh0Lm9yQ29udGV4dChyZXN1bHQsIG8pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLm9wbmRzLm1hcCgobykgPT4gby50b1N0cmluZygpKTtcbiAgICAgIHJldHVybiAocy5sZW5ndGggPiAzID8gcy5zbGljZSgzKSA6IHMpLmpvaW4oXCJ8fFwiKTtcbiAgICB9XG4gIH07XG4gIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICBTZW1hbnRpY0NvbnRleHQsXG4gICAgUHJlY2VkZW5jZVByZWRpY2F0ZSxcbiAgICBQcmVkaWNhdGVcbiAgfTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0L3NyYy9hbnRscjQvYXRuL0FUTkNvbmZpZy5qc1xudmFyIHJlcXVpcmVfQVROQ29uZmlnMiA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZTIpID0+IHtcbiAgdmFyIHtEZWNpc2lvblN0YXRlfSA9IHJlcXVpcmVfQVROU3RhdGUyKCk7XG4gIHZhciB7U2VtYW50aWNDb250ZXh0fSA9IHJlcXVpcmVfU2VtYW50aWNDb250ZXh0MigpO1xuICB2YXIge0hhc2g6IEhhc2gyfSA9IHJlcXVpcmVfVXRpbHMyKCk7XG4gIGZ1bmN0aW9uIGNoZWNrUGFyYW1zKHBhcmFtcywgaXNDZmcpIHtcbiAgICBpZiAocGFyYW1zID09PSBudWxsKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7c3RhdGU6IG51bGwsIGFsdDogbnVsbCwgY29udGV4dDogbnVsbCwgc2VtYW50aWNDb250ZXh0OiBudWxsfTtcbiAgICAgIGlmIChpc0NmZykge1xuICAgICAgICByZXN1bHQucmVhY2hlc0ludG9PdXRlckNvbnRleHQgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcHJvcHMgPSB7fTtcbiAgICAgIHByb3BzLnN0YXRlID0gcGFyYW1zLnN0YXRlIHx8IG51bGw7XG4gICAgICBwcm9wcy5hbHQgPSBwYXJhbXMuYWx0ID09PSB2b2lkIDAgPyBudWxsIDogcGFyYW1zLmFsdDtcbiAgICAgIHByb3BzLmNvbnRleHQgPSBwYXJhbXMuY29udGV4dCB8fCBudWxsO1xuICAgICAgcHJvcHMuc2VtYW50aWNDb250ZXh0ID0gcGFyYW1zLnNlbWFudGljQ29udGV4dCB8fCBudWxsO1xuICAgICAgaWYgKGlzQ2ZnKSB7XG4gICAgICAgIHByb3BzLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0ID0gcGFyYW1zLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0IHx8IDA7XG4gICAgICAgIHByb3BzLnByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkID0gcGFyYW1zLnByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkIHx8IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH1cbiAgfVxuICB2YXIgQVROQ29uZmlnID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcywgY29uZmlnKSB7XG4gICAgICB0aGlzLmNoZWNrQ29udGV4dChwYXJhbXMsIGNvbmZpZyk7XG4gICAgICBwYXJhbXMgPSBjaGVja1BhcmFtcyhwYXJhbXMpO1xuICAgICAgY29uZmlnID0gY2hlY2tQYXJhbXMoY29uZmlnLCB0cnVlKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBwYXJhbXMuc3RhdGUgIT09IG51bGwgPyBwYXJhbXMuc3RhdGUgOiBjb25maWcuc3RhdGU7XG4gICAgICB0aGlzLmFsdCA9IHBhcmFtcy5hbHQgIT09IG51bGwgPyBwYXJhbXMuYWx0IDogY29uZmlnLmFsdDtcbiAgICAgIHRoaXMuY29udGV4dCA9IHBhcmFtcy5jb250ZXh0ICE9PSBudWxsID8gcGFyYW1zLmNvbnRleHQgOiBjb25maWcuY29udGV4dDtcbiAgICAgIHRoaXMuc2VtYW50aWNDb250ZXh0ID0gcGFyYW1zLnNlbWFudGljQ29udGV4dCAhPT0gbnVsbCA/IHBhcmFtcy5zZW1hbnRpY0NvbnRleHQgOiBjb25maWcuc2VtYW50aWNDb250ZXh0ICE9PSBudWxsID8gY29uZmlnLnNlbWFudGljQ29udGV4dCA6IFNlbWFudGljQ29udGV4dC5OT05FO1xuICAgICAgdGhpcy5yZWFjaGVzSW50b091dGVyQ29udGV4dCA9IGNvbmZpZy5yZWFjaGVzSW50b091dGVyQ29udGV4dDtcbiAgICAgIHRoaXMucHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWQgPSBjb25maWcucHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWQ7XG4gICAgfVxuICAgIGNoZWNrQ29udGV4dChwYXJhbXMsIGNvbmZpZykge1xuICAgICAgaWYgKChwYXJhbXMuY29udGV4dCA9PT0gbnVsbCB8fCBwYXJhbXMuY29udGV4dCA9PT0gdm9pZCAwKSAmJiAoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZy5jb250ZXh0ID09PSBudWxsIHx8IGNvbmZpZy5jb250ZXh0ID09PSB2b2lkIDApKSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGhhc2hDb2RlKCkge1xuICAgICAgY29uc3QgaGFzaCA9IG5ldyBIYXNoMigpO1xuICAgICAgdGhpcy51cGRhdGVIYXNoQ29kZShoYXNoKTtcbiAgICAgIHJldHVybiBoYXNoLmZpbmlzaCgpO1xuICAgIH1cbiAgICB1cGRhdGVIYXNoQ29kZShoYXNoKSB7XG4gICAgICBoYXNoLnVwZGF0ZSh0aGlzLnN0YXRlLnN0YXRlTnVtYmVyLCB0aGlzLmFsdCwgdGhpcy5jb250ZXh0LCB0aGlzLnNlbWFudGljQ29udGV4dCk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmICghKG90aGVyIGluc3RhbmNlb2YgQVROQ29uZmlnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zdGF0ZU51bWJlciA9PT0gb3RoZXIuc3RhdGUuc3RhdGVOdW1iZXIgJiYgdGhpcy5hbHQgPT09IG90aGVyLmFsdCAmJiAodGhpcy5jb250ZXh0ID09PSBudWxsID8gb3RoZXIuY29udGV4dCA9PT0gbnVsbCA6IHRoaXMuY29udGV4dC5lcXVhbHMob3RoZXIuY29udGV4dCkpICYmIHRoaXMuc2VtYW50aWNDb250ZXh0LmVxdWFscyhvdGhlci5zZW1hbnRpY0NvbnRleHQpICYmIHRoaXMucHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWQgPT09IG90aGVyLnByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkO1xuICAgICAgfVxuICAgIH1cbiAgICBoYXNoQ29kZUZvckNvbmZpZ1NldCgpIHtcbiAgICAgIGNvbnN0IGhhc2ggPSBuZXcgSGFzaDIoKTtcbiAgICAgIGhhc2gudXBkYXRlKHRoaXMuc3RhdGUuc3RhdGVOdW1iZXIsIHRoaXMuYWx0LCB0aGlzLnNlbWFudGljQ29udGV4dCk7XG4gICAgICByZXR1cm4gaGFzaC5maW5pc2goKTtcbiAgICB9XG4gICAgZXF1YWxzRm9yQ29uZmlnU2V0KG90aGVyKSB7XG4gICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBBVE5Db25maWcpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnN0YXRlTnVtYmVyID09PSBvdGhlci5zdGF0ZS5zdGF0ZU51bWJlciAmJiB0aGlzLmFsdCA9PT0gb3RoZXIuYWx0ICYmIHRoaXMuc2VtYW50aWNDb250ZXh0LmVxdWFscyhvdGhlci5zZW1hbnRpY0NvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIihcIiArIHRoaXMuc3RhdGUgKyBcIixcIiArIHRoaXMuYWx0ICsgKHRoaXMuY29udGV4dCAhPT0gbnVsbCA/IFwiLFtcIiArIHRoaXMuY29udGV4dC50b1N0cmluZygpICsgXCJdXCIgOiBcIlwiKSArICh0aGlzLnNlbWFudGljQ29udGV4dCAhPT0gU2VtYW50aWNDb250ZXh0Lk5PTkUgPyBcIixcIiArIHRoaXMuc2VtYW50aWNDb250ZXh0LnRvU3RyaW5nKCkgOiBcIlwiKSArICh0aGlzLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0ID4gMCA/IFwiLHVwPVwiICsgdGhpcy5yZWFjaGVzSW50b091dGVyQ29udGV4dCA6IFwiXCIpICsgXCIpXCI7XG4gICAgfVxuICB9O1xuICB2YXIgTGV4ZXJBVE5Db25maWcgPSBjbGFzcyBleHRlbmRzIEFUTkNvbmZpZyB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zLCBjb25maWcpIHtcbiAgICAgIHN1cGVyKHBhcmFtcywgY29uZmlnKTtcbiAgICAgIGNvbnN0IGxleGVyQWN0aW9uRXhlY3V0b3IgPSBwYXJhbXMubGV4ZXJBY3Rpb25FeGVjdXRvciB8fCBudWxsO1xuICAgICAgdGhpcy5sZXhlckFjdGlvbkV4ZWN1dG9yID0gbGV4ZXJBY3Rpb25FeGVjdXRvciB8fCAoY29uZmlnICE9PSBudWxsID8gY29uZmlnLmxleGVyQWN0aW9uRXhlY3V0b3IgOiBudWxsKTtcbiAgICAgIHRoaXMucGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uID0gY29uZmlnICE9PSBudWxsID8gdGhpcy5jaGVja05vbkdyZWVkeURlY2lzaW9uKGNvbmZpZywgdGhpcy5zdGF0ZSkgOiBmYWxzZTtcbiAgICAgIHRoaXMuaGFzaENvZGVGb3JDb25maWdTZXQgPSBMZXhlckFUTkNvbmZpZy5wcm90b3R5cGUuaGFzaENvZGU7XG4gICAgICB0aGlzLmVxdWFsc0ZvckNvbmZpZ1NldCA9IExleGVyQVROQ29uZmlnLnByb3RvdHlwZS5lcXVhbHM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdXBkYXRlSGFzaENvZGUoaGFzaCkge1xuICAgICAgaGFzaC51cGRhdGUodGhpcy5zdGF0ZS5zdGF0ZU51bWJlciwgdGhpcy5hbHQsIHRoaXMuY29udGV4dCwgdGhpcy5zZW1hbnRpY0NvbnRleHQsIHRoaXMucGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uLCB0aGlzLmxleGVyQWN0aW9uRXhlY3V0b3IpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzID09PSBvdGhlciB8fCBvdGhlciBpbnN0YW5jZW9mIExleGVyQVROQ29uZmlnICYmIHRoaXMucGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uID09PSBvdGhlci5wYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb24gJiYgKHRoaXMubGV4ZXJBY3Rpb25FeGVjdXRvciA/IHRoaXMubGV4ZXJBY3Rpb25FeGVjdXRvci5lcXVhbHMob3RoZXIubGV4ZXJBY3Rpb25FeGVjdXRvcikgOiAhb3RoZXIubGV4ZXJBY3Rpb25FeGVjdXRvcikgJiYgc3VwZXIuZXF1YWxzKG90aGVyKTtcbiAgICB9XG4gICAgY2hlY2tOb25HcmVlZHlEZWNpc2lvbihzb3VyY2UsIHRhcmdldCkge1xuICAgICAgcmV0dXJuIHNvdXJjZS5wYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb24gfHwgdGFyZ2V0IGluc3RhbmNlb2YgRGVjaXNpb25TdGF0ZSAmJiB0YXJnZXQubm9uR3JlZWR5O1xuICAgIH1cbiAgfTtcbiAgbW9kdWxlMi5leHBvcnRzLkFUTkNvbmZpZyA9IEFUTkNvbmZpZztcbiAgbW9kdWxlMi5leHBvcnRzLkxleGVyQVROQ29uZmlnID0gTGV4ZXJBVE5Db25maWc7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNC9zcmMvYW50bHI0L0ludGVydmFsU2V0LmpzXG52YXIgcmVxdWlyZV9JbnRlcnZhbFNldDIgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUyKSA9PiB7XG4gIHZhciB7VG9rZW46IFRva2VuMn0gPSByZXF1aXJlX1Rva2VuMigpO1xuICB2YXIgSW50ZXJ2YWwgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnQsIHN0b3ApIHtcbiAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgIHRoaXMuc3RvcCA9IHN0b3A7XG4gICAgfVxuICAgIGNvbnRhaW5zKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtID49IHRoaXMuc3RhcnQgJiYgaXRlbSA8IHRoaXMuc3RvcDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICBpZiAodGhpcy5zdGFydCA9PT0gdGhpcy5zdG9wIC0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydC50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQudG9TdHJpbmcoKSArIFwiLi5cIiArICh0aGlzLnN0b3AgLSAxKS50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RvcCAtIHRoaXMuc3RhcnQ7XG4gICAgfVxuICB9O1xuICB2YXIgSW50ZXJ2YWxTZXQgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLmludGVydmFscyA9IG51bGw7XG4gICAgICB0aGlzLnJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfVxuICAgIGZpcnN0KHYpIHtcbiAgICAgIGlmICh0aGlzLmludGVydmFscyA9PT0gbnVsbCB8fCB0aGlzLmludGVydmFscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFRva2VuMi5JTlZBTElEX1RZUEU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnZhbHNbMF0uc3RhcnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGFkZE9uZSh2KSB7XG4gICAgICB0aGlzLmFkZEludGVydmFsKG5ldyBJbnRlcnZhbCh2LCB2ICsgMSkpO1xuICAgIH1cbiAgICBhZGRSYW5nZShsLCBoKSB7XG4gICAgICB0aGlzLmFkZEludGVydmFsKG5ldyBJbnRlcnZhbChsLCBoICsgMSkpO1xuICAgIH1cbiAgICBhZGRJbnRlcnZhbCh0b0FkZCkge1xuICAgICAgaWYgKHRoaXMuaW50ZXJ2YWxzID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxzID0gW107XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxzLnB1c2godG9BZGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgdGhpcy5pbnRlcnZhbHMubGVuZ3RoOyBwb3MrKykge1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5pbnRlcnZhbHNbcG9zXTtcbiAgICAgICAgICBpZiAodG9BZGQuc3RvcCA8IGV4aXN0aW5nLnN0YXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmludGVydmFscy5zcGxpY2UocG9zLCAwLCB0b0FkZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmICh0b0FkZC5zdG9wID09PSBleGlzdGluZy5zdGFydCkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbHNbcG9zXS5zdGFydCA9IHRvQWRkLnN0YXJ0O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9BZGQuc3RhcnQgPD0gZXhpc3Rpbmcuc3RvcCkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbHNbcG9zXSA9IG5ldyBJbnRlcnZhbChNYXRoLm1pbihleGlzdGluZy5zdGFydCwgdG9BZGQuc3RhcnQpLCBNYXRoLm1heChleGlzdGluZy5zdG9wLCB0b0FkZC5zdG9wKSk7XG4gICAgICAgICAgICB0aGlzLnJlZHVjZShwb3MpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVydmFscy5wdXNoKHRvQWRkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYWRkU2V0KG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIuaW50ZXJ2YWxzICE9PSBudWxsKSB7XG4gICAgICAgIG90aGVyLmludGVydmFscy5mb3JFYWNoKCh0b0FkZCkgPT4gdGhpcy5hZGRJbnRlcnZhbCh0b0FkZCksIHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlZHVjZShwb3MpIHtcbiAgICAgIGlmIChwb3MgPCB0aGlzLmludGVydmFscy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmludGVydmFsc1twb3NdO1xuICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnRlcnZhbHNbcG9zICsgMV07XG4gICAgICAgIGlmIChjdXJyZW50LnN0b3AgPj0gbmV4dC5zdG9wKSB7XG4gICAgICAgICAgdGhpcy5pbnRlcnZhbHMuc3BsaWNlKHBvcyArIDEsIDEpO1xuICAgICAgICAgIHRoaXMucmVkdWNlKHBvcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudC5zdG9wID49IG5leHQuc3RhcnQpIHtcbiAgICAgICAgICB0aGlzLmludGVydmFsc1twb3NdID0gbmV3IEludGVydmFsKGN1cnJlbnQuc3RhcnQsIG5leHQuc3RvcCk7XG4gICAgICAgICAgdGhpcy5pbnRlcnZhbHMuc3BsaWNlKHBvcyArIDEsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbXBsZW1lbnQoc3RhcnQsIHN0b3ApIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBJbnRlcnZhbFNldCgpO1xuICAgICAgcmVzdWx0LmFkZEludGVydmFsKG5ldyBJbnRlcnZhbChzdGFydCwgc3RvcCArIDEpKTtcbiAgICAgIGlmICh0aGlzLmludGVydmFscyAhPT0gbnVsbClcbiAgICAgICAgdGhpcy5pbnRlcnZhbHMuZm9yRWFjaCgodG9SZW1vdmUpID0+IHJlc3VsdC5yZW1vdmVSYW5nZSh0b1JlbW92ZSkpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29udGFpbnMoaXRlbSkge1xuICAgICAgaWYgKHRoaXMuaW50ZXJ2YWxzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGhpcy5pbnRlcnZhbHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5pbnRlcnZhbHNba10uY29udGFpbnMoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZVJhbmdlKHRvUmVtb3ZlKSB7XG4gICAgICBpZiAodG9SZW1vdmUuc3RhcnQgPT09IHRvUmVtb3ZlLnN0b3AgLSAxKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlT25lKHRvUmVtb3ZlLnN0YXJ0KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pbnRlcnZhbHMgIT09IG51bGwpIHtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgdGhpcy5pbnRlcnZhbHMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuaW50ZXJ2YWxzW3Bvc107XG4gICAgICAgICAgaWYgKHRvUmVtb3ZlLnN0b3AgPD0gZXhpc3Rpbmcuc3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRvUmVtb3ZlLnN0YXJ0ID4gZXhpc3Rpbmcuc3RhcnQgJiYgdG9SZW1vdmUuc3RvcCA8IGV4aXN0aW5nLnN0b3ApIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxzW3Bvc10gPSBuZXcgSW50ZXJ2YWwoZXhpc3Rpbmcuc3RhcnQsIHRvUmVtb3ZlLnN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBuZXcgSW50ZXJ2YWwodG9SZW1vdmUuc3RvcCwgZXhpc3Rpbmcuc3RvcCk7XG4gICAgICAgICAgICB0aGlzLmludGVydmFscy5zcGxpY2UocG9zLCAwLCB4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRvUmVtb3ZlLnN0YXJ0IDw9IGV4aXN0aW5nLnN0YXJ0ICYmIHRvUmVtb3ZlLnN0b3AgPj0gZXhpc3Rpbmcuc3RvcCkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbHMuc3BsaWNlKHBvcywgMSk7XG4gICAgICAgICAgICBwb3MgPSBwb3MgLSAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9SZW1vdmUuc3RhcnQgPCBleGlzdGluZy5zdG9wKSB7XG4gICAgICAgICAgICB0aGlzLmludGVydmFsc1twb3NdID0gbmV3IEludGVydmFsKGV4aXN0aW5nLnN0YXJ0LCB0b1JlbW92ZS5zdGFydCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0b1JlbW92ZS5zdG9wIDwgZXhpc3Rpbmcuc3RvcCkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbHNbcG9zXSA9IG5ldyBJbnRlcnZhbCh0b1JlbW92ZS5zdG9wLCBleGlzdGluZy5zdG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlT25lKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5pbnRlcnZhbHMgIT09IG51bGwpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmludGVydmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5pbnRlcnZhbHNbaV07XG4gICAgICAgICAgaWYgKHZhbHVlIDwgZXhpc3Rpbmcuc3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBleGlzdGluZy5zdGFydCAmJiB2YWx1ZSA9PT0gZXhpc3Rpbmcuc3RvcCAtIDEpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBleGlzdGluZy5zdGFydCkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbHNbaV0gPSBuZXcgSW50ZXJ2YWwoZXhpc3Rpbmcuc3RhcnQgKyAxLCBleGlzdGluZy5zdG9wKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBleGlzdGluZy5zdG9wIC0gMSkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbHNbaV0gPSBuZXcgSW50ZXJ2YWwoZXhpc3Rpbmcuc3RhcnQsIGV4aXN0aW5nLnN0b3AgLSAxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIDwgZXhpc3Rpbmcuc3RvcCAtIDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcGxhY2UgPSBuZXcgSW50ZXJ2YWwoZXhpc3Rpbmcuc3RhcnQsIHZhbHVlKTtcbiAgICAgICAgICAgIGV4aXN0aW5nLnN0YXJ0ID0gdmFsdWUgKyAxO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbHMuc3BsaWNlKGksIDAsIHJlcGxhY2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZyhsaXRlcmFsTmFtZXMsIHN5bWJvbGljTmFtZXMsIGVsZW1zQXJlQ2hhcikge1xuICAgICAgbGl0ZXJhbE5hbWVzID0gbGl0ZXJhbE5hbWVzIHx8IG51bGw7XG4gICAgICBzeW1ib2xpY05hbWVzID0gc3ltYm9saWNOYW1lcyB8fCBudWxsO1xuICAgICAgZWxlbXNBcmVDaGFyID0gZWxlbXNBcmVDaGFyIHx8IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuaW50ZXJ2YWxzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcInt9XCI7XG4gICAgICB9IGVsc2UgaWYgKGxpdGVyYWxOYW1lcyAhPT0gbnVsbCB8fCBzeW1ib2xpY05hbWVzICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvVG9rZW5TdHJpbmcobGl0ZXJhbE5hbWVzLCBzeW1ib2xpY05hbWVzKTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbXNBcmVDaGFyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQ2hhclN0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9JbmRleFN0cmluZygpO1xuICAgICAgfVxuICAgIH1cbiAgICB0b0NoYXJTdHJpbmcoKSB7XG4gICAgICBjb25zdCBuYW1lcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmludGVydmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuaW50ZXJ2YWxzW2ldO1xuICAgICAgICBpZiAoZXhpc3Rpbmcuc3RvcCA9PT0gZXhpc3Rpbmcuc3RhcnQgKyAxKSB7XG4gICAgICAgICAgaWYgKGV4aXN0aW5nLnN0YXJ0ID09PSBUb2tlbjIuRU9GKSB7XG4gICAgICAgICAgICBuYW1lcy5wdXNoKFwiPEVPRj5cIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5hbWVzLnB1c2goXCInXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGV4aXN0aW5nLnN0YXJ0KSArIFwiJ1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZXMucHVzaChcIidcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUoZXhpc3Rpbmcuc3RhcnQpICsgXCInLi4nXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGV4aXN0aW5nLnN0b3AgLSAxKSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5hbWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIFwie1wiICsgbmFtZXMuam9pbihcIiwgXCIpICsgXCJ9XCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmFtZXNbMF07XG4gICAgICB9XG4gICAgfVxuICAgIHRvSW5kZXhTdHJpbmcoKSB7XG4gICAgICBjb25zdCBuYW1lcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmludGVydmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuaW50ZXJ2YWxzW2ldO1xuICAgICAgICBpZiAoZXhpc3Rpbmcuc3RvcCA9PT0gZXhpc3Rpbmcuc3RhcnQgKyAxKSB7XG4gICAgICAgICAgaWYgKGV4aXN0aW5nLnN0YXJ0ID09PSBUb2tlbjIuRU9GKSB7XG4gICAgICAgICAgICBuYW1lcy5wdXNoKFwiPEVPRj5cIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5hbWVzLnB1c2goZXhpc3Rpbmcuc3RhcnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5hbWVzLnB1c2goZXhpc3Rpbmcuc3RhcnQudG9TdHJpbmcoKSArIFwiLi5cIiArIChleGlzdGluZy5zdG9wIC0gMSkudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChuYW1lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJldHVybiBcIntcIiArIG5hbWVzLmpvaW4oXCIsIFwiKSArIFwifVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5hbWVzWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICB0b1Rva2VuU3RyaW5nKGxpdGVyYWxOYW1lcywgc3ltYm9saWNOYW1lcykge1xuICAgICAgY29uc3QgbmFtZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbnRlcnZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLmludGVydmFsc1tpXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IGV4aXN0aW5nLnN0YXJ0OyBqIDwgZXhpc3Rpbmcuc3RvcDsgaisrKSB7XG4gICAgICAgICAgbmFtZXMucHVzaCh0aGlzLmVsZW1lbnROYW1lKGxpdGVyYWxOYW1lcywgc3ltYm9saWNOYW1lcywgaikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobmFtZXMubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyBuYW1lcy5qb2luKFwiLCBcIikgKyBcIn1cIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuYW1lc1swXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudE5hbWUobGl0ZXJhbE5hbWVzLCBzeW1ib2xpY05hbWVzLCB0b2tlbikge1xuICAgICAgaWYgKHRva2VuID09PSBUb2tlbjIuRU9GKSB7XG4gICAgICAgIHJldHVybiBcIjxFT0Y+XCI7XG4gICAgICB9IGVsc2UgaWYgKHRva2VuID09PSBUb2tlbjIuRVBTSUxPTikge1xuICAgICAgICByZXR1cm4gXCI8RVBTSUxPTj5cIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsaXRlcmFsTmFtZXNbdG9rZW5dIHx8IHN5bWJvbGljTmFtZXNbdG9rZW5dO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJ2YWxzLm1hcCgoaW50ZXJ2YWwpID0+IGludGVydmFsLmxlbmd0aCkucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKTtcbiAgICB9XG4gIH07XG4gIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICBJbnRlcnZhbCxcbiAgICBJbnRlcnZhbFNldFxuICB9O1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjQvc3JjL2FudGxyNC9hdG4vVHJhbnNpdGlvbi5qc1xudmFyIHJlcXVpcmVfVHJhbnNpdGlvbjIgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUyKSA9PiB7XG4gIHZhciB7VG9rZW46IFRva2VuMn0gPSByZXF1aXJlX1Rva2VuMigpO1xuICB2YXIge0ludGVydmFsU2V0fSA9IHJlcXVpcmVfSW50ZXJ2YWxTZXQyKCk7XG4gIHZhciB7UHJlZGljYXRlLCBQcmVjZWRlbmNlUHJlZGljYXRlfSA9IHJlcXVpcmVfU2VtYW50aWNDb250ZXh0MigpO1xuICB2YXIgVHJhbnNpdGlvbiA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcbiAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgXCJ0YXJnZXQgY2Fubm90IGJlIG51bGwuXCI7XG4gICAgICB9XG4gICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgIHRoaXMuaXNFcHNpbG9uID0gZmFsc2U7XG4gICAgICB0aGlzLmxhYmVsID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIFRyYW5zaXRpb24uRVBTSUxPTiA9IDE7XG4gIFRyYW5zaXRpb24uUkFOR0UgPSAyO1xuICBUcmFuc2l0aW9uLlJVTEUgPSAzO1xuICBUcmFuc2l0aW9uLlBSRURJQ0FURSA9IDQ7XG4gIFRyYW5zaXRpb24uQVRPTSA9IDU7XG4gIFRyYW5zaXRpb24uQUNUSU9OID0gNjtcbiAgVHJhbnNpdGlvbi5TRVQgPSA3O1xuICBUcmFuc2l0aW9uLk5PVF9TRVQgPSA4O1xuICBUcmFuc2l0aW9uLldJTERDQVJEID0gOTtcbiAgVHJhbnNpdGlvbi5QUkVDRURFTkNFID0gMTA7XG4gIFRyYW5zaXRpb24uc2VyaWFsaXphdGlvbk5hbWVzID0gW1xuICAgIFwiSU5WQUxJRFwiLFxuICAgIFwiRVBTSUxPTlwiLFxuICAgIFwiUkFOR0VcIixcbiAgICBcIlJVTEVcIixcbiAgICBcIlBSRURJQ0FURVwiLFxuICAgIFwiQVRPTVwiLFxuICAgIFwiQUNUSU9OXCIsXG4gICAgXCJTRVRcIixcbiAgICBcIk5PVF9TRVRcIixcbiAgICBcIldJTERDQVJEXCIsXG4gICAgXCJQUkVDRURFTkNFXCJcbiAgXTtcbiAgVHJhbnNpdGlvbi5zZXJpYWxpemF0aW9uVHlwZXMgPSB7XG4gICAgRXBzaWxvblRyYW5zaXRpb246IFRyYW5zaXRpb24uRVBTSUxPTixcbiAgICBSYW5nZVRyYW5zaXRpb246IFRyYW5zaXRpb24uUkFOR0UsXG4gICAgUnVsZVRyYW5zaXRpb246IFRyYW5zaXRpb24uUlVMRSxcbiAgICBQcmVkaWNhdGVUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLlBSRURJQ0FURSxcbiAgICBBdG9tVHJhbnNpdGlvbjogVHJhbnNpdGlvbi5BVE9NLFxuICAgIEFjdGlvblRyYW5zaXRpb246IFRyYW5zaXRpb24uQUNUSU9OLFxuICAgIFNldFRyYW5zaXRpb246IFRyYW5zaXRpb24uU0VULFxuICAgIE5vdFNldFRyYW5zaXRpb246IFRyYW5zaXRpb24uTk9UX1NFVCxcbiAgICBXaWxkY2FyZFRyYW5zaXRpb246IFRyYW5zaXRpb24uV0lMRENBUkQsXG4gICAgUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb246IFRyYW5zaXRpb24uUFJFQ0VERU5DRVxuICB9O1xuICB2YXIgQXRvbVRyYW5zaXRpb24yID0gY2xhc3MgZXh0ZW5kcyBUcmFuc2l0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGxhYmVsKSB7XG4gICAgICBzdXBlcih0YXJnZXQpO1xuICAgICAgdGhpcy5sYWJlbF8gPSBsYWJlbDtcbiAgICAgIHRoaXMubGFiZWwgPSB0aGlzLm1ha2VMYWJlbCgpO1xuICAgICAgdGhpcy5zZXJpYWxpemF0aW9uVHlwZSA9IFRyYW5zaXRpb24uQVRPTTtcbiAgICB9XG4gICAgbWFrZUxhYmVsKCkge1xuICAgICAgY29uc3QgcyA9IG5ldyBJbnRlcnZhbFNldCgpO1xuICAgICAgcy5hZGRPbmUodGhpcy5sYWJlbF8pO1xuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIG1hdGNoZXMoc3ltYm9sLCBtaW5Wb2NhYlN5bWJvbCwgbWF4Vm9jYWJTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhYmVsXyA9PT0gc3ltYm9sO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhYmVsXztcbiAgICB9XG4gIH07XG4gIHZhciBSdWxlVHJhbnNpdGlvbiA9IGNsYXNzIGV4dGVuZHMgVHJhbnNpdGlvbiB7XG4gICAgY29uc3RydWN0b3IocnVsZVN0YXJ0LCBydWxlSW5kZXgsIHByZWNlZGVuY2UsIGZvbGxvd1N0YXRlKSB7XG4gICAgICBzdXBlcihydWxlU3RhcnQpO1xuICAgICAgdGhpcy5ydWxlSW5kZXggPSBydWxlSW5kZXg7XG4gICAgICB0aGlzLnByZWNlZGVuY2UgPSBwcmVjZWRlbmNlO1xuICAgICAgdGhpcy5mb2xsb3dTdGF0ZSA9IGZvbGxvd1N0YXRlO1xuICAgICAgdGhpcy5zZXJpYWxpemF0aW9uVHlwZSA9IFRyYW5zaXRpb24uUlVMRTtcbiAgICAgIHRoaXMuaXNFcHNpbG9uID0gdHJ1ZTtcbiAgICB9XG4gICAgbWF0Y2hlcyhzeW1ib2wsIG1pblZvY2FiU3ltYm9sLCBtYXhWb2NhYlN5bWJvbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgdmFyIEVwc2lsb25UcmFuc2l0aW9uID0gY2xhc3MgZXh0ZW5kcyBUcmFuc2l0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIG91dGVybW9zdFByZWNlZGVuY2VSZXR1cm4pIHtcbiAgICAgIHN1cGVyKHRhcmdldCk7XG4gICAgICB0aGlzLnNlcmlhbGl6YXRpb25UeXBlID0gVHJhbnNpdGlvbi5FUFNJTE9OO1xuICAgICAgdGhpcy5pc0Vwc2lsb24gPSB0cnVlO1xuICAgICAgdGhpcy5vdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuID0gb3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybjtcbiAgICB9XG4gICAgbWF0Y2hlcyhzeW1ib2wsIG1pblZvY2FiU3ltYm9sLCBtYXhWb2NhYlN5bWJvbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcImVwc2lsb25cIjtcbiAgICB9XG4gIH07XG4gIHZhciBSYW5nZVRyYW5zaXRpb24gPSBjbGFzcyBleHRlbmRzIFRyYW5zaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgc3RhcnQsIHN0b3ApIHtcbiAgICAgIHN1cGVyKHRhcmdldCk7XG4gICAgICB0aGlzLnNlcmlhbGl6YXRpb25UeXBlID0gVHJhbnNpdGlvbi5SQU5HRTtcbiAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgIHRoaXMuc3RvcCA9IHN0b3A7XG4gICAgICB0aGlzLmxhYmVsID0gdGhpcy5tYWtlTGFiZWwoKTtcbiAgICB9XG4gICAgbWFrZUxhYmVsKCkge1xuICAgICAgY29uc3QgcyA9IG5ldyBJbnRlcnZhbFNldCgpO1xuICAgICAgcy5hZGRSYW5nZSh0aGlzLnN0YXJ0LCB0aGlzLnN0b3ApO1xuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIG1hdGNoZXMoc3ltYm9sLCBtaW5Wb2NhYlN5bWJvbCwgbWF4Vm9jYWJTeW1ib2wpIHtcbiAgICAgIHJldHVybiBzeW1ib2wgPj0gdGhpcy5zdGFydCAmJiBzeW1ib2wgPD0gdGhpcy5zdG9wO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIidcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5zdGFydCkgKyBcIicuLidcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5zdG9wKSArIFwiJ1wiO1xuICAgIH1cbiAgfTtcbiAgdmFyIEFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbiA9IGNsYXNzIGV4dGVuZHMgVHJhbnNpdGlvbiB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgICBzdXBlcih0YXJnZXQpO1xuICAgIH1cbiAgfTtcbiAgdmFyIFByZWRpY2F0ZVRyYW5zaXRpb24gPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbiB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBydWxlSW5kZXgsIHByZWRJbmRleCwgaXNDdHhEZXBlbmRlbnQpIHtcbiAgICAgIHN1cGVyKHRhcmdldCk7XG4gICAgICB0aGlzLnNlcmlhbGl6YXRpb25UeXBlID0gVHJhbnNpdGlvbi5QUkVESUNBVEU7XG4gICAgICB0aGlzLnJ1bGVJbmRleCA9IHJ1bGVJbmRleDtcbiAgICAgIHRoaXMucHJlZEluZGV4ID0gcHJlZEluZGV4O1xuICAgICAgdGhpcy5pc0N0eERlcGVuZGVudCA9IGlzQ3R4RGVwZW5kZW50O1xuICAgICAgdGhpcy5pc0Vwc2lsb24gPSB0cnVlO1xuICAgIH1cbiAgICBtYXRjaGVzKHN5bWJvbCwgbWluVm9jYWJTeW1ib2wsIG1heFZvY2FiU3ltYm9sKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldFByZWRpY2F0ZSgpIHtcbiAgICAgIHJldHVybiBuZXcgUHJlZGljYXRlKHRoaXMucnVsZUluZGV4LCB0aGlzLnByZWRJbmRleCwgdGhpcy5pc0N0eERlcGVuZGVudCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwicHJlZF9cIiArIHRoaXMucnVsZUluZGV4ICsgXCI6XCIgKyB0aGlzLnByZWRJbmRleDtcbiAgICB9XG4gIH07XG4gIHZhciBBY3Rpb25UcmFuc2l0aW9uID0gY2xhc3MgZXh0ZW5kcyBUcmFuc2l0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIHJ1bGVJbmRleCwgYWN0aW9uSW5kZXgsIGlzQ3R4RGVwZW5kZW50KSB7XG4gICAgICBzdXBlcih0YXJnZXQpO1xuICAgICAgdGhpcy5zZXJpYWxpemF0aW9uVHlwZSA9IFRyYW5zaXRpb24uQUNUSU9OO1xuICAgICAgdGhpcy5ydWxlSW5kZXggPSBydWxlSW5kZXg7XG4gICAgICB0aGlzLmFjdGlvbkluZGV4ID0gYWN0aW9uSW5kZXggPT09IHZvaWQgMCA/IC0xIDogYWN0aW9uSW5kZXg7XG4gICAgICB0aGlzLmlzQ3R4RGVwZW5kZW50ID0gaXNDdHhEZXBlbmRlbnQgPT09IHZvaWQgMCA/IGZhbHNlIDogaXNDdHhEZXBlbmRlbnQ7XG4gICAgICB0aGlzLmlzRXBzaWxvbiA9IHRydWU7XG4gICAgfVxuICAgIG1hdGNoZXMoc3ltYm9sLCBtaW5Wb2NhYlN5bWJvbCwgbWF4Vm9jYWJTeW1ib2wpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJhY3Rpb25fXCIgKyB0aGlzLnJ1bGVJbmRleCArIFwiOlwiICsgdGhpcy5hY3Rpb25JbmRleDtcbiAgICB9XG4gIH07XG4gIHZhciBTZXRUcmFuc2l0aW9uID0gY2xhc3MgZXh0ZW5kcyBUcmFuc2l0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIHNldCkge1xuICAgICAgc3VwZXIodGFyZ2V0KTtcbiAgICAgIHRoaXMuc2VyaWFsaXphdGlvblR5cGUgPSBUcmFuc2l0aW9uLlNFVDtcbiAgICAgIGlmIChzZXQgIT09IHZvaWQgMCAmJiBzZXQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5sYWJlbCA9IHNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGFiZWwgPSBuZXcgSW50ZXJ2YWxTZXQoKTtcbiAgICAgICAgdGhpcy5sYWJlbC5hZGRPbmUoVG9rZW4yLklOVkFMSURfVFlQRSk7XG4gICAgICB9XG4gICAgfVxuICAgIG1hdGNoZXMoc3ltYm9sLCBtaW5Wb2NhYlN5bWJvbCwgbWF4Vm9jYWJTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhYmVsLmNvbnRhaW5zKHN5bWJvbCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGFiZWwudG9TdHJpbmcoKTtcbiAgICB9XG4gIH07XG4gIHZhciBOb3RTZXRUcmFuc2l0aW9uID0gY2xhc3MgZXh0ZW5kcyBTZXRUcmFuc2l0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIHNldCkge1xuICAgICAgc3VwZXIodGFyZ2V0LCBzZXQpO1xuICAgICAgdGhpcy5zZXJpYWxpemF0aW9uVHlwZSA9IFRyYW5zaXRpb24uTk9UX1NFVDtcbiAgICB9XG4gICAgbWF0Y2hlcyhzeW1ib2wsIG1pblZvY2FiU3ltYm9sLCBtYXhWb2NhYlN5bWJvbCkge1xuICAgICAgcmV0dXJuIHN5bWJvbCA+PSBtaW5Wb2NhYlN5bWJvbCAmJiBzeW1ib2wgPD0gbWF4Vm9jYWJTeW1ib2wgJiYgIXN1cGVyLm1hdGNoZXMoc3ltYm9sLCBtaW5Wb2NhYlN5bWJvbCwgbWF4Vm9jYWJTeW1ib2wpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIn5cIiArIHN1cGVyLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9O1xuICB2YXIgV2lsZGNhcmRUcmFuc2l0aW9uID0gY2xhc3MgZXh0ZW5kcyBUcmFuc2l0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcbiAgICAgIHN1cGVyKHRhcmdldCk7XG4gICAgICB0aGlzLnNlcmlhbGl6YXRpb25UeXBlID0gVHJhbnNpdGlvbi5XSUxEQ0FSRDtcbiAgICB9XG4gICAgbWF0Y2hlcyhzeW1ib2wsIG1pblZvY2FiU3ltYm9sLCBtYXhWb2NhYlN5bWJvbCkge1xuICAgICAgcmV0dXJuIHN5bWJvbCA+PSBtaW5Wb2NhYlN5bWJvbCAmJiBzeW1ib2wgPD0gbWF4Vm9jYWJTeW1ib2w7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwiLlwiO1xuICAgIH1cbiAgfTtcbiAgdmFyIFByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgcHJlY2VkZW5jZSkge1xuICAgICAgc3VwZXIodGFyZ2V0KTtcbiAgICAgIHRoaXMuc2VyaWFsaXphdGlvblR5cGUgPSBUcmFuc2l0aW9uLlBSRUNFREVOQ0U7XG4gICAgICB0aGlzLnByZWNlZGVuY2UgPSBwcmVjZWRlbmNlO1xuICAgICAgdGhpcy5pc0Vwc2lsb24gPSB0cnVlO1xuICAgIH1cbiAgICBtYXRjaGVzKHN5bWJvbCwgbWluVm9jYWJTeW1ib2wsIG1heFZvY2FiU3ltYm9sKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldFByZWRpY2F0ZSgpIHtcbiAgICAgIHJldHVybiBuZXcgUHJlY2VkZW5jZVByZWRpY2F0ZSh0aGlzLnByZWNlZGVuY2UpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWNlZGVuY2UgKyBcIiA+PSBfcFwiO1xuICAgIH1cbiAgfTtcbiAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgIFRyYW5zaXRpb24sXG4gICAgQXRvbVRyYW5zaXRpb246IEF0b21UcmFuc2l0aW9uMixcbiAgICBTZXRUcmFuc2l0aW9uLFxuICAgIE5vdFNldFRyYW5zaXRpb24sXG4gICAgUnVsZVRyYW5zaXRpb24sXG4gICAgQWN0aW9uVHJhbnNpdGlvbixcbiAgICBFcHNpbG9uVHJhbnNpdGlvbixcbiAgICBSYW5nZVRyYW5zaXRpb24sXG4gICAgV2lsZGNhcmRUcmFuc2l0aW9uLFxuICAgIFByZWRpY2F0ZVRyYW5zaXRpb24sXG4gICAgUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb24sXG4gICAgQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uXG4gIH07XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNC9zcmMvYW50bHI0L3RyZWUvVHJlZS5qc1xudmFyIHJlcXVpcmVfVHJlZSA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZTIpID0+IHtcbiAgdmFyIHtUb2tlbjogVG9rZW4yfSA9IHJlcXVpcmVfVG9rZW4yKCk7XG4gIHZhciB7SW50ZXJ2YWx9ID0gcmVxdWlyZV9JbnRlcnZhbFNldDIoKTtcbiAgdmFyIElOVkFMSURfSU5URVJWQUwgPSBuZXcgSW50ZXJ2YWwoLTEsIC0yKTtcbiAgdmFyIFRyZWUgPSBjbGFzcyB7XG4gIH07XG4gIHZhciBTeW50YXhUcmVlID0gY2xhc3MgZXh0ZW5kcyBUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgfVxuICB9O1xuICB2YXIgUGFyc2VUcmVlID0gY2xhc3MgZXh0ZW5kcyBTeW50YXhUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgfVxuICB9O1xuICB2YXIgUnVsZU5vZGUgPSBjbGFzcyBleHRlbmRzIFBhcnNlVHJlZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgIH1cbiAgICBnZXRSdWxlQ29udGV4dCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW50ZXJmYWNlIGltcGxlbWVudGF0aW9uXCIpO1xuICAgIH1cbiAgfTtcbiAgdmFyIFRlcm1pbmFsTm9kZSA9IGNsYXNzIGV4dGVuZHMgUGFyc2VUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgfVxuICB9O1xuICB2YXIgRXJyb3JOb2RlMiA9IGNsYXNzIGV4dGVuZHMgVGVybWluYWxOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgfVxuICB9O1xuICB2YXIgUGFyc2VUcmVlVmlzaXRvciA9IGNsYXNzIHtcbiAgICB2aXNpdChjdHgpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGN0eCkpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGQuYWNjZXB0KHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjdHguYWNjZXB0KHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICB2aXNpdENoaWxkcmVuKGN0eCkge1xuICAgICAgaWYgKGN0eC5jaGlsZHJlbikge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdChjdHguY2hpbGRyZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHZpc2l0VGVybWluYWwobm9kZSkge1xuICAgIH1cbiAgICB2aXNpdEVycm9yTm9kZShub2RlKSB7XG4gICAgfVxuICB9O1xuICB2YXIgUGFyc2VUcmVlTGlzdGVuZXIgPSBjbGFzcyB7XG4gICAgdmlzaXRUZXJtaW5hbChub2RlKSB7XG4gICAgfVxuICAgIHZpc2l0RXJyb3JOb2RlKG5vZGUpIHtcbiAgICB9XG4gICAgZW50ZXJFdmVyeVJ1bGUobm9kZSkge1xuICAgIH1cbiAgICBleGl0RXZlcnlSdWxlKG5vZGUpIHtcbiAgICB9XG4gIH07XG4gIHZhciBUZXJtaW5hbE5vZGVJbXBsID0gY2xhc3MgZXh0ZW5kcyBUZXJtaW5hbE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKHN5bWJvbCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMucGFyZW50Q3R4ID0gbnVsbDtcbiAgICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xuICAgIH1cbiAgICBnZXRDaGlsZChpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0U3ltYm9sKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sO1xuICAgIH1cbiAgICBnZXRQYXJlbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnRDdHg7XG4gICAgfVxuICAgIGdldFBheWxvYWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zeW1ib2w7XG4gICAgfVxuICAgIGdldFNvdXJjZUludGVydmFsKCkge1xuICAgICAgaWYgKHRoaXMuc3ltYm9sID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBJTlZBTElEX0lOVEVSVkFMO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9rZW5JbmRleCA9IHRoaXMuc3ltYm9sLnRva2VuSW5kZXg7XG4gICAgICByZXR1cm4gbmV3IEludGVydmFsKHRva2VuSW5kZXgsIHRva2VuSW5kZXgpO1xuICAgIH1cbiAgICBnZXRDaGlsZENvdW50KCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRlcm1pbmFsKHRoaXMpO1xuICAgIH1cbiAgICBnZXRUZXh0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sLnRleHQ7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgaWYgKHRoaXMuc3ltYm9sLnR5cGUgPT09IFRva2VuMi5FT0YpIHtcbiAgICAgICAgcmV0dXJuIFwiPEVPRj5cIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bWJvbC50ZXh0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIEVycm9yTm9kZUltcGwgPSBjbGFzcyBleHRlbmRzIFRlcm1pbmFsTm9kZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHRva2VuKSB7XG4gICAgICBzdXBlcih0b2tlbik7XG4gICAgfVxuICAgIGlzRXJyb3JOb2RlKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdEVycm9yTm9kZSh0aGlzKTtcbiAgICB9XG4gIH07XG4gIHZhciBQYXJzZVRyZWVXYWxrZXIgPSBjbGFzcyB7XG4gICAgd2FsayhsaXN0ZW5lciwgdCkge1xuICAgICAgY29uc3QgZXJyb3JOb2RlID0gdCBpbnN0YW5jZW9mIEVycm9yTm9kZTIgfHwgdC5pc0Vycm9yTm9kZSAhPT0gdm9pZCAwICYmIHQuaXNFcnJvck5vZGUoKTtcbiAgICAgIGlmIChlcnJvck5vZGUpIHtcbiAgICAgICAgbGlzdGVuZXIudmlzaXRFcnJvck5vZGUodCk7XG4gICAgICB9IGVsc2UgaWYgKHQgaW5zdGFuY2VvZiBUZXJtaW5hbE5vZGUpIHtcbiAgICAgICAgbGlzdGVuZXIudmlzaXRUZXJtaW5hbCh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW50ZXJSdWxlKGxpc3RlbmVyLCB0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0LmdldENoaWxkQ291bnQoKTsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSB0LmdldENoaWxkKGkpO1xuICAgICAgICAgIHRoaXMud2FsayhsaXN0ZW5lciwgY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhpdFJ1bGUobGlzdGVuZXIsIHQpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbnRlclJ1bGUobGlzdGVuZXIsIHIpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHIuZ2V0UnVsZUNvbnRleHQoKTtcbiAgICAgIGxpc3RlbmVyLmVudGVyRXZlcnlSdWxlKGN0eCk7XG4gICAgICBjdHguZW50ZXJSdWxlKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgZXhpdFJ1bGUobGlzdGVuZXIsIHIpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHIuZ2V0UnVsZUNvbnRleHQoKTtcbiAgICAgIGN0eC5leGl0UnVsZShsaXN0ZW5lcik7XG4gICAgICBsaXN0ZW5lci5leGl0RXZlcnlSdWxlKGN0eCk7XG4gICAgfVxuICB9O1xuICBQYXJzZVRyZWVXYWxrZXIuREVGQVVMVCA9IG5ldyBQYXJzZVRyZWVXYWxrZXIoKTtcbiAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgIFJ1bGVOb2RlLFxuICAgIEVycm9yTm9kZTogRXJyb3JOb2RlMixcbiAgICBUZXJtaW5hbE5vZGUsXG4gICAgRXJyb3JOb2RlSW1wbCxcbiAgICBUZXJtaW5hbE5vZGVJbXBsLFxuICAgIFBhcnNlVHJlZUxpc3RlbmVyLFxuICAgIFBhcnNlVHJlZVZpc2l0b3IsXG4gICAgUGFyc2VUcmVlV2Fsa2VyLFxuICAgIElOVkFMSURfSU5URVJWQUxcbiAgfTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0L3NyYy9hbnRscjQvdHJlZS9UcmVlcy5qc1xudmFyIHJlcXVpcmVfVHJlZXMyID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlMikgPT4ge1xuICB2YXIgVXRpbHMzID0gcmVxdWlyZV9VdGlsczIoKTtcbiAgdmFyIHtUb2tlbjogVG9rZW4yfSA9IHJlcXVpcmVfVG9rZW4yKCk7XG4gIHZhciB7RXJyb3JOb2RlOiBFcnJvck5vZGUyLCBUZXJtaW5hbE5vZGUsIFJ1bGVOb2RlfSA9IHJlcXVpcmVfVHJlZSgpO1xuICB2YXIgVHJlZXMgPSB7XG4gICAgdG9TdHJpbmdUcmVlOiBmdW5jdGlvbih0cmVlLCBydWxlTmFtZXMsIHJlY29nKSB7XG4gICAgICBydWxlTmFtZXMgPSBydWxlTmFtZXMgfHwgbnVsbDtcbiAgICAgIHJlY29nID0gcmVjb2cgfHwgbnVsbDtcbiAgICAgIGlmIChyZWNvZyAhPT0gbnVsbCkge1xuICAgICAgICBydWxlTmFtZXMgPSByZWNvZy5ydWxlTmFtZXM7XG4gICAgICB9XG4gICAgICBsZXQgcyA9IFRyZWVzLmdldE5vZGVUZXh0KHRyZWUsIHJ1bGVOYW1lcyk7XG4gICAgICBzID0gVXRpbHMzLmVzY2FwZVdoaXRlc3BhY2UocywgZmFsc2UpO1xuICAgICAgY29uc3QgYyA9IHRyZWUuZ2V0Q2hpbGRDb3VudCgpO1xuICAgICAgaWYgKGMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9XG4gICAgICBsZXQgcmVzID0gXCIoXCIgKyBzICsgXCIgXCI7XG4gICAgICBpZiAoYyA+IDApIHtcbiAgICAgICAgcyA9IFRyZWVzLnRvU3RyaW5nVHJlZSh0cmVlLmdldENoaWxkKDApLCBydWxlTmFtZXMpO1xuICAgICAgICByZXMgPSByZXMuY29uY2F0KHMpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjOyBpKyspIHtcbiAgICAgICAgcyA9IFRyZWVzLnRvU3RyaW5nVHJlZSh0cmVlLmdldENoaWxkKGkpLCBydWxlTmFtZXMpO1xuICAgICAgICByZXMgPSByZXMuY29uY2F0KFwiIFwiICsgcyk7XG4gICAgICB9XG4gICAgICByZXMgPSByZXMuY29uY2F0KFwiKVwiKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBnZXROb2RlVGV4dDogZnVuY3Rpb24odCwgcnVsZU5hbWVzLCByZWNvZykge1xuICAgICAgcnVsZU5hbWVzID0gcnVsZU5hbWVzIHx8IG51bGw7XG4gICAgICByZWNvZyA9IHJlY29nIHx8IG51bGw7XG4gICAgICBpZiAocmVjb2cgIT09IG51bGwpIHtcbiAgICAgICAgcnVsZU5hbWVzID0gcmVjb2cucnVsZU5hbWVzO1xuICAgICAgfVxuICAgICAgaWYgKHJ1bGVOYW1lcyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodCBpbnN0YW5jZW9mIFJ1bGVOb2RlKSB7XG4gICAgICAgICAgY29uc3QgY29udGV4dCA9IHQuZ2V0UnVsZUNvbnRleHQoKTtcbiAgICAgICAgICBjb25zdCBhbHROdW1iZXIgPSBjb250ZXh0LmdldEFsdE51bWJlcigpO1xuICAgICAgICAgIGlmIChhbHROdW1iZXIgIT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJ1bGVOYW1lc1t0LnJ1bGVJbmRleF0gKyBcIjpcIiArIGFsdE51bWJlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJ1bGVOYW1lc1t0LnJ1bGVJbmRleF07XG4gICAgICAgIH0gZWxzZSBpZiAodCBpbnN0YW5jZW9mIEVycm9yTm9kZTIpIHtcbiAgICAgICAgICByZXR1cm4gdC50b1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHQgaW5zdGFuY2VvZiBUZXJtaW5hbE5vZGUpIHtcbiAgICAgICAgICBpZiAodC5zeW1ib2wgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0LnN5bWJvbC50ZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcGF5bG9hZCA9IHQuZ2V0UGF5bG9hZCgpO1xuICAgICAgaWYgKHBheWxvYWQgaW5zdGFuY2VvZiBUb2tlbjIpIHtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQudGV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0LmdldFBheWxvYWQoKS50b1N0cmluZygpO1xuICAgIH0sXG4gICAgZ2V0Q2hpbGRyZW46IGZ1bmN0aW9uKHQpIHtcbiAgICAgIGNvbnN0IGxpc3QgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdC5nZXRDaGlsZENvdW50KCk7IGkrKykge1xuICAgICAgICBsaXN0LnB1c2godC5nZXRDaGlsZChpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9LFxuICAgIGdldEFuY2VzdG9yczogZnVuY3Rpb24odCkge1xuICAgICAgbGV0IGFuY2VzdG9ycyA9IFtdO1xuICAgICAgdCA9IHQuZ2V0UGFyZW50KCk7XG4gICAgICB3aGlsZSAodCAhPT0gbnVsbCkge1xuICAgICAgICBhbmNlc3RvcnMgPSBbdF0uY29uY2F0KGFuY2VzdG9ycyk7XG4gICAgICAgIHQgPSB0LmdldFBhcmVudCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFuY2VzdG9ycztcbiAgICB9LFxuICAgIGZpbmRBbGxUb2tlbk5vZGVzOiBmdW5jdGlvbih0LCB0dHlwZSkge1xuICAgICAgcmV0dXJuIFRyZWVzLmZpbmRBbGxOb2Rlcyh0LCB0dHlwZSwgdHJ1ZSk7XG4gICAgfSxcbiAgICBmaW5kQWxsUnVsZU5vZGVzOiBmdW5jdGlvbih0LCBydWxlSW5kZXgpIHtcbiAgICAgIHJldHVybiBUcmVlcy5maW5kQWxsTm9kZXModCwgcnVsZUluZGV4LCBmYWxzZSk7XG4gICAgfSxcbiAgICBmaW5kQWxsTm9kZXM6IGZ1bmN0aW9uKHQsIGluZGV4LCBmaW5kVG9rZW5zKSB7XG4gICAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgICAgVHJlZXMuX2ZpbmRBbGxOb2Rlcyh0LCBpbmRleCwgZmluZFRva2Vucywgbm9kZXMpO1xuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH0sXG4gICAgX2ZpbmRBbGxOb2RlczogZnVuY3Rpb24odCwgaW5kZXgsIGZpbmRUb2tlbnMsIG5vZGVzKSB7XG4gICAgICBpZiAoZmluZFRva2VucyAmJiB0IGluc3RhbmNlb2YgVGVybWluYWxOb2RlKSB7XG4gICAgICAgIGlmICh0LnN5bWJvbC50eXBlID09PSBpbmRleCkge1xuICAgICAgICAgIG5vZGVzLnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWZpbmRUb2tlbnMgJiYgdCBpbnN0YW5jZW9mIFJ1bGVOb2RlKSB7XG4gICAgICAgIGlmICh0LnJ1bGVJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHQuZ2V0Q2hpbGRDb3VudCgpOyBpKyspIHtcbiAgICAgICAgVHJlZXMuX2ZpbmRBbGxOb2Rlcyh0LmdldENoaWxkKGkpLCBpbmRleCwgZmluZFRva2Vucywgbm9kZXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVzY2VuZGFudHM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgIGxldCBub2RlcyA9IFt0XTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdC5nZXRDaGlsZENvdW50KCk7IGkrKykge1xuICAgICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChUcmVlcy5kZXNjZW5kYW50cyh0LmdldENoaWxkKGkpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICB9O1xuICBtb2R1bGUyLmV4cG9ydHMgPSBUcmVlcztcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0L3NyYy9hbnRscjQvUnVsZUNvbnRleHQuanNcbnZhciByZXF1aXJlX1J1bGVDb250ZXh0MiA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZTIpID0+IHtcbiAgdmFyIHtSdWxlTm9kZX0gPSByZXF1aXJlX1RyZWUoKTtcbiAgdmFyIHtJTlZBTElEX0lOVEVSVkFMfSA9IHJlcXVpcmVfVHJlZSgpO1xuICB2YXIgVHJlZXMgPSByZXF1aXJlX1RyZWVzMigpO1xuICB2YXIgUnVsZUNvbnRleHQgPSBjbGFzcyBleHRlbmRzIFJ1bGVOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLnBhcmVudEN0eCA9IHBhcmVudCB8fCBudWxsO1xuICAgICAgdGhpcy5pbnZva2luZ1N0YXRlID0gaW52b2tpbmdTdGF0ZSB8fCAtMTtcbiAgICB9XG4gICAgZGVwdGgoKSB7XG4gICAgICBsZXQgbiA9IDA7XG4gICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICB3aGlsZSAocCAhPT0gbnVsbCkge1xuICAgICAgICBwID0gcC5wYXJlbnRDdHg7XG4gICAgICAgIG4gKz0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW52b2tpbmdTdGF0ZSA9PT0gLTE7XG4gICAgfVxuICAgIGdldFNvdXJjZUludGVydmFsKCkge1xuICAgICAgcmV0dXJuIElOVkFMSURfSU5URVJWQUw7XG4gICAgfVxuICAgIGdldFJ1bGVDb250ZXh0KCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldFBheWxvYWQoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0VGV4dCgpIHtcbiAgICAgIGlmICh0aGlzLmdldENoaWxkQ291bnQoKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLm1hcChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZC5nZXRUZXh0KCk7XG4gICAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGdldEFsdE51bWJlcigpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBzZXRBbHROdW1iZXIoYWx0TnVtYmVyKSB7XG4gICAgfVxuICAgIGdldENoaWxkKGkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXRDaGlsZENvdW50KCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgICB0b1N0cmluZ1RyZWUocnVsZU5hbWVzLCByZWNvZykge1xuICAgICAgcmV0dXJuIFRyZWVzLnRvU3RyaW5nVHJlZSh0aGlzLCBydWxlTmFtZXMsIHJlY29nKTtcbiAgICB9XG4gICAgdG9TdHJpbmcocnVsZU5hbWVzLCBzdG9wKSB7XG4gICAgICBydWxlTmFtZXMgPSBydWxlTmFtZXMgfHwgbnVsbDtcbiAgICAgIHN0b3AgPSBzdG9wIHx8IG51bGw7XG4gICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICBsZXQgcyA9IFwiW1wiO1xuICAgICAgd2hpbGUgKHAgIT09IG51bGwgJiYgcCAhPT0gc3RvcCkge1xuICAgICAgICBpZiAocnVsZU5hbWVzID09PSBudWxsKSB7XG4gICAgICAgICAgaWYgKCFwLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcyArPSBwLmludm9raW5nU3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHJpID0gcC5ydWxlSW5kZXg7XG4gICAgICAgICAgY29uc3QgcnVsZU5hbWUgPSByaSA+PSAwICYmIHJpIDwgcnVsZU5hbWVzLmxlbmd0aCA/IHJ1bGVOYW1lc1tyaV0gOiBcIlwiICsgcmk7XG4gICAgICAgICAgcyArPSBydWxlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocC5wYXJlbnRDdHggIT09IG51bGwgJiYgKHJ1bGVOYW1lcyAhPT0gbnVsbCB8fCAhcC5wYXJlbnRDdHguaXNFbXB0eSgpKSkge1xuICAgICAgICAgIHMgKz0gXCIgXCI7XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAucGFyZW50Q3R4O1xuICAgICAgfVxuICAgICAgcyArPSBcIl1cIjtcbiAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgfTtcbiAgbW9kdWxlMi5leHBvcnRzID0gUnVsZUNvbnRleHQ7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNC9zcmMvYW50bHI0L1ByZWRpY3Rpb25Db250ZXh0LmpzXG52YXIgcmVxdWlyZV9QcmVkaWN0aW9uQ29udGV4dDIgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUyKSA9PiB7XG4gIHZhciBSdWxlQ29udGV4dCA9IHJlcXVpcmVfUnVsZUNvbnRleHQyKCk7XG4gIHZhciB7SGFzaDogSGFzaDIsIE1hcDogTWFwMiwgZXF1YWxBcnJheXN9ID0gcmVxdWlyZV9VdGlsczIoKTtcbiAgdmFyIFByZWRpY3Rpb25Db250ZXh0ID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGNhY2hlZEhhc2hDb2RlKSB7XG4gICAgICB0aGlzLmNhY2hlZEhhc2hDb2RlID0gY2FjaGVkSGFzaENvZGU7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICByZXR1cm4gdGhpcyA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFk7XG4gICAgfVxuICAgIGhhc0VtcHR5UGF0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJldHVyblN0YXRlKHRoaXMubGVuZ3RoIC0gMSkgPT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX1JFVFVSTl9TVEFURTtcbiAgICB9XG4gICAgaGFzaENvZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZWRIYXNoQ29kZTtcbiAgICB9XG4gICAgdXBkYXRlSGFzaENvZGUoaGFzaCkge1xuICAgICAgaGFzaC51cGRhdGUodGhpcy5jYWNoZWRIYXNoQ29kZSk7XG4gICAgfVxuICB9O1xuICBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWSA9IG51bGw7XG4gIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX1JFVFVSTl9TVEFURSA9IDIxNDc0ODM2NDc7XG4gIFByZWRpY3Rpb25Db250ZXh0Lmdsb2JhbE5vZGVDb3VudCA9IDE7XG4gIFByZWRpY3Rpb25Db250ZXh0LmlkID0gUHJlZGljdGlvbkNvbnRleHQuZ2xvYmFsTm9kZUNvdW50O1xuICB2YXIgUHJlZGljdGlvbkNvbnRleHRDYWNoZSA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwMigpO1xuICAgIH1cbiAgICBhZGQoY3R4KSB7XG4gICAgICBpZiAoY3R4ID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWSkge1xuICAgICAgICByZXR1cm4gUHJlZGljdGlvbkNvbnRleHQuRU1QVFk7XG4gICAgICB9XG4gICAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuY2FjaGUuZ2V0KGN0eCkgfHwgbnVsbDtcbiAgICAgIGlmIChleGlzdGluZyAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlLnB1dChjdHgsIGN0eCk7XG4gICAgICByZXR1cm4gY3R4O1xuICAgIH1cbiAgICBnZXQoY3R4KSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQoY3R4KSB8fCBudWxsO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGUubGVuZ3RoO1xuICAgIH1cbiAgfTtcbiAgdmFyIFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBQcmVkaWN0aW9uQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCByZXR1cm5TdGF0ZSkge1xuICAgICAgbGV0IGhhc2hDb2RlID0gMDtcbiAgICAgIGNvbnN0IGhhc2ggPSBuZXcgSGFzaDIoKTtcbiAgICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgaGFzaC51cGRhdGUocGFyZW50LCByZXR1cm5TdGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYXNoLnVwZGF0ZSgxKTtcbiAgICAgIH1cbiAgICAgIGhhc2hDb2RlID0gaGFzaC5maW5pc2goKTtcbiAgICAgIHN1cGVyKGhhc2hDb2RlKTtcbiAgICAgIHRoaXMucGFyZW50Q3R4ID0gcGFyZW50O1xuICAgICAgdGhpcy5yZXR1cm5TdGF0ZSA9IHJldHVyblN0YXRlO1xuICAgIH1cbiAgICBnZXRQYXJlbnQoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudEN0eDtcbiAgICB9XG4gICAgZ2V0UmV0dXJuU3RhdGUoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldHVyblN0YXRlO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzaENvZGUoKSAhPT0gb3RoZXIuaGFzaENvZGUoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5yZXR1cm5TdGF0ZSAhPT0gb3RoZXIucmV0dXJuU3RhdGUpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBlbHNlIGlmICh0aGlzLnBhcmVudEN0eCA9PSBudWxsKVxuICAgICAgICAgIHJldHVybiBvdGhlci5wYXJlbnRDdHggPT0gbnVsbDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudEN0eC5lcXVhbHMob3RoZXIucGFyZW50Q3R4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICBjb25zdCB1cCA9IHRoaXMucGFyZW50Q3R4ID09PSBudWxsID8gXCJcIiA6IHRoaXMucGFyZW50Q3R4LnRvU3RyaW5nKCk7XG4gICAgICBpZiAodXAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmICh0aGlzLnJldHVyblN0YXRlID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9SRVRVUk5fU1RBVEUpIHtcbiAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFwiXCIgKyB0aGlzLnJldHVyblN0YXRlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJcIiArIHRoaXMucmV0dXJuU3RhdGUgKyBcIiBcIiArIHVwO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUocGFyZW50LCByZXR1cm5TdGF0ZSkge1xuICAgICAgaWYgKHJldHVyblN0YXRlID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9SRVRVUk5fU1RBVEUgJiYgcGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQocGFyZW50LCByZXR1cm5TdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgRW1wdHlQcmVkaWN0aW9uQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIobnVsbCwgUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfUkVUVVJOX1NUQVRFKTtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXRQYXJlbnQoaW5kZXgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXRSZXR1cm5TdGF0ZShpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMucmV0dXJuU3RhdGU7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMgPT09IG90aGVyO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIiRcIjtcbiAgICB9XG4gIH07XG4gIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZID0gbmV3IEVtcHR5UHJlZGljdGlvbkNvbnRleHQoKTtcbiAgdmFyIEFycmF5UHJlZGljdGlvbkNvbnRleHQgPSBjbGFzcyBleHRlbmRzIFByZWRpY3Rpb25Db250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRzLCByZXR1cm5TdGF0ZXMpIHtcbiAgICAgIGNvbnN0IGggPSBuZXcgSGFzaDIoKTtcbiAgICAgIGgudXBkYXRlKHBhcmVudHMsIHJldHVyblN0YXRlcyk7XG4gICAgICBjb25zdCBoYXNoQ29kZSA9IGguZmluaXNoKCk7XG4gICAgICBzdXBlcihoYXNoQ29kZSk7XG4gICAgICB0aGlzLnBhcmVudHMgPSBwYXJlbnRzO1xuICAgICAgdGhpcy5yZXR1cm5TdGF0ZXMgPSByZXR1cm5TdGF0ZXM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldHVyblN0YXRlc1swXSA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfUkVUVVJOX1NUQVRFO1xuICAgIH1cbiAgICBnZXRQYXJlbnQoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudHNbaW5kZXhdO1xuICAgIH1cbiAgICBnZXRSZXR1cm5TdGF0ZShpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMucmV0dXJuU3RhdGVzW2luZGV4XTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBBcnJheVByZWRpY3Rpb25Db250ZXh0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzaENvZGUoKSAhPT0gb3RoZXIuaGFzaENvZGUoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZXF1YWxBcnJheXModGhpcy5yZXR1cm5TdGF0ZXMsIG90aGVyLnJldHVyblN0YXRlcykgJiYgZXF1YWxBcnJheXModGhpcy5wYXJlbnRzLCBvdGhlci5wYXJlbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuIFwiW11cIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBzID0gXCJbXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yZXR1cm5TdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIHMgPSBzICsgXCIsIFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5yZXR1cm5TdGF0ZXNbaV0gPT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX1JFVFVSTl9TVEFURSkge1xuICAgICAgICAgICAgcyA9IHMgKyBcIiRcIjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzID0gcyArIHRoaXMucmV0dXJuU3RhdGVzW2ldO1xuICAgICAgICAgIGlmICh0aGlzLnBhcmVudHNbaV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHMgPSBzICsgXCIgXCIgKyB0aGlzLnBhcmVudHNbaV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMgPSBzICsgXCJudWxsXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzICsgXCJdXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXR1cm5TdGF0ZXMubGVuZ3RoO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gcHJlZGljdGlvbkNvbnRleHRGcm9tUnVsZUNvbnRleHQoYXRuLCBvdXRlckNvbnRleHQpIHtcbiAgICBpZiAob3V0ZXJDb250ZXh0ID09PSB2b2lkIDAgfHwgb3V0ZXJDb250ZXh0ID09PSBudWxsKSB7XG4gICAgICBvdXRlckNvbnRleHQgPSBSdWxlQ29udGV4dC5FTVBUWTtcbiAgICB9XG4gICAgaWYgKG91dGVyQ29udGV4dC5wYXJlbnRDdHggPT09IG51bGwgfHwgb3V0ZXJDb250ZXh0ID09PSBSdWxlQ29udGV4dC5FTVBUWSkge1xuICAgICAgcmV0dXJuIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnQgPSBwcmVkaWN0aW9uQ29udGV4dEZyb21SdWxlQ29udGV4dChhdG4sIG91dGVyQ29udGV4dC5wYXJlbnRDdHgpO1xuICAgIGNvbnN0IHN0YXRlID0gYXRuLnN0YXRlc1tvdXRlckNvbnRleHQuaW52b2tpbmdTdGF0ZV07XG4gICAgY29uc3QgdHJhbnNpdGlvbiA9IHN0YXRlLnRyYW5zaXRpb25zWzBdO1xuICAgIHJldHVybiBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dC5jcmVhdGUocGFyZW50LCB0cmFuc2l0aW9uLmZvbGxvd1N0YXRlLnN0YXRlTnVtYmVyKTtcbiAgfVxuICBmdW5jdGlvbiBtZXJnZShhLCBiLCByb290SXNXaWxkY2FyZCwgbWVyZ2VDYWNoZSkge1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dCAmJiBiIGluc3RhbmNlb2YgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQpIHtcbiAgICAgIHJldHVybiBtZXJnZVNpbmdsZXRvbnMoYSwgYiwgcm9vdElzV2lsZGNhcmQsIG1lcmdlQ2FjaGUpO1xuICAgIH1cbiAgICBpZiAocm9vdElzV2lsZGNhcmQpIHtcbiAgICAgIGlmIChhIGluc3RhbmNlb2YgRW1wdHlQcmVkaWN0aW9uQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH1cbiAgICAgIGlmIChiIGluc3RhbmNlb2YgRW1wdHlQcmVkaWN0aW9uQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dCkge1xuICAgICAgYSA9IG5ldyBBcnJheVByZWRpY3Rpb25Db250ZXh0KFthLmdldFBhcmVudCgpXSwgW2EucmV0dXJuU3RhdGVdKTtcbiAgICB9XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dCkge1xuICAgICAgYiA9IG5ldyBBcnJheVByZWRpY3Rpb25Db250ZXh0KFtiLmdldFBhcmVudCgpXSwgW2IucmV0dXJuU3RhdGVdKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlQXJyYXlzKGEsIGIsIHJvb3RJc1dpbGRjYXJkLCBtZXJnZUNhY2hlKTtcbiAgfVxuICBmdW5jdGlvbiBtZXJnZVNpbmdsZXRvbnMoYSwgYiwgcm9vdElzV2lsZGNhcmQsIG1lcmdlQ2FjaGUpIHtcbiAgICBpZiAobWVyZ2VDYWNoZSAhPT0gbnVsbCkge1xuICAgICAgbGV0IHByZXZpb3VzID0gbWVyZ2VDYWNoZS5nZXQoYSwgYik7XG4gICAgICBpZiAocHJldmlvdXMgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzO1xuICAgICAgfVxuICAgICAgcHJldmlvdXMgPSBtZXJnZUNhY2hlLmdldChiLCBhKTtcbiAgICAgIGlmIChwcmV2aW91cyAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJvb3RNZXJnZSA9IG1lcmdlUm9vdChhLCBiLCByb290SXNXaWxkY2FyZCk7XG4gICAgaWYgKHJvb3RNZXJnZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG1lcmdlQ2FjaGUgIT09IG51bGwpIHtcbiAgICAgICAgbWVyZ2VDYWNoZS5zZXQoYSwgYiwgcm9vdE1lcmdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb290TWVyZ2U7XG4gICAgfVxuICAgIGlmIChhLnJldHVyblN0YXRlID09PSBiLnJldHVyblN0YXRlKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBtZXJnZShhLnBhcmVudEN0eCwgYi5wYXJlbnRDdHgsIHJvb3RJc1dpbGRjYXJkLCBtZXJnZUNhY2hlKTtcbiAgICAgIGlmIChwYXJlbnQgPT09IGEucGFyZW50Q3R4KSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudCA9PT0gYi5wYXJlbnRDdHgpIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9XG4gICAgICBjb25zdCBzcGMgPSBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dC5jcmVhdGUocGFyZW50LCBhLnJldHVyblN0YXRlKTtcbiAgICAgIGlmIChtZXJnZUNhY2hlICE9PSBudWxsKSB7XG4gICAgICAgIG1lcmdlQ2FjaGUuc2V0KGEsIGIsIHNwYyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3BjO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgc2luZ2xlUGFyZW50ID0gbnVsbDtcbiAgICAgIGlmIChhID09PSBiIHx8IGEucGFyZW50Q3R4ICE9PSBudWxsICYmIGEucGFyZW50Q3R4ID09PSBiLnBhcmVudEN0eCkge1xuICAgICAgICBzaW5nbGVQYXJlbnQgPSBhLnBhcmVudEN0eDtcbiAgICAgIH1cbiAgICAgIGlmIChzaW5nbGVQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZHMyID0gW2EucmV0dXJuU3RhdGUsIGIucmV0dXJuU3RhdGVdO1xuICAgICAgICBpZiAoYS5yZXR1cm5TdGF0ZSA+IGIucmV0dXJuU3RhdGUpIHtcbiAgICAgICAgICBwYXlsb2FkczJbMF0gPSBiLnJldHVyblN0YXRlO1xuICAgICAgICAgIHBheWxvYWRzMlsxXSA9IGEucmV0dXJuU3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50czIgPSBbc2luZ2xlUGFyZW50LCBzaW5nbGVQYXJlbnRdO1xuICAgICAgICBjb25zdCBhcGMgPSBuZXcgQXJyYXlQcmVkaWN0aW9uQ29udGV4dChwYXJlbnRzMiwgcGF5bG9hZHMyKTtcbiAgICAgICAgaWYgKG1lcmdlQ2FjaGUgIT09IG51bGwpIHtcbiAgICAgICAgICBtZXJnZUNhY2hlLnNldChhLCBiLCBhcGMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcGM7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXlsb2FkcyA9IFthLnJldHVyblN0YXRlLCBiLnJldHVyblN0YXRlXTtcbiAgICAgIGxldCBwYXJlbnRzID0gW2EucGFyZW50Q3R4LCBiLnBhcmVudEN0eF07XG4gICAgICBpZiAoYS5yZXR1cm5TdGF0ZSA+IGIucmV0dXJuU3RhdGUpIHtcbiAgICAgICAgcGF5bG9hZHNbMF0gPSBiLnJldHVyblN0YXRlO1xuICAgICAgICBwYXlsb2Fkc1sxXSA9IGEucmV0dXJuU3RhdGU7XG4gICAgICAgIHBhcmVudHMgPSBbYi5wYXJlbnRDdHgsIGEucGFyZW50Q3R4XTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFfID0gbmV3IEFycmF5UHJlZGljdGlvbkNvbnRleHQocGFyZW50cywgcGF5bG9hZHMpO1xuICAgICAgaWYgKG1lcmdlQ2FjaGUgIT09IG51bGwpIHtcbiAgICAgICAgbWVyZ2VDYWNoZS5zZXQoYSwgYiwgYV8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFfO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZVJvb3QoYSwgYiwgcm9vdElzV2lsZGNhcmQpIHtcbiAgICBpZiAocm9vdElzV2lsZGNhcmQpIHtcbiAgICAgIGlmIChhID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWSkge1xuICAgICAgICByZXR1cm4gUHJlZGljdGlvbkNvbnRleHQuRU1QVFk7XG4gICAgICB9XG4gICAgICBpZiAoYiA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFkpIHtcbiAgICAgICAgcmV0dXJuIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYSA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFkgJiYgYiA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFkpIHtcbiAgICAgICAgcmV0dXJuIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZO1xuICAgICAgfSBlbHNlIGlmIChhID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWSkge1xuICAgICAgICBjb25zdCBwYXlsb2FkcyA9IFtcbiAgICAgICAgICBiLnJldHVyblN0YXRlLFxuICAgICAgICAgIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX1JFVFVSTl9TVEFURVxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBwYXJlbnRzID0gW2IucGFyZW50Q3R4LCBudWxsXTtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheVByZWRpY3Rpb25Db250ZXh0KHBhcmVudHMsIHBheWxvYWRzKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFkpIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZHMgPSBbYS5yZXR1cm5TdGF0ZSwgUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfUkVUVVJOX1NUQVRFXTtcbiAgICAgICAgY29uc3QgcGFyZW50cyA9IFthLnBhcmVudEN0eCwgbnVsbF07XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlQcmVkaWN0aW9uQ29udGV4dChwYXJlbnRzLCBwYXlsb2Fkcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIG1lcmdlQXJyYXlzKGEsIGIsIHJvb3RJc1dpbGRjYXJkLCBtZXJnZUNhY2hlKSB7XG4gICAgaWYgKG1lcmdlQ2FjaGUgIT09IG51bGwpIHtcbiAgICAgIGxldCBwcmV2aW91cyA9IG1lcmdlQ2FjaGUuZ2V0KGEsIGIpO1xuICAgICAgaWYgKHByZXZpb3VzICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzID0gbWVyZ2VDYWNoZS5nZXQoYiwgYSk7XG4gICAgICBpZiAocHJldmlvdXMgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGogPSAwO1xuICAgIGxldCBrID0gMDtcbiAgICBsZXQgbWVyZ2VkUmV0dXJuU3RhdGVzID0gW107XG4gICAgbGV0IG1lcmdlZFBhcmVudHMgPSBbXTtcbiAgICB3aGlsZSAoaSA8IGEucmV0dXJuU3RhdGVzLmxlbmd0aCAmJiBqIDwgYi5yZXR1cm5TdGF0ZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBhX3BhcmVudCA9IGEucGFyZW50c1tpXTtcbiAgICAgIGNvbnN0IGJfcGFyZW50ID0gYi5wYXJlbnRzW2pdO1xuICAgICAgaWYgKGEucmV0dXJuU3RhdGVzW2ldID09PSBiLnJldHVyblN0YXRlc1tqXSkge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gYS5yZXR1cm5TdGF0ZXNbaV07XG4gICAgICAgIGNvbnN0IGJvdGhEb2xsYXJzID0gcGF5bG9hZCA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfUkVUVVJOX1NUQVRFICYmIGFfcGFyZW50ID09PSBudWxsICYmIGJfcGFyZW50ID09PSBudWxsO1xuICAgICAgICBjb25zdCBheF9heCA9IGFfcGFyZW50ICE9PSBudWxsICYmIGJfcGFyZW50ICE9PSBudWxsICYmIGFfcGFyZW50ID09PSBiX3BhcmVudDtcbiAgICAgICAgaWYgKGJvdGhEb2xsYXJzIHx8IGF4X2F4KSB7XG4gICAgICAgICAgbWVyZ2VkUGFyZW50c1trXSA9IGFfcGFyZW50O1xuICAgICAgICAgIG1lcmdlZFJldHVyblN0YXRlc1trXSA9IHBheWxvYWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWVyZ2VkUGFyZW50c1trXSA9IG1lcmdlKGFfcGFyZW50LCBiX3BhcmVudCwgcm9vdElzV2lsZGNhcmQsIG1lcmdlQ2FjaGUpO1xuICAgICAgICAgIG1lcmdlZFJldHVyblN0YXRlc1trXSA9IHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgaSArPSAxO1xuICAgICAgICBqICs9IDE7XG4gICAgICB9IGVsc2UgaWYgKGEucmV0dXJuU3RhdGVzW2ldIDwgYi5yZXR1cm5TdGF0ZXNbal0pIHtcbiAgICAgICAgbWVyZ2VkUGFyZW50c1trXSA9IGFfcGFyZW50O1xuICAgICAgICBtZXJnZWRSZXR1cm5TdGF0ZXNba10gPSBhLnJldHVyblN0YXRlc1tpXTtcbiAgICAgICAgaSArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVyZ2VkUGFyZW50c1trXSA9IGJfcGFyZW50O1xuICAgICAgICBtZXJnZWRSZXR1cm5TdGF0ZXNba10gPSBiLnJldHVyblN0YXRlc1tqXTtcbiAgICAgICAgaiArPSAxO1xuICAgICAgfVxuICAgICAgayArPSAxO1xuICAgIH1cbiAgICBpZiAoaSA8IGEucmV0dXJuU3RhdGVzLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgcCA9IGk7IHAgPCBhLnJldHVyblN0YXRlcy5sZW5ndGg7IHArKykge1xuICAgICAgICBtZXJnZWRQYXJlbnRzW2tdID0gYS5wYXJlbnRzW3BdO1xuICAgICAgICBtZXJnZWRSZXR1cm5TdGF0ZXNba10gPSBhLnJldHVyblN0YXRlc1twXTtcbiAgICAgICAgayArPSAxO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBwID0gajsgcCA8IGIucmV0dXJuU3RhdGVzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgIG1lcmdlZFBhcmVudHNba10gPSBiLnBhcmVudHNbcF07XG4gICAgICAgIG1lcmdlZFJldHVyblN0YXRlc1trXSA9IGIucmV0dXJuU3RhdGVzW3BdO1xuICAgICAgICBrICs9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrIDwgbWVyZ2VkUGFyZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGFfID0gU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQuY3JlYXRlKG1lcmdlZFBhcmVudHNbMF0sIG1lcmdlZFJldHVyblN0YXRlc1swXSk7XG4gICAgICAgIGlmIChtZXJnZUNhY2hlICE9PSBudWxsKSB7XG4gICAgICAgICAgbWVyZ2VDYWNoZS5zZXQoYSwgYiwgYV8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhXztcbiAgICAgIH1cbiAgICAgIG1lcmdlZFBhcmVudHMgPSBtZXJnZWRQYXJlbnRzLnNsaWNlKDAsIGspO1xuICAgICAgbWVyZ2VkUmV0dXJuU3RhdGVzID0gbWVyZ2VkUmV0dXJuU3RhdGVzLnNsaWNlKDAsIGspO1xuICAgIH1cbiAgICBjb25zdCBNID0gbmV3IEFycmF5UHJlZGljdGlvbkNvbnRleHQobWVyZ2VkUGFyZW50cywgbWVyZ2VkUmV0dXJuU3RhdGVzKTtcbiAgICBpZiAoTSA9PT0gYSkge1xuICAgICAgaWYgKG1lcmdlQ2FjaGUgIT09IG51bGwpIHtcbiAgICAgICAgbWVyZ2VDYWNoZS5zZXQoYSwgYiwgYSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgaWYgKE0gPT09IGIpIHtcbiAgICAgIGlmIChtZXJnZUNhY2hlICE9PSBudWxsKSB7XG4gICAgICAgIG1lcmdlQ2FjaGUuc2V0KGEsIGIsIGIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIGNvbWJpbmVDb21tb25QYXJlbnRzKG1lcmdlZFBhcmVudHMpO1xuICAgIGlmIChtZXJnZUNhY2hlICE9PSBudWxsKSB7XG4gICAgICBtZXJnZUNhY2hlLnNldChhLCBiLCBNKTtcbiAgICB9XG4gICAgcmV0dXJuIE07XG4gIH1cbiAgZnVuY3Rpb24gY29tYmluZUNvbW1vblBhcmVudHMocGFyZW50cykge1xuICAgIGNvbnN0IHVuaXF1ZVBhcmVudHMgPSBuZXcgTWFwMigpO1xuICAgIGZvciAobGV0IHAgPSAwOyBwIDwgcGFyZW50cy5sZW5ndGg7IHArKykge1xuICAgICAgY29uc3QgcGFyZW50ID0gcGFyZW50c1twXTtcbiAgICAgIGlmICghdW5pcXVlUGFyZW50cy5jb250YWluc0tleShwYXJlbnQpKSB7XG4gICAgICAgIHVuaXF1ZVBhcmVudHMucHV0KHBhcmVudCwgcGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgcSA9IDA7IHEgPCBwYXJlbnRzLmxlbmd0aDsgcSsrKSB7XG4gICAgICBwYXJlbnRzW3FdID0gdW5pcXVlUGFyZW50cy5nZXQocGFyZW50c1txXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldENhY2hlZFByZWRpY3Rpb25Db250ZXh0KGNvbnRleHQsIGNvbnRleHRDYWNoZSwgdmlzaXRlZCkge1xuICAgIGlmIChjb250ZXh0LmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIGxldCBleGlzdGluZyA9IHZpc2l0ZWQuZ2V0KGNvbnRleHQpIHx8IG51bGw7XG4gICAgaWYgKGV4aXN0aW5nICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gY29udGV4dENhY2hlLmdldChjb250ZXh0KTtcbiAgICBpZiAoZXhpc3RpbmcgIT09IG51bGwpIHtcbiAgICAgIHZpc2l0ZWQucHV0KGNvbnRleHQsIGV4aXN0aW5nKTtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBsZXQgcGFyZW50cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGFyZW50ID0gZ2V0Q2FjaGVkUHJlZGljdGlvbkNvbnRleHQoY29udGV4dC5nZXRQYXJlbnQoaSksIGNvbnRleHRDYWNoZSwgdmlzaXRlZCk7XG4gICAgICBpZiAoY2hhbmdlZCB8fCBwYXJlbnQgIT09IGNvbnRleHQuZ2V0UGFyZW50KGkpKSB7XG4gICAgICAgIGlmICghY2hhbmdlZCkge1xuICAgICAgICAgIHBhcmVudHMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbnRleHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHBhcmVudHNbal0gPSBjb250ZXh0LmdldFBhcmVudChqKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50c1tpXSA9IHBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjaGFuZ2VkKSB7XG4gICAgICBjb250ZXh0Q2FjaGUuYWRkKGNvbnRleHQpO1xuICAgICAgdmlzaXRlZC5wdXQoY29udGV4dCwgY29udGV4dCk7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gICAgbGV0IHVwZGF0ZWQgPSBudWxsO1xuICAgIGlmIChwYXJlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdXBkYXRlZCA9IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZO1xuICAgIH0gZWxzZSBpZiAocGFyZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHVwZGF0ZWQgPSBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dC5jcmVhdGUocGFyZW50c1swXSwgY29udGV4dC5nZXRSZXR1cm5TdGF0ZSgwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZWQgPSBuZXcgQXJyYXlQcmVkaWN0aW9uQ29udGV4dChwYXJlbnRzLCBjb250ZXh0LnJldHVyblN0YXRlcyk7XG4gICAgfVxuICAgIGNvbnRleHRDYWNoZS5hZGQodXBkYXRlZCk7XG4gICAgdmlzaXRlZC5wdXQodXBkYXRlZCwgdXBkYXRlZCk7XG4gICAgdmlzaXRlZC5wdXQoY29udGV4dCwgdXBkYXRlZCk7XG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH1cbiAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgIG1lcmdlLFxuICAgIFByZWRpY3Rpb25Db250ZXh0LFxuICAgIFByZWRpY3Rpb25Db250ZXh0Q2FjaGUsXG4gICAgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQsXG4gICAgcHJlZGljdGlvbkNvbnRleHRGcm9tUnVsZUNvbnRleHQsXG4gICAgZ2V0Q2FjaGVkUHJlZGljdGlvbkNvbnRleHRcbiAgfTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0L3NyYy9hbnRscjQvTEwxQW5hbHl6ZXIuanNcbnZhciByZXF1aXJlX0xMMUFuYWx5emVyMiA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZTIpID0+IHtcbiAgdmFyIHtTZXQ6IFNldDIsIEJpdFNldH0gPSByZXF1aXJlX1V0aWxzMigpO1xuICB2YXIge1Rva2VuOiBUb2tlbjJ9ID0gcmVxdWlyZV9Ub2tlbjIoKTtcbiAgdmFyIHtBVE5Db25maWd9ID0gcmVxdWlyZV9BVE5Db25maWcyKCk7XG4gIHZhciB7SW50ZXJ2YWxTZXR9ID0gcmVxdWlyZV9JbnRlcnZhbFNldDIoKTtcbiAgdmFyIHtSdWxlU3RvcFN0YXRlfSA9IHJlcXVpcmVfQVROU3RhdGUyKCk7XG4gIHZhciB7UnVsZVRyYW5zaXRpb24sIE5vdFNldFRyYW5zaXRpb24sIFdpbGRjYXJkVHJhbnNpdGlvbiwgQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9ufSA9IHJlcXVpcmVfVHJhbnNpdGlvbjIoKTtcbiAgdmFyIHtwcmVkaWN0aW9uQ29udGV4dEZyb21SdWxlQ29udGV4dCwgUHJlZGljdGlvbkNvbnRleHQsIFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0fSA9IHJlcXVpcmVfUHJlZGljdGlvbkNvbnRleHQyKCk7XG4gIHZhciBMTDFBbmFseXplciA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihhdG4pIHtcbiAgICAgIHRoaXMuYXRuID0gYXRuO1xuICAgIH1cbiAgICBnZXREZWNpc2lvbkxvb2thaGVhZChzKSB7XG4gICAgICBpZiAocyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvdW50ID0gcy50cmFuc2l0aW9ucy5sZW5ndGg7XG4gICAgICBjb25zdCBsb29rID0gW107XG4gICAgICBmb3IgKGxldCBhbHQgPSAwOyBhbHQgPCBjb3VudDsgYWx0KyspIHtcbiAgICAgICAgbG9va1thbHRdID0gbmV3IEludGVydmFsU2V0KCk7XG4gICAgICAgIGNvbnN0IGxvb2tCdXN5ID0gbmV3IFNldDIoKTtcbiAgICAgICAgY29uc3Qgc2VlVGhydVByZWRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX0xPT0socy50cmFuc2l0aW9uKGFsdCkudGFyZ2V0LCBudWxsLCBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWSwgbG9va1thbHRdLCBsb29rQnVzeSwgbmV3IEJpdFNldCgpLCBzZWVUaHJ1UHJlZHMsIGZhbHNlKTtcbiAgICAgICAgaWYgKGxvb2tbYWx0XS5sZW5ndGggPT09IDAgfHwgbG9va1thbHRdLmNvbnRhaW5zKExMMUFuYWx5emVyLkhJVF9QUkVEKSkge1xuICAgICAgICAgIGxvb2tbYWx0XSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsb29rO1xuICAgIH1cbiAgICBMT09LKHMsIHN0b3BTdGF0ZSwgY3R4KSB7XG4gICAgICBjb25zdCByID0gbmV3IEludGVydmFsU2V0KCk7XG4gICAgICBjb25zdCBzZWVUaHJ1UHJlZHMgPSB0cnVlO1xuICAgICAgY3R4ID0gY3R4IHx8IG51bGw7XG4gICAgICBjb25zdCBsb29rQ29udGV4dCA9IGN0eCAhPT0gbnVsbCA/IHByZWRpY3Rpb25Db250ZXh0RnJvbVJ1bGVDb250ZXh0KHMuYXRuLCBjdHgpIDogbnVsbDtcbiAgICAgIHRoaXMuX0xPT0socywgc3RvcFN0YXRlLCBsb29rQ29udGV4dCwgciwgbmV3IFNldDIoKSwgbmV3IEJpdFNldCgpLCBzZWVUaHJ1UHJlZHMsIHRydWUpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIF9MT09LKHMsIHN0b3BTdGF0ZSwgY3R4LCBsb29rLCBsb29rQnVzeSwgY2FsbGVkUnVsZVN0YWNrLCBzZWVUaHJ1UHJlZHMsIGFkZEVPRikge1xuICAgICAgY29uc3QgYyA9IG5ldyBBVE5Db25maWcoe3N0YXRlOiBzLCBhbHQ6IDAsIGNvbnRleHQ6IGN0eH0sIG51bGwpO1xuICAgICAgaWYgKGxvb2tCdXN5LmNvbnRhaW5zKGMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvb2tCdXN5LmFkZChjKTtcbiAgICAgIGlmIChzID09PSBzdG9wU3RhdGUpIHtcbiAgICAgICAgaWYgKGN0eCA9PT0gbnVsbCkge1xuICAgICAgICAgIGxvb2suYWRkT25lKFRva2VuMi5FUFNJTE9OKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoY3R4LmlzRW1wdHkoKSAmJiBhZGRFT0YpIHtcbiAgICAgICAgICBsb29rLmFkZE9uZShUb2tlbjIuRU9GKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkge1xuICAgICAgICBpZiAoY3R4ID09PSBudWxsKSB7XG4gICAgICAgICAgbG9vay5hZGRPbmUoVG9rZW4yLkVQU0lMT04pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChjdHguaXNFbXB0eSgpICYmIGFkZEVPRikge1xuICAgICAgICAgIGxvb2suYWRkT25lKFRva2VuMi5FT0YpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4ICE9PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWSkge1xuICAgICAgICAgIGNvbnN0IHJlbW92ZWQgPSBjYWxsZWRSdWxlU3RhY2suY29udGFpbnMocy5ydWxlSW5kZXgpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYWxsZWRSdWxlU3RhY2sucmVtb3ZlKHMucnVsZUluZGV4KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3R4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJldHVyblN0YXRlID0gdGhpcy5hdG4uc3RhdGVzW2N0eC5nZXRSZXR1cm5TdGF0ZShpKV07XG4gICAgICAgICAgICAgIHRoaXMuX0xPT0socmV0dXJuU3RhdGUsIHN0b3BTdGF0ZSwgY3R4LmdldFBhcmVudChpKSwgbG9vaywgbG9va0J1c3ksIGNhbGxlZFJ1bGVTdGFjaywgc2VlVGhydVByZWRzLCBhZGRFT0YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgICAgICBjYWxsZWRSdWxlU3RhY2suYWRkKHMucnVsZUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHMudHJhbnNpdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgdCA9IHMudHJhbnNpdGlvbnNbal07XG4gICAgICAgIGlmICh0LmNvbnN0cnVjdG9yID09PSBSdWxlVHJhbnNpdGlvbikge1xuICAgICAgICAgIGlmIChjYWxsZWRSdWxlU3RhY2suY29udGFpbnModC50YXJnZXQucnVsZUluZGV4KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5ld0NvbnRleHQgPSBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dC5jcmVhdGUoY3R4LCB0LmZvbGxvd1N0YXRlLnN0YXRlTnVtYmVyKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2FsbGVkUnVsZVN0YWNrLmFkZCh0LnRhcmdldC5ydWxlSW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5fTE9PSyh0LnRhcmdldCwgc3RvcFN0YXRlLCBuZXdDb250ZXh0LCBsb29rLCBsb29rQnVzeSwgY2FsbGVkUnVsZVN0YWNrLCBzZWVUaHJ1UHJlZHMsIGFkZEVPRik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNhbGxlZFJ1bGVTdGFjay5yZW1vdmUodC50YXJnZXQucnVsZUluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodCBpbnN0YW5jZW9mIEFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbikge1xuICAgICAgICAgIGlmIChzZWVUaHJ1UHJlZHMpIHtcbiAgICAgICAgICAgIHRoaXMuX0xPT0sodC50YXJnZXQsIHN0b3BTdGF0ZSwgY3R4LCBsb29rLCBsb29rQnVzeSwgY2FsbGVkUnVsZVN0YWNrLCBzZWVUaHJ1UHJlZHMsIGFkZEVPRik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvb2suYWRkT25lKExMMUFuYWx5emVyLkhJVF9QUkVEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodC5pc0Vwc2lsb24pIHtcbiAgICAgICAgICB0aGlzLl9MT09LKHQudGFyZ2V0LCBzdG9wU3RhdGUsIGN0eCwgbG9vaywgbG9va0J1c3ksIGNhbGxlZFJ1bGVTdGFjaywgc2VlVGhydVByZWRzLCBhZGRFT0YpO1xuICAgICAgICB9IGVsc2UgaWYgKHQuY29uc3RydWN0b3IgPT09IFdpbGRjYXJkVHJhbnNpdGlvbikge1xuICAgICAgICAgIGxvb2suYWRkUmFuZ2UoVG9rZW4yLk1JTl9VU0VSX1RPS0VOX1RZUEUsIHRoaXMuYXRuLm1heFRva2VuVHlwZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IHNldCA9IHQubGFiZWw7XG4gICAgICAgICAgaWYgKHNldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiBOb3RTZXRUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgIHNldCA9IHNldC5jb21wbGVtZW50KFRva2VuMi5NSU5fVVNFUl9UT0tFTl9UWVBFLCB0aGlzLmF0bi5tYXhUb2tlblR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9vay5hZGRTZXQoc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIExMMUFuYWx5emVyLkhJVF9QUkVEID0gVG9rZW4yLklOVkFMSURfVFlQRTtcbiAgbW9kdWxlMi5leHBvcnRzID0gTEwxQW5hbHl6ZXI7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNC9zcmMvYW50bHI0L2F0bi9BVE4uanNcbnZhciByZXF1aXJlX0FUTjIgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUyKSA9PiB7XG4gIHZhciBMTDFBbmFseXplciA9IHJlcXVpcmVfTEwxQW5hbHl6ZXIyKCk7XG4gIHZhciB7SW50ZXJ2YWxTZXR9ID0gcmVxdWlyZV9JbnRlcnZhbFNldDIoKTtcbiAgdmFyIHtUb2tlbjogVG9rZW4yfSA9IHJlcXVpcmVfVG9rZW4yKCk7XG4gIHZhciBBVE4yID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGdyYW1tYXJUeXBlLCBtYXhUb2tlblR5cGUpIHtcbiAgICAgIHRoaXMuZ3JhbW1hclR5cGUgPSBncmFtbWFyVHlwZTtcbiAgICAgIHRoaXMubWF4VG9rZW5UeXBlID0gbWF4VG9rZW5UeXBlO1xuICAgICAgdGhpcy5zdGF0ZXMgPSBbXTtcbiAgICAgIHRoaXMuZGVjaXNpb25Ub1N0YXRlID0gW107XG4gICAgICB0aGlzLnJ1bGVUb1N0YXJ0U3RhdGUgPSBbXTtcbiAgICAgIHRoaXMucnVsZVRvU3RvcFN0YXRlID0gbnVsbDtcbiAgICAgIHRoaXMubW9kZU5hbWVUb1N0YXJ0U3RhdGUgPSB7fTtcbiAgICAgIHRoaXMucnVsZVRvVG9rZW5UeXBlID0gbnVsbDtcbiAgICAgIHRoaXMubGV4ZXJBY3Rpb25zID0gbnVsbDtcbiAgICAgIHRoaXMubW9kZVRvU3RhcnRTdGF0ZSA9IFtdO1xuICAgIH1cbiAgICBuZXh0VG9rZW5zSW5Db250ZXh0KHMsIGN0eCkge1xuICAgICAgY29uc3QgYW5hbCA9IG5ldyBMTDFBbmFseXplcih0aGlzKTtcbiAgICAgIHJldHVybiBhbmFsLkxPT0socywgbnVsbCwgY3R4KTtcbiAgICB9XG4gICAgbmV4dFRva2Vuc05vQ29udGV4dChzKSB7XG4gICAgICBpZiAocy5uZXh0VG9rZW5XaXRoaW5SdWxlICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzLm5leHRUb2tlbldpdGhpblJ1bGU7XG4gICAgICB9XG4gICAgICBzLm5leHRUb2tlbldpdGhpblJ1bGUgPSB0aGlzLm5leHRUb2tlbnNJbkNvbnRleHQocywgbnVsbCk7XG4gICAgICBzLm5leHRUb2tlbldpdGhpblJ1bGUucmVhZE9ubHkgPSB0cnVlO1xuICAgICAgcmV0dXJuIHMubmV4dFRva2VuV2l0aGluUnVsZTtcbiAgICB9XG4gICAgbmV4dFRva2VucyhzLCBjdHgpIHtcbiAgICAgIGlmIChjdHggPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW5zTm9Db250ZXh0KHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2Vuc0luQ29udGV4dChzLCBjdHgpO1xuICAgICAgfVxuICAgIH1cbiAgICBhZGRTdGF0ZShzdGF0ZSkge1xuICAgICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHN0YXRlLmF0biA9IHRoaXM7XG4gICAgICAgIHN0YXRlLnN0YXRlTnVtYmVyID0gdGhpcy5zdGF0ZXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZXMucHVzaChzdGF0ZSk7XG4gICAgfVxuICAgIHJlbW92ZVN0YXRlKHN0YXRlKSB7XG4gICAgICB0aGlzLnN0YXRlc1tzdGF0ZS5zdGF0ZU51bWJlcl0gPSBudWxsO1xuICAgIH1cbiAgICBkZWZpbmVEZWNpc2lvblN0YXRlKHMpIHtcbiAgICAgIHRoaXMuZGVjaXNpb25Ub1N0YXRlLnB1c2gocyk7XG4gICAgICBzLmRlY2lzaW9uID0gdGhpcy5kZWNpc2lvblRvU3RhdGUubGVuZ3RoIC0gMTtcbiAgICAgIHJldHVybiBzLmRlY2lzaW9uO1xuICAgIH1cbiAgICBnZXREZWNpc2lvblN0YXRlKGRlY2lzaW9uKSB7XG4gICAgICBpZiAodGhpcy5kZWNpc2lvblRvU3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjaXNpb25Ub1N0YXRlW2RlY2lzaW9uXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0RXhwZWN0ZWRUb2tlbnMoc3RhdGVOdW1iZXIsIGN0eCkge1xuICAgICAgaWYgKHN0YXRlTnVtYmVyIDwgMCB8fCBzdGF0ZU51bWJlciA+PSB0aGlzLnN0YXRlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHN0YXRlIG51bWJlci5cIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHMgPSB0aGlzLnN0YXRlc1tzdGF0ZU51bWJlcl07XG4gICAgICBsZXQgZm9sbG93aW5nID0gdGhpcy5uZXh0VG9rZW5zKHMpO1xuICAgICAgaWYgKCFmb2xsb3dpbmcuY29udGFpbnMoVG9rZW4yLkVQU0lMT04pKSB7XG4gICAgICAgIHJldHVybiBmb2xsb3dpbmc7XG4gICAgICB9XG4gICAgICBjb25zdCBleHBlY3RlZCA9IG5ldyBJbnRlcnZhbFNldCgpO1xuICAgICAgZXhwZWN0ZWQuYWRkU2V0KGZvbGxvd2luZyk7XG4gICAgICBleHBlY3RlZC5yZW1vdmVPbmUoVG9rZW4yLkVQU0lMT04pO1xuICAgICAgd2hpbGUgKGN0eCAhPT0gbnVsbCAmJiBjdHguaW52b2tpbmdTdGF0ZSA+PSAwICYmIGZvbGxvd2luZy5jb250YWlucyhUb2tlbjIuRVBTSUxPTikpIHtcbiAgICAgICAgY29uc3QgaW52b2tpbmdTdGF0ZSA9IHRoaXMuc3RhdGVzW2N0eC5pbnZva2luZ1N0YXRlXTtcbiAgICAgICAgY29uc3QgcnQgPSBpbnZva2luZ1N0YXRlLnRyYW5zaXRpb25zWzBdO1xuICAgICAgICBmb2xsb3dpbmcgPSB0aGlzLm5leHRUb2tlbnMocnQuZm9sbG93U3RhdGUpO1xuICAgICAgICBleHBlY3RlZC5hZGRTZXQoZm9sbG93aW5nKTtcbiAgICAgICAgZXhwZWN0ZWQucmVtb3ZlT25lKFRva2VuMi5FUFNJTE9OKTtcbiAgICAgICAgY3R4ID0gY3R4LnBhcmVudEN0eDtcbiAgICAgIH1cbiAgICAgIGlmIChmb2xsb3dpbmcuY29udGFpbnMoVG9rZW4yLkVQU0lMT04pKSB7XG4gICAgICAgIGV4cGVjdGVkLmFkZE9uZShUb2tlbjIuRU9GKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICB9XG4gIH07XG4gIEFUTjIuSU5WQUxJRF9BTFRfTlVNQkVSID0gMDtcbiAgbW9kdWxlMi5leHBvcnRzID0gQVROMjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0L3NyYy9hbnRscjQvYXRuL0FUTlR5cGUuanNcbnZhciByZXF1aXJlX0FUTlR5cGUgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUyKSA9PiB7XG4gIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICBMRVhFUjogMCxcbiAgICBQQVJTRVI6IDFcbiAgfTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0L3NyYy9hbnRscjQvYXRuL0FUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMuanNcbnZhciByZXF1aXJlX0FUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMyID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlMikgPT4ge1xuICB2YXIgQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucyA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihjb3B5RnJvbSkge1xuICAgICAgaWYgKGNvcHlGcm9tID09PSB2b2lkIDApIHtcbiAgICAgICAgY29weUZyb20gPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWFkT25seSA9IGZhbHNlO1xuICAgICAgdGhpcy52ZXJpZnlBVE4gPSBjb3B5RnJvbSA9PT0gbnVsbCA/IHRydWUgOiBjb3B5RnJvbS52ZXJpZnlBVE47XG4gICAgICB0aGlzLmdlbmVyYXRlUnVsZUJ5cGFzc1RyYW5zaXRpb25zID0gY29weUZyb20gPT09IG51bGwgPyBmYWxzZSA6IGNvcHlGcm9tLmdlbmVyYXRlUnVsZUJ5cGFzc1RyYW5zaXRpb25zO1xuICAgIH1cbiAgfTtcbiAgQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucy5kZWZhdWx0T3B0aW9ucyA9IG5ldyBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zKCk7XG4gIEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMuZGVmYXVsdE9wdGlvbnMucmVhZE9ubHkgPSB0cnVlO1xuICBtb2R1bGUyLmV4cG9ydHMgPSBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjQvc3JjL2FudGxyNC9hdG4vTGV4ZXJBY3Rpb24uanNcbnZhciByZXF1aXJlX0xleGVyQWN0aW9uID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlMikgPT4ge1xuICB2YXIgTGV4ZXJBY3Rpb25UeXBlID0ge1xuICAgIENIQU5ORUw6IDAsXG4gICAgQ1VTVE9NOiAxLFxuICAgIE1PREU6IDIsXG4gICAgTU9SRTogMyxcbiAgICBQT1BfTU9ERTogNCxcbiAgICBQVVNIX01PREU6IDUsXG4gICAgU0tJUDogNixcbiAgICBUWVBFOiA3XG4gIH07XG4gIHZhciBMZXhlckFjdGlvbiA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihhY3Rpb24pIHtcbiAgICAgIHRoaXMuYWN0aW9uVHlwZSA9IGFjdGlvbjtcbiAgICAgIHRoaXMuaXNQb3NpdGlvbkRlcGVuZGVudCA9IGZhbHNlO1xuICAgIH1cbiAgICBoYXNoQ29kZSgpIHtcbiAgICAgIGNvbnN0IGhhc2ggPSBuZXcgSGFzaCgpO1xuICAgICAgdGhpcy51cGRhdGVIYXNoQ29kZShoYXNoKTtcbiAgICAgIHJldHVybiBoYXNoLmZpbmlzaCgpO1xuICAgIH1cbiAgICB1cGRhdGVIYXNoQ29kZShoYXNoKSB7XG4gICAgICBoYXNoLnVwZGF0ZSh0aGlzLmFjdGlvblR5cGUpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzID09PSBvdGhlcjtcbiAgICB9XG4gIH07XG4gIHZhciBMZXhlclNraXBBY3Rpb24gPSBjbGFzcyBleHRlbmRzIExleGVyQWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKExleGVyQWN0aW9uVHlwZS5TS0lQKTtcbiAgICB9XG4gICAgZXhlY3V0ZShsZXhlcikge1xuICAgICAgbGV4ZXIuc2tpcCgpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcInNraXBcIjtcbiAgICB9XG4gIH07XG4gIExleGVyU2tpcEFjdGlvbi5JTlNUQU5DRSA9IG5ldyBMZXhlclNraXBBY3Rpb24oKTtcbiAgdmFyIExleGVyVHlwZUFjdGlvbiA9IGNsYXNzIGV4dGVuZHMgTGV4ZXJBY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICAgIHN1cGVyKExleGVyQWN0aW9uVHlwZS5UWVBFKTtcbiAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIGV4ZWN1dGUobGV4ZXIpIHtcbiAgICAgIGxleGVyLnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgfVxuICAgIHVwZGF0ZUhhc2hDb2RlKGhhc2gpIHtcbiAgICAgIGhhc2gudXBkYXRlKHRoaXMuYWN0aW9uVHlwZSwgdGhpcy50eXBlKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBMZXhlclR5cGVBY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IG90aGVyLnR5cGU7XG4gICAgICB9XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwidHlwZShcIiArIHRoaXMudHlwZSArIFwiKVwiO1xuICAgIH1cbiAgfTtcbiAgdmFyIExleGVyUHVzaE1vZGVBY3Rpb24gPSBjbGFzcyBleHRlbmRzIExleGVyQWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlKSB7XG4gICAgICBzdXBlcihMZXhlckFjdGlvblR5cGUuUFVTSF9NT0RFKTtcbiAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgfVxuICAgIGV4ZWN1dGUobGV4ZXIpIHtcbiAgICAgIGxleGVyLnB1c2hNb2RlKHRoaXMubW9kZSk7XG4gICAgfVxuICAgIHVwZGF0ZUhhc2hDb2RlKGhhc2gpIHtcbiAgICAgIGhhc2gudXBkYXRlKHRoaXMuYWN0aW9uVHlwZSwgdGhpcy5tb2RlKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBMZXhlclB1c2hNb2RlQWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09PSBvdGhlci5tb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcInB1c2hNb2RlKFwiICsgdGhpcy5tb2RlICsgXCIpXCI7XG4gICAgfVxuICB9O1xuICB2YXIgTGV4ZXJQb3BNb2RlQWN0aW9uID0gY2xhc3MgZXh0ZW5kcyBMZXhlckFjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcihMZXhlckFjdGlvblR5cGUuUE9QX01PREUpO1xuICAgIH1cbiAgICBleGVjdXRlKGxleGVyKSB7XG4gICAgICBsZXhlci5wb3BNb2RlKCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwicG9wTW9kZVwiO1xuICAgIH1cbiAgfTtcbiAgTGV4ZXJQb3BNb2RlQWN0aW9uLklOU1RBTkNFID0gbmV3IExleGVyUG9wTW9kZUFjdGlvbigpO1xuICB2YXIgTGV4ZXJNb3JlQWN0aW9uID0gY2xhc3MgZXh0ZW5kcyBMZXhlckFjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcihMZXhlckFjdGlvblR5cGUuTU9SRSk7XG4gICAgfVxuICAgIGV4ZWN1dGUobGV4ZXIpIHtcbiAgICAgIGxleGVyLm1vcmUoKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJtb3JlXCI7XG4gICAgfVxuICB9O1xuICBMZXhlck1vcmVBY3Rpb24uSU5TVEFOQ0UgPSBuZXcgTGV4ZXJNb3JlQWN0aW9uKCk7XG4gIHZhciBMZXhlck1vZGVBY3Rpb24gPSBjbGFzcyBleHRlbmRzIExleGVyQWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlKSB7XG4gICAgICBzdXBlcihMZXhlckFjdGlvblR5cGUuTU9ERSk7XG4gICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgIH1cbiAgICBleGVjdXRlKGxleGVyKSB7XG4gICAgICBsZXhlci5tb2RlKHRoaXMubW9kZSk7XG4gICAgfVxuICAgIHVwZGF0ZUhhc2hDb2RlKGhhc2gpIHtcbiAgICAgIGhhc2gudXBkYXRlKHRoaXMuYWN0aW9uVHlwZSwgdGhpcy5tb2RlKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBMZXhlck1vZGVBY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGUgPT09IG90aGVyLm1vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwibW9kZShcIiArIHRoaXMubW9kZSArIFwiKVwiO1xuICAgIH1cbiAgfTtcbiAgdmFyIExleGVyQ3VzdG9tQWN0aW9uID0gY2xhc3MgZXh0ZW5kcyBMZXhlckFjdGlvbiB7XG4gICAgY29uc3RydWN0b3IocnVsZUluZGV4LCBhY3Rpb25JbmRleCkge1xuICAgICAgc3VwZXIoTGV4ZXJBY3Rpb25UeXBlLkNVU1RPTSk7XG4gICAgICB0aGlzLnJ1bGVJbmRleCA9IHJ1bGVJbmRleDtcbiAgICAgIHRoaXMuYWN0aW9uSW5kZXggPSBhY3Rpb25JbmRleDtcbiAgICAgIHRoaXMuaXNQb3NpdGlvbkRlcGVuZGVudCA9IHRydWU7XG4gICAgfVxuICAgIGV4ZWN1dGUobGV4ZXIpIHtcbiAgICAgIGxleGVyLmFjdGlvbihudWxsLCB0aGlzLnJ1bGVJbmRleCwgdGhpcy5hY3Rpb25JbmRleCk7XG4gICAgfVxuICAgIHVwZGF0ZUhhc2hDb2RlKGhhc2gpIHtcbiAgICAgIGhhc2gudXBkYXRlKHRoaXMuYWN0aW9uVHlwZSwgdGhpcy5ydWxlSW5kZXgsIHRoaXMuYWN0aW9uSW5kZXgpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIShvdGhlciBpbnN0YW5jZW9mIExleGVyQ3VzdG9tQWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5ydWxlSW5kZXggPT09IG90aGVyLnJ1bGVJbmRleCAmJiB0aGlzLmFjdGlvbkluZGV4ID09PSBvdGhlci5hY3Rpb25JbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBMZXhlckNoYW5uZWxBY3Rpb24gPSBjbGFzcyBleHRlbmRzIExleGVyQWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsKSB7XG4gICAgICBzdXBlcihMZXhlckFjdGlvblR5cGUuQ0hBTk5FTCk7XG4gICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgIH1cbiAgICBleGVjdXRlKGxleGVyKSB7XG4gICAgICBsZXhlci5fY2hhbm5lbCA9IHRoaXMuY2hhbm5lbDtcbiAgICB9XG4gICAgdXBkYXRlSGFzaENvZGUoaGFzaCkge1xuICAgICAgaGFzaC51cGRhdGUodGhpcy5hY3Rpb25UeXBlLCB0aGlzLmNoYW5uZWwpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIShvdGhlciBpbnN0YW5jZW9mIExleGVyQ2hhbm5lbEFjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbCA9PT0gb3RoZXIuY2hhbm5lbDtcbiAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJjaGFubmVsKFwiICsgdGhpcy5jaGFubmVsICsgXCIpXCI7XG4gICAgfVxuICB9O1xuICB2YXIgTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uID0gY2xhc3MgZXh0ZW5kcyBMZXhlckFjdGlvbiB7XG4gICAgY29uc3RydWN0b3Iob2Zmc2V0LCBhY3Rpb24pIHtcbiAgICAgIHN1cGVyKGFjdGlvbi5hY3Rpb25UeXBlKTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgdGhpcy5hY3Rpb24gPSBhY3Rpb247XG4gICAgICB0aGlzLmlzUG9zaXRpb25EZXBlbmRlbnQgPSB0cnVlO1xuICAgIH1cbiAgICBleGVjdXRlKGxleGVyKSB7XG4gICAgICB0aGlzLmFjdGlvbi5leGVjdXRlKGxleGVyKTtcbiAgICB9XG4gICAgdXBkYXRlSGFzaENvZGUoaGFzaCkge1xuICAgICAgaGFzaC51cGRhdGUodGhpcy5hY3Rpb25UeXBlLCB0aGlzLm9mZnNldCwgdGhpcy5hY3Rpb24pO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIShvdGhlciBpbnN0YW5jZW9mIExleGVySW5kZXhlZEN1c3RvbUFjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0ID09PSBvdGhlci5vZmZzZXQgJiYgdGhpcy5hY3Rpb24gPT09IG90aGVyLmFjdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICBMZXhlckFjdGlvblR5cGUsXG4gICAgTGV4ZXJTa2lwQWN0aW9uLFxuICAgIExleGVyQ2hhbm5lbEFjdGlvbixcbiAgICBMZXhlckN1c3RvbUFjdGlvbixcbiAgICBMZXhlckluZGV4ZWRDdXN0b21BY3Rpb24sXG4gICAgTGV4ZXJNb3JlQWN0aW9uLFxuICAgIExleGVyVHlwZUFjdGlvbixcbiAgICBMZXhlclB1c2hNb2RlQWN0aW9uLFxuICAgIExleGVyUG9wTW9kZUFjdGlvbixcbiAgICBMZXhlck1vZGVBY3Rpb25cbiAgfTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0L3NyYy9hbnRscjQvYXRuL0FUTkRlc2VyaWFsaXplci5qc1xudmFyIHJlcXVpcmVfQVRORGVzZXJpYWxpemVyMiA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZTIpID0+IHtcbiAgdmFyIHtUb2tlbjogVG9rZW4yfSA9IHJlcXVpcmVfVG9rZW4yKCk7XG4gIHZhciBBVE4yID0gcmVxdWlyZV9BVE4yKCk7XG4gIHZhciBBVE5UeXBlID0gcmVxdWlyZV9BVE5UeXBlKCk7XG4gIHZhciB7XG4gICAgQVROU3RhdGUsXG4gICAgQmFzaWNTdGF0ZSxcbiAgICBEZWNpc2lvblN0YXRlLFxuICAgIEJsb2NrU3RhcnRTdGF0ZSxcbiAgICBCbG9ja0VuZFN0YXRlLFxuICAgIExvb3BFbmRTdGF0ZSxcbiAgICBSdWxlU3RhcnRTdGF0ZSxcbiAgICBSdWxlU3RvcFN0YXRlLFxuICAgIFRva2Vuc1N0YXJ0U3RhdGUsXG4gICAgUGx1c0xvb3BiYWNrU3RhdGUsXG4gICAgU3Rhckxvb3BiYWNrU3RhdGUsXG4gICAgU3Rhckxvb3BFbnRyeVN0YXRlLFxuICAgIFBsdXNCbG9ja1N0YXJ0U3RhdGUsXG4gICAgU3RhckJsb2NrU3RhcnRTdGF0ZSxcbiAgICBCYXNpY0Jsb2NrU3RhcnRTdGF0ZVxuICB9ID0gcmVxdWlyZV9BVE5TdGF0ZTIoKTtcbiAgdmFyIHtcbiAgICBUcmFuc2l0aW9uLFxuICAgIEF0b21UcmFuc2l0aW9uOiBBdG9tVHJhbnNpdGlvbjIsXG4gICAgU2V0VHJhbnNpdGlvbixcbiAgICBOb3RTZXRUcmFuc2l0aW9uLFxuICAgIFJ1bGVUcmFuc2l0aW9uLFxuICAgIFJhbmdlVHJhbnNpdGlvbixcbiAgICBBY3Rpb25UcmFuc2l0aW9uLFxuICAgIEVwc2lsb25UcmFuc2l0aW9uLFxuICAgIFdpbGRjYXJkVHJhbnNpdGlvbixcbiAgICBQcmVkaWNhdGVUcmFuc2l0aW9uLFxuICAgIFByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uXG4gIH0gPSByZXF1aXJlX1RyYW5zaXRpb24yKCk7XG4gIHZhciB7SW50ZXJ2YWxTZXR9ID0gcmVxdWlyZV9JbnRlcnZhbFNldDIoKTtcbiAgdmFyIEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMgPSByZXF1aXJlX0FUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMyKCk7XG4gIHZhciB7XG4gICAgTGV4ZXJBY3Rpb25UeXBlLFxuICAgIExleGVyU2tpcEFjdGlvbixcbiAgICBMZXhlckNoYW5uZWxBY3Rpb24sXG4gICAgTGV4ZXJDdXN0b21BY3Rpb24sXG4gICAgTGV4ZXJNb3JlQWN0aW9uLFxuICAgIExleGVyVHlwZUFjdGlvbixcbiAgICBMZXhlclB1c2hNb2RlQWN0aW9uLFxuICAgIExleGVyUG9wTW9kZUFjdGlvbixcbiAgICBMZXhlck1vZGVBY3Rpb25cbiAgfSA9IHJlcXVpcmVfTGV4ZXJBY3Rpb24oKTtcbiAgdmFyIEJBU0VfU0VSSUFMSVpFRF9VVUlEID0gXCJBQURCOEQ3RS1BRUVGLTQ0MTUtQUQyQi04MjA0RDZDRjA0MkVcIjtcbiAgdmFyIEFEREVEX1VOSUNPREVfU01QID0gXCI1OTYyNzc4NC0zQkU1LTQxN0EtQjlFQi04MTMxQTcyODYwODlcIjtcbiAgdmFyIFNVUFBPUlRFRF9VVUlEUyA9IFtCQVNFX1NFUklBTElaRURfVVVJRCwgQURERURfVU5JQ09ERV9TTVBdO1xuICB2YXIgU0VSSUFMSVpFRF9WRVJTSU9OID0gMztcbiAgdmFyIFNFUklBTElaRURfVVVJRCA9IEFEREVEX1VOSUNPREVfU01QO1xuICBmdW5jdGlvbiBpbml0QXJyYXkobGVuZ3RoLCB2YWx1ZSkge1xuICAgIGNvbnN0IHRtcCA9IFtdO1xuICAgIHRtcFtsZW5ndGggLSAxXSA9IHZhbHVlO1xuICAgIHJldHVybiB0bXAubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuICB2YXIgQVRORGVzZXJpYWxpemVyMyA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwIHx8IG9wdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMuZGVmYXVsdE9wdGlvbnM7XG4gICAgICB9XG4gICAgICB0aGlzLmRlc2VyaWFsaXphdGlvbk9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgdGhpcy5zdGF0ZUZhY3RvcmllcyA9IG51bGw7XG4gICAgICB0aGlzLmFjdGlvbkZhY3RvcmllcyA9IG51bGw7XG4gICAgfVxuICAgIGlzRmVhdHVyZVN1cHBvcnRlZChmZWF0dXJlLCBhY3R1YWxVdWlkKSB7XG4gICAgICBjb25zdCBpZHgxID0gU1VQUE9SVEVEX1VVSURTLmluZGV4T2YoZmVhdHVyZSk7XG4gICAgICBpZiAoaWR4MSA8IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgaWR4MiA9IFNVUFBPUlRFRF9VVUlEUy5pbmRleE9mKGFjdHVhbFV1aWQpO1xuICAgICAgcmV0dXJuIGlkeDIgPj0gaWR4MTtcbiAgICB9XG4gICAgZGVzZXJpYWxpemUoZGF0YSkge1xuICAgICAgdGhpcy5yZXNldChkYXRhKTtcbiAgICAgIHRoaXMuY2hlY2tWZXJzaW9uKCk7XG4gICAgICB0aGlzLmNoZWNrVVVJRCgpO1xuICAgICAgY29uc3QgYXRuID0gdGhpcy5yZWFkQVROKCk7XG4gICAgICB0aGlzLnJlYWRTdGF0ZXMoYXRuKTtcbiAgICAgIHRoaXMucmVhZFJ1bGVzKGF0bik7XG4gICAgICB0aGlzLnJlYWRNb2RlcyhhdG4pO1xuICAgICAgY29uc3Qgc2V0cyA9IFtdO1xuICAgICAgdGhpcy5yZWFkU2V0cyhhdG4sIHNldHMsIHRoaXMucmVhZEludC5iaW5kKHRoaXMpKTtcbiAgICAgIGlmICh0aGlzLmlzRmVhdHVyZVN1cHBvcnRlZChBRERFRF9VTklDT0RFX1NNUCwgdGhpcy51dWlkKSkge1xuICAgICAgICB0aGlzLnJlYWRTZXRzKGF0biwgc2V0cywgdGhpcy5yZWFkSW50MzIuYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlYWRFZGdlcyhhdG4sIHNldHMpO1xuICAgICAgdGhpcy5yZWFkRGVjaXNpb25zKGF0bik7XG4gICAgICB0aGlzLnJlYWRMZXhlckFjdGlvbnMoYXRuKTtcbiAgICAgIHRoaXMubWFya1ByZWNlZGVuY2VEZWNpc2lvbnMoYXRuKTtcbiAgICAgIHRoaXMudmVyaWZ5QVROKGF0bik7XG4gICAgICBpZiAodGhpcy5kZXNlcmlhbGl6YXRpb25PcHRpb25zLmdlbmVyYXRlUnVsZUJ5cGFzc1RyYW5zaXRpb25zICYmIGF0bi5ncmFtbWFyVHlwZSA9PT0gQVROVHlwZS5QQVJTRVIpIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9ucyhhdG4pO1xuICAgICAgICB0aGlzLnZlcmlmeUFUTihhdG4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0bjtcbiAgICB9XG4gICAgcmVzZXQoZGF0YSkge1xuICAgICAgY29uc3QgYWRqdXN0ID0gZnVuY3Rpb24oYykge1xuICAgICAgICBjb25zdCB2ID0gYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICByZXR1cm4gdiA+IDEgPyB2IC0gMiA6IHYgKyA2NTUzNDtcbiAgICAgIH07XG4gICAgICBjb25zdCB0ZW1wID0gZGF0YS5zcGxpdChcIlwiKS5tYXAoYWRqdXN0KTtcbiAgICAgIHRlbXBbMF0gPSBkYXRhLmNoYXJDb2RlQXQoMCk7XG4gICAgICB0aGlzLmRhdGEgPSB0ZW1wO1xuICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICBjaGVja1ZlcnNpb24oKSB7XG4gICAgICBjb25zdCB2ZXJzaW9uID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICBpZiAodmVyc2lvbiAhPT0gU0VSSUFMSVpFRF9WRVJTSU9OKSB7XG4gICAgICAgIHRocm93IFwiQ291bGQgbm90IGRlc2VyaWFsaXplIEFUTiB3aXRoIHZlcnNpb24gXCIgKyB2ZXJzaW9uICsgXCIgKGV4cGVjdGVkIFwiICsgU0VSSUFMSVpFRF9WRVJTSU9OICsgXCIpLlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBjaGVja1VVSUQoKSB7XG4gICAgICBjb25zdCB1dWlkID0gdGhpcy5yZWFkVVVJRCgpO1xuICAgICAgaWYgKFNVUFBPUlRFRF9VVUlEUy5pbmRleE9mKHV1aWQpIDwgMCkge1xuICAgICAgICB0aHJvdyBcIkNvdWxkIG5vdCBkZXNlcmlhbGl6ZSBBVE4gd2l0aCBVVUlEOiBcIiArIHV1aWQgKyBcIiAoZXhwZWN0ZWQgXCIgKyBTRVJJQUxJWkVEX1VVSUQgKyBcIiBvciBhIGxlZ2FjeSBVVUlEKS5cIiwgdXVpZCwgU0VSSUFMSVpFRF9VVUlEO1xuICAgICAgfVxuICAgICAgdGhpcy51dWlkID0gdXVpZDtcbiAgICB9XG4gICAgcmVhZEFUTigpIHtcbiAgICAgIGNvbnN0IGdyYW1tYXJUeXBlID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICBjb25zdCBtYXhUb2tlblR5cGUgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgIHJldHVybiBuZXcgQVROMihncmFtbWFyVHlwZSwgbWF4VG9rZW5UeXBlKTtcbiAgICB9XG4gICAgcmVhZFN0YXRlcyhhdG4pIHtcbiAgICAgIGxldCBqLCBwYWlyLCBzdGF0ZU51bWJlcjtcbiAgICAgIGNvbnN0IGxvb3BCYWNrU3RhdGVOdW1iZXJzID0gW107XG4gICAgICBjb25zdCBlbmRTdGF0ZU51bWJlcnMgPSBbXTtcbiAgICAgIGNvbnN0IG5zdGF0ZXMgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnN0YXRlczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN0eXBlID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICAgIGlmIChzdHlwZSA9PT0gQVROU3RhdGUuSU5WQUxJRF9UWVBFKSB7XG4gICAgICAgICAgYXRuLmFkZFN0YXRlKG51bGwpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBydWxlSW5kZXggPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgaWYgKHJ1bGVJbmRleCA9PT0gNjU1MzUpIHtcbiAgICAgICAgICBydWxlSW5kZXggPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzID0gdGhpcy5zdGF0ZUZhY3Rvcnkoc3R5cGUsIHJ1bGVJbmRleCk7XG4gICAgICAgIGlmIChzdHlwZSA9PT0gQVROU3RhdGUuTE9PUF9FTkQpIHtcbiAgICAgICAgICBjb25zdCBsb29wQmFja1N0YXRlTnVtYmVyID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICAgICAgbG9vcEJhY2tTdGF0ZU51bWJlcnMucHVzaChbcywgbG9vcEJhY2tTdGF0ZU51bWJlcl0pO1xuICAgICAgICB9IGVsc2UgaWYgKHMgaW5zdGFuY2VvZiBCbG9ja1N0YXJ0U3RhdGUpIHtcbiAgICAgICAgICBjb25zdCBlbmRTdGF0ZU51bWJlciA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICAgIGVuZFN0YXRlTnVtYmVycy5wdXNoKFtzLCBlbmRTdGF0ZU51bWJlcl0pO1xuICAgICAgICB9XG4gICAgICAgIGF0bi5hZGRTdGF0ZShzKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaiA9IDA7IGogPCBsb29wQmFja1N0YXRlTnVtYmVycy5sZW5ndGg7IGorKykge1xuICAgICAgICBwYWlyID0gbG9vcEJhY2tTdGF0ZU51bWJlcnNbal07XG4gICAgICAgIHBhaXJbMF0ubG9vcEJhY2tTdGF0ZSA9IGF0bi5zdGF0ZXNbcGFpclsxXV07XG4gICAgICB9XG4gICAgICBmb3IgKGogPSAwOyBqIDwgZW5kU3RhdGVOdW1iZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhaXIgPSBlbmRTdGF0ZU51bWJlcnNbal07XG4gICAgICAgIHBhaXJbMF0uZW5kU3RhdGUgPSBhdG4uc3RhdGVzW3BhaXJbMV1dO1xuICAgICAgfVxuICAgICAgbGV0IG51bU5vbkdyZWVkeVN0YXRlcyA9IHRoaXMucmVhZEludCgpO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG51bU5vbkdyZWVkeVN0YXRlczsgaisrKSB7XG4gICAgICAgIHN0YXRlTnVtYmVyID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICAgIGF0bi5zdGF0ZXNbc3RhdGVOdW1iZXJdLm5vbkdyZWVkeSA9IHRydWU7XG4gICAgICB9XG4gICAgICBsZXQgbnVtUHJlY2VkZW5jZVN0YXRlcyA9IHRoaXMucmVhZEludCgpO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG51bVByZWNlZGVuY2VTdGF0ZXM7IGorKykge1xuICAgICAgICBzdGF0ZU51bWJlciA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICBhdG4uc3RhdGVzW3N0YXRlTnVtYmVyXS5pc1ByZWNlZGVuY2VSdWxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVhZFJ1bGVzKGF0bikge1xuICAgICAgbGV0IGk7XG4gICAgICBjb25zdCBucnVsZXMgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgIGlmIChhdG4uZ3JhbW1hclR5cGUgPT09IEFUTlR5cGUuTEVYRVIpIHtcbiAgICAgICAgYXRuLnJ1bGVUb1Rva2VuVHlwZSA9IGluaXRBcnJheShucnVsZXMsIDApO1xuICAgICAgfVxuICAgICAgYXRuLnJ1bGVUb1N0YXJ0U3RhdGUgPSBpbml0QXJyYXkobnJ1bGVzLCAwKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBucnVsZXM7IGkrKykge1xuICAgICAgICBjb25zdCBzID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICAgIGF0bi5ydWxlVG9TdGFydFN0YXRlW2ldID0gYXRuLnN0YXRlc1tzXTtcbiAgICAgICAgaWYgKGF0bi5ncmFtbWFyVHlwZSA9PT0gQVROVHlwZS5MRVhFUikge1xuICAgICAgICAgIGxldCB0b2tlblR5cGUgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgICBpZiAodG9rZW5UeXBlID09PSA2NTUzNSkge1xuICAgICAgICAgICAgdG9rZW5UeXBlID0gVG9rZW4yLkVPRjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXRuLnJ1bGVUb1Rva2VuVHlwZVtpXSA9IHRva2VuVHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXRuLnJ1bGVUb1N0b3BTdGF0ZSA9IGluaXRBcnJheShucnVsZXMsIDApO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGF0bi5zdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBhdG4uc3RhdGVzW2ldO1xuICAgICAgICBpZiAoIShzdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYXRuLnJ1bGVUb1N0b3BTdGF0ZVtzdGF0ZS5ydWxlSW5kZXhdID0gc3RhdGU7XG4gICAgICAgIGF0bi5ydWxlVG9TdGFydFN0YXRlW3N0YXRlLnJ1bGVJbmRleF0uc3RvcFN0YXRlID0gc3RhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJlYWRNb2RlcyhhdG4pIHtcbiAgICAgIGNvbnN0IG5tb2RlcyA9IHRoaXMucmVhZEludCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBubW9kZXM7IGkrKykge1xuICAgICAgICBsZXQgcyA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICBhdG4ubW9kZVRvU3RhcnRTdGF0ZS5wdXNoKGF0bi5zdGF0ZXNbc10pO1xuICAgICAgfVxuICAgIH1cbiAgICByZWFkU2V0cyhhdG4sIHNldHMsIHJlYWRVbmljb2RlKSB7XG4gICAgICBjb25zdCBtID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICBjb25zdCBpc2V0ID0gbmV3IEludGVydmFsU2V0KCk7XG4gICAgICAgIHNldHMucHVzaChpc2V0KTtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICBjb25zdCBjb250YWluc0VvZiA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICBpZiAoY29udGFpbnNFb2YgIT09IDApIHtcbiAgICAgICAgICBpc2V0LmFkZE9uZSgtMSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBpMSA9IHJlYWRVbmljb2RlKCk7XG4gICAgICAgICAgY29uc3QgaTIgPSByZWFkVW5pY29kZSgpO1xuICAgICAgICAgIGlzZXQuYWRkUmFuZ2UoaTEsIGkyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZWFkRWRnZXMoYXRuLCBzZXRzKSB7XG4gICAgICBsZXQgaSwgaiwgc3RhdGUsIHRyYW5zLCB0YXJnZXQ7XG4gICAgICBjb25zdCBuZWRnZXMgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuZWRnZXM7IGkrKykge1xuICAgICAgICBjb25zdCBzcmMgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgY29uc3QgdHJnID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICAgIGNvbnN0IHR0eXBlID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICAgIGNvbnN0IGFyZzEgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgY29uc3QgYXJnMiA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICBjb25zdCBhcmczID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICAgIHRyYW5zID0gdGhpcy5lZGdlRmFjdG9yeShhdG4sIHR0eXBlLCBzcmMsIHRyZywgYXJnMSwgYXJnMiwgYXJnMywgc2V0cyk7XG4gICAgICAgIGNvbnN0IHNyY1N0YXRlID0gYXRuLnN0YXRlc1tzcmNdO1xuICAgICAgICBzcmNTdGF0ZS5hZGRUcmFuc2l0aW9uKHRyYW5zKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhdG4uc3RhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0YXRlID0gYXRuLnN0YXRlc1tpXTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHN0YXRlLnRyYW5zaXRpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgdCA9IHN0YXRlLnRyYW5zaXRpb25zW2pdO1xuICAgICAgICAgIGlmICghKHQgaW5zdGFuY2VvZiBSdWxlVHJhbnNpdGlvbikpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgb3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybiA9IC0xO1xuICAgICAgICAgIGlmIChhdG4ucnVsZVRvU3RhcnRTdGF0ZVt0LnRhcmdldC5ydWxlSW5kZXhdLmlzUHJlY2VkZW5jZVJ1bGUpIHtcbiAgICAgICAgICAgIGlmICh0LnByZWNlZGVuY2UgPT09IDApIHtcbiAgICAgICAgICAgICAgb3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybiA9IHQudGFyZ2V0LnJ1bGVJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhbnMgPSBuZXcgRXBzaWxvblRyYW5zaXRpb24odC5mb2xsb3dTdGF0ZSwgb3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybik7XG4gICAgICAgICAgYXRuLnJ1bGVUb1N0b3BTdGF0ZVt0LnRhcmdldC5ydWxlSW5kZXhdLmFkZFRyYW5zaXRpb24odHJhbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXRuLnN0YXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdGF0ZSA9IGF0bi5zdGF0ZXNbaV07XG4gICAgICAgIGlmIChzdGF0ZSBpbnN0YW5jZW9mIEJsb2NrU3RhcnRTdGF0ZSkge1xuICAgICAgICAgIGlmIChzdGF0ZS5lbmRTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgXCJJbGxlZ2FsU3RhdGVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmVuZFN0YXRlLnN0YXJ0U3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IFwiSWxsZWdhbFN0YXRlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlLmVuZFN0YXRlLnN0YXJ0U3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUgaW5zdGFuY2VvZiBQbHVzTG9vcGJhY2tTdGF0ZSkge1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBzdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdGFyZ2V0ID0gc3RhdGUudHJhbnNpdGlvbnNbal0udGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFBsdXNCbG9ja1N0YXJ0U3RhdGUpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0Lmxvb3BCYWNrU3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgaW5zdGFuY2VvZiBTdGFyTG9vcGJhY2tTdGF0ZSkge1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBzdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdGFyZ2V0ID0gc3RhdGUudHJhbnNpdGlvbnNbal0udGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFN0YXJMb29wRW50cnlTdGF0ZSkge1xuICAgICAgICAgICAgICB0YXJnZXQubG9vcEJhY2tTdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZWFkRGVjaXNpb25zKGF0bikge1xuICAgICAgY29uc3QgbmRlY2lzaW9ucyA9IHRoaXMucmVhZEludCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZGVjaXNpb25zOyBpKyspIHtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICBjb25zdCBkZWNTdGF0ZSA9IGF0bi5zdGF0ZXNbc107XG4gICAgICAgIGF0bi5kZWNpc2lvblRvU3RhdGUucHVzaChkZWNTdGF0ZSk7XG4gICAgICAgIGRlY1N0YXRlLmRlY2lzaW9uID0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVhZExleGVyQWN0aW9ucyhhdG4pIHtcbiAgICAgIGlmIChhdG4uZ3JhbW1hclR5cGUgPT09IEFUTlR5cGUuTEVYRVIpIHtcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgYXRuLmxleGVyQWN0aW9ucyA9IGluaXRBcnJheShjb3VudCwgbnVsbCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGFjdGlvblR5cGUgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgICBsZXQgZGF0YTEgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgICBpZiAoZGF0YTEgPT09IDY1NTM1KSB7XG4gICAgICAgICAgICBkYXRhMSA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgZGF0YTIgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgICBpZiAoZGF0YTIgPT09IDY1NTM1KSB7XG4gICAgICAgICAgICBkYXRhMiA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdG4ubGV4ZXJBY3Rpb25zW2ldID0gdGhpcy5sZXhlckFjdGlvbkZhY3RvcnkoYWN0aW9uVHlwZSwgZGF0YTEsIGRhdGEyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBnZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9ucyhhdG4pIHtcbiAgICAgIGxldCBpO1xuICAgICAgY29uc3QgY291bnQgPSBhdG4ucnVsZVRvU3RhcnRTdGF0ZS5sZW5ndGg7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBhdG4ucnVsZVRvVG9rZW5UeXBlW2ldID0gYXRuLm1heFRva2VuVHlwZSArIGkgKyAxO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9uKGF0biwgaSk7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbmVyYXRlUnVsZUJ5cGFzc1RyYW5zaXRpb24oYXRuLCBpZHgpIHtcbiAgICAgIGxldCBpLCBzdGF0ZTtcbiAgICAgIGNvbnN0IGJ5cGFzc1N0YXJ0ID0gbmV3IEJhc2ljQmxvY2tTdGFydFN0YXRlKCk7XG4gICAgICBieXBhc3NTdGFydC5ydWxlSW5kZXggPSBpZHg7XG4gICAgICBhdG4uYWRkU3RhdGUoYnlwYXNzU3RhcnQpO1xuICAgICAgY29uc3QgYnlwYXNzU3RvcCA9IG5ldyBCbG9ja0VuZFN0YXRlKCk7XG4gICAgICBieXBhc3NTdG9wLnJ1bGVJbmRleCA9IGlkeDtcbiAgICAgIGF0bi5hZGRTdGF0ZShieXBhc3NTdG9wKTtcbiAgICAgIGJ5cGFzc1N0YXJ0LmVuZFN0YXRlID0gYnlwYXNzU3RvcDtcbiAgICAgIGF0bi5kZWZpbmVEZWNpc2lvblN0YXRlKGJ5cGFzc1N0YXJ0KTtcbiAgICAgIGJ5cGFzc1N0b3Auc3RhcnRTdGF0ZSA9IGJ5cGFzc1N0YXJ0O1xuICAgICAgbGV0IGV4Y2x1ZGVUcmFuc2l0aW9uID0gbnVsbDtcbiAgICAgIGxldCBlbmRTdGF0ZSA9IG51bGw7XG4gICAgICBpZiAoYXRuLnJ1bGVUb1N0YXJ0U3RhdGVbaWR4XS5pc1ByZWNlZGVuY2VSdWxlKSB7XG4gICAgICAgIGVuZFN0YXRlID0gbnVsbDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGF0bi5zdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdGF0ZSA9IGF0bi5zdGF0ZXNbaV07XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGVJc0VuZFN0YXRlRm9yKHN0YXRlLCBpZHgpKSB7XG4gICAgICAgICAgICBlbmRTdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgZXhjbHVkZVRyYW5zaXRpb24gPSBzdGF0ZS5sb29wQmFja1N0YXRlLnRyYW5zaXRpb25zWzBdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleGNsdWRlVHJhbnNpdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IFwiQ291bGRuJ3QgaWRlbnRpZnkgZmluYWwgc3RhdGUgb2YgdGhlIHByZWNlZGVuY2UgcnVsZSBwcmVmaXggc2VjdGlvbi5cIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kU3RhdGUgPSBhdG4ucnVsZVRvU3RvcFN0YXRlW2lkeF07XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXRuLnN0YXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdGF0ZSA9IGF0bi5zdGF0ZXNbaV07XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RhdGUudHJhbnNpdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uID0gc3RhdGUudHJhbnNpdGlvbnNbal07XG4gICAgICAgICAgaWYgKHRyYW5zaXRpb24gPT09IGV4Y2x1ZGVUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRyYW5zaXRpb24udGFyZ2V0ID09PSBlbmRTdGF0ZSkge1xuICAgICAgICAgICAgdHJhbnNpdGlvbi50YXJnZXQgPSBieXBhc3NTdG9wO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcnVsZVRvU3RhcnRTdGF0ZSA9IGF0bi5ydWxlVG9TdGFydFN0YXRlW2lkeF07XG4gICAgICBjb25zdCBjb3VudCA9IHJ1bGVUb1N0YXJ0U3RhdGUudHJhbnNpdGlvbnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGNvdW50ID4gMCkge1xuICAgICAgICBieXBhc3NTdGFydC5hZGRUcmFuc2l0aW9uKHJ1bGVUb1N0YXJ0U3RhdGUudHJhbnNpdGlvbnNbY291bnQgLSAxXSk7XG4gICAgICAgIHJ1bGVUb1N0YXJ0U3RhdGUudHJhbnNpdGlvbnMgPSBydWxlVG9TdGFydFN0YXRlLnRyYW5zaXRpb25zLnNsaWNlKC0xKTtcbiAgICAgIH1cbiAgICAgIGF0bi5ydWxlVG9TdGFydFN0YXRlW2lkeF0uYWRkVHJhbnNpdGlvbihuZXcgRXBzaWxvblRyYW5zaXRpb24oYnlwYXNzU3RhcnQpKTtcbiAgICAgIGJ5cGFzc1N0b3AuYWRkVHJhbnNpdGlvbihuZXcgRXBzaWxvblRyYW5zaXRpb24oZW5kU3RhdGUpKTtcbiAgICAgIGNvbnN0IG1hdGNoU3RhdGUgPSBuZXcgQmFzaWNTdGF0ZSgpO1xuICAgICAgYXRuLmFkZFN0YXRlKG1hdGNoU3RhdGUpO1xuICAgICAgbWF0Y2hTdGF0ZS5hZGRUcmFuc2l0aW9uKG5ldyBBdG9tVHJhbnNpdGlvbjIoYnlwYXNzU3RvcCwgYXRuLnJ1bGVUb1Rva2VuVHlwZVtpZHhdKSk7XG4gICAgICBieXBhc3NTdGFydC5hZGRUcmFuc2l0aW9uKG5ldyBFcHNpbG9uVHJhbnNpdGlvbihtYXRjaFN0YXRlKSk7XG4gICAgfVxuICAgIHN0YXRlSXNFbmRTdGF0ZUZvcihzdGF0ZSwgaWR4KSB7XG4gICAgICBpZiAoc3RhdGUucnVsZUluZGV4ICE9PSBpZHgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIShzdGF0ZSBpbnN0YW5jZW9mIFN0YXJMb29wRW50cnlTdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBtYXliZUxvb3BFbmRTdGF0ZSA9IHN0YXRlLnRyYW5zaXRpb25zW3N0YXRlLnRyYW5zaXRpb25zLmxlbmd0aCAtIDFdLnRhcmdldDtcbiAgICAgIGlmICghKG1heWJlTG9vcEVuZFN0YXRlIGluc3RhbmNlb2YgTG9vcEVuZFN0YXRlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChtYXliZUxvb3BFbmRTdGF0ZS5lcHNpbG9uT25seVRyYW5zaXRpb25zICYmIG1heWJlTG9vcEVuZFN0YXRlLnRyYW5zaXRpb25zWzBdLnRhcmdldCBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIG1hcmtQcmVjZWRlbmNlRGVjaXNpb25zKGF0bikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdG4uc3RhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gYXRuLnN0YXRlc1tpXTtcbiAgICAgICAgaWYgKCEoc3RhdGUgaW5zdGFuY2VvZiBTdGFyTG9vcEVudHJ5U3RhdGUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0bi5ydWxlVG9TdGFydFN0YXRlW3N0YXRlLnJ1bGVJbmRleF0uaXNQcmVjZWRlbmNlUnVsZSkge1xuICAgICAgICAgIGNvbnN0IG1heWJlTG9vcEVuZFN0YXRlID0gc3RhdGUudHJhbnNpdGlvbnNbc3RhdGUudHJhbnNpdGlvbnMubGVuZ3RoIC0gMV0udGFyZ2V0O1xuICAgICAgICAgIGlmIChtYXliZUxvb3BFbmRTdGF0ZSBpbnN0YW5jZW9mIExvb3BFbmRTdGF0ZSkge1xuICAgICAgICAgICAgaWYgKG1heWJlTG9vcEVuZFN0YXRlLmVwc2lsb25Pbmx5VHJhbnNpdGlvbnMgJiYgbWF5YmVMb29wRW5kU3RhdGUudHJhbnNpdGlvbnNbMF0udGFyZ2V0IGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkge1xuICAgICAgICAgICAgICBzdGF0ZS5pc1ByZWNlZGVuY2VEZWNpc2lvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZlcmlmeUFUTihhdG4pIHtcbiAgICAgIGlmICghdGhpcy5kZXNlcmlhbGl6YXRpb25PcHRpb25zLnZlcmlmeUFUTikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0bi5zdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBhdG4uc3RhdGVzW2ldO1xuICAgICAgICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXRlLmVwc2lsb25Pbmx5VHJhbnNpdGlvbnMgfHwgc3RhdGUudHJhbnNpdGlvbnMubGVuZ3RoIDw9IDEpO1xuICAgICAgICBpZiAoc3RhdGUgaW5zdGFuY2VvZiBQbHVzQmxvY2tTdGFydFN0YXRlKSB7XG4gICAgICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS5sb29wQmFja1N0YXRlICE9PSBudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSBpbnN0YW5jZW9mIFN0YXJMb29wRW50cnlTdGF0ZSkge1xuICAgICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUubG9vcEJhY2tTdGF0ZSAhPT0gbnVsbCk7XG4gICAgICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGggPT09IDIpO1xuICAgICAgICAgIGlmIChzdGF0ZS50cmFuc2l0aW9uc1swXS50YXJnZXQgaW5zdGFuY2VvZiBTdGFyQmxvY2tTdGFydFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXRlLnRyYW5zaXRpb25zWzFdLnRhcmdldCBpbnN0YW5jZW9mIExvb3BFbmRTdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ29uZGl0aW9uKCFzdGF0ZS5ub25HcmVlZHkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUudHJhbnNpdGlvbnNbMF0udGFyZ2V0IGluc3RhbmNlb2YgTG9vcEVuZFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXRlLnRyYW5zaXRpb25zWzFdLnRhcmdldCBpbnN0YW5jZW9mIFN0YXJCbG9ja1N0YXJ0U3RhdGUpO1xuICAgICAgICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS5ub25HcmVlZHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBcIklsbGVnYWxTdGF0ZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSBpbnN0YW5jZW9mIFN0YXJMb29wYmFja1N0YXRlKSB7XG4gICAgICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGggPT09IDEpO1xuICAgICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUudHJhbnNpdGlvbnNbMF0udGFyZ2V0IGluc3RhbmNlb2YgU3Rhckxvb3BFbnRyeVN0YXRlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSBpbnN0YW5jZW9mIExvb3BFbmRTdGF0ZSkge1xuICAgICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUubG9vcEJhY2tTdGF0ZSAhPT0gbnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RhcnRTdGF0ZSkge1xuICAgICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUuc3RvcFN0YXRlICE9PSBudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSBpbnN0YW5jZW9mIEJsb2NrU3RhcnRTdGF0ZSkge1xuICAgICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUuZW5kU3RhdGUgIT09IG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlIGluc3RhbmNlb2YgQmxvY2tFbmRTdGF0ZSkge1xuICAgICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUuc3RhcnRTdGF0ZSAhPT0gbnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgaW5zdGFuY2VvZiBEZWNpc2lvblN0YXRlKSB7XG4gICAgICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGggPD0gMSB8fCBzdGF0ZS5kZWNpc2lvbiA+PSAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXRlLnRyYW5zaXRpb25zLmxlbmd0aCA8PSAxIHx8IHN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tDb25kaXRpb24oY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gdm9pZCAwIHx8IG1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICBtZXNzYWdlID0gXCJJbGxlZ2FsU3RhdGVcIjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBtZXNzYWdlO1xuICAgICAgfVxuICAgIH1cbiAgICByZWFkSW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLnBvcysrXTtcbiAgICB9XG4gICAgcmVhZEludDMyKCkge1xuICAgICAgY29uc3QgbG93ID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICBjb25zdCBoaWdoID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICByZXR1cm4gbG93IHwgaGlnaCA8PCAxNjtcbiAgICB9XG4gICAgcmVhZExvbmcoKSB7XG4gICAgICBjb25zdCBsb3cgPSB0aGlzLnJlYWRJbnQzMigpO1xuICAgICAgY29uc3QgaGlnaCA9IHRoaXMucmVhZEludDMyKCk7XG4gICAgICByZXR1cm4gbG93ICYgNDI5NDk2NzI5NSB8IGhpZ2ggPDwgMzI7XG4gICAgfVxuICAgIHJlYWRVVUlEKCkge1xuICAgICAgY29uc3QgYmIgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSA3OyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBpbnQgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgYmJbMiAqIGkgKyAxXSA9IGludCAmIDI1NTtcbiAgICAgICAgYmJbMiAqIGldID0gaW50ID4+IDggJiAyNTU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnl0ZVRvSGV4W2JiWzBdXSArIGJ5dGVUb0hleFtiYlsxXV0gKyBieXRlVG9IZXhbYmJbMl1dICsgYnl0ZVRvSGV4W2JiWzNdXSArIFwiLVwiICsgYnl0ZVRvSGV4W2JiWzRdXSArIGJ5dGVUb0hleFtiYls1XV0gKyBcIi1cIiArIGJ5dGVUb0hleFtiYls2XV0gKyBieXRlVG9IZXhbYmJbN11dICsgXCItXCIgKyBieXRlVG9IZXhbYmJbOF1dICsgYnl0ZVRvSGV4W2JiWzldXSArIFwiLVwiICsgYnl0ZVRvSGV4W2JiWzEwXV0gKyBieXRlVG9IZXhbYmJbMTFdXSArIGJ5dGVUb0hleFtiYlsxMl1dICsgYnl0ZVRvSGV4W2JiWzEzXV0gKyBieXRlVG9IZXhbYmJbMTRdXSArIGJ5dGVUb0hleFtiYlsxNV1dO1xuICAgIH1cbiAgICBlZGdlRmFjdG9yeShhdG4sIHR5cGUsIHNyYywgdHJnLCBhcmcxLCBhcmcyLCBhcmczLCBzZXRzKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBhdG4uc3RhdGVzW3RyZ107XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBUcmFuc2l0aW9uLkVQU0lMT046XG4gICAgICAgICAgcmV0dXJuIG5ldyBFcHNpbG9uVHJhbnNpdGlvbih0YXJnZXQpO1xuICAgICAgICBjYXNlIFRyYW5zaXRpb24uUkFOR0U6XG4gICAgICAgICAgcmV0dXJuIGFyZzMgIT09IDAgPyBuZXcgUmFuZ2VUcmFuc2l0aW9uKHRhcmdldCwgVG9rZW4yLkVPRiwgYXJnMikgOiBuZXcgUmFuZ2VUcmFuc2l0aW9uKHRhcmdldCwgYXJnMSwgYXJnMik7XG4gICAgICAgIGNhc2UgVHJhbnNpdGlvbi5SVUxFOlxuICAgICAgICAgIHJldHVybiBuZXcgUnVsZVRyYW5zaXRpb24oYXRuLnN0YXRlc1thcmcxXSwgYXJnMiwgYXJnMywgdGFyZ2V0KTtcbiAgICAgICAgY2FzZSBUcmFuc2l0aW9uLlBSRURJQ0FURTpcbiAgICAgICAgICByZXR1cm4gbmV3IFByZWRpY2F0ZVRyYW5zaXRpb24odGFyZ2V0LCBhcmcxLCBhcmcyLCBhcmczICE9PSAwKTtcbiAgICAgICAgY2FzZSBUcmFuc2l0aW9uLlBSRUNFREVOQ0U6XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbih0YXJnZXQsIGFyZzEpO1xuICAgICAgICBjYXNlIFRyYW5zaXRpb24uQVRPTTpcbiAgICAgICAgICByZXR1cm4gYXJnMyAhPT0gMCA/IG5ldyBBdG9tVHJhbnNpdGlvbjIodGFyZ2V0LCBUb2tlbjIuRU9GKSA6IG5ldyBBdG9tVHJhbnNpdGlvbjIodGFyZ2V0LCBhcmcxKTtcbiAgICAgICAgY2FzZSBUcmFuc2l0aW9uLkFDVElPTjpcbiAgICAgICAgICByZXR1cm4gbmV3IEFjdGlvblRyYW5zaXRpb24odGFyZ2V0LCBhcmcxLCBhcmcyLCBhcmczICE9PSAwKTtcbiAgICAgICAgY2FzZSBUcmFuc2l0aW9uLlNFVDpcbiAgICAgICAgICByZXR1cm4gbmV3IFNldFRyYW5zaXRpb24odGFyZ2V0LCBzZXRzW2FyZzFdKTtcbiAgICAgICAgY2FzZSBUcmFuc2l0aW9uLk5PVF9TRVQ6XG4gICAgICAgICAgcmV0dXJuIG5ldyBOb3RTZXRUcmFuc2l0aW9uKHRhcmdldCwgc2V0c1thcmcxXSk7XG4gICAgICAgIGNhc2UgVHJhbnNpdGlvbi5XSUxEQ0FSRDpcbiAgICAgICAgICByZXR1cm4gbmV3IFdpbGRjYXJkVHJhbnNpdGlvbih0YXJnZXQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IFwiVGhlIHNwZWNpZmllZCB0cmFuc2l0aW9uIHR5cGU6IFwiICsgdHlwZSArIFwiIGlzIG5vdCB2YWxpZC5cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGVGYWN0b3J5KHR5cGUsIHJ1bGVJbmRleCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGVGYWN0b3JpZXMgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc2YgPSBbXTtcbiAgICAgICAgc2ZbQVROU3RhdGUuSU5WQUxJRF9UWVBFXSA9IG51bGw7XG4gICAgICAgIHNmW0FUTlN0YXRlLkJBU0lDXSA9ICgpID0+IG5ldyBCYXNpY1N0YXRlKCk7XG4gICAgICAgIHNmW0FUTlN0YXRlLlJVTEVfU1RBUlRdID0gKCkgPT4gbmV3IFJ1bGVTdGFydFN0YXRlKCk7XG4gICAgICAgIHNmW0FUTlN0YXRlLkJMT0NLX1NUQVJUXSA9ICgpID0+IG5ldyBCYXNpY0Jsb2NrU3RhcnRTdGF0ZSgpO1xuICAgICAgICBzZltBVE5TdGF0ZS5QTFVTX0JMT0NLX1NUQVJUXSA9ICgpID0+IG5ldyBQbHVzQmxvY2tTdGFydFN0YXRlKCk7XG4gICAgICAgIHNmW0FUTlN0YXRlLlNUQVJfQkxPQ0tfU1RBUlRdID0gKCkgPT4gbmV3IFN0YXJCbG9ja1N0YXJ0U3RhdGUoKTtcbiAgICAgICAgc2ZbQVROU3RhdGUuVE9LRU5fU1RBUlRdID0gKCkgPT4gbmV3IFRva2Vuc1N0YXJ0U3RhdGUoKTtcbiAgICAgICAgc2ZbQVROU3RhdGUuUlVMRV9TVE9QXSA9ICgpID0+IG5ldyBSdWxlU3RvcFN0YXRlKCk7XG4gICAgICAgIHNmW0FUTlN0YXRlLkJMT0NLX0VORF0gPSAoKSA9PiBuZXcgQmxvY2tFbmRTdGF0ZSgpO1xuICAgICAgICBzZltBVE5TdGF0ZS5TVEFSX0xPT1BfQkFDS10gPSAoKSA9PiBuZXcgU3Rhckxvb3BiYWNrU3RhdGUoKTtcbiAgICAgICAgc2ZbQVROU3RhdGUuU1RBUl9MT09QX0VOVFJZXSA9ICgpID0+IG5ldyBTdGFyTG9vcEVudHJ5U3RhdGUoKTtcbiAgICAgICAgc2ZbQVROU3RhdGUuUExVU19MT09QX0JBQ0tdID0gKCkgPT4gbmV3IFBsdXNMb29wYmFja1N0YXRlKCk7XG4gICAgICAgIHNmW0FUTlN0YXRlLkxPT1BfRU5EXSA9ICgpID0+IG5ldyBMb29wRW5kU3RhdGUoKTtcbiAgICAgICAgdGhpcy5zdGF0ZUZhY3RvcmllcyA9IHNmO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPiB0aGlzLnN0YXRlRmFjdG9yaWVzLmxlbmd0aCB8fCB0aGlzLnN0YXRlRmFjdG9yaWVzW3R5cGVdID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IFwiVGhlIHNwZWNpZmllZCBzdGF0ZSB0eXBlIFwiICsgdHlwZSArIFwiIGlzIG5vdCB2YWxpZC5cIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLnN0YXRlRmFjdG9yaWVzW3R5cGVdKCk7XG4gICAgICAgIGlmIChzICE9PSBudWxsKSB7XG4gICAgICAgICAgcy5ydWxlSW5kZXggPSBydWxlSW5kZXg7XG4gICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV4ZXJBY3Rpb25GYWN0b3J5KHR5cGUsIGRhdGExLCBkYXRhMikge1xuICAgICAgaWYgKHRoaXMuYWN0aW9uRmFjdG9yaWVzID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGFmID0gW107XG4gICAgICAgIGFmW0xleGVyQWN0aW9uVHlwZS5DSEFOTkVMXSA9IChkYXRhMTIsIGRhdGEyMikgPT4gbmV3IExleGVyQ2hhbm5lbEFjdGlvbihkYXRhMTIpO1xuICAgICAgICBhZltMZXhlckFjdGlvblR5cGUuQ1VTVE9NXSA9IChkYXRhMTIsIGRhdGEyMikgPT4gbmV3IExleGVyQ3VzdG9tQWN0aW9uKGRhdGExMiwgZGF0YTIyKTtcbiAgICAgICAgYWZbTGV4ZXJBY3Rpb25UeXBlLk1PREVdID0gKGRhdGExMiwgZGF0YTIyKSA9PiBuZXcgTGV4ZXJNb2RlQWN0aW9uKGRhdGExMik7XG4gICAgICAgIGFmW0xleGVyQWN0aW9uVHlwZS5NT1JFXSA9IChkYXRhMTIsIGRhdGEyMikgPT4gTGV4ZXJNb3JlQWN0aW9uLklOU1RBTkNFO1xuICAgICAgICBhZltMZXhlckFjdGlvblR5cGUuUE9QX01PREVdID0gKGRhdGExMiwgZGF0YTIyKSA9PiBMZXhlclBvcE1vZGVBY3Rpb24uSU5TVEFOQ0U7XG4gICAgICAgIGFmW0xleGVyQWN0aW9uVHlwZS5QVVNIX01PREVdID0gKGRhdGExMiwgZGF0YTIyKSA9PiBuZXcgTGV4ZXJQdXNoTW9kZUFjdGlvbihkYXRhMTIpO1xuICAgICAgICBhZltMZXhlckFjdGlvblR5cGUuU0tJUF0gPSAoZGF0YTEyLCBkYXRhMjIpID0+IExleGVyU2tpcEFjdGlvbi5JTlNUQU5DRTtcbiAgICAgICAgYWZbTGV4ZXJBY3Rpb25UeXBlLlRZUEVdID0gKGRhdGExMiwgZGF0YTIyKSA9PiBuZXcgTGV4ZXJUeXBlQWN0aW9uKGRhdGExMik7XG4gICAgICAgIHRoaXMuYWN0aW9uRmFjdG9yaWVzID0gYWY7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA+IHRoaXMuYWN0aW9uRmFjdG9yaWVzLmxlbmd0aCB8fCB0aGlzLmFjdGlvbkZhY3Rvcmllc1t0eXBlXSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBcIlRoZSBzcGVjaWZpZWQgbGV4ZXIgYWN0aW9uIHR5cGUgXCIgKyB0eXBlICsgXCIgaXMgbm90IHZhbGlkLlwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9uRmFjdG9yaWVzW3R5cGVdKGRhdGExLCBkYXRhMik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBjcmVhdGVCeXRlVG9IZXgoKSB7XG4gICAgY29uc3QgYnRoID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgYnRoW2ldID0gKGkgKyAyNTYpLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ0aDtcbiAgfVxuICB2YXIgYnl0ZVRvSGV4ID0gY3JlYXRlQnl0ZVRvSGV4KCk7XG4gIG1vZHVsZTIuZXhwb3J0cyA9IEFUTkRlc2VyaWFsaXplcjM7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNC9zcmMvYW50bHI0L2Vycm9yL0Vycm9yTGlzdGVuZXIuanNcbnZhciByZXF1aXJlX0Vycm9yTGlzdGVuZXIgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUyKSA9PiB7XG4gIHZhciBFcnJvckxpc3RlbmVyMiA9IGNsYXNzIHtcbiAgICBzeW50YXhFcnJvcihyZWNvZ25pemVyLCBvZmZlbmRpbmdTeW1ib2wsIGxpbmUsIGNvbHVtbiwgbXNnLCBlKSB7XG4gICAgfVxuICAgIHJlcG9ydEFtYmlndWl0eShyZWNvZ25pemVyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgZXhhY3QsIGFtYmlnQWx0cywgY29uZmlncykge1xuICAgIH1cbiAgICByZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHQocmVjb2duaXplciwgZGZhLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIGNvbmZsaWN0aW5nQWx0cywgY29uZmlncykge1xuICAgIH1cbiAgICByZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHkocmVjb2duaXplciwgZGZhLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIHByZWRpY3Rpb24sIGNvbmZpZ3MpIHtcbiAgICB9XG4gIH07XG4gIHZhciBDb25zb2xlRXJyb3JMaXN0ZW5lciA9IGNsYXNzIGV4dGVuZHMgRXJyb3JMaXN0ZW5lcjIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICB9XG4gICAgc3ludGF4RXJyb3IocmVjb2duaXplciwgb2ZmZW5kaW5nU3ltYm9sLCBsaW5lLCBjb2x1bW4sIG1zZywgZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcImxpbmUgXCIgKyBsaW5lICsgXCI6XCIgKyBjb2x1bW4gKyBcIiBcIiArIG1zZyk7XG4gICAgfVxuICB9O1xuICBDb25zb2xlRXJyb3JMaXN0ZW5lci5JTlNUQU5DRSA9IG5ldyBDb25zb2xlRXJyb3JMaXN0ZW5lcigpO1xuICB2YXIgUHJveHlFcnJvckxpc3RlbmVyID0gY2xhc3MgZXh0ZW5kcyBFcnJvckxpc3RlbmVyMiB7XG4gICAgY29uc3RydWN0b3IoZGVsZWdhdGVzKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgaWYgKGRlbGVnYXRlcyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBcImRlbGVnYXRlc1wiO1xuICAgICAgfVxuICAgICAgdGhpcy5kZWxlZ2F0ZXMgPSBkZWxlZ2F0ZXM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3ludGF4RXJyb3IocmVjb2duaXplciwgb2ZmZW5kaW5nU3ltYm9sLCBsaW5lLCBjb2x1bW4sIG1zZywgZSkge1xuICAgICAgdGhpcy5kZWxlZ2F0ZXMubWFwKChkKSA9PiBkLnN5bnRheEVycm9yKHJlY29nbml6ZXIsIG9mZmVuZGluZ1N5bWJvbCwgbGluZSwgY29sdW1uLCBtc2csIGUpKTtcbiAgICB9XG4gICAgcmVwb3J0QW1iaWd1aXR5KHJlY29nbml6ZXIsIGRmYSwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBleGFjdCwgYW1iaWdBbHRzLCBjb25maWdzKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlcy5tYXAoKGQpID0+IGQucmVwb3J0QW1iaWd1aXR5KHJlY29nbml6ZXIsIGRmYSwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBleGFjdCwgYW1iaWdBbHRzLCBjb25maWdzKSk7XG4gICAgfVxuICAgIHJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dChyZWNvZ25pemVyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgY29uZmxpY3RpbmdBbHRzLCBjb25maWdzKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlcy5tYXAoKGQpID0+IGQucmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0KHJlY29nbml6ZXIsIGRmYSwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBjb25mbGljdGluZ0FsdHMsIGNvbmZpZ3MpKTtcbiAgICB9XG4gICAgcmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5KHJlY29nbml6ZXIsIGRmYSwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBwcmVkaWN0aW9uLCBjb25maWdzKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlcy5tYXAoKGQpID0+IGQucmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5KHJlY29nbml6ZXIsIGRmYSwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBwcmVkaWN0aW9uLCBjb25maWdzKSk7XG4gICAgfVxuICB9O1xuICBtb2R1bGUyLmV4cG9ydHMgPSB7RXJyb3JMaXN0ZW5lcjogRXJyb3JMaXN0ZW5lcjIsIENvbnNvbGVFcnJvckxpc3RlbmVyLCBQcm94eUVycm9yTGlzdGVuZXJ9O1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjQvc3JjL2FudGxyNC9SZWNvZ25pemVyLmpzXG52YXIgcmVxdWlyZV9SZWNvZ25pemVyMiA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZTIpID0+IHtcbiAgdmFyIHtUb2tlbjogVG9rZW4yfSA9IHJlcXVpcmVfVG9rZW4yKCk7XG4gIHZhciB7Q29uc29sZUVycm9yTGlzdGVuZXJ9ID0gcmVxdWlyZV9FcnJvckxpc3RlbmVyKCk7XG4gIHZhciB7UHJveHlFcnJvckxpc3RlbmVyfSA9IHJlcXVpcmVfRXJyb3JMaXN0ZW5lcigpO1xuICB2YXIgUmVjb2duaXplciA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtDb25zb2xlRXJyb3JMaXN0ZW5lci5JTlNUQU5DRV07XG4gICAgICB0aGlzLl9pbnRlcnAgPSBudWxsO1xuICAgICAgdGhpcy5fc3RhdGVOdW1iZXIgPSAtMTtcbiAgICB9XG4gICAgY2hlY2tWZXJzaW9uKHRvb2xWZXJzaW9uKSB7XG4gICAgICBjb25zdCBydW50aW1lVmVyc2lvbiA9IFwiNC45LjJcIjtcbiAgICAgIGlmIChydW50aW1lVmVyc2lvbiAhPT0gdG9vbFZlcnNpb24pIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJBTlRMUiBydW50aW1lIGFuZCBnZW5lcmF0ZWQgY29kZSB2ZXJzaW9ucyBkaXNhZ3JlZTogXCIgKyBydW50aW1lVmVyc2lvbiArIFwiIT1cIiArIHRvb2xWZXJzaW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYWRkRXJyb3JMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgICByZW1vdmVFcnJvckxpc3RlbmVycygpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICAgIH1cbiAgICBnZXRUb2tlblR5cGVNYXAoKSB7XG4gICAgICBjb25zdCB0b2tlbk5hbWVzID0gdGhpcy5nZXRUb2tlbk5hbWVzKCk7XG4gICAgICBpZiAodG9rZW5OYW1lcyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBcIlRoZSBjdXJyZW50IHJlY29nbml6ZXIgZG9lcyBub3QgcHJvdmlkZSBhIGxpc3Qgb2YgdG9rZW4gbmFtZXMuXCI7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdWx0ID0gdGhpcy50b2tlblR5cGVNYXBDYWNoZVt0b2tlbk5hbWVzXTtcbiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICByZXN1bHQgPSB0b2tlbk5hbWVzLnJlZHVjZShmdW5jdGlvbihvLCBrLCBpKSB7XG4gICAgICAgICAgb1trXSA9IGk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQuRU9GID0gVG9rZW4yLkVPRjtcbiAgICAgICAgdGhpcy50b2tlblR5cGVNYXBDYWNoZVt0b2tlbk5hbWVzXSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGdldFJ1bGVJbmRleE1hcCgpIHtcbiAgICAgIGNvbnN0IHJ1bGVOYW1lcyA9IHRoaXMucnVsZU5hbWVzO1xuICAgICAgaWYgKHJ1bGVOYW1lcyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBcIlRoZSBjdXJyZW50IHJlY29nbml6ZXIgZG9lcyBub3QgcHJvdmlkZSBhIGxpc3Qgb2YgcnVsZSBuYW1lcy5cIjtcbiAgICAgIH1cbiAgICAgIGxldCByZXN1bHQgPSB0aGlzLnJ1bGVJbmRleE1hcENhY2hlW3J1bGVOYW1lc107XG4gICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmVzdWx0ID0gcnVsZU5hbWVzLnJlZHVjZShmdW5jdGlvbihvLCBrLCBpKSB7XG4gICAgICAgICAgb1trXSA9IGk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJ1bGVJbmRleE1hcENhY2hlW3J1bGVOYW1lc10gPSByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXRUb2tlblR5cGUodG9rZW5OYW1lKSB7XG4gICAgICBjb25zdCB0dHlwZSA9IHRoaXMuZ2V0VG9rZW5UeXBlTWFwKClbdG9rZW5OYW1lXTtcbiAgICAgIGlmICh0dHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB0dHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBUb2tlbjIuSU5WQUxJRF9UWVBFO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXRFcnJvckhlYWRlcihlKSB7XG4gICAgICBjb25zdCBsaW5lID0gZS5nZXRPZmZlbmRpbmdUb2tlbigpLmxpbmU7XG4gICAgICBjb25zdCBjb2x1bW4gPSBlLmdldE9mZmVuZGluZ1Rva2VuKCkuY29sdW1uO1xuICAgICAgcmV0dXJuIFwibGluZSBcIiArIGxpbmUgKyBcIjpcIiArIGNvbHVtbjtcbiAgICB9XG4gICAgZ2V0VG9rZW5FcnJvckRpc3BsYXkodCkge1xuICAgICAgaWYgKHQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwiPG5vIHRva2VuPlwiO1xuICAgICAgfVxuICAgICAgbGV0IHMgPSB0LnRleHQ7XG4gICAgICBpZiAocyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAodC50eXBlID09PSBUb2tlbjIuRU9GKSB7XG4gICAgICAgICAgcyA9IFwiPEVPRj5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzID0gXCI8XCIgKyB0LnR5cGUgKyBcIj5cIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcyA9IHMucmVwbGFjZShcIlxcblwiLCBcIlxcXFxuXCIpLnJlcGxhY2UoXCJcXHJcIiwgXCJcXFxcclwiKS5yZXBsYWNlKFwiXHRcIiwgXCJcXFxcdFwiKTtcbiAgICAgIHJldHVybiBcIidcIiArIHMgKyBcIidcIjtcbiAgICB9XG4gICAgZ2V0RXJyb3JMaXN0ZW5lckRpc3BhdGNoKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm94eUVycm9yTGlzdGVuZXIodGhpcy5fbGlzdGVuZXJzKTtcbiAgICB9XG4gICAgc2VtcHJlZChsb2NhbGN0eCwgcnVsZUluZGV4LCBhY3Rpb25JbmRleCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHByZWNwcmVkKGxvY2FsY3R4LCBwcmVjZWRlbmNlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlTnVtYmVyO1xuICAgIH1cbiAgICBzZXQgc3RhdGUoc3RhdGUpIHtcbiAgICAgIHRoaXMuX3N0YXRlTnVtYmVyID0gc3RhdGU7XG4gICAgfVxuICB9O1xuICBSZWNvZ25pemVyLnRva2VuVHlwZU1hcENhY2hlID0ge307XG4gIFJlY29nbml6ZXIucnVsZUluZGV4TWFwQ2FjaGUgPSB7fTtcbiAgbW9kdWxlMi5leHBvcnRzID0gUmVjb2duaXplcjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0L3NyYy9hbnRscjQvQ29tbW9uVG9rZW5GYWN0b3J5LmpzXG52YXIgcmVxdWlyZV9Db21tb25Ub2tlbkZhY3RvcnkyID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlMikgPT4ge1xuICB2YXIgQ29tbW9uVG9rZW4gPSByZXF1aXJlX1Rva2VuMigpLkNvbW1vblRva2VuO1xuICB2YXIgVG9rZW5GYWN0b3J5ID0gY2xhc3Mge1xuICB9O1xuICB2YXIgQ29tbW9uVG9rZW5GYWN0b3J5ID0gY2xhc3MgZXh0ZW5kcyBUb2tlbkZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKGNvcHlUZXh0KSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5jb3B5VGV4dCA9IGNvcHlUZXh0ID09PSB2b2lkIDAgPyBmYWxzZSA6IGNvcHlUZXh0O1xuICAgIH1cbiAgICBjcmVhdGUoc291cmNlLCB0eXBlLCB0ZXh0LCBjaGFubmVsLCBzdGFydCwgc3RvcCwgbGluZSwgY29sdW1uKSB7XG4gICAgICBjb25zdCB0ID0gbmV3IENvbW1vblRva2VuKHNvdXJjZSwgdHlwZSwgY2hhbm5lbCwgc3RhcnQsIHN0b3ApO1xuICAgICAgdC5saW5lID0gbGluZTtcbiAgICAgIHQuY29sdW1uID0gY29sdW1uO1xuICAgICAgaWYgKHRleHQgIT09IG51bGwpIHtcbiAgICAgICAgdC50ZXh0ID0gdGV4dDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jb3B5VGV4dCAmJiBzb3VyY2VbMV0gIT09IG51bGwpIHtcbiAgICAgICAgdC50ZXh0ID0gc291cmNlWzFdLmdldFRleHQoc3RhcnQsIHN0b3ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICAgIGNyZWF0ZVRoaW4odHlwZSwgdGV4dCkge1xuICAgICAgY29uc3QgdCA9IG5ldyBDb21tb25Ub2tlbihudWxsLCB0eXBlKTtcbiAgICAgIHQudGV4dCA9IHRleHQ7XG4gICAgICByZXR1cm4gdDtcbiAgICB9XG4gIH07XG4gIENvbW1vblRva2VuRmFjdG9yeS5ERUZBVUxUID0gbmV3IENvbW1vblRva2VuRmFjdG9yeSgpO1xuICBtb2R1bGUyLmV4cG9ydHMgPSBDb21tb25Ub2tlbkZhY3Rvcnk7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNC9zcmMvYW50bHI0L2Vycm9yL0Vycm9ycy5qc1xudmFyIHJlcXVpcmVfRXJyb3JzID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlMikgPT4ge1xuICB2YXIge1ByZWRpY2F0ZVRyYW5zaXRpb259ID0gcmVxdWlyZV9UcmFuc2l0aW9uMigpO1xuICB2YXIge0ludGVydmFsfSA9IHJlcXVpcmVfSW50ZXJ2YWxTZXQyKCkuSW50ZXJ2YWw7XG4gIHZhciBSZWNvZ25pdGlvbkV4Y2VwdGlvbjIgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgIHN1cGVyKHBhcmFtcy5tZXNzYWdlKTtcbiAgICAgIGlmICghIUVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFJlY29nbml0aW9uRXhjZXB0aW9uMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICAgIH1cbiAgICAgIHRoaXMubWVzc2FnZSA9IHBhcmFtcy5tZXNzYWdlO1xuICAgICAgdGhpcy5yZWNvZ25pemVyID0gcGFyYW1zLnJlY29nbml6ZXI7XG4gICAgICB0aGlzLmlucHV0ID0gcGFyYW1zLmlucHV0O1xuICAgICAgdGhpcy5jdHggPSBwYXJhbXMuY3R4O1xuICAgICAgdGhpcy5vZmZlbmRpbmdUb2tlbiA9IG51bGw7XG4gICAgICB0aGlzLm9mZmVuZGluZ1N0YXRlID0gLTE7XG4gICAgICBpZiAodGhpcy5yZWNvZ25pemVyICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMub2ZmZW5kaW5nU3RhdGUgPSB0aGlzLnJlY29nbml6ZXIuc3RhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIGdldEV4cGVjdGVkVG9rZW5zKCkge1xuICAgICAgaWYgKHRoaXMucmVjb2duaXplciAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWNvZ25pemVyLmF0bi5nZXRFeHBlY3RlZFRva2Vucyh0aGlzLm9mZmVuZGluZ1N0YXRlLCB0aGlzLmN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgIH1cbiAgfTtcbiAgdmFyIExleGVyTm9WaWFibGVBbHRFeGNlcHRpb24gPSBjbGFzcyBleHRlbmRzIFJlY29nbml0aW9uRXhjZXB0aW9uMiB7XG4gICAgY29uc3RydWN0b3IobGV4ZXIsIGlucHV0LCBzdGFydEluZGV4LCBkZWFkRW5kQ29uZmlncykge1xuICAgICAgc3VwZXIoe21lc3NhZ2U6IFwiXCIsIHJlY29nbml6ZXI6IGxleGVyLCBpbnB1dCwgY3R4OiBudWxsfSk7XG4gICAgICB0aGlzLnN0YXJ0SW5kZXggPSBzdGFydEluZGV4O1xuICAgICAgdGhpcy5kZWFkRW5kQ29uZmlncyA9IGRlYWRFbmRDb25maWdzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIGxldCBzeW1ib2wgPSBcIlwiO1xuICAgICAgaWYgKHRoaXMuc3RhcnRJbmRleCA+PSAwICYmIHRoaXMuc3RhcnRJbmRleCA8IHRoaXMuaW5wdXQuc2l6ZSkge1xuICAgICAgICBzeW1ib2wgPSB0aGlzLmlucHV0LmdldFRleHQobmV3IEludGVydmFsKHRoaXMuc3RhcnRJbmRleCwgdGhpcy5zdGFydEluZGV4KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uXCIgKyBzeW1ib2w7XG4gICAgfVxuICB9O1xuICB2YXIgTm9WaWFibGVBbHRFeGNlcHRpb24yID0gY2xhc3MgZXh0ZW5kcyBSZWNvZ25pdGlvbkV4Y2VwdGlvbjIge1xuICAgIGNvbnN0cnVjdG9yKHJlY29nbml6ZXIsIGlucHV0LCBzdGFydFRva2VuLCBvZmZlbmRpbmdUb2tlbiwgZGVhZEVuZENvbmZpZ3MsIGN0eCkge1xuICAgICAgY3R4ID0gY3R4IHx8IHJlY29nbml6ZXIuX2N0eDtcbiAgICAgIG9mZmVuZGluZ1Rva2VuID0gb2ZmZW5kaW5nVG9rZW4gfHwgcmVjb2duaXplci5nZXRDdXJyZW50VG9rZW4oKTtcbiAgICAgIHN0YXJ0VG9rZW4gPSBzdGFydFRva2VuIHx8IHJlY29nbml6ZXIuZ2V0Q3VycmVudFRva2VuKCk7XG4gICAgICBpbnB1dCA9IGlucHV0IHx8IHJlY29nbml6ZXIuZ2V0SW5wdXRTdHJlYW0oKTtcbiAgICAgIHN1cGVyKHttZXNzYWdlOiBcIlwiLCByZWNvZ25pemVyLCBpbnB1dCwgY3R4fSk7XG4gICAgICB0aGlzLmRlYWRFbmRDb25maWdzID0gZGVhZEVuZENvbmZpZ3M7XG4gICAgICB0aGlzLnN0YXJ0VG9rZW4gPSBzdGFydFRva2VuO1xuICAgICAgdGhpcy5vZmZlbmRpbmdUb2tlbiA9IG9mZmVuZGluZ1Rva2VuO1xuICAgIH1cbiAgfTtcbiAgdmFyIElucHV0TWlzbWF0Y2hFeGNlcHRpb24gPSBjbGFzcyBleHRlbmRzIFJlY29nbml0aW9uRXhjZXB0aW9uMiB7XG4gICAgY29uc3RydWN0b3IocmVjb2duaXplcikge1xuICAgICAgc3VwZXIoe21lc3NhZ2U6IFwiXCIsIHJlY29nbml6ZXIsIGlucHV0OiByZWNvZ25pemVyLmdldElucHV0U3RyZWFtKCksIGN0eDogcmVjb2duaXplci5fY3R4fSk7XG4gICAgICB0aGlzLm9mZmVuZGluZ1Rva2VuID0gcmVjb2duaXplci5nZXRDdXJyZW50VG9rZW4oKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2UocHJlZGljYXRlLCBtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJmYWlsZWQgcHJlZGljYXRlOiB7XCIgKyBwcmVkaWNhdGUgKyBcIn0/XCI7XG4gICAgfVxuICB9XG4gIHZhciBGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24yID0gY2xhc3MgZXh0ZW5kcyBSZWNvZ25pdGlvbkV4Y2VwdGlvbjIge1xuICAgIGNvbnN0cnVjdG9yKHJlY29nbml6ZXIsIHByZWRpY2F0ZSwgbWVzc2FnZSkge1xuICAgICAgc3VwZXIoe1xuICAgICAgICBtZXNzYWdlOiBmb3JtYXRNZXNzYWdlKHByZWRpY2F0ZSwgbWVzc2FnZSB8fCBudWxsKSxcbiAgICAgICAgcmVjb2duaXplcixcbiAgICAgICAgaW5wdXQ6IHJlY29nbml6ZXIuZ2V0SW5wdXRTdHJlYW0oKSxcbiAgICAgICAgY3R4OiByZWNvZ25pemVyLl9jdHhcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcyA9IHJlY29nbml6ZXIuX2ludGVycC5hdG4uc3RhdGVzW3JlY29nbml6ZXIuc3RhdGVdO1xuICAgICAgY29uc3QgdHJhbnMgPSBzLnRyYW5zaXRpb25zWzBdO1xuICAgICAgaWYgKHRyYW5zIGluc3RhbmNlb2YgUHJlZGljYXRlVHJhbnNpdGlvbikge1xuICAgICAgICB0aGlzLnJ1bGVJbmRleCA9IHRyYW5zLnJ1bGVJbmRleDtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGVJbmRleCA9IHRyYW5zLnByZWRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucnVsZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGVJbmRleCA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgIHRoaXMub2ZmZW5kaW5nVG9rZW4gPSByZWNvZ25pemVyLmdldEN1cnJlbnRUb2tlbigpO1xuICAgIH1cbiAgfTtcbiAgdmFyIFBhcnNlQ2FuY2VsbGF0aW9uRXhjZXB0aW9uID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb24pO1xuICAgIH1cbiAgfTtcbiAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgIFJlY29nbml0aW9uRXhjZXB0aW9uOiBSZWNvZ25pdGlvbkV4Y2VwdGlvbjIsXG4gICAgTm9WaWFibGVBbHRFeGNlcHRpb246IE5vVmlhYmxlQWx0RXhjZXB0aW9uMixcbiAgICBMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uLFxuICAgIElucHV0TWlzbWF0Y2hFeGNlcHRpb24sXG4gICAgRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uOiBGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24yLFxuICAgIFBhcnNlQ2FuY2VsbGF0aW9uRXhjZXB0aW9uXG4gIH07XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNC9zcmMvYW50bHI0L0xleGVyLmpzXG52YXIgcmVxdWlyZV9MZXhlcjIgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUyKSA9PiB7XG4gIHZhciB7VG9rZW46IFRva2VuMn0gPSByZXF1aXJlX1Rva2VuMigpO1xuICB2YXIgUmVjb2duaXplciA9IHJlcXVpcmVfUmVjb2duaXplcjIoKTtcbiAgdmFyIENvbW1vblRva2VuRmFjdG9yeSA9IHJlcXVpcmVfQ29tbW9uVG9rZW5GYWN0b3J5MigpO1xuICB2YXIge1JlY29nbml0aW9uRXhjZXB0aW9uOiBSZWNvZ25pdGlvbkV4Y2VwdGlvbjJ9ID0gcmVxdWlyZV9FcnJvcnMoKTtcbiAgdmFyIHtMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9ufSA9IHJlcXVpcmVfRXJyb3JzKCk7XG4gIHZhciBMZXhlcjIgPSBjbGFzcyBleHRlbmRzIFJlY29nbml6ZXIge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgICAgIHRoaXMuX2ZhY3RvcnkgPSBDb21tb25Ub2tlbkZhY3RvcnkuREVGQVVMVDtcbiAgICAgIHRoaXMuX3Rva2VuRmFjdG9yeVNvdXJjZVBhaXIgPSBbdGhpcywgaW5wdXRdO1xuICAgICAgdGhpcy5faW50ZXJwID0gbnVsbDtcbiAgICAgIHRoaXMuX3Rva2VuID0gbnVsbDtcbiAgICAgIHRoaXMuX3Rva2VuU3RhcnRDaGFySW5kZXggPSAtMTtcbiAgICAgIHRoaXMuX3Rva2VuU3RhcnRMaW5lID0gLTE7XG4gICAgICB0aGlzLl90b2tlblN0YXJ0Q29sdW1uID0gLTE7XG4gICAgICB0aGlzLl9oaXRFT0YgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2NoYW5uZWwgPSBUb2tlbjIuREVGQVVMVF9DSEFOTkVMO1xuICAgICAgdGhpcy5fdHlwZSA9IFRva2VuMi5JTlZBTElEX1RZUEU7XG4gICAgICB0aGlzLl9tb2RlU3RhY2sgPSBbXTtcbiAgICAgIHRoaXMuX21vZGUgPSBMZXhlcjIuREVGQVVMVF9NT0RFO1xuICAgICAgdGhpcy5fdGV4dCA9IG51bGw7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgaWYgKHRoaXMuX2lucHV0ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2lucHV0LnNlZWsoMCk7XG4gICAgICB9XG4gICAgICB0aGlzLl90b2tlbiA9IG51bGw7XG4gICAgICB0aGlzLl90eXBlID0gVG9rZW4yLklOVkFMSURfVFlQRTtcbiAgICAgIHRoaXMuX2NoYW5uZWwgPSBUb2tlbjIuREVGQVVMVF9DSEFOTkVMO1xuICAgICAgdGhpcy5fdG9rZW5TdGFydENoYXJJbmRleCA9IC0xO1xuICAgICAgdGhpcy5fdG9rZW5TdGFydENvbHVtbiA9IC0xO1xuICAgICAgdGhpcy5fdG9rZW5TdGFydExpbmUgPSAtMTtcbiAgICAgIHRoaXMuX3RleHQgPSBudWxsO1xuICAgICAgdGhpcy5faGl0RU9GID0gZmFsc2U7XG4gICAgICB0aGlzLl9tb2RlID0gTGV4ZXIyLkRFRkFVTFRfTU9ERTtcbiAgICAgIHRoaXMuX21vZGVTdGFjayA9IFtdO1xuICAgICAgdGhpcy5faW50ZXJwLnJlc2V0KCk7XG4gICAgfVxuICAgIG5leHRUb2tlbigpIHtcbiAgICAgIGlmICh0aGlzLl9pbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBcIm5leHRUb2tlbiByZXF1aXJlcyBhIG5vbi1udWxsIGlucHV0IHN0cmVhbS5cIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRva2VuU3RhcnRNYXJrZXIgPSB0aGlzLl9pbnB1dC5tYXJrKCk7XG4gICAgICB0cnkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLl9oaXRFT0YpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdEVPRigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl90b2tlbiA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fY2hhbm5lbCA9IFRva2VuMi5ERUZBVUxUX0NIQU5ORUw7XG4gICAgICAgICAgdGhpcy5fdG9rZW5TdGFydENoYXJJbmRleCA9IHRoaXMuX2lucHV0LmluZGV4O1xuICAgICAgICAgIHRoaXMuX3Rva2VuU3RhcnRDb2x1bW4gPSB0aGlzLl9pbnRlcnAuY29sdW1uO1xuICAgICAgICAgIHRoaXMuX3Rva2VuU3RhcnRMaW5lID0gdGhpcy5faW50ZXJwLmxpbmU7XG4gICAgICAgICAgdGhpcy5fdGV4dCA9IG51bGw7XG4gICAgICAgICAgbGV0IGNvbnRpbnVlT3V0ZXIgPSBmYWxzZTtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdHlwZSA9IFRva2VuMi5JTlZBTElEX1RZUEU7XG4gICAgICAgICAgICBsZXQgdHR5cGUgPSBMZXhlcjIuU0tJUDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHR0eXBlID0gdGhpcy5faW50ZXJwLm1hdGNoKHRoaXMuX2lucHV0LCB0aGlzLl9tb2RlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBSZWNvZ25pdGlvbkV4Y2VwdGlvbjIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY292ZXIoZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS5zdGFjayk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2lucHV0LkxBKDEpID09PSBUb2tlbjIuRU9GKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2hpdEVPRiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdHlwZSA9PT0gVG9rZW4yLklOVkFMSURfVFlQRSkge1xuICAgICAgICAgICAgICB0aGlzLl90eXBlID0gdHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdHlwZSA9PT0gTGV4ZXIyLlNLSVApIHtcbiAgICAgICAgICAgICAgY29udGludWVPdXRlciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUgIT09IExleGVyMi5NT1JFKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29udGludWVPdXRlcikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl90b2tlbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl90b2tlbjtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5faW5wdXQucmVsZWFzZSh0b2tlblN0YXJ0TWFya2VyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2tpcCgpIHtcbiAgICAgIHRoaXMuX3R5cGUgPSBMZXhlcjIuU0tJUDtcbiAgICB9XG4gICAgbW9yZSgpIHtcbiAgICAgIHRoaXMuX3R5cGUgPSBMZXhlcjIuTU9SRTtcbiAgICB9XG4gICAgbW9kZShtKSB7XG4gICAgICB0aGlzLl9tb2RlID0gbTtcbiAgICB9XG4gICAgcHVzaE1vZGUobSkge1xuICAgICAgaWYgKHRoaXMuX2ludGVycC5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcInB1c2hNb2RlIFwiICsgbSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tb2RlU3RhY2sucHVzaCh0aGlzLl9tb2RlKTtcbiAgICAgIHRoaXMubW9kZShtKTtcbiAgICB9XG4gICAgcG9wTW9kZSgpIHtcbiAgICAgIGlmICh0aGlzLl9tb2RlU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IFwiRW1wdHkgU3RhY2tcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9pbnRlcnAuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJwb3BNb2RlIGJhY2sgdG8gXCIgKyB0aGlzLl9tb2RlU3RhY2suc2xpY2UoMCwgLTEpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubW9kZSh0aGlzLl9tb2RlU3RhY2sucG9wKCkpO1xuICAgICAgcmV0dXJuIHRoaXMuX21vZGU7XG4gICAgfVxuICAgIGVtaXRUb2tlbih0b2tlbikge1xuICAgICAgdGhpcy5fdG9rZW4gPSB0b2tlbjtcbiAgICB9XG4gICAgZW1pdCgpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLl9mYWN0b3J5LmNyZWF0ZSh0aGlzLl90b2tlbkZhY3RvcnlTb3VyY2VQYWlyLCB0aGlzLl90eXBlLCB0aGlzLl90ZXh0LCB0aGlzLl9jaGFubmVsLCB0aGlzLl90b2tlblN0YXJ0Q2hhckluZGV4LCB0aGlzLmdldENoYXJJbmRleCgpIC0gMSwgdGhpcy5fdG9rZW5TdGFydExpbmUsIHRoaXMuX3Rva2VuU3RhcnRDb2x1bW4pO1xuICAgICAgdGhpcy5lbWl0VG9rZW4odCk7XG4gICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgZW1pdEVPRigpIHtcbiAgICAgIGNvbnN0IGNwb3MgPSB0aGlzLmNvbHVtbjtcbiAgICAgIGNvbnN0IGxwb3MgPSB0aGlzLmxpbmU7XG4gICAgICBjb25zdCBlb2YgPSB0aGlzLl9mYWN0b3J5LmNyZWF0ZSh0aGlzLl90b2tlbkZhY3RvcnlTb3VyY2VQYWlyLCBUb2tlbjIuRU9GLCBudWxsLCBUb2tlbjIuREVGQVVMVF9DSEFOTkVMLCB0aGlzLl9pbnB1dC5pbmRleCwgdGhpcy5faW5wdXQuaW5kZXggLSAxLCBscG9zLCBjcG9zKTtcbiAgICAgIHRoaXMuZW1pdFRva2VuKGVvZik7XG4gICAgICByZXR1cm4gZW9mO1xuICAgIH1cbiAgICBnZXRDaGFySW5kZXgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5wdXQuaW5kZXg7XG4gICAgfVxuICAgIGdldEFsbFRva2VucygpIHtcbiAgICAgIGNvbnN0IHRva2VuczIgPSBbXTtcbiAgICAgIGxldCB0ID0gdGhpcy5uZXh0VG9rZW4oKTtcbiAgICAgIHdoaWxlICh0LnR5cGUgIT09IFRva2VuMi5FT0YpIHtcbiAgICAgICAgdG9rZW5zMi5wdXNoKHQpO1xuICAgICAgICB0ID0gdGhpcy5uZXh0VG9rZW4oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b2tlbnMyO1xuICAgIH1cbiAgICBub3RpZnlMaXN0ZW5lcnMoZSkge1xuICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl90b2tlblN0YXJ0Q2hhckluZGV4O1xuICAgICAgY29uc3Qgc3RvcCA9IHRoaXMuX2lucHV0LmluZGV4O1xuICAgICAgY29uc3QgdGV4dCA9IHRoaXMuX2lucHV0LmdldFRleHQoc3RhcnQsIHN0b3ApO1xuICAgICAgY29uc3QgbXNnID0gXCJ0b2tlbiByZWNvZ25pdGlvbiBlcnJvciBhdDogJ1wiICsgdGhpcy5nZXRFcnJvckRpc3BsYXkodGV4dCkgKyBcIidcIjtcbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gdGhpcy5nZXRFcnJvckxpc3RlbmVyRGlzcGF0Y2goKTtcbiAgICAgIGxpc3RlbmVyLnN5bnRheEVycm9yKHRoaXMsIG51bGwsIHRoaXMuX3Rva2VuU3RhcnRMaW5lLCB0aGlzLl90b2tlblN0YXJ0Q29sdW1uLCBtc2csIGUpO1xuICAgIH1cbiAgICBnZXRFcnJvckRpc3BsYXkocykge1xuICAgICAgY29uc3QgZCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGQucHVzaChzW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIGdldEVycm9yRGlzcGxheUZvckNoYXIoYykge1xuICAgICAgaWYgKGMuY2hhckNvZGVBdCgwKSA9PT0gVG9rZW4yLkVPRikge1xuICAgICAgICByZXR1cm4gXCI8RU9GPlwiO1xuICAgICAgfSBlbHNlIGlmIChjID09PSBcIlxcblwiKSB7XG4gICAgICAgIHJldHVybiBcIlxcXFxuXCI7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09IFwiXHRcIikge1xuICAgICAgICByZXR1cm4gXCJcXFxcdFwiO1xuICAgICAgfSBlbHNlIGlmIChjID09PSBcIlxcclwiKSB7XG4gICAgICAgIHJldHVybiBcIlxcXFxyXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2hhckVycm9yRGlzcGxheShjKSB7XG4gICAgICByZXR1cm4gXCInXCIgKyB0aGlzLmdldEVycm9yRGlzcGxheUZvckNoYXIoYykgKyBcIidcIjtcbiAgICB9XG4gICAgcmVjb3ZlcihyZSkge1xuICAgICAgaWYgKHRoaXMuX2lucHV0LkxBKDEpICE9PSBUb2tlbjIuRU9GKSB7XG4gICAgICAgIGlmIChyZSBpbnN0YW5jZW9mIExleGVyTm9WaWFibGVBbHRFeGNlcHRpb24pIHtcbiAgICAgICAgICB0aGlzLl9pbnRlcnAuY29uc3VtZSh0aGlzLl9pbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5faW5wdXQuY29uc3VtZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGdldCBpbnB1dFN0cmVhbSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbnB1dDtcbiAgICB9XG4gICAgc2V0IGlucHV0U3RyZWFtKGlucHV0KSB7XG4gICAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG4gICAgICB0aGlzLl90b2tlbkZhY3RvcnlTb3VyY2VQYWlyID0gW3RoaXMsIHRoaXMuX2lucHV0XTtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgICB0aGlzLl90b2tlbkZhY3RvcnlTb3VyY2VQYWlyID0gW3RoaXMsIHRoaXMuX2lucHV0XTtcbiAgICB9XG4gICAgZ2V0IHNvdXJjZU5hbWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5wdXQuc291cmNlTmFtZTtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlO1xuICAgIH1cbiAgICBzZXQgdHlwZSh0eXBlKSB7XG4gICAgICB0aGlzLl90eXBlID0gdHlwZTtcbiAgICB9XG4gICAgZ2V0IGxpbmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW50ZXJwLmxpbmU7XG4gICAgfVxuICAgIHNldCBsaW5lKGxpbmUpIHtcbiAgICAgIHRoaXMuX2ludGVycC5saW5lID0gbGluZTtcbiAgICB9XG4gICAgZ2V0IGNvbHVtbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbnRlcnAuY29sdW1uO1xuICAgIH1cbiAgICBzZXQgY29sdW1uKGNvbHVtbikge1xuICAgICAgdGhpcy5faW50ZXJwLmNvbHVtbiA9IGNvbHVtbjtcbiAgICB9XG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICBpZiAodGhpcy5fdGV4dCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcnAuZ2V0VGV4dCh0aGlzLl9pbnB1dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHNldCB0ZXh0KHRleHQpIHtcbiAgICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xuICAgIH1cbiAgfTtcbiAgTGV4ZXIyLkRFRkFVTFRfTU9ERSA9IDA7XG4gIExleGVyMi5NT1JFID0gLTI7XG4gIExleGVyMi5TS0lQID0gLTM7XG4gIExleGVyMi5ERUZBVUxUX1RPS0VOX0NIQU5ORUwgPSBUb2tlbjIuREVGQVVMVF9DSEFOTkVMO1xuICBMZXhlcjIuSElEREVOID0gVG9rZW4yLkhJRERFTl9DSEFOTkVMO1xuICBMZXhlcjIuTUlOX0NIQVJfVkFMVUUgPSAwO1xuICBMZXhlcjIuTUFYX0NIQVJfVkFMVUUgPSAxMTE0MTExO1xuICBtb2R1bGUyLmV4cG9ydHMgPSBMZXhlcjI7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNC9zcmMvYW50bHI0L2F0bi9BVE5Db25maWdTZXQuanNcbnZhciByZXF1aXJlX0FUTkNvbmZpZ1NldDIgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUyKSA9PiB7XG4gIHZhciBBVE4yID0gcmVxdWlyZV9BVE4yKCk7XG4gIHZhciBVdGlsczMgPSByZXF1aXJlX1V0aWxzMigpO1xuICB2YXIge1NlbWFudGljQ29udGV4dH0gPSByZXF1aXJlX1NlbWFudGljQ29udGV4dDIoKTtcbiAgdmFyIHttZXJnZX0gPSByZXF1aXJlX1ByZWRpY3Rpb25Db250ZXh0MigpO1xuICBmdW5jdGlvbiBoYXNoQVROQ29uZmlnKGMpIHtcbiAgICByZXR1cm4gYy5oYXNoQ29kZUZvckNvbmZpZ1NldCgpO1xuICB9XG4gIGZ1bmN0aW9uIGVxdWFsQVROQ29uZmlncyhhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoYSA9PT0gbnVsbCB8fCBiID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gYS5lcXVhbHNGb3JDb25maWdTZXQoYik7XG4gIH1cbiAgdmFyIEFUTkNvbmZpZ1NldCA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihmdWxsQ3R4KSB7XG4gICAgICB0aGlzLmNvbmZpZ0xvb2t1cCA9IG5ldyBVdGlsczMuU2V0KGhhc2hBVE5Db25maWcsIGVxdWFsQVROQ29uZmlncyk7XG4gICAgICB0aGlzLmZ1bGxDdHggPSBmdWxsQ3R4ID09PSB2b2lkIDAgPyB0cnVlIDogZnVsbEN0eDtcbiAgICAgIHRoaXMucmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuY29uZmlncyA9IFtdO1xuICAgICAgdGhpcy51bmlxdWVBbHQgPSAwO1xuICAgICAgdGhpcy5jb25mbGljdGluZ0FsdHMgPSBudWxsO1xuICAgICAgdGhpcy5oYXNTZW1hbnRpY0NvbnRleHQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGlwc0ludG9PdXRlckNvbnRleHQgPSBmYWxzZTtcbiAgICAgIHRoaXMuY2FjaGVkSGFzaENvZGUgPSAtMTtcbiAgICB9XG4gICAgYWRkKGNvbmZpZywgbWVyZ2VDYWNoZSkge1xuICAgICAgaWYgKG1lcmdlQ2FjaGUgPT09IHZvaWQgMCkge1xuICAgICAgICBtZXJnZUNhY2hlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJlYWRPbmx5KSB7XG4gICAgICAgIHRocm93IFwiVGhpcyBzZXQgaXMgcmVhZG9ubHlcIjtcbiAgICAgIH1cbiAgICAgIGlmIChjb25maWcuc2VtYW50aWNDb250ZXh0ICE9PSBTZW1hbnRpY0NvbnRleHQuTk9ORSkge1xuICAgICAgICB0aGlzLmhhc1NlbWFudGljQ29udGV4dCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoY29uZmlnLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0ID4gMCkge1xuICAgICAgICB0aGlzLmRpcHNJbnRvT3V0ZXJDb250ZXh0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5jb25maWdMb29rdXAuYWRkKGNvbmZpZyk7XG4gICAgICBpZiAoZXhpc3RpbmcgPT09IGNvbmZpZykge1xuICAgICAgICB0aGlzLmNhY2hlZEhhc2hDb2RlID0gLTE7XG4gICAgICAgIHRoaXMuY29uZmlncy5wdXNoKGNvbmZpZyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgcm9vdElzV2lsZGNhcmQgPSAhdGhpcy5mdWxsQ3R4O1xuICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2UoZXhpc3RpbmcuY29udGV4dCwgY29uZmlnLmNvbnRleHQsIHJvb3RJc1dpbGRjYXJkLCBtZXJnZUNhY2hlKTtcbiAgICAgIGV4aXN0aW5nLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0ID0gTWF0aC5tYXgoZXhpc3RpbmcucmVhY2hlc0ludG9PdXRlckNvbnRleHQsIGNvbmZpZy5yZWFjaGVzSW50b091dGVyQ29udGV4dCk7XG4gICAgICBpZiAoY29uZmlnLnByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkKSB7XG4gICAgICAgIGV4aXN0aW5nLnByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGV4aXN0aW5nLmNvbnRleHQgPSBtZXJnZWQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0U3RhdGVzKCkge1xuICAgICAgY29uc3Qgc3RhdGVzID0gbmV3IFV0aWxzMy5TZXQoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0YXRlcy5hZGQodGhpcy5jb25maWdzW2ldLnN0YXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGF0ZXM7XG4gICAgfVxuICAgIGdldFByZWRpY2F0ZXMoKSB7XG4gICAgICBjb25zdCBwcmVkcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHRoaXMuY29uZmlnc1tpXS5zZW1hbnRpY0NvbnRleHQ7XG4gICAgICAgIGlmIChjICE9PSBTZW1hbnRpY0NvbnRleHQuTk9ORSkge1xuICAgICAgICAgIHByZWRzLnB1c2goYy5zZW1hbnRpY0NvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJlZHM7XG4gICAgfVxuICAgIG9wdGltaXplQ29uZmlncyhpbnRlcnByZXRlcikge1xuICAgICAgaWYgKHRoaXMucmVhZE9ubHkpIHtcbiAgICAgICAgdGhyb3cgXCJUaGlzIHNldCBpcyByZWFkb25seVwiO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29uZmlnTG9va3VwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29uZmlncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZ3NbaV07XG4gICAgICAgIGNvbmZpZy5jb250ZXh0ID0gaW50ZXJwcmV0ZXIuZ2V0Q2FjaGVkQ29udGV4dChjb25maWcuY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIGFkZEFsbChjb2xsKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGQoY29sbFtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMgPT09IG90aGVyIHx8IG90aGVyIGluc3RhbmNlb2YgQVROQ29uZmlnU2V0ICYmIFV0aWxzMy5lcXVhbEFycmF5cyh0aGlzLmNvbmZpZ3MsIG90aGVyLmNvbmZpZ3MpICYmIHRoaXMuZnVsbEN0eCA9PT0gb3RoZXIuZnVsbEN0eCAmJiB0aGlzLnVuaXF1ZUFsdCA9PT0gb3RoZXIudW5pcXVlQWx0ICYmIHRoaXMuY29uZmxpY3RpbmdBbHRzID09PSBvdGhlci5jb25mbGljdGluZ0FsdHMgJiYgdGhpcy5oYXNTZW1hbnRpY0NvbnRleHQgPT09IG90aGVyLmhhc1NlbWFudGljQ29udGV4dCAmJiB0aGlzLmRpcHNJbnRvT3V0ZXJDb250ZXh0ID09PSBvdGhlci5kaXBzSW50b091dGVyQ29udGV4dDtcbiAgICB9XG4gICAgaGFzaENvZGUoKSB7XG4gICAgICBjb25zdCBoYXNoID0gbmV3IFV0aWxzMy5IYXNoKCk7XG4gICAgICBoYXNoLnVwZGF0ZSh0aGlzLmNvbmZpZ3MpO1xuICAgICAgcmV0dXJuIGhhc2guZmluaXNoKCk7XG4gICAgfVxuICAgIHVwZGF0ZUhhc2hDb2RlKGhhc2gpIHtcbiAgICAgIGlmICh0aGlzLnJlYWRPbmx5KSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZEhhc2hDb2RlID09PSAtMSkge1xuICAgICAgICAgIHRoaXMuY2FjaGVkSGFzaENvZGUgPSB0aGlzLmhhc2hDb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzaC51cGRhdGUodGhpcy5jYWNoZWRIYXNoQ29kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYXNoLnVwZGF0ZSh0aGlzLmhhc2hDb2RlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZmlncy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGNvbnRhaW5zKGl0ZW0pIHtcbiAgICAgIGlmICh0aGlzLmNvbmZpZ0xvb2t1cCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBcIlRoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgcmVhZG9ubHkgc2V0cy5cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZ0xvb2t1cC5jb250YWlucyhpdGVtKTtcbiAgICB9XG4gICAgY29udGFpbnNGYXN0KGl0ZW0pIHtcbiAgICAgIGlmICh0aGlzLmNvbmZpZ0xvb2t1cCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBcIlRoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgcmVhZG9ubHkgc2V0cy5cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZ0xvb2t1cC5jb250YWluc0Zhc3QoaXRlbSk7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgaWYgKHRoaXMucmVhZE9ubHkpIHtcbiAgICAgICAgdGhyb3cgXCJUaGlzIHNldCBpcyByZWFkb25seVwiO1xuICAgICAgfVxuICAgICAgdGhpcy5jb25maWdzID0gW107XG4gICAgICB0aGlzLmNhY2hlZEhhc2hDb2RlID0gLTE7XG4gICAgICB0aGlzLmNvbmZpZ0xvb2t1cCA9IG5ldyBVdGlsczMuU2V0KCk7XG4gICAgfVxuICAgIHNldFJlYWRvbmx5KHJlYWRPbmx5KSB7XG4gICAgICB0aGlzLnJlYWRPbmx5ID0gcmVhZE9ubHk7XG4gICAgICBpZiAocmVhZE9ubHkpIHtcbiAgICAgICAgdGhpcy5jb25maWdMb29rdXAgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBVdGlsczMuYXJyYXlUb1N0cmluZyh0aGlzLmNvbmZpZ3MpICsgKHRoaXMuaGFzU2VtYW50aWNDb250ZXh0ID8gXCIsaGFzU2VtYW50aWNDb250ZXh0PVwiICsgdGhpcy5oYXNTZW1hbnRpY0NvbnRleHQgOiBcIlwiKSArICh0aGlzLnVuaXF1ZUFsdCAhPT0gQVROMi5JTlZBTElEX0FMVF9OVU1CRVIgPyBcIix1bmlxdWVBbHQ9XCIgKyB0aGlzLnVuaXF1ZUFsdCA6IFwiXCIpICsgKHRoaXMuY29uZmxpY3RpbmdBbHRzICE9PSBudWxsID8gXCIsY29uZmxpY3RpbmdBbHRzPVwiICsgdGhpcy5jb25mbGljdGluZ0FsdHMgOiBcIlwiKSArICh0aGlzLmRpcHNJbnRvT3V0ZXJDb250ZXh0ID8gXCIsZGlwc0ludG9PdXRlckNvbnRleHRcIiA6IFwiXCIpO1xuICAgIH1cbiAgICBnZXQgaXRlbXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25maWdzO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZmlncy5sZW5ndGg7XG4gICAgfVxuICB9O1xuICB2YXIgT3JkZXJlZEFUTkNvbmZpZ1NldCA9IGNsYXNzIGV4dGVuZHMgQVROQ29uZmlnU2V0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLmNvbmZpZ0xvb2t1cCA9IG5ldyBVdGlsczMuU2V0KCk7XG4gICAgfVxuICB9O1xuICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgQVROQ29uZmlnU2V0LFxuICAgIE9yZGVyZWRBVE5Db25maWdTZXRcbiAgfTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0L3NyYy9hbnRscjQvZGZhL0RGQVN0YXRlLmpzXG52YXIgcmVxdWlyZV9ERkFTdGF0ZTIgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUyKSA9PiB7XG4gIHZhciB7QVROQ29uZmlnU2V0fSA9IHJlcXVpcmVfQVROQ29uZmlnU2V0MigpO1xuICB2YXIge0hhc2g6IEhhc2gyLCBTZXQ6IFNldDJ9ID0gcmVxdWlyZV9VdGlsczIoKTtcbiAgdmFyIFByZWRQcmVkaWN0aW9uID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHByZWQsIGFsdCkge1xuICAgICAgdGhpcy5hbHQgPSBhbHQ7XG4gICAgICB0aGlzLnByZWQgPSBwcmVkO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIihcIiArIHRoaXMucHJlZCArIFwiLCBcIiArIHRoaXMuYWx0ICsgXCIpXCI7XG4gICAgfVxuICB9O1xuICB2YXIgREZBU3RhdGUgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3Ioc3RhdGVOdW1iZXIsIGNvbmZpZ3MpIHtcbiAgICAgIGlmIChzdGF0ZU51bWJlciA9PT0gbnVsbCkge1xuICAgICAgICBzdGF0ZU51bWJlciA9IC0xO1xuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZ3MgPT09IG51bGwpIHtcbiAgICAgICAgY29uZmlncyA9IG5ldyBBVE5Db25maWdTZXQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGVOdW1iZXIgPSBzdGF0ZU51bWJlcjtcbiAgICAgIHRoaXMuY29uZmlncyA9IGNvbmZpZ3M7XG4gICAgICB0aGlzLmVkZ2VzID0gbnVsbDtcbiAgICAgIHRoaXMuaXNBY2NlcHRTdGF0ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5wcmVkaWN0aW9uID0gMDtcbiAgICAgIHRoaXMubGV4ZXJBY3Rpb25FeGVjdXRvciA9IG51bGw7XG4gICAgICB0aGlzLnJlcXVpcmVzRnVsbENvbnRleHQgPSBmYWxzZTtcbiAgICAgIHRoaXMucHJlZGljYXRlcyA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0QWx0U2V0KCkge1xuICAgICAgY29uc3QgYWx0cyA9IG5ldyBTZXQyKCk7XG4gICAgICBpZiAodGhpcy5jb25maWdzICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgYyA9IHRoaXMuY29uZmlnc1tpXTtcbiAgICAgICAgICBhbHRzLmFkZChjLmFsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhbHRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhbHRzO1xuICAgICAgfVxuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzID09PSBvdGhlciB8fCBvdGhlciBpbnN0YW5jZW9mIERGQVN0YXRlICYmIHRoaXMuY29uZmlncy5lcXVhbHMob3RoZXIuY29uZmlncyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgbGV0IHMgPSBcIlwiICsgdGhpcy5zdGF0ZU51bWJlciArIFwiOlwiICsgdGhpcy5jb25maWdzO1xuICAgICAgaWYgKHRoaXMuaXNBY2NlcHRTdGF0ZSkge1xuICAgICAgICBzID0gcyArIFwiPT5cIjtcbiAgICAgICAgaWYgKHRoaXMucHJlZGljYXRlcyAhPT0gbnVsbClcbiAgICAgICAgICBzID0gcyArIHRoaXMucHJlZGljYXRlcztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHMgPSBzICsgdGhpcy5wcmVkaWN0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGhhc2hDb2RlKCkge1xuICAgICAgY29uc3QgaGFzaCA9IG5ldyBIYXNoMigpO1xuICAgICAgaGFzaC51cGRhdGUodGhpcy5jb25maWdzKTtcbiAgICAgIHJldHVybiBoYXNoLmZpbmlzaCgpO1xuICAgIH1cbiAgfTtcbiAgbW9kdWxlMi5leHBvcnRzID0ge0RGQVN0YXRlLCBQcmVkUHJlZGljdGlvbn07XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNC9zcmMvYW50bHI0L2F0bi9BVE5TaW11bGF0b3IuanNcbnZhciByZXF1aXJlX0FUTlNpbXVsYXRvcjIgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUyKSA9PiB7XG4gIHZhciB7REZBU3RhdGV9ID0gcmVxdWlyZV9ERkFTdGF0ZTIoKTtcbiAgdmFyIHtBVE5Db25maWdTZXR9ID0gcmVxdWlyZV9BVE5Db25maWdTZXQyKCk7XG4gIHZhciB7Z2V0Q2FjaGVkUHJlZGljdGlvbkNvbnRleHR9ID0gcmVxdWlyZV9QcmVkaWN0aW9uQ29udGV4dDIoKTtcbiAgdmFyIHtNYXA6IE1hcDJ9ID0gcmVxdWlyZV9VdGlsczIoKTtcbiAgdmFyIEFUTlNpbXVsYXRvciA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihhdG4sIHNoYXJlZENvbnRleHRDYWNoZSkge1xuICAgICAgdGhpcy5hdG4gPSBhdG47XG4gICAgICB0aGlzLnNoYXJlZENvbnRleHRDYWNoZSA9IHNoYXJlZENvbnRleHRDYWNoZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRDYWNoZWRDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgIGlmICh0aGlzLnNoYXJlZENvbnRleHRDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZpc2l0ZWQgPSBuZXcgTWFwMigpO1xuICAgICAgcmV0dXJuIGdldENhY2hlZFByZWRpY3Rpb25Db250ZXh0KGNvbnRleHQsIHRoaXMuc2hhcmVkQ29udGV4dENhY2hlLCB2aXNpdGVkKTtcbiAgICB9XG4gIH07XG4gIEFUTlNpbXVsYXRvci5FUlJPUiA9IG5ldyBERkFTdGF0ZSgyMTQ3NDgzNjQ3LCBuZXcgQVROQ29uZmlnU2V0KCkpO1xuICBtb2R1bGUyLmV4cG9ydHMgPSBBVE5TaW11bGF0b3I7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNC9zcmMvYW50bHI0L2F0bi9MZXhlckFjdGlvbkV4ZWN1dG9yLmpzXG52YXIgcmVxdWlyZV9MZXhlckFjdGlvbkV4ZWN1dG9yMiA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZTIpID0+IHtcbiAgdmFyIHtoYXNoU3R1ZmZ9ID0gcmVxdWlyZV9VdGlsczIoKTtcbiAgdmFyIHtMZXhlckluZGV4ZWRDdXN0b21BY3Rpb259ID0gcmVxdWlyZV9MZXhlckFjdGlvbigpO1xuICB2YXIgTGV4ZXJBY3Rpb25FeGVjdXRvciA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihsZXhlckFjdGlvbnMpIHtcbiAgICAgIHRoaXMubGV4ZXJBY3Rpb25zID0gbGV4ZXJBY3Rpb25zID09PSBudWxsID8gW10gOiBsZXhlckFjdGlvbnM7XG4gICAgICB0aGlzLmNhY2hlZEhhc2hDb2RlID0gaGFzaFN0dWZmKGxleGVyQWN0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZml4T2Zmc2V0QmVmb3JlTWF0Y2gob2Zmc2V0KSB7XG4gICAgICBsZXQgdXBkYXRlZExleGVyQWN0aW9ucyA9IG51bGw7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGV4ZXJBY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmxleGVyQWN0aW9uc1tpXS5pc1Bvc2l0aW9uRGVwZW5kZW50ICYmICEodGhpcy5sZXhlckFjdGlvbnNbaV0gaW5zdGFuY2VvZiBMZXhlckluZGV4ZWRDdXN0b21BY3Rpb24pKSB7XG4gICAgICAgICAgaWYgKHVwZGF0ZWRMZXhlckFjdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHVwZGF0ZWRMZXhlckFjdGlvbnMgPSB0aGlzLmxleGVyQWN0aW9ucy5jb25jYXQoW10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVkTGV4ZXJBY3Rpb25zW2ldID0gbmV3IExleGVySW5kZXhlZEN1c3RvbUFjdGlvbihvZmZzZXQsIHRoaXMubGV4ZXJBY3Rpb25zW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHVwZGF0ZWRMZXhlckFjdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IExleGVyQWN0aW9uRXhlY3V0b3IodXBkYXRlZExleGVyQWN0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIGV4ZWN1dGUobGV4ZXIsIGlucHV0LCBzdGFydEluZGV4KSB7XG4gICAgICBsZXQgcmVxdWlyZXNTZWVrID0gZmFsc2U7XG4gICAgICBjb25zdCBzdG9wSW5kZXggPSBpbnB1dC5pbmRleDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZXhlckFjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgbGV4ZXJBY3Rpb24gPSB0aGlzLmxleGVyQWN0aW9uc1tpXTtcbiAgICAgICAgICBpZiAobGV4ZXJBY3Rpb24gaW5zdGFuY2VvZiBMZXhlckluZGV4ZWRDdXN0b21BY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGxleGVyQWN0aW9uLm9mZnNldDtcbiAgICAgICAgICAgIGlucHV0LnNlZWsoc3RhcnRJbmRleCArIG9mZnNldCk7XG4gICAgICAgICAgICBsZXhlckFjdGlvbiA9IGxleGVyQWN0aW9uLmFjdGlvbjtcbiAgICAgICAgICAgIHJlcXVpcmVzU2VlayA9IHN0YXJ0SW5kZXggKyBvZmZzZXQgIT09IHN0b3BJbmRleDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxleGVyQWN0aW9uLmlzUG9zaXRpb25EZXBlbmRlbnQpIHtcbiAgICAgICAgICAgIGlucHV0LnNlZWsoc3RvcEluZGV4KTtcbiAgICAgICAgICAgIHJlcXVpcmVzU2VlayA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXhlckFjdGlvbi5leGVjdXRlKGxleGVyKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHJlcXVpcmVzU2Vlaykge1xuICAgICAgICAgIGlucHV0LnNlZWsoc3RvcEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBoYXNoQ29kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlZEhhc2hDb2RlO1xuICAgIH1cbiAgICB1cGRhdGVIYXNoQ29kZShoYXNoKSB7XG4gICAgICBoYXNoLnVwZGF0ZSh0aGlzLmNhY2hlZEhhc2hDb2RlKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBMZXhlckFjdGlvbkV4ZWN1dG9yKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY2FjaGVkSGFzaENvZGUgIT0gb3RoZXIuY2FjaGVkSGFzaENvZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmxleGVyQWN0aW9ucy5sZW5ndGggIT0gb3RoZXIubGV4ZXJBY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBudW1BY3Rpb25zID0gdGhpcy5sZXhlckFjdGlvbnMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBudW1BY3Rpb25zOyArK2lkeCkge1xuICAgICAgICAgIGlmICghdGhpcy5sZXhlckFjdGlvbnNbaWR4XS5lcXVhbHMob3RoZXIubGV4ZXJBY3Rpb25zW2lkeF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgYXBwZW5kKGxleGVyQWN0aW9uRXhlY3V0b3IsIGxleGVyQWN0aW9uKSB7XG4gICAgICBpZiAobGV4ZXJBY3Rpb25FeGVjdXRvciA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbmV3IExleGVyQWN0aW9uRXhlY3V0b3IoW2xleGVyQWN0aW9uXSk7XG4gICAgICB9XG4gICAgICBjb25zdCBsZXhlckFjdGlvbnMgPSBsZXhlckFjdGlvbkV4ZWN1dG9yLmxleGVyQWN0aW9ucy5jb25jYXQoW2xleGVyQWN0aW9uXSk7XG4gICAgICByZXR1cm4gbmV3IExleGVyQWN0aW9uRXhlY3V0b3IobGV4ZXJBY3Rpb25zKTtcbiAgICB9XG4gIH07XG4gIG1vZHVsZTIuZXhwb3J0cyA9IExleGVyQWN0aW9uRXhlY3V0b3I7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNC9zcmMvYW50bHI0L2F0bi9MZXhlckFUTlNpbXVsYXRvci5qc1xudmFyIHJlcXVpcmVfTGV4ZXJBVE5TaW11bGF0b3IyID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlMikgPT4ge1xuICB2YXIge1Rva2VuOiBUb2tlbjJ9ID0gcmVxdWlyZV9Ub2tlbjIoKTtcbiAgdmFyIExleGVyMiA9IHJlcXVpcmVfTGV4ZXIyKCk7XG4gIHZhciBBVE4yID0gcmVxdWlyZV9BVE4yKCk7XG4gIHZhciBBVE5TaW11bGF0b3IgPSByZXF1aXJlX0FUTlNpbXVsYXRvcjIoKTtcbiAgdmFyIHtERkFTdGF0ZX0gPSByZXF1aXJlX0RGQVN0YXRlMigpO1xuICB2YXIge09yZGVyZWRBVE5Db25maWdTZXR9ID0gcmVxdWlyZV9BVE5Db25maWdTZXQyKCk7XG4gIHZhciB7UHJlZGljdGlvbkNvbnRleHR9ID0gcmVxdWlyZV9QcmVkaWN0aW9uQ29udGV4dDIoKTtcbiAgdmFyIHtTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dH0gPSByZXF1aXJlX1ByZWRpY3Rpb25Db250ZXh0MigpO1xuICB2YXIge1J1bGVTdG9wU3RhdGV9ID0gcmVxdWlyZV9BVE5TdGF0ZTIoKTtcbiAgdmFyIHtMZXhlckFUTkNvbmZpZ30gPSByZXF1aXJlX0FUTkNvbmZpZzIoKTtcbiAgdmFyIHtUcmFuc2l0aW9ufSA9IHJlcXVpcmVfVHJhbnNpdGlvbjIoKTtcbiAgdmFyIExleGVyQWN0aW9uRXhlY3V0b3IgPSByZXF1aXJlX0xleGVyQWN0aW9uRXhlY3V0b3IyKCk7XG4gIHZhciB7TGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbn0gPSByZXF1aXJlX0Vycm9ycygpO1xuICBmdW5jdGlvbiByZXNldFNpbVN0YXRlKHNpbSkge1xuICAgIHNpbS5pbmRleCA9IC0xO1xuICAgIHNpbS5saW5lID0gMDtcbiAgICBzaW0uY29sdW1uID0gLTE7XG4gICAgc2ltLmRmYVN0YXRlID0gbnVsbDtcbiAgfVxuICB2YXIgU2ltU3RhdGUgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICByZXNldFNpbVN0YXRlKHRoaXMpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgIHJlc2V0U2ltU3RhdGUodGhpcyk7XG4gICAgfVxuICB9O1xuICB2YXIgTGV4ZXJBVE5TaW11bGF0b3IyID0gY2xhc3MgZXh0ZW5kcyBBVE5TaW11bGF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlY29nLCBhdG4sIGRlY2lzaW9uVG9ERkEsIHNoYXJlZENvbnRleHRDYWNoZSkge1xuICAgICAgc3VwZXIoYXRuLCBzaGFyZWRDb250ZXh0Q2FjaGUpO1xuICAgICAgdGhpcy5kZWNpc2lvblRvREZBID0gZGVjaXNpb25Ub0RGQTtcbiAgICAgIHRoaXMucmVjb2cgPSByZWNvZztcbiAgICAgIHRoaXMuc3RhcnRJbmRleCA9IC0xO1xuICAgICAgdGhpcy5saW5lID0gMTtcbiAgICAgIHRoaXMuY29sdW1uID0gMDtcbiAgICAgIHRoaXMubW9kZSA9IExleGVyMi5ERUZBVUxUX01PREU7XG4gICAgICB0aGlzLnByZXZBY2NlcHQgPSBuZXcgU2ltU3RhdGUoKTtcbiAgICB9XG4gICAgY29weVN0YXRlKHNpbXVsYXRvcikge1xuICAgICAgdGhpcy5jb2x1bW4gPSBzaW11bGF0b3IuY29sdW1uO1xuICAgICAgdGhpcy5saW5lID0gc2ltdWxhdG9yLmxpbmU7XG4gICAgICB0aGlzLm1vZGUgPSBzaW11bGF0b3IubW9kZTtcbiAgICAgIHRoaXMuc3RhcnRJbmRleCA9IHNpbXVsYXRvci5zdGFydEluZGV4O1xuICAgIH1cbiAgICBtYXRjaChpbnB1dCwgbW9kZSkge1xuICAgICAgdGhpcy5tYXRjaF9jYWxscyArPSAxO1xuICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgIGNvbnN0IG1hcmsgPSBpbnB1dC5tYXJrKCk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSBpbnB1dC5pbmRleDtcbiAgICAgICAgdGhpcy5wcmV2QWNjZXB0LnJlc2V0KCk7XG4gICAgICAgIGNvbnN0IGRmYSA9IHRoaXMuZGVjaXNpb25Ub0RGQVttb2RlXTtcbiAgICAgICAgaWYgKGRmYS5zMCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1hdGNoQVROKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5leGVjQVROKGlucHV0LCBkZmEuczApO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpbnB1dC5yZWxlYXNlKG1hcmspO1xuICAgICAgfVxuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgIHRoaXMucHJldkFjY2VwdC5yZXNldCgpO1xuICAgICAgdGhpcy5zdGFydEluZGV4ID0gLTE7XG4gICAgICB0aGlzLmxpbmUgPSAxO1xuICAgICAgdGhpcy5jb2x1bW4gPSAwO1xuICAgICAgdGhpcy5tb2RlID0gTGV4ZXIyLkRFRkFVTFRfTU9ERTtcbiAgICB9XG4gICAgbWF0Y2hBVE4oaW5wdXQpIHtcbiAgICAgIGNvbnN0IHN0YXJ0U3RhdGUgPSB0aGlzLmF0bi5tb2RlVG9TdGFydFN0YXRlW3RoaXMubW9kZV07XG4gICAgICBpZiAoTGV4ZXJBVE5TaW11bGF0b3IyLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibWF0Y2hBVE4gbW9kZSBcIiArIHRoaXMubW9kZSArIFwiIHN0YXJ0OiBcIiArIHN0YXJ0U3RhdGUpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2xkX21vZGUgPSB0aGlzLm1vZGU7XG4gICAgICBjb25zdCBzMF9jbG9zdXJlID0gdGhpcy5jb21wdXRlU3RhcnRTdGF0ZShpbnB1dCwgc3RhcnRTdGF0ZSk7XG4gICAgICBjb25zdCBzdXBwcmVzc0VkZ2UgPSBzMF9jbG9zdXJlLmhhc1NlbWFudGljQ29udGV4dDtcbiAgICAgIHMwX2Nsb3N1cmUuaGFzU2VtYW50aWNDb250ZXh0ID0gZmFsc2U7XG4gICAgICBjb25zdCBuZXh0ID0gdGhpcy5hZGRERkFTdGF0ZShzMF9jbG9zdXJlKTtcbiAgICAgIGlmICghc3VwcHJlc3NFZGdlKSB7XG4gICAgICAgIHRoaXMuZGVjaXNpb25Ub0RGQVt0aGlzLm1vZGVdLnMwID0gbmV4dDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZWRpY3QgPSB0aGlzLmV4ZWNBVE4oaW5wdXQsIG5leHQpO1xuICAgICAgaWYgKExleGVyQVROU2ltdWxhdG9yMi5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkRGQSBhZnRlciBtYXRjaEFUTjogXCIgKyB0aGlzLmRlY2lzaW9uVG9ERkFbb2xkX21vZGVdLnRvTGV4ZXJTdHJpbmcoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJlZGljdDtcbiAgICB9XG4gICAgZXhlY0FUTihpbnB1dCwgZHMwKSB7XG4gICAgICBpZiAoTGV4ZXJBVE5TaW11bGF0b3IyLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwic3RhcnQgc3RhdGUgY2xvc3VyZT1cIiArIGRzMC5jb25maWdzKTtcbiAgICAgIH1cbiAgICAgIGlmIChkczAuaXNBY2NlcHRTdGF0ZSkge1xuICAgICAgICB0aGlzLmNhcHR1cmVTaW1TdGF0ZSh0aGlzLnByZXZBY2NlcHQsIGlucHV0LCBkczApO1xuICAgICAgfVxuICAgICAgbGV0IHQgPSBpbnB1dC5MQSgxKTtcbiAgICAgIGxldCBzID0gZHMwO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKExleGVyQVROU2ltdWxhdG9yMi5kZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiZXhlY0FUTiBsb29wIHN0YXJ0aW5nIGNsb3N1cmU6IFwiICsgcy5jb25maWdzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5nZXRFeGlzdGluZ1RhcmdldFN0YXRlKHMsIHQpO1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gdGhpcy5jb21wdXRlVGFyZ2V0U3RhdGUoaW5wdXQsIHMsIHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXQgPT09IEFUTlNpbXVsYXRvci5FUlJPUikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ICE9PSBUb2tlbjIuRU9GKSB7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0LmlzQWNjZXB0U3RhdGUpIHtcbiAgICAgICAgICB0aGlzLmNhcHR1cmVTaW1TdGF0ZSh0aGlzLnByZXZBY2NlcHQsIGlucHV0LCB0YXJnZXQpO1xuICAgICAgICAgIGlmICh0ID09PSBUb2tlbjIuRU9GKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdCA9IGlucHV0LkxBKDEpO1xuICAgICAgICBzID0gdGFyZ2V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmFpbE9yQWNjZXB0KHRoaXMucHJldkFjY2VwdCwgaW5wdXQsIHMuY29uZmlncywgdCk7XG4gICAgfVxuICAgIGdldEV4aXN0aW5nVGFyZ2V0U3RhdGUocywgdCkge1xuICAgICAgaWYgKHMuZWRnZXMgPT09IG51bGwgfHwgdCA8IExleGVyQVROU2ltdWxhdG9yMi5NSU5fREZBX0VER0UgfHwgdCA+IExleGVyQVROU2ltdWxhdG9yMi5NQVhfREZBX0VER0UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBsZXQgdGFyZ2V0ID0gcy5lZGdlc1t0IC0gTGV4ZXJBVE5TaW11bGF0b3IyLk1JTl9ERkFfRURHRV07XG4gICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChMZXhlckFUTlNpbXVsYXRvcjIuZGVidWcgJiYgdGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwicmV1c2Ugc3RhdGUgXCIgKyBzLnN0YXRlTnVtYmVyICsgXCIgZWRnZSB0byBcIiArIHRhcmdldC5zdGF0ZU51bWJlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBjb21wdXRlVGFyZ2V0U3RhdGUoaW5wdXQsIHMsIHQpIHtcbiAgICAgIGNvbnN0IHJlYWNoID0gbmV3IE9yZGVyZWRBVE5Db25maWdTZXQoKTtcbiAgICAgIHRoaXMuZ2V0UmVhY2hhYmxlQ29uZmlnU2V0KGlucHV0LCBzLmNvbmZpZ3MsIHJlYWNoLCB0KTtcbiAgICAgIGlmIChyZWFjaC5pdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKCFyZWFjaC5oYXNTZW1hbnRpY0NvbnRleHQpIHtcbiAgICAgICAgICB0aGlzLmFkZERGQUVkZ2UocywgdCwgQVROU2ltdWxhdG9yLkVSUk9SKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQVROU2ltdWxhdG9yLkVSUk9SO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuYWRkREZBRWRnZShzLCB0LCBudWxsLCByZWFjaCk7XG4gICAgfVxuICAgIGZhaWxPckFjY2VwdChwcmV2QWNjZXB0LCBpbnB1dCwgcmVhY2gsIHQpIHtcbiAgICAgIGlmICh0aGlzLnByZXZBY2NlcHQuZGZhU3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgbGV4ZXJBY3Rpb25FeGVjdXRvciA9IHByZXZBY2NlcHQuZGZhU3RhdGUubGV4ZXJBY3Rpb25FeGVjdXRvcjtcbiAgICAgICAgdGhpcy5hY2NlcHQoaW5wdXQsIGxleGVyQWN0aW9uRXhlY3V0b3IsIHRoaXMuc3RhcnRJbmRleCwgcHJldkFjY2VwdC5pbmRleCwgcHJldkFjY2VwdC5saW5lLCBwcmV2QWNjZXB0LmNvbHVtbik7XG4gICAgICAgIHJldHVybiBwcmV2QWNjZXB0LmRmYVN0YXRlLnByZWRpY3Rpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodCA9PT0gVG9rZW4yLkVPRiAmJiBpbnB1dC5pbmRleCA9PT0gdGhpcy5zdGFydEluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIFRva2VuMi5FT0Y7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IExleGVyTm9WaWFibGVBbHRFeGNlcHRpb24odGhpcy5yZWNvZywgaW5wdXQsIHRoaXMuc3RhcnRJbmRleCwgcmVhY2gpO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXRSZWFjaGFibGVDb25maWdTZXQoaW5wdXQsIGNsb3N1cmUsIHJlYWNoLCB0KSB7XG4gICAgICBsZXQgc2tpcEFsdCA9IEFUTjIuSU5WQUxJRF9BTFRfTlVNQkVSO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbG9zdXJlLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNmZyA9IGNsb3N1cmUuaXRlbXNbaV07XG4gICAgICAgIGNvbnN0IGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGUgPSBjZmcuYWx0ID09PSBza2lwQWx0O1xuICAgICAgICBpZiAoY3VycmVudEFsdFJlYWNoZWRBY2NlcHRTdGF0ZSAmJiBjZmcucGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKExleGVyQVROU2ltdWxhdG9yMi5kZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwidGVzdGluZyAlcyBhdCAlc1xcblwiLCB0aGlzLmdldFRva2VuTmFtZSh0KSwgY2ZnLnRvU3RyaW5nKHRoaXMucmVjb2csIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNmZy5zdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IHRyYW5zID0gY2ZnLnN0YXRlLnRyYW5zaXRpb25zW2pdO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZ2V0UmVhY2hhYmxlVGFyZ2V0KHRyYW5zLCB0KTtcbiAgICAgICAgICBpZiAodGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgbGV4ZXJBY3Rpb25FeGVjdXRvciA9IGNmZy5sZXhlckFjdGlvbkV4ZWN1dG9yO1xuICAgICAgICAgICAgaWYgKGxleGVyQWN0aW9uRXhlY3V0b3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgbGV4ZXJBY3Rpb25FeGVjdXRvciA9IGxleGVyQWN0aW9uRXhlY3V0b3IuZml4T2Zmc2V0QmVmb3JlTWF0Y2goaW5wdXQuaW5kZXggLSB0aGlzLnN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHJlYXRFb2ZBc0Vwc2lsb24gPSB0ID09PSBUb2tlbjIuRU9GO1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gbmV3IExleGVyQVROQ29uZmlnKHtzdGF0ZTogdGFyZ2V0LCBsZXhlckFjdGlvbkV4ZWN1dG9yfSwgY2ZnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsb3N1cmUoaW5wdXQsIGNvbmZpZywgcmVhY2gsIGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGUsIHRydWUsIHRyZWF0RW9mQXNFcHNpbG9uKSkge1xuICAgICAgICAgICAgICBza2lwQWx0ID0gY2ZnLmFsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYWNjZXB0KGlucHV0LCBsZXhlckFjdGlvbkV4ZWN1dG9yLCBzdGFydEluZGV4LCBpbmRleCwgbGluZSwgY2hhclBvcykge1xuICAgICAgaWYgKExleGVyQVROU2ltdWxhdG9yMi5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFDVElPTiAlc1xcblwiLCBsZXhlckFjdGlvbkV4ZWN1dG9yKTtcbiAgICAgIH1cbiAgICAgIGlucHV0LnNlZWsoaW5kZXgpO1xuICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgIHRoaXMuY29sdW1uID0gY2hhclBvcztcbiAgICAgIGlmIChsZXhlckFjdGlvbkV4ZWN1dG9yICE9PSBudWxsICYmIHRoaXMucmVjb2cgIT09IG51bGwpIHtcbiAgICAgICAgbGV4ZXJBY3Rpb25FeGVjdXRvci5leGVjdXRlKHRoaXMucmVjb2csIGlucHV0LCBzdGFydEluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0UmVhY2hhYmxlVGFyZ2V0KHRyYW5zLCB0KSB7XG4gICAgICBpZiAodHJhbnMubWF0Y2hlcyh0LCAwLCBMZXhlcjIuTUFYX0NIQVJfVkFMVUUpKSB7XG4gICAgICAgIHJldHVybiB0cmFucy50YXJnZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29tcHV0ZVN0YXJ0U3RhdGUoaW5wdXQsIHApIHtcbiAgICAgIGNvbnN0IGluaXRpYWxDb250ZXh0ID0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFk7XG4gICAgICBjb25zdCBjb25maWdzID0gbmV3IE9yZGVyZWRBVE5Db25maWdTZXQoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcC50cmFuc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBwLnRyYW5zaXRpb25zW2ldLnRhcmdldDtcbiAgICAgICAgY29uc3QgY2ZnID0gbmV3IExleGVyQVROQ29uZmlnKHtzdGF0ZTogdGFyZ2V0LCBhbHQ6IGkgKyAxLCBjb250ZXh0OiBpbml0aWFsQ29udGV4dH0sIG51bGwpO1xuICAgICAgICB0aGlzLmNsb3N1cmUoaW5wdXQsIGNmZywgY29uZmlncywgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uZmlncztcbiAgICB9XG4gICAgY2xvc3VyZShpbnB1dCwgY29uZmlnLCBjb25maWdzLCBjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlLCBzcGVjdWxhdGl2ZSwgdHJlYXRFb2ZBc0Vwc2lsb24pIHtcbiAgICAgIGxldCBjZmcgPSBudWxsO1xuICAgICAgaWYgKExleGVyQVROU2ltdWxhdG9yMi5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcImNsb3N1cmUoXCIgKyBjb25maWcudG9TdHJpbmcodGhpcy5yZWNvZywgdHJ1ZSkgKyBcIilcIik7XG4gICAgICB9XG4gICAgICBpZiAoY29uZmlnLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkge1xuICAgICAgICBpZiAoTGV4ZXJBVE5TaW11bGF0b3IyLmRlYnVnKSB7XG4gICAgICAgICAgaWYgKHRoaXMucmVjb2cgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2xvc3VyZSBhdCAlcyBydWxlIHN0b3AgJXNcXG5cIiwgdGhpcy5yZWNvZy5ydWxlTmFtZXNbY29uZmlnLnN0YXRlLnJ1bGVJbmRleF0sIGNvbmZpZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2xvc3VyZSBhdCBydWxlIHN0b3AgJXNcXG5cIiwgY29uZmlnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5jb250ZXh0ID09PSBudWxsIHx8IGNvbmZpZy5jb250ZXh0Lmhhc0VtcHR5UGF0aCgpKSB7XG4gICAgICAgICAgaWYgKGNvbmZpZy5jb250ZXh0ID09PSBudWxsIHx8IGNvbmZpZy5jb250ZXh0LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgY29uZmlncy5hZGQoY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWdzLmFkZChuZXcgTGV4ZXJBVE5Db25maWcoe3N0YXRlOiBjb25maWcuc3RhdGUsIGNvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZfSwgY29uZmlnKSk7XG4gICAgICAgICAgICBjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5jb250ZXh0ICE9PSBudWxsICYmICFjb25maWcuY29udGV4dC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbmZpZy5jb250ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmNvbnRleHQuZ2V0UmV0dXJuU3RhdGUoaSkgIT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX1JFVFVSTl9TVEFURSkge1xuICAgICAgICAgICAgICBjb25zdCBuZXdDb250ZXh0ID0gY29uZmlnLmNvbnRleHQuZ2V0UGFyZW50KGkpO1xuICAgICAgICAgICAgICBjb25zdCByZXR1cm5TdGF0ZSA9IHRoaXMuYXRuLnN0YXRlc1tjb25maWcuY29udGV4dC5nZXRSZXR1cm5TdGF0ZShpKV07XG4gICAgICAgICAgICAgIGNmZyA9IG5ldyBMZXhlckFUTkNvbmZpZyh7c3RhdGU6IHJldHVyblN0YXRlLCBjb250ZXh0OiBuZXdDb250ZXh0fSwgY29uZmlnKTtcbiAgICAgICAgICAgICAgY3VycmVudEFsdFJlYWNoZWRBY2NlcHRTdGF0ZSA9IHRoaXMuY2xvc3VyZShpbnB1dCwgY2ZnLCBjb25maWdzLCBjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlLCBzcGVjdWxhdGl2ZSwgdHJlYXRFb2ZBc0Vwc2lsb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudEFsdFJlYWNoZWRBY2NlcHRTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGlmICghY29uZmlnLnN0YXRlLmVwc2lsb25Pbmx5VHJhbnNpdGlvbnMpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlIHx8ICFjb25maWcucGFzc2VkVGhyb3VnaE5vbkdyZWVkeURlY2lzaW9uKSB7XG4gICAgICAgICAgY29uZmlncy5hZGQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb25maWcuc3RhdGUudHJhbnNpdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgdHJhbnMgPSBjb25maWcuc3RhdGUudHJhbnNpdGlvbnNbal07XG4gICAgICAgIGNmZyA9IHRoaXMuZ2V0RXBzaWxvblRhcmdldChpbnB1dCwgY29uZmlnLCB0cmFucywgY29uZmlncywgc3BlY3VsYXRpdmUsIHRyZWF0RW9mQXNFcHNpbG9uKTtcbiAgICAgICAgaWYgKGNmZyAhPT0gbnVsbCkge1xuICAgICAgICAgIGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGUgPSB0aGlzLmNsb3N1cmUoaW5wdXQsIGNmZywgY29uZmlncywgY3VycmVudEFsdFJlYWNoZWRBY2NlcHRTdGF0ZSwgc3BlY3VsYXRpdmUsIHRyZWF0RW9mQXNFcHNpbG9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGU7XG4gICAgfVxuICAgIGdldEVwc2lsb25UYXJnZXQoaW5wdXQsIGNvbmZpZywgdHJhbnMsIGNvbmZpZ3MsIHNwZWN1bGF0aXZlLCB0cmVhdEVvZkFzRXBzaWxvbikge1xuICAgICAgbGV0IGNmZyA9IG51bGw7XG4gICAgICBpZiAodHJhbnMuc2VyaWFsaXphdGlvblR5cGUgPT09IFRyYW5zaXRpb24uUlVMRSkge1xuICAgICAgICBjb25zdCBuZXdDb250ZXh0ID0gU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQuY3JlYXRlKGNvbmZpZy5jb250ZXh0LCB0cmFucy5mb2xsb3dTdGF0ZS5zdGF0ZU51bWJlcik7XG4gICAgICAgIGNmZyA9IG5ldyBMZXhlckFUTkNvbmZpZyh7c3RhdGU6IHRyYW5zLnRhcmdldCwgY29udGV4dDogbmV3Q29udGV4dH0sIGNvbmZpZyk7XG4gICAgICB9IGVsc2UgaWYgKHRyYW5zLnNlcmlhbGl6YXRpb25UeXBlID09PSBUcmFuc2l0aW9uLlBSRUNFREVOQ0UpIHtcbiAgICAgICAgdGhyb3cgXCJQcmVjZWRlbmNlIHByZWRpY2F0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gbGV4ZXJzLlwiO1xuICAgICAgfSBlbHNlIGlmICh0cmFucy5zZXJpYWxpemF0aW9uVHlwZSA9PT0gVHJhbnNpdGlvbi5QUkVESUNBVEUpIHtcbiAgICAgICAgaWYgKExleGVyQVROU2ltdWxhdG9yMi5kZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVZBTCBydWxlIFwiICsgdHJhbnMucnVsZUluZGV4ICsgXCI6XCIgKyB0cmFucy5wcmVkSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZ3MuaGFzU2VtYW50aWNDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuZXZhbHVhdGVQcmVkaWNhdGUoaW5wdXQsIHRyYW5zLnJ1bGVJbmRleCwgdHJhbnMucHJlZEluZGV4LCBzcGVjdWxhdGl2ZSkpIHtcbiAgICAgICAgICBjZmcgPSBuZXcgTGV4ZXJBVE5Db25maWcoe3N0YXRlOiB0cmFucy50YXJnZXR9LCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRyYW5zLnNlcmlhbGl6YXRpb25UeXBlID09PSBUcmFuc2l0aW9uLkFDVElPTikge1xuICAgICAgICBpZiAoY29uZmlnLmNvbnRleHQgPT09IG51bGwgfHwgY29uZmlnLmNvbnRleHQuaGFzRW1wdHlQYXRoKCkpIHtcbiAgICAgICAgICBjb25zdCBsZXhlckFjdGlvbkV4ZWN1dG9yID0gTGV4ZXJBY3Rpb25FeGVjdXRvci5hcHBlbmQoY29uZmlnLmxleGVyQWN0aW9uRXhlY3V0b3IsIHRoaXMuYXRuLmxleGVyQWN0aW9uc1t0cmFucy5hY3Rpb25JbmRleF0pO1xuICAgICAgICAgIGNmZyA9IG5ldyBMZXhlckFUTkNvbmZpZyh7c3RhdGU6IHRyYW5zLnRhcmdldCwgbGV4ZXJBY3Rpb25FeGVjdXRvcn0sIGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2ZnID0gbmV3IExleGVyQVROQ29uZmlnKHtzdGF0ZTogdHJhbnMudGFyZ2V0fSwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0cmFucy5zZXJpYWxpemF0aW9uVHlwZSA9PT0gVHJhbnNpdGlvbi5FUFNJTE9OKSB7XG4gICAgICAgIGNmZyA9IG5ldyBMZXhlckFUTkNvbmZpZyh7c3RhdGU6IHRyYW5zLnRhcmdldH0sIGNvbmZpZyk7XG4gICAgICB9IGVsc2UgaWYgKHRyYW5zLnNlcmlhbGl6YXRpb25UeXBlID09PSBUcmFuc2l0aW9uLkFUT00gfHwgdHJhbnMuc2VyaWFsaXphdGlvblR5cGUgPT09IFRyYW5zaXRpb24uUkFOR0UgfHwgdHJhbnMuc2VyaWFsaXphdGlvblR5cGUgPT09IFRyYW5zaXRpb24uU0VUKSB7XG4gICAgICAgIGlmICh0cmVhdEVvZkFzRXBzaWxvbikge1xuICAgICAgICAgIGlmICh0cmFucy5tYXRjaGVzKFRva2VuMi5FT0YsIDAsIExleGVyMi5NQVhfQ0hBUl9WQUxVRSkpIHtcbiAgICAgICAgICAgIGNmZyA9IG5ldyBMZXhlckFUTkNvbmZpZyh7c3RhdGU6IHRyYW5zLnRhcmdldH0sIGNvbmZpZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2ZnO1xuICAgIH1cbiAgICBldmFsdWF0ZVByZWRpY2F0ZShpbnB1dCwgcnVsZUluZGV4LCBwcmVkSW5kZXgsIHNwZWN1bGF0aXZlKSB7XG4gICAgICBpZiAodGhpcy5yZWNvZyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghc3BlY3VsYXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjb2cuc2VtcHJlZChudWxsLCBydWxlSW5kZXgsIHByZWRJbmRleCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzYXZlZGNvbHVtbiA9IHRoaXMuY29sdW1uO1xuICAgICAgY29uc3Qgc2F2ZWRMaW5lID0gdGhpcy5saW5lO1xuICAgICAgY29uc3QgaW5kZXggPSBpbnB1dC5pbmRleDtcbiAgICAgIGNvbnN0IG1hcmtlciA9IGlucHV0Lm1hcmsoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuY29uc3VtZShpbnB1dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY29nLnNlbXByZWQobnVsbCwgcnVsZUluZGV4LCBwcmVkSW5kZXgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBzYXZlZGNvbHVtbjtcbiAgICAgICAgdGhpcy5saW5lID0gc2F2ZWRMaW5lO1xuICAgICAgICBpbnB1dC5zZWVrKGluZGV4KTtcbiAgICAgICAgaW5wdXQucmVsZWFzZShtYXJrZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjYXB0dXJlU2ltU3RhdGUoc2V0dGluZ3MsIGlucHV0LCBkZmFTdGF0ZSkge1xuICAgICAgc2V0dGluZ3MuaW5kZXggPSBpbnB1dC5pbmRleDtcbiAgICAgIHNldHRpbmdzLmxpbmUgPSB0aGlzLmxpbmU7XG4gICAgICBzZXR0aW5ncy5jb2x1bW4gPSB0aGlzLmNvbHVtbjtcbiAgICAgIHNldHRpbmdzLmRmYVN0YXRlID0gZGZhU3RhdGU7XG4gICAgfVxuICAgIGFkZERGQUVkZ2UoZnJvbV8sIHRrLCB0bywgY2Zncykge1xuICAgICAgaWYgKHRvID09PSB2b2lkIDApIHtcbiAgICAgICAgdG8gPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGNmZ3MgPT09IHZvaWQgMCkge1xuICAgICAgICBjZmdzID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0byA9PT0gbnVsbCAmJiBjZmdzICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHN1cHByZXNzRWRnZSA9IGNmZ3MuaGFzU2VtYW50aWNDb250ZXh0O1xuICAgICAgICBjZmdzLmhhc1NlbWFudGljQ29udGV4dCA9IGZhbHNlO1xuICAgICAgICB0byA9IHRoaXMuYWRkREZBU3RhdGUoY2Zncyk7XG4gICAgICAgIGlmIChzdXBwcmVzc0VkZ2UpIHtcbiAgICAgICAgICByZXR1cm4gdG87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0ayA8IExleGVyQVROU2ltdWxhdG9yMi5NSU5fREZBX0VER0UgfHwgdGsgPiBMZXhlckFUTlNpbXVsYXRvcjIuTUFYX0RGQV9FREdFKSB7XG4gICAgICAgIHJldHVybiB0bztcbiAgICAgIH1cbiAgICAgIGlmIChMZXhlckFUTlNpbXVsYXRvcjIuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJFREdFIFwiICsgZnJvbV8gKyBcIiAtPiBcIiArIHRvICsgXCIgdXBvbiBcIiArIHRrKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcm9tXy5lZGdlcyA9PT0gbnVsbCkge1xuICAgICAgICBmcm9tXy5lZGdlcyA9IFtdO1xuICAgICAgfVxuICAgICAgZnJvbV8uZWRnZXNbdGsgLSBMZXhlckFUTlNpbXVsYXRvcjIuTUlOX0RGQV9FREdFXSA9IHRvO1xuICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBhZGRERkFTdGF0ZShjb25maWdzKSB7XG4gICAgICBjb25zdCBwcm9wb3NlZCA9IG5ldyBERkFTdGF0ZShudWxsLCBjb25maWdzKTtcbiAgICAgIGxldCBmaXJzdENvbmZpZ1dpdGhSdWxlU3RvcFN0YXRlID0gbnVsbDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29uZmlncy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjZmcgPSBjb25maWdzLml0ZW1zW2ldO1xuICAgICAgICBpZiAoY2ZnLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkge1xuICAgICAgICAgIGZpcnN0Q29uZmlnV2l0aFJ1bGVTdG9wU3RhdGUgPSBjZmc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdENvbmZpZ1dpdGhSdWxlU3RvcFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHByb3Bvc2VkLmlzQWNjZXB0U3RhdGUgPSB0cnVlO1xuICAgICAgICBwcm9wb3NlZC5sZXhlckFjdGlvbkV4ZWN1dG9yID0gZmlyc3RDb25maWdXaXRoUnVsZVN0b3BTdGF0ZS5sZXhlckFjdGlvbkV4ZWN1dG9yO1xuICAgICAgICBwcm9wb3NlZC5wcmVkaWN0aW9uID0gdGhpcy5hdG4ucnVsZVRvVG9rZW5UeXBlW2ZpcnN0Q29uZmlnV2l0aFJ1bGVTdG9wU3RhdGUuc3RhdGUucnVsZUluZGV4XTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRmYSA9IHRoaXMuZGVjaXNpb25Ub0RGQVt0aGlzLm1vZGVdO1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBkZmEuc3RhdGVzLmdldChwcm9wb3NlZCk7XG4gICAgICBpZiAoZXhpc3RpbmcgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3U3RhdGUgPSBwcm9wb3NlZDtcbiAgICAgIG5ld1N0YXRlLnN0YXRlTnVtYmVyID0gZGZhLnN0YXRlcy5sZW5ndGg7XG4gICAgICBjb25maWdzLnNldFJlYWRvbmx5KHRydWUpO1xuICAgICAgbmV3U3RhdGUuY29uZmlncyA9IGNvbmZpZ3M7XG4gICAgICBkZmEuc3RhdGVzLmFkZChuZXdTdGF0ZSk7XG4gICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgfVxuICAgIGdldERGQShtb2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNpc2lvblRvREZBW21vZGVdO1xuICAgIH1cbiAgICBnZXRUZXh0KGlucHV0KSB7XG4gICAgICByZXR1cm4gaW5wdXQuZ2V0VGV4dCh0aGlzLnN0YXJ0SW5kZXgsIGlucHV0LmluZGV4IC0gMSk7XG4gICAgfVxuICAgIGNvbnN1bWUoaW5wdXQpIHtcbiAgICAgIGNvbnN0IGN1ckNoYXIgPSBpbnB1dC5MQSgxKTtcbiAgICAgIGlmIChjdXJDaGFyID09PSBcIlxcblwiLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgdGhpcy5saW5lICs9IDE7XG4gICAgICAgIHRoaXMuY29sdW1uID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29sdW1uICs9IDE7XG4gICAgICB9XG4gICAgICBpbnB1dC5jb25zdW1lKCk7XG4gICAgfVxuICAgIGdldFRva2VuTmFtZSh0dCkge1xuICAgICAgaWYgKHR0ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gXCJFT0ZcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIidcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUodHQpICsgXCInXCI7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBMZXhlckFUTlNpbXVsYXRvcjIuZGVidWcgPSBmYWxzZTtcbiAgTGV4ZXJBVE5TaW11bGF0b3IyLmRmYV9kZWJ1ZyA9IGZhbHNlO1xuICBMZXhlckFUTlNpbXVsYXRvcjIuTUlOX0RGQV9FREdFID0gMDtcbiAgTGV4ZXJBVE5TaW11bGF0b3IyLk1BWF9ERkFfRURHRSA9IDEyNztcbiAgTGV4ZXJBVE5TaW11bGF0b3IyLm1hdGNoX2NhbGxzID0gMDtcbiAgbW9kdWxlMi5leHBvcnRzID0gTGV4ZXJBVE5TaW11bGF0b3IyO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjQvc3JjL2FudGxyNC9hdG4vUHJlZGljdGlvbk1vZGUuanNcbnZhciByZXF1aXJlX1ByZWRpY3Rpb25Nb2RlMiA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZTIpID0+IHtcbiAgdmFyIHtNYXA6IE1hcDIsIEJpdFNldCwgQWx0RGljdCwgaGFzaFN0dWZmfSA9IHJlcXVpcmVfVXRpbHMyKCk7XG4gIHZhciBBVE4yID0gcmVxdWlyZV9BVE4yKCk7XG4gIHZhciB7UnVsZVN0b3BTdGF0ZX0gPSByZXF1aXJlX0FUTlN0YXRlMigpO1xuICB2YXIge0FUTkNvbmZpZ1NldH0gPSByZXF1aXJlX0FUTkNvbmZpZ1NldDIoKTtcbiAgdmFyIHtBVE5Db25maWd9ID0gcmVxdWlyZV9BVE5Db25maWcyKCk7XG4gIHZhciB7U2VtYW50aWNDb250ZXh0fSA9IHJlcXVpcmVfU2VtYW50aWNDb250ZXh0MigpO1xuICB2YXIgUHJlZGljdGlvbk1vZGUgPSB7XG4gICAgU0xMOiAwLFxuICAgIExMOiAxLFxuICAgIExMX0VYQUNUX0FNQklHX0RFVEVDVElPTjogMixcbiAgICBoYXNTTExDb25mbGljdFRlcm1pbmF0aW5nUHJlZGljdGlvbjogZnVuY3Rpb24obW9kZSwgY29uZmlncykge1xuICAgICAgaWYgKFByZWRpY3Rpb25Nb2RlLmFsbENvbmZpZ3NJblJ1bGVTdG9wU3RhdGVzKGNvbmZpZ3MpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKG1vZGUgPT09IFByZWRpY3Rpb25Nb2RlLlNMTCkge1xuICAgICAgICBpZiAoY29uZmlncy5oYXNTZW1hbnRpY0NvbnRleHQpIHtcbiAgICAgICAgICBjb25zdCBkdXAgPSBuZXcgQVROQ29uZmlnU2V0KCk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25maWdzLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYyA9IGNvbmZpZ3MuaXRlbXNbaV07XG4gICAgICAgICAgICBjID0gbmV3IEFUTkNvbmZpZyh7c2VtYW50aWNDb250ZXh0OiBTZW1hbnRpY0NvbnRleHQuTk9ORX0sIGMpO1xuICAgICAgICAgICAgZHVwLmFkZChjKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uZmlncyA9IGR1cDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgYWx0c2V0cyA9IFByZWRpY3Rpb25Nb2RlLmdldENvbmZsaWN0aW5nQWx0U3Vic2V0cyhjb25maWdzKTtcbiAgICAgIHJldHVybiBQcmVkaWN0aW9uTW9kZS5oYXNDb25mbGljdGluZ0FsdFNldChhbHRzZXRzKSAmJiAhUHJlZGljdGlvbk1vZGUuaGFzU3RhdGVBc3NvY2lhdGVkV2l0aE9uZUFsdChjb25maWdzKTtcbiAgICB9LFxuICAgIGhhc0NvbmZpZ0luUnVsZVN0b3BTdGF0ZTogZnVuY3Rpb24oY29uZmlncykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25maWdzLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBjb25maWdzLml0ZW1zW2ldO1xuICAgICAgICBpZiAoYy5zdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWxsQ29uZmlnc0luUnVsZVN0b3BTdGF0ZXM6IGZ1bmN0aW9uKGNvbmZpZ3MpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29uZmlncy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gY29uZmlncy5pdGVtc1tpXTtcbiAgICAgICAgaWYgKCEoYy5zdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHJlc29sdmVzVG9KdXN0T25lVmlhYmxlQWx0OiBmdW5jdGlvbihhbHRzZXRzKSB7XG4gICAgICByZXR1cm4gUHJlZGljdGlvbk1vZGUuZ2V0U2luZ2xlVmlhYmxlQWx0KGFsdHNldHMpO1xuICAgIH0sXG4gICAgYWxsU3Vic2V0c0NvbmZsaWN0OiBmdW5jdGlvbihhbHRzZXRzKSB7XG4gICAgICByZXR1cm4gIVByZWRpY3Rpb25Nb2RlLmhhc05vbkNvbmZsaWN0aW5nQWx0U2V0KGFsdHNldHMpO1xuICAgIH0sXG4gICAgaGFzTm9uQ29uZmxpY3RpbmdBbHRTZXQ6IGZ1bmN0aW9uKGFsdHNldHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWx0c2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhbHRzID0gYWx0c2V0c1tpXTtcbiAgICAgICAgaWYgKGFsdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGhhc0NvbmZsaWN0aW5nQWx0U2V0OiBmdW5jdGlvbihhbHRzZXRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsdHNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYWx0cyA9IGFsdHNldHNbaV07XG4gICAgICAgIGlmIChhbHRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWxsU3Vic2V0c0VxdWFsOiBmdW5jdGlvbihhbHRzZXRzKSB7XG4gICAgICBsZXQgZmlyc3QgPSBudWxsO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbHRzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFsdHMgPSBhbHRzZXRzW2ldO1xuICAgICAgICBpZiAoZmlyc3QgPT09IG51bGwpIHtcbiAgICAgICAgICBmaXJzdCA9IGFsdHM7XG4gICAgICAgIH0gZWxzZSBpZiAoYWx0cyAhPT0gZmlyc3QpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZ2V0VW5pcXVlQWx0OiBmdW5jdGlvbihhbHRzZXRzKSB7XG4gICAgICBjb25zdCBhbGwgPSBQcmVkaWN0aW9uTW9kZS5nZXRBbHRzKGFsdHNldHMpO1xuICAgICAgaWYgKGFsbC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGFsbC5taW5WYWx1ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEFUTjIuSU5WQUxJRF9BTFRfTlVNQkVSO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0QWx0czogZnVuY3Rpb24oYWx0c2V0cykge1xuICAgICAgY29uc3QgYWxsID0gbmV3IEJpdFNldCgpO1xuICAgICAgYWx0c2V0cy5tYXAoZnVuY3Rpb24oYWx0cykge1xuICAgICAgICBhbGwub3IoYWx0cyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhbGw7XG4gICAgfSxcbiAgICBnZXRDb25mbGljdGluZ0FsdFN1YnNldHM6IGZ1bmN0aW9uKGNvbmZpZ3MpIHtcbiAgICAgIGNvbnN0IGNvbmZpZ1RvQWx0cyA9IG5ldyBNYXAyKCk7XG4gICAgICBjb25maWdUb0FsdHMuaGFzaEZ1bmN0aW9uID0gZnVuY3Rpb24oY2ZnKSB7XG4gICAgICAgIGhhc2hTdHVmZihjZmcuc3RhdGUuc3RhdGVOdW1iZXIsIGNmZy5jb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBjb25maWdUb0FsdHMuZXF1YWxzRnVuY3Rpb24gPSBmdW5jdGlvbihjMSwgYzIpIHtcbiAgICAgICAgcmV0dXJuIGMxLnN0YXRlLnN0YXRlTnVtYmVyID09PSBjMi5zdGF0ZS5zdGF0ZU51bWJlciAmJiBjMS5jb250ZXh0LmVxdWFscyhjMi5jb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBjb25maWdzLml0ZW1zLm1hcChmdW5jdGlvbihjZmcpIHtcbiAgICAgICAgbGV0IGFsdHMgPSBjb25maWdUb0FsdHMuZ2V0KGNmZyk7XG4gICAgICAgIGlmIChhbHRzID09PSBudWxsKSB7XG4gICAgICAgICAgYWx0cyA9IG5ldyBCaXRTZXQoKTtcbiAgICAgICAgICBjb25maWdUb0FsdHMucHV0KGNmZywgYWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgYWx0cy5hZGQoY2ZnLmFsdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb25maWdUb0FsdHMuZ2V0VmFsdWVzKCk7XG4gICAgfSxcbiAgICBnZXRTdGF0ZVRvQWx0TWFwOiBmdW5jdGlvbihjb25maWdzKSB7XG4gICAgICBjb25zdCBtID0gbmV3IEFsdERpY3QoKTtcbiAgICAgIGNvbmZpZ3MuaXRlbXMubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgbGV0IGFsdHMgPSBtLmdldChjLnN0YXRlKTtcbiAgICAgICAgaWYgKGFsdHMgPT09IG51bGwpIHtcbiAgICAgICAgICBhbHRzID0gbmV3IEJpdFNldCgpO1xuICAgICAgICAgIG0ucHV0KGMuc3RhdGUsIGFsdHMpO1xuICAgICAgICB9XG4gICAgICAgIGFsdHMuYWRkKGMuYWx0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG07XG4gICAgfSxcbiAgICBoYXNTdGF0ZUFzc29jaWF0ZWRXaXRoT25lQWx0OiBmdW5jdGlvbihjb25maWdzKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBQcmVkaWN0aW9uTW9kZS5nZXRTdGF0ZVRvQWx0TWFwKGNvbmZpZ3MpLnZhbHVlcygpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHZhbHVlc1tpXS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgZ2V0U2luZ2xlVmlhYmxlQWx0OiBmdW5jdGlvbihhbHRzZXRzKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWx0c2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhbHRzID0gYWx0c2V0c1tpXTtcbiAgICAgICAgY29uc3QgbWluQWx0ID0gYWx0cy5taW5WYWx1ZSgpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0ID0gbWluQWx0O1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCAhPT0gbWluQWx0KSB7XG4gICAgICAgICAgcmV0dXJuIEFUTjIuSU5WQUxJRF9BTFRfTlVNQkVSO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcbiAgbW9kdWxlMi5leHBvcnRzID0gUHJlZGljdGlvbk1vZGU7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNC9zcmMvYW50bHI0L1BhcnNlclJ1bGVDb250ZXh0LmpzXG52YXIgcmVxdWlyZV9QYXJzZXJSdWxlQ29udGV4dDIgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUyKSA9PiB7XG4gIHZhciBSdWxlQ29udGV4dCA9IHJlcXVpcmVfUnVsZUNvbnRleHQyKCk7XG4gIHZhciBUcmVlID0gcmVxdWlyZV9UcmVlKCk7XG4gIHZhciBJTlZBTElEX0lOVEVSVkFMID0gVHJlZS5JTlZBTElEX0lOVEVSVkFMO1xuICB2YXIgVGVybWluYWxOb2RlID0gVHJlZS5UZXJtaW5hbE5vZGU7XG4gIHZhciBUZXJtaW5hbE5vZGVJbXBsID0gVHJlZS5UZXJtaW5hbE5vZGVJbXBsO1xuICB2YXIgRXJyb3JOb2RlSW1wbCA9IFRyZWUuRXJyb3JOb2RlSW1wbDtcbiAgdmFyIEludGVydmFsID0gcmVxdWlyZV9JbnRlcnZhbFNldDIoKS5JbnRlcnZhbDtcbiAgdmFyIFBhcnNlclJ1bGVDb250ZXh0MiA9IGNsYXNzIGV4dGVuZHMgUnVsZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZU51bWJlcikge1xuICAgICAgcGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gICAgICBpbnZva2luZ1N0YXRlTnVtYmVyID0gaW52b2tpbmdTdGF0ZU51bWJlciB8fCBudWxsO1xuICAgICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlTnVtYmVyKTtcbiAgICAgIHRoaXMucnVsZUluZGV4ID0gLTE7XG4gICAgICB0aGlzLmNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHRoaXMuc3RhcnQgPSBudWxsO1xuICAgICAgdGhpcy5zdG9wID0gbnVsbDtcbiAgICAgIHRoaXMuZXhjZXB0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgY29weUZyb20oY3R4KSB7XG4gICAgICB0aGlzLnBhcmVudEN0eCA9IGN0eC5wYXJlbnRDdHg7XG4gICAgICB0aGlzLmludm9raW5nU3RhdGUgPSBjdHguaW52b2tpbmdTdGF0ZTtcbiAgICAgIHRoaXMuY2hpbGRyZW4gPSBudWxsO1xuICAgICAgdGhpcy5zdGFydCA9IGN0eC5zdGFydDtcbiAgICAgIHRoaXMuc3RvcCA9IGN0eC5zdG9wO1xuICAgICAgaWYgKGN0eC5jaGlsZHJlbikge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIGN0eC5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBFcnJvck5vZGVJbXBsKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgY2hpbGQucGFyZW50Q3R4ID0gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICB9XG4gICAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICB9XG4gICAgYWRkQ2hpbGQoY2hpbGQpIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIHJlbW92ZUxhc3RDaGlsZCgpIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucG9wKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGFkZFRva2VuTm9kZSh0b2tlbikge1xuICAgICAgY29uc3Qgbm9kZSA9IG5ldyBUZXJtaW5hbE5vZGVJbXBsKHRva2VuKTtcbiAgICAgIHRoaXMuYWRkQ2hpbGQobm9kZSk7XG4gICAgICBub2RlLnBhcmVudEN0eCA9IHRoaXM7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgYWRkRXJyb3JOb2RlKGJhZFRva2VuKSB7XG4gICAgICBjb25zdCBub2RlID0gbmV3IEVycm9yTm9kZUltcGwoYmFkVG9rZW4pO1xuICAgICAgdGhpcy5hZGRDaGlsZChub2RlKTtcbiAgICAgIG5vZGUucGFyZW50Q3R4ID0gdGhpcztcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBnZXRDaGlsZChpLCB0eXBlKSB7XG4gICAgICB0eXBlID0gdHlwZSB8fCBudWxsO1xuICAgICAgaWYgKHRoaXMuY2hpbGRyZW4gPT09IG51bGwgfHwgaSA8IDAgfHwgaSA+PSB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2pdO1xuICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIHR5cGUpIHtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGdldFRva2VuKHR0eXBlLCBpKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbiA9PT0gbnVsbCB8fCBpIDwgMCB8fCBpID49IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltqXTtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgaWYgKGNoaWxkLnN5bWJvbC50eXBlID09PSB0dHlwZSkge1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldFRva2Vucyh0dHlwZSkge1xuICAgICAgaWYgKHRoaXMuY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdG9rZW5zMiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bal07XG4gICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQuc3ltYm9sLnR5cGUgPT09IHR0eXBlKSB7XG4gICAgICAgICAgICAgIHRva2VuczIucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnMyO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXRUeXBlZFJ1bGVDb250ZXh0KGN0eFR5cGUsIGkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldENoaWxkKGksIGN0eFR5cGUpO1xuICAgIH1cbiAgICBnZXRUeXBlZFJ1bGVDb250ZXh0cyhjdHhUeXBlKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb250ZXh0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bal07XG4gICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgY3R4VHlwZSkge1xuICAgICAgICAgICAgY29udGV4dHMucHVzaChjaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZXh0cztcbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2hpbGRDb3VudCgpIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXRTb3VyY2VJbnRlcnZhbCgpIHtcbiAgICAgIGlmICh0aGlzLnN0YXJ0ID09PSBudWxsIHx8IHRoaXMuc3RvcCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gSU5WQUxJRF9JTlRFUlZBTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWwodGhpcy5zdGFydC50b2tlbkluZGV4LCB0aGlzLnN0b3AudG9rZW5JbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBSdWxlQ29udGV4dC5FTVBUWSA9IG5ldyBQYXJzZXJSdWxlQ29udGV4dDIoKTtcbiAgbW9kdWxlMi5leHBvcnRzID0gUGFyc2VyUnVsZUNvbnRleHQyO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjQvc3JjL2FudGxyNC9hdG4vUGFyc2VyQVROU2ltdWxhdG9yLmpzXG52YXIgcmVxdWlyZV9QYXJzZXJBVE5TaW11bGF0b3IyID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlMikgPT4ge1xuICB2YXIgVXRpbHMzID0gcmVxdWlyZV9VdGlsczIoKTtcbiAgdmFyIHtTZXQ6IFNldDIsIEJpdFNldCwgRG91YmxlRGljdH0gPSBVdGlsczM7XG4gIHZhciBBVE4yID0gcmVxdWlyZV9BVE4yKCk7XG4gIHZhciB7QVROU3RhdGUsIFJ1bGVTdG9wU3RhdGV9ID0gcmVxdWlyZV9BVE5TdGF0ZTIoKTtcbiAgdmFyIHtBVE5Db25maWd9ID0gcmVxdWlyZV9BVE5Db25maWcyKCk7XG4gIHZhciB7QVROQ29uZmlnU2V0fSA9IHJlcXVpcmVfQVROQ29uZmlnU2V0MigpO1xuICB2YXIge1Rva2VuOiBUb2tlbjJ9ID0gcmVxdWlyZV9Ub2tlbjIoKTtcbiAgdmFyIHtERkFTdGF0ZSwgUHJlZFByZWRpY3Rpb259ID0gcmVxdWlyZV9ERkFTdGF0ZTIoKTtcbiAgdmFyIEFUTlNpbXVsYXRvciA9IHJlcXVpcmVfQVROU2ltdWxhdG9yMigpO1xuICB2YXIgUHJlZGljdGlvbk1vZGUgPSByZXF1aXJlX1ByZWRpY3Rpb25Nb2RlMigpO1xuICB2YXIgUnVsZUNvbnRleHQgPSByZXF1aXJlX1J1bGVDb250ZXh0MigpO1xuICB2YXIgUGFyc2VyUnVsZUNvbnRleHQyID0gcmVxdWlyZV9QYXJzZXJSdWxlQ29udGV4dDIoKTtcbiAgdmFyIHtTZW1hbnRpY0NvbnRleHR9ID0gcmVxdWlyZV9TZW1hbnRpY0NvbnRleHQyKCk7XG4gIHZhciB7UHJlZGljdGlvbkNvbnRleHR9ID0gcmVxdWlyZV9QcmVkaWN0aW9uQ29udGV4dDIoKTtcbiAgdmFyIHtJbnRlcnZhbH0gPSByZXF1aXJlX0ludGVydmFsU2V0MigpO1xuICB2YXIge1RyYW5zaXRpb24sIFNldFRyYW5zaXRpb24sIE5vdFNldFRyYW5zaXRpb24sIFJ1bGVUcmFuc2l0aW9uLCBBY3Rpb25UcmFuc2l0aW9ufSA9IHJlcXVpcmVfVHJhbnNpdGlvbjIoKTtcbiAgdmFyIHtOb1ZpYWJsZUFsdEV4Y2VwdGlvbjogTm9WaWFibGVBbHRFeGNlcHRpb24yfSA9IHJlcXVpcmVfRXJyb3JzKCk7XG4gIHZhciB7U2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQsIHByZWRpY3Rpb25Db250ZXh0RnJvbVJ1bGVDb250ZXh0fSA9IHJlcXVpcmVfUHJlZGljdGlvbkNvbnRleHQyKCk7XG4gIHZhciBQYXJzZXJBVE5TaW11bGF0b3IyID0gY2xhc3MgZXh0ZW5kcyBBVE5TaW11bGF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgYXRuLCBkZWNpc2lvblRvREZBLCBzaGFyZWRDb250ZXh0Q2FjaGUpIHtcbiAgICAgIHN1cGVyKGF0biwgc2hhcmVkQ29udGV4dENhY2hlKTtcbiAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgdGhpcy5kZWNpc2lvblRvREZBID0gZGVjaXNpb25Ub0RGQTtcbiAgICAgIHRoaXMucHJlZGljdGlvbk1vZGUgPSBQcmVkaWN0aW9uTW9kZS5MTDtcbiAgICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3N0YXJ0SW5kZXggPSAwO1xuICAgICAgdGhpcy5fb3V0ZXJDb250ZXh0ID0gbnVsbDtcbiAgICAgIHRoaXMuX2RmYSA9IG51bGw7XG4gICAgICB0aGlzLm1lcmdlQ2FjaGUgPSBudWxsO1xuICAgICAgdGhpcy5kZWJ1ZyA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWJ1Z19jbG9zdXJlID0gZmFsc2U7XG4gICAgICB0aGlzLmRlYnVnX2FkZCA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWJ1Z19saXN0X2F0bl9kZWNpc2lvbnMgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGZhX2RlYnVnID0gZmFsc2U7XG4gICAgICB0aGlzLnJldHJ5X2RlYnVnID0gZmFsc2U7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgIH1cbiAgICBhZGFwdGl2ZVByZWRpY3QoaW5wdXQsIGRlY2lzaW9uLCBvdXRlckNvbnRleHQpIHtcbiAgICAgIGlmICh0aGlzLmRlYnVnIHx8IHRoaXMuZGVidWdfbGlzdF9hdG5fZGVjaXNpb25zKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiYWRhcHRpdmVQcmVkaWN0IGRlY2lzaW9uIFwiICsgZGVjaXNpb24gKyBcIiBleGVjIExBKDEpPT1cIiArIHRoaXMuZ2V0TG9va2FoZWFkTmFtZShpbnB1dCkgKyBcIiBsaW5lIFwiICsgaW5wdXQuTFQoMSkubGluZSArIFwiOlwiICsgaW5wdXQuTFQoMSkuY29sdW1uKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgICB0aGlzLl9zdGFydEluZGV4ID0gaW5wdXQuaW5kZXg7XG4gICAgICB0aGlzLl9vdXRlckNvbnRleHQgPSBvdXRlckNvbnRleHQ7XG4gICAgICBjb25zdCBkZmEgPSB0aGlzLmRlY2lzaW9uVG9ERkFbZGVjaXNpb25dO1xuICAgICAgdGhpcy5fZGZhID0gZGZhO1xuICAgICAgY29uc3QgbSA9IGlucHV0Lm1hcmsoKTtcbiAgICAgIGNvbnN0IGluZGV4ID0gaW5wdXQuaW5kZXg7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgczA7XG4gICAgICAgIGlmIChkZmEucHJlY2VkZW5jZURmYSkge1xuICAgICAgICAgIHMwID0gZGZhLmdldFByZWNlZGVuY2VTdGFydFN0YXRlKHRoaXMucGFyc2VyLmdldFByZWNlZGVuY2UoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczAgPSBkZmEuczA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMwID09PSBudWxsKSB7XG4gICAgICAgICAgaWYgKG91dGVyQ29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgb3V0ZXJDb250ZXh0ID0gUnVsZUNvbnRleHQuRU1QVFk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmRlYnVnIHx8IHRoaXMuZGVidWdfbGlzdF9hdG5fZGVjaXNpb25zKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInByZWRpY3RBVE4gZGVjaXNpb24gXCIgKyBkZmEuZGVjaXNpb24gKyBcIiBleGVjIExBKDEpPT1cIiArIHRoaXMuZ2V0TG9va2FoZWFkTmFtZShpbnB1dCkgKyBcIiwgb3V0ZXJDb250ZXh0PVwiICsgb3V0ZXJDb250ZXh0LnRvU3RyaW5nKHRoaXMucGFyc2VyLnJ1bGVOYW1lcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmdWxsQ3R4ID0gZmFsc2U7XG4gICAgICAgICAgbGV0IHMwX2Nsb3N1cmUgPSB0aGlzLmNvbXB1dGVTdGFydFN0YXRlKGRmYS5hdG5TdGFydFN0YXRlLCBSdWxlQ29udGV4dC5FTVBUWSwgZnVsbEN0eCk7XG4gICAgICAgICAgaWYgKGRmYS5wcmVjZWRlbmNlRGZhKSB7XG4gICAgICAgICAgICBkZmEuczAuY29uZmlncyA9IHMwX2Nsb3N1cmU7XG4gICAgICAgICAgICBzMF9jbG9zdXJlID0gdGhpcy5hcHBseVByZWNlZGVuY2VGaWx0ZXIoczBfY2xvc3VyZSk7XG4gICAgICAgICAgICBzMCA9IHRoaXMuYWRkREZBU3RhdGUoZGZhLCBuZXcgREZBU3RhdGUobnVsbCwgczBfY2xvc3VyZSkpO1xuICAgICAgICAgICAgZGZhLnNldFByZWNlZGVuY2VTdGFydFN0YXRlKHRoaXMucGFyc2VyLmdldFByZWNlZGVuY2UoKSwgczApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMCA9IHRoaXMuYWRkREZBU3RhdGUoZGZhLCBuZXcgREZBU3RhdGUobnVsbCwgczBfY2xvc3VyZSkpO1xuICAgICAgICAgICAgZGZhLnMwID0gczA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsdCA9IHRoaXMuZXhlY0FUTihkZmEsIHMwLCBpbnB1dCwgaW5kZXgsIG91dGVyQ29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJERkEgYWZ0ZXIgcHJlZGljdEFUTjogXCIgKyBkZmEudG9TdHJpbmcodGhpcy5wYXJzZXIubGl0ZXJhbE5hbWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsdDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2RmYSA9IG51bGw7XG4gICAgICAgIHRoaXMubWVyZ2VDYWNoZSA9IG51bGw7XG4gICAgICAgIGlucHV0LnNlZWsoaW5kZXgpO1xuICAgICAgICBpbnB1dC5yZWxlYXNlKG0pO1xuICAgICAgfVxuICAgIH1cbiAgICBleGVjQVROKGRmYSwgczAsIGlucHV0LCBzdGFydEluZGV4LCBvdXRlckNvbnRleHQpIHtcbiAgICAgIGlmICh0aGlzLmRlYnVnIHx8IHRoaXMuZGVidWdfbGlzdF9hdG5fZGVjaXNpb25zKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiZXhlY0FUTiBkZWNpc2lvbiBcIiArIGRmYS5kZWNpc2lvbiArIFwiIGV4ZWMgTEEoMSk9PVwiICsgdGhpcy5nZXRMb29rYWhlYWROYW1lKGlucHV0KSArIFwiIGxpbmUgXCIgKyBpbnB1dC5MVCgxKS5saW5lICsgXCI6XCIgKyBpbnB1dC5MVCgxKS5jb2x1bW4pO1xuICAgICAgfVxuICAgICAgbGV0IGFsdDtcbiAgICAgIGxldCBwcmV2aW91c0QgPSBzMDtcbiAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiczAgPSBcIiArIHMwKTtcbiAgICAgIH1cbiAgICAgIGxldCB0ID0gaW5wdXQuTEEoMSk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgRCA9IHRoaXMuZ2V0RXhpc3RpbmdUYXJnZXRTdGF0ZShwcmV2aW91c0QsIHQpO1xuICAgICAgICBpZiAoRCA9PT0gbnVsbCkge1xuICAgICAgICAgIEQgPSB0aGlzLmNvbXB1dGVUYXJnZXRTdGF0ZShkZmEsIHByZXZpb3VzRCwgdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEQgPT09IEFUTlNpbXVsYXRvci5FUlJPUikge1xuICAgICAgICAgIGNvbnN0IGUgPSB0aGlzLm5vVmlhYmxlQWx0KGlucHV0LCBvdXRlckNvbnRleHQsIHByZXZpb3VzRC5jb25maWdzLCBzdGFydEluZGV4KTtcbiAgICAgICAgICBpbnB1dC5zZWVrKHN0YXJ0SW5kZXgpO1xuICAgICAgICAgIGFsdCA9IHRoaXMuZ2V0U3luVmFsaWRPclNlbUludmFsaWRBbHRUaGF0RmluaXNoZWREZWNpc2lvbkVudHJ5UnVsZShwcmV2aW91c0QuY29uZmlncywgb3V0ZXJDb250ZXh0KTtcbiAgICAgICAgICBpZiAoYWx0ICE9PSBBVE4yLklOVkFMSURfQUxUX05VTUJFUikge1xuICAgICAgICAgICAgcmV0dXJuIGFsdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEQucmVxdWlyZXNGdWxsQ29udGV4dCAmJiB0aGlzLnByZWRpY3Rpb25Nb2RlICE9PSBQcmVkaWN0aW9uTW9kZS5TTEwpIHtcbiAgICAgICAgICBsZXQgY29uZmxpY3RpbmdBbHRzID0gbnVsbDtcbiAgICAgICAgICBpZiAoRC5wcmVkaWNhdGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRGQSBzdGF0ZSBoYXMgcHJlZHMgaW4gREZBIHNpbSBMTCBmYWlsb3ZlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbmZsaWN0SW5kZXggPSBpbnB1dC5pbmRleDtcbiAgICAgICAgICAgIGlmIChjb25mbGljdEluZGV4ICE9PSBzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgIGlucHV0LnNlZWsoc3RhcnRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25mbGljdGluZ0FsdHMgPSB0aGlzLmV2YWxTZW1hbnRpY0NvbnRleHQoRC5wcmVkaWNhdGVzLCBvdXRlckNvbnRleHQsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGNvbmZsaWN0aW5nQWx0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZ1bGwgTEwgYXZvaWRlZFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY29uZmxpY3RpbmdBbHRzLm1pblZhbHVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmxpY3RJbmRleCAhPT0gc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgICBpbnB1dC5zZWVrKGNvbmZsaWN0SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5kZmFfZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY3R4IHNlbnNpdGl2ZSBzdGF0ZSBcIiArIG91dGVyQ29udGV4dCArIFwiIGluIFwiICsgRCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZ1bGxDdHggPSB0cnVlO1xuICAgICAgICAgIGNvbnN0IHMwX2Nsb3N1cmUgPSB0aGlzLmNvbXB1dGVTdGFydFN0YXRlKGRmYS5hdG5TdGFydFN0YXRlLCBvdXRlckNvbnRleHQsIGZ1bGxDdHgpO1xuICAgICAgICAgIHRoaXMucmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0KGRmYSwgY29uZmxpY3RpbmdBbHRzLCBELmNvbmZpZ3MsIHN0YXJ0SW5kZXgsIGlucHV0LmluZGV4KTtcbiAgICAgICAgICBhbHQgPSB0aGlzLmV4ZWNBVE5XaXRoRnVsbENvbnRleHQoZGZhLCBELCBzMF9jbG9zdXJlLCBpbnB1dCwgc3RhcnRJbmRleCwgb3V0ZXJDb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gYWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChELmlzQWNjZXB0U3RhdGUpIHtcbiAgICAgICAgICBpZiAoRC5wcmVkaWNhdGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gRC5wcmVkaWN0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzdG9wSW5kZXggPSBpbnB1dC5pbmRleDtcbiAgICAgICAgICBpbnB1dC5zZWVrKHN0YXJ0SW5kZXgpO1xuICAgICAgICAgIGNvbnN0IGFsdHMgPSB0aGlzLmV2YWxTZW1hbnRpY0NvbnRleHQoRC5wcmVkaWNhdGVzLCBvdXRlckNvbnRleHQsIHRydWUpO1xuICAgICAgICAgIGlmIChhbHRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5ub1ZpYWJsZUFsdChpbnB1dCwgb3V0ZXJDb250ZXh0LCBELmNvbmZpZ3MsIHN0YXJ0SW5kZXgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYWx0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBhbHRzLm1pblZhbHVlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0QW1iaWd1aXR5KGRmYSwgRCwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBmYWxzZSwgYWx0cywgRC5jb25maWdzKTtcbiAgICAgICAgICAgIHJldHVybiBhbHRzLm1pblZhbHVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzRCA9IEQ7XG4gICAgICAgIGlmICh0ICE9PSBUb2tlbjIuRU9GKSB7XG4gICAgICAgICAgaW5wdXQuY29uc3VtZSgpO1xuICAgICAgICAgIHQgPSBpbnB1dC5MQSgxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBnZXRFeGlzdGluZ1RhcmdldFN0YXRlKHByZXZpb3VzRCwgdCkge1xuICAgICAgY29uc3QgZWRnZXMgPSBwcmV2aW91c0QuZWRnZXM7XG4gICAgICBpZiAoZWRnZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZWRnZXNbdCArIDFdIHx8IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbXB1dGVUYXJnZXRTdGF0ZShkZmEsIHByZXZpb3VzRCwgdCkge1xuICAgICAgY29uc3QgcmVhY2ggPSB0aGlzLmNvbXB1dGVSZWFjaFNldChwcmV2aW91c0QuY29uZmlncywgdCwgZmFsc2UpO1xuICAgICAgaWYgKHJlYWNoID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuYWRkREZBRWRnZShkZmEsIHByZXZpb3VzRCwgdCwgQVROU2ltdWxhdG9yLkVSUk9SKTtcbiAgICAgICAgcmV0dXJuIEFUTlNpbXVsYXRvci5FUlJPUjtcbiAgICAgIH1cbiAgICAgIGxldCBEID0gbmV3IERGQVN0YXRlKG51bGwsIHJlYWNoKTtcbiAgICAgIGNvbnN0IHByZWRpY3RlZEFsdCA9IHRoaXMuZ2V0VW5pcXVlQWx0KHJlYWNoKTtcbiAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgIGNvbnN0IGFsdFN1YlNldHMgPSBQcmVkaWN0aW9uTW9kZS5nZXRDb25mbGljdGluZ0FsdFN1YnNldHMocmVhY2gpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlNMTCBhbHRTdWJTZXRzPVwiICsgVXRpbHMzLmFycmF5VG9TdHJpbmcoYWx0U3ViU2V0cykgKyBcIiwgcHJldmlvdXM9XCIgKyBwcmV2aW91c0QuY29uZmlncyArIFwiLCBjb25maWdzPVwiICsgcmVhY2ggKyBcIiwgcHJlZGljdD1cIiArIHByZWRpY3RlZEFsdCArIFwiLCBhbGxTdWJzZXRzQ29uZmxpY3Q9XCIgKyBQcmVkaWN0aW9uTW9kZS5hbGxTdWJzZXRzQ29uZmxpY3QoYWx0U3ViU2V0cykgKyBcIiwgY29uZmxpY3RpbmdBbHRzPVwiICsgdGhpcy5nZXRDb25mbGljdGluZ0FsdHMocmVhY2gpKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVkaWN0ZWRBbHQgIT09IEFUTjIuSU5WQUxJRF9BTFRfTlVNQkVSKSB7XG4gICAgICAgIEQuaXNBY2NlcHRTdGF0ZSA9IHRydWU7XG4gICAgICAgIEQuY29uZmlncy51bmlxdWVBbHQgPSBwcmVkaWN0ZWRBbHQ7XG4gICAgICAgIEQucHJlZGljdGlvbiA9IHByZWRpY3RlZEFsdDtcbiAgICAgIH0gZWxzZSBpZiAoUHJlZGljdGlvbk1vZGUuaGFzU0xMQ29uZmxpY3RUZXJtaW5hdGluZ1ByZWRpY3Rpb24odGhpcy5wcmVkaWN0aW9uTW9kZSwgcmVhY2gpKSB7XG4gICAgICAgIEQuY29uZmlncy5jb25mbGljdGluZ0FsdHMgPSB0aGlzLmdldENvbmZsaWN0aW5nQWx0cyhyZWFjaCk7XG4gICAgICAgIEQucmVxdWlyZXNGdWxsQ29udGV4dCA9IHRydWU7XG4gICAgICAgIEQuaXNBY2NlcHRTdGF0ZSA9IHRydWU7XG4gICAgICAgIEQucHJlZGljdGlvbiA9IEQuY29uZmlncy5jb25mbGljdGluZ0FsdHMubWluVmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChELmlzQWNjZXB0U3RhdGUgJiYgRC5jb25maWdzLmhhc1NlbWFudGljQ29udGV4dCkge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZURGQVN0YXRlKEQsIHRoaXMuYXRuLmdldERlY2lzaW9uU3RhdGUoZGZhLmRlY2lzaW9uKSk7XG4gICAgICAgIGlmIChELnByZWRpY2F0ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICBELnByZWRpY3Rpb24gPSBBVE4yLklOVkFMSURfQUxUX05VTUJFUjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgRCA9IHRoaXMuYWRkREZBRWRnZShkZmEsIHByZXZpb3VzRCwgdCwgRCk7XG4gICAgICByZXR1cm4gRDtcbiAgICB9XG4gICAgcHJlZGljYXRlREZBU3RhdGUoZGZhU3RhdGUsIGRlY2lzaW9uU3RhdGUpIHtcbiAgICAgIGNvbnN0IG5hbHRzID0gZGVjaXNpb25TdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGg7XG4gICAgICBjb25zdCBhbHRzVG9Db2xsZWN0UHJlZHNGcm9tID0gdGhpcy5nZXRDb25mbGljdGluZ0FsdHNPclVuaXF1ZUFsdChkZmFTdGF0ZS5jb25maWdzKTtcbiAgICAgIGNvbnN0IGFsdFRvUHJlZCA9IHRoaXMuZ2V0UHJlZHNGb3JBbWJpZ0FsdHMoYWx0c1RvQ29sbGVjdFByZWRzRnJvbSwgZGZhU3RhdGUuY29uZmlncywgbmFsdHMpO1xuICAgICAgaWYgKGFsdFRvUHJlZCAhPT0gbnVsbCkge1xuICAgICAgICBkZmFTdGF0ZS5wcmVkaWNhdGVzID0gdGhpcy5nZXRQcmVkaWNhdGVQcmVkaWN0aW9ucyhhbHRzVG9Db2xsZWN0UHJlZHNGcm9tLCBhbHRUb1ByZWQpO1xuICAgICAgICBkZmFTdGF0ZS5wcmVkaWN0aW9uID0gQVROMi5JTlZBTElEX0FMVF9OVU1CRVI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZmFTdGF0ZS5wcmVkaWN0aW9uID0gYWx0c1RvQ29sbGVjdFByZWRzRnJvbS5taW5WYWx1ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBleGVjQVROV2l0aEZ1bGxDb250ZXh0KGRmYSwgRCwgczAsIGlucHV0LCBzdGFydEluZGV4LCBvdXRlckNvbnRleHQpIHtcbiAgICAgIGlmICh0aGlzLmRlYnVnIHx8IHRoaXMuZGVidWdfbGlzdF9hdG5fZGVjaXNpb25zKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiZXhlY0FUTldpdGhGdWxsQ29udGV4dCBcIiArIHMwKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZ1bGxDdHggPSB0cnVlO1xuICAgICAgbGV0IGZvdW5kRXhhY3RBbWJpZyA9IGZhbHNlO1xuICAgICAgbGV0IHJlYWNoO1xuICAgICAgbGV0IHByZXZpb3VzID0gczA7XG4gICAgICBpbnB1dC5zZWVrKHN0YXJ0SW5kZXgpO1xuICAgICAgbGV0IHQgPSBpbnB1dC5MQSgxKTtcbiAgICAgIGxldCBwcmVkaWN0ZWRBbHQgPSAtMTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHJlYWNoID0gdGhpcy5jb21wdXRlUmVhY2hTZXQocHJldmlvdXMsIHQsIGZ1bGxDdHgpO1xuICAgICAgICBpZiAocmVhY2ggPT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBlID0gdGhpcy5ub1ZpYWJsZUFsdChpbnB1dCwgb3V0ZXJDb250ZXh0LCBwcmV2aW91cywgc3RhcnRJbmRleCk7XG4gICAgICAgICAgaW5wdXQuc2VlayhzdGFydEluZGV4KTtcbiAgICAgICAgICBjb25zdCBhbHQgPSB0aGlzLmdldFN5blZhbGlkT3JTZW1JbnZhbGlkQWx0VGhhdEZpbmlzaGVkRGVjaXNpb25FbnRyeVJ1bGUocHJldmlvdXMsIG91dGVyQ29udGV4dCk7XG4gICAgICAgICAgaWYgKGFsdCAhPT0gQVROMi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcbiAgICAgICAgICAgIHJldHVybiBhbHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsdFN1YlNldHMgPSBQcmVkaWN0aW9uTW9kZS5nZXRDb25mbGljdGluZ0FsdFN1YnNldHMocmVhY2gpO1xuICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiTEwgYWx0U3ViU2V0cz1cIiArIGFsdFN1YlNldHMgKyBcIiwgcHJlZGljdD1cIiArIFByZWRpY3Rpb25Nb2RlLmdldFVuaXF1ZUFsdChhbHRTdWJTZXRzKSArIFwiLCByZXNvbHZlc1RvSnVzdE9uZVZpYWJsZUFsdD1cIiArIFByZWRpY3Rpb25Nb2RlLnJlc29sdmVzVG9KdXN0T25lVmlhYmxlQWx0KGFsdFN1YlNldHMpKTtcbiAgICAgICAgfVxuICAgICAgICByZWFjaC51bmlxdWVBbHQgPSB0aGlzLmdldFVuaXF1ZUFsdChyZWFjaCk7XG4gICAgICAgIGlmIChyZWFjaC51bmlxdWVBbHQgIT09IEFUTjIuSU5WQUxJRF9BTFRfTlVNQkVSKSB7XG4gICAgICAgICAgcHJlZGljdGVkQWx0ID0gcmVhY2gudW5pcXVlQWx0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJlZGljdGlvbk1vZGUgIT09IFByZWRpY3Rpb25Nb2RlLkxMX0VYQUNUX0FNQklHX0RFVEVDVElPTikge1xuICAgICAgICAgIHByZWRpY3RlZEFsdCA9IFByZWRpY3Rpb25Nb2RlLnJlc29sdmVzVG9KdXN0T25lVmlhYmxlQWx0KGFsdFN1YlNldHMpO1xuICAgICAgICAgIGlmIChwcmVkaWN0ZWRBbHQgIT09IEFUTjIuSU5WQUxJRF9BTFRfTlVNQkVSKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKFByZWRpY3Rpb25Nb2RlLmFsbFN1YnNldHNDb25mbGljdChhbHRTdWJTZXRzKSAmJiBQcmVkaWN0aW9uTW9kZS5hbGxTdWJzZXRzRXF1YWwoYWx0U3ViU2V0cykpIHtcbiAgICAgICAgICAgIGZvdW5kRXhhY3RBbWJpZyA9IHRydWU7XG4gICAgICAgICAgICBwcmVkaWN0ZWRBbHQgPSBQcmVkaWN0aW9uTW9kZS5nZXRTaW5nbGVWaWFibGVBbHQoYWx0U3ViU2V0cyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXMgPSByZWFjaDtcbiAgICAgICAgaWYgKHQgIT09IFRva2VuMi5FT0YpIHtcbiAgICAgICAgICBpbnB1dC5jb25zdW1lKCk7XG4gICAgICAgICAgdCA9IGlucHV0LkxBKDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVhY2gudW5pcXVlQWx0ICE9PSBBVE4yLklOVkFMSURfQUxUX05VTUJFUikge1xuICAgICAgICB0aGlzLnJlcG9ydENvbnRleHRTZW5zaXRpdml0eShkZmEsIHByZWRpY3RlZEFsdCwgcmVhY2gsIHN0YXJ0SW5kZXgsIGlucHV0LmluZGV4KTtcbiAgICAgICAgcmV0dXJuIHByZWRpY3RlZEFsdDtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVwb3J0QW1iaWd1aXR5KGRmYSwgRCwgc3RhcnRJbmRleCwgaW5wdXQuaW5kZXgsIGZvdW5kRXhhY3RBbWJpZywgbnVsbCwgcmVhY2gpO1xuICAgICAgcmV0dXJuIHByZWRpY3RlZEFsdDtcbiAgICB9XG4gICAgY29tcHV0ZVJlYWNoU2V0KGNsb3N1cmUsIHQsIGZ1bGxDdHgpIHtcbiAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiaW4gY29tcHV0ZVJlYWNoU2V0LCBzdGFydGluZyBjbG9zdXJlOiBcIiArIGNsb3N1cmUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWVyZ2VDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLm1lcmdlQ2FjaGUgPSBuZXcgRG91YmxlRGljdCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgaW50ZXJtZWRpYXRlID0gbmV3IEFUTkNvbmZpZ1NldChmdWxsQ3R4KTtcbiAgICAgIGxldCBza2lwcGVkU3RvcFN0YXRlcyA9IG51bGw7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsb3N1cmUuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IGNsb3N1cmUuaXRlbXNbaV07XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJ0ZXN0aW5nIFwiICsgdGhpcy5nZXRUb2tlbk5hbWUodCkgKyBcIiBhdCBcIiArIGMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkge1xuICAgICAgICAgIGlmIChmdWxsQ3R4IHx8IHQgPT09IFRva2VuMi5FT0YpIHtcbiAgICAgICAgICAgIGlmIChza2lwcGVkU3RvcFN0YXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBza2lwcGVkU3RvcFN0YXRlcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2tpcHBlZFN0b3BTdGF0ZXMucHVzaChjKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnX2FkZCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImFkZGVkIFwiICsgYyArIFwiIHRvIHNraXBwZWRTdG9wU3RhdGVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGMuc3RhdGUudHJhbnNpdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCB0cmFucyA9IGMuc3RhdGUudHJhbnNpdGlvbnNbal07XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRSZWFjaGFibGVUYXJnZXQodHJhbnMsIHQpO1xuICAgICAgICAgIGlmICh0YXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGNmZyA9IG5ldyBBVE5Db25maWcoe3N0YXRlOiB0YXJnZXR9LCBjKTtcbiAgICAgICAgICAgIGludGVybWVkaWF0ZS5hZGQoY2ZnLCB0aGlzLm1lcmdlQ2FjaGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWdfYWRkKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYWRkZWQgXCIgKyBjZmcgKyBcIiB0byBpbnRlcm1lZGlhdGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgcmVhY2ggPSBudWxsO1xuICAgICAgaWYgKHNraXBwZWRTdG9wU3RhdGVzID09PSBudWxsICYmIHQgIT09IFRva2VuMi5FT0YpIHtcbiAgICAgICAgaWYgKGludGVybWVkaWF0ZS5pdGVtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZWFjaCA9IGludGVybWVkaWF0ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmdldFVuaXF1ZUFsdChpbnRlcm1lZGlhdGUpICE9PSBBVE4yLklOVkFMSURfQUxUX05VTUJFUikge1xuICAgICAgICAgIHJlYWNoID0gaW50ZXJtZWRpYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVhY2ggPT09IG51bGwpIHtcbiAgICAgICAgcmVhY2ggPSBuZXcgQVROQ29uZmlnU2V0KGZ1bGxDdHgpO1xuICAgICAgICBjb25zdCBjbG9zdXJlQnVzeSA9IG5ldyBTZXQyKCk7XG4gICAgICAgIGNvbnN0IHRyZWF0RW9mQXNFcHNpbG9uID0gdCA9PT0gVG9rZW4yLkVPRjtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBpbnRlcm1lZGlhdGUuaXRlbXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICB0aGlzLmNsb3N1cmUoaW50ZXJtZWRpYXRlLml0ZW1zW2tdLCByZWFjaCwgY2xvc3VyZUJ1c3ksIGZhbHNlLCBmdWxsQ3R4LCB0cmVhdEVvZkFzRXBzaWxvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0ID09PSBUb2tlbjIuRU9GKSB7XG4gICAgICAgIHJlYWNoID0gdGhpcy5yZW1vdmVBbGxDb25maWdzTm90SW5SdWxlU3RvcFN0YXRlKHJlYWNoLCByZWFjaCA9PT0gaW50ZXJtZWRpYXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChza2lwcGVkU3RvcFN0YXRlcyAhPT0gbnVsbCAmJiAoIWZ1bGxDdHggfHwgIVByZWRpY3Rpb25Nb2RlLmhhc0NvbmZpZ0luUnVsZVN0b3BTdGF0ZShyZWFjaCkpKSB7XG4gICAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgc2tpcHBlZFN0b3BTdGF0ZXMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICByZWFjaC5hZGQoc2tpcHBlZFN0b3BTdGF0ZXNbbF0sIHRoaXMubWVyZ2VDYWNoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZWFjaC5pdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVhY2g7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUFsbENvbmZpZ3NOb3RJblJ1bGVTdG9wU3RhdGUoY29uZmlncywgbG9va1RvRW5kT2ZSdWxlKSB7XG4gICAgICBpZiAoUHJlZGljdGlvbk1vZGUuYWxsQ29uZmlnc0luUnVsZVN0b3BTdGF0ZXMoY29uZmlncykpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZ3M7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBuZXcgQVROQ29uZmlnU2V0KGNvbmZpZ3MuZnVsbEN0eCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbmZpZ3MuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gY29uZmlncy5pdGVtc1tpXTtcbiAgICAgICAgaWYgKGNvbmZpZy5zdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpIHtcbiAgICAgICAgICByZXN1bHQuYWRkKGNvbmZpZywgdGhpcy5tZXJnZUNhY2hlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9va1RvRW5kT2ZSdWxlICYmIGNvbmZpZy5zdGF0ZS5lcHNpbG9uT25seVRyYW5zaXRpb25zKSB7XG4gICAgICAgICAgY29uc3QgbmV4dFRva2VucyA9IHRoaXMuYXRuLm5leHRUb2tlbnMoY29uZmlnLnN0YXRlKTtcbiAgICAgICAgICBpZiAobmV4dFRva2Vucy5jb250YWlucyhUb2tlbjIuRVBTSUxPTikpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuZE9mUnVsZVN0YXRlID0gdGhpcy5hdG4ucnVsZVRvU3RvcFN0YXRlW2NvbmZpZy5zdGF0ZS5ydWxlSW5kZXhdO1xuICAgICAgICAgICAgcmVzdWx0LmFkZChuZXcgQVROQ29uZmlnKHtzdGF0ZTogZW5kT2ZSdWxlU3RhdGV9LCBjb25maWcpLCB0aGlzLm1lcmdlQ2FjaGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29tcHV0ZVN0YXJ0U3RhdGUocCwgY3R4LCBmdWxsQ3R4KSB7XG4gICAgICBjb25zdCBpbml0aWFsQ29udGV4dCA9IHByZWRpY3Rpb25Db250ZXh0RnJvbVJ1bGVDb250ZXh0KHRoaXMuYXRuLCBjdHgpO1xuICAgICAgY29uc3QgY29uZmlncyA9IG5ldyBBVE5Db25maWdTZXQoZnVsbEN0eCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHAudHJhbnNpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gcC50cmFuc2l0aW9uc1tpXS50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgQVROQ29uZmlnKHtzdGF0ZTogdGFyZ2V0LCBhbHQ6IGkgKyAxLCBjb250ZXh0OiBpbml0aWFsQ29udGV4dH0sIG51bGwpO1xuICAgICAgICBjb25zdCBjbG9zdXJlQnVzeSA9IG5ldyBTZXQyKCk7XG4gICAgICAgIHRoaXMuY2xvc3VyZShjLCBjb25maWdzLCBjbG9zdXJlQnVzeSwgdHJ1ZSwgZnVsbEN0eCwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmZpZ3M7XG4gICAgfVxuICAgIGFwcGx5UHJlY2VkZW5jZUZpbHRlcihjb25maWdzKSB7XG4gICAgICBsZXQgY29uZmlnO1xuICAgICAgY29uc3Qgc3RhdGVzRnJvbUFsdDEgPSBbXTtcbiAgICAgIGNvbnN0IGNvbmZpZ1NldCA9IG5ldyBBVE5Db25maWdTZXQoY29uZmlncy5mdWxsQ3R4KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29uZmlncy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25maWcgPSBjb25maWdzLml0ZW1zW2ldO1xuICAgICAgICBpZiAoY29uZmlnLmFsdCAhPT0gMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRDb250ZXh0ID0gY29uZmlnLnNlbWFudGljQ29udGV4dC5ldmFsUHJlY2VkZW5jZSh0aGlzLnBhcnNlciwgdGhpcy5fb3V0ZXJDb250ZXh0KTtcbiAgICAgICAgaWYgKHVwZGF0ZWRDb250ZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGVzRnJvbUFsdDFbY29uZmlnLnN0YXRlLnN0YXRlTnVtYmVyXSA9IGNvbmZpZy5jb250ZXh0O1xuICAgICAgICBpZiAodXBkYXRlZENvbnRleHQgIT09IGNvbmZpZy5zZW1hbnRpY0NvbnRleHQpIHtcbiAgICAgICAgICBjb25maWdTZXQuYWRkKG5ldyBBVE5Db25maWcoe3NlbWFudGljQ29udGV4dDogdXBkYXRlZENvbnRleHR9LCBjb25maWcpLCB0aGlzLm1lcmdlQ2FjaGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbmZpZ1NldC5hZGQoY29uZmlnLCB0aGlzLm1lcmdlQ2FjaGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbmZpZ3MuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uZmlnID0gY29uZmlncy5pdGVtc1tpXTtcbiAgICAgICAgaWYgKGNvbmZpZy5hbHQgPT09IDEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbmZpZy5wcmVjZWRlbmNlRmlsdGVyU3VwcHJlc3NlZCkge1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBzdGF0ZXNGcm9tQWx0MVtjb25maWcuc3RhdGUuc3RhdGVOdW1iZXJdIHx8IG51bGw7XG4gICAgICAgICAgaWYgKGNvbnRleHQgIT09IG51bGwgJiYgY29udGV4dC5lcXVhbHMoY29uZmlnLmNvbnRleHQpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnU2V0LmFkZChjb25maWcsIHRoaXMubWVyZ2VDYWNoZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uZmlnU2V0O1xuICAgIH1cbiAgICBnZXRSZWFjaGFibGVUYXJnZXQodHJhbnMsIHR0eXBlKSB7XG4gICAgICBpZiAodHJhbnMubWF0Y2hlcyh0dHlwZSwgMCwgdGhpcy5hdG4ubWF4VG9rZW5UeXBlKSkge1xuICAgICAgICByZXR1cm4gdHJhbnMudGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGdldFByZWRzRm9yQW1iaWdBbHRzKGFtYmlnQWx0cywgY29uZmlncywgbmFsdHMpIHtcbiAgICAgIGxldCBhbHRUb1ByZWQgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29uZmlncy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gY29uZmlncy5pdGVtc1tpXTtcbiAgICAgICAgaWYgKGFtYmlnQWx0cy5jb250YWlucyhjLmFsdCkpIHtcbiAgICAgICAgICBhbHRUb1ByZWRbYy5hbHRdID0gU2VtYW50aWNDb250ZXh0Lm9yQ29udGV4dChhbHRUb1ByZWRbYy5hbHRdIHx8IG51bGwsIGMuc2VtYW50aWNDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IG5QcmVkQWx0cyA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG5hbHRzICsgMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHByZWQgPSBhbHRUb1ByZWRbaV0gfHwgbnVsbDtcbiAgICAgICAgaWYgKHByZWQgPT09IG51bGwpIHtcbiAgICAgICAgICBhbHRUb1ByZWRbaV0gPSBTZW1hbnRpY0NvbnRleHQuTk9ORTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmVkICE9PSBTZW1hbnRpY0NvbnRleHQuTk9ORSkge1xuICAgICAgICAgIG5QcmVkQWx0cyArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoblByZWRBbHRzID09PSAwKSB7XG4gICAgICAgIGFsdFRvUHJlZCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcImdldFByZWRzRm9yQW1iaWdBbHRzIHJlc3VsdCBcIiArIFV0aWxzMy5hcnJheVRvU3RyaW5nKGFsdFRvUHJlZCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFsdFRvUHJlZDtcbiAgICB9XG4gICAgZ2V0UHJlZGljYXRlUHJlZGljdGlvbnMoYW1iaWdBbHRzLCBhbHRUb1ByZWQpIHtcbiAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICBsZXQgY29udGFpbnNQcmVkaWNhdGUgPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYWx0VG9QcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHByZWQgPSBhbHRUb1ByZWRbaV07XG4gICAgICAgIGlmIChhbWJpZ0FsdHMgIT09IG51bGwgJiYgYW1iaWdBbHRzLmNvbnRhaW5zKGkpKSB7XG4gICAgICAgICAgcGFpcnMucHVzaChuZXcgUHJlZFByZWRpY3Rpb24ocHJlZCwgaSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVkICE9PSBTZW1hbnRpY0NvbnRleHQuTk9ORSkge1xuICAgICAgICAgIGNvbnRhaW5zUHJlZGljYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjb250YWluc1ByZWRpY2F0ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYWlycztcbiAgICB9XG4gICAgZ2V0U3luVmFsaWRPclNlbUludmFsaWRBbHRUaGF0RmluaXNoZWREZWNpc2lvbkVudHJ5UnVsZShjb25maWdzLCBvdXRlckNvbnRleHQpIHtcbiAgICAgIGNvbnN0IGNmZ3MgPSB0aGlzLnNwbGl0QWNjb3JkaW5nVG9TZW1hbnRpY1ZhbGlkaXR5KGNvbmZpZ3MsIG91dGVyQ29udGV4dCk7XG4gICAgICBjb25zdCBzZW1WYWxpZENvbmZpZ3MgPSBjZmdzWzBdO1xuICAgICAgY29uc3Qgc2VtSW52YWxpZENvbmZpZ3MgPSBjZmdzWzFdO1xuICAgICAgbGV0IGFsdCA9IHRoaXMuZ2V0QWx0VGhhdEZpbmlzaGVkRGVjaXNpb25FbnRyeVJ1bGUoc2VtVmFsaWRDb25maWdzKTtcbiAgICAgIGlmIChhbHQgIT09IEFUTjIuSU5WQUxJRF9BTFRfTlVNQkVSKSB7XG4gICAgICAgIHJldHVybiBhbHQ7XG4gICAgICB9XG4gICAgICBpZiAoc2VtSW52YWxpZENvbmZpZ3MuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICBhbHQgPSB0aGlzLmdldEFsdFRoYXRGaW5pc2hlZERlY2lzaW9uRW50cnlSdWxlKHNlbUludmFsaWRDb25maWdzKTtcbiAgICAgICAgaWYgKGFsdCAhPT0gQVROMi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcbiAgICAgICAgICByZXR1cm4gYWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gQVROMi5JTlZBTElEX0FMVF9OVU1CRVI7XG4gICAgfVxuICAgIGdldEFsdFRoYXRGaW5pc2hlZERlY2lzaW9uRW50cnlSdWxlKGNvbmZpZ3MpIHtcbiAgICAgIGNvbnN0IGFsdHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29uZmlncy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gY29uZmlncy5pdGVtc1tpXTtcbiAgICAgICAgaWYgKGMucmVhY2hlc0ludG9PdXRlckNvbnRleHQgPiAwIHx8IGMuc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlICYmIGMuY29udGV4dC5oYXNFbXB0eVBhdGgoKSkge1xuICAgICAgICAgIGlmIChhbHRzLmluZGV4T2YoYy5hbHQpIDwgMCkge1xuICAgICAgICAgICAgYWx0cy5wdXNoKGMuYWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhbHRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQVROMi5JTlZBTElEX0FMVF9OVU1CRVI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkobnVsbCwgYWx0cyk7XG4gICAgICB9XG4gICAgfVxuICAgIHNwbGl0QWNjb3JkaW5nVG9TZW1hbnRpY1ZhbGlkaXR5KGNvbmZpZ3MsIG91dGVyQ29udGV4dCkge1xuICAgICAgY29uc3Qgc3VjY2VlZGVkID0gbmV3IEFUTkNvbmZpZ1NldChjb25maWdzLmZ1bGxDdHgpO1xuICAgICAgY29uc3QgZmFpbGVkID0gbmV3IEFUTkNvbmZpZ1NldChjb25maWdzLmZ1bGxDdHgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25maWdzLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBjb25maWdzLml0ZW1zW2ldO1xuICAgICAgICBpZiAoYy5zZW1hbnRpY0NvbnRleHQgIT09IFNlbWFudGljQ29udGV4dC5OT05FKSB7XG4gICAgICAgICAgY29uc3QgcHJlZGljYXRlRXZhbHVhdGlvblJlc3VsdCA9IGMuc2VtYW50aWNDb250ZXh0LmV2YWx1YXRlKHRoaXMucGFyc2VyLCBvdXRlckNvbnRleHQpO1xuICAgICAgICAgIGlmIChwcmVkaWNhdGVFdmFsdWF0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICBzdWNjZWVkZWQuYWRkKGMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmYWlsZWQuYWRkKGMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWNjZWVkZWQuYWRkKGMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW3N1Y2NlZWRlZCwgZmFpbGVkXTtcbiAgICB9XG4gICAgZXZhbFNlbWFudGljQ29udGV4dChwcmVkUHJlZGljdGlvbnMsIG91dGVyQ29udGV4dCwgY29tcGxldGUpIHtcbiAgICAgIGNvbnN0IHByZWRpY3Rpb25zID0gbmV3IEJpdFNldCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVkUHJlZGljdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGFpciA9IHByZWRQcmVkaWN0aW9uc1tpXTtcbiAgICAgICAgaWYgKHBhaXIucHJlZCA9PT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcbiAgICAgICAgICBwcmVkaWN0aW9ucy5hZGQocGFpci5hbHQpO1xuICAgICAgICAgIGlmICghY29tcGxldGUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVkaWNhdGVFdmFsdWF0aW9uUmVzdWx0ID0gcGFpci5wcmVkLmV2YWx1YXRlKHRoaXMucGFyc2VyLCBvdXRlckNvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy5kZWJ1ZyB8fCB0aGlzLmRmYV9kZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiZXZhbCBwcmVkIFwiICsgcGFpciArIFwiPVwiICsgcHJlZGljYXRlRXZhbHVhdGlvblJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWRpY2F0ZUV2YWx1YXRpb25SZXN1bHQpIHtcbiAgICAgICAgICBpZiAodGhpcy5kZWJ1ZyB8fCB0aGlzLmRmYV9kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJQUkVESUNUIFwiICsgcGFpci5hbHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcmVkaWN0aW9ucy5hZGQocGFpci5hbHQpO1xuICAgICAgICAgIGlmICghY29tcGxldGUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHByZWRpY3Rpb25zO1xuICAgIH1cbiAgICBjbG9zdXJlKGNvbmZpZywgY29uZmlncywgY2xvc3VyZUJ1c3ksIGNvbGxlY3RQcmVkaWNhdGVzLCBmdWxsQ3R4LCB0cmVhdEVvZkFzRXBzaWxvbikge1xuICAgICAgY29uc3QgaW5pdGlhbERlcHRoID0gMDtcbiAgICAgIHRoaXMuY2xvc3VyZUNoZWNraW5nU3RvcFN0YXRlKGNvbmZpZywgY29uZmlncywgY2xvc3VyZUJ1c3ksIGNvbGxlY3RQcmVkaWNhdGVzLCBmdWxsQ3R4LCBpbml0aWFsRGVwdGgsIHRyZWF0RW9mQXNFcHNpbG9uKTtcbiAgICB9XG4gICAgY2xvc3VyZUNoZWNraW5nU3RvcFN0YXRlKGNvbmZpZywgY29uZmlncywgY2xvc3VyZUJ1c3ksIGNvbGxlY3RQcmVkaWNhdGVzLCBmdWxsQ3R4LCBkZXB0aCwgdHJlYXRFb2ZBc0Vwc2lsb24pIHtcbiAgICAgIGlmICh0aGlzLmRlYnVnIHx8IHRoaXMuZGVidWdfY2xvc3VyZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcImNsb3N1cmUoXCIgKyBjb25maWcudG9TdHJpbmcodGhpcy5wYXJzZXIsIHRydWUpICsgXCIpXCIpO1xuICAgICAgICBpZiAoY29uZmlnLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0ID4gNTApIHtcbiAgICAgICAgICB0aHJvdyBcInByb2JsZW1cIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZy5zdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpIHtcbiAgICAgICAgaWYgKCFjb25maWcuY29udGV4dC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbmZpZy5jb250ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmNvbnRleHQuZ2V0UmV0dXJuU3RhdGUoaSkgPT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX1JFVFVSTl9TVEFURSkge1xuICAgICAgICAgICAgICBpZiAoZnVsbEN0eCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3MuYWRkKG5ldyBBVE5Db25maWcoe3N0YXRlOiBjb25maWcuc3RhdGUsIGNvbnRleHQ6IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZfSwgY29uZmlnKSwgdGhpcy5tZXJnZUNhY2hlKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGQUxMSU5HIG9mZiBydWxlIFwiICsgdGhpcy5nZXRSdWxlTmFtZShjb25maWcuc3RhdGUucnVsZUluZGV4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc3VyZV8oY29uZmlnLCBjb25maWdzLCBjbG9zdXJlQnVzeSwgY29sbGVjdFByZWRpY2F0ZXMsIGZ1bGxDdHgsIGRlcHRoLCB0cmVhdEVvZkFzRXBzaWxvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXR1cm5TdGF0ZSA9IHRoaXMuYXRuLnN0YXRlc1tjb25maWcuY29udGV4dC5nZXRSZXR1cm5TdGF0ZShpKV07XG4gICAgICAgICAgICBjb25zdCBuZXdDb250ZXh0ID0gY29uZmlnLmNvbnRleHQuZ2V0UGFyZW50KGkpO1xuICAgICAgICAgICAgY29uc3QgcGFybXMgPSB7c3RhdGU6IHJldHVyblN0YXRlLCBhbHQ6IGNvbmZpZy5hbHQsIGNvbnRleHQ6IG5ld0NvbnRleHQsIHNlbWFudGljQ29udGV4dDogY29uZmlnLnNlbWFudGljQ29udGV4dH07XG4gICAgICAgICAgICBjb25zdCBjID0gbmV3IEFUTkNvbmZpZyhwYXJtcywgbnVsbCk7XG4gICAgICAgICAgICBjLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0ID0gY29uZmlnLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0O1xuICAgICAgICAgICAgdGhpcy5jbG9zdXJlQ2hlY2tpbmdTdG9wU3RhdGUoYywgY29uZmlncywgY2xvc3VyZUJ1c3ksIGNvbGxlY3RQcmVkaWNhdGVzLCBmdWxsQ3R4LCBkZXB0aCAtIDEsIHRyZWF0RW9mQXNFcHNpbG9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKGZ1bGxDdHgpIHtcbiAgICAgICAgICBjb25maWdzLmFkZChjb25maWcsIHRoaXMubWVyZ2VDYWNoZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZBTExJTkcgb2ZmIHJ1bGUgXCIgKyB0aGlzLmdldFJ1bGVOYW1lKGNvbmZpZy5zdGF0ZS5ydWxlSW5kZXgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuY2xvc3VyZV8oY29uZmlnLCBjb25maWdzLCBjbG9zdXJlQnVzeSwgY29sbGVjdFByZWRpY2F0ZXMsIGZ1bGxDdHgsIGRlcHRoLCB0cmVhdEVvZkFzRXBzaWxvbik7XG4gICAgfVxuICAgIGNsb3N1cmVfKGNvbmZpZywgY29uZmlncywgY2xvc3VyZUJ1c3ksIGNvbGxlY3RQcmVkaWNhdGVzLCBmdWxsQ3R4LCBkZXB0aCwgdHJlYXRFb2ZBc0Vwc2lsb24pIHtcbiAgICAgIGNvbnN0IHAgPSBjb25maWcuc3RhdGU7XG4gICAgICBpZiAoIXAuZXBzaWxvbk9ubHlUcmFuc2l0aW9ucykge1xuICAgICAgICBjb25maWdzLmFkZChjb25maWcsIHRoaXMubWVyZ2VDYWNoZSk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHAudHJhbnNpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPT09IDAgJiYgdGhpcy5jYW5Ecm9wTG9vcEVudHJ5RWRnZUluTGVmdFJlY3Vyc2l2ZVJ1bGUoY29uZmlnKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgdCA9IHAudHJhbnNpdGlvbnNbaV07XG4gICAgICAgIGNvbnN0IGNvbnRpbnVlQ29sbGVjdGluZyA9IGNvbGxlY3RQcmVkaWNhdGVzICYmICEodCBpbnN0YW5jZW9mIEFjdGlvblRyYW5zaXRpb24pO1xuICAgICAgICBjb25zdCBjID0gdGhpcy5nZXRFcHNpbG9uVGFyZ2V0KGNvbmZpZywgdCwgY29udGludWVDb2xsZWN0aW5nLCBkZXB0aCA9PT0gMCwgZnVsbEN0eCwgdHJlYXRFb2ZBc0Vwc2lsb24pO1xuICAgICAgICBpZiAoYyAhPT0gbnVsbCkge1xuICAgICAgICAgIGxldCBuZXdEZXB0aCA9IGRlcHRoO1xuICAgICAgICAgIGlmIChjb25maWcuc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGZhICE9PSBudWxsICYmIHRoaXMuX2RmYS5wcmVjZWRlbmNlRGZhKSB7XG4gICAgICAgICAgICAgIGlmICh0Lm91dGVybW9zdFByZWNlZGVuY2VSZXR1cm4gPT09IHRoaXMuX2RmYS5hdG5TdGFydFN0YXRlLnJ1bGVJbmRleCkge1xuICAgICAgICAgICAgICAgIGMucHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0ICs9IDE7XG4gICAgICAgICAgICBpZiAoY2xvc3VyZUJ1c3kuYWRkKGMpICE9PSBjKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlncy5kaXBzSW50b091dGVyQ29udGV4dCA9IHRydWU7XG4gICAgICAgICAgICBuZXdEZXB0aCAtPSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJkaXBzIGludG8gb3V0ZXIgY3R4OiBcIiArIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXQuaXNFcHNpbG9uICYmIGNsb3N1cmVCdXN5LmFkZChjKSAhPT0gYykge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0IGluc3RhbmNlb2YgUnVsZVRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgaWYgKG5ld0RlcHRoID49IDApIHtcbiAgICAgICAgICAgICAgICBuZXdEZXB0aCArPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY2xvc3VyZUNoZWNraW5nU3RvcFN0YXRlKGMsIGNvbmZpZ3MsIGNsb3N1cmVCdXN5LCBjb250aW51ZUNvbGxlY3RpbmcsIGZ1bGxDdHgsIG5ld0RlcHRoLCB0cmVhdEVvZkFzRXBzaWxvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY2FuRHJvcExvb3BFbnRyeUVkZ2VJbkxlZnRSZWN1cnNpdmVSdWxlKGNvbmZpZykge1xuICAgICAgY29uc3QgcCA9IGNvbmZpZy5zdGF0ZTtcbiAgICAgIGlmIChwLnN0YXRlVHlwZSAhPT0gQVROU3RhdGUuU1RBUl9MT09QX0VOVFJZKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAocC5zdGF0ZVR5cGUgIT09IEFUTlN0YXRlLlNUQVJfTE9PUF9FTlRSWSB8fCAhcC5pc1ByZWNlZGVuY2VEZWNpc2lvbiB8fCBjb25maWcuY29udGV4dC5pc0VtcHR5KCkgfHwgY29uZmlnLmNvbnRleHQuaGFzRW1wdHlQYXRoKCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGNvbnN0IG51bUN0eHMgPSBjb25maWcuY29udGV4dC5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUN0eHM7IGkrKykge1xuICAgICAgICBjb25zdCByZXR1cm5TdGF0ZSA9IHRoaXMuYXRuLnN0YXRlc1tjb25maWcuY29udGV4dC5nZXRSZXR1cm5TdGF0ZShpKV07XG4gICAgICAgIGlmIChyZXR1cm5TdGF0ZS5ydWxlSW5kZXggIT09IHAucnVsZUluZGV4KVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlY2lzaW9uU3RhcnRTdGF0ZSA9IHAudHJhbnNpdGlvbnNbMF0udGFyZ2V0O1xuICAgICAgY29uc3QgYmxvY2tFbmRTdGF0ZU51bSA9IGRlY2lzaW9uU3RhcnRTdGF0ZS5lbmRTdGF0ZS5zdGF0ZU51bWJlcjtcbiAgICAgIGNvbnN0IGJsb2NrRW5kU3RhdGUgPSB0aGlzLmF0bi5zdGF0ZXNbYmxvY2tFbmRTdGF0ZU51bV07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUN0eHM7IGkrKykge1xuICAgICAgICBjb25zdCByZXR1cm5TdGF0ZU51bWJlciA9IGNvbmZpZy5jb250ZXh0LmdldFJldHVyblN0YXRlKGkpO1xuICAgICAgICBjb25zdCByZXR1cm5TdGF0ZSA9IHRoaXMuYXRuLnN0YXRlc1tyZXR1cm5TdGF0ZU51bWJlcl07XG4gICAgICAgIGlmIChyZXR1cm5TdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGggIT09IDEgfHwgIXJldHVyblN0YXRlLnRyYW5zaXRpb25zWzBdLmlzRXBzaWxvbilcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHJldHVyblN0YXRlVGFyZ2V0ID0gcmV0dXJuU3RhdGUudHJhbnNpdGlvbnNbMF0udGFyZ2V0O1xuICAgICAgICBpZiAocmV0dXJuU3RhdGUuc3RhdGVUeXBlID09PSBBVE5TdGF0ZS5CTE9DS19FTkQgJiYgcmV0dXJuU3RhdGVUYXJnZXQgPT09IHApXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChyZXR1cm5TdGF0ZSA9PT0gYmxvY2tFbmRTdGF0ZSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHJldHVyblN0YXRlVGFyZ2V0ID09PSBibG9ja0VuZFN0YXRlKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAocmV0dXJuU3RhdGVUYXJnZXQuc3RhdGVUeXBlID09PSBBVE5TdGF0ZS5CTE9DS19FTkQgJiYgcmV0dXJuU3RhdGVUYXJnZXQudHJhbnNpdGlvbnMubGVuZ3RoID09PSAxICYmIHJldHVyblN0YXRlVGFyZ2V0LnRyYW5zaXRpb25zWzBdLmlzRXBzaWxvbiAmJiByZXR1cm5TdGF0ZVRhcmdldC50cmFuc2l0aW9uc1swXS50YXJnZXQgPT09IHApXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXRSdWxlTmFtZShpbmRleCkge1xuICAgICAgaWYgKHRoaXMucGFyc2VyICE9PSBudWxsICYmIGluZGV4ID49IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VyLnJ1bGVOYW1lc1tpbmRleF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCI8cnVsZSBcIiArIGluZGV4ICsgXCI+XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdldEVwc2lsb25UYXJnZXQoY29uZmlnLCB0LCBjb2xsZWN0UHJlZGljYXRlcywgaW5Db250ZXh0LCBmdWxsQ3R4LCB0cmVhdEVvZkFzRXBzaWxvbikge1xuICAgICAgc3dpdGNoICh0LnNlcmlhbGl6YXRpb25UeXBlKSB7XG4gICAgICAgIGNhc2UgVHJhbnNpdGlvbi5SVUxFOlxuICAgICAgICAgIHJldHVybiB0aGlzLnJ1bGVUcmFuc2l0aW9uKGNvbmZpZywgdCk7XG4gICAgICAgIGNhc2UgVHJhbnNpdGlvbi5QUkVDRURFTkNFOlxuICAgICAgICAgIHJldHVybiB0aGlzLnByZWNlZGVuY2VUcmFuc2l0aW9uKGNvbmZpZywgdCwgY29sbGVjdFByZWRpY2F0ZXMsIGluQ29udGV4dCwgZnVsbEN0eCk7XG4gICAgICAgIGNhc2UgVHJhbnNpdGlvbi5QUkVESUNBVEU6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHJlZFRyYW5zaXRpb24oY29uZmlnLCB0LCBjb2xsZWN0UHJlZGljYXRlcywgaW5Db250ZXh0LCBmdWxsQ3R4KTtcbiAgICAgICAgY2FzZSBUcmFuc2l0aW9uLkFDVElPTjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb25UcmFuc2l0aW9uKGNvbmZpZywgdCk7XG4gICAgICAgIGNhc2UgVHJhbnNpdGlvbi5FUFNJTE9OOlxuICAgICAgICAgIHJldHVybiBuZXcgQVROQ29uZmlnKHtzdGF0ZTogdC50YXJnZXR9LCBjb25maWcpO1xuICAgICAgICBjYXNlIFRyYW5zaXRpb24uQVRPTTpcbiAgICAgICAgY2FzZSBUcmFuc2l0aW9uLlJBTkdFOlxuICAgICAgICBjYXNlIFRyYW5zaXRpb24uU0VUOlxuICAgICAgICAgIGlmICh0cmVhdEVvZkFzRXBzaWxvbikge1xuICAgICAgICAgICAgaWYgKHQubWF0Y2hlcyhUb2tlbjIuRU9GLCAwLCAxKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEFUTkNvbmZpZyh7c3RhdGU6IHQudGFyZ2V0fSwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGFjdGlvblRyYW5zaXRpb24oY29uZmlnLCB0KSB7XG4gICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICBjb25zdCBpbmRleCA9IHQuYWN0aW9uSW5kZXggPT09IC0xID8gNjU1MzUgOiB0LmFjdGlvbkluZGV4O1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFDVElPTiBlZGdlIFwiICsgdC5ydWxlSW5kZXggKyBcIjpcIiArIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQVROQ29uZmlnKHtzdGF0ZTogdC50YXJnZXR9LCBjb25maWcpO1xuICAgIH1cbiAgICBwcmVjZWRlbmNlVHJhbnNpdGlvbihjb25maWcsIHB0LCBjb2xsZWN0UHJlZGljYXRlcywgaW5Db250ZXh0LCBmdWxsQ3R4KSB7XG4gICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlBSRUQgKGNvbGxlY3RQcmVkaWNhdGVzPVwiICsgY29sbGVjdFByZWRpY2F0ZXMgKyBcIikgXCIgKyBwdC5wcmVjZWRlbmNlICsgXCI+PV9wLCBjdHggZGVwZW5kZW50PXRydWVcIik7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlciAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiY29udGV4dCBzdXJyb3VuZGluZyBwcmVkIGlzIFwiICsgVXRpbHMzLmFycmF5VG9TdHJpbmcodGhpcy5wYXJzZXIuZ2V0UnVsZUludm9jYXRpb25TdGFjaygpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBjID0gbnVsbDtcbiAgICAgIGlmIChjb2xsZWN0UHJlZGljYXRlcyAmJiBpbkNvbnRleHQpIHtcbiAgICAgICAgaWYgKGZ1bGxDdHgpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50UG9zaXRpb24gPSB0aGlzLl9pbnB1dC5pbmRleDtcbiAgICAgICAgICB0aGlzLl9pbnB1dC5zZWVrKHRoaXMuX3N0YXJ0SW5kZXgpO1xuICAgICAgICAgIGNvbnN0IHByZWRTdWNjZWVkcyA9IHB0LmdldFByZWRpY2F0ZSgpLmV2YWx1YXRlKHRoaXMucGFyc2VyLCB0aGlzLl9vdXRlckNvbnRleHQpO1xuICAgICAgICAgIHRoaXMuX2lucHV0LnNlZWsoY3VycmVudFBvc2l0aW9uKTtcbiAgICAgICAgICBpZiAocHJlZFN1Y2NlZWRzKSB7XG4gICAgICAgICAgICBjID0gbmV3IEFUTkNvbmZpZyh7c3RhdGU6IHB0LnRhcmdldH0sIGNvbmZpZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG5ld1NlbUN0eCA9IFNlbWFudGljQ29udGV4dC5hbmRDb250ZXh0KGNvbmZpZy5zZW1hbnRpY0NvbnRleHQsIHB0LmdldFByZWRpY2F0ZSgpKTtcbiAgICAgICAgICBjID0gbmV3IEFUTkNvbmZpZyh7c3RhdGU6IHB0LnRhcmdldCwgc2VtYW50aWNDb250ZXh0OiBuZXdTZW1DdHh9LCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjID0gbmV3IEFUTkNvbmZpZyh7c3RhdGU6IHB0LnRhcmdldH0sIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcImNvbmZpZyBmcm9tIHByZWQgdHJhbnNpdGlvbj1cIiArIGMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIHByZWRUcmFuc2l0aW9uKGNvbmZpZywgcHQsIGNvbGxlY3RQcmVkaWNhdGVzLCBpbkNvbnRleHQsIGZ1bGxDdHgpIHtcbiAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiUFJFRCAoY29sbGVjdFByZWRpY2F0ZXM9XCIgKyBjb2xsZWN0UHJlZGljYXRlcyArIFwiKSBcIiArIHB0LnJ1bGVJbmRleCArIFwiOlwiICsgcHQucHJlZEluZGV4ICsgXCIsIGN0eCBkZXBlbmRlbnQ9XCIgKyBwdC5pc0N0eERlcGVuZGVudCk7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlciAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiY29udGV4dCBzdXJyb3VuZGluZyBwcmVkIGlzIFwiICsgVXRpbHMzLmFycmF5VG9TdHJpbmcodGhpcy5wYXJzZXIuZ2V0UnVsZUludm9jYXRpb25TdGFjaygpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBjID0gbnVsbDtcbiAgICAgIGlmIChjb2xsZWN0UHJlZGljYXRlcyAmJiAocHQuaXNDdHhEZXBlbmRlbnQgJiYgaW5Db250ZXh0IHx8ICFwdC5pc0N0eERlcGVuZGVudCkpIHtcbiAgICAgICAgaWYgKGZ1bGxDdHgpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50UG9zaXRpb24gPSB0aGlzLl9pbnB1dC5pbmRleDtcbiAgICAgICAgICB0aGlzLl9pbnB1dC5zZWVrKHRoaXMuX3N0YXJ0SW5kZXgpO1xuICAgICAgICAgIGNvbnN0IHByZWRTdWNjZWVkcyA9IHB0LmdldFByZWRpY2F0ZSgpLmV2YWx1YXRlKHRoaXMucGFyc2VyLCB0aGlzLl9vdXRlckNvbnRleHQpO1xuICAgICAgICAgIHRoaXMuX2lucHV0LnNlZWsoY3VycmVudFBvc2l0aW9uKTtcbiAgICAgICAgICBpZiAocHJlZFN1Y2NlZWRzKSB7XG4gICAgICAgICAgICBjID0gbmV3IEFUTkNvbmZpZyh7c3RhdGU6IHB0LnRhcmdldH0sIGNvbmZpZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG5ld1NlbUN0eCA9IFNlbWFudGljQ29udGV4dC5hbmRDb250ZXh0KGNvbmZpZy5zZW1hbnRpY0NvbnRleHQsIHB0LmdldFByZWRpY2F0ZSgpKTtcbiAgICAgICAgICBjID0gbmV3IEFUTkNvbmZpZyh7c3RhdGU6IHB0LnRhcmdldCwgc2VtYW50aWNDb250ZXh0OiBuZXdTZW1DdHh9LCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjID0gbmV3IEFUTkNvbmZpZyh7c3RhdGU6IHB0LnRhcmdldH0sIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcImNvbmZpZyBmcm9tIHByZWQgdHJhbnNpdGlvbj1cIiArIGMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIHJ1bGVUcmFuc2l0aW9uKGNvbmZpZywgdCkge1xuICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJDQUxMIHJ1bGUgXCIgKyB0aGlzLmdldFJ1bGVOYW1lKHQudGFyZ2V0LnJ1bGVJbmRleCkgKyBcIiwgY3R4PVwiICsgY29uZmlnLmNvbnRleHQpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmV0dXJuU3RhdGUgPSB0LmZvbGxvd1N0YXRlO1xuICAgICAgY29uc3QgbmV3Q29udGV4dCA9IFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0LmNyZWF0ZShjb25maWcuY29udGV4dCwgcmV0dXJuU3RhdGUuc3RhdGVOdW1iZXIpO1xuICAgICAgcmV0dXJuIG5ldyBBVE5Db25maWcoe3N0YXRlOiB0LnRhcmdldCwgY29udGV4dDogbmV3Q29udGV4dH0sIGNvbmZpZyk7XG4gICAgfVxuICAgIGdldENvbmZsaWN0aW5nQWx0cyhjb25maWdzKSB7XG4gICAgICBjb25zdCBhbHRzZXRzID0gUHJlZGljdGlvbk1vZGUuZ2V0Q29uZmxpY3RpbmdBbHRTdWJzZXRzKGNvbmZpZ3MpO1xuICAgICAgcmV0dXJuIFByZWRpY3Rpb25Nb2RlLmdldEFsdHMoYWx0c2V0cyk7XG4gICAgfVxuICAgIGdldENvbmZsaWN0aW5nQWx0c09yVW5pcXVlQWx0KGNvbmZpZ3MpIHtcbiAgICAgIGxldCBjb25mbGljdGluZ0FsdHMgPSBudWxsO1xuICAgICAgaWYgKGNvbmZpZ3MudW5pcXVlQWx0ICE9PSBBVE4yLklOVkFMSURfQUxUX05VTUJFUikge1xuICAgICAgICBjb25mbGljdGluZ0FsdHMgPSBuZXcgQml0U2V0KCk7XG4gICAgICAgIGNvbmZsaWN0aW5nQWx0cy5hZGQoY29uZmlncy51bmlxdWVBbHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uZmxpY3RpbmdBbHRzID0gY29uZmlncy5jb25mbGljdGluZ0FsdHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uZmxpY3RpbmdBbHRzO1xuICAgIH1cbiAgICBnZXRUb2tlbk5hbWUodCkge1xuICAgICAgaWYgKHQgPT09IFRva2VuMi5FT0YpIHtcbiAgICAgICAgcmV0dXJuIFwiRU9GXCI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wYXJzZXIgIT09IG51bGwgJiYgdGhpcy5wYXJzZXIubGl0ZXJhbE5hbWVzICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh0ID49IHRoaXMucGFyc2VyLmxpdGVyYWxOYW1lcy5sZW5ndGggJiYgdCA+PSB0aGlzLnBhcnNlci5zeW1ib2xpY05hbWVzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiXCIgKyB0ICsgXCIgdHR5cGUgb3V0IG9mIHJhbmdlOiBcIiArIHRoaXMucGFyc2VyLmxpdGVyYWxOYW1lcyk7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJcIiArIHRoaXMucGFyc2VyLmdldElucHV0U3RyZWFtKCkuZ2V0VG9rZW5zKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlci5saXRlcmFsTmFtZXNbdF0gfHwgdGhpcy5wYXJzZXIuc3ltYm9saWNOYW1lc1t0XTtcbiAgICAgICAgICByZXR1cm4gbmFtZSArIFwiPFwiICsgdCArIFwiPlwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJcIiArIHQ7XG4gICAgfVxuICAgIGdldExvb2thaGVhZE5hbWUoaW5wdXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRva2VuTmFtZShpbnB1dC5MQSgxKSk7XG4gICAgfVxuICAgIGR1bXBEZWFkRW5kQ29uZmlncyhudmFlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImRlYWQgZW5kIGNvbmZpZ3M6IFwiKTtcbiAgICAgIGNvbnN0IGRlY3MgPSBudmFlLmdldERlYWRFbmRDb25maWdzKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IGRlY3NbaV07XG4gICAgICAgIGxldCB0cmFucyA9IFwibm8gZWRnZXNcIjtcbiAgICAgICAgaWYgKGMuc3RhdGUudHJhbnNpdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHQgPSBjLnN0YXRlLnRyYW5zaXRpb25zWzBdO1xuICAgICAgICAgIGlmICh0IGluc3RhbmNlb2YgQXRvbVRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIHRyYW5zID0gXCJBdG9tIFwiICsgdGhpcy5nZXRUb2tlbk5hbWUodC5sYWJlbCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0IGluc3RhbmNlb2YgU2V0VHJhbnNpdGlvbikge1xuICAgICAgICAgICAgY29uc3QgbmVnID0gdCBpbnN0YW5jZW9mIE5vdFNldFRyYW5zaXRpb247XG4gICAgICAgICAgICB0cmFucyA9IChuZWcgPyBcIn5cIiA6IFwiXCIpICsgXCJTZXQgXCIgKyB0LnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihjLnRvU3RyaW5nKHRoaXMucGFyc2VyLCB0cnVlKSArIFwiOlwiICsgdHJhbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBub1ZpYWJsZUFsdChpbnB1dCwgb3V0ZXJDb250ZXh0LCBjb25maWdzLCBzdGFydEluZGV4KSB7XG4gICAgICByZXR1cm4gbmV3IE5vVmlhYmxlQWx0RXhjZXB0aW9uMih0aGlzLnBhcnNlciwgaW5wdXQsIGlucHV0LmdldChzdGFydEluZGV4KSwgaW5wdXQuTFQoMSksIGNvbmZpZ3MsIG91dGVyQ29udGV4dCk7XG4gICAgfVxuICAgIGdldFVuaXF1ZUFsdChjb25maWdzKSB7XG4gICAgICBsZXQgYWx0ID0gQVROMi5JTlZBTElEX0FMVF9OVU1CRVI7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbmZpZ3MuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IGNvbmZpZ3MuaXRlbXNbaV07XG4gICAgICAgIGlmIChhbHQgPT09IEFUTjIuSU5WQUxJRF9BTFRfTlVNQkVSKSB7XG4gICAgICAgICAgYWx0ID0gYy5hbHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYy5hbHQgIT09IGFsdCkge1xuICAgICAgICAgIHJldHVybiBBVE4yLklOVkFMSURfQUxUX05VTUJFUjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFsdDtcbiAgICB9XG4gICAgYWRkREZBRWRnZShkZmEsIGZyb21fLCB0LCB0bykge1xuICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJFREdFIFwiICsgZnJvbV8gKyBcIiAtPiBcIiArIHRvICsgXCIgdXBvbiBcIiArIHRoaXMuZ2V0VG9rZW5OYW1lKHQpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0byA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRvID0gdGhpcy5hZGRERkFTdGF0ZShkZmEsIHRvKTtcbiAgICAgIGlmIChmcm9tXyA9PT0gbnVsbCB8fCB0IDwgLTEgfHwgdCA+IHRoaXMuYXRuLm1heFRva2VuVHlwZSkge1xuICAgICAgICByZXR1cm4gdG87XG4gICAgICB9XG4gICAgICBpZiAoZnJvbV8uZWRnZXMgPT09IG51bGwpIHtcbiAgICAgICAgZnJvbV8uZWRnZXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGZyb21fLmVkZ2VzW3QgKyAxXSA9IHRvO1xuICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgY29uc3QgbGl0ZXJhbE5hbWVzID0gdGhpcy5wYXJzZXIgPT09IG51bGwgPyBudWxsIDogdGhpcy5wYXJzZXIubGl0ZXJhbE5hbWVzO1xuICAgICAgICBjb25zdCBzeW1ib2xpY05hbWVzID0gdGhpcy5wYXJzZXIgPT09IG51bGwgPyBudWxsIDogdGhpcy5wYXJzZXIuc3ltYm9saWNOYW1lcztcbiAgICAgICAgY29uc29sZS5sb2coXCJERkE9XFxuXCIgKyBkZmEudG9TdHJpbmcobGl0ZXJhbE5hbWVzLCBzeW1ib2xpY05hbWVzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGFkZERGQVN0YXRlKGRmYSwgRCkge1xuICAgICAgaWYgKEQgPT09IEFUTlNpbXVsYXRvci5FUlJPUikge1xuICAgICAgICByZXR1cm4gRDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gZGZhLnN0YXRlcy5nZXQoRCk7XG4gICAgICBpZiAoZXhpc3RpbmcgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgfVxuICAgICAgRC5zdGF0ZU51bWJlciA9IGRmYS5zdGF0ZXMubGVuZ3RoO1xuICAgICAgaWYgKCFELmNvbmZpZ3MucmVhZE9ubHkpIHtcbiAgICAgICAgRC5jb25maWdzLm9wdGltaXplQ29uZmlncyh0aGlzKTtcbiAgICAgICAgRC5jb25maWdzLnNldFJlYWRvbmx5KHRydWUpO1xuICAgICAgfVxuICAgICAgZGZhLnN0YXRlcy5hZGQoRCk7XG4gICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcImFkZGluZyBuZXcgREZBIHN0YXRlOiBcIiArIEQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEQ7XG4gICAgfVxuICAgIHJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dChkZmEsIGNvbmZsaWN0aW5nQWx0cywgY29uZmlncywgc3RhcnRJbmRleCwgc3RvcEluZGV4KSB7XG4gICAgICBpZiAodGhpcy5kZWJ1ZyB8fCB0aGlzLnJldHJ5X2RlYnVnKSB7XG4gICAgICAgIGNvbnN0IGludGVydmFsID0gbmV3IEludGVydmFsKHN0YXJ0SW5kZXgsIHN0b3BJbmRleCArIDEpO1xuICAgICAgICBjb25zb2xlLmxvZyhcInJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dCBkZWNpc2lvbj1cIiArIGRmYS5kZWNpc2lvbiArIFwiOlwiICsgY29uZmlncyArIFwiLCBpbnB1dD1cIiArIHRoaXMucGFyc2VyLmdldFRva2VuU3RyZWFtKCkuZ2V0VGV4dChpbnRlcnZhbCkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGFyc2VyICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucGFyc2VyLmdldEVycm9yTGlzdGVuZXJEaXNwYXRjaCgpLnJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dCh0aGlzLnBhcnNlciwgZGZhLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIGNvbmZsaWN0aW5nQWx0cywgY29uZmlncyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlcG9ydENvbnRleHRTZW5zaXRpdml0eShkZmEsIHByZWRpY3Rpb24sIGNvbmZpZ3MsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCkge1xuICAgICAgaWYgKHRoaXMuZGVidWcgfHwgdGhpcy5yZXRyeV9kZWJ1Zykge1xuICAgICAgICBjb25zdCBpbnRlcnZhbCA9IG5ldyBJbnRlcnZhbChzdGFydEluZGV4LCBzdG9wSW5kZXggKyAxKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJyZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHkgZGVjaXNpb249XCIgKyBkZmEuZGVjaXNpb24gKyBcIjpcIiArIGNvbmZpZ3MgKyBcIiwgaW5wdXQ9XCIgKyB0aGlzLnBhcnNlci5nZXRUb2tlblN0cmVhbSgpLmdldFRleHQoaW50ZXJ2YWwpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBhcnNlciAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnBhcnNlci5nZXRFcnJvckxpc3RlbmVyRGlzcGF0Y2goKS5yZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHkodGhpcy5wYXJzZXIsIGRmYSwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBwcmVkaWN0aW9uLCBjb25maWdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVwb3J0QW1iaWd1aXR5KGRmYSwgRCwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBleGFjdCwgYW1iaWdBbHRzLCBjb25maWdzKSB7XG4gICAgICBpZiAodGhpcy5kZWJ1ZyB8fCB0aGlzLnJldHJ5X2RlYnVnKSB7XG4gICAgICAgIGNvbnN0IGludGVydmFsID0gbmV3IEludGVydmFsKHN0YXJ0SW5kZXgsIHN0b3BJbmRleCArIDEpO1xuICAgICAgICBjb25zb2xlLmxvZyhcInJlcG9ydEFtYmlndWl0eSBcIiArIGFtYmlnQWx0cyArIFwiOlwiICsgY29uZmlncyArIFwiLCBpbnB1dD1cIiArIHRoaXMucGFyc2VyLmdldFRva2VuU3RyZWFtKCkuZ2V0VGV4dChpbnRlcnZhbCkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGFyc2VyICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucGFyc2VyLmdldEVycm9yTGlzdGVuZXJEaXNwYXRjaCgpLnJlcG9ydEFtYmlndWl0eSh0aGlzLnBhcnNlciwgZGZhLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIGV4YWN0LCBhbWJpZ0FsdHMsIGNvbmZpZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgbW9kdWxlMi5leHBvcnRzID0gUGFyc2VyQVROU2ltdWxhdG9yMjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0L3NyYy9hbnRscjQvYXRuL2luZGV4LmpzXG52YXIgcmVxdWlyZV9hdG4gPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIGV4cG9ydHMuQVROID0gcmVxdWlyZV9BVE4yKCk7XG4gIGV4cG9ydHMuQVRORGVzZXJpYWxpemVyID0gcmVxdWlyZV9BVE5EZXNlcmlhbGl6ZXIyKCk7XG4gIGV4cG9ydHMuTGV4ZXJBVE5TaW11bGF0b3IgPSByZXF1aXJlX0xleGVyQVROU2ltdWxhdG9yMigpO1xuICBleHBvcnRzLlBhcnNlckFUTlNpbXVsYXRvciA9IHJlcXVpcmVfUGFyc2VyQVROU2ltdWxhdG9yMigpO1xuICBleHBvcnRzLlByZWRpY3Rpb25Nb2RlID0gcmVxdWlyZV9QcmVkaWN0aW9uTW9kZTIoKTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0L3NyYy9hbnRscjQvcG9seWZpbGxzL2NvZGVwb2ludGF0LmpzXG52YXIgcmVxdWlyZV9jb2RlcG9pbnRhdCA9IF9fY29tbW9uSlMoKCkgPT4ge1xuICBpZiAoIVN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQpIHtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IG9iamVjdCA9IHt9O1xuICAgICAgICAgIGNvbnN0ICRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgICAgICAgICByZXN1bHQgPSAkZGVmaW5lUHJvcGVydHkob2JqZWN0LCBvYmplY3QsIG9iamVjdCkgJiYgJGRlZmluZVByb3BlcnR5O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KCk7XG4gICAgICBjb25zdCBjb2RlUG9pbnRBdCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJpbmcgPSBTdHJpbmcodGhpcyk7XG4gICAgICAgIGNvbnN0IHNpemUgPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgICBsZXQgaW5kZXggPSBwb3NpdGlvbiA/IE51bWJlcihwb3NpdGlvbikgOiAwO1xuICAgICAgICBpZiAoaW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc2l6ZSkge1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlyc3QgPSBzdHJpbmcuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgIGxldCBzZWNvbmQ7XG4gICAgICAgIGlmIChmaXJzdCA+PSA1NTI5NiAmJiBmaXJzdCA8PSA1NjMxOSAmJiBzaXplID4gaW5kZXggKyAxKSB7XG4gICAgICAgICAgc2Vjb25kID0gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcbiAgICAgICAgICBpZiAoc2Vjb25kID49IDU2MzIwICYmIHNlY29uZCA8PSA1NzM0Mykge1xuICAgICAgICAgICAgcmV0dXJuIChmaXJzdCAtIDU1Mjk2KSAqIDEwMjQgKyBzZWNvbmQgLSA1NjMyMCArIDY1NTM2O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlyc3Q7XG4gICAgICB9O1xuICAgICAgaWYgKGRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KFN0cmluZy5wcm90b3R5cGUsIFwiY29kZVBvaW50QXRcIiwge1xuICAgICAgICAgIHZhbHVlOiBjb2RlUG9pbnRBdCxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0ID0gY29kZVBvaW50QXQ7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjQvc3JjL2FudGxyNC9kZmEvREZBU2VyaWFsaXplci5qc1xudmFyIHJlcXVpcmVfREZBU2VyaWFsaXplcjIgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUyKSA9PiB7XG4gIHZhciBERkFTZXJpYWxpemVyID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGRmYSwgbGl0ZXJhbE5hbWVzLCBzeW1ib2xpY05hbWVzKSB7XG4gICAgICB0aGlzLmRmYSA9IGRmYTtcbiAgICAgIHRoaXMubGl0ZXJhbE5hbWVzID0gbGl0ZXJhbE5hbWVzIHx8IFtdO1xuICAgICAgdGhpcy5zeW1ib2xpY05hbWVzID0gc3ltYm9saWNOYW1lcyB8fCBbXTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICBpZiAodGhpcy5kZmEuczAgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBsZXQgYnVmID0gXCJcIjtcbiAgICAgIGNvbnN0IHN0YXRlcyA9IHRoaXMuZGZhLnNvcnRlZFN0YXRlcygpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcyA9IHN0YXRlc1tpXTtcbiAgICAgICAgaWYgKHMuZWRnZXMgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBuID0gcy5lZGdlcy5sZW5ndGg7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBzLmVkZ2VzW2pdIHx8IG51bGw7XG4gICAgICAgICAgICBpZiAodCAhPT0gbnVsbCAmJiB0LnN0YXRlTnVtYmVyICE9PSAyMTQ3NDgzNjQ3KSB7XG4gICAgICAgICAgICAgIGJ1ZiA9IGJ1Zi5jb25jYXQodGhpcy5nZXRTdGF0ZVN0cmluZyhzKSk7XG4gICAgICAgICAgICAgIGJ1ZiA9IGJ1Zi5jb25jYXQoXCItXCIpO1xuICAgICAgICAgICAgICBidWYgPSBidWYuY29uY2F0KHRoaXMuZ2V0RWRnZUxhYmVsKGopKTtcbiAgICAgICAgICAgICAgYnVmID0gYnVmLmNvbmNhdChcIi0+XCIpO1xuICAgICAgICAgICAgICBidWYgPSBidWYuY29uY2F0KHRoaXMuZ2V0U3RhdGVTdHJpbmcodCkpO1xuICAgICAgICAgICAgICBidWYgPSBidWYuY29uY2F0KFwiXFxuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5sZW5ndGggPT09IDAgPyBudWxsIDogYnVmO1xuICAgIH1cbiAgICBnZXRFZGdlTGFiZWwoaSkge1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFwiRU9GXCI7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubGl0ZXJhbE5hbWVzICE9PSBudWxsIHx8IHRoaXMuc3ltYm9saWNOYW1lcyAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXRlcmFsTmFtZXNbaSAtIDFdIHx8IHRoaXMuc3ltYm9saWNOYW1lc1tpIC0gMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShpIC0gMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGdldFN0YXRlU3RyaW5nKHMpIHtcbiAgICAgIGNvbnN0IGJhc2VTdGF0ZVN0ciA9IChzLmlzQWNjZXB0U3RhdGUgPyBcIjpcIiA6IFwiXCIpICsgXCJzXCIgKyBzLnN0YXRlTnVtYmVyICsgKHMucmVxdWlyZXNGdWxsQ29udGV4dCA/IFwiXlwiIDogXCJcIik7XG4gICAgICBpZiAocy5pc0FjY2VwdFN0YXRlKSB7XG4gICAgICAgIGlmIChzLnByZWRpY2F0ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZVN0YXRlU3RyICsgXCI9PlwiICsgcy5wcmVkaWNhdGVzLnRvU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VTdGF0ZVN0ciArIFwiPT5cIiArIHMucHJlZGljdGlvbi50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYmFzZVN0YXRlU3RyO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIExleGVyREZBU2VyaWFsaXplciA9IGNsYXNzIGV4dGVuZHMgREZBU2VyaWFsaXplciB7XG4gICAgY29uc3RydWN0b3IoZGZhKSB7XG4gICAgICBzdXBlcihkZmEsIG51bGwpO1xuICAgIH1cbiAgICBnZXRFZGdlTGFiZWwoaSkge1xuICAgICAgcmV0dXJuIFwiJ1wiICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKSArIFwiJ1wiO1xuICAgIH1cbiAgfTtcbiAgbW9kdWxlMi5leHBvcnRzID0ge0RGQVNlcmlhbGl6ZXIsIExleGVyREZBU2VyaWFsaXplcn07XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNC9zcmMvYW50bHI0L2RmYS9ERkEuanNcbnZhciByZXF1aXJlX0RGQTIgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUyKSA9PiB7XG4gIHZhciB7U2V0OiBTZXQyfSA9IHJlcXVpcmVfVXRpbHMyKCk7XG4gIHZhciB7REZBU3RhdGV9ID0gcmVxdWlyZV9ERkFTdGF0ZTIoKTtcbiAgdmFyIHtTdGFyTG9vcEVudHJ5U3RhdGV9ID0gcmVxdWlyZV9BVE5TdGF0ZTIoKTtcbiAgdmFyIHtBVE5Db25maWdTZXR9ID0gcmVxdWlyZV9BVE5Db25maWdTZXQyKCk7XG4gIHZhciB7REZBU2VyaWFsaXplcn0gPSByZXF1aXJlX0RGQVNlcmlhbGl6ZXIyKCk7XG4gIHZhciB7TGV4ZXJERkFTZXJpYWxpemVyfSA9IHJlcXVpcmVfREZBU2VyaWFsaXplcjIoKTtcbiAgdmFyIERGQSA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihhdG5TdGFydFN0YXRlLCBkZWNpc2lvbikge1xuICAgICAgaWYgKGRlY2lzaW9uID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVjaXNpb24gPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5hdG5TdGFydFN0YXRlID0gYXRuU3RhcnRTdGF0ZTtcbiAgICAgIHRoaXMuZGVjaXNpb24gPSBkZWNpc2lvbjtcbiAgICAgIHRoaXMuX3N0YXRlcyA9IG5ldyBTZXQyKCk7XG4gICAgICB0aGlzLnMwID0gbnVsbDtcbiAgICAgIHRoaXMucHJlY2VkZW5jZURmYSA9IGZhbHNlO1xuICAgICAgaWYgKGF0blN0YXJ0U3RhdGUgaW5zdGFuY2VvZiBTdGFyTG9vcEVudHJ5U3RhdGUpIHtcbiAgICAgICAgaWYgKGF0blN0YXJ0U3RhdGUuaXNQcmVjZWRlbmNlRGVjaXNpb24pIHtcbiAgICAgICAgICB0aGlzLnByZWNlZGVuY2VEZmEgPSB0cnVlO1xuICAgICAgICAgIGNvbnN0IHByZWNlZGVuY2VTdGF0ZSA9IG5ldyBERkFTdGF0ZShudWxsLCBuZXcgQVROQ29uZmlnU2V0KCkpO1xuICAgICAgICAgIHByZWNlZGVuY2VTdGF0ZS5lZGdlcyA9IFtdO1xuICAgICAgICAgIHByZWNlZGVuY2VTdGF0ZS5pc0FjY2VwdFN0YXRlID0gZmFsc2U7XG4gICAgICAgICAgcHJlY2VkZW5jZVN0YXRlLnJlcXVpcmVzRnVsbENvbnRleHQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnMwID0gcHJlY2VkZW5jZVN0YXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGdldFByZWNlZGVuY2VTdGFydFN0YXRlKHByZWNlZGVuY2UpIHtcbiAgICAgIGlmICghdGhpcy5wcmVjZWRlbmNlRGZhKSB7XG4gICAgICAgIHRocm93IFwiT25seSBwcmVjZWRlbmNlIERGQXMgbWF5IGNvbnRhaW4gYSBwcmVjZWRlbmNlIHN0YXJ0IHN0YXRlLlwiO1xuICAgICAgfVxuICAgICAgaWYgKHByZWNlZGVuY2UgPCAwIHx8IHByZWNlZGVuY2UgPj0gdGhpcy5zMC5lZGdlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zMC5lZGdlc1twcmVjZWRlbmNlXSB8fCBudWxsO1xuICAgIH1cbiAgICBzZXRQcmVjZWRlbmNlU3RhcnRTdGF0ZShwcmVjZWRlbmNlLCBzdGFydFN0YXRlKSB7XG4gICAgICBpZiAoIXRoaXMucHJlY2VkZW5jZURmYSkge1xuICAgICAgICB0aHJvdyBcIk9ubHkgcHJlY2VkZW5jZSBERkFzIG1heSBjb250YWluIGEgcHJlY2VkZW5jZSBzdGFydCBzdGF0ZS5cIjtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVjZWRlbmNlIDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnMwLmVkZ2VzW3ByZWNlZGVuY2VdID0gc3RhcnRTdGF0ZTtcbiAgICB9XG4gICAgc2V0UHJlY2VkZW5jZURmYShwcmVjZWRlbmNlRGZhKSB7XG4gICAgICBpZiAodGhpcy5wcmVjZWRlbmNlRGZhICE9PSBwcmVjZWRlbmNlRGZhKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlcyA9IG5ldyBTZXQyKCk7XG4gICAgICAgIGlmIChwcmVjZWRlbmNlRGZhKSB7XG4gICAgICAgICAgY29uc3QgcHJlY2VkZW5jZVN0YXRlID0gbmV3IERGQVN0YXRlKG51bGwsIG5ldyBBVE5Db25maWdTZXQoKSk7XG4gICAgICAgICAgcHJlY2VkZW5jZVN0YXRlLmVkZ2VzID0gW107XG4gICAgICAgICAgcHJlY2VkZW5jZVN0YXRlLmlzQWNjZXB0U3RhdGUgPSBmYWxzZTtcbiAgICAgICAgICBwcmVjZWRlbmNlU3RhdGUucmVxdWlyZXNGdWxsQ29udGV4dCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuczAgPSBwcmVjZWRlbmNlU3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zMCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVjZWRlbmNlRGZhID0gcHJlY2VkZW5jZURmYTtcbiAgICAgIH1cbiAgICB9XG4gICAgc29ydGVkU3RhdGVzKCkge1xuICAgICAgY29uc3QgbGlzdCA9IHRoaXMuX3N0YXRlcy52YWx1ZXMoKTtcbiAgICAgIHJldHVybiBsaXN0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gYS5zdGF0ZU51bWJlciAtIGIuc3RhdGVOdW1iZXI7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdG9TdHJpbmcobGl0ZXJhbE5hbWVzLCBzeW1ib2xpY05hbWVzKSB7XG4gICAgICBsaXRlcmFsTmFtZXMgPSBsaXRlcmFsTmFtZXMgfHwgbnVsbDtcbiAgICAgIHN5bWJvbGljTmFtZXMgPSBzeW1ib2xpY05hbWVzIHx8IG51bGw7XG4gICAgICBpZiAodGhpcy5zMCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgREZBU2VyaWFsaXplcih0aGlzLCBsaXRlcmFsTmFtZXMsIHN5bWJvbGljTmFtZXMpO1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZXIudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgdG9MZXhlclN0cmluZygpIHtcbiAgICAgIGlmICh0aGlzLnMwID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VyaWFsaXplciA9IG5ldyBMZXhlckRGQVNlcmlhbGl6ZXIodGhpcyk7XG4gICAgICByZXR1cm4gc2VyaWFsaXplci50b1N0cmluZygpO1xuICAgIH1cbiAgICBnZXQgc3RhdGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlcztcbiAgICB9XG4gIH07XG4gIG1vZHVsZTIuZXhwb3J0cyA9IERGQTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0L3NyYy9hbnRscjQvZGZhL2luZGV4LmpzXG52YXIgcmVxdWlyZV9kZmEgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIGV4cG9ydHMuREZBID0gcmVxdWlyZV9ERkEyKCk7XG4gIGV4cG9ydHMuREZBU2VyaWFsaXplciA9IHJlcXVpcmVfREZBU2VyaWFsaXplcjIoKS5ERkFTZXJpYWxpemVyO1xuICBleHBvcnRzLkxleGVyREZBU2VyaWFsaXplciA9IHJlcXVpcmVfREZBU2VyaWFsaXplcjIoKS5MZXhlckRGQVNlcmlhbGl6ZXI7XG4gIGV4cG9ydHMuUHJlZFByZWRpY3Rpb24gPSByZXF1aXJlX0RGQVN0YXRlMigpLlByZWRQcmVkaWN0aW9uO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjQvc3JjL2FudGxyNC9wb2x5ZmlsbHMvZnJvbWNvZGVwb2ludC5qc1xudmFyIHJlcXVpcmVfZnJvbWNvZGVwb2ludCA9IF9fY29tbW9uSlMoKCkgPT4ge1xuICBpZiAoIVN0cmluZy5mcm9tQ29kZVBvaW50KSB7XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBvYmplY3QgPSB7fTtcbiAgICAgICAgICBjb25zdCAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gICAgICAgICAgcmVzdWx0ID0gJGRlZmluZVByb3BlcnR5KG9iamVjdCwgb2JqZWN0LCBvYmplY3QpICYmICRkZWZpbmVQcm9wZXJ0eTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSgpO1xuICAgICAgY29uc3Qgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbiAgICAgIGNvbnN0IGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgIGNvbnN0IGZyb21Db2RlUG9pbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIGNvbnN0IE1BWF9TSVpFID0gMTYzODQ7XG4gICAgICAgIGNvbnN0IGNvZGVVbml0cyA9IFtdO1xuICAgICAgICBsZXQgaGlnaFN1cnJvZ2F0ZTtcbiAgICAgICAgbGV0IGxvd1N1cnJvZ2F0ZTtcbiAgICAgICAgbGV0IGluZGV4ID0gLTE7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgbGV0IGNvZGVQb2ludCA9IE51bWJlcihhcmd1bWVudHNbaW5kZXhdKTtcbiAgICAgICAgICBpZiAoIWlzRmluaXRlKGNvZGVQb2ludCkgfHwgY29kZVBvaW50IDwgMCB8fCBjb2RlUG9pbnQgPiAxMTE0MTExIHx8IGZsb29yKGNvZGVQb2ludCkgIT09IGNvZGVQb2ludCkge1xuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIkludmFsaWQgY29kZSBwb2ludDogXCIgKyBjb2RlUG9pbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29kZVBvaW50IDw9IDY1NTM1KSB7XG4gICAgICAgICAgICBjb2RlVW5pdHMucHVzaChjb2RlUG9pbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgLT0gNjU1MzY7XG4gICAgICAgICAgICBoaWdoU3Vycm9nYXRlID0gKGNvZGVQb2ludCA+PiAxMCkgKyA1NTI5NjtcbiAgICAgICAgICAgIGxvd1N1cnJvZ2F0ZSA9IGNvZGVQb2ludCAlIDEwMjQgKyA1NjMyMDtcbiAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGhpZ2hTdXJyb2dhdGUsIGxvd1N1cnJvZ2F0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmRleCArIDEgPT09IGxlbmd0aCB8fCBjb2RlVW5pdHMubGVuZ3RoID4gTUFYX1NJWkUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmdGcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY29kZVVuaXRzKTtcbiAgICAgICAgICAgIGNvZGVVbml0cy5sZW5ndGggPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIGlmIChkZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShTdHJpbmcsIFwiZnJvbUNvZGVQb2ludFwiLCB7XG4gICAgICAgICAgdmFsdWU6IGZyb21Db2RlUG9pbnQsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgU3RyaW5nLmZyb21Db2RlUG9pbnQgPSBmcm9tQ29kZVBvaW50O1xuICAgICAgfVxuICAgIH0pKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0L3NyYy9hbnRscjQvdHJlZS9pbmRleC5qc1xudmFyIHJlcXVpcmVfdHJlZSA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZTIpID0+IHtcbiAgdmFyIFRyZWUgPSByZXF1aXJlX1RyZWUoKTtcbiAgdmFyIFRyZWVzID0gcmVxdWlyZV9UcmVlczIoKTtcbiAgbW9kdWxlMi5leHBvcnRzID0gX19vYmpTcHJlYWQoX19vYmpTcHJlYWQoe30sIFRyZWUpLCB7VHJlZXN9KTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0L3NyYy9hbnRscjQvZXJyb3IvRGlhZ25vc3RpY0Vycm9yTGlzdGVuZXIuanNcbnZhciByZXF1aXJlX0RpYWdub3N0aWNFcnJvckxpc3RlbmVyMiA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZTIpID0+IHtcbiAgdmFyIHtCaXRTZXR9ID0gcmVxdWlyZV9VdGlsczIoKTtcbiAgdmFyIHtFcnJvckxpc3RlbmVyOiBFcnJvckxpc3RlbmVyMn0gPSByZXF1aXJlX0Vycm9yTGlzdGVuZXIoKTtcbiAgdmFyIHtJbnRlcnZhbH0gPSByZXF1aXJlX0ludGVydmFsU2V0MigpO1xuICB2YXIgRGlhZ25vc3RpY0Vycm9yTGlzdGVuZXIgPSBjbGFzcyBleHRlbmRzIEVycm9yTGlzdGVuZXIyIHtcbiAgICBjb25zdHJ1Y3RvcihleGFjdE9ubHkpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICBleGFjdE9ubHkgPSBleGFjdE9ubHkgfHwgdHJ1ZTtcbiAgICAgIHRoaXMuZXhhY3RPbmx5ID0gZXhhY3RPbmx5O1xuICAgIH1cbiAgICByZXBvcnRBbWJpZ3VpdHkocmVjb2duaXplciwgZGZhLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIGV4YWN0LCBhbWJpZ0FsdHMsIGNvbmZpZ3MpIHtcbiAgICAgIGlmICh0aGlzLmV4YWN0T25seSAmJiAhZXhhY3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbXNnID0gXCJyZXBvcnRBbWJpZ3VpdHkgZD1cIiArIHRoaXMuZ2V0RGVjaXNpb25EZXNjcmlwdGlvbihyZWNvZ25pemVyLCBkZmEpICsgXCI6IGFtYmlnQWx0cz1cIiArIHRoaXMuZ2V0Q29uZmxpY3RpbmdBbHRzKGFtYmlnQWx0cywgY29uZmlncykgKyBcIiwgaW5wdXQ9J1wiICsgcmVjb2duaXplci5nZXRUb2tlblN0cmVhbSgpLmdldFRleHQobmV3IEludGVydmFsKHN0YXJ0SW5kZXgsIHN0b3BJbmRleCkpICsgXCInXCI7XG4gICAgICByZWNvZ25pemVyLm5vdGlmeUVycm9yTGlzdGVuZXJzKG1zZyk7XG4gICAgfVxuICAgIHJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dChyZWNvZ25pemVyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgY29uZmxpY3RpbmdBbHRzLCBjb25maWdzKSB7XG4gICAgICBjb25zdCBtc2cgPSBcInJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dCBkPVwiICsgdGhpcy5nZXREZWNpc2lvbkRlc2NyaXB0aW9uKHJlY29nbml6ZXIsIGRmYSkgKyBcIiwgaW5wdXQ9J1wiICsgcmVjb2duaXplci5nZXRUb2tlblN0cmVhbSgpLmdldFRleHQobmV3IEludGVydmFsKHN0YXJ0SW5kZXgsIHN0b3BJbmRleCkpICsgXCInXCI7XG4gICAgICByZWNvZ25pemVyLm5vdGlmeUVycm9yTGlzdGVuZXJzKG1zZyk7XG4gICAgfVxuICAgIHJlcG9ydENvbnRleHRTZW5zaXRpdml0eShyZWNvZ25pemVyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgcHJlZGljdGlvbiwgY29uZmlncykge1xuICAgICAgY29uc3QgbXNnID0gXCJyZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHkgZD1cIiArIHRoaXMuZ2V0RGVjaXNpb25EZXNjcmlwdGlvbihyZWNvZ25pemVyLCBkZmEpICsgXCIsIGlucHV0PSdcIiArIHJlY29nbml6ZXIuZ2V0VG9rZW5TdHJlYW0oKS5nZXRUZXh0KG5ldyBJbnRlcnZhbChzdGFydEluZGV4LCBzdG9wSW5kZXgpKSArIFwiJ1wiO1xuICAgICAgcmVjb2duaXplci5ub3RpZnlFcnJvckxpc3RlbmVycyhtc2cpO1xuICAgIH1cbiAgICBnZXREZWNpc2lvbkRlc2NyaXB0aW9uKHJlY29nbml6ZXIsIGRmYSkge1xuICAgICAgY29uc3QgZGVjaXNpb24gPSBkZmEuZGVjaXNpb247XG4gICAgICBjb25zdCBydWxlSW5kZXggPSBkZmEuYXRuU3RhcnRTdGF0ZS5ydWxlSW5kZXg7XG4gICAgICBjb25zdCBydWxlTmFtZXMgPSByZWNvZ25pemVyLnJ1bGVOYW1lcztcbiAgICAgIGlmIChydWxlSW5kZXggPCAwIHx8IHJ1bGVJbmRleCA+PSBydWxlTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgZGVjaXNpb247XG4gICAgICB9XG4gICAgICBjb25zdCBydWxlTmFtZSA9IHJ1bGVOYW1lc1tydWxlSW5kZXhdIHx8IG51bGw7XG4gICAgICBpZiAocnVsZU5hbWUgPT09IG51bGwgfHwgcnVsZU5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgZGVjaXNpb247XG4gICAgICB9XG4gICAgICByZXR1cm4gYCR7ZGVjaXNpb259ICgke3J1bGVOYW1lfSlgO1xuICAgIH1cbiAgICBnZXRDb25mbGljdGluZ0FsdHMocmVwb3J0ZWRBbHRzLCBjb25maWdzKSB7XG4gICAgICBpZiAocmVwb3J0ZWRBbHRzICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXBvcnRlZEFsdHM7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBuZXcgQml0U2V0KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbmZpZ3MuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LmFkZChjb25maWdzLml0ZW1zW2ldLmFsdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYHske3Jlc3VsdC52YWx1ZXMoKS5qb2luKFwiLCBcIil9fWA7XG4gICAgfVxuICB9O1xuICBtb2R1bGUyLmV4cG9ydHMgPSBEaWFnbm9zdGljRXJyb3JMaXN0ZW5lcjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0L3NyYy9hbnRscjQvZXJyb3IvRXJyb3JTdHJhdGVneS5qc1xudmFyIHJlcXVpcmVfRXJyb3JTdHJhdGVneSA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZTIpID0+IHtcbiAgdmFyIHtUb2tlbjogVG9rZW4yfSA9IHJlcXVpcmVfVG9rZW4yKCk7XG4gIHZhciB7Tm9WaWFibGVBbHRFeGNlcHRpb246IE5vVmlhYmxlQWx0RXhjZXB0aW9uMiwgSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbiwgRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uOiBGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24yLCBQYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbn0gPSByZXF1aXJlX0Vycm9ycygpO1xuICB2YXIge0FUTlN0YXRlfSA9IHJlcXVpcmVfQVROU3RhdGUyKCk7XG4gIHZhciB7SW50ZXJ2YWwsIEludGVydmFsU2V0fSA9IHJlcXVpcmVfSW50ZXJ2YWxTZXQyKCk7XG4gIHZhciBFcnJvclN0cmF0ZWd5ID0gY2xhc3Mge1xuICAgIHJlc2V0KHJlY29nbml6ZXIpIHtcbiAgICB9XG4gICAgcmVjb3ZlcklubGluZShyZWNvZ25pemVyKSB7XG4gICAgfVxuICAgIHJlY292ZXIocmVjb2duaXplciwgZSkge1xuICAgIH1cbiAgICBzeW5jKHJlY29nbml6ZXIpIHtcbiAgICB9XG4gICAgaW5FcnJvclJlY292ZXJ5TW9kZShyZWNvZ25pemVyKSB7XG4gICAgfVxuICAgIHJlcG9ydEVycm9yKHJlY29nbml6ZXIpIHtcbiAgICB9XG4gIH07XG4gIHZhciBEZWZhdWx0RXJyb3JTdHJhdGVneSA9IGNsYXNzIGV4dGVuZHMgRXJyb3JTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5lcnJvclJlY292ZXJ5TW9kZSA9IGZhbHNlO1xuICAgICAgdGhpcy5sYXN0RXJyb3JJbmRleCA9IC0xO1xuICAgICAgdGhpcy5sYXN0RXJyb3JTdGF0ZXMgPSBudWxsO1xuICAgICAgdGhpcy5uZXh0VG9rZW5zQ29udGV4dCA9IG51bGw7XG4gICAgICB0aGlzLm5leHRUb2tlblN0YXRlID0gMDtcbiAgICB9XG4gICAgcmVzZXQocmVjb2duaXplcikge1xuICAgICAgdGhpcy5lbmRFcnJvckNvbmRpdGlvbihyZWNvZ25pemVyKTtcbiAgICB9XG4gICAgYmVnaW5FcnJvckNvbmRpdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICB0aGlzLmVycm9yUmVjb3ZlcnlNb2RlID0gdHJ1ZTtcbiAgICB9XG4gICAgaW5FcnJvclJlY292ZXJ5TW9kZShyZWNvZ25pemVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcnJvclJlY292ZXJ5TW9kZTtcbiAgICB9XG4gICAgZW5kRXJyb3JDb25kaXRpb24ocmVjb2duaXplcikge1xuICAgICAgdGhpcy5lcnJvclJlY292ZXJ5TW9kZSA9IGZhbHNlO1xuICAgICAgdGhpcy5sYXN0RXJyb3JTdGF0ZXMgPSBudWxsO1xuICAgICAgdGhpcy5sYXN0RXJyb3JJbmRleCA9IC0xO1xuICAgIH1cbiAgICByZXBvcnRNYXRjaChyZWNvZ25pemVyKSB7XG4gICAgICB0aGlzLmVuZEVycm9yQ29uZGl0aW9uKHJlY29nbml6ZXIpO1xuICAgIH1cbiAgICByZXBvcnRFcnJvcihyZWNvZ25pemVyLCBlKSB7XG4gICAgICBpZiAodGhpcy5pbkVycm9yUmVjb3ZlcnlNb2RlKHJlY29nbml6ZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYmVnaW5FcnJvckNvbmRpdGlvbihyZWNvZ25pemVyKTtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgTm9WaWFibGVBbHRFeGNlcHRpb24yKSB7XG4gICAgICAgIHRoaXMucmVwb3J0Tm9WaWFibGVBbHRlcm5hdGl2ZShyZWNvZ25pemVyLCBlKTtcbiAgICAgIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIElucHV0TWlzbWF0Y2hFeGNlcHRpb24pIHtcbiAgICAgICAgdGhpcy5yZXBvcnRJbnB1dE1pc21hdGNoKHJlY29nbml6ZXIsIGUpO1xuICAgICAgfSBlbHNlIGlmIChlIGluc3RhbmNlb2YgRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uMikge1xuICAgICAgICB0aGlzLnJlcG9ydEZhaWxlZFByZWRpY2F0ZShyZWNvZ25pemVyLCBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwidW5rbm93biByZWNvZ25pdGlvbiBlcnJvciB0eXBlOiBcIiArIGUuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGUuc3RhY2spO1xuICAgICAgICByZWNvZ25pemVyLm5vdGlmeUVycm9yTGlzdGVuZXJzKGUuZ2V0T2ZmZW5kaW5nVG9rZW4oKSwgZS5nZXRNZXNzYWdlKCksIGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZWNvdmVyKHJlY29nbml6ZXIsIGUpIHtcbiAgICAgIGlmICh0aGlzLmxhc3RFcnJvckluZGV4ID09PSByZWNvZ25pemVyLmdldElucHV0U3RyZWFtKCkuaW5kZXggJiYgdGhpcy5sYXN0RXJyb3JTdGF0ZXMgIT09IG51bGwgJiYgdGhpcy5sYXN0RXJyb3JTdGF0ZXMuaW5kZXhPZihyZWNvZ25pemVyLnN0YXRlKSA+PSAwKSB7XG4gICAgICAgIHJlY29nbml6ZXIuY29uc3VtZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5sYXN0RXJyb3JJbmRleCA9IHJlY29nbml6ZXIuX2lucHV0LmluZGV4O1xuICAgICAgaWYgKHRoaXMubGFzdEVycm9yU3RhdGVzID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMubGFzdEVycm9yU3RhdGVzID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RFcnJvclN0YXRlcy5wdXNoKHJlY29nbml6ZXIuc3RhdGUpO1xuICAgICAgY29uc3QgZm9sbG93U2V0ID0gdGhpcy5nZXRFcnJvclJlY292ZXJ5U2V0KHJlY29nbml6ZXIpO1xuICAgICAgdGhpcy5jb25zdW1lVW50aWwocmVjb2duaXplciwgZm9sbG93U2V0KTtcbiAgICB9XG4gICAgc3luYyhyZWNvZ25pemVyKSB7XG4gICAgICBpZiAodGhpcy5pbkVycm9yUmVjb3ZlcnlNb2RlKHJlY29nbml6ZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHMgPSByZWNvZ25pemVyLl9pbnRlcnAuYXRuLnN0YXRlc1tyZWNvZ25pemVyLnN0YXRlXTtcbiAgICAgIGNvbnN0IGxhID0gcmVjb2duaXplci5nZXRUb2tlblN0cmVhbSgpLkxBKDEpO1xuICAgICAgY29uc3QgbmV4dFRva2VucyA9IHJlY29nbml6ZXIuYXRuLm5leHRUb2tlbnMocyk7XG4gICAgICBpZiAobmV4dFRva2Vucy5jb250YWlucyhsYSkpIHtcbiAgICAgICAgdGhpcy5uZXh0VG9rZW5zQ29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dFRva2VuU3RhdGUgPSBBVE5TdGF0ZS5JTlZBTElEX1NUQVRFX05VTUJFUjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChuZXh0VG9rZW5zLmNvbnRhaW5zKFRva2VuMi5FUFNJTE9OKSkge1xuICAgICAgICBpZiAodGhpcy5uZXh0VG9rZW5zQ29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMubmV4dFRva2Vuc0NvbnRleHQgPSByZWNvZ25pemVyLl9jdHg7XG4gICAgICAgICAgdGhpcy5uZXh0VG9rZW5zU3RhdGUgPSByZWNvZ25pemVyLl9zdGF0ZU51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHMuc3RhdGVUeXBlKSB7XG4gICAgICAgIGNhc2UgQVROU3RhdGUuQkxPQ0tfU1RBUlQ6XG4gICAgICAgIGNhc2UgQVROU3RhdGUuU1RBUl9CTE9DS19TVEFSVDpcbiAgICAgICAgY2FzZSBBVE5TdGF0ZS5QTFVTX0JMT0NLX1NUQVJUOlxuICAgICAgICBjYXNlIEFUTlN0YXRlLlNUQVJfTE9PUF9FTlRSWTpcbiAgICAgICAgICBpZiAodGhpcy5zaW5nbGVUb2tlbkRlbGV0aW9uKHJlY29nbml6ZXIpICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnB1dE1pc21hdGNoRXhjZXB0aW9uKHJlY29nbml6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBBVE5TdGF0ZS5QTFVTX0xPT1BfQkFDSzpcbiAgICAgICAgY2FzZSBBVE5TdGF0ZS5TVEFSX0xPT1BfQkFDSzpcbiAgICAgICAgICB0aGlzLnJlcG9ydFVud2FudGVkVG9rZW4ocmVjb2duaXplcik7XG4gICAgICAgICAgY29uc3QgZXhwZWN0aW5nID0gbmV3IEludGVydmFsU2V0KCk7XG4gICAgICAgICAgZXhwZWN0aW5nLmFkZFNldChyZWNvZ25pemVyLmdldEV4cGVjdGVkVG9rZW5zKCkpO1xuICAgICAgICAgIGNvbnN0IHdoYXRGb2xsb3dzTG9vcEl0ZXJhdGlvbk9yUnVsZSA9IGV4cGVjdGluZy5hZGRTZXQodGhpcy5nZXRFcnJvclJlY292ZXJ5U2V0KHJlY29nbml6ZXIpKTtcbiAgICAgICAgICB0aGlzLmNvbnN1bWVVbnRpbChyZWNvZ25pemVyLCB3aGF0Rm9sbG93c0xvb3BJdGVyYXRpb25PclJ1bGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH1cbiAgICByZXBvcnROb1ZpYWJsZUFsdGVybmF0aXZlKHJlY29nbml6ZXIsIGUpIHtcbiAgICAgIGNvbnN0IHRva2VuczIgPSByZWNvZ25pemVyLmdldFRva2VuU3RyZWFtKCk7XG4gICAgICBsZXQgaW5wdXQ7XG4gICAgICBpZiAodG9rZW5zMiAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoZS5zdGFydFRva2VuLnR5cGUgPT09IFRva2VuMi5FT0YpIHtcbiAgICAgICAgICBpbnB1dCA9IFwiPEVPRj5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnB1dCA9IHRva2VuczIuZ2V0VGV4dChuZXcgSW50ZXJ2YWwoZS5zdGFydFRva2VuLnRva2VuSW5kZXgsIGUub2ZmZW5kaW5nVG9rZW4udG9rZW5JbmRleCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dCA9IFwiPHVua25vd24gaW5wdXQ+XCI7XG4gICAgICB9XG4gICAgICBjb25zdCBtc2cgPSBcIm5vIHZpYWJsZSBhbHRlcm5hdGl2ZSBhdCBpbnB1dCBcIiArIHRoaXMuZXNjYXBlV1NBbmRRdW90ZShpbnB1dCk7XG4gICAgICByZWNvZ25pemVyLm5vdGlmeUVycm9yTGlzdGVuZXJzKG1zZywgZS5vZmZlbmRpbmdUb2tlbiwgZSk7XG4gICAgfVxuICAgIHJlcG9ydElucHV0TWlzbWF0Y2gocmVjb2duaXplciwgZSkge1xuICAgICAgY29uc3QgbXNnID0gXCJtaXNtYXRjaGVkIGlucHV0IFwiICsgdGhpcy5nZXRUb2tlbkVycm9yRGlzcGxheShlLm9mZmVuZGluZ1Rva2VuKSArIFwiIGV4cGVjdGluZyBcIiArIGUuZ2V0RXhwZWN0ZWRUb2tlbnMoKS50b1N0cmluZyhyZWNvZ25pemVyLmxpdGVyYWxOYW1lcywgcmVjb2duaXplci5zeW1ib2xpY05hbWVzKTtcbiAgICAgIHJlY29nbml6ZXIubm90aWZ5RXJyb3JMaXN0ZW5lcnMobXNnLCBlLm9mZmVuZGluZ1Rva2VuLCBlKTtcbiAgICB9XG4gICAgcmVwb3J0RmFpbGVkUHJlZGljYXRlKHJlY29nbml6ZXIsIGUpIHtcbiAgICAgIGNvbnN0IHJ1bGVOYW1lID0gcmVjb2duaXplci5ydWxlTmFtZXNbcmVjb2duaXplci5fY3R4LnJ1bGVJbmRleF07XG4gICAgICBjb25zdCBtc2cgPSBcInJ1bGUgXCIgKyBydWxlTmFtZSArIFwiIFwiICsgZS5tZXNzYWdlO1xuICAgICAgcmVjb2duaXplci5ub3RpZnlFcnJvckxpc3RlbmVycyhtc2csIGUub2ZmZW5kaW5nVG9rZW4sIGUpO1xuICAgIH1cbiAgICByZXBvcnRVbndhbnRlZFRva2VuKHJlY29nbml6ZXIpIHtcbiAgICAgIGlmICh0aGlzLmluRXJyb3JSZWNvdmVyeU1vZGUocmVjb2duaXplcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5iZWdpbkVycm9yQ29uZGl0aW9uKHJlY29nbml6ZXIpO1xuICAgICAgY29uc3QgdCA9IHJlY29nbml6ZXIuZ2V0Q3VycmVudFRva2VuKCk7XG4gICAgICBjb25zdCB0b2tlbk5hbWUgPSB0aGlzLmdldFRva2VuRXJyb3JEaXNwbGF5KHQpO1xuICAgICAgY29uc3QgZXhwZWN0aW5nID0gdGhpcy5nZXRFeHBlY3RlZFRva2VucyhyZWNvZ25pemVyKTtcbiAgICAgIGNvbnN0IG1zZyA9IFwiZXh0cmFuZW91cyBpbnB1dCBcIiArIHRva2VuTmFtZSArIFwiIGV4cGVjdGluZyBcIiArIGV4cGVjdGluZy50b1N0cmluZyhyZWNvZ25pemVyLmxpdGVyYWxOYW1lcywgcmVjb2duaXplci5zeW1ib2xpY05hbWVzKTtcbiAgICAgIHJlY29nbml6ZXIubm90aWZ5RXJyb3JMaXN0ZW5lcnMobXNnLCB0LCBudWxsKTtcbiAgICB9XG4gICAgcmVwb3J0TWlzc2luZ1Rva2VuKHJlY29nbml6ZXIpIHtcbiAgICAgIGlmICh0aGlzLmluRXJyb3JSZWNvdmVyeU1vZGUocmVjb2duaXplcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5iZWdpbkVycm9yQ29uZGl0aW9uKHJlY29nbml6ZXIpO1xuICAgICAgY29uc3QgdCA9IHJlY29nbml6ZXIuZ2V0Q3VycmVudFRva2VuKCk7XG4gICAgICBjb25zdCBleHBlY3RpbmcgPSB0aGlzLmdldEV4cGVjdGVkVG9rZW5zKHJlY29nbml6ZXIpO1xuICAgICAgY29uc3QgbXNnID0gXCJtaXNzaW5nIFwiICsgZXhwZWN0aW5nLnRvU3RyaW5nKHJlY29nbml6ZXIubGl0ZXJhbE5hbWVzLCByZWNvZ25pemVyLnN5bWJvbGljTmFtZXMpICsgXCIgYXQgXCIgKyB0aGlzLmdldFRva2VuRXJyb3JEaXNwbGF5KHQpO1xuICAgICAgcmVjb2duaXplci5ub3RpZnlFcnJvckxpc3RlbmVycyhtc2csIHQsIG51bGwpO1xuICAgIH1cbiAgICByZWNvdmVySW5saW5lKHJlY29nbml6ZXIpIHtcbiAgICAgIGNvbnN0IG1hdGNoZWRTeW1ib2wgPSB0aGlzLnNpbmdsZVRva2VuRGVsZXRpb24ocmVjb2duaXplcik7XG4gICAgICBpZiAobWF0Y2hlZFN5bWJvbCAhPT0gbnVsbCkge1xuICAgICAgICByZWNvZ25pemVyLmNvbnN1bWUoKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoZWRTeW1ib2w7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaW5nbGVUb2tlbkluc2VydGlvbihyZWNvZ25pemVyKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNaXNzaW5nU3ltYm9sKHJlY29nbml6ZXIpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IElucHV0TWlzbWF0Y2hFeGNlcHRpb24ocmVjb2duaXplcik7XG4gICAgfVxuICAgIHNpbmdsZVRva2VuSW5zZXJ0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRTeW1ib2xUeXBlID0gcmVjb2duaXplci5nZXRUb2tlblN0cmVhbSgpLkxBKDEpO1xuICAgICAgY29uc3QgYXRuID0gcmVjb2duaXplci5faW50ZXJwLmF0bjtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGF0bi5zdGF0ZXNbcmVjb2duaXplci5zdGF0ZV07XG4gICAgICBjb25zdCBuZXh0ID0gY3VycmVudFN0YXRlLnRyYW5zaXRpb25zWzBdLnRhcmdldDtcbiAgICAgIGNvbnN0IGV4cGVjdGluZ0F0TEwyID0gYXRuLm5leHRUb2tlbnMobmV4dCwgcmVjb2duaXplci5fY3R4KTtcbiAgICAgIGlmIChleHBlY3RpbmdBdExMMi5jb250YWlucyhjdXJyZW50U3ltYm9sVHlwZSkpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRNaXNzaW5nVG9rZW4ocmVjb2duaXplcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBzaW5nbGVUb2tlbkRlbGV0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgIGNvbnN0IG5leHRUb2tlblR5cGUgPSByZWNvZ25pemVyLmdldFRva2VuU3RyZWFtKCkuTEEoMik7XG4gICAgICBjb25zdCBleHBlY3RpbmcgPSB0aGlzLmdldEV4cGVjdGVkVG9rZW5zKHJlY29nbml6ZXIpO1xuICAgICAgaWYgKGV4cGVjdGluZy5jb250YWlucyhuZXh0VG9rZW5UeXBlKSkge1xuICAgICAgICB0aGlzLnJlcG9ydFVud2FudGVkVG9rZW4ocmVjb2duaXplcik7XG4gICAgICAgIHJlY29nbml6ZXIuY29uc3VtZSgpO1xuICAgICAgICBjb25zdCBtYXRjaGVkU3ltYm9sID0gcmVjb2duaXplci5nZXRDdXJyZW50VG9rZW4oKTtcbiAgICAgICAgdGhpcy5yZXBvcnRNYXRjaChyZWNvZ25pemVyKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoZWRTeW1ib2w7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0TWlzc2luZ1N5bWJvbChyZWNvZ25pemVyKSB7XG4gICAgICBjb25zdCBjdXJyZW50U3ltYm9sID0gcmVjb2duaXplci5nZXRDdXJyZW50VG9rZW4oKTtcbiAgICAgIGNvbnN0IGV4cGVjdGluZyA9IHRoaXMuZ2V0RXhwZWN0ZWRUb2tlbnMocmVjb2duaXplcik7XG4gICAgICBjb25zdCBleHBlY3RlZFRva2VuVHlwZSA9IGV4cGVjdGluZy5maXJzdCgpO1xuICAgICAgbGV0IHRva2VuVGV4dDtcbiAgICAgIGlmIChleHBlY3RlZFRva2VuVHlwZSA9PT0gVG9rZW4yLkVPRikge1xuICAgICAgICB0b2tlblRleHQgPSBcIjxtaXNzaW5nIEVPRj5cIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2VuVGV4dCA9IFwiPG1pc3NpbmcgXCIgKyByZWNvZ25pemVyLmxpdGVyYWxOYW1lc1tleHBlY3RlZFRva2VuVHlwZV0gKyBcIj5cIjtcbiAgICAgIH1cbiAgICAgIGxldCBjdXJyZW50ID0gY3VycmVudFN5bWJvbDtcbiAgICAgIGNvbnN0IGxvb2tiYWNrID0gcmVjb2duaXplci5nZXRUb2tlblN0cmVhbSgpLkxUKC0xKTtcbiAgICAgIGlmIChjdXJyZW50LnR5cGUgPT09IFRva2VuMi5FT0YgJiYgbG9va2JhY2sgIT09IG51bGwpIHtcbiAgICAgICAgY3VycmVudCA9IGxvb2tiYWNrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlY29nbml6ZXIuZ2V0VG9rZW5GYWN0b3J5KCkuY3JlYXRlKGN1cnJlbnQuc291cmNlLCBleHBlY3RlZFRva2VuVHlwZSwgdG9rZW5UZXh0LCBUb2tlbjIuREVGQVVMVF9DSEFOTkVMLCAtMSwgLTEsIGN1cnJlbnQubGluZSwgY3VycmVudC5jb2x1bW4pO1xuICAgIH1cbiAgICBnZXRFeHBlY3RlZFRva2VucyhyZWNvZ25pemVyKSB7XG4gICAgICByZXR1cm4gcmVjb2duaXplci5nZXRFeHBlY3RlZFRva2VucygpO1xuICAgIH1cbiAgICBnZXRUb2tlbkVycm9yRGlzcGxheSh0KSB7XG4gICAgICBpZiAodCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCI8bm8gdG9rZW4+XCI7XG4gICAgICB9XG4gICAgICBsZXQgcyA9IHQudGV4dDtcbiAgICAgIGlmIChzID09PSBudWxsKSB7XG4gICAgICAgIGlmICh0LnR5cGUgPT09IFRva2VuMi5FT0YpIHtcbiAgICAgICAgICBzID0gXCI8RU9GPlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMgPSBcIjxcIiArIHQudHlwZSArIFwiPlwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lc2NhcGVXU0FuZFF1b3RlKHMpO1xuICAgIH1cbiAgICBlc2NhcGVXU0FuZFF1b3RlKHMpIHtcbiAgICAgIHMgPSBzLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpO1xuICAgICAgcyA9IHMucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIik7XG4gICAgICBzID0gcy5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKTtcbiAgICAgIHJldHVybiBcIidcIiArIHMgKyBcIidcIjtcbiAgICB9XG4gICAgZ2V0RXJyb3JSZWNvdmVyeVNldChyZWNvZ25pemVyKSB7XG4gICAgICBjb25zdCBhdG4gPSByZWNvZ25pemVyLl9pbnRlcnAuYXRuO1xuICAgICAgbGV0IGN0eCA9IHJlY29nbml6ZXIuX2N0eDtcbiAgICAgIGNvbnN0IHJlY292ZXJTZXQgPSBuZXcgSW50ZXJ2YWxTZXQoKTtcbiAgICAgIHdoaWxlIChjdHggIT09IG51bGwgJiYgY3R4Lmludm9raW5nU3RhdGUgPj0gMCkge1xuICAgICAgICBjb25zdCBpbnZva2luZ1N0YXRlID0gYXRuLnN0YXRlc1tjdHguaW52b2tpbmdTdGF0ZV07XG4gICAgICAgIGNvbnN0IHJ0ID0gaW52b2tpbmdTdGF0ZS50cmFuc2l0aW9uc1swXTtcbiAgICAgICAgY29uc3QgZm9sbG93ID0gYXRuLm5leHRUb2tlbnMocnQuZm9sbG93U3RhdGUpO1xuICAgICAgICByZWNvdmVyU2V0LmFkZFNldChmb2xsb3cpO1xuICAgICAgICBjdHggPSBjdHgucGFyZW50Q3R4O1xuICAgICAgfVxuICAgICAgcmVjb3ZlclNldC5yZW1vdmVPbmUoVG9rZW4yLkVQU0lMT04pO1xuICAgICAgcmV0dXJuIHJlY292ZXJTZXQ7XG4gICAgfVxuICAgIGNvbnN1bWVVbnRpbChyZWNvZ25pemVyLCBzZXQpIHtcbiAgICAgIGxldCB0dHlwZSA9IHJlY29nbml6ZXIuZ2V0VG9rZW5TdHJlYW0oKS5MQSgxKTtcbiAgICAgIHdoaWxlICh0dHlwZSAhPT0gVG9rZW4yLkVPRiAmJiAhc2V0LmNvbnRhaW5zKHR0eXBlKSkge1xuICAgICAgICByZWNvZ25pemVyLmNvbnN1bWUoKTtcbiAgICAgICAgdHR5cGUgPSByZWNvZ25pemVyLmdldFRva2VuU3RyZWFtKCkuTEEoMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgQmFpbEVycm9yU3RyYXRlZ3kgPSBjbGFzcyBleHRlbmRzIERlZmF1bHRFcnJvclN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgfVxuICAgIHJlY292ZXIocmVjb2duaXplciwgZSkge1xuICAgICAgbGV0IGNvbnRleHQgPSByZWNvZ25pemVyLl9jdHg7XG4gICAgICB3aGlsZSAoY29udGV4dCAhPT0gbnVsbCkge1xuICAgICAgICBjb250ZXh0LmV4Y2VwdGlvbiA9IGU7XG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnBhcmVudEN0eDtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBQYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbihlKTtcbiAgICB9XG4gICAgcmVjb3ZlcklubGluZShyZWNvZ25pemVyKSB7XG4gICAgICB0aGlzLnJlY292ZXIocmVjb2duaXplciwgbmV3IElucHV0TWlzbWF0Y2hFeGNlcHRpb24ocmVjb2duaXplcikpO1xuICAgIH1cbiAgICBzeW5jKHJlY29nbml6ZXIpIHtcbiAgICB9XG4gIH07XG4gIG1vZHVsZTIuZXhwb3J0cyA9IHtCYWlsRXJyb3JTdHJhdGVneSwgRGVmYXVsdEVycm9yU3RyYXRlZ3l9O1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjQvc3JjL2FudGxyNC9lcnJvci9pbmRleC5qc1xudmFyIHJlcXVpcmVfZXJyb3IgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUyKSA9PiB7XG4gIG1vZHVsZTIuZXhwb3J0cy5SZWNvZ25pdGlvbkV4Y2VwdGlvbiA9IHJlcXVpcmVfRXJyb3JzKCkuUmVjb2duaXRpb25FeGNlcHRpb247XG4gIG1vZHVsZTIuZXhwb3J0cy5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbiA9IHJlcXVpcmVfRXJyb3JzKCkuTm9WaWFibGVBbHRFeGNlcHRpb247XG4gIG1vZHVsZTIuZXhwb3J0cy5MZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uID0gcmVxdWlyZV9FcnJvcnMoKS5MZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uO1xuICBtb2R1bGUyLmV4cG9ydHMuSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbiA9IHJlcXVpcmVfRXJyb3JzKCkuSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbjtcbiAgbW9kdWxlMi5leHBvcnRzLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbiA9IHJlcXVpcmVfRXJyb3JzKCkuRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uO1xuICBtb2R1bGUyLmV4cG9ydHMuRGlhZ25vc3RpY0Vycm9yTGlzdGVuZXIgPSByZXF1aXJlX0RpYWdub3N0aWNFcnJvckxpc3RlbmVyMigpO1xuICBtb2R1bGUyLmV4cG9ydHMuQmFpbEVycm9yU3RyYXRlZ3kgPSByZXF1aXJlX0Vycm9yU3RyYXRlZ3koKS5CYWlsRXJyb3JTdHJhdGVneTtcbiAgbW9kdWxlMi5leHBvcnRzLkRlZmF1bHRFcnJvclN0cmF0ZWd5ID0gcmVxdWlyZV9FcnJvclN0cmF0ZWd5KCkuRGVmYXVsdEVycm9yU3RyYXRlZ3k7XG4gIG1vZHVsZTIuZXhwb3J0cy5FcnJvckxpc3RlbmVyID0gcmVxdWlyZV9FcnJvckxpc3RlbmVyKCkuRXJyb3JMaXN0ZW5lcjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0L3NyYy9hbnRscjQvSW5wdXRTdHJlYW0uanNcbnZhciByZXF1aXJlX0lucHV0U3RyZWFtID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlMikgPT4ge1xuICB2YXIge1Rva2VuOiBUb2tlbjJ9ID0gcmVxdWlyZV9Ub2tlbjIoKTtcbiAgcmVxdWlyZV9jb2RlcG9pbnRhdCgpO1xuICByZXF1aXJlX2Zyb21jb2RlcG9pbnQoKTtcbiAgdmFyIElucHV0U3RyZWFtID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGRlY29kZVRvVW5pY29kZUNvZGVQb2ludHMpIHtcbiAgICAgIHRoaXMubmFtZSA9IFwiPGVtcHR5PlwiO1xuICAgICAgdGhpcy5zdHJkYXRhID0gZGF0YTtcbiAgICAgIHRoaXMuZGVjb2RlVG9Vbmljb2RlQ29kZVBvaW50cyA9IGRlY29kZVRvVW5pY29kZUNvZGVQb2ludHMgfHwgZmFsc2U7XG4gICAgICB0aGlzLl9pbmRleCA9IDA7XG4gICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgIGlmICh0aGlzLmRlY29kZVRvVW5pY29kZUNvZGVQb2ludHMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0cmRhdGEubGVuZ3RoOyApIHtcbiAgICAgICAgICBjb25zdCBjb2RlUG9pbnQgPSB0aGlzLnN0cmRhdGEuY29kZVBvaW50QXQoaSk7XG4gICAgICAgICAgdGhpcy5kYXRhLnB1c2goY29kZVBvaW50KTtcbiAgICAgICAgICBpICs9IGNvZGVQb2ludCA8PSA2NTUzNSA/IDEgOiAyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RyZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNvZGVVbml0ID0gdGhpcy5zdHJkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgdGhpcy5kYXRhLnB1c2goY29kZVVuaXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9zaXplID0gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICB0aGlzLl9pbmRleCA9IDA7XG4gICAgfVxuICAgIGNvbnN1bWUoKSB7XG4gICAgICBpZiAodGhpcy5faW5kZXggPj0gdGhpcy5fc2l6ZSkge1xuICAgICAgICB0aHJvdyBcImNhbm5vdCBjb25zdW1lIEVPRlwiO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5kZXggKz0gMTtcbiAgICB9XG4gICAgTEEob2Zmc2V0KSB7XG4gICAgICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICB9XG4gICAgICBjb25zdCBwb3MgPSB0aGlzLl9pbmRleCArIG9mZnNldCAtIDE7XG4gICAgICBpZiAocG9zIDwgMCB8fCBwb3MgPj0gdGhpcy5fc2l6ZSkge1xuICAgICAgICByZXR1cm4gVG9rZW4yLkVPRjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmRhdGFbcG9zXTtcbiAgICB9XG4gICAgTFQob2Zmc2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5MQShvZmZzZXQpO1xuICAgIH1cbiAgICBtYXJrKCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZWxlYXNlKG1hcmtlcikge1xuICAgIH1cbiAgICBzZWVrKF9pbmRleCkge1xuICAgICAgaWYgKF9pbmRleCA8PSB0aGlzLl9pbmRleCkge1xuICAgICAgICB0aGlzLl9pbmRleCA9IF9pbmRleDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5kZXggPSBNYXRoLm1pbihfaW5kZXgsIHRoaXMuX3NpemUpO1xuICAgIH1cbiAgICBnZXRUZXh0KHN0YXJ0LCBzdG9wKSB7XG4gICAgICBpZiAoc3RvcCA+PSB0aGlzLl9zaXplKSB7XG4gICAgICAgIHN0b3AgPSB0aGlzLl9zaXplIC0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA+PSB0aGlzLl9zaXplKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZGVjb2RlVG9Vbmljb2RlQ29kZVBvaW50cykge1xuICAgICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8PSBzdG9wOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNvZGVQb2ludCh0aGlzLmRhdGFbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0cmRhdGEuc2xpY2Uoc3RhcnQsIHN0b3AgKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmRhdGE7XG4gICAgfVxuICAgIGdldCBpbmRleCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbmRleDtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gIH07XG4gIG1vZHVsZTIuZXhwb3J0cyA9IElucHV0U3RyZWFtO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjQvc3JjL2FudGxyNC9DaGFyU3RyZWFtcy5qc1xudmFyIHJlcXVpcmVfQ2hhclN0cmVhbXMyID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlMikgPT4ge1xuICB2YXIgSW5wdXRTdHJlYW0gPSByZXF1aXJlX0lucHV0U3RyZWFtKCk7XG4gIHZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbiAgdmFyIENoYXJTdHJlYW1zID0ge1xuICAgIGZyb21TdHJpbmc6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIG5ldyBJbnB1dFN0cmVhbShzdHIsIHRydWUpO1xuICAgIH0sXG4gICAgZnJvbUJsb2I6IGZ1bmN0aW9uKGJsb2IsIGVuY29kaW5nLCBvbkxvYWQsIG9uRXJyb3IpIHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyB3aW5kb3cuRmlsZVJlYWRlcigpO1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgY29uc3QgaXMgPSBuZXcgSW5wdXRTdHJlYW0oZS50YXJnZXQucmVzdWx0LCB0cnVlKTtcbiAgICAgICAgb25Mb2FkKGlzKTtcbiAgICAgIH07XG4gICAgICByZWFkZXIub25lcnJvciA9IG9uRXJyb3I7XG4gICAgICByZWFkZXIucmVhZEFzVGV4dChibG9iLCBlbmNvZGluZyk7XG4gICAgfSxcbiAgICBmcm9tQnVmZmVyOiBmdW5jdGlvbihidWZmZXIsIGVuY29kaW5nKSB7XG4gICAgICByZXR1cm4gbmV3IElucHV0U3RyZWFtKGJ1ZmZlci50b1N0cmluZyhlbmNvZGluZyksIHRydWUpO1xuICAgIH0sXG4gICAgZnJvbVBhdGg6IGZ1bmN0aW9uKHBhdGgsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgZnMucmVhZEZpbGUocGF0aCwgZW5jb2RpbmcsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICBsZXQgaXMgPSBudWxsO1xuICAgICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlzID0gbmV3IElucHV0U3RyZWFtKGRhdGEsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKGVyciwgaXMpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBmcm9tUGF0aFN5bmM6IGZ1bmN0aW9uKHBhdGgsIGVuY29kaW5nKSB7XG4gICAgICBjb25zdCBkYXRhID0gZnMucmVhZEZpbGVTeW5jKHBhdGgsIGVuY29kaW5nKTtcbiAgICAgIHJldHVybiBuZXcgSW5wdXRTdHJlYW0oZGF0YSwgdHJ1ZSk7XG4gICAgfVxuICB9O1xuICBtb2R1bGUyLmV4cG9ydHMgPSBDaGFyU3RyZWFtcztcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0L3NyYy9hbnRscjQvRmlsZVN0cmVhbS5qc1xudmFyIHJlcXVpcmVfRmlsZVN0cmVhbSA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZTIpID0+IHtcbiAgdmFyIElucHV0U3RyZWFtID0gcmVxdWlyZV9JbnB1dFN0cmVhbSgpO1xuICB2YXIgZnMgPSByZXF1aXJlKFwiZnNcIik7XG4gIHZhciBGaWxlU3RyZWFtID0gY2xhc3MgZXh0ZW5kcyBJbnB1dFN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoZmlsZU5hbWUsIGRlY29kZVRvVW5pY29kZUNvZGVQb2ludHMpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZU5hbWUsIFwidXRmOFwiKTtcbiAgICAgIHN1cGVyKGRhdGEsIGRlY29kZVRvVW5pY29kZUNvZGVQb2ludHMpO1xuICAgICAgdGhpcy5maWxlTmFtZSA9IGZpbGVOYW1lO1xuICAgIH1cbiAgfTtcbiAgbW9kdWxlMi5leHBvcnRzID0gRmlsZVN0cmVhbTtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0L3NyYy9hbnRscjQvQnVmZmVyZWRUb2tlblN0cmVhbS5qc1xudmFyIHJlcXVpcmVfQnVmZmVyZWRUb2tlblN0cmVhbTIgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUyKSA9PiB7XG4gIHZhciB7VG9rZW46IFRva2VuMn0gPSByZXF1aXJlX1Rva2VuMigpO1xuICB2YXIgTGV4ZXIyID0gcmVxdWlyZV9MZXhlcjIoKTtcbiAgdmFyIHtJbnRlcnZhbH0gPSByZXF1aXJlX0ludGVydmFsU2V0MigpO1xuICB2YXIgVG9rZW5TdHJlYW0gPSBjbGFzcyB7XG4gIH07XG4gIHZhciBCdWZmZXJlZFRva2VuU3RyZWFtID0gY2xhc3MgZXh0ZW5kcyBUb2tlblN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IodG9rZW5Tb3VyY2UpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLnRva2VuU291cmNlID0gdG9rZW5Tb3VyY2U7XG4gICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgdGhpcy5pbmRleCA9IC0xO1xuICAgICAgdGhpcy5mZXRjaGVkRU9GID0gZmFsc2U7XG4gICAgfVxuICAgIG1hcmsoKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmVsZWFzZShtYXJrZXIpIHtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICB0aGlzLnNlZWsoMCk7XG4gICAgfVxuICAgIHNlZWsoaW5kZXgpIHtcbiAgICAgIHRoaXMubGF6eUluaXQoKTtcbiAgICAgIHRoaXMuaW5kZXggPSB0aGlzLmFkanVzdFNlZWtJbmRleChpbmRleCk7XG4gICAgfVxuICAgIGdldChpbmRleCkge1xuICAgICAgdGhpcy5sYXp5SW5pdCgpO1xuICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW2luZGV4XTtcbiAgICB9XG4gICAgY29uc3VtZSgpIHtcbiAgICAgIGxldCBza2lwRW9mQ2hlY2sgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmluZGV4ID49IDApIHtcbiAgICAgICAgaWYgKHRoaXMuZmV0Y2hlZEVPRikge1xuICAgICAgICAgIHNraXBFb2ZDaGVjayA9IHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNraXBFb2ZDaGVjayA9IHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNraXBFb2ZDaGVjayA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFza2lwRW9mQ2hlY2sgJiYgdGhpcy5MQSgxKSA9PT0gVG9rZW4yLkVPRikge1xuICAgICAgICB0aHJvdyBcImNhbm5vdCBjb25zdW1lIEVPRlwiO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3luYyh0aGlzLmluZGV4ICsgMSkpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuYWRqdXN0U2Vla0luZGV4KHRoaXMuaW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3luYyhpKSB7XG4gICAgICBjb25zdCBuID0gaSAtIHRoaXMudG9rZW5zLmxlbmd0aCArIDE7XG4gICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgY29uc3QgZmV0Y2hlZCA9IHRoaXMuZmV0Y2gobik7XG4gICAgICAgIHJldHVybiBmZXRjaGVkID49IG47XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZmV0Y2gobikge1xuICAgICAgaWYgKHRoaXMuZmV0Y2hlZEVPRikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLnRva2VuU291cmNlLm5leHRUb2tlbigpO1xuICAgICAgICB0LnRva2VuSW5kZXggPSB0aGlzLnRva2Vucy5sZW5ndGg7XG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2godCk7XG4gICAgICAgIGlmICh0LnR5cGUgPT09IFRva2VuMi5FT0YpIHtcbiAgICAgICAgICB0aGlzLmZldGNoZWRFT0YgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBpICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIGdldFRva2VucyhzdGFydCwgc3RvcCwgdHlwZXMpIHtcbiAgICAgIGlmICh0eXBlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHR5cGVzID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA8IDAgfHwgc3RvcCA8IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmxhenlJbml0KCk7XG4gICAgICBjb25zdCBzdWJzZXQgPSBbXTtcbiAgICAgIGlmIChzdG9wID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICBzdG9wID0gdGhpcy50b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0b3A7IGkrKykge1xuICAgICAgICBjb25zdCB0ID0gdGhpcy50b2tlbnNbaV07XG4gICAgICAgIGlmICh0LnR5cGUgPT09IFRva2VuMi5FT0YpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZXMgPT09IG51bGwgfHwgdHlwZXMuY29udGFpbnModC50eXBlKSkge1xuICAgICAgICAgIHN1YnNldC5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3Vic2V0O1xuICAgIH1cbiAgICBMQShpKSB7XG4gICAgICByZXR1cm4gdGhpcy5MVChpKS50eXBlO1xuICAgIH1cbiAgICBMQihrKSB7XG4gICAgICBpZiAodGhpcy5pbmRleCAtIGsgPCAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuaW5kZXggLSBrXTtcbiAgICB9XG4gICAgTFQoaykge1xuICAgICAgdGhpcy5sYXp5SW5pdCgpO1xuICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuTEIoLWspO1xuICAgICAgfVxuICAgICAgY29uc3QgaSA9IHRoaXMuaW5kZXggKyBrIC0gMTtcbiAgICAgIHRoaXMuc3luYyhpKTtcbiAgICAgIGlmIChpID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnNbaV07XG4gICAgfVxuICAgIGFkanVzdFNlZWtJbmRleChpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgbGF6eUluaXQoKSB7XG4gICAgICBpZiAodGhpcy5pbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5zZXR1cCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXR1cCgpIHtcbiAgICAgIHRoaXMuc3luYygwKTtcbiAgICAgIHRoaXMuaW5kZXggPSB0aGlzLmFkanVzdFNlZWtJbmRleCgwKTtcbiAgICB9XG4gICAgc2V0VG9rZW5Tb3VyY2UodG9rZW5Tb3VyY2UpIHtcbiAgICAgIHRoaXMudG9rZW5Tb3VyY2UgPSB0b2tlblNvdXJjZTtcbiAgICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgICB0aGlzLmluZGV4ID0gLTE7XG4gICAgICB0aGlzLmZldGNoZWRFT0YgPSBmYWxzZTtcbiAgICB9XG4gICAgbmV4dFRva2VuT25DaGFubmVsKGksIGNoYW5uZWwpIHtcbiAgICAgIHRoaXMuc3luYyhpKTtcbiAgICAgIGlmIChpID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBsZXQgdG9rZW4gPSB0aGlzLnRva2Vuc1tpXTtcbiAgICAgIHdoaWxlICh0b2tlbi5jaGFubmVsICE9PSB0aGlzLmNoYW5uZWwpIHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuMi5FT0YpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaSArPSAxO1xuICAgICAgICB0aGlzLnN5bmMoaSk7XG4gICAgICAgIHRva2VuID0gdGhpcy50b2tlbnNbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgcHJldmlvdXNUb2tlbk9uQ2hhbm5lbChpLCBjaGFubmVsKSB7XG4gICAgICB3aGlsZSAoaSA+PSAwICYmIHRoaXMudG9rZW5zW2ldLmNoYW5uZWwgIT09IGNoYW5uZWwpIHtcbiAgICAgICAgaSAtPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIGdldEhpZGRlblRva2Vuc1RvUmlnaHQodG9rZW5JbmRleCwgY2hhbm5lbCkge1xuICAgICAgaWYgKGNoYW5uZWwgPT09IHZvaWQgMCkge1xuICAgICAgICBjaGFubmVsID0gLTE7XG4gICAgICB9XG4gICAgICB0aGlzLmxhenlJbml0KCk7XG4gICAgICBpZiAodG9rZW5JbmRleCA8IDAgfHwgdG9rZW5JbmRleCA+PSB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgXCJcIiArIHRva2VuSW5kZXggKyBcIiBub3QgaW4gMC4uXCIgKyB0aGlzLnRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV4dE9uQ2hhbm5lbCA9IHRoaXMubmV4dFRva2VuT25DaGFubmVsKHRva2VuSW5kZXggKyAxLCBMZXhlcjIuREVGQVVMVF9UT0tFTl9DSEFOTkVMKTtcbiAgICAgIGNvbnN0IGZyb21fID0gdG9rZW5JbmRleCArIDE7XG4gICAgICBjb25zdCB0byA9IG5leHRPbkNoYW5uZWwgPT09IC0xID8gdGhpcy50b2tlbnMubGVuZ3RoIC0gMSA6IG5leHRPbkNoYW5uZWw7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXJGb3JDaGFubmVsKGZyb21fLCB0bywgY2hhbm5lbCk7XG4gICAgfVxuICAgIGdldEhpZGRlblRva2Vuc1RvTGVmdCh0b2tlbkluZGV4LCBjaGFubmVsKSB7XG4gICAgICBpZiAoY2hhbm5lbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNoYW5uZWwgPSAtMTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGF6eUluaXQoKTtcbiAgICAgIGlmICh0b2tlbkluZGV4IDwgMCB8fCB0b2tlbkluZGV4ID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBcIlwiICsgdG9rZW5JbmRleCArIFwiIG5vdCBpbiAwLi5cIiArIHRoaXMudG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2T25DaGFubmVsID0gdGhpcy5wcmV2aW91c1Rva2VuT25DaGFubmVsKHRva2VuSW5kZXggLSAxLCBMZXhlcjIuREVGQVVMVF9UT0tFTl9DSEFOTkVMKTtcbiAgICAgIGlmIChwcmV2T25DaGFubmVsID09PSB0b2tlbkluZGV4IC0gMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZyb21fID0gcHJldk9uQ2hhbm5lbCArIDE7XG4gICAgICBjb25zdCB0byA9IHRva2VuSW5kZXggLSAxO1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyRm9yQ2hhbm5lbChmcm9tXywgdG8sIGNoYW5uZWwpO1xuICAgIH1cbiAgICBmaWx0ZXJGb3JDaGFubmVsKGxlZnQsIHJpZ2h0LCBjaGFubmVsKSB7XG4gICAgICBjb25zdCBoaWRkZW4gPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSBsZWZ0OyBpIDwgcmlnaHQgKyAxOyBpKyspIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMudG9rZW5zW2ldO1xuICAgICAgICBpZiAoY2hhbm5lbCA9PT0gLTEpIHtcbiAgICAgICAgICBpZiAodC5jaGFubmVsICE9PSBMZXhlcjIuREVGQVVMVF9UT0tFTl9DSEFOTkVMKSB7XG4gICAgICAgICAgICBoaWRkZW4ucHVzaCh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodC5jaGFubmVsID09PSBjaGFubmVsKSB7XG4gICAgICAgICAgaGlkZGVuLnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoaWRkZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhpZGRlbjtcbiAgICB9XG4gICAgZ2V0U291cmNlTmFtZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRva2VuU291cmNlLmdldFNvdXJjZU5hbWUoKTtcbiAgICB9XG4gICAgZ2V0VGV4dChpbnRlcnZhbCkge1xuICAgICAgdGhpcy5sYXp5SW5pdCgpO1xuICAgICAgdGhpcy5maWxsKCk7XG4gICAgICBpZiAoaW50ZXJ2YWwgPT09IHZvaWQgMCB8fCBpbnRlcnZhbCA9PT0gbnVsbCkge1xuICAgICAgICBpbnRlcnZhbCA9IG5ldyBJbnRlcnZhbCgwLCB0aGlzLnRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIGxldCBzdGFydCA9IGludGVydmFsLnN0YXJ0O1xuICAgICAgaWYgKHN0YXJ0IGluc3RhbmNlb2YgVG9rZW4yKSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQudG9rZW5JbmRleDtcbiAgICAgIH1cbiAgICAgIGxldCBzdG9wID0gaW50ZXJ2YWwuc3RvcDtcbiAgICAgIGlmIChzdG9wIGluc3RhbmNlb2YgVG9rZW4yKSB7XG4gICAgICAgIHN0b3AgPSBzdG9wLnRva2VuSW5kZXg7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPT09IG51bGwgfHwgc3RvcCA9PT0gbnVsbCB8fCBzdGFydCA8IDAgfHwgc3RvcCA8IDApIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAoc3RvcCA+PSB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgc3RvcCA9IHRoaXMudG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgICBsZXQgcyA9IFwiXCI7XG4gICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdG9wICsgMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLnRva2Vuc1tpXTtcbiAgICAgICAgaWYgKHQudHlwZSA9PT0gVG9rZW4yLkVPRikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHMgPSBzICsgdC50ZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGZpbGwoKSB7XG4gICAgICB0aGlzLmxhenlJbml0KCk7XG4gICAgICB3aGlsZSAodGhpcy5mZXRjaCgxZTMpID09PSAxZTMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBtb2R1bGUyLmV4cG9ydHMgPSBCdWZmZXJlZFRva2VuU3RyZWFtO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9hbnRscjQvc3JjL2FudGxyNC9Db21tb25Ub2tlblN0cmVhbS5qc1xudmFyIHJlcXVpcmVfQ29tbW9uVG9rZW5TdHJlYW0yID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlMikgPT4ge1xuICB2YXIgVG9rZW4yID0gcmVxdWlyZV9Ub2tlbjIoKS5Ub2tlbjtcbiAgdmFyIEJ1ZmZlcmVkVG9rZW5TdHJlYW0gPSByZXF1aXJlX0J1ZmZlcmVkVG9rZW5TdHJlYW0yKCk7XG4gIHZhciBDb21tb25Ub2tlblN0cmVhbTIgPSBjbGFzcyBleHRlbmRzIEJ1ZmZlcmVkVG9rZW5TdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKGxleGVyLCBjaGFubmVsKSB7XG4gICAgICBzdXBlcihsZXhlcik7XG4gICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsID09PSB2b2lkIDAgPyBUb2tlbjIuREVGQVVMVF9DSEFOTkVMIDogY2hhbm5lbDtcbiAgICB9XG4gICAgYWRqdXN0U2Vla0luZGV4KGkpIHtcbiAgICAgIHJldHVybiB0aGlzLm5leHRUb2tlbk9uQ2hhbm5lbChpLCB0aGlzLmNoYW5uZWwpO1xuICAgIH1cbiAgICBMQihrKSB7XG4gICAgICBpZiAoayA9PT0gMCB8fCB0aGlzLmluZGV4IC0gayA8IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBsZXQgaSA9IHRoaXMuaW5kZXg7XG4gICAgICBsZXQgbiA9IDE7XG4gICAgICB3aGlsZSAobiA8PSBrKSB7XG4gICAgICAgIGkgPSB0aGlzLnByZXZpb3VzVG9rZW5PbkNoYW5uZWwoaSAtIDEsIHRoaXMuY2hhbm5lbCk7XG4gICAgICAgIG4gKz0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRva2Vuc1tpXTtcbiAgICB9XG4gICAgTFQoaykge1xuICAgICAgdGhpcy5sYXp5SW5pdCgpO1xuICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuTEIoLWspO1xuICAgICAgfVxuICAgICAgbGV0IGkgPSB0aGlzLmluZGV4O1xuICAgICAgbGV0IG4gPSAxO1xuICAgICAgd2hpbGUgKG4gPCBrKSB7XG4gICAgICAgIGlmICh0aGlzLnN5bmMoaSArIDEpKSB7XG4gICAgICAgICAgaSA9IHRoaXMubmV4dFRva2VuT25DaGFubmVsKGkgKyAxLCB0aGlzLmNoYW5uZWwpO1xuICAgICAgICB9XG4gICAgICAgIG4gKz0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRva2Vuc1tpXTtcbiAgICB9XG4gICAgZ2V0TnVtYmVyT2ZPbkNoYW5uZWxUb2tlbnMoKSB7XG4gICAgICBsZXQgbiA9IDA7XG4gICAgICB0aGlzLmZpbGwoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMudG9rZW5zW2ldO1xuICAgICAgICBpZiAodC5jaGFubmVsID09PSB0aGlzLmNoYW5uZWwpIHtcbiAgICAgICAgICBuICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQudHlwZSA9PT0gVG9rZW4yLkVPRikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG4gIH07XG4gIG1vZHVsZTIuZXhwb3J0cyA9IENvbW1vblRva2VuU3RyZWFtMjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYW50bHI0L3NyYy9hbnRscjQvUGFyc2VyLmpzXG52YXIgcmVxdWlyZV9QYXJzZXIyID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlMikgPT4ge1xuICB2YXIge1Rva2VuOiBUb2tlbjJ9ID0gcmVxdWlyZV9Ub2tlbjIoKTtcbiAgdmFyIHtQYXJzZVRyZWVMaXN0ZW5lciwgVGVybWluYWxOb2RlLCBFcnJvck5vZGU6IEVycm9yTm9kZTJ9ID0gcmVxdWlyZV9UcmVlKCk7XG4gIHZhciBSZWNvZ25pemVyID0gcmVxdWlyZV9SZWNvZ25pemVyMigpO1xuICB2YXIge0RlZmF1bHRFcnJvclN0cmF0ZWd5fSA9IHJlcXVpcmVfRXJyb3JTdHJhdGVneSgpO1xuICB2YXIgQVRORGVzZXJpYWxpemVyMyA9IHJlcXVpcmVfQVRORGVzZXJpYWxpemVyMigpO1xuICB2YXIgQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucyA9IHJlcXVpcmVfQVRORGVzZXJpYWxpemF0aW9uT3B0aW9uczIoKTtcbiAgdmFyIExleGVyMiA9IHJlcXVpcmVfTGV4ZXIyKCk7XG4gIHZhciBUcmFjZUxpc3RlbmVyID0gY2xhc3MgZXh0ZW5kcyBQYXJzZVRyZWVMaXN0ZW5lciB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgfVxuICAgIGVudGVyRXZlcnlSdWxlKGN0eCkge1xuICAgICAgY29uc29sZS5sb2coXCJlbnRlciAgIFwiICsgdGhpcy5wYXJzZXIucnVsZU5hbWVzW2N0eC5ydWxlSW5kZXhdICsgXCIsIExUKDEpPVwiICsgdGhpcy5wYXJzZXIuX2lucHV0LkxUKDEpLnRleHQpO1xuICAgIH1cbiAgICB2aXNpdFRlcm1pbmFsKG5vZGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiY29uc3VtZSBcIiArIG5vZGUuc3ltYm9sICsgXCIgcnVsZSBcIiArIHRoaXMucGFyc2VyLnJ1bGVOYW1lc1t0aGlzLnBhcnNlci5fY3R4LnJ1bGVJbmRleF0pO1xuICAgIH1cbiAgICBleGl0RXZlcnlSdWxlKGN0eCkge1xuICAgICAgY29uc29sZS5sb2coXCJleGl0ICAgIFwiICsgdGhpcy5wYXJzZXIucnVsZU5hbWVzW2N0eC5ydWxlSW5kZXhdICsgXCIsIExUKDEpPVwiICsgdGhpcy5wYXJzZXIuX2lucHV0LkxUKDEpLnRleHQpO1xuICAgIH1cbiAgfTtcbiAgdmFyIFBhcnNlcjIgPSBjbGFzcyBleHRlbmRzIFJlY29nbml6ZXIge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5faW5wdXQgPSBudWxsO1xuICAgICAgdGhpcy5fZXJySGFuZGxlciA9IG5ldyBEZWZhdWx0RXJyb3JTdHJhdGVneSgpO1xuICAgICAgdGhpcy5fcHJlY2VkZW5jZVN0YWNrID0gW107XG4gICAgICB0aGlzLl9wcmVjZWRlbmNlU3RhY2sucHVzaCgwKTtcbiAgICAgIHRoaXMuX2N0eCA9IG51bGw7XG4gICAgICB0aGlzLmJ1aWxkUGFyc2VUcmVlcyA9IHRydWU7XG4gICAgICB0aGlzLl90cmFjZXIgPSBudWxsO1xuICAgICAgdGhpcy5fcGFyc2VMaXN0ZW5lcnMgPSBudWxsO1xuICAgICAgdGhpcy5fc3ludGF4RXJyb3JzID0gMDtcbiAgICAgIHRoaXMuc2V0SW5wdXRTdHJlYW0oaW5wdXQpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgIGlmICh0aGlzLl9pbnB1dCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9pbnB1dC5zZWVrKDApO1xuICAgICAgfVxuICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXNldCh0aGlzKTtcbiAgICAgIHRoaXMuX2N0eCA9IG51bGw7XG4gICAgICB0aGlzLl9zeW50YXhFcnJvcnMgPSAwO1xuICAgICAgdGhpcy5zZXRUcmFjZShmYWxzZSk7XG4gICAgICB0aGlzLl9wcmVjZWRlbmNlU3RhY2sgPSBbXTtcbiAgICAgIHRoaXMuX3ByZWNlZGVuY2VTdGFjay5wdXNoKDApO1xuICAgICAgaWYgKHRoaXMuX2ludGVycCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9pbnRlcnAucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWF0Y2godHR5cGUpIHtcbiAgICAgIGxldCB0ID0gdGhpcy5nZXRDdXJyZW50VG9rZW4oKTtcbiAgICAgIGlmICh0LnR5cGUgPT09IHR0eXBlKSB7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IHRoaXMuX2VyckhhbmRsZXIucmVjb3ZlcklubGluZSh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuYnVpbGRQYXJzZVRyZWVzICYmIHQudG9rZW5JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9jdHguYWRkRXJyb3JOb2RlKHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgbWF0Y2hXaWxkY2FyZCgpIHtcbiAgICAgIGxldCB0ID0gdGhpcy5nZXRDdXJyZW50VG9rZW4oKTtcbiAgICAgIGlmICh0LnR5cGUgPiAwKSB7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IHRoaXMuX2VyckhhbmRsZXIucmVjb3ZlcklubGluZSh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuX2J1aWxkUGFyc2VUcmVlcyAmJiB0LnRva2VuSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5fY3R4LmFkZEVycm9yTm9kZSh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICAgIGdldFBhcnNlTGlzdGVuZXJzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlTGlzdGVuZXJzIHx8IFtdO1xuICAgIH1cbiAgICBhZGRQYXJzZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICBpZiAobGlzdGVuZXIgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgXCJsaXN0ZW5lclwiO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3BhcnNlTGlzdGVuZXJzID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3BhcnNlTGlzdGVuZXJzID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLl9wYXJzZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmVtb3ZlUGFyc2VMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgaWYgKHRoaXMuX3BhcnNlTGlzdGVuZXJzICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX3BhcnNlTGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICB0aGlzLl9wYXJzZUxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGFyc2VMaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fcGFyc2VMaXN0ZW5lcnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZVBhcnNlTGlzdGVuZXJzKCkge1xuICAgICAgdGhpcy5fcGFyc2VMaXN0ZW5lcnMgPSBudWxsO1xuICAgIH1cbiAgICB0cmlnZ2VyRW50ZXJSdWxlRXZlbnQoKSB7XG4gICAgICBpZiAodGhpcy5fcGFyc2VMaXN0ZW5lcnMgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICB0aGlzLl9wYXJzZUxpc3RlbmVycy5tYXAoZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICAgICAgICBsaXN0ZW5lci5lbnRlckV2ZXJ5UnVsZShjdHgpO1xuICAgICAgICAgIGN0eC5lbnRlclJ1bGUobGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJpZ2dlckV4aXRSdWxlRXZlbnQoKSB7XG4gICAgICBpZiAodGhpcy5fcGFyc2VMaXN0ZW5lcnMgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICB0aGlzLl9wYXJzZUxpc3RlbmVycy5zbGljZSgwKS5yZXZlcnNlKCkubWFwKGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgICAgY3R4LmV4aXRSdWxlKGxpc3RlbmVyKTtcbiAgICAgICAgICBsaXN0ZW5lci5leGl0RXZlcnlSdWxlKGN0eCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXRUb2tlbkZhY3RvcnkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5wdXQudG9rZW5Tb3VyY2UuX2ZhY3Rvcnk7XG4gICAgfVxuICAgIHNldFRva2VuRmFjdG9yeShmYWN0b3J5KSB7XG4gICAgICB0aGlzLl9pbnB1dC50b2tlblNvdXJjZS5fZmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgfVxuICAgIGdldEFUTldpdGhCeXBhc3NBbHRzKCkge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZEF0biA9IHRoaXMuZ2V0U2VyaWFsaXplZEFUTigpO1xuICAgICAgaWYgKHNlcmlhbGl6ZWRBdG4gPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgXCJUaGUgY3VycmVudCBwYXJzZXIgZG9lcyBub3Qgc3VwcG9ydCBhbiBBVE4gd2l0aCBieXBhc3MgYWx0ZXJuYXRpdmVzLlwiO1xuICAgICAgfVxuICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuYnlwYXNzQWx0c0F0bkNhY2hlW3NlcmlhbGl6ZWRBdG5dO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBkZXNlcmlhbGl6YXRpb25PcHRpb25zID0gbmV3IEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMoKTtcbiAgICAgICAgZGVzZXJpYWxpemF0aW9uT3B0aW9ucy5nZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9ucyA9IHRydWU7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBBVE5EZXNlcmlhbGl6ZXIzKGRlc2VyaWFsaXphdGlvbk9wdGlvbnMpLmRlc2VyaWFsaXplKHNlcmlhbGl6ZWRBdG4pO1xuICAgICAgICB0aGlzLmJ5cGFzc0FsdHNBdG5DYWNoZVtzZXJpYWxpemVkQXRuXSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbXBpbGVQYXJzZVRyZWVQYXR0ZXJuKHBhdHRlcm4sIHBhdHRlcm5SdWxlSW5kZXgsIGxleGVyKSB7XG4gICAgICBsZXhlciA9IGxleGVyIHx8IG51bGw7XG4gICAgICBpZiAobGV4ZXIgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VG9rZW5TdHJlYW0oKSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IHRva2VuU291cmNlID0gdGhpcy5nZXRUb2tlblN0cmVhbSgpLnRva2VuU291cmNlO1xuICAgICAgICAgIGlmICh0b2tlblNvdXJjZSBpbnN0YW5jZW9mIExleGVyMikge1xuICAgICAgICAgICAgbGV4ZXIgPSB0b2tlblNvdXJjZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsZXhlciA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBcIlBhcnNlciBjYW4ndCBkaXNjb3ZlciBhIGxleGVyIHRvIHVzZVwiO1xuICAgICAgfVxuICAgICAgY29uc3QgbSA9IG5ldyBQYXJzZVRyZWVQYXR0ZXJuTWF0Y2hlcihsZXhlciwgdGhpcyk7XG4gICAgICByZXR1cm4gbS5jb21waWxlKHBhdHRlcm4sIHBhdHRlcm5SdWxlSW5kZXgpO1xuICAgIH1cbiAgICBnZXRJbnB1dFN0cmVhbSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRva2VuU3RyZWFtKCk7XG4gICAgfVxuICAgIHNldElucHV0U3RyZWFtKGlucHV0KSB7XG4gICAgICB0aGlzLnNldFRva2VuU3RyZWFtKGlucHV0KTtcbiAgICB9XG4gICAgZ2V0VG9rZW5TdHJlYW0oKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5wdXQ7XG4gICAgfVxuICAgIHNldFRva2VuU3RyZWFtKGlucHV0KSB7XG4gICAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICAgIH1cbiAgICBnZXRDdXJyZW50VG9rZW4oKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5wdXQuTFQoMSk7XG4gICAgfVxuICAgIG5vdGlmeUVycm9yTGlzdGVuZXJzKG1zZywgb2ZmZW5kaW5nVG9rZW4sIGVycikge1xuICAgICAgb2ZmZW5kaW5nVG9rZW4gPSBvZmZlbmRpbmdUb2tlbiB8fCBudWxsO1xuICAgICAgZXJyID0gZXJyIHx8IG51bGw7XG4gICAgICBpZiAob2ZmZW5kaW5nVG9rZW4gPT09IG51bGwpIHtcbiAgICAgICAgb2ZmZW5kaW5nVG9rZW4gPSB0aGlzLmdldEN1cnJlbnRUb2tlbigpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3ludGF4RXJyb3JzICs9IDE7XG4gICAgICBjb25zdCBsaW5lID0gb2ZmZW5kaW5nVG9rZW4ubGluZTtcbiAgICAgIGNvbnN0IGNvbHVtbiA9IG9mZmVuZGluZ1Rva2VuLmNvbHVtbjtcbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gdGhpcy5nZXRFcnJvckxpc3RlbmVyRGlzcGF0Y2goKTtcbiAgICAgIGxpc3RlbmVyLnN5bnRheEVycm9yKHRoaXMsIG9mZmVuZGluZ1Rva2VuLCBsaW5lLCBjb2x1bW4sIG1zZywgZXJyKTtcbiAgICB9XG4gICAgY29uc3VtZSgpIHtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLmdldEN1cnJlbnRUb2tlbigpO1xuICAgICAgaWYgKG8udHlwZSAhPT0gVG9rZW4yLkVPRikge1xuICAgICAgICB0aGlzLmdldElucHV0U3RyZWFtKCkuY29uc3VtZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgaGFzTGlzdGVuZXIgPSB0aGlzLl9wYXJzZUxpc3RlbmVycyAhPT0gbnVsbCAmJiB0aGlzLl9wYXJzZUxpc3RlbmVycy5sZW5ndGggPiAwO1xuICAgICAgaWYgKHRoaXMuYnVpbGRQYXJzZVRyZWVzIHx8IGhhc0xpc3RlbmVyKSB7XG4gICAgICAgIGxldCBub2RlO1xuICAgICAgICBpZiAodGhpcy5fZXJySGFuZGxlci5pbkVycm9yUmVjb3ZlcnlNb2RlKHRoaXMpKSB7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuX2N0eC5hZGRFcnJvck5vZGUobyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuX2N0eC5hZGRUb2tlbk5vZGUobyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5pbnZva2luZ1N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgaWYgKGhhc0xpc3RlbmVyKSB7XG4gICAgICAgICAgdGhpcy5fcGFyc2VMaXN0ZW5lcnMubWFwKGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVycm9yTm9kZTIgfHwgbm9kZS5pc0Vycm9yTm9kZSAhPT0gdm9pZCAwICYmIG5vZGUuaXNFcnJvck5vZGUoKSkge1xuICAgICAgICAgICAgICBsaXN0ZW5lci52aXNpdEVycm9yTm9kZShub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFRlcm1pbmFsTm9kZSkge1xuICAgICAgICAgICAgICBsaXN0ZW5lci52aXNpdFRlcm1pbmFsKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9XG4gICAgYWRkQ29udGV4dFRvUGFyc2VUcmVlKCkge1xuICAgICAgaWYgKHRoaXMuX2N0eC5wYXJlbnRDdHggIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fY3R4LnBhcmVudEN0eC5hZGRDaGlsZCh0aGlzLl9jdHgpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbnRlclJ1bGUobG9jYWxjdHgsIHN0YXRlLCBydWxlSW5kZXgpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgIHRoaXMuX2N0eCA9IGxvY2FsY3R4O1xuICAgICAgdGhpcy5fY3R4LnN0YXJ0ID0gdGhpcy5faW5wdXQuTFQoMSk7XG4gICAgICBpZiAodGhpcy5idWlsZFBhcnNlVHJlZXMpIHtcbiAgICAgICAgdGhpcy5hZGRDb250ZXh0VG9QYXJzZVRyZWUoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9wYXJzZUxpc3RlbmVycyAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnRyaWdnZXJFbnRlclJ1bGVFdmVudCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBleGl0UnVsZSgpIHtcbiAgICAgIHRoaXMuX2N0eC5zdG9wID0gdGhpcy5faW5wdXQuTFQoLTEpO1xuICAgICAgaWYgKHRoaXMuX3BhcnNlTGlzdGVuZXJzICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlckV4aXRSdWxlRXZlbnQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLl9jdHguaW52b2tpbmdTdGF0ZTtcbiAgICAgIHRoaXMuX2N0eCA9IHRoaXMuX2N0eC5wYXJlbnRDdHg7XG4gICAgfVxuICAgIGVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIGFsdE51bSkge1xuICAgICAgbG9jYWxjdHguc2V0QWx0TnVtYmVyKGFsdE51bSk7XG4gICAgICBpZiAodGhpcy5idWlsZFBhcnNlVHJlZXMgJiYgdGhpcy5fY3R4ICE9PSBsb2NhbGN0eCkge1xuICAgICAgICBpZiAodGhpcy5fY3R4LnBhcmVudEN0eCAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX2N0eC5wYXJlbnRDdHgucmVtb3ZlTGFzdENoaWxkKCk7XG4gICAgICAgICAgdGhpcy5fY3R4LnBhcmVudEN0eC5hZGRDaGlsZChsb2NhbGN0eCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2N0eCA9IGxvY2FsY3R4O1xuICAgIH1cbiAgICBnZXRQcmVjZWRlbmNlKCkge1xuICAgICAgaWYgKHRoaXMuX3ByZWNlZGVuY2VTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZWNlZGVuY2VTdGFja1t0aGlzLl9wcmVjZWRlbmNlU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICB9XG4gICAgfVxuICAgIGVudGVyUmVjdXJzaW9uUnVsZShsb2NhbGN0eCwgc3RhdGUsIHJ1bGVJbmRleCwgcHJlY2VkZW5jZSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgdGhpcy5fcHJlY2VkZW5jZVN0YWNrLnB1c2gocHJlY2VkZW5jZSk7XG4gICAgICB0aGlzLl9jdHggPSBsb2NhbGN0eDtcbiAgICAgIHRoaXMuX2N0eC5zdGFydCA9IHRoaXMuX2lucHV0LkxUKDEpO1xuICAgICAgaWYgKHRoaXMuX3BhcnNlTGlzdGVuZXJzICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlckVudGVyUnVsZUV2ZW50KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHB1c2hOZXdSZWN1cnNpb25Db250ZXh0KGxvY2FsY3R4LCBzdGF0ZSwgcnVsZUluZGV4KSB7XG4gICAgICBjb25zdCBwcmV2aW91cyA9IHRoaXMuX2N0eDtcbiAgICAgIHByZXZpb3VzLnBhcmVudEN0eCA9IGxvY2FsY3R4O1xuICAgICAgcHJldmlvdXMuaW52b2tpbmdTdGF0ZSA9IHN0YXRlO1xuICAgICAgcHJldmlvdXMuc3RvcCA9IHRoaXMuX2lucHV0LkxUKC0xKTtcbiAgICAgIHRoaXMuX2N0eCA9IGxvY2FsY3R4O1xuICAgICAgdGhpcy5fY3R4LnN0YXJ0ID0gcHJldmlvdXMuc3RhcnQ7XG4gICAgICBpZiAodGhpcy5idWlsZFBhcnNlVHJlZXMpIHtcbiAgICAgICAgdGhpcy5fY3R4LmFkZENoaWxkKHByZXZpb3VzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9wYXJzZUxpc3RlbmVycyAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnRyaWdnZXJFbnRlclJ1bGVFdmVudCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB1bnJvbGxSZWN1cnNpb25Db250ZXh0cyhwYXJlbnRDdHgpIHtcbiAgICAgIHRoaXMuX3ByZWNlZGVuY2VTdGFjay5wb3AoKTtcbiAgICAgIHRoaXMuX2N0eC5zdG9wID0gdGhpcy5faW5wdXQuTFQoLTEpO1xuICAgICAgY29uc3QgcmV0Q3R4ID0gdGhpcy5fY3R4O1xuICAgICAgaWYgKHRoaXMuX3BhcnNlTGlzdGVuZXJzICE9PSBudWxsKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9jdHggIT09IHBhcmVudEN0eCkge1xuICAgICAgICAgIHRoaXMudHJpZ2dlckV4aXRSdWxlRXZlbnQoKTtcbiAgICAgICAgICB0aGlzLl9jdHggPSB0aGlzLl9jdHgucGFyZW50Q3R4O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jdHggPSBwYXJlbnRDdHg7XG4gICAgICB9XG4gICAgICByZXRDdHgucGFyZW50Q3R4ID0gcGFyZW50Q3R4O1xuICAgICAgaWYgKHRoaXMuYnVpbGRQYXJzZVRyZWVzICYmIHBhcmVudEN0eCAhPT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRDdHguYWRkQ2hpbGQocmV0Q3R4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0SW52b2tpbmdDb250ZXh0KHJ1bGVJbmRleCkge1xuICAgICAgbGV0IGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgIHdoaWxlIChjdHggIT09IG51bGwpIHtcbiAgICAgICAgaWYgKGN0eC5ydWxlSW5kZXggPT09IHJ1bGVJbmRleCkge1xuICAgICAgICAgIHJldHVybiBjdHg7XG4gICAgICAgIH1cbiAgICAgICAgY3R4ID0gY3R4LnBhcmVudEN0eDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBwcmVjcHJlZChsb2NhbGN0eCwgcHJlY2VkZW5jZSkge1xuICAgICAgcmV0dXJuIHByZWNlZGVuY2UgPj0gdGhpcy5fcHJlY2VkZW5jZVN0YWNrW3RoaXMuX3ByZWNlZGVuY2VTdGFjay5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgaW5Db250ZXh0KGNvbnRleHQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXNFeHBlY3RlZFRva2VuKHN5bWJvbCkge1xuICAgICAgY29uc3QgYXRuID0gdGhpcy5faW50ZXJwLmF0bjtcbiAgICAgIGxldCBjdHggPSB0aGlzLl9jdHg7XG4gICAgICBjb25zdCBzID0gYXRuLnN0YXRlc1t0aGlzLnN0YXRlXTtcbiAgICAgIGxldCBmb2xsb3dpbmcgPSBhdG4ubmV4dFRva2VucyhzKTtcbiAgICAgIGlmIChmb2xsb3dpbmcuY29udGFpbnMoc3ltYm9sKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghZm9sbG93aW5nLmNvbnRhaW5zKFRva2VuMi5FUFNJTE9OKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB3aGlsZSAoY3R4ICE9PSBudWxsICYmIGN0eC5pbnZva2luZ1N0YXRlID49IDAgJiYgZm9sbG93aW5nLmNvbnRhaW5zKFRva2VuMi5FUFNJTE9OKSkge1xuICAgICAgICBjb25zdCBpbnZva2luZ1N0YXRlID0gYXRuLnN0YXRlc1tjdHguaW52b2tpbmdTdGF0ZV07XG4gICAgICAgIGNvbnN0IHJ0ID0gaW52b2tpbmdTdGF0ZS50cmFuc2l0aW9uc1swXTtcbiAgICAgICAgZm9sbG93aW5nID0gYXRuLm5leHRUb2tlbnMocnQuZm9sbG93U3RhdGUpO1xuICAgICAgICBpZiAoZm9sbG93aW5nLmNvbnRhaW5zKHN5bWJvbCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHggPSBjdHgucGFyZW50Q3R4O1xuICAgICAgfVxuICAgICAgaWYgKGZvbGxvd2luZy5jb250YWlucyhUb2tlbjIuRVBTSUxPTikgJiYgc3ltYm9sID09PSBUb2tlbjIuRU9GKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXRFeHBlY3RlZFRva2VucygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbnRlcnAuYXRuLmdldEV4cGVjdGVkVG9rZW5zKHRoaXMuc3RhdGUsIHRoaXMuX2N0eCk7XG4gICAgfVxuICAgIGdldEV4cGVjdGVkVG9rZW5zV2l0aGluQ3VycmVudFJ1bGUoKSB7XG4gICAgICBjb25zdCBhdG4gPSB0aGlzLl9pbnRlcnAuYXRuO1xuICAgICAgY29uc3QgcyA9IGF0bi5zdGF0ZXNbdGhpcy5zdGF0ZV07XG4gICAgICByZXR1cm4gYXRuLm5leHRUb2tlbnMocyk7XG4gICAgfVxuICAgIGdldFJ1bGVJbmRleChydWxlTmFtZSkge1xuICAgICAgY29uc3QgcnVsZUluZGV4ID0gdGhpcy5nZXRSdWxlSW5kZXhNYXAoKVtydWxlTmFtZV07XG4gICAgICBpZiAocnVsZUluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBydWxlSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGdldFJ1bGVJbnZvY2F0aW9uU3RhY2socCkge1xuICAgICAgcCA9IHAgfHwgbnVsbDtcbiAgICAgIGlmIChwID09PSBudWxsKSB7XG4gICAgICAgIHAgPSB0aGlzLl9jdHg7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFjayA9IFtdO1xuICAgICAgd2hpbGUgKHAgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcnVsZUluZGV4ID0gcC5ydWxlSW5kZXg7XG4gICAgICAgIGlmIChydWxlSW5kZXggPCAwKSB7XG4gICAgICAgICAgc3RhY2sucHVzaChcIm4vYVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFjay5wdXNoKHRoaXMucnVsZU5hbWVzW3J1bGVJbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIHAgPSBwLnBhcmVudEN0eDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9XG4gICAgZ2V0REZBU3RyaW5ncygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbnRlcnAuZGVjaXNpb25Ub0RGQS50b1N0cmluZygpO1xuICAgIH1cbiAgICBkdW1wREZBKCkge1xuICAgICAgbGV0IHNlZW5PbmUgPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faW50ZXJwLmRlY2lzaW9uVG9ERkEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGZhID0gdGhpcy5faW50ZXJwLmRlY2lzaW9uVG9ERkFbaV07XG4gICAgICAgIGlmIChkZmEuc3RhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAoc2Vlbk9uZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5wcmludGVyLnByaW50bG4oXCJEZWNpc2lvbiBcIiArIGRmYS5kZWNpc2lvbiArIFwiOlwiKTtcbiAgICAgICAgICB0aGlzLnByaW50ZXIucHJpbnQoZGZhLnRvU3RyaW5nKHRoaXMubGl0ZXJhbE5hbWVzLCB0aGlzLnN5bWJvbGljTmFtZXMpKTtcbiAgICAgICAgICBzZWVuT25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBnZXRTb3VyY2VOYW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lucHV0LnNvdXJjZU5hbWU7XG4gICAgfVxuICAgIHNldFRyYWNlKHRyYWNlKSB7XG4gICAgICBpZiAoIXRyYWNlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUGFyc2VMaXN0ZW5lcih0aGlzLl90cmFjZXIpO1xuICAgICAgICB0aGlzLl90cmFjZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYWNlciAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlUGFyc2VMaXN0ZW5lcih0aGlzLl90cmFjZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYWNlciA9IG5ldyBUcmFjZUxpc3RlbmVyKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZFBhcnNlTGlzdGVuZXIodGhpcy5fdHJhY2VyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFBhcnNlcjIuYnlwYXNzQWx0c0F0bkNhY2hlID0ge307XG4gIG1vZHVsZTIuZXhwb3J0cyA9IFBhcnNlcjI7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2FudGxyNC9zcmMvYW50bHI0L2luZGV4LmpzXG52YXIgcmVxdWlyZV9hbnRscjQgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIGV4cG9ydHMuYXRuID0gcmVxdWlyZV9hdG4oKTtcbiAgZXhwb3J0cy5jb2RlcG9pbnRhdCA9IHJlcXVpcmVfY29kZXBvaW50YXQoKTtcbiAgZXhwb3J0cy5kZmEgPSByZXF1aXJlX2RmYSgpO1xuICBleHBvcnRzLmZyb21jb2RlcG9pbnQgPSByZXF1aXJlX2Zyb21jb2RlcG9pbnQoKTtcbiAgZXhwb3J0cy50cmVlID0gcmVxdWlyZV90cmVlKCk7XG4gIGV4cG9ydHMuZXJyb3IgPSByZXF1aXJlX2Vycm9yKCk7XG4gIGV4cG9ydHMuVG9rZW4gPSByZXF1aXJlX1Rva2VuMigpLlRva2VuO1xuICBleHBvcnRzLkNoYXJTdHJlYW1zID0gcmVxdWlyZV9DaGFyU3RyZWFtczIoKTtcbiAgZXhwb3J0cy5Db21tb25Ub2tlbiA9IHJlcXVpcmVfVG9rZW4yKCkuQ29tbW9uVG9rZW47XG4gIGV4cG9ydHMuSW5wdXRTdHJlYW0gPSByZXF1aXJlX0lucHV0U3RyZWFtKCk7XG4gIGV4cG9ydHMuRmlsZVN0cmVhbSA9IHJlcXVpcmVfRmlsZVN0cmVhbSgpO1xuICBleHBvcnRzLkNvbW1vblRva2VuU3RyZWFtID0gcmVxdWlyZV9Db21tb25Ub2tlblN0cmVhbTIoKTtcbiAgZXhwb3J0cy5MZXhlciA9IHJlcXVpcmVfTGV4ZXIyKCk7XG4gIGV4cG9ydHMuUGFyc2VyID0gcmVxdWlyZV9QYXJzZXIyKCk7XG4gIHZhciBwYyA9IHJlcXVpcmVfUHJlZGljdGlvbkNvbnRleHQyKCk7XG4gIGV4cG9ydHMuUHJlZGljdGlvbkNvbnRleHRDYWNoZSA9IHBjLlByZWRpY3Rpb25Db250ZXh0Q2FjaGU7XG4gIGV4cG9ydHMuUGFyc2VyUnVsZUNvbnRleHQgPSByZXF1aXJlX1BhcnNlclJ1bGVDb250ZXh0MigpO1xuICBleHBvcnRzLkludGVydmFsID0gcmVxdWlyZV9JbnRlcnZhbFNldDIoKS5JbnRlcnZhbDtcbiAgZXhwb3J0cy5JbnRlcnZhbFNldCA9IHJlcXVpcmVfSW50ZXJ2YWxTZXQyKCkuSW50ZXJ2YWxTZXQ7XG4gIGV4cG9ydHMuVXRpbHMgPSByZXF1aXJlX1V0aWxzMigpO1xuICBleHBvcnRzLkxMMUFuYWx5emVyID0gcmVxdWlyZV9MTDFBbmFseXplcjIoKS5MTDFBbmFseXplcjtcbn0pO1xuXG4vLyBzcmMvYW50bHIvU29saWRpdHkudG9rZW5zXG52YXIgcmVxdWlyZV9Tb2xpZGl0eSA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZTIpID0+IHtcbiAgbW9kdWxlMi5leHBvcnRzID0gXCIuL1NvbGlkaXR5LUVaVlE2QUU0LnRva2Vuc1wiO1xufSk7XG5cbi8vIHNyYy90b2tlbnMtc3RyaW5nLmpzXG52YXIgcmVxdWlyZV90b2tlbnNfc3RyaW5nID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlMikgPT4ge1xuICBpZiAodHlwZW9mIEJST1dTRVIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSByZXF1aXJlX1NvbGlkaXR5KCk7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcmVxdWlyZShcImZzXCIpLnJlYWRGaWxlU3luYyhyZXF1aXJlKFwicGF0aFwiKS5qb2luKF9fZGlybmFtZSwgXCIuL2FudGxyL1NvbGlkaXR5LnRva2Vuc1wiKSkudG9TdHJpbmcoKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9pbmRleC50c1xuX19tYXJrQXNNb2R1bGUoZXhwb3J0cyk7XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIFBhcnNlckVycm9yOiAoKSA9PiBQYXJzZXJFcnJvcixcbiAgcGFyc2U6ICgpID0+IHBhcnNlLFxuICB0b2tlbml6ZTogKCkgPT4gdG9rZW5pemUsXG4gIHZpc2l0OiAoKSA9PiB2aXNpdFxufSk7XG5cbi8vIHNyYy9wYXJzZXIudHNcbnZhciBpbXBvcnRfYW50bHI0dHMgPSBfX3RvTW9kdWxlKHJlcXVpcmVfYW50bHI0dHMoKSk7XG5cbi8vIHNyYy9hbnRsci9Tb2xpZGl0eUxleGVyLnRzXG52YXIgaW1wb3J0X0FUTkRlc2VyaWFsaXplciA9IF9fdG9Nb2R1bGUocmVxdWlyZV9BVE5EZXNlcmlhbGl6ZXIoKSk7XG52YXIgaW1wb3J0X0xleGVyID0gX190b01vZHVsZShyZXF1aXJlX0xleGVyKCkpO1xudmFyIGltcG9ydF9MZXhlckFUTlNpbXVsYXRvciA9IF9fdG9Nb2R1bGUocmVxdWlyZV9MZXhlckFUTlNpbXVsYXRvcigpKTtcbnZhciBpbXBvcnRfVm9jYWJ1bGFyeUltcGwgPSBfX3RvTW9kdWxlKHJlcXVpcmVfVm9jYWJ1bGFyeUltcGwoKSk7XG52YXIgVXRpbHMgPSBfX3RvTW9kdWxlKHJlcXVpcmVfVXRpbHMoKSk7XG52YXIgX1NvbGlkaXR5TGV4ZXIgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9MZXhlci5MZXhlciB7XG4gIGdldCB2b2NhYnVsYXJ5KCkge1xuICAgIHJldHVybiBfU29saWRpdHlMZXhlci5WT0NBQlVMQVJZO1xuICB9XG4gIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgc3VwZXIoaW5wdXQpO1xuICAgIHRoaXMuX2ludGVycCA9IG5ldyBpbXBvcnRfTGV4ZXJBVE5TaW11bGF0b3IuTGV4ZXJBVE5TaW11bGF0b3IoX1NvbGlkaXR5TGV4ZXIuX0FUTiwgdGhpcyk7XG4gIH1cbiAgZ2V0IGdyYW1tYXJGaWxlTmFtZSgpIHtcbiAgICByZXR1cm4gXCJTb2xpZGl0eS5nNFwiO1xuICB9XG4gIGdldCBydWxlTmFtZXMoKSB7XG4gICAgcmV0dXJuIF9Tb2xpZGl0eUxleGVyLnJ1bGVOYW1lcztcbiAgfVxuICBnZXQgc2VyaWFsaXplZEFUTigpIHtcbiAgICByZXR1cm4gX1NvbGlkaXR5TGV4ZXIuX3NlcmlhbGl6ZWRBVE47XG4gIH1cbiAgZ2V0IGNoYW5uZWxOYW1lcygpIHtcbiAgICByZXR1cm4gX1NvbGlkaXR5TGV4ZXIuY2hhbm5lbE5hbWVzO1xuICB9XG4gIGdldCBtb2RlTmFtZXMoKSB7XG4gICAgcmV0dXJuIF9Tb2xpZGl0eUxleGVyLm1vZGVOYW1lcztcbiAgfVxuICBzdGF0aWMgZ2V0IF9BVE4oKSB7XG4gICAgaWYgKCFfU29saWRpdHlMZXhlci5fX0FUTikge1xuICAgICAgX1NvbGlkaXR5TGV4ZXIuX19BVE4gPSBuZXcgaW1wb3J0X0FUTkRlc2VyaWFsaXplci5BVE5EZXNlcmlhbGl6ZXIoKS5kZXNlcmlhbGl6ZShVdGlscy50b0NoYXJBcnJheShfU29saWRpdHlMZXhlci5fc2VyaWFsaXplZEFUTikpO1xuICAgIH1cbiAgICByZXR1cm4gX1NvbGlkaXR5TGV4ZXIuX19BVE47XG4gIH1cbn07XG52YXIgU29saWRpdHlMZXhlciA9IF9Tb2xpZGl0eUxleGVyO1xuU29saWRpdHlMZXhlci5UX18wID0gMTtcblNvbGlkaXR5TGV4ZXIuVF9fMSA9IDI7XG5Tb2xpZGl0eUxleGVyLlRfXzIgPSAzO1xuU29saWRpdHlMZXhlci5UX18zID0gNDtcblNvbGlkaXR5TGV4ZXIuVF9fNCA9IDU7XG5Tb2xpZGl0eUxleGVyLlRfXzUgPSA2O1xuU29saWRpdHlMZXhlci5UX182ID0gNztcblNvbGlkaXR5TGV4ZXIuVF9fNyA9IDg7XG5Tb2xpZGl0eUxleGVyLlRfXzggPSA5O1xuU29saWRpdHlMZXhlci5UX185ID0gMTA7XG5Tb2xpZGl0eUxleGVyLlRfXzEwID0gMTE7XG5Tb2xpZGl0eUxleGVyLlRfXzExID0gMTI7XG5Tb2xpZGl0eUxleGVyLlRfXzEyID0gMTM7XG5Tb2xpZGl0eUxleGVyLlRfXzEzID0gMTQ7XG5Tb2xpZGl0eUxleGVyLlRfXzE0ID0gMTU7XG5Tb2xpZGl0eUxleGVyLlRfXzE1ID0gMTY7XG5Tb2xpZGl0eUxleGVyLlRfXzE2ID0gMTc7XG5Tb2xpZGl0eUxleGVyLlRfXzE3ID0gMTg7XG5Tb2xpZGl0eUxleGVyLlRfXzE4ID0gMTk7XG5Tb2xpZGl0eUxleGVyLlRfXzE5ID0gMjA7XG5Tb2xpZGl0eUxleGVyLlRfXzIwID0gMjE7XG5Tb2xpZGl0eUxleGVyLlRfXzIxID0gMjI7XG5Tb2xpZGl0eUxleGVyLlRfXzIyID0gMjM7XG5Tb2xpZGl0eUxleGVyLlRfXzIzID0gMjQ7XG5Tb2xpZGl0eUxleGVyLlRfXzI0ID0gMjU7XG5Tb2xpZGl0eUxleGVyLlRfXzI1ID0gMjY7XG5Tb2xpZGl0eUxleGVyLlRfXzI2ID0gMjc7XG5Tb2xpZGl0eUxleGVyLlRfXzI3ID0gMjg7XG5Tb2xpZGl0eUxleGVyLlRfXzI4ID0gMjk7XG5Tb2xpZGl0eUxleGVyLlRfXzI5ID0gMzA7XG5Tb2xpZGl0eUxleGVyLlRfXzMwID0gMzE7XG5Tb2xpZGl0eUxleGVyLlRfXzMxID0gMzI7XG5Tb2xpZGl0eUxleGVyLlRfXzMyID0gMzM7XG5Tb2xpZGl0eUxleGVyLlRfXzMzID0gMzQ7XG5Tb2xpZGl0eUxleGVyLlRfXzM0ID0gMzU7XG5Tb2xpZGl0eUxleGVyLlRfXzM1ID0gMzY7XG5Tb2xpZGl0eUxleGVyLlRfXzM2ID0gMzc7XG5Tb2xpZGl0eUxleGVyLlRfXzM3ID0gMzg7XG5Tb2xpZGl0eUxleGVyLlRfXzM4ID0gMzk7XG5Tb2xpZGl0eUxleGVyLlRfXzM5ID0gNDA7XG5Tb2xpZGl0eUxleGVyLlRfXzQwID0gNDE7XG5Tb2xpZGl0eUxleGVyLlRfXzQxID0gNDI7XG5Tb2xpZGl0eUxleGVyLlRfXzQyID0gNDM7XG5Tb2xpZGl0eUxleGVyLlRfXzQzID0gNDQ7XG5Tb2xpZGl0eUxleGVyLlRfXzQ0ID0gNDU7XG5Tb2xpZGl0eUxleGVyLlRfXzQ1ID0gNDY7XG5Tb2xpZGl0eUxleGVyLlRfXzQ2ID0gNDc7XG5Tb2xpZGl0eUxleGVyLlRfXzQ3ID0gNDg7XG5Tb2xpZGl0eUxleGVyLlRfXzQ4ID0gNDk7XG5Tb2xpZGl0eUxleGVyLlRfXzQ5ID0gNTA7XG5Tb2xpZGl0eUxleGVyLlRfXzUwID0gNTE7XG5Tb2xpZGl0eUxleGVyLlRfXzUxID0gNTI7XG5Tb2xpZGl0eUxleGVyLlRfXzUyID0gNTM7XG5Tb2xpZGl0eUxleGVyLlRfXzUzID0gNTQ7XG5Tb2xpZGl0eUxleGVyLlRfXzU0ID0gNTU7XG5Tb2xpZGl0eUxleGVyLlRfXzU1ID0gNTY7XG5Tb2xpZGl0eUxleGVyLlRfXzU2ID0gNTc7XG5Tb2xpZGl0eUxleGVyLlRfXzU3ID0gNTg7XG5Tb2xpZGl0eUxleGVyLlRfXzU4ID0gNTk7XG5Tb2xpZGl0eUxleGVyLlRfXzU5ID0gNjA7XG5Tb2xpZGl0eUxleGVyLlRfXzYwID0gNjE7XG5Tb2xpZGl0eUxleGVyLlRfXzYxID0gNjI7XG5Tb2xpZGl0eUxleGVyLlRfXzYyID0gNjM7XG5Tb2xpZGl0eUxleGVyLlRfXzYzID0gNjQ7XG5Tb2xpZGl0eUxleGVyLlRfXzY0ID0gNjU7XG5Tb2xpZGl0eUxleGVyLlRfXzY1ID0gNjY7XG5Tb2xpZGl0eUxleGVyLlRfXzY2ID0gNjc7XG5Tb2xpZGl0eUxleGVyLlRfXzY3ID0gNjg7XG5Tb2xpZGl0eUxleGVyLlRfXzY4ID0gNjk7XG5Tb2xpZGl0eUxleGVyLlRfXzY5ID0gNzA7XG5Tb2xpZGl0eUxleGVyLlRfXzcwID0gNzE7XG5Tb2xpZGl0eUxleGVyLlRfXzcxID0gNzI7XG5Tb2xpZGl0eUxleGVyLlRfXzcyID0gNzM7XG5Tb2xpZGl0eUxleGVyLlRfXzczID0gNzQ7XG5Tb2xpZGl0eUxleGVyLlRfXzc0ID0gNzU7XG5Tb2xpZGl0eUxleGVyLlRfXzc1ID0gNzY7XG5Tb2xpZGl0eUxleGVyLlRfXzc2ID0gNzc7XG5Tb2xpZGl0eUxleGVyLlRfXzc3ID0gNzg7XG5Tb2xpZGl0eUxleGVyLlRfXzc4ID0gNzk7XG5Tb2xpZGl0eUxleGVyLlRfXzc5ID0gODA7XG5Tb2xpZGl0eUxleGVyLlRfXzgwID0gODE7XG5Tb2xpZGl0eUxleGVyLlRfXzgxID0gODI7XG5Tb2xpZGl0eUxleGVyLlRfXzgyID0gODM7XG5Tb2xpZGl0eUxleGVyLlRfXzgzID0gODQ7XG5Tb2xpZGl0eUxleGVyLlRfXzg0ID0gODU7XG5Tb2xpZGl0eUxleGVyLlRfXzg1ID0gODY7XG5Tb2xpZGl0eUxleGVyLlRfXzg2ID0gODc7XG5Tb2xpZGl0eUxleGVyLlRfXzg3ID0gODg7XG5Tb2xpZGl0eUxleGVyLlRfXzg4ID0gODk7XG5Tb2xpZGl0eUxleGVyLlRfXzg5ID0gOTA7XG5Tb2xpZGl0eUxleGVyLlRfXzkwID0gOTE7XG5Tb2xpZGl0eUxleGVyLlRfXzkxID0gOTI7XG5Tb2xpZGl0eUxleGVyLlRfXzkyID0gOTM7XG5Tb2xpZGl0eUxleGVyLlRfXzkzID0gOTQ7XG5Tb2xpZGl0eUxleGVyLlRfXzk0ID0gOTU7XG5Tb2xpZGl0eUxleGVyLlRfXzk1ID0gOTY7XG5Tb2xpZGl0eUxleGVyLlRfXzk2ID0gOTc7XG5Tb2xpZGl0eUxleGVyLkludCA9IDk4O1xuU29saWRpdHlMZXhlci5VaW50ID0gOTk7XG5Tb2xpZGl0eUxleGVyLkJ5dGUgPSAxMDA7XG5Tb2xpZGl0eUxleGVyLkZpeGVkID0gMTAxO1xuU29saWRpdHlMZXhlci5VZml4ZWQgPSAxMDI7XG5Tb2xpZGl0eUxleGVyLkJvb2xlYW5MaXRlcmFsID0gMTAzO1xuU29saWRpdHlMZXhlci5EZWNpbWFsTnVtYmVyID0gMTA0O1xuU29saWRpdHlMZXhlci5IZXhOdW1iZXIgPSAxMDU7XG5Tb2xpZGl0eUxleGVyLk51bWJlclVuaXQgPSAxMDY7XG5Tb2xpZGl0eUxleGVyLkhleExpdGVyYWxGcmFnbWVudCA9IDEwNztcblNvbGlkaXR5TGV4ZXIuUmVzZXJ2ZWRLZXl3b3JkID0gMTA4O1xuU29saWRpdHlMZXhlci5Bbm9ueW1vdXNLZXl3b3JkID0gMTA5O1xuU29saWRpdHlMZXhlci5CcmVha0tleXdvcmQgPSAxMTA7XG5Tb2xpZGl0eUxleGVyLkNvbnN0YW50S2V5d29yZCA9IDExMTtcblNvbGlkaXR5TGV4ZXIuSW1tdXRhYmxlS2V5d29yZCA9IDExMjtcblNvbGlkaXR5TGV4ZXIuQ29udGludWVLZXl3b3JkID0gMTEzO1xuU29saWRpdHlMZXhlci5MZWF2ZUtleXdvcmQgPSAxMTQ7XG5Tb2xpZGl0eUxleGVyLkV4dGVybmFsS2V5d29yZCA9IDExNTtcblNvbGlkaXR5TGV4ZXIuSW5kZXhlZEtleXdvcmQgPSAxMTY7XG5Tb2xpZGl0eUxleGVyLkludGVybmFsS2V5d29yZCA9IDExNztcblNvbGlkaXR5TGV4ZXIuUGF5YWJsZUtleXdvcmQgPSAxMTg7XG5Tb2xpZGl0eUxleGVyLlByaXZhdGVLZXl3b3JkID0gMTE5O1xuU29saWRpdHlMZXhlci5QdWJsaWNLZXl3b3JkID0gMTIwO1xuU29saWRpdHlMZXhlci5WaXJ0dWFsS2V5d29yZCA9IDEyMTtcblNvbGlkaXR5TGV4ZXIuUHVyZUtleXdvcmQgPSAxMjI7XG5Tb2xpZGl0eUxleGVyLlR5cGVLZXl3b3JkID0gMTIzO1xuU29saWRpdHlMZXhlci5WaWV3S2V5d29yZCA9IDEyNDtcblNvbGlkaXR5TGV4ZXIuR2xvYmFsS2V5d29yZCA9IDEyNTtcblNvbGlkaXR5TGV4ZXIuQ29uc3RydWN0b3JLZXl3b3JkID0gMTI2O1xuU29saWRpdHlMZXhlci5GYWxsYmFja0tleXdvcmQgPSAxMjc7XG5Tb2xpZGl0eUxleGVyLlJlY2VpdmVLZXl3b3JkID0gMTI4O1xuU29saWRpdHlMZXhlci5JZGVudGlmaWVyID0gMTI5O1xuU29saWRpdHlMZXhlci5TdHJpbmdMaXRlcmFsRnJhZ21lbnQgPSAxMzA7XG5Tb2xpZGl0eUxleGVyLlZlcnNpb25MaXRlcmFsID0gMTMxO1xuU29saWRpdHlMZXhlci5XUyA9IDEzMjtcblNvbGlkaXR5TGV4ZXIuQ09NTUVOVCA9IDEzMztcblNvbGlkaXR5TGV4ZXIuTElORV9DT01NRU5UID0gMTM0O1xuU29saWRpdHlMZXhlci5jaGFubmVsTmFtZXMgPSBbXG4gIFwiREVGQVVMVF9UT0tFTl9DSEFOTkVMXCIsXG4gIFwiSElEREVOXCJcbl07XG5Tb2xpZGl0eUxleGVyLm1vZGVOYW1lcyA9IFtcbiAgXCJERUZBVUxUX01PREVcIlxuXTtcblNvbGlkaXR5TGV4ZXIucnVsZU5hbWVzID0gW1xuICBcIlRfXzBcIixcbiAgXCJUX18xXCIsXG4gIFwiVF9fMlwiLFxuICBcIlRfXzNcIixcbiAgXCJUX180XCIsXG4gIFwiVF9fNVwiLFxuICBcIlRfXzZcIixcbiAgXCJUX183XCIsXG4gIFwiVF9fOFwiLFxuICBcIlRfXzlcIixcbiAgXCJUX18xMFwiLFxuICBcIlRfXzExXCIsXG4gIFwiVF9fMTJcIixcbiAgXCJUX18xM1wiLFxuICBcIlRfXzE0XCIsXG4gIFwiVF9fMTVcIixcbiAgXCJUX18xNlwiLFxuICBcIlRfXzE3XCIsXG4gIFwiVF9fMThcIixcbiAgXCJUX18xOVwiLFxuICBcIlRfXzIwXCIsXG4gIFwiVF9fMjFcIixcbiAgXCJUX18yMlwiLFxuICBcIlRfXzIzXCIsXG4gIFwiVF9fMjRcIixcbiAgXCJUX18yNVwiLFxuICBcIlRfXzI2XCIsXG4gIFwiVF9fMjdcIixcbiAgXCJUX18yOFwiLFxuICBcIlRfXzI5XCIsXG4gIFwiVF9fMzBcIixcbiAgXCJUX18zMVwiLFxuICBcIlRfXzMyXCIsXG4gIFwiVF9fMzNcIixcbiAgXCJUX18zNFwiLFxuICBcIlRfXzM1XCIsXG4gIFwiVF9fMzZcIixcbiAgXCJUX18zN1wiLFxuICBcIlRfXzM4XCIsXG4gIFwiVF9fMzlcIixcbiAgXCJUX180MFwiLFxuICBcIlRfXzQxXCIsXG4gIFwiVF9fNDJcIixcbiAgXCJUX180M1wiLFxuICBcIlRfXzQ0XCIsXG4gIFwiVF9fNDVcIixcbiAgXCJUX180NlwiLFxuICBcIlRfXzQ3XCIsXG4gIFwiVF9fNDhcIixcbiAgXCJUX180OVwiLFxuICBcIlRfXzUwXCIsXG4gIFwiVF9fNTFcIixcbiAgXCJUX181MlwiLFxuICBcIlRfXzUzXCIsXG4gIFwiVF9fNTRcIixcbiAgXCJUX181NVwiLFxuICBcIlRfXzU2XCIsXG4gIFwiVF9fNTdcIixcbiAgXCJUX181OFwiLFxuICBcIlRfXzU5XCIsXG4gIFwiVF9fNjBcIixcbiAgXCJUX182MVwiLFxuICBcIlRfXzYyXCIsXG4gIFwiVF9fNjNcIixcbiAgXCJUX182NFwiLFxuICBcIlRfXzY1XCIsXG4gIFwiVF9fNjZcIixcbiAgXCJUX182N1wiLFxuICBcIlRfXzY4XCIsXG4gIFwiVF9fNjlcIixcbiAgXCJUX183MFwiLFxuICBcIlRfXzcxXCIsXG4gIFwiVF9fNzJcIixcbiAgXCJUX183M1wiLFxuICBcIlRfXzc0XCIsXG4gIFwiVF9fNzVcIixcbiAgXCJUX183NlwiLFxuICBcIlRfXzc3XCIsXG4gIFwiVF9fNzhcIixcbiAgXCJUX183OVwiLFxuICBcIlRfXzgwXCIsXG4gIFwiVF9fODFcIixcbiAgXCJUX184MlwiLFxuICBcIlRfXzgzXCIsXG4gIFwiVF9fODRcIixcbiAgXCJUX184NVwiLFxuICBcIlRfXzg2XCIsXG4gIFwiVF9fODdcIixcbiAgXCJUX184OFwiLFxuICBcIlRfXzg5XCIsXG4gIFwiVF9fOTBcIixcbiAgXCJUX185MVwiLFxuICBcIlRfXzkyXCIsXG4gIFwiVF9fOTNcIixcbiAgXCJUX185NFwiLFxuICBcIlRfXzk1XCIsXG4gIFwiVF9fOTZcIixcbiAgXCJJbnRcIixcbiAgXCJVaW50XCIsXG4gIFwiQnl0ZVwiLFxuICBcIkZpeGVkXCIsXG4gIFwiVWZpeGVkXCIsXG4gIFwiQm9vbGVhbkxpdGVyYWxcIixcbiAgXCJEZWNpbWFsTnVtYmVyXCIsXG4gIFwiRGVjaW1hbERpZ2l0c1wiLFxuICBcIkhleE51bWJlclwiLFxuICBcIkhleERpZ2l0c1wiLFxuICBcIk51bWJlclVuaXRcIixcbiAgXCJIZXhMaXRlcmFsRnJhZ21lbnRcIixcbiAgXCJIZXhQYWlyXCIsXG4gIFwiSGV4Q2hhcmFjdGVyXCIsXG4gIFwiUmVzZXJ2ZWRLZXl3b3JkXCIsXG4gIFwiQW5vbnltb3VzS2V5d29yZFwiLFxuICBcIkJyZWFrS2V5d29yZFwiLFxuICBcIkNvbnN0YW50S2V5d29yZFwiLFxuICBcIkltbXV0YWJsZUtleXdvcmRcIixcbiAgXCJDb250aW51ZUtleXdvcmRcIixcbiAgXCJMZWF2ZUtleXdvcmRcIixcbiAgXCJFeHRlcm5hbEtleXdvcmRcIixcbiAgXCJJbmRleGVkS2V5d29yZFwiLFxuICBcIkludGVybmFsS2V5d29yZFwiLFxuICBcIlBheWFibGVLZXl3b3JkXCIsXG4gIFwiUHJpdmF0ZUtleXdvcmRcIixcbiAgXCJQdWJsaWNLZXl3b3JkXCIsXG4gIFwiVmlydHVhbEtleXdvcmRcIixcbiAgXCJQdXJlS2V5d29yZFwiLFxuICBcIlR5cGVLZXl3b3JkXCIsXG4gIFwiVmlld0tleXdvcmRcIixcbiAgXCJHbG9iYWxLZXl3b3JkXCIsXG4gIFwiQ29uc3RydWN0b3JLZXl3b3JkXCIsXG4gIFwiRmFsbGJhY2tLZXl3b3JkXCIsXG4gIFwiUmVjZWl2ZUtleXdvcmRcIixcbiAgXCJJZGVudGlmaWVyXCIsXG4gIFwiSWRlbnRpZmllclN0YXJ0XCIsXG4gIFwiSWRlbnRpZmllclBhcnRcIixcbiAgXCJTdHJpbmdMaXRlcmFsRnJhZ21lbnRcIixcbiAgXCJEb3VibGVRdW90ZWRTdHJpbmdDaGFyYWN0ZXJcIixcbiAgXCJTaW5nbGVRdW90ZWRTdHJpbmdDaGFyYWN0ZXJcIixcbiAgXCJWZXJzaW9uTGl0ZXJhbFwiLFxuICBcIldTXCIsXG4gIFwiQ09NTUVOVFwiLFxuICBcIkxJTkVfQ09NTUVOVFwiXG5dO1xuU29saWRpdHlMZXhlci5fTElURVJBTF9OQU1FUyA9IFtcbiAgdm9pZCAwLFxuICBcIidwcmFnbWEnXCIsXG4gIFwiJzsnXCIsXG4gIFwiJyonXCIsXG4gIFwiJ3x8J1wiLFxuICBcIideJ1wiLFxuICBcIid+J1wiLFxuICBcIic+PSdcIixcbiAgXCInPidcIixcbiAgXCInPCdcIixcbiAgXCInPD0nXCIsXG4gIFwiJz0nXCIsXG4gIFwiJ2FzJ1wiLFxuICBcIidpbXBvcnQnXCIsXG4gIFwiJ2Zyb20nXCIsXG4gIFwiJ3snXCIsXG4gIFwiJywnXCIsXG4gIFwiJ30nXCIsXG4gIFwiJ2Fic3RyYWN0J1wiLFxuICBcIidjb250cmFjdCdcIixcbiAgXCInaW50ZXJmYWNlJ1wiLFxuICBcIidsaWJyYXJ5J1wiLFxuICBcIidpcydcIixcbiAgXCInKCdcIixcbiAgXCInKSdcIixcbiAgXCInZXJyb3InXCIsXG4gIFwiJ3VzaW5nJ1wiLFxuICBcIidmb3InXCIsXG4gIFwiJ3N0cnVjdCdcIixcbiAgXCInbW9kaWZpZXInXCIsXG4gIFwiJ2Z1bmN0aW9uJ1wiLFxuICBcIidyZXR1cm5zJ1wiLFxuICBcIidldmVudCdcIixcbiAgXCInZW51bSdcIixcbiAgXCInWydcIixcbiAgXCInXSdcIixcbiAgXCInYWRkcmVzcydcIixcbiAgXCInLidcIixcbiAgXCInbWFwcGluZydcIixcbiAgXCInPT4nXCIsXG4gIFwiJ21lbW9yeSdcIixcbiAgXCInc3RvcmFnZSdcIixcbiAgXCInY2FsbGRhdGEnXCIsXG4gIFwiJ2lmJ1wiLFxuICBcIidlbHNlJ1wiLFxuICBcIid0cnknXCIsXG4gIFwiJ2NhdGNoJ1wiLFxuICBcIid3aGlsZSdcIixcbiAgXCIndW5jaGVja2VkJ1wiLFxuICBcIidhc3NlbWJseSdcIixcbiAgXCInZG8nXCIsXG4gIFwiJ3JldHVybidcIixcbiAgXCIndGhyb3cnXCIsXG4gIFwiJ2VtaXQnXCIsXG4gIFwiJ3JldmVydCdcIixcbiAgXCIndmFyJ1wiLFxuICBcIidib29sJ1wiLFxuICBcIidzdHJpbmcnXCIsXG4gIFwiJ2J5dGUnXCIsXG4gIFwiJysrJ1wiLFxuICBcIictLSdcIixcbiAgXCInbmV3J1wiLFxuICBcIic6J1wiLFxuICBcIicrJ1wiLFxuICBcIictJ1wiLFxuICBcIidhZnRlcidcIixcbiAgXCInZGVsZXRlJ1wiLFxuICBcIichJ1wiLFxuICBcIicqKidcIixcbiAgXCInLydcIixcbiAgXCInJSdcIixcbiAgXCInPDwnXCIsXG4gIFwiJz4+J1wiLFxuICBcIicmJ1wiLFxuICBcIid8J1wiLFxuICBcIic9PSdcIixcbiAgXCInIT0nXCIsXG4gIFwiJyYmJ1wiLFxuICBcIic/J1wiLFxuICBcIid8PSdcIixcbiAgXCInXj0nXCIsXG4gIFwiJyY9J1wiLFxuICBcIic8PD0nXCIsXG4gIFwiJz4+PSdcIixcbiAgXCInKz0nXCIsXG4gIFwiJy09J1wiLFxuICBcIicqPSdcIixcbiAgXCInLz0nXCIsXG4gIFwiJyU9J1wiLFxuICBcIidsZXQnXCIsXG4gIFwiJzo9J1wiLFxuICBcIic9OidcIixcbiAgXCInc3dpdGNoJ1wiLFxuICBcIidjYXNlJ1wiLFxuICBcIidkZWZhdWx0J1wiLFxuICBcIictPidcIixcbiAgXCInY2FsbGJhY2snXCIsXG4gIFwiJ292ZXJyaWRlJ1wiLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgXCInYW5vbnltb3VzJ1wiLFxuICBcIidicmVhaydcIixcbiAgXCInY29uc3RhbnQnXCIsXG4gIFwiJ2ltbXV0YWJsZSdcIixcbiAgXCInY29udGludWUnXCIsXG4gIFwiJ2xlYXZlJ1wiLFxuICBcIidleHRlcm5hbCdcIixcbiAgXCInaW5kZXhlZCdcIixcbiAgXCInaW50ZXJuYWwnXCIsXG4gIFwiJ3BheWFibGUnXCIsXG4gIFwiJ3ByaXZhdGUnXCIsXG4gIFwiJ3B1YmxpYydcIixcbiAgXCIndmlydHVhbCdcIixcbiAgXCIncHVyZSdcIixcbiAgXCIndHlwZSdcIixcbiAgXCIndmlldydcIixcbiAgXCInZ2xvYmFsJ1wiLFxuICBcIidjb25zdHJ1Y3RvcidcIixcbiAgXCInZmFsbGJhY2snXCIsXG4gIFwiJ3JlY2VpdmUnXCJcbl07XG5Tb2xpZGl0eUxleGVyLl9TWU1CT0xJQ19OQU1FUyA9IFtcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIFwiSW50XCIsXG4gIFwiVWludFwiLFxuICBcIkJ5dGVcIixcbiAgXCJGaXhlZFwiLFxuICBcIlVmaXhlZFwiLFxuICBcIkJvb2xlYW5MaXRlcmFsXCIsXG4gIFwiRGVjaW1hbE51bWJlclwiLFxuICBcIkhleE51bWJlclwiLFxuICBcIk51bWJlclVuaXRcIixcbiAgXCJIZXhMaXRlcmFsRnJhZ21lbnRcIixcbiAgXCJSZXNlcnZlZEtleXdvcmRcIixcbiAgXCJBbm9ueW1vdXNLZXl3b3JkXCIsXG4gIFwiQnJlYWtLZXl3b3JkXCIsXG4gIFwiQ29uc3RhbnRLZXl3b3JkXCIsXG4gIFwiSW1tdXRhYmxlS2V5d29yZFwiLFxuICBcIkNvbnRpbnVlS2V5d29yZFwiLFxuICBcIkxlYXZlS2V5d29yZFwiLFxuICBcIkV4dGVybmFsS2V5d29yZFwiLFxuICBcIkluZGV4ZWRLZXl3b3JkXCIsXG4gIFwiSW50ZXJuYWxLZXl3b3JkXCIsXG4gIFwiUGF5YWJsZUtleXdvcmRcIixcbiAgXCJQcml2YXRlS2V5d29yZFwiLFxuICBcIlB1YmxpY0tleXdvcmRcIixcbiAgXCJWaXJ0dWFsS2V5d29yZFwiLFxuICBcIlB1cmVLZXl3b3JkXCIsXG4gIFwiVHlwZUtleXdvcmRcIixcbiAgXCJWaWV3S2V5d29yZFwiLFxuICBcIkdsb2JhbEtleXdvcmRcIixcbiAgXCJDb25zdHJ1Y3RvcktleXdvcmRcIixcbiAgXCJGYWxsYmFja0tleXdvcmRcIixcbiAgXCJSZWNlaXZlS2V5d29yZFwiLFxuICBcIklkZW50aWZpZXJcIixcbiAgXCJTdHJpbmdMaXRlcmFsRnJhZ21lbnRcIixcbiAgXCJWZXJzaW9uTGl0ZXJhbFwiLFxuICBcIldTXCIsXG4gIFwiQ09NTUVOVFwiLFxuICBcIkxJTkVfQ09NTUVOVFwiXG5dO1xuU29saWRpdHlMZXhlci5WT0NBQlVMQVJZID0gbmV3IGltcG9ydF9Wb2NhYnVsYXJ5SW1wbC5Wb2NhYnVsYXJ5SW1wbChfU29saWRpdHlMZXhlci5fTElURVJBTF9OQU1FUywgX1NvbGlkaXR5TGV4ZXIuX1NZTUJPTElDX05BTUVTLCBbXSk7XG5Tb2xpZGl0eUxleGVyLl9zZXJpYWxpemVkQVROU2VnbWVudHMgPSA0O1xuU29saWRpdHlMZXhlci5fc2VyaWFsaXplZEFUTlNlZ21lbnQwID0gYFx1MDAwM1xcdUM5MURcXHVDQUJBXFx1MDU4RFxcdUFGQkFcXHU0RjUzXFx1MDYwN1xcdUVBOEJcXHVDMjQxXHUwMDAyXFx4ODhcXHUwNzU3XFxiXHUwMDAxXHUwMDA0XHUwMDAyXHRcdTAwMDJcdTAwMDRcdTAwMDNcdFx1MDAwM1x1MDAwNFx1MDAwNFx0XHUwMDA0XHUwMDA0XHUwMDA1XHRcdTAwMDVcdTAwMDRcdTAwMDZcdFx1MDAwNlx1MDAwNFxceDA3XHRcXHgwN1x1MDAwNFxcYlx0XFxiXHUwMDA0XHRcdFx0XHUwMDA0XG5cdFxuXHUwMDA0XFx2XHRcXHZcdTAwMDRcXGZcdFxcZlx1MDAwNFxcclx0XFxyXHUwMDA0XHUwMDBlXHRcdTAwMGVcdTAwMDRcdTAwMGZcdFx1MDAwZlx1MDAwNFx1MDAxMFx0XHUwMDEwXHUwMDA0XHUwMDExXHRcdTAwMTFcdTAwMDRcdTAwMTJcdFx1MDAxMlx1MDAwNFx1MDAxM1x0XHUwMDEzXHUwMDA0XHUwMDE0XHRcdTAwMTRcdTAwMDRcdTAwMTVcdFx1MDAxNVx1MDAwNFx1MDAxNlx0XHUwMDE2XHUwMDA0XHUwMDE3XHRcdTAwMTdcdTAwMDRcdTAwMThcdFx1MDAxOFx1MDAwNFx1MDAxOVx0XHUwMDE5XHUwMDA0XHUwMDFhXHRcdTAwMWFcdTAwMDRcdTAwMWJcdFx1MDAxYlx1MDAwNFx1MDAxY1x0XHUwMDFjXHUwMDA0XHUwMDFkXHRcdTAwMWRcdTAwMDRcdTAwMWVcdFx1MDAxZVx1MDAwNFx1MDAxZlx0XHUwMDFmXHUwMDA0IFx0IFx1MDAwNCFcdCFcdTAwMDRcIlx0XCJcdTAwMDQjXHQjXHUwMDA0JFx0JFx1MDAwNCVcdCVcdTAwMDQmXHQmXHUwMDA0J1x0J1x1MDAwNChcdChcdTAwMDQpXHQpXHUwMDA0Klx0Klx1MDAwNCtcdCtcdTAwMDQsXHQsXHUwMDA0LVx0LVx1MDAwNC5cdC5cdTAwMDQvXHQvXHUwMDA0MFx0MFx1MDAwNDFcdDFcdTAwMDQyXHQyXHUwMDA0M1x0M1x1MDAwNDRcdDRcdTAwMDQ1XHQ1XHUwMDA0Nlx0Nlx1MDAwNDdcdDdcdTAwMDQ4XHQ4XHUwMDA0OVx0OVx1MDAwNDpcdDpcdTAwMDQ7XHQ7XHUwMDA0PFx0PFx1MDAwND1cdD1cdTAwMDQ+XHQ+XHUwMDA0P1x0P1x1MDAwNEBcdEBcdTAwMDRBXHRBXHUwMDA0Qlx0Qlx1MDAwNENcdENcdTAwMDREXHREXHUwMDA0RVx0RVx1MDAwNEZcdEZcdTAwMDRHXHRHXHUwMDA0SFx0SFx1MDAwNElcdElcdTAwMDRKXHRKXHUwMDA0S1x0S1x1MDAwNExcdExcdTAwMDRNXHRNXHUwMDA0Tlx0Tlx1MDAwNE9cdE9cdTAwMDRQXHRQXHUwMDA0UVx0UVx1MDAwNFJcdFJcdTAwMDRTXHRTXHUwMDA0VFx0VFx1MDAwNFVcdFVcdTAwMDRWXHRWXHUwMDA0V1x0V1x1MDAwNFhcdFhcdTAwMDRZXHRZXHUwMDA0Wlx0Wlx1MDAwNFtcdFtcdTAwMDRcXFxcXHRcXFxcXHUwMDA0XVx0XVx1MDAwNF5cdF5cdTAwMDRfXHRfXHUwMDA0XFxgXHRcXGBcdTAwMDRhXHRhXHUwMDA0Ylx0Ylx1MDAwNGNcdGNcdTAwMDRkXHRkXHUwMDA0ZVx0ZVx1MDAwNGZcdGZcdTAwMDRnXHRnXHUwMDA0aFx0aFx1MDAwNGlcdGlcdTAwMDRqXHRqXHUwMDA0a1x0a1x1MDAwNGxcdGxcdTAwMDRtXHRtXHUwMDA0blx0blx1MDAwNG9cdG9cdTAwMDRwXHRwXHUwMDA0cVx0cVx1MDAwNHJcdHJcdTAwMDRzXHRzXHUwMDA0dFx0dFx1MDAwNHVcdHVcdTAwMDR2XHR2XHUwMDA0d1x0d1x1MDAwNHhcdHhcdTAwMDR5XHR5XHUwMDA0elx0elx1MDAwNHtcdHtcdTAwMDR8XHR8XHUwMDA0fVx0fVx1MDAwNH5cdH5cdTAwMDRcXHg3Rlx0XFx4N0ZcdTAwMDRcXHg4MFx0XFx4ODBcdTAwMDRcXHg4MVx0XFx4ODFcdTAwMDRcXHg4Mlx0XFx4ODJcdTAwMDRcXHg4M1x0XFx4ODNcdTAwMDRcXHg4NFx0XFx4ODRcdTAwMDRcXHg4NVx0XFx4ODVcdTAwMDRcXHg4Nlx0XFx4ODZcdTAwMDRcXHg4N1x0XFx4ODdcdTAwMDRcXHg4OFx0XFx4ODhcdTAwMDRcXHg4OVx0XFx4ODlcdTAwMDRcXHg4QVx0XFx4OEFcdTAwMDRcXHg4Qlx0XFx4OEJcdTAwMDRcXHg4Q1x0XFx4OENcdTAwMDRcXHg4RFx0XFx4OERcdTAwMDRcXHg4RVx0XFx4OEVcdTAwMDRcXHg4Rlx0XFx4OEZcdTAwMDNcdTAwMDJcdTAwMDNcdTAwMDJcdTAwMDNcdTAwMDJcdTAwMDNcdTAwMDJcdTAwMDNcdTAwMDJcdTAwMDNcdTAwMDJcdTAwMDNcdTAwMDJcdTAwMDNcdTAwMDNcdTAwMDNcdTAwMDNcdTAwMDNcdTAwMDRcdTAwMDNcdTAwMDRcdTAwMDNcdTAwMDVcdTAwMDNcdTAwMDVcdTAwMDNcdTAwMDVcdTAwMDNcdTAwMDZcdTAwMDNcdTAwMDZcdTAwMDNcXHgwN1x1MDAwM1xceDA3XHUwMDAzXFxiXHUwMDAzXFxiXHUwMDAzXFxiXHUwMDAzXHRcdTAwMDNcdFx1MDAwM1xuXHUwMDAzXG5cdTAwMDNcXHZcdTAwMDNcXHZcdTAwMDNcXHZcdTAwMDNcXGZcdTAwMDNcXGZcdTAwMDNcXHJcdTAwMDNcXHJcdTAwMDNcXHJcdTAwMDNcdTAwMGVcdTAwMDNcdTAwMGVcdTAwMDNcdTAwMGVcdTAwMDNcdTAwMGVcdTAwMDNcdTAwMGVcdTAwMDNcdTAwMGVcdTAwMDNcdTAwMGVcdTAwMDNcdTAwMGZcdTAwMDNcdTAwMGZcdTAwMDNcdTAwMGZcdTAwMDNcdTAwMGZcdTAwMDNcdTAwMGZcdTAwMDNcdTAwMTBcdTAwMDNcdTAwMTBcdTAwMDNcdTAwMTFcdTAwMDNcdTAwMTFcdTAwMDNcdTAwMTJcdTAwMDNcdTAwMTJcdTAwMDNcdTAwMTNcdTAwMDNcdTAwMTNcdTAwMDNcdTAwMTNcdTAwMDNcdTAwMTNcdTAwMDNcdTAwMTNcdTAwMDNcdTAwMTNcdTAwMDNcdTAwMTNcdTAwMDNcdTAwMTNcdTAwMDNcdTAwMTNcdTAwMDNcdTAwMTRcdTAwMDNcdTAwMTRcdTAwMDNcdTAwMTRcdTAwMDNcdTAwMTRcdTAwMDNcdTAwMTRcdTAwMDNcdTAwMTRcdTAwMDNcdTAwMTRcdTAwMDNcdTAwMTRcdTAwMDNcdTAwMTRcdTAwMDNcdTAwMTVcdTAwMDNcdTAwMTVcdTAwMDNcdTAwMTVcdTAwMDNcdTAwMTVcdTAwMDNcdTAwMTVcdTAwMDNcdTAwMTVcdTAwMDNcdTAwMTVcdTAwMDNcdTAwMTVcdTAwMDNcdTAwMTVcdTAwMDNcdTAwMTVcdTAwMDNcdTAwMTZcdTAwMDNcdTAwMTZcdTAwMDNcdTAwMTZcdTAwMDNcdTAwMTZcdTAwMDNcdTAwMTZcdTAwMDNcdTAwMTZcdTAwMDNcdTAwMTZcdTAwMDNcdTAwMTZcdTAwMDNcdTAwMTdcdTAwMDNcdTAwMTdcdTAwMDNcdTAwMTdcdTAwMDNcdTAwMThcdTAwMDNcdTAwMThcdTAwMDNcdTAwMTlcdTAwMDNcdTAwMTlcdTAwMDNcdTAwMWFcdTAwMDNcdTAwMWFcdTAwMDNcdTAwMWFcdTAwMDNcdTAwMWFcdTAwMDNcdTAwMWFcdTAwMDNcdTAwMWFcdTAwMDNcdTAwMWJcdTAwMDNcdTAwMWJcdTAwMDNcdTAwMWJcdTAwMDNcdTAwMWJcdTAwMDNcdTAwMWJcdTAwMDNcdTAwMWJcdTAwMDNcdTAwMWNcdTAwMDNcdTAwMWNcdTAwMDNcdTAwMWNcdTAwMDNcdTAwMWNcdTAwMDNcdTAwMWRcdTAwMDNcdTAwMWRcdTAwMDNcdTAwMWRcdTAwMDNcdTAwMWRcdTAwMDNcdTAwMWRcdTAwMDNcdTAwMWRcdTAwMDNcdTAwMWRcdTAwMDNcdTAwMWVcdTAwMDNcdTAwMWVcdTAwMDNcdTAwMWVcdTAwMDNcdTAwMWVcdTAwMDNcdTAwMWVcdTAwMDNcdTAwMWVcdTAwMDNcdTAwMWVcdTAwMDNcdTAwMWVcdTAwMDNcdTAwMWVcdTAwMDNcdTAwMWZcdTAwMDNcdTAwMWZcdTAwMDNcdTAwMWZcdTAwMDNcdTAwMWZcdTAwMDNcdTAwMWZcdTAwMDNcdTAwMWZcdTAwMDNcdTAwMWZcdTAwMDNcdTAwMWZcdTAwMDNcdTAwMWZcdTAwMDMgXHUwMDAzIFx1MDAwMyBcdTAwMDMgXHUwMDAzIFx1MDAwMyBcdTAwMDMgXHUwMDAzIFx1MDAwMyFcdTAwMDMhXHUwMDAzIVx1MDAwMyFcdTAwMDMhXHUwMDAzIVx1MDAwM1wiXHUwMDAzXCJcdTAwMDNcIlx1MDAwM1wiXHUwMDAzXCJcdTAwMDMjXHUwMDAzI1x1MDAwMyRcdTAwMDMkXHUwMDAzJVx1MDAwMyVcdTAwMDMlXHUwMDAzJVx1MDAwMyVcdTAwMDMlXHUwMDAzJVx1MDAwMyVcdTAwMDMmXHUwMDAzJlx1MDAwMydcdTAwMDMnXHUwMDAzJ1x1MDAwMydcdTAwMDMnXHUwMDAzJ1x1MDAwMydcdTAwMDMnXHUwMDAzKFx1MDAwMyhcdTAwMDMoXHUwMDAzKVx1MDAwMylcdTAwMDMpXHUwMDAzKVx1MDAwMylcdTAwMDMpXHUwMDAzKVx1MDAwMypcdTAwMDMqXHUwMDAzKlx1MDAwMypcdTAwMDMqXHUwMDAzKlx1MDAwMypcdTAwMDMqXHUwMDAzK1x1MDAwMytcdTAwMDMrXHUwMDAzK1x1MDAwMytcdTAwMDMrXHUwMDAzK1x1MDAwMytcdTAwMDMrXHUwMDAzLFx1MDAwMyxcdTAwMDMsXHUwMDAzLVx1MDAwMy1cdTAwMDMtXHUwMDAzLVx1MDAwMy1cdTAwMDMuXHUwMDAzLlx1MDAwMy5cdTAwMDMuXHUwMDAzL1x1MDAwMy9cdTAwMDMvXHUwMDAzL1x1MDAwMy9cdTAwMDMvXHUwMDAzMFx1MDAwMzBcdTAwMDMwXHUwMDAzMFx1MDAwMzBcdTAwMDMwXHUwMDAzMVx1MDAwMzFcdTAwMDMxXHUwMDAzMVx1MDAwMzFcdTAwMDMxXHUwMDAzMVx1MDAwMzFcdTAwMDMxXHUwMDAzMVx1MDAwMzJcdTAwMDMyXHUwMDAzMlx1MDAwMzJcdTAwMDMyXHUwMDAzMlx1MDAwMzJcdTAwMDMyXHUwMDAzMlx1MDAwMzNcdTAwMDMzXHUwMDAzM1x1MDAwMzRcdTAwMDM0XHUwMDAzNFx1MDAwMzRcdTAwMDM0XHUwMDAzNFx1MDAwMzRcdTAwMDM1XHUwMDAzNVx1MDAwMzVcdTAwMDM1XHUwMDAzNVx1MDAwMzVcdTAwMDM2XHUwMDAzNlx1MDAwMzZcdTAwMDM2XHUwMDAzNlx1MDAwMzdcdTAwMDM3XHUwMDAzN1x1MDAwMzdcdTAwMDM3XHUwMDAzN1x1MDAwMzdcdTAwMDM4XHUwMDAzOFx1MDAwMzhcdTAwMDM4XHUwMDAzOVx1MDAwMzlcdTAwMDM5XHUwMDAzOVx1MDAwMzlcdTAwMDM6XHUwMDAzOlx1MDAwMzpcdTAwMDM6XHUwMDAzOlx1MDAwMzpcdTAwMDM6XHUwMDAzO1x1MDAwMztcdTAwMDM7XHUwMDAzO1x1MDAwMztcdTAwMDM8XHUwMDAzPFx1MDAwMzxcdTAwMDM9XHUwMDAzPVx1MDAwMz1cdTAwMDM+XHUwMDAzPlx1MDAwMz5cdTAwMDM+XHUwMDAzP1x1MDAwMz9cdTAwMDNAXHUwMDAzQFx1MDAwM0FcdTAwMDNBXHUwMDAzQlx1MDAwM0JcdTAwMDNCXHUwMDAzQlx1MDAwM0JcdTAwMDNCXHUwMDAzQ1x1MDAwM0NcdTAwMDNDXHUwMDAzQ1x1MDAwM0NcdTAwMDNDXHUwMDAzQ1x1MDAwM0RcdTAwMDNEXHUwMDAzRVx1MDAwM0VcdTAwMDNFXHUwMDAzRlx1MDAwM0ZcdTAwMDNHXHUwMDAzR1x1MDAwM0hcdTAwMDNIXHUwMDAzSFx1MDAwM0lcdTAwMDNJXHUwMDAzSVx1MDAwM0pcdTAwMDNKXHUwMDAzS1x1MDAwM0tcdTAwMDNMXHUwMDAzTFx1MDAwM0xcdTAwMDNNXHUwMDAzTVx1MDAwM01cdTAwMDNOXHUwMDAzTlx1MDAwM05cdTAwMDNPXHUwMDAzT1x1MDAwM1BcdTAwMDNQXHUwMDAzUFx1MDAwM1FcdTAwMDNRXHUwMDAzUVx1MDAwM1JcdTAwMDNSXHUwMDAzUlx1MDAwM1NcdTAwMDNTXHUwMDAzU1x1MDAwM1NcdTAwMDNUXHUwMDAzVFx1MDAwM1RcdTAwMDNUXHUwMDAzVVx1MDAwM1VcdTAwMDNVXHUwMDAzVlx1MDAwM1ZcdTAwMDNWXHUwMDAzV1x1MDAwM1dcdTAwMDNXXHUwMDAzWFx1MDAwM1hcdTAwMDNYXHUwMDAzWVx1MDAwM1lcdTAwMDNZXHUwMDAzWlx1MDAwM1pcdTAwMDNaXHUwMDAzWlx1MDAwM1tcdTAwMDNbXHUwMDAzW1x1MDAwM1xcXFxcdTAwMDNcXFxcXHUwMDAzXFxcXFx1MDAwM11cdTAwMDNdXHUwMDAzXVx1MDAwM11cdTAwMDNdXHUwMDAzXVx1MDAwM11cdTAwMDNeXHUwMDAzXlx1MDAwM15cdTAwMDNeXHUwMDAzXlx1MDAwM19cdTAwMDNfXHUwMDAzX1x1MDAwM19cdTAwMDNfXHUwMDAzX1x1MDAwM19cdTAwMDNfXHUwMDAzXFxgXHUwMDAzXFxgXHUwMDAzXFxgXHUwMDAzYVx1MDAwM2FcdTAwMDNhXHUwMDAzYVx1MDAwM2FcdTAwMDNhXHUwMDAzYVx1MDAwM2FcdTAwMDNhXHUwMDAzYlx1MDAwM2JcdTAwMDNiXHUwMDAzYlx1MDAwM2JcdTAwMDNiXHUwMDAzYlx1MDAwM2JcdTAwMDNiXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDNjXHUwMDAzY1x1MDAwM2NcdTAwMDVjXFx1MDM4QlxuY1x1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDAzZFx1MDAwM2RcdTAwMDNkXHUwMDA1ZFxcdTA0NjRcbmRcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDAzZVx1MDAwM2VcdTAwMDNlXHUwMDA1ZVxcdTA1NDJcbmVcdTAwMDNmXHUwMDAzZlx1MDAwM2ZcdTAwMDNmXHUwMDAzZlx1MDAwM2ZcdTAwMDNmXHUwMDAzZlx1MDAwM2ZcdTAwMDNmXHUwMDAzZlx1MDAwM2ZcdTAwMDZmXFx1MDU1MFxuZlxccmZcdTAwMGVmXFx1MDU1MVx1MDAwM2ZcdTAwMDNmXHUwMDA2ZlxcdTA1NTZcbmZcXHJmXHUwMDBlZlxcdTA1NTdcdTAwMDVmXFx1MDU1QVxuZlx1MDAwM2dcdTAwMDNnXHUwMDAzZ1x1MDAwM2dcdTAwMDNnXHUwMDAzZ1x1MDAwM2dcdTAwMDNnXHUwMDAzZ1x1MDAwM2dcdTAwMDNnXHUwMDAzZ1x1MDAwM2dcdTAwMDNnXHUwMDA2Z1xcdTA1NkFcbmdcXHJnXHUwMDBlZ1xcdTA1NkJcdTAwMDNnXHUwMDAzZ1x1MDAwNmdcXHUwNTcwXG5nXFxyZ1x1MDAwZWdcXHUwNTcxXHUwMDA1Z1xcdTA1NzRcbmdcdTAwMDNoXHUwMDAzaFx1MDAwM2hcdTAwMDNoXHUwMDAzaFx1MDAwM2hcdTAwMDNoXHUwMDAzaFx1MDAwM2hcdTAwMDVoXFx1MDU3RlxuaFx1MDAwM2lcdTAwMDNpXHUwMDA1aVxcdTA1ODNcbmlcdTAwMDNpXHUwMDAzaVx1MDAwNWlcXHUwNTg3XG5pXHUwMDAzaVx1MDAwM2lcdTAwMDVpXFx1MDU4QlxuaVx1MDAwM2pcdTAwMDNqXHUwMDA1alxcdTA1OEZcbmpcdTAwMDNqXFx4MDdqXFx1MDU5MlxualxcZmpcdTAwMGVqXFx1MDU5NVxcdmpcdTAwMDNrXHUwMDAza1x1MDAwM2tcdTAwMDNrXHUwMDAzbFx1MDAwM2xcdTAwMDVsXFx1MDU5RFxubFx1MDAwM2xcXHgwN2xcXHUwNUEwXG5sXFxmbFx1MDAwZWxcXHUwNUEzXFx2bFx1MDAwM21cdTAwMDNtXHUwMDAzbVx1MDAwM21cdTAwMDNtXHUwMDAzbVx1MDAwM21cdTAwMDNtXHUwMDAzbVx1MDAwM21cdTAwMDNtXHUwMDAzbVx1MDAwM21cdTAwMDNtXHUwMDAzbVx1MDAwM21cdTAwMDNtXHUwMDAzbVx1MDAwM21cdTAwMDNtXHUwMDAzbVx1MDAwM21cdTAwMDNtXHUwMDAzbVx1MDAwM21cdTAwMDNtXHUwMDAzbVx1MDAwM21cdTAwMDNtXHUwMDAzbVx1MDAwM21cdTAwMDNtXHUwMDAzbVx1MDAwM21cdTAwMDNtXHUwMDAzbVx1MDAwM21cdTAwMDNtXHUwMDAzbVx1MDAwM21cdTAwMDNtXHUwMDAzbVx1MDAwM21cdTAwMDNtXHUwMDAzbVx1MDAwM21cdTAwMDNtXHUwMDAzbVx1MDAwM21cdTAwMDNtXHUwMDAzbVx1MDAwM21cdTAwMDNtXHUwMDAzbVx1MDAwM21cdTAwMDNtXHUwMDA1bVxcdTA1RERcbm1cdTAwMDNuXHUwMDAzblx1MDAwM25cdTAwMDNuXHUwMDAzblx1MDAwM25cdTAwMDVuXFx1MDVFNVxublx1MDAwM25cdTAwMDNuXHUwMDAzblx1MDAwNW5cXHUwNUVBXG5uXHUwMDAzblx1MDAwNW5cXHUwNUVEXG5uXHUwMDAzb1x1MDAwM29cdTAwMDNvXHUwMDAzcFx1MDAwM3BcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDAzcVx1MDAwM3FcdTAwMDNxXHUwMDA1cVxcdTA2NENcbnFcdTAwMDNyXHUwMDAzclx1MDAwM3JcdTAwMDNyXHUwMDAzclx1MDAwM3JcdTAwMDNyXHUwMDAzclx1MDAwM3JcdTAwMDNyXHUwMDAzc1x1MDAwM3NcdTAwMDNzXHUwMDAzc1x1MDAwM3NcdTAwMDNzXHUwMDAzdFx1MDAwM3RcdTAwMDN0XHUwMDAzdFx1MDAwM3RcdTAwMDN0XHUwMDAzdFx1MDAwM3RcdTAwMDN0XHUwMDAzdVx1MDAwM3VcdTAwMDN1XHUwMDAzdVx1MDAwM3VcdTAwMDN1XHUwMDAzdVx1MDAwM3VcdTAwMDN1XHUwMDAzdVx1MDAwM3ZcdTAwMDN2XHUwMDAzdlx1MDAwM3ZcdTAwMDN2XHUwMDAzdlx1MDAwM3ZcdTAwMDN2XHUwMDAzdlx1MDAwM3dcdTAwMDN3XHUwMDAzd1x1MDAwM3dcdTAwMDN3XHUwMDAzd1x1MDAwM3hcdTAwMDN4XHUwMDAzeFx1MDAwM3hcdTAwMDN4XHUwMDAzeFx1MDAwM3hcdTAwMDN4XHUwMDAzeFx1MDAwM3lcdTAwMDN5XHUwMDAzeVx1MDAwM3lcdTAwMDN5XHUwMDAzeVx1MDAwM3lcdTAwMDN5XHUwMDAzelx1MDAwM3pcdTAwMDN6XHUwMDAzelx1MDAwM3pcdTAwMDN6XHUwMDAzelx1MDAwM3pcdTAwMDN6XHUwMDAze1x1MDAwM3tcdTAwMDN7XHUwMDAze1x1MDAwM3tcdTAwMDN7XHUwMDAze1x1MDAwM3tcdTAwMDN8XHUwMDAzfFx1MDAwM3xcdTAwMDN8XHUwMDAzfFx1MDAwM3xcdTAwMDN8XHUwMDAzfFx1MDAwM31cdTAwMDN9XHUwMDAzfVx1MDAwM31cdTAwMDN9XHUwMDAzfVx1MDAwM31cdTAwMDN+XHUwMDAzflx1MDAwM35cdTAwMDN+XHUwMDAzflx1MDAwM35cdTAwMDN+XHUwMDAzflx1MDAwM1xceDdGXHUwMDAzXFx4N0ZcdTAwMDNcXHg3Rlx1MDAwM1xceDdGXHUwMDAzXFx4N0ZcdTAwMDNcXHg4MFx1MDAwM1xceDgwXHUwMDAzXFx4ODBcdTAwMDNcXHg4MFx1MDAwM1xceDgwXHUwMDAzXFx4ODFcdTAwMDNcXHg4MVx1MDAwM1xceDgxXHUwMDAzXFx4ODFcdTAwMDNcXHg4MVx1MDAwM1xceDgyXHUwMDAzXFx4ODJcdTAwMDNcXHg4Mlx1MDAwM1xceDgyXHUwMDAzXFx4ODJcdTAwMDNcXHg4Mlx1MDAwM1xceDgyXHUwMDAzXFx4ODNcdTAwMDNcXHg4M1x1MDAwM1xceDgzXHUwMDAzXFx4ODNcdTAwMDNcXHg4M1x1MDAwM1xceDgzXHUwMDAzXFx4ODNcdTAwMDNcXHg4M1x1MDAwM1xceDgzXHUwMDAzXFx4ODNcdTAwMDNcXHg4M1x1MDAwM1xceDgzXHUwMDAzXFx4ODRcdTAwMDNcXHg4NFx1MDAwM1xceDg0XHUwMDAzXFx4ODRcdTAwMDNcXHg4NFx1MDAwM1xceDg0XHUwMDAzXFx4ODRcdTAwMDNcXHg4NFx1MDAwM1xceDg0XHUwMDAzXFx4ODVcdTAwMDNcXHg4NVx1MDAwM1xceDg1XHUwMDAzXFx4ODVcdTAwMDNcXHg4NVx1MDAwM1xceDg1XHUwMDAzXFx4ODVcdTAwMDNcXHg4NVx1MDAwM1xceDg2XHUwMDAzXFx4ODZcXHgwN1xceDg2XFx1MDZFRVxuXFx4ODZcXGZcXHg4Nlx1MDAwZVxceDg2XFx1MDZGMVxcdlxceDg2XHUwMDAzXFx4ODdcdTAwMDNcXHg4N1x1MDAwM1xceDg4XHUwMDAzXFx4ODhcdTAwMDNcXHg4OVx1MDAwM1xceDg5XHUwMDAzXFx4ODlcdTAwMDNcXHg4OVx1MDAwM1xceDg5XHUwMDAzXFx4ODlcdTAwMDNcXHg4OVx1MDAwNVxceDg5XFx1MDZGRVxuXFx4ODlcdTAwMDNcXHg4OVx1MDAwM1xceDg5XFx4MDdcXHg4OVxcdTA3MDJcblxceDg5XFxmXFx4ODlcdTAwMGVcXHg4OVxcdTA3MDVcXHZcXHg4OVx1MDAwM1xceDg5XHUwMDAzXFx4ODlcdTAwMDNcXHg4OVx1MDAwM1xceDg5XHUwMDAzXFx4ODlcdTAwMDNcXHg4OVx1MDAwM1xceDg5XHUwMDAzXFx4ODlcdTAwMDVcXHg4OVxcdTA3MEZcblxceDg5XHUwMDAzXFx4ODlcdTAwMDNcXHg4OVxceDA3XFx4ODlcXHUwNzEzXG5cXHg4OVxcZlxceDg5XHUwMDBlXFx4ODlcXHUwNzE2XFx2XFx4ODlcdTAwMDNcXHg4OVx1MDAwNVxceDg5XFx1MDcxOVxuXFx4ODlcdTAwMDNcXHg4QVx1MDAwM1xceDhBXHUwMDAzXFx4OEFcdTAwMDVcXHg4QVxcdTA3MUVcblxceDhBXHUwMDAzXFx4OEJcdTAwMDNcXHg4Qlx1MDAwM1xceDhCXHUwMDA1XFx4OEJcXHUwNzIzXG5cXHg4Qlx1MDAwM1xceDhDXHUwMDA2XFx4OENcXHUwNzI2XG5cXHg4Q1xcclxceDhDXHUwMDBlXFx4OENcXHUwNzI3XHUwMDAzXFx4OENcdTAwMDNcXHg4Q1x1MDAwNlxceDhDXFx1MDcyQ1xuXFx4OENcXHJcXHg4Q1x1MDAwZVxceDhDXFx1MDcyRFx1MDAwM1xceDhDXHUwMDAzXFx4OENcdTAwMDZcXHg4Q1xcdTA3MzJcblxceDhDXFxyXFx4OENcdTAwMGVcXHg4Q1xcdTA3MzNcdTAwMDVcXHg4Q1xcdTA3MzZcblxceDhDXHUwMDAzXFx4OERcdTAwMDZcXHg4RFxcdTA3MzlcblxceDhEXFxyXFx4OERcdTAwMGVcXHg4RFxcdTA3M0FcdTAwMDNcXHg4RFx1MDAwM1xceDhEXHUwMDAzXFx4OEVcdTAwMDNcXHg4RVx1MDAwM1xceDhFXHUwMDAzXFx4OEVcXHgwN1xceDhFXFx1MDc0M1xuXFx4OEVcXGZcXHg4RVx1MDAwZVxceDhFXFx1MDc0NlxcdlxceDhFXHUwMDAzXFx4OEVcdTAwMDNcXHg4RVx1MDAwM1xceDhFXHUwMDAzXFx4OEVcdTAwMDNcXHg4RVx1MDAwM1xceDhGXHUwMDAzXFx4OEZcdTAwMDNcXHg4Rlx1MDAwM1xceDhGXFx4MDdcXHg4RlxcdTA3NTFcblxceDhGXFxmXFx4OEZcdTAwMGVcXHg4RlxcdTA3NTRcXHZcXHg4Rlx1MDAwM1xceDhGXHUwMDAzXFx4OEZcdTAwMDNcXHUwNzQ0XHUwMDAyXHUwMDAyXFx4OTBcdTAwMDNcdTAwMDJcdTAwMDNcdTAwMDVcdTAwMDJcdTAwMDRcXHgwN1x1MDAwMlx1MDAwNVx0XHUwMDAyXHUwMDA2XFx2XHUwMDAyXFx4MDdcXHJcdTAwMDJcXGJcdTAwMGZcdTAwMDJcdFx1MDAxMVx1MDAwMlxuXHUwMDEzXHUwMDAyXFx2XHUwMDE1XHUwMDAyXFxmXHUwMDE3XHUwMDAyXFxyXHUwMDE5XHUwMDAyXHUwMDBlXHUwMDFiXHUwMDAyXHUwMDBmXHUwMDFkXHUwMDAyXHUwMDEwXHUwMDFmXHUwMDAyXHUwMDExIVx1MDAwMlx1MDAxMiNcdTAwMDJcdTAwMTMlXHUwMDAyXHUwMDE0J1x1MDAwMlx1MDAxNSlcdTAwMDJcdTAwMTYrXHUwMDAyXHUwMDE3LVx1MDAwMlx1MDAxOC9cdTAwMDJcdTAwMTkxXHUwMDAyXHUwMDFhM1x1MDAwMlx1MDAxYjVcdTAwMDJcdTAwMWM3XHUwMDAyXHUwMDFkOVx1MDAwMlx1MDAxZTtcdTAwMDJcdTAwMWY9XHUwMDAyID9cdTAwMDIhQVx1MDAwMlwiQ1x1MDAwMiNFXHUwMDAyJEdcdTAwMDIlSVx1MDAwMiZLXHUwMDAyJ01cdTAwMDIoT1x1MDAwMilRXHUwMDAyKlNcdTAwMDIrVVx1MDAwMixXXHUwMDAyLVlcdTAwMDIuW1x1MDAwMi9dXHUwMDAyMF9cdTAwMDIxYVx1MDAwMjJjXHUwMDAyM2VcdTAwMDI0Z1x1MDAwMjVpXHUwMDAyNmtcdTAwMDI3bVx1MDAwMjhvXHUwMDAyOXFcdTAwMDI6c1x1MDAwMjt1XHUwMDAyPHdcdTAwMDI9eVx1MDAwMj57XHUwMDAyP31cdTAwMDJAXFx4N0ZcdTAwMDJBXFx4ODFcdTAwMDJCXFx4ODNcdTAwMDJDXFx4ODVcdTAwMDJEXFx4ODdcdTAwMDJFXFx4ODlcdTAwMDJGXFx4OEJcdTAwMDJHXFx4OERcdTAwMDJIXFx4OEZcdTAwMDJJXFx4OTFcdTAwMDJKXFx4OTNcdTAwMDJLXFx4OTVcdTAwMDJMXFx4OTdcdTAwMDJNXFx4OTlcdTAwMDJOXFx4OUJcdTAwMDJPXFx4OURcdTAwMDJQXFx4OUZcdTAwMDJRXFx4QTFcdTAwMDJSXFx4QTNcdTAwMDJTXFx4QTVcdTAwMDJUXFx4QTdcdTAwMDJVXFx4QTlcdTAwMDJWXFx4QUJcdTAwMDJXXFx4QURcdTAwMDJYXFx4QUZcdTAwMDJZXFx4QjFcdTAwMDJaXFx4QjNcdTAwMDJbXFx4QjVcdTAwMDJcXFxcXFx4QjdcdTAwMDJdXFx4QjlcdTAwMDJeXFx4QkJcdTAwMDJfXFx4QkRcdTAwMDJcXGBcXHhCRlx1MDAwMmFcXHhDMVx1MDAwMmJcXHhDM1x1MDAwMmNcXHhDNVx1MDAwMmRcXHhDN1x1MDAwMmVcXHhDOVx1MDAwMmZcXHhDQlx1MDAwMmdcXHhDRFx1MDAwMmhcXHhDRlx1MDAwMmlcXHhEMVx1MDAwMmpcXHhEM1x1MDAwMlx1MDAwMlxceEQ1XHUwMDAya1xceEQ3XHUwMDAyXHUwMDAyXFx4RDlcdTAwMDJsXFx4REJcdTAwMDJtXFx4RERcdTAwMDJcdTAwMDJcXHhERlx1MDAwMlx1MDAwMlxceEUxXHUwMDAyblxceEUzXHUwMDAyb1xceEU1XHUwMDAycFxceEU3XHUwMDAycVxceEU5XHUwMDAyclxceEVCXHUwMDAyc1xceEVEXHUwMDAydFxceEVGXHUwMDAydVxceEYxXHUwMDAydlxceEYzXHUwMDAyd1xceEY1XHUwMDAyeFxceEY3XHUwMDAyeVxceEY5XHUwMDAyelxceEZCXHUwMDAye1xceEZEXHUwMDAyfFxceEZGXHUwMDAyfVxcdTAxMDFcdTAwMDJ+XFx1MDEwM1x1MDAwMlxceDdGXFx1MDEwNVx1MDAwMlxceDgwXFx1MDEwN1x1MDAwMlxceDgxXFx1MDEwOVx1MDAwMlxceDgyXFx1MDEwQlx1MDAwMlxceDgzXFx1MDEwRFx1MDAwMlx1MDAwMlxcdTAxMEZcdTAwMDJcdTAwMDJcXHUwMTExXHUwMDAyXFx4ODRcXHUwMTEzXHUwMDAyXHUwMDAyXFx1MDExNVx1MDAwMlx1MDAwMlxcdTAxMTdcdTAwMDJcXHg4NVxcdTAxMTlcdTAwMDJcXHg4NlxcdTAxMUJcdTAwMDJcXHg4N1xcdTAxMURcdTAwMDJcXHg4OFx1MDAwM1x1MDAwMlxcZlx1MDAwM1x1MDAwMjI7XHUwMDA0XHUwMDAyR0dnZ1x1MDAwNFx1MDAwMlpaenpcdTAwMDVcdTAwMDIyO0NIY2hcdTAwMDZcdTAwMDImJkNcXFxcYWFjfFxceDA3XHUwMDAyJiYyO0NcXFxcYWFjfFx1MDAwNlx1MDAwMlxcZlxcZlx1MDAwZlx1MDAwZiQkXl5cdTAwMDZcdTAwMDJcXGZcXGZcdTAwMGZcdTAwMGYpKV5eXHUwMDA1XHUwMDAyXFx2XFxmXHUwMDBlXHUwMDBmXCJcIlx1MDAwNFx1MDAwMlxcZlxcZlx1MDAwZlx1MDAwZlx1MDAwMlxcdTA3RThcdTAwMDJcdTAwMDNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHgwN1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlx0XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFxyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDBmXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDExXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDEzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDE1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDE3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDE5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDFiXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDFkXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDFmXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyIVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMiNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDIlXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyJ1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMilcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDIrXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyLVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMi9cdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDIxXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyM1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMjVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDI3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyOVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMjtcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDI9XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyP1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMkFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyRVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMkdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJJXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyS1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMk1cdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJPXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyUVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJVXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyV1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMllcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJbXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMl9cdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJhXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyY1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMmVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJnXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyaVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMmtcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJtXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyb1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMnFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAydVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMndcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJ5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAye1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMn1cdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHg3Rlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxceDgxXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx4ODNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHg4NVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxceDg3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx4ODlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHg4Qlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxceDhEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx4OEZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHg5MVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxceDkzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx4OTVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHg5N1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxceDk5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx4OUJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHg5RFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxceDlGXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx4QTFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHhBM1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxceEE1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx4QTdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHhBOVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxceEFCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx4QURcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHhBRlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxceEIxXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx4QjNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHhCNVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxceEI3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx4QjlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHhCQlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxceEJEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx4QkZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHhDMVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxceEMzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx4QzVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHhDN1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxceEM5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx4Q0JcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHhDRFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxceENGXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx4RDFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHhENVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxceEQ5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx4REJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHhFMVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxceEUzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx4RTVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHhFN1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMmA7XG5Tb2xpZGl0eUxleGVyLl9zZXJpYWxpemVkQVROU2VnbWVudDEgPSBcIlx1MDAwMlxceEU5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx4RUJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHhFRFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxceEVGXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx4RjFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHhGM1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxceEY1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx4RjdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHhGOVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxceEZCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx4RkRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHhGRlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMDFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTAzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDEwNVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMDdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTA5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDEwQlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMTFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTE3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDExOVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMUJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTFEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDAzXFx1MDExRlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwNVxcdTAxMjZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHgwN1xcdTAxMjhcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdFxcdTAxMkFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHZcXHUwMTJEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFxyXFx1MDEyRlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwZlxcdTAxMzFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMTFcXHUwMTM0XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDEzXFx1MDEzNlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAxNVxcdTAxMzhcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMTdcXHUwMTNCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDE5XFx1MDEzRFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAxYlxcdTAxNDBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMWRcXHUwMTQ3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDFmXFx1MDE0Q1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMiFcXHUwMTRFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyI1xcdTAxNTBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDIlXFx1MDE1Mlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMidcXHUwMTVCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyKVxcdTAxNjRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDIrXFx1MDE2RVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMi1cXHUwMTc2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyL1xcdTAxNzlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDIxXFx1MDE3Qlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMjNcXHUwMTdEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyNVxcdTAxODNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDI3XFx1MDE4OVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMjlcXHUwMThEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyO1xcdTAxOTRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDI9XFx1MDE5RFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMj9cXHUwMUE2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyQVxcdTAxQUVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJDXFx1MDFCNFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMkVcXHUwMUI5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyR1xcdTAxQkJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJJXFx1MDFCRFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMktcXHUwMUM1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyTVxcdTAxQzdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJPXFx1MDFDRlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlFcXHUwMUQyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyU1xcdTAxRDlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJVXFx1MDFFMVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMldcXHUwMUVBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyWVxcdTAxRURcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJbXFx1MDFGMlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMl1cXHUwMUY2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyX1xcdTAxRkNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJhXFx1MDIwMlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMmNcXHUwMjBDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyZVxcdTAyMTVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJnXFx1MDIxOFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMmlcXHUwMjFGXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAya1xcdTAyMjVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJtXFx1MDIyQVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMm9cXHUwMjMxXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAycVxcdTAyMzVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJzXFx1MDIzQVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMnVcXHUwMjQxXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyd1xcdTAyNDZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJ5XFx1MDI0OVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMntcXHUwMjRDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyfVxcdTAyNTBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHg3RlxcdTAyNTJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHg4MVxcdTAyNTRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHg4M1xcdTAyNTZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHg4NVxcdTAyNUNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHg4N1xcdTAyNjNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHg4OVxcdTAyNjVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHg4QlxcdTAyNjhcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHg4RFxcdTAyNkFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHg4RlxcdTAyNkNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHg5MVxcdTAyNkZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHg5M1xcdTAyNzJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHg5NVxcdTAyNzRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHg5N1xcdTAyNzZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHg5OVxcdTAyNzlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHg5QlxcdTAyN0NcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHg5RFxcdTAyN0ZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHg5RlxcdTAyODFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhBMVxcdTAyODRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhBM1xcdTAyODdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhBNVxcdTAyOEFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhBN1xcdTAyOEVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhBOVxcdTAyOTJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhBQlxcdTAyOTVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhBRFxcdTAyOThcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhBRlxcdTAyOUJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhCMVxcdTAyOUVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhCM1xcdTAyQTFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhCNVxcdTAyQTVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhCN1xcdTAyQThcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhCOVxcdTAyQUJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhCQlxcdTAyQjJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhCRFxcdTAyQjdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhCRlxcdTAyQkZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhDMVxcdTAyQzJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhDM1xcdTAyQ0JcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhDNVxcdTAzOEFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhDN1xcdTA0NjNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhDOVxcdTA1NDFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhDQlxcdTA1NTlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhDRFxcdTA1NzNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhDRlxcdTA1N0VcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhEMVxcdTA1ODZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhEM1xcdTA1OENcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhENVxcdTA1OTZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhEN1xcdTA1OUFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhEOVxcdTA1RENcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhEQlxcdTA1REVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhERFxcdTA1RUVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhERlxcdTA1RjFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhFMVxcdTA2NEJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhFM1xcdTA2NERcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhFNVxcdTA2NTdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhFN1xcdTA2NURcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhFOVxcdTA2NjZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhFQlxcdTA2NzBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhFRFxcdTA2NzlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhFRlxcdTA2N0ZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhGMVxcdTA2ODhcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhGM1xcdTA2OTBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhGNVxcdTA2OTlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhGN1xcdTA2QTFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhGOVxcdTA2QTlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhGQlxcdTA2QjBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhGRFxcdTA2QjhcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhGRlxcdTA2QkRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTAxXFx1MDZDMlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMDNcXHUwNkM3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDEwNVxcdTA2Q0VcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTA3XFx1MDZEQVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMDlcXHUwNkUzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDEwQlxcdTA2RUJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTBEXFx1MDZGMlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMEZcXHUwNkY0XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDExMVxcdTA3MThcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTEzXFx1MDcxRFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMTVcXHUwNzIyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDExN1xcdTA3MjVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTE5XFx1MDczOFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMUJcXHUwNzNFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDExRFxcdTA3NENcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTFGXFx1MDEyMFxceDA3clx1MDAwMlx1MDAwMlxcdTAxMjBcXHUwMTIxXFx4MDd0XHUwMDAyXHUwMDAyXFx1MDEyMVxcdTAxMjJcXHgwN2NcdTAwMDJcdTAwMDJcXHUwMTIyXFx1MDEyM1xceDA3aVx1MDAwMlx1MDAwMlxcdTAxMjNcXHUwMTI0XFx4MDdvXHUwMDAyXHUwMDAyXFx1MDEyNFxcdTAxMjVcXHgwN2NcdTAwMDJcdTAwMDJcXHUwMTI1XHUwMDA0XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDEyNlxcdTAxMjdcXHgwNz1cdTAwMDJcdTAwMDJcXHUwMTI3XHUwMDA2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDEyOFxcdTAxMjlcXHgwNyxcdTAwMDJcdTAwMDJcXHUwMTI5XFxiXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDEyQVxcdTAxMkJcXHgwN35cdTAwMDJcdTAwMDJcXHUwMTJCXFx1MDEyQ1xceDA3flx1MDAwMlx1MDAwMlxcdTAxMkNcXG5cdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTJEXFx1MDEyRVxceDA3YFx1MDAwMlx1MDAwMlxcdTAxMkVcXGZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTJGXFx1MDEzMFxceDA3XFx4ODBcdTAwMDJcdTAwMDJcXHUwMTMwXHUwMDBlXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDEzMVxcdTAxMzJcXHgwN0BcdTAwMDJcdTAwMDJcXHUwMTMyXFx1MDEzM1xceDA3P1x1MDAwMlx1MDAwMlxcdTAxMzNcdTAwMTBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTM0XFx1MDEzNVxceDA3QFx1MDAwMlx1MDAwMlxcdTAxMzVcdTAwMTJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTM2XFx1MDEzN1xceDA3Plx1MDAwMlx1MDAwMlxcdTAxMzdcdTAwMTRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTM4XFx1MDEzOVxceDA3Plx1MDAwMlx1MDAwMlxcdTAxMzlcXHUwMTNBXFx4MDc/XHUwMDAyXHUwMDAyXFx1MDEzQVx1MDAxNlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxM0JcXHUwMTNDXFx4MDc/XHUwMDAyXHUwMDAyXFx1MDEzQ1x1MDAxOFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxM0RcXHUwMTNFXFx4MDdjXHUwMDAyXHUwMDAyXFx1MDEzRVxcdTAxM0ZcXHgwN3VcdTAwMDJcdTAwMDJcXHUwMTNGXHUwMDFhXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDE0MFxcdTAxNDFcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMTQxXFx1MDE0MlxceDA3b1x1MDAwMlx1MDAwMlxcdTAxNDJcXHUwMTQzXFx4MDdyXHUwMDAyXHUwMDAyXFx1MDE0M1xcdTAxNDRcXHgwN3FcdTAwMDJcdTAwMDJcXHUwMTQ0XFx1MDE0NVxceDA3dFx1MDAwMlx1MDAwMlxcdTAxNDVcXHUwMTQ2XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDE0Nlx1MDAxY1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxNDdcXHUwMTQ4XFx4MDdoXHUwMDAyXHUwMDAyXFx1MDE0OFxcdTAxNDlcXHgwN3RcdTAwMDJcdTAwMDJcXHUwMTQ5XFx1MDE0QVxceDA3cVx1MDAwMlx1MDAwMlxcdTAxNEFcXHUwMTRCXFx4MDdvXHUwMDAyXHUwMDAyXFx1MDE0Qlx1MDAxZVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxNENcXHUwMTREXFx4MDd9XHUwMDAyXHUwMDAyXFx1MDE0RCBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTRFXFx1MDE0RlxceDA3Llx1MDAwMlx1MDAwMlxcdTAxNEZcXFwiXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDE1MFxcdTAxNTFcXHgwN1xceDdGXHUwMDAyXHUwMDAyXFx1MDE1MSRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTUyXFx1MDE1M1xceDA3Y1x1MDAwMlx1MDAwMlxcdTAxNTNcXHUwMTU0XFx4MDdkXHUwMDAyXHUwMDAyXFx1MDE1NFxcdTAxNTVcXHgwN3VcdTAwMDJcdTAwMDJcXHUwMTU1XFx1MDE1NlxceDA3dlx1MDAwMlx1MDAwMlxcdTAxNTZcXHUwMTU3XFx4MDd0XHUwMDAyXHUwMDAyXFx1MDE1N1xcdTAxNThcXHgwN2NcdTAwMDJcdTAwMDJcXHUwMTU4XFx1MDE1OVxceDA3ZVx1MDAwMlx1MDAwMlxcdTAxNTlcXHUwMTVBXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDE1QSZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTVCXFx1MDE1Q1xceDA3ZVx1MDAwMlx1MDAwMlxcdTAxNUNcXHUwMTVEXFx4MDdxXHUwMDAyXHUwMDAyXFx1MDE1RFxcdTAxNUVcXHgwN3BcdTAwMDJcdTAwMDJcXHUwMTVFXFx1MDE1RlxceDA3dlx1MDAwMlx1MDAwMlxcdTAxNUZcXHUwMTYwXFx4MDd0XHUwMDAyXHUwMDAyXFx1MDE2MFxcdTAxNjFcXHgwN2NcdTAwMDJcdTAwMDJcXHUwMTYxXFx1MDE2MlxceDA3ZVx1MDAwMlx1MDAwMlxcdTAxNjJcXHUwMTYzXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDE2MyhcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTY0XFx1MDE2NVxceDA3a1x1MDAwMlx1MDAwMlxcdTAxNjVcXHUwMTY2XFx4MDdwXHUwMDAyXHUwMDAyXFx1MDE2NlxcdTAxNjdcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwMTY3XFx1MDE2OFxceDA3Z1x1MDAwMlx1MDAwMlxcdTAxNjhcXHUwMTY5XFx4MDd0XHUwMDAyXHUwMDAyXFx1MDE2OVxcdTAxNkFcXHgwN2hcdTAwMDJcdTAwMDJcXHUwMTZBXFx1MDE2QlxceDA3Y1x1MDAwMlx1MDAwMlxcdTAxNkJcXHUwMTZDXFx4MDdlXHUwMDAyXHUwMDAyXFx1MDE2Q1xcdTAxNkRcXHgwN2dcdTAwMDJcdTAwMDJcXHUwMTZEKlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxNkVcXHUwMTZGXFx4MDduXHUwMDAyXHUwMDAyXFx1MDE2RlxcdTAxNzBcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMTcwXFx1MDE3MVxceDA3ZFx1MDAwMlx1MDAwMlxcdTAxNzFcXHUwMTcyXFx4MDd0XHUwMDAyXHUwMDAyXFx1MDE3MlxcdTAxNzNcXHgwN2NcdTAwMDJcdTAwMDJcXHUwMTczXFx1MDE3NFxceDA3dFx1MDAwMlx1MDAwMlxcdTAxNzRcXHUwMTc1XFx4MDd7XHUwMDAyXHUwMDAyXFx1MDE3NSxcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTc2XFx1MDE3N1xceDA3a1x1MDAwMlx1MDAwMlxcdTAxNzdcXHUwMTc4XFx4MDd1XHUwMDAyXHUwMDAyXFx1MDE3OC5cdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTc5XFx1MDE3QVxceDA3Klx1MDAwMlx1MDAwMlxcdTAxN0EwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDE3QlxcdTAxN0NcXHgwNytcdTAwMDJcdTAwMDJcXHUwMTdDMlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxN0RcXHUwMTdFXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDE3RVxcdTAxN0ZcXHgwN3RcdTAwMDJcdTAwMDJcXHUwMTdGXFx1MDE4MFxceDA3dFx1MDAwMlx1MDAwMlxcdTAxODBcXHUwMTgxXFx4MDdxXHUwMDAyXHUwMDAyXFx1MDE4MVxcdTAxODJcXHgwN3RcdTAwMDJcdTAwMDJcXHUwMTgyNFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxODNcXHUwMTg0XFx4MDd3XHUwMDAyXHUwMDAyXFx1MDE4NFxcdTAxODVcXHgwN3VcdTAwMDJcdTAwMDJcXHUwMTg1XFx1MDE4NlxceDA3a1x1MDAwMlx1MDAwMlxcdTAxODZcXHUwMTg3XFx4MDdwXHUwMDAyXHUwMDAyXFx1MDE4N1xcdTAxODhcXHgwN2lcdTAwMDJcdTAwMDJcXHUwMTg4Nlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxODlcXHUwMThBXFx4MDdoXHUwMDAyXHUwMDAyXFx1MDE4QVxcdTAxOEJcXHgwN3FcdTAwMDJcdTAwMDJcXHUwMThCXFx1MDE4Q1xceDA3dFx1MDAwMlx1MDAwMlxcdTAxOEM4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDE4RFxcdTAxOEVcXHgwN3VcdTAwMDJcdTAwMDJcXHUwMThFXFx1MDE4RlxceDA3dlx1MDAwMlx1MDAwMlxcdTAxOEZcXHUwMTkwXFx4MDd0XHUwMDAyXHUwMDAyXFx1MDE5MFxcdTAxOTFcXHgwN3dcdTAwMDJcdTAwMDJcXHUwMTkxXFx1MDE5MlxceDA3ZVx1MDAwMlx1MDAwMlxcdTAxOTJcXHUwMTkzXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDE5MzpcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTk0XFx1MDE5NVxceDA3b1x1MDAwMlx1MDAwMlxcdTAxOTVcXHUwMTk2XFx4MDdxXHUwMDAyXHUwMDAyXFx1MDE5NlxcdTAxOTdcXHgwN2ZcdTAwMDJcdTAwMDJcXHUwMTk3XFx1MDE5OFxceDA3a1x1MDAwMlx1MDAwMlxcdTAxOThcXHUwMTk5XFx4MDdoXHUwMDAyXHUwMDAyXFx1MDE5OVxcdTAxOUFcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMTlBXFx1MDE5QlxceDA3Z1x1MDAwMlx1MDAwMlxcdTAxOUJcXHUwMTlDXFx4MDd0XHUwMDAyXHUwMDAyXFx1MDE5QzxcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTlEXFx1MDE5RVxceDA3aFx1MDAwMlx1MDAwMlxcdTAxOUVcXHUwMTlGXFx4MDd3XHUwMDAyXHUwMDAyXFx1MDE5RlxcdTAxQTBcXHgwN3BcdTAwMDJcdTAwMDJcXHUwMUEwXFx1MDFBMVxceDA3ZVx1MDAwMlx1MDAwMlxcdTAxQTFcXHUwMUEyXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDFBMlxcdTAxQTNcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMUEzXFx1MDFBNFxceDA3cVx1MDAwMlx1MDAwMlxcdTAxQTRcXHUwMUE1XFx4MDdwXHUwMDAyXHUwMDAyXFx1MDFBNT5cdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUE2XFx1MDFBN1xceDA3dFx1MDAwMlx1MDAwMlxcdTAxQTdcXHUwMUE4XFx4MDdnXHUwMDAyXHUwMDAyXFx1MDFBOFxcdTAxQTlcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwMUE5XFx1MDFBQVxceDA3d1x1MDAwMlx1MDAwMlxcdTAxQUFcXHUwMUFCXFx4MDd0XHUwMDAyXHUwMDAyXFx1MDFBQlxcdTAxQUNcXHgwN3BcdTAwMDJcdTAwMDJcXHUwMUFDXFx1MDFBRFxceDA3dVx1MDAwMlx1MDAwMlxcdTAxQURAXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFBRVxcdTAxQUZcXHgwN2dcdTAwMDJcdTAwMDJcXHUwMUFGXFx1MDFCMFxceDA3eFx1MDAwMlx1MDAwMlxcdTAxQjBcXHUwMUIxXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDFCMVxcdTAxQjJcXHgwN3BcdTAwMDJcdTAwMDJcXHUwMUIyXFx1MDFCM1xceDA3dlx1MDAwMlx1MDAwMlxcdTAxQjNCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFCNFxcdTAxQjVcXHgwN2dcdTAwMDJcdTAwMDJcXHUwMUI1XFx1MDFCNlxceDA3cFx1MDAwMlx1MDAwMlxcdTAxQjZcXHUwMUI3XFx4MDd3XHUwMDAyXHUwMDAyXFx1MDFCN1xcdTAxQjhcXHgwN29cdTAwMDJcdTAwMDJcXHUwMUI4RFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxQjlcXHUwMUJBXFx4MDddXHUwMDAyXHUwMDAyXFx1MDFCQUZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUJCXFx1MDFCQ1xceDA3X1x1MDAwMlx1MDAwMlxcdTAxQkNIXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFCRFxcdTAxQkVcXHgwN2NcdTAwMDJcdTAwMDJcXHUwMUJFXFx1MDFCRlxceDA3Zlx1MDAwMlx1MDAwMlxcdTAxQkZcXHUwMUMwXFx4MDdmXHUwMDAyXHUwMDAyXFx1MDFDMFxcdTAxQzFcXHgwN3RcdTAwMDJcdTAwMDJcXHUwMUMxXFx1MDFDMlxceDA3Z1x1MDAwMlx1MDAwMlxcdTAxQzJcXHUwMUMzXFx4MDd1XHUwMDAyXHUwMDAyXFx1MDFDM1xcdTAxQzRcXHgwN3VcdTAwMDJcdTAwMDJcXHUwMUM0Slx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxQzVcXHUwMUM2XFx4MDcwXHUwMDAyXHUwMDAyXFx1MDFDNkxcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUM3XFx1MDFDOFxceDA3b1x1MDAwMlx1MDAwMlxcdTAxQzhcXHUwMUM5XFx4MDdjXHUwMDAyXHUwMDAyXFx1MDFDOVxcdTAxQ0FcXHgwN3JcdTAwMDJcdTAwMDJcXHUwMUNBXFx1MDFDQlxceDA3clx1MDAwMlx1MDAwMlxcdTAxQ0JcXHUwMUNDXFx4MDdrXHUwMDAyXHUwMDAyXFx1MDFDQ1xcdTAxQ0RcXHgwN3BcdTAwMDJcdTAwMDJcXHUwMUNEXFx1MDFDRVxceDA3aVx1MDAwMlx1MDAwMlxcdTAxQ0VOXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFDRlxcdTAxRDBcXHgwNz9cdTAwMDJcdTAwMDJcXHUwMUQwXFx1MDFEMVxceDA3QFx1MDAwMlx1MDAwMlxcdTAxRDFQXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFEMlxcdTAxRDNcXHgwN29cdTAwMDJcdTAwMDJcXHUwMUQzXFx1MDFENFxceDA3Z1x1MDAwMlx1MDAwMlxcdTAxRDRcXHUwMUQ1XFx4MDdvXHUwMDAyXHUwMDAyXFx1MDFENVxcdTAxRDZcXHgwN3FcdTAwMDJcdTAwMDJcXHUwMUQ2XFx1MDFEN1xceDA3dFx1MDAwMlx1MDAwMlxcdTAxRDdcXHUwMUQ4XFx4MDd7XHUwMDAyXHUwMDAyXFx1MDFEOFJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUQ5XFx1MDFEQVxceDA3dVx1MDAwMlx1MDAwMlxcdTAxREFcXHUwMURCXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDFEQlxcdTAxRENcXHgwN3FcdTAwMDJcdTAwMDJcXHUwMURDXFx1MDFERFxceDA3dFx1MDAwMlx1MDAwMlxcdTAxRERcXHUwMURFXFx4MDdjXHUwMDAyXHUwMDAyXFx1MDFERVxcdTAxREZcXHgwN2lcdTAwMDJcdTAwMDJcXHUwMURGXFx1MDFFMFxceDA3Z1x1MDAwMlx1MDAwMlxcdTAxRTBUXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFFMVxcdTAxRTJcXHgwN2VcdTAwMDJcdTAwMDJcXHUwMUUyXFx1MDFFM1xceDA3Y1x1MDAwMlx1MDAwMlxcdTAxRTNcXHUwMUU0XFx4MDduXHUwMDAyXHUwMDAyXFx1MDFFNFxcdTAxRTVcXHgwN25cdTAwMDJcdTAwMDJcXHUwMUU1XFx1MDFFNlxceDA3Zlx1MDAwMlx1MDAwMlxcdTAxRTZcXHUwMUU3XFx4MDdjXHUwMDAyXHUwMDAyXFx1MDFFN1xcdTAxRThcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwMUU4XFx1MDFFOVxceDA3Y1x1MDAwMlx1MDAwMlxcdTAxRTlWXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFFQVxcdTAxRUJcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMUVCXFx1MDFFQ1xceDA3aFx1MDAwMlx1MDAwMlxcdTAxRUNYXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFFRFxcdTAxRUVcXHgwN2dcdTAwMDJcdTAwMDJcXHUwMUVFXFx1MDFFRlxceDA3blx1MDAwMlx1MDAwMlxcdTAxRUZcXHUwMUYwXFx4MDd1XHUwMDAyXHUwMDAyXFx1MDFGMFxcdTAxRjFcXHgwN2dcdTAwMDJcdTAwMDJcXHUwMUYxWlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxRjJcXHUwMUYzXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDFGM1xcdTAxRjRcXHgwN3RcdTAwMDJcdTAwMDJcXHUwMUY0XFx1MDFGNVxceDA3e1x1MDAwMlx1MDAwMlxcdTAxRjVcXFxcXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFGNlxcdTAxRjdcXHgwN2VcdTAwMDJcdTAwMDJcXHUwMUY3XFx1MDFGOFxceDA3Y1x1MDAwMlx1MDAwMlxcdTAxRjhcXHUwMUY5XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDFGOVxcdTAxRkFcXHgwN2VcdTAwMDJcdTAwMDJcXHUwMUZBXFx1MDFGQlxceDA3alx1MDAwMlx1MDAwMlxcdTAxRkJeXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFGQ1xcdTAxRkRcXHgwN3lcdTAwMDJcdTAwMDJcXHUwMUZEXFx1MDFGRVxceDA3alx1MDAwMlx1MDAwMlxcdTAxRkVcXHUwMUZGXFx4MDdrXHUwMDAyXHUwMDAyXFx1MDFGRlxcdTAyMDBcXHgwN25cdTAwMDJcdTAwMDJcXHUwMjAwXFx1MDIwMVxceDA3Z1x1MDAwMlx1MDAwMlxcdTAyMDFgXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDIwMlxcdTAyMDNcXHgwN3dcdTAwMDJcdTAwMDJcXHUwMjAzXFx1MDIwNFxceDA3cFx1MDAwMlx1MDAwMlxcdTAyMDRcXHUwMjA1XFx4MDdlXHUwMDAyXHUwMDAyXFx1MDIwNVxcdTAyMDZcXHgwN2pcdTAwMDJcdTAwMDJcXHUwMjA2XFx1MDIwN1xceDA3Z1x1MDAwMlx1MDAwMlxcdTAyMDdcXHUwMjA4XFx4MDdlXHUwMDAyXHUwMDAyXFx1MDIwOFxcdTAyMDlcXHgwN21cdTAwMDJcdTAwMDJcXHUwMjA5XFx1MDIwQVxceDA3Z1x1MDAwMlx1MDAwMlxcdTAyMEFcXHUwMjBCXFx4MDdmXHUwMDAyXHUwMDAyXFx1MDIwQmJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjBDXFx1MDIwRFxceDA3Y1x1MDAwMlx1MDAwMlxcdTAyMERcXHUwMjBFXFx4MDd1XHUwMDAyXHUwMDAyXFx1MDIwRVxcdTAyMEZcXHgwN3VcdTAwMDJcdTAwMDJcXHUwMjBGXFx1MDIxMFxceDA3Z1x1MDAwMlx1MDAwMlxcdTAyMTBcXHUwMjExXFx4MDdvXHUwMDAyXHUwMDAyXFx1MDIxMVxcdTAyMTJcXHgwN2RcdTAwMDJcdTAwMDJcXHUwMjEyXFx1MDIxM1xceDA3blx1MDAwMlx1MDAwMlxcdTAyMTNcXHUwMjE0XFx4MDd7XHUwMDAyXHUwMDAyXFx1MDIxNGRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjE1XFx1MDIxNlxceDA3Zlx1MDAwMlx1MDAwMlxcdTAyMTZcXHUwMjE3XFx4MDdxXHUwMDAyXHUwMDAyXFx1MDIxN2ZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjE4XFx1MDIxOVxceDA3dFx1MDAwMlx1MDAwMlxcdTAyMTlcXHUwMjFBXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDIxQVxcdTAyMUJcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwMjFCXFx1MDIxQ1xceDA3d1x1MDAwMlx1MDAwMlxcdTAyMUNcXHUwMjFEXFx4MDd0XHUwMDAyXHUwMDAyXFx1MDIxRFxcdTAyMUVcXHgwN3BcdTAwMDJcdTAwMDJcXHUwMjFFaFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyMUZcXHUwMjIwXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDIyMFxcdTAyMjFcXHgwN2pcdTAwMDJcdTAwMDJcXHUwMjIxXFx1MDIyMlxceDA3dFx1MDAwMlx1MDAwMlxcdTAyMjJcXHUwMjIzXFx4MDdxXHUwMDAyXHUwMDAyXFx1MDIyM1xcdTAyMjRcXHgwN3lcdTAwMDJcdTAwMDJcXHUwMjI0alx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyMjVcXHUwMjI2XFx4MDdnXHUwMDAyXHUwMDAyXFx1MDIyNlxcdTAyMjdcXHgwN29cdTAwMDJcdTAwMDJcXHUwMjI3XFx1MDIyOFxceDA3a1x1MDAwMlx1MDAwMlxcdTAyMjhcXHUwMjI5XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDIyOWxcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjJBXFx1MDIyQlxceDA3dFx1MDAwMlx1MDAwMlxcdTAyMkJcXHUwMjJDXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDIyQ1xcdTAyMkRcXHgwN3hcdTAwMDJcdTAwMDJcXHUwMjJEXFx1MDIyRVxceDA3Z1x1MDAwMlx1MDAwMlxcdTAyMkVcXHUwMjJGXFx4MDd0XHUwMDAyXHUwMDAyXFx1MDIyRlxcdTAyMzBcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwMjMwblx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyMzFcXHUwMjMyXFx4MDd4XHUwMDAyXHUwMDAyXFx1MDIzMlxcdTAyMzNcXHgwN2NcdTAwMDJcdTAwMDJcXHUwMjMzXFx1MDIzNFxceDA3dFx1MDAwMlx1MDAwMlxcdTAyMzRwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDIzNVxcdTAyMzZcXHgwN2RcdTAwMDJcdTAwMDJcXHUwMjM2XFx1MDIzN1xceDA3cVx1MDAwMlx1MDAwMlxcdTAyMzdcXHUwMjM4XFx4MDdxXHUwMDAyXHUwMDAyXFx1MDIzOFxcdTAyMzlcXHgwN25cdTAwMDJcdTAwMDJcXHUwMjM5clx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyM0FcXHUwMjNCXFx4MDd1XHUwMDAyXHUwMDAyXFx1MDIzQlxcdTAyM0NcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwMjNDXFx1MDIzRFxceDA3dFx1MDAwMlx1MDAwMlxcdTAyM0RcXHUwMjNFXFx4MDdrXHUwMDAyXHUwMDAyXFx1MDIzRVxcdTAyM0ZcXHgwN3BcdTAwMDJcdTAwMDJcXHUwMjNGXFx1MDI0MFxceDA3aVx1MDAwMlx1MDAwMlxcdTAyNDB0XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI0MVxcdTAyNDJcXHgwN2RcdTAwMDJcdTAwMDJcXHUwMjQyXFx1MDI0M1xceDA3e1x1MDAwMlx1MDAwMlxcdTAyNDNcXHUwMjQ0XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDI0NFxcdTAyNDVcXHgwN2dcdTAwMDJcdTAwMDJcXHUwMjQ1dlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyNDZcXHUwMjQ3XFx4MDctXHUwMDAyXHUwMDAyXFx1MDI0N1xcdTAyNDhcXHgwNy1cdTAwMDJcdTAwMDJcXHUwMjQ4eFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyNDlcXHUwMjRBXFx4MDcvXHUwMDAyXHUwMDAyXFx1MDI0QVxcdTAyNEJcXHgwNy9cdTAwMDJcdTAwMDJcXHUwMjRCelx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyNENcXHUwMjREXFx4MDdwXHUwMDAyXHUwMDAyXFx1MDI0RFxcdTAyNEVcXHgwN2dcdTAwMDJcdTAwMDJcXHUwMjRFXFx1MDI0RlxceDA3eVx1MDAwMlx1MDAwMlxcdTAyNEZ8XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI1MFxcdTAyNTFcXHgwNzxcdTAwMDJcdTAwMDJcXHUwMjUxflx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyNTJcXHUwMjUzXFx4MDctXHUwMDAyXHUwMDAyXFx1MDI1M1xceDgwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI1NFxcdTAyNTVcXHgwNy9cdTAwMDJcdTAwMDJcXHUwMjU1XFx4ODJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjU2XFx1MDI1N1xceDA3Y1x1MDAwMlx1MDAwMlxcdTAyNTdcXHUwMjU4XFx4MDdoXHUwMDAyXHUwMDAyXFx1MDI1OFxcdTAyNTlcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwMjU5XFx1MDI1QVxceDA3Z1x1MDAwMlx1MDAwMlxcdTAyNUFcXHUwMjVCXFx4MDd0XHUwMDAyXHUwMDAyXFx1MDI1QlxceDg0XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI1Q1xcdTAyNURcXHgwN2ZcdTAwMDJcdTAwMDJcXHUwMjVEXFx1MDI1RVxceDA3Z1x1MDAwMlx1MDAwMlxcdTAyNUVcXHUwMjVGXFx4MDduXHUwMDAyXHUwMDAyXFx1MDI1RlxcdTAyNjBcXHgwN2dcdTAwMDJcdTAwMDJcXHUwMjYwXFx1MDI2MVxceDA3dlx1MDAwMlx1MDAwMlxcdTAyNjFcXHUwMjYyXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDI2MlxceDg2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI2M1xcdTAyNjRcXHgwNyNcdTAwMDJcdTAwMDJcXHUwMjY0XFx4ODhcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjY1XFx1MDI2NlxceDA3LFx1MDAwMlx1MDAwMlxcdTAyNjZcXHUwMjY3XFx4MDcsXHUwMDAyXHUwMDAyXFx1MDI2N1xceDhBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI2OFxcdTAyNjlcXHgwNzFcdTAwMDJcdTAwMDJcXHUwMjY5XFx4OENcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjZBXFx1MDI2QlxceDA3J1x1MDAwMlx1MDAwMlxcdTAyNkJcXHg4RVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyNkNcXHUwMjZEXFx4MDc+XHUwMDAyXHUwMDAyXFx1MDI2RFxcdTAyNkVcXHgwNz5cdTAwMDJcdTAwMDJcXHUwMjZFXFx4OTBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjZGXFx1MDI3MFxceDA3QFx1MDAwMlx1MDAwMlxcdTAyNzBcXHUwMjcxXFx4MDdAXHUwMDAyXHUwMDAyXFx1MDI3MVxceDkyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI3MlxcdTAyNzNcXHgwNyhcdTAwMDJcdTAwMDJcXHUwMjczXFx4OTRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjc0XFx1MDI3NVxceDA3flx1MDAwMlx1MDAwMlxcdTAyNzVcXHg5Nlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyNzZcXHUwMjc3XFx4MDc/XHUwMDAyXHUwMDAyXFx1MDI3N1xcdTAyNzhcXHgwNz9cdTAwMDJcdTAwMDJcXHUwMjc4XFx4OThcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjc5XFx1MDI3QVxceDA3I1x1MDAwMlx1MDAwMlxcdTAyN0FcXHUwMjdCXFx4MDc/XHUwMDAyXHUwMDAyXFx1MDI3QlxceDlBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI3Q1xcdTAyN0RcXHgwNyhcdTAwMDJcdTAwMDJcXHUwMjdEXFx1MDI3RVxceDA3KFx1MDAwMlx1MDAwMlxcdTAyN0VcXHg5Q1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyN0ZcXHUwMjgwXFx4MDdBXHUwMDAyXHUwMDAyXFx1MDI4MFxceDlFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI4MVxcdTAyODJcXHgwN35cdTAwMDJcdTAwMDJcXHUwMjgyXFx1MDI4M1xceDA3P1x1MDAwMlx1MDAwMlxcdTAyODNcXHhBMFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyODRcXHUwMjg1XFx4MDdgXHUwMDAyXHUwMDAyXFx1MDI4NVxcdTAyODZcXHgwNz9cdTAwMDJcdTAwMDJcXHUwMjg2XFx4QTJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjg3XFx1MDI4OFxceDA3KFx1MDAwMlx1MDAwMlxcdTAyODhcXHUwMjg5XFx4MDc/XHUwMDAyXHUwMDAyXFx1MDI4OVxceEE0XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI4QVxcdTAyOEJcXHgwNz5cdTAwMDJcdTAwMDJcXHUwMjhCXFx1MDI4Q1xceDA3Plx1MDAwMlx1MDAwMlxcdTAyOENcXHUwMjhEXFx4MDc/XHUwMDAyXHUwMDAyXFx1MDI4RFxceEE2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI4RVxcdTAyOEZcXHgwN0BcdTAwMDJcdTAwMDJcXHUwMjhGXFx1MDI5MFxceDA3QFx1MDAwMlx1MDAwMlxcdTAyOTBcXHUwMjkxXFx4MDc/XHUwMDAyXHUwMDAyXFx1MDI5MVxceEE4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI5MlxcdTAyOTNcXHgwNy1cdTAwMDJcdTAwMDJcXHUwMjkzXFx1MDI5NFxceDA3P1x1MDAwMlx1MDAwMlxcdTAyOTRcXHhBQVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyOTVcXHUwMjk2XFx4MDcvXHUwMDAyXHUwMDAyXFx1MDI5NlxcdTAyOTdcXHgwNz9cdTAwMDJcdTAwMDJcXHUwMjk3XFx4QUNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjk4XFx1MDI5OVxceDA3LFx1MDAwMlx1MDAwMlxcdTAyOTlcXHUwMjlBXFx4MDc/XHUwMDAyXHUwMDAyXFx1MDI5QVxceEFFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI5QlxcdTAyOUNcXHgwNzFcdTAwMDJcdTAwMDJcXHUwMjlDXFx1MDI5RFxceDA3P1x1MDAwMlx1MDAwMlxcdTAyOURcXHhCMFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyOUVcXHUwMjlGXFx4MDcnXHUwMDAyXHUwMDAyXFx1MDI5RlxcdTAyQTBcXHgwNz9cdTAwMDJcdTAwMDJcXHUwMkEwXFx4QjJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMkExXFx1MDJBMlxceDA3blx1MDAwMlx1MDAwMlxcdTAyQTJcXHUwMkEzXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDJBM1xcdTAyQTRcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwMkE0XFx4QjRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMkE1XFx1MDJBNlxceDA3PFx1MDAwMlx1MDAwMlxcdTAyQTZcXHUwMkE3XFx4MDc/XHUwMDAyXHUwMDAyXFx1MDJBN1xceEI2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDJBOFxcdTAyQTlcXHgwNz9cdTAwMDJcdTAwMDJcXHUwMkE5XFx1MDJBQVxceDA3PFx1MDAwMlx1MDAwMlxcdTAyQUFcXHhCOFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyQUJcXHUwMkFDXFx4MDd1XHUwMDAyXHUwMDAyXFx1MDJBQ1xcdTAyQURcXHgwN3lcdTAwMDJcdTAwMDJcXHUwMkFEXFx1MDJBRVxceDA3a1x1MDAwMlx1MDAwMlxcdTAyQUVcXHUwMkFGXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDJBRlxcdTAyQjBcXHgwN2VcdTAwMDJcdTAwMDJcXHUwMkIwXFx1MDJCMVxceDA3alx1MDAwMlx1MDAwMlxcdTAyQjFcXHhCQVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyQjJcXHUwMkIzXFx4MDdlXHUwMDAyXHUwMDAyXFx1MDJCM1xcdTAyQjRcXHgwN2NcdTAwMDJcdTAwMDJcXHUwMkI0XFx1MDJCNVxceDA3dVx1MDAwMlx1MDAwMlxcdTAyQjVcXHUwMkI2XFx4MDdnXHUwMDAyXHUwMDAyXFx1MDJCNlxceEJDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDJCN1xcdTAyQjhcXHgwN2ZcdTAwMDJcdTAwMDJcXHUwMkI4XFx1MDJCOVxceDA3Z1x1MDAwMlx1MDAwMlxcdTAyQjlcXHUwMkJBXFx4MDdoXHUwMDAyXHUwMDAyXFx1MDJCQVxcdTAyQkJcXHgwN2NcdTAwMDJcdTAwMDJcXHUwMkJCXFx1MDJCQ1xceDA3d1x1MDAwMlx1MDAwMlxcdTAyQkNcXHUwMkJEXFx4MDduXHUwMDAyXHUwMDAyXFx1MDJCRFxcdTAyQkVcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwMkJFXFx4QkVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMkJGXFx1MDJDMFxceDA3L1x1MDAwMlx1MDAwMlxcdTAyQzBcXHUwMkMxXFx4MDdAXHUwMDAyXHUwMDAyXFx1MDJDMVxceEMwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDJDMlxcdTAyQzNcXHgwN2VcdTAwMDJcdTAwMDJcXHUwMkMzXFx1MDJDNFxceDA3Y1x1MDAwMlx1MDAwMlxcdTAyQzRcXHUwMkM1XFx4MDduXHUwMDAyXHUwMDAyXFx1MDJDNVxcdTAyQzZcXHgwN25cdTAwMDJcdTAwMDJcXHUwMkM2XFx1MDJDN1xceDA3ZFx1MDAwMlx1MDAwMlxcdTAyQzdcXHUwMkM4XFx4MDdjXHUwMDAyXHUwMDAyXFx1MDJDOFxcdTAyQzlcXHgwN2VcdTAwMDJcdTAwMDJcXHUwMkM5XFx1MDJDQVxceDA3bVx1MDAwMlx1MDAwMlxcdTAyQ0FcXHhDMlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyQ0JcXHUwMkNDXFx4MDdxXHUwMDAyXHUwMDAyXFx1MDJDQ1xcdTAyQ0RcXHgwN3hcdTAwMDJcdTAwMDJcXHUwMkNEXFx1MDJDRVxceDA3Z1x1MDAwMlx1MDAwMlxcdTAyQ0VcXHUwMkNGXFx4MDd0XHUwMDAyXHUwMDAyXFx1MDJDRlxcdTAyRDBcXHgwN3RcdTAwMDJcdTAwMDJcXHUwMkQwXFx1MDJEMVxceDA3a1x1MDAwMlx1MDAwMlxcdTAyRDFcXHUwMkQyXFx4MDdmXHUwMDAyXHUwMDAyXFx1MDJEMlxcdTAyRDNcXHgwN2dcdTAwMDJcdTAwMDJcXHUwMkQzXFx4QzRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMkQ0XFx1MDJENVxceDA3a1x1MDAwMlx1MDAwMlxcdTAyRDVcXHUwMkQ2XFx4MDdwXHUwMDAyXHUwMDAyXFx1MDJENlxcdTAzOEJcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwMkQ3XFx1MDJEOFxceDA3a1x1MDAwMlx1MDAwMlxcdTAyRDhcXHUwMkQ5XFx4MDdwXHUwMDAyXHUwMDAyXFx1MDJEOVxcdTAyREFcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwMkRBXFx1MDM4QlxceDA3Olx1MDAwMlx1MDAwMlxcdTAyREJcXHUwMkRDXFx4MDdrXHUwMDAyXHUwMDAyXFx1MDJEQ1xcdTAyRERcXHgwN3BcdTAwMDJcdTAwMDJcXHUwMkREXFx1MDJERVxceDA3dlx1MDAwMlx1MDAwMlxcdTAyREVcXHUwMkRGXFx4MDczXHUwMDAyXHUwMDAyXFx1MDJERlxcdTAzOEJcXHgwNzhcdTAwMDJcdTAwMDJcXHUwMkUwXFx1MDJFMVxceDA3a1x1MDAwMlx1MDAwMlxcdTAyRTFcXHUwMkUyXFx4MDdwXHUwMDAyXHUwMDAyXFx1MDJFMlxcdTAyRTNcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwMkUzXFx1MDJFNFxceDA3NFx1MDAwMlx1MDAwMlxcdTAyRTRcXHUwMzhCXFx4MDc2XHUwMDAyXHUwMDAyXFx1MDJFNVxcdTAyRTZcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMkU2XFx1MDJFN1xceDA3cFx1MDAwMlx1MDAwMlxcdTAyRTdcXHUwMkU4XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDJFOFxcdTAyRTlcXHgwNzVcdTAwMDJcdTAwMDJcXHUwMkU5XFx1MDM4QlxceDA3NFx1MDAwMlx1MDAwMlxcdTAyRUFcXHUwMkVCXFx4MDdrXHUwMDAyXHUwMDAyXFx1MDJFQlxcdTAyRUNcXHgwN3BcdTAwMDJcdTAwMDJcXHUwMkVDXFx1MDJFRFxceDA3dlx1MDAwMlx1MDAwMlxcdTAyRURcXHUwMkVFXFx4MDc2XHUwMDAyXHUwMDAyXFx1MDJFRVxcdTAzOEJcXHgwNzJcdTAwMDJcdTAwMDJcXHUwMkVGXFx1MDJGMFxceDA3a1x1MDAwMlx1MDAwMlxcdTAyRjBcXHUwMkYxXFx4MDdwXHUwMDAyXHUwMDAyXFx1MDJGMVxcdTAyRjJcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwMkYyXFx1MDJGM1xceDA3Nlx1MDAwMlx1MDAwMlxcdTAyRjNcXHUwMzhCXFx4MDc6XHUwMDAyXHUwMDAyXFx1MDJGNFxcdTAyRjVcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMkY1XFx1MDJGNlxceDA3cFx1MDAwMlx1MDAwMlxcdTAyRjZcXHUwMkY3XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDJGN1xcdTAyRjhcXHgwNzdcdTAwMDJcdTAwMDJcXHUwMkY4XFx1MDM4QlxceDA3OFx1MDAwMlx1MDAwMlxcdTAyRjlcXHUwMkZBXFx4MDdrXHUwMDAyXHUwMDAyXFx1MDJGQVxcdTAyRkJcXHgwN3BcdTAwMDJcdTAwMDJcXHUwMkZCXFx1MDJGQ1xceDA3dlx1MDAwMlx1MDAwMlxcdTAyRkNcXHUwMkZEXFx4MDc4XHUwMDAyXHUwMDAyXFx1MDJGRFxcdTAzOEJcXHgwNzZcdTAwMDJcdTAwMDJcXHUwMkZFXFx1MDJGRlxceDA3a1x1MDAwMlx1MDAwMlxcdTAyRkZcXHUwMzAwXFx4MDdwXHUwMDAyXHUwMDAyXFx1MDMwMFxcdTAzMDFcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwMzAxXFx1MDMwMlxceDA3OVx1MDAwMlx1MDAwMlxcdTAzMDJcXHUwMzhCXFx4MDc0XHUwMDAyXHUwMDAyXFx1MDMwM1xcdTAzMDRcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMzA0XFx1MDMwNVxceDA3cFx1MDAwMlx1MDAwMlxcdTAzMDVcXHUwMzA2XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDMwNlxcdTAzMDdcXHgwNzpcdTAwMDJcdTAwMDJcXHUwMzA3XFx1MDM4QlxceDA3Mlx1MDAwMlx1MDAwMlxcdTAzMDhcXHUwMzA5XFx4MDdrXHUwMDAyXHUwMDAyXFx1MDMwOVxcdTAzMEFcXHgwN3BcdTAwMDJcdTAwMDJcXHUwMzBBXFx1MDMwQlxceDA3dlx1MDAwMlx1MDAwMlxcdTAzMEJcXHUwMzBDXFx4MDc6XHUwMDAyXHUwMDAyXFx1MDMwQ1xcdTAzOEJcXHgwNzpcdTAwMDJcdTAwMDJcXHUwMzBEXFx1MDMwRVxceDA3a1x1MDAwMlx1MDAwMlxcdTAzMEVcXHUwMzBGXFx4MDdwXHUwMDAyXHUwMDAyXFx1MDMwRlxcdTAzMTBcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwMzEwXFx1MDMxMVxceDA3O1x1MDAwMlx1MDAwMlxcdTAzMTFcXHUwMzhCXFx4MDc4XHUwMDAyXHUwMDAyXFx1MDMxMlxcdTAzMTNcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMzEzXFx1MDMxNFxceDA3cFx1MDAwMlx1MDAwMlxcdTAzMTRcXHUwMzE1XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDMxNVxcdTAzMTZcXHgwNzNcdTAwMDJcdTAwMDJcXHUwMzE2XFx1MDMxN1xceDA3Mlx1MDAwMlx1MDAwMlxcdTAzMTdcXHUwMzhCXFx4MDc2XHUwMDAyXHUwMDAyXFx1MDMxOFxcdTAzMTlcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMzE5XFx1MDMxQVxceDA3cFx1MDAwMlx1MDAwMlxcdTAzMUFcXHUwMzFCXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDMxQlxcdTAzMUNcXHgwNzNcdTAwMDJcdTAwMDJcXHUwMzFDXFx1MDMxRFxceDA3M1x1MDAwMlx1MDAwMlxcdTAzMURcXHUwMzhCXFx4MDc0XHUwMDAyXHUwMDAyXFx1MDMxRVxcdTAzMUZcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMzFGXFx1MDMyMFxceDA3cFx1MDAwMlx1MDAwMlxcdTAzMjBcXHUwMzIxXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDMyMVxcdTAzMjJcXHgwNzNcdTAwMDJcdTAwMDJcXHUwMzIyXFx1MDMyM1xceDA3NFx1MDAwMlx1MDAwMlxcdTAzMjNcXHUwMzhCXFx4MDcyXHUwMDAyXHUwMDAyXFx1MDMyNFxcdTAzMjVcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMzI1XFx1MDMyNlxceDA3cFx1MDAwMlx1MDAwMlxcdTAzMjZcXHUwMzI3XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDMyN1xcdTAzMjhcXHgwNzNcdTAwMDJcdTAwMDJcXHUwMzI4XFx1MDMyOVxceDA3NFx1MDAwMlx1MDAwMlxcdTAzMjlcXHUwMzhCXFx4MDc6XHUwMDAyXHUwMDAyXFx1MDMyQVxcdTAzMkJcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMzJCXFx1MDMyQ1xceDA3cFx1MDAwMlx1MDAwMlxcdTAzMkNcXHUwMzJEXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDMyRFxcdTAzMkVcXHgwNzNcdTAwMDJcdTAwMDJcXHUwMzJFXFx1MDMyRlxceDA3NVx1MDAwMlx1MDAwMlxcdTAzMkZcXHUwMzhCXFx4MDc4XHUwMDAyXHUwMDAyXFx1MDMzMFxcdTAzMzFcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMzMxXFx1MDMzMlxceDA3cFx1MDAwMlx1MDAwMlxcdTAzMzJcXHUwMzMzXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDMzM1xcdTAzMzRcXHgwNzNcdTAwMDJcdTAwMDJcXHUwMzM0XFx1MDMzNVxceDA3Nlx1MDAwMlx1MDAwMlxcdTAzMzVcXHUwMzhCXFx4MDc2XHUwMDAyXHUwMDAyXFx1MDMzNlxcdTAzMzdcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMzM3XFx1MDMzOFxceDA3cFx1MDAwMlx1MDAwMlxcdTAzMzhcXHUwMzM5XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDMzOVxcdTAzM0FcXHgwNzNcdTAwMDJcdTAwMDJcXHUwMzNBXFx1MDMzQlxceDA3N1x1MDAwMlx1MDAwMlxcdTAzM0JcXHUwMzhCXFx4MDc0XHUwMDAyXHUwMDAyXFx1MDMzQ1xcdTAzM0RcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMzNEXFx1MDMzRVxceDA3cFx1MDAwMlx1MDAwMlxcdTAzM0VcXHUwMzNGXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDMzRlxcdTAzNDBcXHgwNzNcdTAwMDJcdTAwMDJcXHUwMzQwXFx1MDM0MVxceDA3OFx1MDAwMlx1MDAwMlxcdTAzNDFcXHUwMzhCXFx4MDcyXHUwMDAyXHUwMDAyXFx1MDM0MlxcdTAzNDNcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMzQzXFx1MDM0NFxceDA3cFx1MDAwMlx1MDAwMlxcdTAzNDRcXHUwMzQ1XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDM0NVxcdTAzNDZcXHgwNzNcdTAwMDJcdTAwMDJcXHUwMzQ2XFx1MDM0N1xceDA3OFx1MDAwMlx1MDAwMlxcdTAzNDdcXHUwMzhCXFx4MDc6XHUwMDAyXHUwMDAyXFx1MDM0OFxcdTAzNDlcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMzQ5XFx1MDM0QVxceDA3cFx1MDAwMlx1MDAwMlxcdTAzNEFcXHUwMzRCXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDM0QlxcdTAzNENcXHgwNzNcdTAwMDJcdTAwMDJcXHUwMzRDXFx1MDM0RFxceDA3OVx1MDAwMlx1MDAwMlxcdTAzNERcXHUwMzhCXFx4MDc4XHUwMDAyXHUwMDAyXFx1MDM0RVxcdTAzNEZcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMzRGXFx1MDM1MFxceDA3cFx1MDAwMlx1MDAwMlxcdTAzNTBcXHUwMzUxXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDM1MVxcdTAzNTJcXHgwNzNcdTAwMDJcdTAwMDJcXHUwMzUyXFx1MDM1M1xceDA3Olx1MDAwMlx1MDAwMlxcdTAzNTNcXHUwMzhCXFx4MDc2XHUwMDAyXHUwMDAyXFx1MDM1NFxcdTAzNTVcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMzU1XFx1MDM1NlxceDA3cFx1MDAwMlx1MDAwMlxcdTAzNTZcXHUwMzU3XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDM1N1xcdTAzNThcXHgwNzNcdTAwMDJcdTAwMDJcXHUwMzU4XFx1MDM1OVxceDA3O1x1MDAwMlx1MDAwMlxcdTAzNTlcXHUwMzhCXFx4MDc0XHUwMDAyXHUwMDAyXFx1MDM1QVxcdTAzNUJcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMzVCXFx1MDM1Q1xceDA3cFx1MDAwMlx1MDAwMlxcdTAzNUNcXHUwMzVEXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDM1RFxcdTAzNUVcXHgwNzRcdTAwMDJcdTAwMDJcXHUwMzVFXFx1MDM1RlxceDA3Mlx1MDAwMlx1MDAwMlxcdTAzNUZcXHUwMzhCXFx4MDcyXHUwMDAyXHUwMDAyXFx1MDM2MFxcdTAzNjFcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMzYxXFx1MDM2MlxceDA3cFx1MDAwMlx1MDAwMlxcdTAzNjJcXHUwMzYzXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDM2M1xcdTAzNjRcXHgwNzRcdTAwMDJcdTAwMDJcXHUwMzY0XFx1MDM2NVxceDA3Mlx1MDAwMlx1MDAwMlxcdTAzNjVcXHUwMzhCXFx4MDc6XHUwMDAyXHUwMDAyXFx1MDM2NlxcdTAzNjdcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMzY3XFx1MDM2OFxceDA3cFx1MDAwMlx1MDAwMlxcdTAzNjhcXHUwMzY5XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDM2OVxcdTAzNkFcXHgwNzRcdTAwMDJcdTAwMDJcXHUwMzZBXFx1MDM2QlxceDA3M1x1MDAwMlx1MDAwMlxcdTAzNkJcXHUwMzhCXFx4MDc4XHUwMDAyXHUwMDAyXFx1MDM2Q1xcdTAzNkRcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMzZEXFx1MDM2RVxceDA3cFx1MDAwMlx1MDAwMlxcdTAzNkVcXHUwMzZGXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDM2RlxcdTAzNzBcXHgwNzRcdTAwMDJcdTAwMDJcXHUwMzcwXFx1MDM3MVxceDA3NFx1MDAwMlx1MDAwMlxcdTAzNzFcXHUwMzhCXFx4MDc2XHUwMDAyXHUwMDAyXFx1MDM3MlxcdTAzNzNcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMzczXFx1MDM3NFxceDA3cFx1MDAwMlx1MDAwMlxcdTAzNzRcXHUwMzc1XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDM3NVxcdTAzNzZcXHgwNzRcdTAwMDJcdTAwMDJcXHUwMzc2XFx1MDM3N1xceDA3NVx1MDAwMlx1MDAwMlxcdTAzNzdcXHUwMzhCXFx4MDc0XHUwMDAyXHUwMDAyXFx1MDM3OFxcdTAzNzlcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMzc5XFx1MDM3QVxceDA3cFx1MDAwMlx1MDAwMlxcdTAzN0FcXHUwMzdCXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDM3QlxcdTAzN0NcXHgwNzRcdTAwMDJcdTAwMDJcXHUwMzdDXFx1MDM3RFxceDA3Nlx1MDAwMlx1MDAwMlxcdTAzN0RcXHUwMzhCXFx4MDcyXHUwMDAyXHUwMDAyXFx1MDM3RVxcdTAzN0ZcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMzdGXFx1MDM4MFxceDA3cFx1MDAwMlx1MDAwMlxcdTAzODBcXHUwMzgxXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDM4MVxcdTAzODJcXHgwNzRcdTAwMDJcdTAwMDJcXHUwMzgyXFx1MDM4M1xceDA3Nlx1MDAwMlx1MDAwMlxcdTAzODNcXHUwMzhCXFx4MDc6XHUwMDAyXHUwMDAyXFx1MDM4NFxcdTAzODVcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMzg1XFx1MDM4NlxceDA3cFx1MDAwMlx1MDAwMlxcdTAzODZcXHUwMzg3XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDM4N1xcdTAzODhcXHgwNzRcdTAwMDJcdTAwMDJcXHUwMzg4XFx1MDM4OVxceDA3N1x1MDAwMlx1MDAwMlxcdTAzODlcXHUwMzhCXFx4MDc4XHUwMDAyXHUwMDAyXFx1MDM4QVxcdTAyRDRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzhBXFx1MDJEN1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzOEFcXHUwMkRCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM4QVxcdTAyRTBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzhBXFx1MDJFNVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzOEFcXHUwMkVBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM4QVxcdTAyRUZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzhBXFx1MDJGNFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzOEFcXHUwMkY5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM4QVxcdTAyRkVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzhBXFx1MDMwM1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzOEFcXHUwMzA4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM4QVxcdTAzMERcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzhBXFx1MDMxMlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzOEFcXHUwMzE4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM4QVxcdTAzMUVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzhBXFx1MDMyNFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzOEFcXHUwMzJBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM4QVxcdTAzMzBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzhBXFx1MDMzNlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzOEFcXHUwMzNDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM4QVxcdTAzNDJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzhBXFx1MDM0OFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzOEFcXHUwMzRFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM4QVxcdTAzNTRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzhBXFx1MDM1QVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzOEFcXHUwMzYwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM4QVxcdTAzNjZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzhBXFx1MDM2Q1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzOEFcXHUwMzcyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM4QVxcdTAzNzhcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzhBXFx1MDM3RVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzOEFcXHUwMzg0XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM4QlxceEM2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM4Q1xcdTAzOERcXHgwN3dcdTAwMDJcdTAwMDJcXHUwMzhEXFx1MDM4RVxceDA3a1x1MDAwMlx1MDAwMlxcdTAzOEVcXHUwMzhGXFx4MDdwXHUwMDAyXHUwMDAyXFx1MDM4RlxcdTA0NjRcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwMzkwXFx1MDM5MVxceDA3d1x1MDAwMlx1MDAwMlxcdTAzOTFcXHUwMzkyXFx4MDdrXHUwMDAyXHUwMDAyXFx1MDM5MlxcdTAzOTNcXHgwN3BcdTAwMDJcdTAwMDJcXHUwMzkzXFx1MDM5NFxceDA3dlx1MDAwMlx1MDAwMlxcdTAzOTRcXHUwNDY0XFx4MDc6XHUwMDAyXHUwMDAyXFx1MDM5NVxcdTAzOTZcXHgwN3dcdTAwMDJcdTAwMDJcXHUwMzk2XFx1MDM5N1xceDA3a1x1MDAwMlx1MDAwMlxcdTAzOTdcXHUwMzk4XFx4MDdwXHUwMDAyXHUwMDAyXFx1MDM5OFxcdTAzOTlcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwMzk5XFx1MDM5QVxceDA3M1x1MDAwMlx1MDAwMlxcdTAzOUFcXHUwNDY0XFx4MDc4XHUwMDAyXHUwMDAyXFx1MDM5QlxcdTAzOUNcIjtcblNvbGlkaXR5TGV4ZXIuX3NlcmlhbGl6ZWRBVE5TZWdtZW50MiA9IFwiXFx4MDd3XHUwMDAyXHUwMDAyXFx1MDM5Q1xcdTAzOURcXHgwN2tcdTAwMDJcdTAwMDJcXHUwMzlEXFx1MDM5RVxceDA3cFx1MDAwMlx1MDAwMlxcdTAzOUVcXHUwMzlGXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDM5RlxcdTAzQTBcXHgwNzRcdTAwMDJcdTAwMDJcXHUwM0EwXFx1MDQ2NFxceDA3Nlx1MDAwMlx1MDAwMlxcdTAzQTFcXHUwM0EyXFx4MDd3XHUwMDAyXHUwMDAyXFx1MDNBMlxcdTAzQTNcXHgwN2tcdTAwMDJcdTAwMDJcXHUwM0EzXFx1MDNBNFxceDA3cFx1MDAwMlx1MDAwMlxcdTAzQTRcXHUwM0E1XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDNBNVxcdTAzQTZcXHgwNzVcdTAwMDJcdTAwMDJcXHUwM0E2XFx1MDQ2NFxceDA3NFx1MDAwMlx1MDAwMlxcdTAzQTdcXHUwM0E4XFx4MDd3XHUwMDAyXHUwMDAyXFx1MDNBOFxcdTAzQTlcXHgwN2tcdTAwMDJcdTAwMDJcXHUwM0E5XFx1MDNBQVxceDA3cFx1MDAwMlx1MDAwMlxcdTAzQUFcXHUwM0FCXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDNBQlxcdTAzQUNcXHgwNzZcdTAwMDJcdTAwMDJcXHUwM0FDXFx1MDQ2NFxceDA3Mlx1MDAwMlx1MDAwMlxcdTAzQURcXHUwM0FFXFx4MDd3XHUwMDAyXHUwMDAyXFx1MDNBRVxcdTAzQUZcXHgwN2tcdTAwMDJcdTAwMDJcXHUwM0FGXFx1MDNCMFxceDA3cFx1MDAwMlx1MDAwMlxcdTAzQjBcXHUwM0IxXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDNCMVxcdTAzQjJcXHgwNzZcdTAwMDJcdTAwMDJcXHUwM0IyXFx1MDQ2NFxceDA3Olx1MDAwMlx1MDAwMlxcdTAzQjNcXHUwM0I0XFx4MDd3XHUwMDAyXHUwMDAyXFx1MDNCNFxcdTAzQjVcXHgwN2tcdTAwMDJcdTAwMDJcXHUwM0I1XFx1MDNCNlxceDA3cFx1MDAwMlx1MDAwMlxcdTAzQjZcXHUwM0I3XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDNCN1xcdTAzQjhcXHgwNzdcdTAwMDJcdTAwMDJcXHUwM0I4XFx1MDQ2NFxceDA3OFx1MDAwMlx1MDAwMlxcdTAzQjlcXHUwM0JBXFx4MDd3XHUwMDAyXHUwMDAyXFx1MDNCQVxcdTAzQkJcXHgwN2tcdTAwMDJcdTAwMDJcXHUwM0JCXFx1MDNCQ1xceDA3cFx1MDAwMlx1MDAwMlxcdTAzQkNcXHUwM0JEXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDNCRFxcdTAzQkVcXHgwNzhcdTAwMDJcdTAwMDJcXHUwM0JFXFx1MDQ2NFxceDA3Nlx1MDAwMlx1MDAwMlxcdTAzQkZcXHUwM0MwXFx4MDd3XHUwMDAyXHUwMDAyXFx1MDNDMFxcdTAzQzFcXHgwN2tcdTAwMDJcdTAwMDJcXHUwM0MxXFx1MDNDMlxceDA3cFx1MDAwMlx1MDAwMlxcdTAzQzJcXHUwM0MzXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDNDM1xcdTAzQzRcXHgwNzlcdTAwMDJcdTAwMDJcXHUwM0M0XFx1MDQ2NFxceDA3NFx1MDAwMlx1MDAwMlxcdTAzQzVcXHUwM0M2XFx4MDd3XHUwMDAyXHUwMDAyXFx1MDNDNlxcdTAzQzdcXHgwN2tcdTAwMDJcdTAwMDJcXHUwM0M3XFx1MDNDOFxceDA3cFx1MDAwMlx1MDAwMlxcdTAzQzhcXHUwM0M5XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDNDOVxcdTAzQ0FcXHgwNzpcdTAwMDJcdTAwMDJcXHUwM0NBXFx1MDQ2NFxceDA3Mlx1MDAwMlx1MDAwMlxcdTAzQ0JcXHUwM0NDXFx4MDd3XHUwMDAyXHUwMDAyXFx1MDNDQ1xcdTAzQ0RcXHgwN2tcdTAwMDJcdTAwMDJcXHUwM0NEXFx1MDNDRVxceDA3cFx1MDAwMlx1MDAwMlxcdTAzQ0VcXHUwM0NGXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDNDRlxcdTAzRDBcXHgwNzpcdTAwMDJcdTAwMDJcXHUwM0QwXFx1MDQ2NFxceDA3Olx1MDAwMlx1MDAwMlxcdTAzRDFcXHUwM0QyXFx4MDd3XHUwMDAyXHUwMDAyXFx1MDNEMlxcdTAzRDNcXHgwN2tcdTAwMDJcdTAwMDJcXHUwM0QzXFx1MDNENFxceDA3cFx1MDAwMlx1MDAwMlxcdTAzRDRcXHUwM0Q1XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDNENVxcdTAzRDZcXHgwNztcdTAwMDJcdTAwMDJcXHUwM0Q2XFx1MDQ2NFxceDA3OFx1MDAwMlx1MDAwMlxcdTAzRDdcXHUwM0Q4XFx4MDd3XHUwMDAyXHUwMDAyXFx1MDNEOFxcdTAzRDlcXHgwN2tcdTAwMDJcdTAwMDJcXHUwM0Q5XFx1MDNEQVxceDA3cFx1MDAwMlx1MDAwMlxcdTAzREFcXHUwM0RCXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDNEQlxcdTAzRENcXHgwNzNcdTAwMDJcdTAwMDJcXHUwM0RDXFx1MDNERFxceDA3Mlx1MDAwMlx1MDAwMlxcdTAzRERcXHUwNDY0XFx4MDc2XHUwMDAyXHUwMDAyXFx1MDNERVxcdTAzREZcXHgwN3dcdTAwMDJcdTAwMDJcXHUwM0RGXFx1MDNFMFxceDA3a1x1MDAwMlx1MDAwMlxcdTAzRTBcXHUwM0UxXFx4MDdwXHUwMDAyXHUwMDAyXFx1MDNFMVxcdTAzRTJcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwM0UyXFx1MDNFM1xceDA3M1x1MDAwMlx1MDAwMlxcdTAzRTNcXHUwM0U0XFx4MDczXHUwMDAyXHUwMDAyXFx1MDNFNFxcdTA0NjRcXHgwNzRcdTAwMDJcdTAwMDJcXHUwM0U1XFx1MDNFNlxceDA3d1x1MDAwMlx1MDAwMlxcdTAzRTZcXHUwM0U3XFx4MDdrXHUwMDAyXHUwMDAyXFx1MDNFN1xcdTAzRThcXHgwN3BcdTAwMDJcdTAwMDJcXHUwM0U4XFx1MDNFOVxceDA3dlx1MDAwMlx1MDAwMlxcdTAzRTlcXHUwM0VBXFx4MDczXHUwMDAyXHUwMDAyXFx1MDNFQVxcdTAzRUJcXHgwNzRcdTAwMDJcdTAwMDJcXHUwM0VCXFx1MDQ2NFxceDA3Mlx1MDAwMlx1MDAwMlxcdTAzRUNcXHUwM0VEXFx4MDd3XHUwMDAyXHUwMDAyXFx1MDNFRFxcdTAzRUVcXHgwN2tcdTAwMDJcdTAwMDJcXHUwM0VFXFx1MDNFRlxceDA3cFx1MDAwMlx1MDAwMlxcdTAzRUZcXHUwM0YwXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDNGMFxcdTAzRjFcXHgwNzNcdTAwMDJcdTAwMDJcXHUwM0YxXFx1MDNGMlxceDA3NFx1MDAwMlx1MDAwMlxcdTAzRjJcXHUwNDY0XFx4MDc6XHUwMDAyXHUwMDAyXFx1MDNGM1xcdTAzRjRcXHgwN3dcdTAwMDJcdTAwMDJcXHUwM0Y0XFx1MDNGNVxceDA3a1x1MDAwMlx1MDAwMlxcdTAzRjVcXHUwM0Y2XFx4MDdwXHUwMDAyXHUwMDAyXFx1MDNGNlxcdTAzRjdcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwM0Y3XFx1MDNGOFxceDA3M1x1MDAwMlx1MDAwMlxcdTAzRjhcXHUwM0Y5XFx4MDc1XHUwMDAyXHUwMDAyXFx1MDNGOVxcdTA0NjRcXHgwNzhcdTAwMDJcdTAwMDJcXHUwM0ZBXFx1MDNGQlxceDA3d1x1MDAwMlx1MDAwMlxcdTAzRkJcXHUwM0ZDXFx4MDdrXHUwMDAyXHUwMDAyXFx1MDNGQ1xcdTAzRkRcXHgwN3BcdTAwMDJcdTAwMDJcXHUwM0ZEXFx1MDNGRVxceDA3dlx1MDAwMlx1MDAwMlxcdTAzRkVcXHUwM0ZGXFx4MDczXHUwMDAyXHUwMDAyXFx1MDNGRlxcdTA0MDBcXHgwNzZcdTAwMDJcdTAwMDJcXHUwNDAwXFx1MDQ2NFxceDA3Nlx1MDAwMlx1MDAwMlxcdTA0MDFcXHUwNDAyXFx4MDd3XHUwMDAyXHUwMDAyXFx1MDQwMlxcdTA0MDNcXHgwN2tcdTAwMDJcdTAwMDJcXHUwNDAzXFx1MDQwNFxceDA3cFx1MDAwMlx1MDAwMlxcdTA0MDRcXHUwNDA1XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDQwNVxcdTA0MDZcXHgwNzNcdTAwMDJcdTAwMDJcXHUwNDA2XFx1MDQwN1xceDA3N1x1MDAwMlx1MDAwMlxcdTA0MDdcXHUwNDY0XFx4MDc0XHUwMDAyXHUwMDAyXFx1MDQwOFxcdTA0MDlcXHgwN3dcdTAwMDJcdTAwMDJcXHUwNDA5XFx1MDQwQVxceDA3a1x1MDAwMlx1MDAwMlxcdTA0MEFcXHUwNDBCXFx4MDdwXHUwMDAyXHUwMDAyXFx1MDQwQlxcdTA0MENcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNDBDXFx1MDQwRFxceDA3M1x1MDAwMlx1MDAwMlxcdTA0MERcXHUwNDBFXFx4MDc4XHUwMDAyXHUwMDAyXFx1MDQwRVxcdTA0NjRcXHgwNzJcdTAwMDJcdTAwMDJcXHUwNDBGXFx1MDQxMFxceDA3d1x1MDAwMlx1MDAwMlxcdTA0MTBcXHUwNDExXFx4MDdrXHUwMDAyXHUwMDAyXFx1MDQxMVxcdTA0MTJcXHgwN3BcdTAwMDJcdTAwMDJcXHUwNDEyXFx1MDQxM1xceDA3dlx1MDAwMlx1MDAwMlxcdTA0MTNcXHUwNDE0XFx4MDczXHUwMDAyXHUwMDAyXFx1MDQxNFxcdTA0MTVcXHgwNzhcdTAwMDJcdTAwMDJcXHUwNDE1XFx1MDQ2NFxceDA3Olx1MDAwMlx1MDAwMlxcdTA0MTZcXHUwNDE3XFx4MDd3XHUwMDAyXHUwMDAyXFx1MDQxN1xcdTA0MThcXHgwN2tcdTAwMDJcdTAwMDJcXHUwNDE4XFx1MDQxOVxceDA3cFx1MDAwMlx1MDAwMlxcdTA0MTlcXHUwNDFBXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDQxQVxcdTA0MUJcXHgwNzNcdTAwMDJcdTAwMDJcXHUwNDFCXFx1MDQxQ1xceDA3OVx1MDAwMlx1MDAwMlxcdTA0MUNcXHUwNDY0XFx4MDc4XHUwMDAyXHUwMDAyXFx1MDQxRFxcdTA0MUVcXHgwN3dcdTAwMDJcdTAwMDJcXHUwNDFFXFx1MDQxRlxceDA3a1x1MDAwMlx1MDAwMlxcdTA0MUZcXHUwNDIwXFx4MDdwXHUwMDAyXHUwMDAyXFx1MDQyMFxcdTA0MjFcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNDIxXFx1MDQyMlxceDA3M1x1MDAwMlx1MDAwMlxcdTA0MjJcXHUwNDIzXFx4MDc6XHUwMDAyXHUwMDAyXFx1MDQyM1xcdTA0NjRcXHgwNzZcdTAwMDJcdTAwMDJcXHUwNDI0XFx1MDQyNVxceDA3d1x1MDAwMlx1MDAwMlxcdTA0MjVcXHUwNDI2XFx4MDdrXHUwMDAyXHUwMDAyXFx1MDQyNlxcdTA0MjdcXHgwN3BcdTAwMDJcdTAwMDJcXHUwNDI3XFx1MDQyOFxceDA3dlx1MDAwMlx1MDAwMlxcdTA0MjhcXHUwNDI5XFx4MDczXHUwMDAyXHUwMDAyXFx1MDQyOVxcdTA0MkFcXHgwNztcdTAwMDJcdTAwMDJcXHUwNDJBXFx1MDQ2NFxceDA3NFx1MDAwMlx1MDAwMlxcdTA0MkJcXHUwNDJDXFx4MDd3XHUwMDAyXHUwMDAyXFx1MDQyQ1xcdTA0MkRcXHgwN2tcdTAwMDJcdTAwMDJcXHUwNDJEXFx1MDQyRVxceDA3cFx1MDAwMlx1MDAwMlxcdTA0MkVcXHUwNDJGXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDQyRlxcdTA0MzBcXHgwNzRcdTAwMDJcdTAwMDJcXHUwNDMwXFx1MDQzMVxceDA3Mlx1MDAwMlx1MDAwMlxcdTA0MzFcXHUwNDY0XFx4MDcyXHUwMDAyXHUwMDAyXFx1MDQzMlxcdTA0MzNcXHgwN3dcdTAwMDJcdTAwMDJcXHUwNDMzXFx1MDQzNFxceDA3a1x1MDAwMlx1MDAwMlxcdTA0MzRcXHUwNDM1XFx4MDdwXHUwMDAyXHUwMDAyXFx1MDQzNVxcdTA0MzZcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNDM2XFx1MDQzN1xceDA3NFx1MDAwMlx1MDAwMlxcdTA0MzdcXHUwNDM4XFx4MDcyXHUwMDAyXHUwMDAyXFx1MDQzOFxcdTA0NjRcXHgwNzpcdTAwMDJcdTAwMDJcXHUwNDM5XFx1MDQzQVxceDA3d1x1MDAwMlx1MDAwMlxcdTA0M0FcXHUwNDNCXFx4MDdrXHUwMDAyXHUwMDAyXFx1MDQzQlxcdTA0M0NcXHgwN3BcdTAwMDJcdTAwMDJcXHUwNDNDXFx1MDQzRFxceDA3dlx1MDAwMlx1MDAwMlxcdTA0M0RcXHUwNDNFXFx4MDc0XHUwMDAyXHUwMDAyXFx1MDQzRVxcdTA0M0ZcXHgwNzNcdTAwMDJcdTAwMDJcXHUwNDNGXFx1MDQ2NFxceDA3OFx1MDAwMlx1MDAwMlxcdTA0NDBcXHUwNDQxXFx4MDd3XHUwMDAyXHUwMDAyXFx1MDQ0MVxcdTA0NDJcXHgwN2tcdTAwMDJcdTAwMDJcXHUwNDQyXFx1MDQ0M1xceDA3cFx1MDAwMlx1MDAwMlxcdTA0NDNcXHUwNDQ0XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDQ0NFxcdTA0NDVcXHgwNzRcdTAwMDJcdTAwMDJcXHUwNDQ1XFx1MDQ0NlxceDA3NFx1MDAwMlx1MDAwMlxcdTA0NDZcXHUwNDY0XFx4MDc2XHUwMDAyXHUwMDAyXFx1MDQ0N1xcdTA0NDhcXHgwN3dcdTAwMDJcdTAwMDJcXHUwNDQ4XFx1MDQ0OVxceDA3a1x1MDAwMlx1MDAwMlxcdTA0NDlcXHUwNDRBXFx4MDdwXHUwMDAyXHUwMDAyXFx1MDQ0QVxcdTA0NEJcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNDRCXFx1MDQ0Q1xceDA3NFx1MDAwMlx1MDAwMlxcdTA0NENcXHUwNDREXFx4MDc1XHUwMDAyXHUwMDAyXFx1MDQ0RFxcdTA0NjRcXHgwNzRcdTAwMDJcdTAwMDJcXHUwNDRFXFx1MDQ0RlxceDA3d1x1MDAwMlx1MDAwMlxcdTA0NEZcXHUwNDUwXFx4MDdrXHUwMDAyXHUwMDAyXFx1MDQ1MFxcdTA0NTFcXHgwN3BcdTAwMDJcdTAwMDJcXHUwNDUxXFx1MDQ1MlxceDA3dlx1MDAwMlx1MDAwMlxcdTA0NTJcXHUwNDUzXFx4MDc0XHUwMDAyXHUwMDAyXFx1MDQ1M1xcdTA0NTRcXHgwNzZcdTAwMDJcdTAwMDJcXHUwNDU0XFx1MDQ2NFxceDA3Mlx1MDAwMlx1MDAwMlxcdTA0NTVcXHUwNDU2XFx4MDd3XHUwMDAyXHUwMDAyXFx1MDQ1NlxcdTA0NTdcXHgwN2tcdTAwMDJcdTAwMDJcXHUwNDU3XFx1MDQ1OFxceDA3cFx1MDAwMlx1MDAwMlxcdTA0NThcXHUwNDU5XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDQ1OVxcdTA0NUFcXHgwNzRcdTAwMDJcdTAwMDJcXHUwNDVBXFx1MDQ1QlxceDA3Nlx1MDAwMlx1MDAwMlxcdTA0NUJcXHUwNDY0XFx4MDc6XHUwMDAyXHUwMDAyXFx1MDQ1Q1xcdTA0NURcXHgwN3dcdTAwMDJcdTAwMDJcXHUwNDVEXFx1MDQ1RVxceDA3a1x1MDAwMlx1MDAwMlxcdTA0NUVcXHUwNDVGXFx4MDdwXHUwMDAyXHUwMDAyXFx1MDQ1RlxcdTA0NjBcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNDYwXFx1MDQ2MVxceDA3NFx1MDAwMlx1MDAwMlxcdTA0NjFcXHUwNDYyXFx4MDc3XHUwMDAyXHUwMDAyXFx1MDQ2MlxcdTA0NjRcXHgwNzhcdTAwMDJcdTAwMDJcXHUwNDYzXFx1MDM4Q1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NjNcXHUwMzkwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ2M1xcdTAzOTVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDYzXFx1MDM5Qlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NjNcXHUwM0ExXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ2M1xcdTAzQTdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDYzXFx1MDNBRFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NjNcXHUwM0IzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ2M1xcdTAzQjlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDYzXFx1MDNCRlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NjNcXHUwM0M1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ2M1xcdTAzQ0JcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDYzXFx1MDNEMVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NjNcXHUwM0Q3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ2M1xcdTAzREVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDYzXFx1MDNFNVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NjNcXHUwM0VDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ2M1xcdTAzRjNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDYzXFx1MDNGQVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NjNcXHUwNDAxXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ2M1xcdTA0MDhcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDYzXFx1MDQwRlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NjNcXHUwNDE2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ2M1xcdTA0MURcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDYzXFx1MDQyNFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NjNcXHUwNDJCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ2M1xcdTA0MzJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDYzXFx1MDQzOVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NjNcXHUwNDQwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ2M1xcdTA0NDdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDYzXFx1MDQ0RVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NjNcXHUwNDU1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ2M1xcdTA0NUNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDY0XFx4QzhcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDY1XFx1MDQ2NlxceDA3ZFx1MDAwMlx1MDAwMlxcdTA0NjZcXHUwNDY3XFx4MDd7XHUwMDAyXHUwMDAyXFx1MDQ2N1xcdTA0NjhcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNDY4XFx1MDQ2OVxceDA3Z1x1MDAwMlx1MDAwMlxcdTA0NjlcXHUwNTQyXFx4MDd1XHUwMDAyXHUwMDAyXFx1MDQ2QVxcdTA0NkJcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNDZCXFx1MDQ2Q1xceDA3e1x1MDAwMlx1MDAwMlxcdTA0NkNcXHUwNDZEXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDQ2RFxcdTA0NkVcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNDZFXFx1MDQ2RlxceDA3dVx1MDAwMlx1MDAwMlxcdTA0NkZcXHUwNTQyXFx4MDczXHUwMDAyXHUwMDAyXFx1MDQ3MFxcdTA0NzFcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNDcxXFx1MDQ3MlxceDA3e1x1MDAwMlx1MDAwMlxcdTA0NzJcXHUwNDczXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDQ3M1xcdTA0NzRcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNDc0XFx1MDQ3NVxceDA3dVx1MDAwMlx1MDAwMlxcdTA0NzVcXHUwNTQyXFx4MDc0XHUwMDAyXHUwMDAyXFx1MDQ3NlxcdTA0NzdcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNDc3XFx1MDQ3OFxceDA3e1x1MDAwMlx1MDAwMlxcdTA0NzhcXHUwNDc5XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDQ3OVxcdTA0N0FcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNDdBXFx1MDQ3QlxceDA3dVx1MDAwMlx1MDAwMlxcdTA0N0JcXHUwNTQyXFx4MDc1XHUwMDAyXHUwMDAyXFx1MDQ3Q1xcdTA0N0RcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNDdEXFx1MDQ3RVxceDA3e1x1MDAwMlx1MDAwMlxcdTA0N0VcXHUwNDdGXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDQ3RlxcdTA0ODBcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNDgwXFx1MDQ4MVxceDA3dVx1MDAwMlx1MDAwMlxcdTA0ODFcXHUwNTQyXFx4MDc2XHUwMDAyXHUwMDAyXFx1MDQ4MlxcdTA0ODNcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNDgzXFx1MDQ4NFxceDA3e1x1MDAwMlx1MDAwMlxcdTA0ODRcXHUwNDg1XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDQ4NVxcdTA0ODZcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNDg2XFx1MDQ4N1xceDA3dVx1MDAwMlx1MDAwMlxcdTA0ODdcXHUwNTQyXFx4MDc3XHUwMDAyXHUwMDAyXFx1MDQ4OFxcdTA0ODlcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNDg5XFx1MDQ4QVxceDA3e1x1MDAwMlx1MDAwMlxcdTA0OEFcXHUwNDhCXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDQ4QlxcdTA0OENcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNDhDXFx1MDQ4RFxceDA3dVx1MDAwMlx1MDAwMlxcdTA0OERcXHUwNTQyXFx4MDc4XHUwMDAyXHUwMDAyXFx1MDQ4RVxcdTA0OEZcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNDhGXFx1MDQ5MFxceDA3e1x1MDAwMlx1MDAwMlxcdTA0OTBcXHUwNDkxXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDQ5MVxcdTA0OTJcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNDkyXFx1MDQ5M1xceDA3dVx1MDAwMlx1MDAwMlxcdTA0OTNcXHUwNTQyXFx4MDc5XHUwMDAyXHUwMDAyXFx1MDQ5NFxcdTA0OTVcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNDk1XFx1MDQ5NlxceDA3e1x1MDAwMlx1MDAwMlxcdTA0OTZcXHUwNDk3XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDQ5N1xcdTA0OThcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNDk4XFx1MDQ5OVxceDA3dVx1MDAwMlx1MDAwMlxcdTA0OTlcXHUwNTQyXFx4MDc6XHUwMDAyXHUwMDAyXFx1MDQ5QVxcdTA0OUJcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNDlCXFx1MDQ5Q1xceDA3e1x1MDAwMlx1MDAwMlxcdTA0OUNcXHUwNDlEXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDQ5RFxcdTA0OUVcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNDlFXFx1MDQ5RlxceDA3dVx1MDAwMlx1MDAwMlxcdTA0OUZcXHUwNTQyXFx4MDc7XHUwMDAyXHUwMDAyXFx1MDRBMFxcdTA0QTFcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNEExXFx1MDRBMlxceDA3e1x1MDAwMlx1MDAwMlxcdTA0QTJcXHUwNEEzXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDRBM1xcdTA0QTRcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNEE0XFx1MDRBNVxceDA3dVx1MDAwMlx1MDAwMlxcdTA0QTVcXHUwNEE2XFx4MDczXHUwMDAyXHUwMDAyXFx1MDRBNlxcdTA1NDJcXHgwNzJcdTAwMDJcdTAwMDJcXHUwNEE3XFx1MDRBOFxceDA3ZFx1MDAwMlx1MDAwMlxcdTA0QThcXHUwNEE5XFx4MDd7XHUwMDAyXHUwMDAyXFx1MDRBOVxcdTA0QUFcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNEFBXFx1MDRBQlxceDA3Z1x1MDAwMlx1MDAwMlxcdTA0QUJcXHUwNEFDXFx4MDd1XHUwMDAyXHUwMDAyXFx1MDRBQ1xcdTA0QURcXHgwNzNcdTAwMDJcdTAwMDJcXHUwNEFEXFx1MDU0MlxceDA3M1x1MDAwMlx1MDAwMlxcdTA0QUVcXHUwNEFGXFx4MDdkXHUwMDAyXHUwMDAyXFx1MDRBRlxcdTA0QjBcXHgwN3tcdTAwMDJcdTAwMDJcXHUwNEIwXFx1MDRCMVxceDA3dlx1MDAwMlx1MDAwMlxcdTA0QjFcXHUwNEIyXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDRCMlxcdTA0QjNcXHgwN3VcdTAwMDJcdTAwMDJcXHUwNEIzXFx1MDRCNFxceDA3M1x1MDAwMlx1MDAwMlxcdTA0QjRcXHUwNTQyXFx4MDc0XHUwMDAyXHUwMDAyXFx1MDRCNVxcdTA0QjZcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNEI2XFx1MDRCN1xceDA3e1x1MDAwMlx1MDAwMlxcdTA0QjdcXHUwNEI4XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDRCOFxcdTA0QjlcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNEI5XFx1MDRCQVxceDA3dVx1MDAwMlx1MDAwMlxcdTA0QkFcXHUwNEJCXFx4MDczXHUwMDAyXHUwMDAyXFx1MDRCQlxcdTA1NDJcXHgwNzVcdTAwMDJcdTAwMDJcXHUwNEJDXFx1MDRCRFxceDA3ZFx1MDAwMlx1MDAwMlxcdTA0QkRcXHUwNEJFXFx4MDd7XHUwMDAyXHUwMDAyXFx1MDRCRVxcdTA0QkZcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNEJGXFx1MDRDMFxceDA3Z1x1MDAwMlx1MDAwMlxcdTA0QzBcXHUwNEMxXFx4MDd1XHUwMDAyXHUwMDAyXFx1MDRDMVxcdTA0QzJcXHgwNzNcdTAwMDJcdTAwMDJcXHUwNEMyXFx1MDU0MlxceDA3Nlx1MDAwMlx1MDAwMlxcdTA0QzNcXHUwNEM0XFx4MDdkXHUwMDAyXHUwMDAyXFx1MDRDNFxcdTA0QzVcXHgwN3tcdTAwMDJcdTAwMDJcXHUwNEM1XFx1MDRDNlxceDA3dlx1MDAwMlx1MDAwMlxcdTA0QzZcXHUwNEM3XFx4MDdnXHUwMDAyXHUwMDAyXFx1MDRDN1xcdTA0QzhcXHgwN3VcdTAwMDJcdTAwMDJcXHUwNEM4XFx1MDRDOVxceDA3M1x1MDAwMlx1MDAwMlxcdTA0QzlcXHUwNTQyXFx4MDc3XHUwMDAyXHUwMDAyXFx1MDRDQVxcdTA0Q0JcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNENCXFx1MDRDQ1xceDA3e1x1MDAwMlx1MDAwMlxcdTA0Q0NcXHUwNENEXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDRDRFxcdTA0Q0VcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNENFXFx1MDRDRlxceDA3dVx1MDAwMlx1MDAwMlxcdTA0Q0ZcXHUwNEQwXFx4MDczXHUwMDAyXHUwMDAyXFx1MDREMFxcdTA1NDJcXHgwNzhcdTAwMDJcdTAwMDJcXHUwNEQxXFx1MDREMlxceDA3ZFx1MDAwMlx1MDAwMlxcdTA0RDJcXHUwNEQzXFx4MDd7XHUwMDAyXHUwMDAyXFx1MDREM1xcdTA0RDRcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNEQ0XFx1MDRENVxceDA3Z1x1MDAwMlx1MDAwMlxcdTA0RDVcXHUwNEQ2XFx4MDd1XHUwMDAyXHUwMDAyXFx1MDRENlxcdTA0RDdcXHgwNzNcdTAwMDJcdTAwMDJcXHUwNEQ3XFx1MDU0MlxceDA3OVx1MDAwMlx1MDAwMlxcdTA0RDhcXHUwNEQ5XFx4MDdkXHUwMDAyXHUwMDAyXFx1MDREOVxcdTA0REFcXHgwN3tcdTAwMDJcdTAwMDJcXHUwNERBXFx1MDREQlxceDA3dlx1MDAwMlx1MDAwMlxcdTA0REJcXHUwNERDXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDREQ1xcdTA0RERcXHgwN3VcdTAwMDJcdTAwMDJcXHUwNEREXFx1MDRERVxceDA3M1x1MDAwMlx1MDAwMlxcdTA0REVcXHUwNTQyXFx4MDc6XHUwMDAyXHUwMDAyXFx1MDRERlxcdTA0RTBcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNEUwXFx1MDRFMVxceDA3e1x1MDAwMlx1MDAwMlxcdTA0RTFcXHUwNEUyXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDRFMlxcdTA0RTNcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNEUzXFx1MDRFNFxceDA3dVx1MDAwMlx1MDAwMlxcdTA0RTRcXHUwNEU1XFx4MDczXHUwMDAyXHUwMDAyXFx1MDRFNVxcdTA1NDJcXHgwNztcdTAwMDJcdTAwMDJcXHUwNEU2XFx1MDRFN1xceDA3ZFx1MDAwMlx1MDAwMlxcdTA0RTdcXHUwNEU4XFx4MDd7XHUwMDAyXHUwMDAyXFx1MDRFOFxcdTA0RTlcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNEU5XFx1MDRFQVxceDA3Z1x1MDAwMlx1MDAwMlxcdTA0RUFcXHUwNEVCXFx4MDd1XHUwMDAyXHUwMDAyXFx1MDRFQlxcdTA0RUNcXHgwNzRcdTAwMDJcdTAwMDJcXHUwNEVDXFx1MDU0MlxceDA3Mlx1MDAwMlx1MDAwMlxcdTA0RURcXHUwNEVFXFx4MDdkXHUwMDAyXHUwMDAyXFx1MDRFRVxcdTA0RUZcXHgwN3tcdTAwMDJcdTAwMDJcXHUwNEVGXFx1MDRGMFxceDA3dlx1MDAwMlx1MDAwMlxcdTA0RjBcXHUwNEYxXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDRGMVxcdTA0RjJcXHgwN3VcdTAwMDJcdTAwMDJcXHUwNEYyXFx1MDRGM1xceDA3NFx1MDAwMlx1MDAwMlxcdTA0RjNcXHUwNTQyXFx4MDczXHUwMDAyXHUwMDAyXFx1MDRGNFxcdTA0RjVcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNEY1XFx1MDRGNlxceDA3e1x1MDAwMlx1MDAwMlxcdTA0RjZcXHUwNEY3XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDRGN1xcdTA0RjhcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNEY4XFx1MDRGOVxceDA3dVx1MDAwMlx1MDAwMlxcdTA0RjlcXHUwNEZBXFx4MDc0XHUwMDAyXHUwMDAyXFx1MDRGQVxcdTA1NDJcXHgwNzRcdTAwMDJcdTAwMDJcXHUwNEZCXFx1MDRGQ1xceDA3ZFx1MDAwMlx1MDAwMlxcdTA0RkNcXHUwNEZEXFx4MDd7XHUwMDAyXHUwMDAyXFx1MDRGRFxcdTA0RkVcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNEZFXFx1MDRGRlxceDA3Z1x1MDAwMlx1MDAwMlxcdTA0RkZcXHUwNTAwXFx4MDd1XHUwMDAyXHUwMDAyXFx1MDUwMFxcdTA1MDFcXHgwNzRcdTAwMDJcdTAwMDJcXHUwNTAxXFx1MDU0MlxceDA3NVx1MDAwMlx1MDAwMlxcdTA1MDJcXHUwNTAzXFx4MDdkXHUwMDAyXHUwMDAyXFx1MDUwM1xcdTA1MDRcXHgwN3tcdTAwMDJcdTAwMDJcXHUwNTA0XFx1MDUwNVxceDA3dlx1MDAwMlx1MDAwMlxcdTA1MDVcXHUwNTA2XFx4MDdnXHUwMDAyXHUwMDAyXFx1MDUwNlxcdTA1MDdcXHgwN3VcdTAwMDJcdTAwMDJcXHUwNTA3XFx1MDUwOFxceDA3NFx1MDAwMlx1MDAwMlxcdTA1MDhcXHUwNTQyXFx4MDc2XHUwMDAyXHUwMDAyXFx1MDUwOVxcdTA1MEFcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNTBBXFx1MDUwQlxceDA3e1x1MDAwMlx1MDAwMlxcdTA1MEJcXHUwNTBDXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDUwQ1xcdTA1MERcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNTBEXFx1MDUwRVxceDA3dVx1MDAwMlx1MDAwMlxcdTA1MEVcXHUwNTBGXFx4MDc0XHUwMDAyXHUwMDAyXFx1MDUwRlxcdTA1NDJcXHgwNzdcdTAwMDJcdTAwMDJcXHUwNTEwXFx1MDUxMVxceDA3ZFx1MDAwMlx1MDAwMlxcdTA1MTFcXHUwNTEyXFx4MDd7XHUwMDAyXHUwMDAyXFx1MDUxMlxcdTA1MTNcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNTEzXFx1MDUxNFxceDA3Z1x1MDAwMlx1MDAwMlxcdTA1MTRcXHUwNTE1XFx4MDd1XHUwMDAyXHUwMDAyXFx1MDUxNVxcdTA1MTZcXHgwNzRcdTAwMDJcdTAwMDJcXHUwNTE2XFx1MDU0MlxceDA3OFx1MDAwMlx1MDAwMlxcdTA1MTdcXHUwNTE4XFx4MDdkXHUwMDAyXHUwMDAyXFx1MDUxOFxcdTA1MTlcXHgwN3tcdTAwMDJcdTAwMDJcXHUwNTE5XFx1MDUxQVxceDA3dlx1MDAwMlx1MDAwMlxcdTA1MUFcXHUwNTFCXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDUxQlxcdTA1MUNcXHgwN3VcdTAwMDJcdTAwMDJcXHUwNTFDXFx1MDUxRFxceDA3NFx1MDAwMlx1MDAwMlxcdTA1MURcXHUwNTQyXFx4MDc5XHUwMDAyXHUwMDAyXFx1MDUxRVxcdTA1MUZcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNTFGXFx1MDUyMFxceDA3e1x1MDAwMlx1MDAwMlxcdTA1MjBcXHUwNTIxXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDUyMVxcdTA1MjJcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNTIyXFx1MDUyM1xceDA3dVx1MDAwMlx1MDAwMlxcdTA1MjNcXHUwNTI0XFx4MDc0XHUwMDAyXHUwMDAyXFx1MDUyNFxcdTA1NDJcXHgwNzpcdTAwMDJcdTAwMDJcXHUwNTI1XFx1MDUyNlxceDA3ZFx1MDAwMlx1MDAwMlxcdTA1MjZcXHUwNTI3XFx4MDd7XHUwMDAyXHUwMDAyXFx1MDUyN1xcdTA1MjhcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNTI4XFx1MDUyOVxceDA3Z1x1MDAwMlx1MDAwMlxcdTA1MjlcXHUwNTJBXFx4MDd1XHUwMDAyXHUwMDAyXFx1MDUyQVxcdTA1MkJcXHgwNzRcdTAwMDJcdTAwMDJcXHUwNTJCXFx1MDU0MlxceDA3O1x1MDAwMlx1MDAwMlxcdTA1MkNcXHUwNTJEXFx4MDdkXHUwMDAyXHUwMDAyXFx1MDUyRFxcdTA1MkVcXHgwN3tcdTAwMDJcdTAwMDJcXHUwNTJFXFx1MDUyRlxceDA3dlx1MDAwMlx1MDAwMlxcdTA1MkZcXHUwNTMwXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDUzMFxcdTA1MzFcXHgwN3VcdTAwMDJcdTAwMDJcXHUwNTMxXFx1MDUzMlxceDA3NVx1MDAwMlx1MDAwMlxcdTA1MzJcXHUwNTQyXFx4MDcyXHUwMDAyXHUwMDAyXFx1MDUzM1xcdTA1MzRcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNTM0XFx1MDUzNVxceDA3e1x1MDAwMlx1MDAwMlxcdTA1MzVcXHUwNTM2XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDUzNlxcdTA1MzdcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNTM3XFx1MDUzOFxceDA3dVx1MDAwMlx1MDAwMlxcdTA1MzhcXHUwNTM5XFx4MDc1XHUwMDAyXHUwMDAyXFx1MDUzOVxcdTA1NDJcXHgwNzNcdTAwMDJcdTAwMDJcXHUwNTNBXFx1MDUzQlxceDA3ZFx1MDAwMlx1MDAwMlxcdTA1M0JcXHUwNTNDXFx4MDd7XHUwMDAyXHUwMDAyXFx1MDUzQ1xcdTA1M0RcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNTNEXFx1MDUzRVxceDA3Z1x1MDAwMlx1MDAwMlxcdTA1M0VcXHUwNTNGXFx4MDd1XHUwMDAyXHUwMDAyXFx1MDUzRlxcdTA1NDBcXHgwNzVcdTAwMDJcdTAwMDJcXHUwNTQwXFx1MDU0MlxceDA3NFx1MDAwMlx1MDAwMlxcdTA1NDFcXHUwNDY1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU0MVxcdTA0NkFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTQxXFx1MDQ3MFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1NDFcXHUwNDc2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU0MVxcdTA0N0NcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTQxXFx1MDQ4Mlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1NDFcXHUwNDg4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU0MVxcdTA0OEVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTQxXFx1MDQ5NFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1NDFcXHUwNDlBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU0MVxcdTA0QTBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTQxXFx1MDRBN1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1NDFcXHUwNEFFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU0MVxcdTA0QjVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTQxXFx1MDRCQ1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1NDFcXHUwNEMzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU0MVxcdTA0Q0FcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTQxXFx1MDREMVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1NDFcXHUwNEQ4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU0MVxcdTA0REZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTQxXFx1MDRFNlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1NDFcXHUwNEVEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU0MVxcdTA0RjRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTQxXFx1MDRGQlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1NDFcXHUwNTAyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU0MVxcdTA1MDlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTQxXFx1MDUxMFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1NDFcXHUwNTE3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU0MVxcdTA1MUVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTQxXFx1MDUyNVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1NDFcXHUwNTJDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU0MVxcdTA1MzNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTQxXFx1MDUzQVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1NDJcXHhDQVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1NDNcXHUwNTQ0XFx4MDdoXHUwMDAyXHUwMDAyXFx1MDU0NFxcdTA1NDVcXHgwN2tcdTAwMDJcdTAwMDJcXHUwNTQ1XFx1MDU0NlxceDA3elx1MDAwMlx1MDAwMlxcdTA1NDZcXHUwNTQ3XFx4MDdnXHUwMDAyXHUwMDAyXFx1MDU0N1xcdTA1NUFcXHgwN2ZcdTAwMDJcdTAwMDJcXHUwNTQ4XFx1MDU0OVxceDA3aFx1MDAwMlx1MDAwMlxcdTA1NDlcXHUwNTRBXFx4MDdrXHUwMDAyXHUwMDAyXFx1MDU0QVxcdTA1NEJcXHgwN3pcdTAwMDJcdTAwMDJcXHUwNTRCXFx1MDU0Q1xceDA3Z1x1MDAwMlx1MDAwMlxcdTA1NENcXHUwNTREXFx4MDdmXHUwMDAyXHUwMDAyXFx1MDU0RFxcdTA1NEZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTRFXFx1MDU1MFx0XHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU0RlxcdTA1NEVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTUwXFx1MDU1MVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1NTFcXHUwNTRGXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU1MVxcdTA1NTJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTUyXFx1MDU1M1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1NTNcXHUwNTU1XFx4MDd6XHUwMDAyXHUwMDAyXFx1MDU1NFxcdTA1NTZcdFx1MDAwMlx1MDAwMlx1MDAwMlxcdTA1NTVcXHUwNTU0XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU1NlxcdTA1NTdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTU3XFx1MDU1NVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1NTdcXHUwNTU4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU1OFxcdTA1NUFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTU5XFx1MDU0M1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1NTlcXHUwNTQ4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU1QVxceENDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU1QlxcdTA1NUNcXHgwN3dcdTAwMDJcdTAwMDJcXHUwNTVDXFx1MDU1RFxceDA3aFx1MDAwMlx1MDAwMlxcdTA1NURcXHUwNTVFXFx4MDdrXHUwMDAyXHUwMDAyXFx1MDU1RVxcdTA1NUZcXHgwN3pcdTAwMDJcdTAwMDJcXHUwNTVGXFx1MDU2MFxceDA3Z1x1MDAwMlx1MDAwMlxcdTA1NjBcXHUwNTc0XFx4MDdmXHUwMDAyXHUwMDAyXFx1MDU2MVxcdTA1NjJcXHgwN3dcdTAwMDJcdTAwMDJcXHUwNTYyXFx1MDU2M1xceDA3aFx1MDAwMlx1MDAwMlxcdTA1NjNcXHUwNTY0XFx4MDdrXHUwMDAyXHUwMDAyXFx1MDU2NFxcdTA1NjVcXHgwN3pcdTAwMDJcdTAwMDJcXHUwNTY1XFx1MDU2NlxceDA3Z1x1MDAwMlx1MDAwMlxcdTA1NjZcXHUwNTY3XFx4MDdmXHUwMDAyXHUwMDAyXFx1MDU2N1xcdTA1NjlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTY4XFx1MDU2QVx0XHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU2OVxcdTA1NjhcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTZBXFx1MDU2Qlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1NkJcXHUwNTY5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU2QlxcdTA1NkNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTZDXFx1MDU2RFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1NkRcXHUwNTZGXFx4MDd6XHUwMDAyXHUwMDAyXFx1MDU2RVxcdTA1NzBcdFx1MDAwMlx1MDAwMlx1MDAwMlxcdTA1NkZcXHUwNTZFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU3MFxcdTA1NzFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTcxXFx1MDU2Rlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1NzFcXHUwNTcyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU3MlxcdTA1NzRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTczXFx1MDU1Qlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1NzNcXHUwNTYxXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU3NFxceENFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU3NVxcdTA1NzZcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNTc2XFx1MDU3N1xceDA3dFx1MDAwMlx1MDAwMlxcdTA1NzdcXHUwNTc4XFx4MDd3XHUwMDAyXHUwMDAyXFx1MDU3OFxcdTA1N0ZcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNTc5XFx1MDU3QVxceDA3aFx1MDAwMlx1MDAwMlxcdTA1N0FcXHUwNTdCXFx4MDdjXHUwMDAyXHUwMDAyXFx1MDU3QlxcdTA1N0NcXHgwN25cdTAwMDJcdTAwMDJcXHUwNTdDXFx1MDU3RFxceDA3dVx1MDAwMlx1MDAwMlxcdTA1N0RcXHUwNTdGXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDU3RVxcdTA1NzVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTdFXFx1MDU3OVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1N0ZcXHhEMFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1ODBcXHUwNTg3XHUwMDA1XFx4RDNqXHUwMDAyXFx1MDU4MVxcdTA1ODNcdTAwMDVcXHhEM2pcdTAwMDJcXHUwNTgyXFx1MDU4MVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1ODJcXHUwNTgzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU4M1xcdTA1ODRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTg0XFx1MDU4NVxceDA3MFx1MDAwMlx1MDAwMlxcdTA1ODVcXHUwNTg3XHUwMDA1XFx4RDNqXHUwMDAyXFx1MDU4NlxcdTA1ODBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTg2XFx1MDU4Mlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1ODdcXHUwNThBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU4OFxcdTA1ODlcdFx1MDAwM1x1MDAwMlx1MDAwMlxcdTA1ODlcXHUwNThCXHUwMDA1XFx4RDNqXHUwMDAyXFx1MDU4QVxcdTA1ODhcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNThBXFx1MDU4Qlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1OEJcXHhEMlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1OENcXHUwNTkzXHRcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNThEXFx1MDU4RlxceDA3YVx1MDAwMlx1MDAwMlxcdTA1OEVcXHUwNThEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU4RVxcdTA1OEZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNThGXFx1MDU5MFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1OTBcXHUwNTkyXHRcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTkxXFx1MDU4RVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1OTJcXHUwNTk1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU5M1xcdTA1OTFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTkzXFx1MDU5NFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1OTRcXHhENFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1OTVcXHUwNTkzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU5NlxcdTA1OTdcXHgwNzJcdTAwMDJcdTAwMDJcXHUwNTk3XFx1MDU5OFx0XHUwMDA0XHUwMDAyXHUwMDAyXFx1MDU5OFxcdTA1OTlcdTAwMDVcXHhEN2xcdTAwMDJcXHUwNTk5XFx4RDZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTlBXFx1MDVBMVx1MDAwNVxceERGcFx1MDAwMlxcdTA1OUJcXHUwNTlEXFx4MDdhXHUwMDAyXHUwMDAyXFx1MDU5Q1xcdTA1OUJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNTlDXFx1MDU5RFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1OURcXHUwNTlFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDU5RVxcdTA1QTBcdTAwMDVcXHhERnBcdTAwMDJcXHUwNTlGXFx1MDU5Q1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1QTBcXHUwNUEzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDVBMVxcdTA1OUZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNUExXFx1MDVBMlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1QTJcXHhEOFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1QTNcXHUwNUExXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDVBNFxcdTA1QTVcXHgwN3lcdTAwMDJcdTAwMDJcXHUwNUE1XFx1MDVBNlxceDA3Z1x1MDAwMlx1MDAwMlxcdTA1QTZcXHUwNUREXFx4MDdrXHUwMDAyXHUwMDAyXFx1MDVBN1xcdTA1QThcXHgwN2lcdTAwMDJcdTAwMDJcXHUwNUE4XFx1MDVBOVxceDA3eVx1MDAwMlx1MDAwMlxcdTA1QTlcXHUwNUFBXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDVBQVxcdTA1RERcXHgwN2tcdTAwMDJcdTAwMDJcXHUwNUFCXFx1MDVBQ1xceDA3dVx1MDAwMlx1MDAwMlxcdTA1QUNcXHUwNUFEXFx4MDd8XHUwMDAyXHUwMDAyXFx1MDVBRFxcdTA1QUVcXHgwN2NcdTAwMDJcdTAwMDJcXHUwNUFFXFx1MDVBRlxceDA3ZFx1MDAwMlx1MDAwMlxcdTA1QUZcXHUwNUREXFx4MDdxXHUwMDAyXHUwMDAyXFx1MDVCMFxcdTA1QjFcXHgwN2hcdTAwMDJcdTAwMDJcXHUwNUIxXFx1MDVCMlxceDA3a1x1MDAwMlx1MDAwMlxcdTA1QjJcXHUwNUIzXFx4MDdwXHUwMDAyXHUwMDAyXFx1MDVCM1xcdTA1QjRcXHgwN3BcdTAwMDJcdTAwMDJcXHUwNUI0XFx1MDVCNVxceDA3Z1x1MDAwMlx1MDAwMlxcdTA1QjVcXHUwNUREXFx4MDd7XHUwMDAyXHUwMDAyXFx1MDVCNlxcdTA1QjdcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNUI3XFx1MDVCOFxceDA3dlx1MDAwMlx1MDAwMlxcdTA1QjhcXHUwNUI5XFx4MDdqXHUwMDAyXHUwMDAyXFx1MDVCOVxcdTA1QkFcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNUJBXFx1MDVERFxceDA3dFx1MDAwMlx1MDAwMlxcdTA1QkJcXHUwNUJDXFx4MDd1XHUwMDAyXHUwMDAyXFx1MDVCQ1xcdTA1QkRcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNUJEXFx1MDVCRVxceDA3ZVx1MDAwMlx1MDAwMlxcdTA1QkVcXHUwNUJGXFx4MDdxXHUwMDAyXHUwMDAyXFx1MDVCRlxcdTA1QzBcXHgwN3BcdTAwMDJcdTAwMDJcXHUwNUMwXFx1MDVDMVxceDA3Zlx1MDAwMlx1MDAwMlxcdTA1QzFcXHUwNUREXFx4MDd1XHUwMDAyXHUwMDAyXFx1MDVDMlxcdTA1QzNcXHgwN29cdTAwMDJcdTAwMDJcXHUwNUMzXFx1MDVDNFxceDA3a1x1MDAwMlx1MDAwMlxcdTA1QzRcXHUwNUM1XFx4MDdwXHUwMDAyXHUwMDAyXFx1MDVDNVxcdTA1QzZcXHgwN3dcdTAwMDJcdTAwMDJcXHUwNUM2XFx1MDVDN1xceDA3dlx1MDAwMlx1MDAwMlxcdTA1QzdcXHUwNUM4XFx4MDdnXHUwMDAyXHUwMDAyXFx1MDVDOFxcdTA1RERcXHgwN3VcdTAwMDJcdTAwMDJcXHUwNUM5XFx1MDVDQVxceDA3alx1MDAwMlx1MDAwMlxcdTA1Q0FcXHUwNUNCXFx4MDdxXHUwMDAyXHUwMDAyXFx1MDVDQlxcdTA1Q0NcXHgwN3dcdTAwMDJcdTAwMDJcXHUwNUNDXFx1MDVDRFxceDA3dFx1MDAwMlx1MDAwMlxcdTA1Q0RcXHUwNUREXFx4MDd1XHUwMDAyXHUwMDAyXFx1MDVDRVxcdTA1Q0ZcXHgwN2ZcdTAwMDJcdTAwMDJcXHUwNUNGXFx1MDVEMFxceDA3Y1x1MDAwMlx1MDAwMlxcdTA1RDBcXHUwNUQxXFx4MDd7XHUwMDAyXHUwMDAyXFx1MDVEMVxcdTA1RERcXHgwN3VcdTAwMDJcdTAwMDJcXHUwNUQyXFx1MDVEM1xceDA3eVx1MDAwMlx1MDAwMlxcdTA1RDNcXHUwNUQ0XFx4MDdnXHUwMDAyXHUwMDAyXFx1MDVENFxcdTA1RDVcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNUQ1XFx1MDVENlxceDA3bVx1MDAwMlx1MDAwMlxcdTA1RDZcXHUwNUREXFx4MDd1XHUwMDAyXHUwMDAyXFx1MDVEN1xcdTA1RDhcXHgwN3tcdTAwMDJcdTAwMDJcXHUwNUQ4XFx1MDVEOVxceDA3Z1x1MDAwMlx1MDAwMlxcdTA1RDlcXHUwNURBXFx4MDdjXHUwMDAyXHUwMDAyXFx1MDVEQVxcdTA1REJcXHgwN3RcdTAwMDJcdTAwMDJcXHUwNURCXFx1MDVERFxceDA3dVx1MDAwMlx1MDAwMlxcdTA1RENcXHUwNUE0XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDVEQ1xcdTA1QTdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNURDXFx1MDVBQlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1RENcXHUwNUIwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDVEQ1xcdTA1QjZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNURDXFx1MDVCQlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1RENcXHUwNUMyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDVEQ1xcdTA1QzlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNURDXFx1MDVDRVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1RENcXHUwNUQyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDVEQ1xcdTA1RDdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNUREXFx4REFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNURFXFx1MDVERlxceDA3alx1MDAwMlx1MDAwMlxcdTA1REZcXHUwNUUwXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDVFMFxcdTA1RTFcXHgwN3pcdTAwMDJcdTAwMDJcXHUwNUUxXFx1MDVFQ1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1RTJcXHUwNUU0XFx4MDckXHUwMDAyXHUwMDAyXFx1MDVFM1xcdTA1RTVcdTAwMDVcXHhEN2xcdTAwMDJcXHUwNUU0XFx1MDVFM1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1RTRcXHUwNUU1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDVFNVxcdTA1RTZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNUU2XFx1MDVFRFxceDA3JFx1MDAwMlx1MDAwMlxcdTA1RTdcXHUwNUU5XFx4MDcpXHUwMDAyXHUwMDAyXFx1MDVFOFxcdTA1RUFcdTAwMDVcXHhEN2xcdTAwMDJcXHUwNUU5XFx1MDVFOFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1RTlcXHUwNUVBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDVFQVxcdTA1RUJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNUVCXFx1MDVFRFxceDA3KVx1MDAwMlx1MDAwMlxcdTA1RUNcXHUwNUUyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDVFQ1xcdTA1RTdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNUVEXFx4RENcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNUVFXFx1MDVFRlx1MDAwNVxceERGcFx1MDAwMlxcdTA1RUZcXHUwNUYwXHUwMDA1XFx4REZwXHUwMDAyXFx1MDVGMFxceERFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDVGMVxcdTA1RjJcdFx1MDAwNVx1MDAwMlx1MDAwMlxcdTA1RjJcXHhFMFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA1RjNcXHUwNUY0XFx4MDdjXHUwMDAyXHUwMDAyXFx1MDVGNFxcdTA1RjVcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNUY1XFx1MDVGNlxceDA3dVx1MDAwMlx1MDAwMlxcdTA1RjZcXHUwNUY3XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDVGN1xcdTA1RjhcXHgwN3RcdTAwMDJcdTAwMDJcXHUwNUY4XFx1MDVGOVxceDA3Y1x1MDAwMlx1MDAwMlxcdTA1RjlcXHUwNUZBXFx4MDdlXHUwMDAyXHUwMDAyXFx1MDVGQVxcdTA2NENcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNUZCXFx1MDVGQ1xceDA3Y1x1MDAwMlx1MDAwMlxcdTA1RkNcXHUwNUZEXFx4MDdoXHUwMDAyXHUwMDAyXFx1MDVGRFxcdTA1RkVcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNUZFXFx1MDVGRlxceDA3Z1x1MDAwMlx1MDAwMlxcdTA1RkZcXHUwNjRDXFx4MDd0XHUwMDAyXHUwMDAyXFx1MDYwMFxcdTA2MDFcXHgwN2VcdTAwMDJcdTAwMDJcXHUwNjAxXFx1MDYwMlxceDA3Y1x1MDAwMlx1MDAwMlxcdTA2MDJcXHUwNjAzXFx4MDd1XHUwMDAyXHUwMDAyXFx1MDYwM1xcdTA2NENcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNjA0XFx1MDYwNVxceDA3ZVx1MDAwMlx1MDAwMlxcdTA2MDVcXHUwNjA2XFx4MDdjXHUwMDAyXHUwMDAyXFx1MDYwNlxcdTA2MDdcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNjA3XFx1MDYwOFxceDA3ZVx1MDAwMlx1MDAwMlxcdTA2MDhcXHUwNjRDXFx4MDdqXHUwMDAyXHUwMDAyXFx1MDYwOVxcdTA2MEFcXHgwN2ZcdTAwMDJcdTAwMDJcXHUwNjBBXFx1MDYwQlxceDA3Z1x1MDAwMlx1MDAwMlxcdTA2MEJcXHUwNjBDXFx4MDdoXHUwMDAyXHUwMDAyXFx1MDYwQ1xcdTA2MERcXHgwN2NcdTAwMDJcdTAwMDJcXHUwNjBEXFx1MDYwRVxceDA3d1x1MDAwMlx1MDAwMlxcdTA2MEVcXHUwNjBGXFx4MDduXHUwMDAyXHUwMDAyXFx1MDYwRlxcdTA2NENcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNjEwXFx1MDYxMVxceDA3aFx1MDAwMlx1MDAwMlxcdTA2MTFcXHUwNjEyXFx4MDdrXHUwMDAyXHUwMDAyXFx1MDYxMlxcdTA2MTNcXHgwN3BcdTAwMDJcdTAwMDJcXHUwNjEzXFx1MDYxNFxceDA3Y1x1MDAwMlx1MDAwMlxcdTA2MTRcXHUwNjRDXFx4MDduXHUwMDAyXHUwMDAyXFx1MDYxNVxcdTA2MTZcXHgwN2tcdTAwMDJcdTAwMDJcXHUwNjE2XFx1MDY0Q1xceDA3cFx1MDAwMlx1MDAwMlxcdTA2MTdcXHUwNjE4XFx4MDdrXHUwMDAyXHUwMDAyXFx1MDYxOFxcdTA2MTlcXHgwN3BcdTAwMDJcdTAwMDJcXHUwNjE5XFx1MDYxQVxceDA3blx1MDAwMlx1MDAwMlxcdTA2MUFcXHUwNjFCXFx4MDdrXHUwMDAyXHUwMDAyXFx1MDYxQlxcdTA2MUNcXHgwN3BcdTAwMDJcdTAwMDJcXHUwNjFDXFx1MDY0Q1xceDA3Z1x1MDAwMlx1MDAwMlxcdTA2MURcXHUwNjFFXFx4MDduXHUwMDAyXHUwMDAyXFx1MDYxRVxcdTA2MUZcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNjFGXFx1MDY0Q1xceDA3dlx1MDAwMlx1MDAwMlxcdTA2MjBcXHUwNjIxXFx4MDdvXHUwMDAyXHUwMDAyXFx1MDYyMVxcdTA2MjJcXHgwN2NcdTAwMDJcdTAwMDJcXHUwNjIyXFx1MDYyM1xceDA3dlx1MDAwMlx1MDAwMlxcdTA2MjNcXHUwNjI0XFx4MDdlXHUwMDAyXHUwMDAyXFx1MDYyNFxcdTA2NENcXHgwN2pcdTAwMDJcdTAwMDJcXHUwNjI1XFx1MDYyNlxceDA3cFx1MDAwMlx1MDAwMlxcdTA2MjZcXHUwNjI3XFx4MDd3XHUwMDAyXHUwMDAyXFx1MDYyN1xcdTA2MjhcXHgwN25cdTAwMDJcdTAwMDJcXHUwNjI4XFx1MDY0Q1xceDA3blx1MDAwMlx1MDAwMlxcdTA2MjlcXHUwNjJBXFx4MDdxXHUwMDAyXHUwMDAyXFx1MDYyQVxcdTA2NENcXHgwN2hcdTAwMDJcdTAwMDJcXHUwNjJCXFx1MDYyQ1xceDA3dFx1MDAwMlx1MDAwMlxcdTA2MkNcXHUwNjJEXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDYyRFxcdTA2MkVcXHgwN25cdTAwMDJcdTAwMDJcXHUwNjJFXFx1MDYyRlxceDA3cVx1MDAwMlx1MDAwMlxcdTA2MkZcXHUwNjMwXFx4MDdlXHUwMDAyXHUwMDAyXFx1MDYzMFxcdTA2MzFcXHgwN2NcdTAwMDJcdTAwMDJcXHUwNjMxXFx1MDYzMlxceDA3dlx1MDAwMlx1MDAwMlxcdTA2MzJcXHUwNjMzXFx4MDdjXHUwMDAyXHUwMDAyXFx1MDYzM1xcdTA2MzRcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNjM0XFx1MDYzNVxceDA3blx1MDAwMlx1MDAwMlxcdTA2MzVcXHUwNjRDXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDYzNlxcdTA2MzdcXHgwN3VcdTAwMDJcdTAwMDJcXHUwNjM3XFx1MDYzOFxceDA3dlx1MDAwMlx1MDAwMlxcdTA2MzhcXHUwNjM5XFx4MDdjXHUwMDAyXHUwMDAyXFx1MDYzOVxcdTA2M0FcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNjNBXFx1MDYzQlxceDA3a1x1MDAwMlx1MDAwMlxcdTA2M0JcXHUwNjRDXFx4MDdlXHUwMDAyXHUwMDAyXFx1MDYzQ1xcdTA2M0RcXHgwN3VcdTAwMDJcdTAwMDJcXHUwNjNEXFx1MDYzRVxceDA3eVx1MDAwMlx1MDAwMlxcdTA2M0VcXHUwNjNGXFx4MDdrXHUwMDAyXHUwMDAyXFx1MDYzRlxcdTA2NDBcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNjQwXFx1MDY0MVxceDA3ZVx1MDAwMlx1MDAwMlxcdTA2NDFcXHUwNjRDXFx4MDdqXHUwMDAyXHUwMDAyXFx1MDY0MlxcdTA2NDNcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNjQzXFx1MDY0NFxceDA3dFx1MDAwMlx1MDAwMlxcdTA2NDRcXHUwNjRDXFx4MDd7XHUwMDAyXHUwMDAyXFx1MDY0NVxcdTA2NDZcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNjQ2XFx1MDY0N1xceDA3e1x1MDAwMlx1MDAwMlxcdTA2NDdcXHUwNjQ4XFx4MDdyXHUwMDAyXHUwMDAyXFx1MDY0OFxcdTA2NDlcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNjQ5XFx1MDY0QVxceDA3cVx1MDAwMlx1MDAwMlxcdTA2NEFcXHUwNjRDXFx4MDdoXHUwMDAyXHUwMDAyXFx1MDY0QlxcdTA1RjNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNjRCXFx1MDVGQlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA2NEJcXHUwNjAwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDY0QlxcdTA2MDRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNjRCXFx1MDYwOVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA2NEJcXHUwNjEwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDY0QlxcdTA2MTVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNjRCXFx1MDYxN1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA2NEJcXHUwNjFEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDY0QlxcdTA2MjBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNjRCXFx1MDYyNVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA2NEJcXHUwNjI5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDY0QlxcdTA2MkJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNjRCXFx1MDYzNlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA2NEJcXHUwNjNDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDY0QlxcdTA2NDJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNjRCXFx1MDY0NVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA2NENcXHhFMlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA2NERcXHUwNjRFXFx4MDdjXHUwMDAyXHUwMDAyXFx1MDY0RVxcdTA2NEZcXHgwN3BcdTAwMDJcdTAwMDJcXHUwNjRGXFx1MDY1MFxceDA3cVx1MDAwMlx1MDAwMlxcdTA2NTBcXHUwNjUxXFx4MDdwXHUwMDAyXHUwMDAyXFx1MDY1MVxcdTA2NTJcXHgwN3tcdTAwMDJcdTAwMDJcXHUwNjUyXFx1MDY1M1xceDA3b1x1MDAwMlx1MDAwMlxcdTA2NTNcXHUwNjU0XFx4MDdxXHUwMDAyXHUwMDAyXFx1MDY1NFxcdTA2NTVcXHgwN3dcdTAwMDJcdTAwMDJcXHUwNjU1XFx1MDY1NlxceDA3dVx1MDAwMlx1MDAwMlxcdTA2NTZcXHhFNFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA2NTdcXHUwNjU4XFx4MDdkXHUwMDAyXHUwMDAyXFx1MDY1OFxcdTA2NTlcXHgwN3RcdTAwMDJcdTAwMDJcXHUwNjU5XFx1MDY1QVxceDA3Z1x1MDAwMlx1MDAwMlxcdTA2NUFcXHUwNjVCXFx4MDdjXHUwMDAyXHUwMDAyXFx1MDY1QlxcdTA2NUNcXHgwN21cdTAwMDJcdTAwMDJcXHUwNjVDXFx4RTZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNjVEXFx1MDY1RVxceDA3ZVx1MDAwMlx1MDAwMlxcdTA2NUVcXHUwNjVGXFx4MDdxXHUwMDAyXHUwMDAyXFx1MDY1RlxcdTA2NjBcXHgwN3BcdTAwMDJcdTAwMDJcXHUwNjYwXFx1MDY2MVxceDA3dVx1MDAwMlx1MDAwMlxcdTA2NjFcXHUwNjYyXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDY2MlxcdTA2NjNcXHgwN2NcdTAwMDJcdTAwMDJcXHUwNjYzXFx1MDY2NFxceDA3cFx1MDAwMlx1MDAwMlxcdTA2NjRcXHUwNjY1XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDY2NVxceEU4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDY2NlxcdTA2NjdcXHgwN2tcdTAwMDJcdTAwMDJcXHUwNjY3XFx1MDY2OFxceDA3b1x1MDAwMlx1MDAwMlxcdTA2NjhcXHUwNjY5XFx4MDdvXHUwMDAyXHUwMDAyXFx1MDY2OVxcdTA2NkFcXHgwN3dcdTAwMDJcdTAwMDJcXHUwNjZBXFx1MDY2QlxceDA3dlx1MDAwMlx1MDAwMlxcdTA2NkJcXHUwNjZDXFx4MDdjXHUwMDAyXHUwMDAyXFx1MDY2Q1xcdTA2NkRcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNjZEXFx1MDY2RVxceDA3blx1MDAwMlx1MDAwMlxcdTA2NkVcXHUwNjZGXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDY2RlxceEVBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDY3MFxcdTA2NzFcXHgwN2VcdTAwMDJcdTAwMDJcXHUwNjcxXFx1MDY3MlxceDA3cVwiO1xuU29saWRpdHlMZXhlci5fc2VyaWFsaXplZEFUTlNlZ21lbnQzID0gXCJcdTAwMDJcdTAwMDJcXHUwNjcyXFx1MDY3M1xceDA3cFx1MDAwMlx1MDAwMlxcdTA2NzNcXHUwNjc0XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDY3NFxcdTA2NzVcXHgwN2tcdTAwMDJcdTAwMDJcXHUwNjc1XFx1MDY3NlxceDA3cFx1MDAwMlx1MDAwMlxcdTA2NzZcXHUwNjc3XFx4MDd3XHUwMDAyXHUwMDAyXFx1MDY3N1xcdTA2NzhcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNjc4XFx4RUNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNjc5XFx1MDY3QVxceDA3blx1MDAwMlx1MDAwMlxcdTA2N0FcXHUwNjdCXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDY3QlxcdTA2N0NcXHgwN2NcdTAwMDJcdTAwMDJcXHUwNjdDXFx1MDY3RFxceDA3eFx1MDAwMlx1MDAwMlxcdTA2N0RcXHUwNjdFXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDY3RVxceEVFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDY3RlxcdTA2ODBcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNjgwXFx1MDY4MVxceDA3elx1MDAwMlx1MDAwMlxcdTA2ODFcXHUwNjgyXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDY4MlxcdTA2ODNcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNjgzXFx1MDY4NFxceDA3dFx1MDAwMlx1MDAwMlxcdTA2ODRcXHUwNjg1XFx4MDdwXHUwMDAyXHUwMDAyXFx1MDY4NVxcdTA2ODZcXHgwN2NcdTAwMDJcdTAwMDJcXHUwNjg2XFx1MDY4N1xceDA3blx1MDAwMlx1MDAwMlxcdTA2ODdcXHhGMFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA2ODhcXHUwNjg5XFx4MDdrXHUwMDAyXHUwMDAyXFx1MDY4OVxcdTA2OEFcXHgwN3BcdTAwMDJcdTAwMDJcXHUwNjhBXFx1MDY4QlxceDA3Zlx1MDAwMlx1MDAwMlxcdTA2OEJcXHUwNjhDXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDY4Q1xcdTA2OERcXHgwN3pcdTAwMDJcdTAwMDJcXHUwNjhEXFx1MDY4RVxceDA3Z1x1MDAwMlx1MDAwMlxcdTA2OEVcXHUwNjhGXFx4MDdmXHUwMDAyXHUwMDAyXFx1MDY4RlxceEYyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDY5MFxcdTA2OTFcXHgwN2tcdTAwMDJcdTAwMDJcXHUwNjkxXFx1MDY5MlxceDA3cFx1MDAwMlx1MDAwMlxcdTA2OTJcXHUwNjkzXFx4MDd2XHUwMDAyXHUwMDAyXFx1MDY5M1xcdTA2OTRcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNjk0XFx1MDY5NVxceDA3dFx1MDAwMlx1MDAwMlxcdTA2OTVcXHUwNjk2XFx4MDdwXHUwMDAyXHUwMDAyXFx1MDY5NlxcdTA2OTdcXHgwN2NcdTAwMDJcdTAwMDJcXHUwNjk3XFx1MDY5OFxceDA3blx1MDAwMlx1MDAwMlxcdTA2OThcXHhGNFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA2OTlcXHUwNjlBXFx4MDdyXHUwMDAyXHUwMDAyXFx1MDY5QVxcdTA2OUJcXHgwN2NcdTAwMDJcdTAwMDJcXHUwNjlCXFx1MDY5Q1xceDA3e1x1MDAwMlx1MDAwMlxcdTA2OUNcXHUwNjlEXFx4MDdjXHUwMDAyXHUwMDAyXFx1MDY5RFxcdTA2OUVcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNjlFXFx1MDY5RlxceDA3blx1MDAwMlx1MDAwMlxcdTA2OUZcXHUwNkEwXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDZBMFxceEY2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDZBMVxcdTA2QTJcXHgwN3JcdTAwMDJcdTAwMDJcXHUwNkEyXFx1MDZBM1xceDA3dFx1MDAwMlx1MDAwMlxcdTA2QTNcXHUwNkE0XFx4MDdrXHUwMDAyXHUwMDAyXFx1MDZBNFxcdTA2QTVcXHgwN3hcdTAwMDJcdTAwMDJcXHUwNkE1XFx1MDZBNlxceDA3Y1x1MDAwMlx1MDAwMlxcdTA2QTZcXHUwNkE3XFx4MDd2XHUwMDAyXHUwMDAyXFx1MDZBN1xcdTA2QThcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNkE4XFx4RjhcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNkE5XFx1MDZBQVxceDA3clx1MDAwMlx1MDAwMlxcdTA2QUFcXHUwNkFCXFx4MDd3XHUwMDAyXHUwMDAyXFx1MDZBQlxcdTA2QUNcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNkFDXFx1MDZBRFxceDA3blx1MDAwMlx1MDAwMlxcdTA2QURcXHUwNkFFXFx4MDdrXHUwMDAyXHUwMDAyXFx1MDZBRVxcdTA2QUZcXHgwN2VcdTAwMDJcdTAwMDJcXHUwNkFGXFx4RkFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNkIwXFx1MDZCMVxceDA3eFx1MDAwMlx1MDAwMlxcdTA2QjFcXHUwNkIyXFx4MDdrXHUwMDAyXHUwMDAyXFx1MDZCMlxcdTA2QjNcXHgwN3RcdTAwMDJcdTAwMDJcXHUwNkIzXFx1MDZCNFxceDA3dlx1MDAwMlx1MDAwMlxcdTA2QjRcXHUwNkI1XFx4MDd3XHUwMDAyXHUwMDAyXFx1MDZCNVxcdTA2QjZcXHgwN2NcdTAwMDJcdTAwMDJcXHUwNkI2XFx1MDZCN1xceDA3blx1MDAwMlx1MDAwMlxcdTA2QjdcXHhGQ1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA2QjhcXHUwNkI5XFx4MDdyXHUwMDAyXHUwMDAyXFx1MDZCOVxcdTA2QkFcXHgwN3dcdTAwMDJcdTAwMDJcXHUwNkJBXFx1MDZCQlxceDA3dFx1MDAwMlx1MDAwMlxcdTA2QkJcXHUwNkJDXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDZCQ1xceEZFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDZCRFxcdTA2QkVcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNkJFXFx1MDZCRlxceDA3e1x1MDAwMlx1MDAwMlxcdTA2QkZcXHUwNkMwXFx4MDdyXHUwMDAyXHUwMDAyXFx1MDZDMFxcdTA2QzFcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNkMxXFx1MDEwMFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA2QzJcXHUwNkMzXFx4MDd4XHUwMDAyXHUwMDAyXFx1MDZDM1xcdTA2QzRcXHgwN2tcdTAwMDJcdTAwMDJcXHUwNkM0XFx1MDZDNVxceDA3Z1x1MDAwMlx1MDAwMlxcdTA2QzVcXHUwNkM2XFx4MDd5XHUwMDAyXHUwMDAyXFx1MDZDNlxcdTAxMDJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNkM3XFx1MDZDOFxceDA3aVx1MDAwMlx1MDAwMlxcdTA2QzhcXHUwNkM5XFx4MDduXHUwMDAyXHUwMDAyXFx1MDZDOVxcdTA2Q0FcXHgwN3FcdTAwMDJcdTAwMDJcXHUwNkNBXFx1MDZDQlxceDA3ZFx1MDAwMlx1MDAwMlxcdTA2Q0JcXHUwNkNDXFx4MDdjXHUwMDAyXHUwMDAyXFx1MDZDQ1xcdTA2Q0RcXHgwN25cdTAwMDJcdTAwMDJcXHUwNkNEXFx1MDEwNFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA2Q0VcXHUwNkNGXFx4MDdlXHUwMDAyXHUwMDAyXFx1MDZDRlxcdTA2RDBcXHgwN3FcdTAwMDJcdTAwMDJcXHUwNkQwXFx1MDZEMVxceDA3cFx1MDAwMlx1MDAwMlxcdTA2RDFcXHUwNkQyXFx4MDd1XHUwMDAyXHUwMDAyXFx1MDZEMlxcdTA2RDNcXHgwN3ZcdTAwMDJcdTAwMDJcXHUwNkQzXFx1MDZENFxceDA3dFx1MDAwMlx1MDAwMlxcdTA2RDRcXHUwNkQ1XFx4MDd3XHUwMDAyXHUwMDAyXFx1MDZENVxcdTA2RDZcXHgwN2VcdTAwMDJcdTAwMDJcXHUwNkQ2XFx1MDZEN1xceDA3dlx1MDAwMlx1MDAwMlxcdTA2RDdcXHUwNkQ4XFx4MDdxXHUwMDAyXHUwMDAyXFx1MDZEOFxcdTA2RDlcXHgwN3RcdTAwMDJcdTAwMDJcXHUwNkQ5XFx1MDEwNlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA2REFcXHUwNkRCXFx4MDdoXHUwMDAyXHUwMDAyXFx1MDZEQlxcdTA2RENcXHgwN2NcdTAwMDJcdTAwMDJcXHUwNkRDXFx1MDZERFxceDA3blx1MDAwMlx1MDAwMlxcdTA2RERcXHUwNkRFXFx4MDduXHUwMDAyXHUwMDAyXFx1MDZERVxcdTA2REZcXHgwN2RcdTAwMDJcdTAwMDJcXHUwNkRGXFx1MDZFMFxceDA3Y1x1MDAwMlx1MDAwMlxcdTA2RTBcXHUwNkUxXFx4MDdlXHUwMDAyXHUwMDAyXFx1MDZFMVxcdTA2RTJcXHgwN21cdTAwMDJcdTAwMDJcXHUwNkUyXFx1MDEwOFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA2RTNcXHUwNkU0XFx4MDd0XHUwMDAyXHUwMDAyXFx1MDZFNFxcdTA2RTVcXHgwN2dcdTAwMDJcdTAwMDJcXHUwNkU1XFx1MDZFNlxceDA3ZVx1MDAwMlx1MDAwMlxcdTA2RTZcXHUwNkU3XFx4MDdnXHUwMDAyXHUwMDAyXFx1MDZFN1xcdTA2RThcXHgwN2tcdTAwMDJcdTAwMDJcXHUwNkU4XFx1MDZFOVxceDA3eFx1MDAwMlx1MDAwMlxcdTA2RTlcXHUwNkVBXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDZFQVxcdTAxMEFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNkVCXFx1MDZFRlx1MDAwNVxcdTAxMERcXHg4N1x1MDAwMlxcdTA2RUNcXHUwNkVFXHUwMDA1XFx1MDEwRlxceDg4XHUwMDAyXFx1MDZFRFxcdTA2RUNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNkVFXFx1MDZGMVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA2RUZcXHUwNkVEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDZFRlxcdTA2RjBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNkYwXFx1MDEwQ1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA2RjFcXHUwNkVGXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDZGMlxcdTA2RjNcdFx1MDAwNlx1MDAwMlx1MDAwMlxcdTA2RjNcXHUwMTBFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDZGNFxcdTA2RjVcdFxceDA3XHUwMDAyXHUwMDAyXFx1MDZGNVxcdTAxMTBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNkY2XFx1MDZGN1xceDA3d1x1MDAwMlx1MDAwMlxcdTA2RjdcXHUwNkY4XFx4MDdwXHUwMDAyXHUwMDAyXFx1MDZGOFxcdTA2RjlcXHgwN2tcdTAwMDJcdTAwMDJcXHUwNkY5XFx1MDZGQVxceDA3ZVx1MDAwMlx1MDAwMlxcdTA2RkFcXHUwNkZCXFx4MDdxXHUwMDAyXHUwMDAyXFx1MDZGQlxcdTA2RkNcXHgwN2ZcdTAwMDJcdTAwMDJcXHUwNkZDXFx1MDZGRVxceDA3Z1x1MDAwMlx1MDAwMlxcdTA2RkRcXHUwNkY2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDZGRFxcdTA2RkVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNkZFXFx1MDZGRlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA2RkZcXHUwNzAzXFx4MDckXHUwMDAyXHUwMDAyXFx1MDcwMFxcdTA3MDJcdTAwMDVcXHUwMTEzXFx4OEFcdTAwMDJcXHUwNzAxXFx1MDcwMFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA3MDJcXHUwNzA1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDcwM1xcdTA3MDFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzAzXFx1MDcwNFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA3MDRcXHUwNzA2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDcwNVxcdTA3MDNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzA2XFx1MDcxOVxceDA3JFx1MDAwMlx1MDAwMlxcdTA3MDdcXHUwNzA4XFx4MDd3XHUwMDAyXHUwMDAyXFx1MDcwOFxcdTA3MDlcXHgwN3BcdTAwMDJcdTAwMDJcXHUwNzA5XFx1MDcwQVxceDA3a1x1MDAwMlx1MDAwMlxcdTA3MEFcXHUwNzBCXFx4MDdlXHUwMDAyXHUwMDAyXFx1MDcwQlxcdTA3MENcXHgwN3FcdTAwMDJcdTAwMDJcXHUwNzBDXFx1MDcwRFxceDA3Zlx1MDAwMlx1MDAwMlxcdTA3MERcXHUwNzBGXFx4MDdnXHUwMDAyXHUwMDAyXFx1MDcwRVxcdTA3MDdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzBFXFx1MDcwRlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA3MEZcXHUwNzEwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDcxMFxcdTA3MTRcXHgwNylcdTAwMDJcdTAwMDJcXHUwNzExXFx1MDcxM1x1MDAwNVxcdTAxMTVcXHg4Qlx1MDAwMlxcdTA3MTJcXHUwNzExXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDcxM1xcdTA3MTZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzE0XFx1MDcxMlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA3MTRcXHUwNzE1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDcxNVxcdTA3MTdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzE2XFx1MDcxNFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA3MTdcXHUwNzE5XFx4MDcpXHUwMDAyXHUwMDAyXFx1MDcxOFxcdTA2RkRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzE4XFx1MDcwRVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA3MTlcXHUwMTEyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDcxQVxcdTA3MUVcXG5cXGJcdTAwMDJcdTAwMDJcXHUwNzFCXFx1MDcxQ1xceDA3Xlx1MDAwMlx1MDAwMlxcdTA3MUNcXHUwNzFFXFx2XHUwMDAyXHUwMDAyXHUwMDAyXFx1MDcxRFxcdTA3MUFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzFEXFx1MDcxQlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA3MUVcXHUwMTE0XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDcxRlxcdTA3MjNcXG5cdFx1MDAwMlx1MDAwMlxcdTA3MjBcXHUwNzIxXFx4MDdeXHUwMDAyXHUwMDAyXFx1MDcyMVxcdTA3MjNcXHZcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzIyXFx1MDcxRlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA3MjJcXHUwNzIwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDcyM1xcdTAxMTZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzI0XFx1MDcyNlx0XHUwMDAyXHUwMDAyXHUwMDAyXFx1MDcyNVxcdTA3MjRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzI2XFx1MDcyN1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA3MjdcXHUwNzI1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDcyN1xcdTA3MjhcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzI4XFx1MDcyOVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA3MjlcXHUwNzJCXFx4MDcwXHUwMDAyXHUwMDAyXFx1MDcyQVxcdTA3MkNcdFx1MDAwMlx1MDAwMlx1MDAwMlxcdTA3MkJcXHUwNzJBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDcyQ1xcdTA3MkRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzJEXFx1MDcyQlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA3MkRcXHUwNzJFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDcyRVxcdTA3MzVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzJGXFx1MDczMVxceDA3MFx1MDAwMlx1MDAwMlxcdTA3MzBcXHUwNzMyXHRcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzMxXFx1MDczMFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA3MzJcXHUwNzMzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDczM1xcdTA3MzFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzMzXFx1MDczNFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA3MzRcXHUwNzM2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDczNVxcdTA3MkZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzM1XFx1MDczNlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA3MzZcXHUwMTE4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDczN1xcdTA3MzlcdFxcblx1MDAwMlx1MDAwMlxcdTA3MzhcXHUwNzM3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDczOVxcdTA3M0FcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzNBXFx1MDczOFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA3M0FcXHUwNzNCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDczQlxcdTA3M0NcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzNDXFx1MDczRFxcYlxceDhEXHUwMDAyXHUwMDAyXFx1MDczRFxcdTAxMUFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzNFXFx1MDczRlxceDA3MVx1MDAwMlx1MDAwMlxcdTA3M0ZcXHUwNzQwXFx4MDcsXHUwMDAyXHUwMDAyXFx1MDc0MFxcdTA3NDRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzQxXFx1MDc0M1xcdlx1MDAwMlx1MDAwMlx1MDAwMlxcdTA3NDJcXHUwNzQxXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDc0M1xcdTA3NDZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzQ0XFx1MDc0NVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA3NDRcXHUwNzQyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDc0NVxcdTA3NDdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzQ2XFx1MDc0NFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA3NDdcXHUwNzQ4XFx4MDcsXHUwMDAyXHUwMDAyXFx1MDc0OFxcdTA3NDlcXHgwNzFcdTAwMDJcdTAwMDJcXHUwNzQ5XFx1MDc0QVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA3NEFcXHUwNzRCXFxiXFx4OEVcdTAwMDNcdTAwMDJcXHUwNzRCXFx1MDExQ1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA3NENcXHUwNzREXFx4MDcxXHUwMDAyXHUwMDAyXFx1MDc0RFxcdTA3NEVcXHgwNzFcdTAwMDJcdTAwMDJcXHUwNzRFXFx1MDc1Mlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA3NEZcXHUwNzUxXFxuXFx2XHUwMDAyXHUwMDAyXFx1MDc1MFxcdTA3NEZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzUxXFx1MDc1NFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA3NTJcXHUwNzUwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDc1MlxcdTA3NTNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNzUzXFx1MDc1NVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA3NTRcXHUwNzUyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDc1NVxcdTA3NTZcXGJcXHg4Rlx1MDAwM1x1MDAwMlxcdTA3NTZcXHUwMTFFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyKFx1MDAwMlxcdTAzOEFcXHUwNDYzXFx1MDU0MVxcdTA1NTFcXHUwNTU3XFx1MDU1OVxcdTA1NkJcXHUwNTcxXFx1MDU3M1xcdTA1N0VcXHUwNTgyXFx1MDU4NlxcdTA1OEFcXHUwNThFXFx1MDU5M1xcdTA1OUNcXHUwNUExXFx1MDVEQ1xcdTA1RTRcXHUwNUU5XFx1MDVFQ1xcdTA2NEJcXHUwNkVGXFx1MDZGRFxcdTA3MDNcXHUwNzBFXFx1MDcxNFxcdTA3MThcXHUwNzFEXFx1MDcyMlxcdTA3MjdcXHUwNzJEXFx1MDczM1xcdTA3MzVcXHUwNzNBXFx1MDc0NFxcdTA3NTJcdTAwMDRcXGJcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDNcdTAwMDJcIjtcblNvbGlkaXR5TGV4ZXIuX3NlcmlhbGl6ZWRBVE4gPSBVdGlscy5qb2luKFtcbiAgX1NvbGlkaXR5TGV4ZXIuX3NlcmlhbGl6ZWRBVE5TZWdtZW50MCxcbiAgX1NvbGlkaXR5TGV4ZXIuX3NlcmlhbGl6ZWRBVE5TZWdtZW50MSxcbiAgX1NvbGlkaXR5TGV4ZXIuX3NlcmlhbGl6ZWRBVE5TZWdtZW50MixcbiAgX1NvbGlkaXR5TGV4ZXIuX3NlcmlhbGl6ZWRBVE5TZWdtZW50M1xuXSwgXCJcIik7XG5cbi8vIHNyYy9hbnRsci9Tb2xpZGl0eVBhcnNlci50c1xudmFyIGltcG9ydF9BVE4gPSBfX3RvTW9kdWxlKHJlcXVpcmVfQVROKCkpO1xudmFyIGltcG9ydF9BVE5EZXNlcmlhbGl6ZXIyID0gX190b01vZHVsZShyZXF1aXJlX0FUTkRlc2VyaWFsaXplcigpKTtcbnZhciBpbXBvcnRfRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uID0gX190b01vZHVsZShyZXF1aXJlX0ZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbigpKTtcbnZhciBpbXBvcnRfTm9WaWFibGVBbHRFeGNlcHRpb24gPSBfX3RvTW9kdWxlKHJlcXVpcmVfTm9WaWFibGVBbHRFeGNlcHRpb24oKSk7XG52YXIgaW1wb3J0X1BhcnNlciA9IF9fdG9Nb2R1bGUocmVxdWlyZV9QYXJzZXIoKSk7XG52YXIgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0ID0gX190b01vZHVsZShyZXF1aXJlX1BhcnNlclJ1bGVDb250ZXh0KCkpO1xudmFyIGltcG9ydF9QYXJzZXJBVE5TaW11bGF0b3IgPSBfX3RvTW9kdWxlKHJlcXVpcmVfUGFyc2VyQVROU2ltdWxhdG9yKCkpO1xudmFyIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbiA9IF9fdG9Nb2R1bGUocmVxdWlyZV9SZWNvZ25pdGlvbkV4Y2VwdGlvbigpKTtcbnZhciBpbXBvcnRfVG9rZW4gPSBfX3RvTW9kdWxlKHJlcXVpcmVfVG9rZW4oKSk7XG52YXIgaW1wb3J0X1ZvY2FidWxhcnlJbXBsMiA9IF9fdG9Nb2R1bGUocmVxdWlyZV9Wb2NhYnVsYXJ5SW1wbCgpKTtcbnZhciBVdGlsczIgPSBfX3RvTW9kdWxlKHJlcXVpcmVfVXRpbHMoKSk7XG52YXIgX1NvbGlkaXR5UGFyc2VyID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyLlBhcnNlciB7XG4gIGdldCB2b2NhYnVsYXJ5KCkge1xuICAgIHJldHVybiBfU29saWRpdHlQYXJzZXIuVk9DQUJVTEFSWTtcbiAgfVxuICBnZXQgZ3JhbW1hckZpbGVOYW1lKCkge1xuICAgIHJldHVybiBcIlNvbGlkaXR5Lmc0XCI7XG4gIH1cbiAgZ2V0IHJ1bGVOYW1lcygpIHtcbiAgICByZXR1cm4gX1NvbGlkaXR5UGFyc2VyLnJ1bGVOYW1lcztcbiAgfVxuICBnZXQgc2VyaWFsaXplZEFUTigpIHtcbiAgICByZXR1cm4gX1NvbGlkaXR5UGFyc2VyLl9zZXJpYWxpemVkQVROO1xuICB9XG4gIGNyZWF0ZUZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbihwcmVkaWNhdGUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IGltcG9ydF9GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24uRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKHRoaXMsIHByZWRpY2F0ZSwgbWVzc2FnZSk7XG4gIH1cbiAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICBzdXBlcihpbnB1dCk7XG4gICAgdGhpcy5faW50ZXJwID0gbmV3IGltcG9ydF9QYXJzZXJBVE5TaW11bGF0b3IuUGFyc2VyQVROU2ltdWxhdG9yKF9Tb2xpZGl0eVBhcnNlci5fQVROLCB0aGlzKTtcbiAgfVxuICBzb3VyY2VVbml0KCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgU291cmNlVW5pdENvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDAsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX3NvdXJjZVVuaXQpO1xuICAgIGxldCBfbGE7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gMjA4O1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICB3aGlsZSAoKF9sYSAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzAgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18xMiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzEzIHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMTcgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18xOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzE5IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjAgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18yNCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzI1IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjcgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18yOSkpICE9PSAwIHx8IChfbGEgLSAzMyAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gMzMgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzIgLSAzMyB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzM1IC0gMzMgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zNyAtIDMzIHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNDEgLSAzMyB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzUzIC0gMzMgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NCAtIDMzIHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTUgLSAzMyB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU2IC0gMzMgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NyAtIDMzKSkgIT09IDAgfHwgKF9sYSAtIDk2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSA5NiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX185NSAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuSW50IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5VaW50IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5CeXRlIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5GaXhlZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVWZpeGVkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UeXBlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQ29uc3RydWN0b3JLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5GYWxsYmFja0tleXdvcmQgLSA5NikpICE9PSAwIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlJlY2VpdmVLZXl3b3JkIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLklkZW50aWZpZXIpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjA2O1xuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmludGVycHJldGVyLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwgMCwgdGhpcy5fY3R4KSkge1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDE5NjtcbiAgICAgICAgICAgICAgICAgIHRoaXMucHJhZ21hRGlyZWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDE5NztcbiAgICAgICAgICAgICAgICAgIHRoaXMuaW1wb3J0RGlyZWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDE5ODtcbiAgICAgICAgICAgICAgICAgIHRoaXMuY29udHJhY3REZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDE5OTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZW51bURlZmluaXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMjAwO1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdHJ1Y3REZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDIwMTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZnVuY3Rpb25EZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDIwMjtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZmlsZUxldmVsQ29uc3RhbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMjAzO1xuICAgICAgICAgICAgICAgICAgdGhpcy5jdXN0b21FcnJvckRlZmluaXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMjA0O1xuICAgICAgICAgICAgICAgICAgdGhpcy50eXBlRGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMjA1O1xuICAgICAgICAgICAgICAgICAgdGhpcy51c2luZ0ZvckRlY2xhcmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YXRlID0gMjEwO1xuICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gMjExO1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5FT0YpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgcHJhZ21hRGlyZWN0aXZlKCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgUHJhZ21hRGlyZWN0aXZlQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMiwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfcHJhZ21hRGlyZWN0aXZlKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAyMTM7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzApO1xuICAgICAgICB0aGlzLnN0YXRlID0gMjE0O1xuICAgICAgICB0aGlzLnByYWdtYU5hbWUoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDIxNTtcbiAgICAgICAgdGhpcy5wcmFnbWFWYWx1ZSgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gMjE2O1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIHByYWdtYU5hbWUoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBQcmFnbWFOYW1lQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgNCwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfcHJhZ21hTmFtZSk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gMjE4O1xuICAgICAgICB0aGlzLmlkZW50aWZpZXIoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIHByYWdtYVZhbHVlKCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgUHJhZ21hVmFsdWVDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCA2LCBfU29saWRpdHlQYXJzZXIuUlVMRV9wcmFnbWFWYWx1ZSk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc3RhdGUgPSAyMjM7XG4gICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICBzd2l0Y2ggKHRoaXMuaW50ZXJwcmV0ZXIuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LCAyLCB0aGlzLl9jdHgpKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjIwO1xuICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMik7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDIyMTtcbiAgICAgICAgICAgIHRoaXMudmVyc2lvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDMpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyMjI7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgdmVyc2lvbigpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IFZlcnNpb25Db250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCA4LCBfU29saWRpdHlQYXJzZXIuUlVMRV92ZXJzaW9uKTtcbiAgICBsZXQgX2xhO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDIyNTtcbiAgICAgICAgdGhpcy52ZXJzaW9uQ29uc3RyYWludCgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gMjMyO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICB3aGlsZSAoKF9sYSAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzMgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX180IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNSB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX183IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzkgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18xMCkpICE9PSAwIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLkRlY2ltYWxOdW1iZXIgfHwgX2xhID09PSBfU29saWRpdHlQYXJzZXIuVmVyc2lvbkxpdGVyYWwpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyMjc7XG4gICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgICAgICAgIGlmIChfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX18zKSB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDIyNjtcbiAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMjI5O1xuICAgICAgICAgICAgICB0aGlzLnZlcnNpb25Db25zdHJhaW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhdGUgPSAyMzQ7XG4gICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICB2ZXJzaW9uT3BlcmF0b3IoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBWZXJzaW9uT3BlcmF0b3JDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAxMCwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfdmVyc2lvbk9wZXJhdG9yKTtcbiAgICBsZXQgX2xhO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDIzNTtcbiAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIGlmICghKChfbGEgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX180IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNSB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX183IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzkgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18xMCkpICE9PSAwKSkge1xuICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3ZlcklubGluZSh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5faW5wdXQuTEEoMSkgPT09IGltcG9ydF9Ub2tlbi5Ub2tlbi5FT0YpIHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlZEVPRiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIHZlcnNpb25Db25zdHJhaW50KCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgVmVyc2lvbkNvbnN0cmFpbnRDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAxMiwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfdmVyc2lvbkNvbnN0cmFpbnQpO1xuICAgIGxldCBfbGE7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc3RhdGUgPSAyNDU7XG4gICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICBzd2l0Y2ggKHRoaXMuaW50ZXJwcmV0ZXIuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LCA3LCB0aGlzLl9jdHgpKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjM4O1xuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgICAgICBpZiAoKF9sYSAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzQgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzcgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX184IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fOSB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzEwKSkgIT09IDApIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyMzc7XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJzaW9uT3BlcmF0b3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI0MDtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlZlcnNpb25MaXRlcmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAyKTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjQyO1xuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgICAgICBpZiAoKF9sYSAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzQgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzcgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX184IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fOSB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzEwKSkgIT09IDApIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNDE7XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJzaW9uT3BlcmF0b3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI0NDtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLkRlY2ltYWxOdW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIGltcG9ydERlY2xhcmF0aW9uKCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgSW1wb3J0RGVjbGFyYXRpb25Db250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAxNCwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfaW1wb3J0RGVjbGFyYXRpb24pO1xuICAgIGxldCBfbGE7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gMjQ3O1xuICAgICAgICB0aGlzLmlkZW50aWZpZXIoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDI1MDtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgaWYgKF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlRfXzExKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI0ODtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzExKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNDk7XG4gICAgICAgICAgICB0aGlzLmlkZW50aWZpZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIGltcG9ydERpcmVjdGl2ZSgpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IEltcG9ydERpcmVjdGl2ZUNvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDE2LCBfU29saWRpdHlQYXJzZXIuUlVMRV9pbXBvcnREaXJlY3RpdmUpO1xuICAgIGxldCBfbGE7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc3RhdGUgPSAyODg7XG4gICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICBzd2l0Y2ggKHRoaXMuaW50ZXJwcmV0ZXIuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LCAxMywgdGhpcy5fY3R4KSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI1MjtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzEyKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNTM7XG4gICAgICAgICAgICB0aGlzLmltcG9ydFBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNTY7XG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgICAgIGlmIChfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX18xMSkge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI1NDtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI1NTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI1ODtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDIpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNjA7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xMik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjYzO1xuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9pbnB1dC5MQSgxKSkge1xuICAgICAgICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5UX18yOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNjE7XG4gICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzEzOlxuICAgICAgICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5UX18yNDpcbiAgICAgICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fMzU6XG4gICAgICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzQxOlxuICAgICAgICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5UX181MzpcbiAgICAgICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fOTU6XG4gICAgICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkxlYXZlS2V5d29yZDpcbiAgICAgICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuUGF5YWJsZUtleXdvcmQ6XG4gICAgICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkNvbnN0cnVjdG9yS2V5d29yZDpcbiAgICAgICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuUmVjZWl2ZUtleXdvcmQ6XG4gICAgICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLklkZW50aWZpZXI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI2MjtcbiAgICAgICAgICAgICAgICAgIHRoaXMuaWRlbnRpZmllcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgaW1wb3J0X05vVmlhYmxlQWx0RXhjZXB0aW9uLk5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI2NztcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgaWYgKF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlRfXzExKSB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMjY1O1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzExKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMjY2O1xuICAgICAgICAgICAgICAgIHRoaXMuaWRlbnRpZmllcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjY5O1xuICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMTMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI3MDtcbiAgICAgICAgICAgIHRoaXMuaW1wb3J0UGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI3MTtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDMpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNzM7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xMik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjc0O1xuICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMTQpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI3NTtcbiAgICAgICAgICAgIHRoaXMuaW1wb3J0RGVjbGFyYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyODA7XG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgICAgIHdoaWxlIChfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX18xNSkge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI3NjtcbiAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzE1KTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNzc7XG4gICAgICAgICAgICAgICAgICB0aGlzLmltcG9ydERlY2xhcmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyODI7XG4gICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjgzO1xuICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMTYpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI4NDtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzEzKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyODU7XG4gICAgICAgICAgICB0aGlzLmltcG9ydFBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyODY7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBpbXBvcnRQYXRoKCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgSW1wb3J0UGF0aENvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDE4LCBfU29saWRpdHlQYXJzZXIuUlVMRV9pbXBvcnRQYXRoKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAyOTA7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlN0cmluZ0xpdGVyYWxGcmFnbWVudCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBjb250cmFjdERlZmluaXRpb24oKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBDb250cmFjdERlZmluaXRpb25Db250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAyMCwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfY29udHJhY3REZWZpbml0aW9uKTtcbiAgICBsZXQgX2xhO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDI5MztcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgaWYgKF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlRfXzE3KSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI5MjtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzE3KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IDI5NTtcbiAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIGlmICghKChfbGEgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18xOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzE5IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjApKSAhPT0gMCkpIHtcbiAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2lucHV0LkxBKDEpID09PSBpbXBvcnRfVG9rZW4uVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoZWRFT0YgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSAyOTY7XG4gICAgICAgIHRoaXMuaWRlbnRpZmllcigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gMzA2O1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICBpZiAoX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fMjEpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjk3O1xuICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMjEpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI5ODtcbiAgICAgICAgICAgIHRoaXMuaW5oZXJpdGFuY2VTcGVjaWZpZXIoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzMDM7XG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgICAgIHdoaWxlIChfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX18xNSkge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI5OTtcbiAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzE1KTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzMDA7XG4gICAgICAgICAgICAgICAgICB0aGlzLmluaGVyaXRhbmNlU3BlY2lmaWVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzMDU7XG4gICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSAzMDg7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzE0KTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDMxMjtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgd2hpbGUgKChfbGEgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18xMyB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzI0IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjUgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18yNyB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzI4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjkpKSAhPT0gMCB8fCAoX2xhIC0gMzIgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDMyICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzMxIC0gMzIgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zMiAtIDMyIHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzUgLSAzMiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzM3IC0gMzIgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX180MSAtIDMyIHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTMgLSAzMiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU0IC0gMzIgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NSAtIDMyIHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTYgLSAzMiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU3IC0gMzIpKSAhPT0gMCB8fCAoX2xhIC0gOTYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDk2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzk1IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5JbnQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlVpbnQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkJ5dGUgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkZpeGVkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5VZml4ZWQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkxlYXZlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuUGF5YWJsZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlR5cGVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5Db25zdHJ1Y3RvcktleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkZhbGxiYWNrS2V5d29yZCAtIDk2KSkgIT09IDAgfHwgX2xhID09PSBfU29saWRpdHlQYXJzZXIuUmVjZWl2ZUtleXdvcmQgfHwgX2xhID09PSBfU29saWRpdHlQYXJzZXIuSWRlbnRpZmllcikge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMwOTtcbiAgICAgICAgICAgICAgdGhpcy5jb250cmFjdFBhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IDMxNDtcbiAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IDMxNTtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMTYpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgaW5oZXJpdGFuY2VTcGVjaWZpZXIoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBJbmhlcml0YW5jZVNwZWNpZmllckNvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDIyLCBfU29saWRpdHlQYXJzZXIuUlVMRV9pbmhlcml0YW5jZVNwZWNpZmllcik7XG4gICAgbGV0IF9sYTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAzMTc7XG4gICAgICAgIHRoaXMudXNlckRlZmluZWRUeXBlTmFtZSgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gMzIzO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICBpZiAoX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fMjIpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzE4O1xuICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMjIpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMyMDtcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgaWYgKChfbGEgLSA2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSA2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzUgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMTMgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjIgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjQgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjkgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzMgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzUgLSA2KSkgIT09IDAgfHwgKF9sYSAtIDM4ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSAzOCAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zNyAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNDEgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzUzIC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NCAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTUgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU2IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NyAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTggLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU5IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182MCAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjIgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzYzIC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182NCAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjUgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzY2IC0gMzgpKSAhPT0gMCB8fCAoX2xhIC0gOTYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDk2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzk1IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5JbnQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlVpbnQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkJ5dGUgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkZpeGVkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5VZml4ZWQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkJvb2xlYW5MaXRlcmFsIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5EZWNpbWFsTnVtYmVyIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5IZXhOdW1iZXIgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkhleExpdGVyYWxGcmFnbWVudCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuTGVhdmVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5QYXlhYmxlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVHlwZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkNvbnN0cnVjdG9yS2V5d29yZCAtIDk2KSkgIT09IDAgfHwgKF9sYSAtIDEyOCAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gMTI4ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlJlY2VpdmVLZXl3b3JkIC0gMTI4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuSWRlbnRpZmllciAtIDEyOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlN0cmluZ0xpdGVyYWxGcmFnbWVudCAtIDEyOCkpICE9PSAwKSB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMzE5O1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbkxpc3QoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMyMjtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzIzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIGNvbnRyYWN0UGFydCgpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IENvbnRyYWN0UGFydENvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDI0LCBfU29saWRpdHlQYXJzZXIuUlVMRV9jb250cmFjdFBhcnQpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnN0YXRlID0gMzM0O1xuICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgc3dpdGNoICh0aGlzLmludGVycHJldGVyLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwgMjAsIHRoaXMuX2N0eCkpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzMjU7XG4gICAgICAgICAgICB0aGlzLnN0YXRlVmFyaWFibGVEZWNsYXJhdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDIpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzMjY7XG4gICAgICAgICAgICB0aGlzLnVzaW5nRm9yRGVjbGFyYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAzKTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzI3O1xuICAgICAgICAgICAgdGhpcy5zdHJ1Y3REZWZpbml0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgNCk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMyODtcbiAgICAgICAgICAgIHRoaXMubW9kaWZpZXJEZWZpbml0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgNSk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMyOTtcbiAgICAgICAgICAgIHRoaXMuZnVuY3Rpb25EZWZpbml0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgNik7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMzMDtcbiAgICAgICAgICAgIHRoaXMuZXZlbnREZWZpbml0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgNyk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMzMTtcbiAgICAgICAgICAgIHRoaXMuZW51bURlZmluaXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCA4KTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzMyO1xuICAgICAgICAgICAgdGhpcy5jdXN0b21FcnJvckRlZmluaXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCA5KTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzMzO1xuICAgICAgICAgICAgdGhpcy50eXBlRGVmaW5pdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIHN0YXRlVmFyaWFibGVEZWNsYXJhdGlvbigpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IFN0YXRlVmFyaWFibGVEZWNsYXJhdGlvbkNvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDI2LCBfU29saWRpdHlQYXJzZXIuUlVMRV9zdGF0ZVZhcmlhYmxlRGVjbGFyYXRpb24pO1xuICAgIGxldCBfbGE7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gMzM2O1xuICAgICAgICB0aGlzLnR5cGVOYW1lKDApO1xuICAgICAgICB0aGlzLnN0YXRlID0gMzQ1O1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICB3aGlsZSAoKF9sYSAtIDk3ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSA5NyAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX185NiAtIDk3IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQ29uc3RhbnRLZXl3b3JkIC0gOTcgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5JbW11dGFibGVLZXl3b3JkIC0gOTcgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5JbnRlcm5hbEtleXdvcmQgLSA5NyB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlByaXZhdGVLZXl3b3JkIC0gOTcgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5QdWJsaWNLZXl3b3JkIC0gOTcpKSAhPT0gMCkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzNDM7XG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX2lucHV0LkxBKDEpKSB7XG4gICAgICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlB1YmxpY0tleXdvcmQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMzNztcbiAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlB1YmxpY0tleXdvcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuSW50ZXJuYWxLZXl3b3JkOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzMzg7XG4gICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5JbnRlcm5hbEtleXdvcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuUHJpdmF0ZUtleXdvcmQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMzOTtcbiAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlByaXZhdGVLZXl3b3JkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkNvbnN0YW50S2V5d29yZDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMzQwO1xuICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuQ29uc3RhbnRLZXl3b3JkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkltbXV0YWJsZUtleXdvcmQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDM0MTtcbiAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLkltbXV0YWJsZUtleXdvcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fOTY6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDM0MjtcbiAgICAgICAgICAgICAgICAgIHRoaXMub3ZlcnJpZGVTcGVjaWZpZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGltcG9ydF9Ob1ZpYWJsZUFsdEV4Y2VwdGlvbi5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IDM0NztcbiAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IDM0ODtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAzNTE7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIGlmIChfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX18xMCkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzNDk7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xMCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzUwO1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gMzUzO1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIGZpbGVMZXZlbENvbnN0YW50KCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgRmlsZUxldmVsQ29uc3RhbnRDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAyOCwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfZmlsZUxldmVsQ29uc3RhbnQpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDM1NTtcbiAgICAgICAgdGhpcy50eXBlTmFtZSgwKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDM1NjtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuQ29uc3RhbnRLZXl3b3JkKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDM1NztcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAzNTg7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzEwKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDM1OTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uKDApO1xuICAgICAgICB0aGlzLnN0YXRlID0gMzYwO1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIGN1c3RvbUVycm9yRGVmaW5pdGlvbigpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IEN1c3RvbUVycm9yRGVmaW5pdGlvbkNvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDMwLCBfU29saWRpdHlQYXJzZXIuUlVMRV9jdXN0b21FcnJvckRlZmluaXRpb24pO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDM2MjtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMjQpO1xuICAgICAgICB0aGlzLnN0YXRlID0gMzYzO1xuICAgICAgICB0aGlzLmlkZW50aWZpZXIoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDM2NDtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJMaXN0KCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAzNjU7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzEpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgdHlwZURlZmluaXRpb24oKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBUeXBlRGVmaW5pdGlvbkNvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDMyLCBfU29saWRpdHlQYXJzZXIuUlVMRV90eXBlRGVmaW5pdGlvbik7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gMzY3O1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UeXBlS2V5d29yZCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAzNjg7XG4gICAgICAgIHRoaXMuaWRlbnRpZmllcigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gMzY5O1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18yMSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAzNzA7XG4gICAgICAgIHRoaXMuZWxlbWVudGFyeVR5cGVOYW1lKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAzNzE7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzEpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgdXNpbmdGb3JEZWNsYXJhdGlvbigpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IFVzaW5nRm9yRGVjbGFyYXRpb25Db250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAzNCwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfdXNpbmdGb3JEZWNsYXJhdGlvbik7XG4gICAgbGV0IF9sYTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAzNzM7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzI1KTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDM3NDtcbiAgICAgICAgdGhpcy51c2luZ0Zvck9iamVjdCgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gMzc1O1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18yNik7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAzNzg7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9pbnB1dC5MQSgxKSkge1xuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzNzY7XG4gICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fMTM6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fMjQ6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fMjk6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fMzU6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fMzc6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fNDE6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fNTM6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fNTQ6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fNTU6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fNTY6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fNTc6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fOTU6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuSW50OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlVpbnQ6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuQnl0ZTpcbiAgICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5GaXhlZDpcbiAgICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5VZml4ZWQ6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuTGVhdmVLZXl3b3JkOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkNvbnN0cnVjdG9yS2V5d29yZDpcbiAgICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5SZWNlaXZlS2V5d29yZDpcbiAgICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5JZGVudGlmaWVyOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMzc3O1xuICAgICAgICAgICAgICB0aGlzLnR5cGVOYW1lKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBpbXBvcnRfTm9WaWFibGVBbHRFeGNlcHRpb24uTm9WaWFibGVBbHRFeGNlcHRpb24odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IDM4MTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgaWYgKF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLkdsb2JhbEtleXdvcmQpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzgwO1xuICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuR2xvYmFsS2V5d29yZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSAzODM7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzEpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgdXNpbmdGb3JPYmplY3QoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBVc2luZ0Zvck9iamVjdENvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDM2LCBfU29saWRpdHlQYXJzZXIuUlVMRV91c2luZ0Zvck9iamVjdCk7XG4gICAgbGV0IF9sYTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5zdGF0ZSA9IDM5NztcbiAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgIHN3aXRjaCAodGhpcy5faW5wdXQuTEEoMSkpIHtcbiAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fMTM6XG4gICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzI0OlxuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5UX18zNTpcbiAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fNDE6XG4gICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzUzOlxuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5UX185NTpcbiAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuTGVhdmVLZXl3b3JkOlxuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5QYXlhYmxlS2V5d29yZDpcbiAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuQ29uc3RydWN0b3JLZXl3b3JkOlxuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5SZWNlaXZlS2V5d29yZDpcbiAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuSWRlbnRpZmllcjpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzg1O1xuICAgICAgICAgICAgdGhpcy51c2VyRGVmaW5lZFR5cGVOYW1lKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5UX18xNDpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAyKTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzg2O1xuICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMTQpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDM4NztcbiAgICAgICAgICAgIHRoaXMudXNlckRlZmluZWRUeXBlTmFtZSgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDM5MjtcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgd2hpbGUgKF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlRfXzE1KSB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMzg4O1xuICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMTUpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDM4OTtcbiAgICAgICAgICAgICAgICAgIHRoaXMudXNlckRlZmluZWRUeXBlTmFtZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMzk0O1xuICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDM5NTtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzE2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IGltcG9ydF9Ob1ZpYWJsZUFsdEV4Y2VwdGlvbi5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbih0aGlzKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIHN0cnVjdERlZmluaXRpb24oKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBTdHJ1Y3REZWZpbml0aW9uQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMzgsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX3N0cnVjdERlZmluaXRpb24pO1xuICAgIGxldCBfbGE7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gMzk5O1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18yNyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA0MDA7XG4gICAgICAgIHRoaXMuaWRlbnRpZmllcigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gNDAxO1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xNCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA0MTI7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIGlmICgoX2xhICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMTMgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18yNCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzI5KSkgIT09IDAgfHwgKF9sYSAtIDM2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSAzNiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zNSAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzcgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzQxIC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181MyAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTQgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU1IC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NiAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTcgLSAzNikpICE9PSAwIHx8IChfbGEgLSA5NiAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gOTYgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fOTUgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkludCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVWludCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQnl0ZSAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuRml4ZWQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlVmaXhlZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuTGVhdmVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5QYXlhYmxlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQ29uc3RydWN0b3JLZXl3b3JkIC0gOTYpKSAhPT0gMCB8fCBfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5SZWNlaXZlS2V5d29yZCB8fCBfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5JZGVudGlmaWVyKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQwMjtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVEZWNsYXJhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQwMztcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzEpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQwOTtcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgd2hpbGUgKChfbGEgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18xMyB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzI0IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjkpKSAhPT0gMCB8fCAoX2xhIC0gMzYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDM2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzM1IC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zNyAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNDEgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzUzIC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NCAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTUgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU2IC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NyAtIDM2KSkgIT09IDAgfHwgKF9sYSAtIDk2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSA5NiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX185NSAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuSW50IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5VaW50IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5CeXRlIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5GaXhlZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVWZpeGVkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5Db25zdHJ1Y3RvcktleXdvcmQgLSA5NikpICE9PSAwIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlJlY2VpdmVLZXl3b3JkIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0MDQ7XG4gICAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlRGVjbGFyYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0MDU7XG4gICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQxMTtcbiAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IDQxNDtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMTYpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgbW9kaWZpZXJEZWZpbml0aW9uKCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgTW9kaWZpZXJEZWZpbml0aW9uQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgNDAsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX21vZGlmaWVyRGVmaW5pdGlvbik7XG4gICAgbGV0IF9sYTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA0MTY7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzI4KTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDQxNztcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA0MTk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIGlmIChfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX18yMikge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0MTg7XG4gICAgICAgICAgICB0aGlzLnBhcmFtZXRlckxpc3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IDQyNTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgd2hpbGUgKF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlRfXzk2IHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlZpcnR1YWxLZXl3b3JkKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQyMztcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5faW5wdXQuTEEoMSkpIHtcbiAgICAgICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVmlydHVhbEtleXdvcmQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQyMTtcbiAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlZpcnR1YWxLZXl3b3JkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzk2OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0MjI7XG4gICAgICAgICAgICAgICAgICB0aGlzLm92ZXJyaWRlU3BlY2lmaWVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBpbXBvcnRfTm9WaWFibGVBbHRFeGNlcHRpb24uTm9WaWFibGVBbHRFeGNlcHRpb24odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhdGUgPSA0Mjc7XG4gICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSA0MzA7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9pbnB1dC5MQSgxKSkge1xuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzE6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0Mjg7XG4gICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fMTQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0Mjk7XG4gICAgICAgICAgICAgIHRoaXMuYmxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgaW1wb3J0X05vVmlhYmxlQWx0RXhjZXB0aW9uLk5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBtb2RpZmllckludm9jYXRpb24oKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBNb2RpZmllckludm9jYXRpb25Db250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCA0MiwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfbW9kaWZpZXJJbnZvY2F0aW9uKTtcbiAgICBsZXQgX2xhO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDQzMjtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA0Mzg7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIGlmIChfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX18yMikge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0MzM7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18yMik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNDM1O1xuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgICAgICBpZiAoKF9sYSAtIDYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDYgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNSAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18xMyAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18yMiAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18yNCAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18yOSAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zMyAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zNSAtIDYpKSAhPT0gMCB8fCAoX2xhIC0gMzggJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDM4ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzM3IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX180MSAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTMgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU0IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NSAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTYgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU3IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181OCAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTkgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzYwIC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182MiAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjMgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzY0IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182NSAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjYgLSAzOCkpICE9PSAwIHx8IChfbGEgLSA5NiAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gOTYgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fOTUgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkludCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVWludCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQnl0ZSAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuRml4ZWQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlVmaXhlZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQm9vbGVhbkxpdGVyYWwgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkRlY2ltYWxOdW1iZXIgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkhleE51bWJlciAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuSGV4TGl0ZXJhbEZyYWdtZW50IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UeXBlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQ29uc3RydWN0b3JLZXl3b3JkIC0gOTYpKSAhPT0gMCB8fCAoX2xhIC0gMTI4ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSAxMjggJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuUmVjZWl2ZUtleXdvcmQgLSAxMjggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5JZGVudGlmaWVyIC0gMTI4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuU3RyaW5nTGl0ZXJhbEZyYWdtZW50IC0gMTI4KSkgIT09IDApIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0MzQ7XG4gICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uTGlzdCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNDM3O1xuICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMjMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgZnVuY3Rpb25EZWZpbml0aW9uKCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgRnVuY3Rpb25EZWZpbml0aW9uQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgNDQsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX2Z1bmN0aW9uRGVmaW5pdGlvbik7XG4gICAgbGV0IF9sYTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA0NDA7XG4gICAgICAgIHRoaXMuZnVuY3Rpb25EZXNjcmlwdG9yKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA0NDE7XG4gICAgICAgIHRoaXMucGFyYW1ldGVyTGlzdCgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gNDQyO1xuICAgICAgICB0aGlzLm1vZGlmaWVyTGlzdCgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gNDQ0O1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICBpZiAoX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fMzApIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNDQzO1xuICAgICAgICAgICAgdGhpcy5yZXR1cm5QYXJhbWV0ZXJzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSA0NDg7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9pbnB1dC5MQSgxKSkge1xuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzE6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0NDY7XG4gICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fMTQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0NDc7XG4gICAgICAgICAgICAgIHRoaXMuYmxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgaW1wb3J0X05vVmlhYmxlQWx0RXhjZXB0aW9uLk5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBmdW5jdGlvbkRlc2NyaXB0b3IoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBGdW5jdGlvbkRlc2NyaXB0b3JDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCA0NiwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfZnVuY3Rpb25EZXNjcmlwdG9yKTtcbiAgICBsZXQgX2xhO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnN0YXRlID0gNDU3O1xuICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgc3dpdGNoICh0aGlzLl9pbnB1dC5MQSgxKSkge1xuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5UX18yOTpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNDUwO1xuICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMjkpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQ1MjtcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgaWYgKF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlRfXzEzIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlRfXzI0IHx8IChfbGEgLSAzNiAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gMzYgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzUgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzQxIC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181MyAtIDM2KSkgIT09IDAgfHwgKF9sYSAtIDk2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSA5NiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX185NSAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuTGVhdmVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5QYXlhYmxlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQ29uc3RydWN0b3JLZXl3b3JkIC0gOTYpKSAhPT0gMCB8fCBfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5SZWNlaXZlS2V5d29yZCB8fCBfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNDUxO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRlbnRpZmllcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5Db25zdHJ1Y3RvcktleXdvcmQ6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMik7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQ1NDtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLkNvbnN0cnVjdG9yS2V5d29yZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5GYWxsYmFja0tleXdvcmQ6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMyk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQ1NTtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLkZhbGxiYWNrS2V5d29yZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5SZWNlaXZlS2V5d29yZDpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCA0KTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNDU2O1xuICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuUmVjZWl2ZUtleXdvcmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgaW1wb3J0X05vVmlhYmxlQWx0RXhjZXB0aW9uLk5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgcmV0dXJuUGFyYW1ldGVycygpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IFJldHVyblBhcmFtZXRlcnNDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCA0OCwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfcmV0dXJuUGFyYW1ldGVycyk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gNDU5O1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18zMCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA0NjA7XG4gICAgICAgIHRoaXMucGFyYW1ldGVyTGlzdCgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgbW9kaWZpZXJMaXN0KCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgTW9kaWZpZXJMaXN0Q29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgNTAsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX21vZGlmaWVyTGlzdCk7XG4gICAgbGV0IF9sYTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA0NzI7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIHdoaWxlIChfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX18xMyB8fCBfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX18yNCB8fCAoX2xhIC0gMzYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDM2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzM1IC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX180MSAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTMgLSAzNikpICE9PSAwIHx8IChfbGEgLSA5NiAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gOTYgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fOTUgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzk2IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5Db25zdGFudEtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkxlYXZlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuRXh0ZXJuYWxLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5JbnRlcm5hbEtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5Qcml2YXRlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuUHVibGljS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVmlydHVhbEtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlB1cmVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5WaWV3S2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQ29uc3RydWN0b3JLZXl3b3JkIC0gOTYpKSAhPT0gMCB8fCBfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5SZWNlaXZlS2V5d29yZCB8fCBfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5JZGVudGlmaWVyKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQ3MDtcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5pbnRlcnByZXRlci5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsIDQwLCB0aGlzLl9jdHgpKSB7XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNDYyO1xuICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuRXh0ZXJuYWxLZXl3b3JkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNDYzO1xuICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuUHVibGljS2V5d29yZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQ2NDtcbiAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLkludGVybmFsS2V5d29yZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQ2NTtcbiAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlByaXZhdGVLZXl3b3JkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNDY2O1xuICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVmlydHVhbEtleXdvcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0Njc7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlTXV0YWJpbGl0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0Njg7XG4gICAgICAgICAgICAgICAgICB0aGlzLm1vZGlmaWVySW52b2NhdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0Njk7XG4gICAgICAgICAgICAgICAgICB0aGlzLm92ZXJyaWRlU3BlY2lmaWVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YXRlID0gNDc0O1xuICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgZXZlbnREZWZpbml0aW9uKCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgRXZlbnREZWZpbml0aW9uQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgNTIsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX2V2ZW50RGVmaW5pdGlvbik7XG4gICAgbGV0IF9sYTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA0NzU7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzMxKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDQ3NjtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA0Nzc7XG4gICAgICAgIHRoaXMuZXZlbnRQYXJhbWV0ZXJMaXN0KCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA0Nzk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIGlmIChfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5Bbm9ueW1vdXNLZXl3b3JkKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQ3ODtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLkFub255bW91c0tleXdvcmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gNDgxO1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIGVudW1WYWx1ZSgpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IEVudW1WYWx1ZUNvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDU0LCBfU29saWRpdHlQYXJzZXIuUlVMRV9lbnVtVmFsdWUpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDQ4MztcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBlbnVtRGVmaW5pdGlvbigpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IEVudW1EZWZpbml0aW9uQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgNTYsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX2VudW1EZWZpbml0aW9uKTtcbiAgICBsZXQgX2xhO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDQ4NTtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMzIpO1xuICAgICAgICB0aGlzLnN0YXRlID0gNDg2O1xuICAgICAgICB0aGlzLmlkZW50aWZpZXIoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDQ4NztcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMTQpO1xuICAgICAgICB0aGlzLnN0YXRlID0gNDg5O1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICBpZiAoX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fMTMgfHwgX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fMjQgfHwgKF9sYSAtIDM2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSAzNiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zNSAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNDEgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzUzIC0gMzYpKSAhPT0gMCB8fCAoX2xhIC0gOTYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDk2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzk1IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5Db25zdHJ1Y3RvcktleXdvcmQgLSA5NikpICE9PSAwIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlJlY2VpdmVLZXl3b3JkIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLklkZW50aWZpZXIpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNDg4O1xuICAgICAgICAgICAgdGhpcy5lbnVtVmFsdWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IDQ5NTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgd2hpbGUgKF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlRfXzE1KSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNDkxO1xuICAgICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xNSk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA0OTI7XG4gICAgICAgICAgICAgIHRoaXMuZW51bVZhbHVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhdGUgPSA0OTc7XG4gICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSA0OTg7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzE2KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIHBhcmFtZXRlckxpc3QoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBQYXJhbWV0ZXJMaXN0Q29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgNTgsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX3BhcmFtZXRlckxpc3QpO1xuICAgIGxldCBfbGE7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gNTAwO1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18yMik7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA1MDk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIGlmICgoX2xhICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMTMgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18yNCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzI5KSkgIT09IDAgfHwgKF9sYSAtIDM2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSAzNiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zNSAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzcgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzQxIC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181MyAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTQgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU1IC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NiAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTcgLSAzNikpICE9PSAwIHx8IChfbGEgLSA5NiAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gOTYgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fOTUgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkludCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVWludCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQnl0ZSAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuRml4ZWQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlVmaXhlZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuTGVhdmVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5QYXlhYmxlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQ29uc3RydWN0b3JLZXl3b3JkIC0gOTYpKSAhPT0gMCB8fCBfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5SZWNlaXZlS2V5d29yZCB8fCBfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5JZGVudGlmaWVyKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDUwMTtcbiAgICAgICAgICAgIHRoaXMucGFyYW1ldGVyKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNTA2O1xuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgICAgICB3aGlsZSAoX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fMTUpIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1MDI7XG4gICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xNSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNTAzO1xuICAgICAgICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDUwODtcbiAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IDUxMTtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMjMpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgcGFyYW1ldGVyKCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgUGFyYW1ldGVyQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgNjAsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX3BhcmFtZXRlcik7XG4gICAgbGV0IF9sYTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA1MTM7XG4gICAgICAgIHRoaXMudHlwZU5hbWUoMCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA1MTU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLmludGVycHJldGVyLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwgNDcsIHRoaXMuX2N0eCkpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1MTQ7XG4gICAgICAgICAgICAgIHRoaXMuc3RvcmFnZUxvY2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gNTE4O1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICBpZiAoX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fMTMgfHwgX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fMjQgfHwgKF9sYSAtIDM2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSAzNiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zNSAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNDEgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzUzIC0gMzYpKSAhPT0gMCB8fCAoX2xhIC0gOTYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDk2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzk1IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5Db25zdHJ1Y3RvcktleXdvcmQgLSA5NikpICE9PSAwIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlJlY2VpdmVLZXl3b3JkIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLklkZW50aWZpZXIpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNTE3O1xuICAgICAgICAgICAgdGhpcy5pZGVudGlmaWVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBldmVudFBhcmFtZXRlckxpc3QoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBFdmVudFBhcmFtZXRlckxpc3RDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCA2MiwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfZXZlbnRQYXJhbWV0ZXJMaXN0KTtcbiAgICBsZXQgX2xhO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDUyMDtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMjIpO1xuICAgICAgICB0aGlzLnN0YXRlID0gNTI5O1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICBpZiAoKF9sYSAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzEzIHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjQgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18yOSkpICE9PSAwIHx8IChfbGEgLSAzNiAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gMzYgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzUgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzM3IC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX180MSAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTMgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU0IC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NSAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTYgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU3IC0gMzYpKSAhPT0gMCB8fCAoX2xhIC0gOTYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDk2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzk1IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5JbnQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlVpbnQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkJ5dGUgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkZpeGVkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5VZml4ZWQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkxlYXZlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuUGF5YWJsZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkNvbnN0cnVjdG9yS2V5d29yZCAtIDk2KSkgIT09IDAgfHwgX2xhID09PSBfU29saWRpdHlQYXJzZXIuUmVjZWl2ZUtleXdvcmQgfHwgX2xhID09PSBfU29saWRpdHlQYXJzZXIuSWRlbnRpZmllcikge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1MjE7XG4gICAgICAgICAgICB0aGlzLmV2ZW50UGFyYW1ldGVyKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNTI2O1xuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgICAgICB3aGlsZSAoX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fMTUpIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1MjI7XG4gICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xNSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNTIzO1xuICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudFBhcmFtZXRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNTI4O1xuICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gNTMxO1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18yMyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBldmVudFBhcmFtZXRlcigpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IEV2ZW50UGFyYW1ldGVyQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgNjQsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX2V2ZW50UGFyYW1ldGVyKTtcbiAgICBsZXQgX2xhO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDUzMztcbiAgICAgICAgdGhpcy50eXBlTmFtZSgwKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDUzNTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgaWYgKF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLkluZGV4ZWRLZXl3b3JkKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDUzNDtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLkluZGV4ZWRLZXl3b3JkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IDUzODtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgaWYgKF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlRfXzEzIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlRfXzI0IHx8IChfbGEgLSAzNiAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gMzYgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzUgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzQxIC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181MyAtIDM2KSkgIT09IDAgfHwgKF9sYSAtIDk2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSA5NiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX185NSAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuTGVhdmVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5QYXlhYmxlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQ29uc3RydWN0b3JLZXl3b3JkIC0gOTYpKSAhPT0gMCB8fCBfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5SZWNlaXZlS2V5d29yZCB8fCBfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5JZGVudGlmaWVyKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDUzNztcbiAgICAgICAgICAgIHRoaXMuaWRlbnRpZmllcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgZnVuY3Rpb25UeXBlUGFyYW1ldGVyTGlzdCgpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IEZ1bmN0aW9uVHlwZVBhcmFtZXRlckxpc3RDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCA2NiwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfZnVuY3Rpb25UeXBlUGFyYW1ldGVyTGlzdCk7XG4gICAgbGV0IF9sYTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA1NDA7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzIyKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDU0OTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgaWYgKChfbGEgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18xMyB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzI0IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjkpKSAhPT0gMCB8fCAoX2xhIC0gMzYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDM2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzM1IC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zNyAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNDEgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzUzIC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NCAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTUgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU2IC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NyAtIDM2KSkgIT09IDAgfHwgKF9sYSAtIDk2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSA5NiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX185NSAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuSW50IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5VaW50IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5CeXRlIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5GaXhlZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVWZpeGVkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5Db25zdHJ1Y3RvcktleXdvcmQgLSA5NikpICE9PSAwIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlJlY2VpdmVLZXl3b3JkIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLklkZW50aWZpZXIpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNTQxO1xuICAgICAgICAgICAgdGhpcy5mdW5jdGlvblR5cGVQYXJhbWV0ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1NDY7XG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgICAgIHdoaWxlIChfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX18xNSkge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDU0MjtcbiAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzE1KTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1NDM7XG4gICAgICAgICAgICAgICAgICB0aGlzLmZ1bmN0aW9uVHlwZVBhcmFtZXRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNTQ4O1xuICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gNTUxO1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18yMyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBmdW5jdGlvblR5cGVQYXJhbWV0ZXIoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBGdW5jdGlvblR5cGVQYXJhbWV0ZXJDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCA2OCwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfZnVuY3Rpb25UeXBlUGFyYW1ldGVyKTtcbiAgICBsZXQgX2xhO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDU1MztcbiAgICAgICAgdGhpcy50eXBlTmFtZSgwKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDU1NTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgaWYgKChfbGEgLSA0MCAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gNDAgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzkgLSA0MCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzQwIC0gNDAgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX180MSAtIDQwKSkgIT09IDApIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNTU0O1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlTG9jYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIHZhcmlhYmxlRGVjbGFyYXRpb24oKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBWYXJpYWJsZURlY2xhcmF0aW9uQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgNzAsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX3ZhcmlhYmxlRGVjbGFyYXRpb24pO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDU1NztcbiAgICAgICAgdGhpcy50eXBlTmFtZSgwKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDU1OTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuaW50ZXJwcmV0ZXIuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LCA1NiwgdGhpcy5fY3R4KSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDU1ODtcbiAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlTG9jYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSA1NjE7XG4gICAgICAgIHRoaXMuaWRlbnRpZmllcigpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgdHlwZU5hbWUoX3ApIHtcbiAgICBpZiAoX3AgPT09IHZvaWQgMCkge1xuICAgICAgX3AgPSAwO1xuICAgIH1cbiAgICBsZXQgX3BhcmVudGN0eCA9IHRoaXMuX2N0eDtcbiAgICBsZXQgX3BhcmVudFN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IFR5cGVOYW1lQ29udGV4dCh0aGlzLl9jdHgsIF9wYXJlbnRTdGF0ZSk7XG4gICAgbGV0IF9wcmV2Y3R4ID0gX2xvY2FsY3R4O1xuICAgIGxldCBfc3RhcnRTdGF0ZSA9IDcyO1xuICAgIHRoaXMuZW50ZXJSZWN1cnNpb25SdWxlKF9sb2NhbGN0eCwgNzIsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX3R5cGVOYW1lLCBfcCk7XG4gICAgbGV0IF9sYTtcbiAgICB0cnkge1xuICAgICAgbGV0IF9hbHQ7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDU3MDtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuaW50ZXJwcmV0ZXIuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LCA1NywgdGhpcy5fY3R4KSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDU2NDtcbiAgICAgICAgICAgICAgdGhpcy5lbGVtZW50YXJ5VHlwZU5hbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDU2NTtcbiAgICAgICAgICAgICAgdGhpcy51c2VyRGVmaW5lZFR5cGVOYW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1NjY7XG4gICAgICAgICAgICAgIHRoaXMubWFwcGluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNTY3O1xuICAgICAgICAgICAgICB0aGlzLmZ1bmN0aW9uVHlwZU5hbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDU2ODtcbiAgICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMzUpO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNTY5O1xuICAgICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5QYXlhYmxlS2V5d29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdHguX3N0b3AgPSB0aGlzLl9pbnB1dC50cnlMVCgtMSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA1ODA7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgX2FsdCA9IHRoaXMuaW50ZXJwcmV0ZXIuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LCA1OSwgdGhpcy5fY3R4KTtcbiAgICAgICAgd2hpbGUgKF9hbHQgIT09IDIgJiYgX2FsdCAhPT0gaW1wb3J0X0FUTi5BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XG4gICAgICAgICAgaWYgKF9hbHQgPT09IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJzZUxpc3RlbmVycyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV4aXRSdWxlRXZlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9wcmV2Y3R4ID0gX2xvY2FsY3R4O1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgX2xvY2FsY3R4ID0gbmV3IFR5cGVOYW1lQ29udGV4dChfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQoX2xvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfdHlwZU5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1NzI7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMykpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuY3JlYXRlRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKFwidGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDMpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNTczO1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzMzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNTc1O1xuICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgICAgICAgICBpZiAoKF9sYSAtIDYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDYgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNSAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18xMyAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18yMiAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18yNCAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18yOSAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zMyAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zNSAtIDYpKSAhPT0gMCB8fCAoX2xhIC0gMzggJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDM4ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzM3IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX180MSAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTMgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU0IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NSAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTYgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU3IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181OCAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTkgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzYwIC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182MiAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjMgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzY0IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182NSAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjYgLSAzOCkpICE9PSAwIHx8IChfbGEgLSA5NiAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gOTYgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fOTUgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkludCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVWludCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQnl0ZSAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuRml4ZWQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlVmaXhlZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQm9vbGVhbkxpdGVyYWwgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkRlY2ltYWxOdW1iZXIgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkhleE51bWJlciAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuSGV4TGl0ZXJhbEZyYWdtZW50IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UeXBlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQ29uc3RydWN0b3JLZXl3b3JkIC0gOTYpKSAhPT0gMCB8fCAoX2xhIC0gMTI4ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSAxMjggJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuUmVjZWl2ZUtleXdvcmQgLSAxMjggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5JZGVudGlmaWVyIC0gMTI4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuU3RyaW5nTGl0ZXJhbEZyYWdtZW50IC0gMTI4KSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDU3NDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uKDApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNTc3O1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzM0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YXRlID0gNTgyO1xuICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgICBfYWx0ID0gdGhpcy5pbnRlcnByZXRlci5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsIDU5LCB0aGlzLl9jdHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMudW5yb2xsUmVjdXJzaW9uQ29udGV4dHMoX3BhcmVudGN0eCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgdXNlckRlZmluZWRUeXBlTmFtZSgpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IFVzZXJEZWZpbmVkVHlwZU5hbWVDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCA3NCwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfdXNlckRlZmluZWRUeXBlTmFtZSk7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBfYWx0O1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA1ODM7XG4gICAgICAgIHRoaXMuaWRlbnRpZmllcigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gNTg4O1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgIF9hbHQgPSB0aGlzLmludGVycHJldGVyLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwgNjAsIHRoaXMuX2N0eCk7XG4gICAgICAgIHdoaWxlIChfYWx0ICE9PSAyICYmIF9hbHQgIT09IGltcG9ydF9BVE4uQVROLklOVkFMSURfQUxUX05VTUJFUikge1xuICAgICAgICAgIGlmIChfYWx0ID09PSAxKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNTg0O1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzM2KTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNTg1O1xuICAgICAgICAgICAgICAgIHRoaXMuaWRlbnRpZmllcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhdGUgPSA1OTA7XG4gICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgIF9hbHQgPSB0aGlzLmludGVycHJldGVyLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwgNjAsIHRoaXMuX2N0eCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIG1hcHBpbmdLZXkoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBNYXBwaW5nS2V5Q29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgNzYsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX21hcHBpbmdLZXkpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnN0YXRlID0gNTkzO1xuICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgc3dpdGNoICh0aGlzLmludGVycHJldGVyLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwgNjEsIHRoaXMuX2N0eCkpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1OTE7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRhcnlUeXBlTmFtZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDIpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1OTI7XG4gICAgICAgICAgICB0aGlzLnVzZXJEZWZpbmVkVHlwZU5hbWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBtYXBwaW5nKCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgTWFwcGluZ0NvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDc4LCBfU29saWRpdHlQYXJzZXIuUlVMRV9tYXBwaW5nKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA1OTU7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzM3KTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDU5NjtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMjIpO1xuICAgICAgICB0aGlzLnN0YXRlID0gNTk3O1xuICAgICAgICB0aGlzLm1hcHBpbmdLZXkoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDU5ODtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMzgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gNTk5O1xuICAgICAgICB0aGlzLnR5cGVOYW1lKDApO1xuICAgICAgICB0aGlzLnN0YXRlID0gNjAwO1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18yMyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBmdW5jdGlvblR5cGVOYW1lKCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgRnVuY3Rpb25UeXBlTmFtZUNvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDgwLCBfU29saWRpdHlQYXJzZXIuUlVMRV9mdW5jdGlvblR5cGVOYW1lKTtcbiAgICB0cnkge1xuICAgICAgbGV0IF9hbHQ7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDYwMjtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMjkpO1xuICAgICAgICB0aGlzLnN0YXRlID0gNjAzO1xuICAgICAgICB0aGlzLmZ1bmN0aW9uVHlwZVBhcmFtZXRlckxpc3QoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDYwOTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBfYWx0ID0gdGhpcy5pbnRlcnByZXRlci5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsIDYzLCB0aGlzLl9jdHgpO1xuICAgICAgICB3aGlsZSAoX2FsdCAhPT0gMiAmJiBfYWx0ICE9PSBpbXBvcnRfQVROLkFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcbiAgICAgICAgICBpZiAoX2FsdCA9PT0gMSkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNjA3O1xuICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5faW5wdXQuTEEoMSkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5JbnRlcm5hbEtleXdvcmQ6XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2MDQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLkludGVybmFsS2V5d29yZCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5FeHRlcm5hbEtleXdvcmQ6XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2MDU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLkV4dGVybmFsS2V5d29yZCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5Db25zdGFudEtleXdvcmQ6XG4gICAgICAgICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuUGF5YWJsZUtleXdvcmQ6XG4gICAgICAgICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuUHVyZUtleXdvcmQ6XG4gICAgICAgICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVmlld0tleXdvcmQ6XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2MDY7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVNdXRhYmlsaXR5KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGltcG9ydF9Ob1ZpYWJsZUFsdEV4Y2VwdGlvbi5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YXRlID0gNjExO1xuICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgICBfYWx0ID0gdGhpcy5pbnRlcnByZXRlci5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsIDYzLCB0aGlzLl9jdHgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSA2MTQ7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLmludGVycHJldGVyLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwgNjQsIHRoaXMuX2N0eCkpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2MTI7XG4gICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzMwKTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDYxMztcbiAgICAgICAgICAgICAgdGhpcy5mdW5jdGlvblR5cGVQYXJhbWV0ZXJMaXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgc3RvcmFnZUxvY2F0aW9uKCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgU3RvcmFnZUxvY2F0aW9uQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgODIsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX3N0b3JhZ2VMb2NhdGlvbik7XG4gICAgbGV0IF9sYTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA2MTY7XG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICBpZiAoISgoX2xhIC0gNDAgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDQwICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzM5IC0gNDAgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX180MCAtIDQwIHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNDEgLSA0MCkpICE9PSAwKSkge1xuICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3ZlcklubGluZSh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5faW5wdXQuTEEoMSkgPT09IGltcG9ydF9Ub2tlbi5Ub2tlbi5FT0YpIHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlZEVPRiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIHN0YXRlTXV0YWJpbGl0eSgpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IFN0YXRlTXV0YWJpbGl0eUNvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDg0LCBfU29saWRpdHlQYXJzZXIuUlVMRV9zdGF0ZU11dGFiaWxpdHkpO1xuICAgIGxldCBfbGE7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gNjE4O1xuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgaWYgKCEoKF9sYSAtIDExMSAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gMTExICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLkNvbnN0YW50S2V5d29yZCAtIDExMSB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkIC0gMTExIHwgMSA8PCBfU29saWRpdHlQYXJzZXIuUHVyZUtleXdvcmQgLSAxMTEgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5WaWV3S2V5d29yZCAtIDExMSkpICE9PSAwKSkge1xuICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3ZlcklubGluZSh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5faW5wdXQuTEEoMSkgPT09IGltcG9ydF9Ub2tlbi5Ub2tlbi5FT0YpIHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlZEVPRiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIGJsb2NrKCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgQmxvY2tDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCA4NiwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfYmxvY2spO1xuICAgIGxldCBfbGE7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gNjIwO1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xNCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA2MjQ7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIHdoaWxlICgoX2xhIC0gNiAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gNiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181IC0gNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzEzIC0gNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzE0IC0gNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzIyIC0gNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzI0IC0gNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzI2IC0gNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzI5IC0gNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzMzIC0gNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzM1IC0gNikpICE9PSAwIHx8IChfbGEgLSAzOCAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gMzggJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzcgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzQxIC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX180MiAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNDQgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzQ2IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX180NyAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNDggLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzQ5IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181MCAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTEgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzUyIC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181MyAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTQgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU1IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NiAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTcgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU4IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181OSAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjAgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzYyIC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182MyAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjQgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzY1IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182NiAtIDM4KSkgIT09IDAgfHwgKF9sYSAtIDk2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSA5NiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX185NSAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuSW50IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5VaW50IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5CeXRlIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5GaXhlZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVWZpeGVkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5Cb29sZWFuTGl0ZXJhbCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuRGVjaW1hbE51bWJlciAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuSGV4TnVtYmVyIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5IZXhMaXRlcmFsRnJhZ21lbnQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkJyZWFrS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQ29udGludWVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UeXBlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQ29uc3RydWN0b3JLZXl3b3JkIC0gOTYpKSAhPT0gMCB8fCAoX2xhIC0gMTI4ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSAxMjggJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuUmVjZWl2ZUtleXdvcmQgLSAxMjggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5JZGVudGlmaWVyIC0gMTI4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuU3RyaW5nTGl0ZXJhbEZyYWdtZW50IC0gMTI4KSkgIT09IDApIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2MjE7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGVtZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhdGUgPSA2MjY7XG4gICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSA2Mjc7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzE2KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIHN0YXRlbWVudCgpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IFN0YXRlbWVudENvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDg4LCBfU29saWRpdHlQYXJzZXIuUlVMRV9zdGF0ZW1lbnQpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnN0YXRlID0gNjQ0O1xuICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgc3dpdGNoICh0aGlzLmludGVycHJldGVyLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwgNjYsIHRoaXMuX2N0eCkpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2Mjk7XG4gICAgICAgICAgICB0aGlzLmlmU3RhdGVtZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMik7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDYzMDtcbiAgICAgICAgICAgIHRoaXMudHJ5U3RhdGVtZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMyk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDYzMTtcbiAgICAgICAgICAgIHRoaXMud2hpbGVTdGF0ZW1lbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCA0KTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNjMyO1xuICAgICAgICAgICAgdGhpcy5mb3JTdGF0ZW1lbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCA1KTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNjMzO1xuICAgICAgICAgICAgdGhpcy5ibG9jaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDYpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2MzQ7XG4gICAgICAgICAgICB0aGlzLmlubGluZUFzc2VtYmx5U3RhdGVtZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgNyk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDYzNTtcbiAgICAgICAgICAgIHRoaXMuZG9XaGlsZVN0YXRlbWVudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDgpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2MzY7XG4gICAgICAgICAgICB0aGlzLmNvbnRpbnVlU3RhdGVtZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgOSk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDYzNztcbiAgICAgICAgICAgIHRoaXMuYnJlYWtTdGF0ZW1lbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMTApO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2Mzg7XG4gICAgICAgICAgICB0aGlzLnJldHVyblN0YXRlbWVudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxMSk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDYzOTtcbiAgICAgICAgICAgIHRoaXMudGhyb3dTdGF0ZW1lbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMTIpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2NDA7XG4gICAgICAgICAgICB0aGlzLmVtaXRTdGF0ZW1lbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMTMpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2NDE7XG4gICAgICAgICAgICB0aGlzLnNpbXBsZVN0YXRlbWVudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxNCk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY0MjtcbiAgICAgICAgICAgIHRoaXMudW5jaGVja2VkU3RhdGVtZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDE1KTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNjQzO1xuICAgICAgICAgICAgdGhpcy5yZXZlcnRTdGF0ZW1lbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBleHByZXNzaW9uU3RhdGVtZW50KCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgRXhwcmVzc2lvblN0YXRlbWVudENvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDkwLCBfU29saWRpdHlQYXJzZXIuUlVMRV9leHByZXNzaW9uU3RhdGVtZW50KTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA2NDY7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDY0NztcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBpZlN0YXRlbWVudCgpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IElmU3RhdGVtZW50Q29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgOTIsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX2lmU3RhdGVtZW50KTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA2NDk7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzQyKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDY1MDtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMjIpO1xuICAgICAgICB0aGlzLnN0YXRlID0gNjUxO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA2NTI7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzIzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDY1MztcbiAgICAgICAgdGhpcy5zdGF0ZW1lbnQoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDY1NjtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuaW50ZXJwcmV0ZXIuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LCA2NywgdGhpcy5fY3R4KSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY1NDtcbiAgICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fNDMpO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNjU1O1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlbWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIHRyeVN0YXRlbWVudCgpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IFRyeVN0YXRlbWVudENvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDk0LCBfU29saWRpdHlQYXJzZXIuUlVMRV90cnlTdGF0ZW1lbnQpO1xuICAgIGxldCBfbGE7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gNjU4O1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX180NCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA2NTk7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDY2MTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgaWYgKF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlRfXzMwKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY2MDtcbiAgICAgICAgICAgIHRoaXMucmV0dXJuUGFyYW1ldGVycygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gNjYzO1xuICAgICAgICB0aGlzLmJsb2NrKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA2NjU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2NjQ7XG4gICAgICAgICAgICAgIHRoaXMuY2F0Y2hDbGF1c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IDY2NztcbiAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIH0gd2hpbGUgKF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlRfXzQ1KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIGNhdGNoQ2xhdXNlKCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgQ2F0Y2hDbGF1c2VDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCA5NiwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfY2F0Y2hDbGF1c2UpO1xuICAgIGxldCBfbGE7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gNjY5O1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX180NSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA2NzQ7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIGlmICgoX2xhICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMTMgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18yMiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzI0KSkgIT09IDAgfHwgKF9sYSAtIDM2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSAzNiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zNSAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNDEgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzUzIC0gMzYpKSAhPT0gMCB8fCAoX2xhIC0gOTYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDk2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzk1IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5Db25zdHJ1Y3RvcktleXdvcmQgLSA5NikpICE9PSAwIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlJlY2VpdmVLZXl3b3JkIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLklkZW50aWZpZXIpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNjcxO1xuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgICAgICBpZiAoX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fMTMgfHwgX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fMjQgfHwgKF9sYSAtIDM2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSAzNiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zNSAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNDEgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzUzIC0gMzYpKSAhPT0gMCB8fCAoX2xhIC0gOTYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDk2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzk1IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5Db25zdHJ1Y3RvcktleXdvcmQgLSA5NikpICE9PSAwIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlJlY2VpdmVLZXl3b3JkIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2NzA7XG4gICAgICAgICAgICAgICAgdGhpcy5pZGVudGlmaWVyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2NzM7XG4gICAgICAgICAgICB0aGlzLnBhcmFtZXRlckxpc3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IDY3NjtcbiAgICAgICAgdGhpcy5ibG9jaygpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgd2hpbGVTdGF0ZW1lbnQoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBXaGlsZVN0YXRlbWVudENvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDk4LCBfU29saWRpdHlQYXJzZXIuUlVMRV93aGlsZVN0YXRlbWVudCk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gNjc4O1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX180Nik7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA2Nzk7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzIyKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDY4MDtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uKDApO1xuICAgICAgICB0aGlzLnN0YXRlID0gNjgxO1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18yMyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA2ODI7XG4gICAgICAgIHRoaXMuc3RhdGVtZW50KCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBzaW1wbGVTdGF0ZW1lbnQoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBTaW1wbGVTdGF0ZW1lbnRDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAxMDAsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX3NpbXBsZVN0YXRlbWVudCk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gNjg2O1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5pbnRlcnByZXRlci5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsIDcyLCB0aGlzLl9jdHgpKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNjg0O1xuICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY4NTtcbiAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uU3RhdGVtZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgdW5jaGVja2VkU3RhdGVtZW50KCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgVW5jaGVja2VkU3RhdGVtZW50Q29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMTAyLCBfU29saWRpdHlQYXJzZXIuUlVMRV91bmNoZWNrZWRTdGF0ZW1lbnQpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDY4ODtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fNDcpO1xuICAgICAgICB0aGlzLnN0YXRlID0gNjg5O1xuICAgICAgICB0aGlzLmJsb2NrKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBmb3JTdGF0ZW1lbnQoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBGb3JTdGF0ZW1lbnRDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAxMDQsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX2ZvclN0YXRlbWVudCk7XG4gICAgbGV0IF9sYTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA2OTE7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzI2KTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDY5MjtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMjIpO1xuICAgICAgICB0aGlzLnN0YXRlID0gNjk1O1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5faW5wdXQuTEEoMSkpIHtcbiAgICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5UX181OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzEzOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzIyOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzI0OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzI5OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzMzOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzM1OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzM3OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzQxOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzUzOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzU0OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzU1OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzU2OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzU3OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzU4OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzU5OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzYwOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzYyOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzYzOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzY0OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzY1OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzY2OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzk1OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkludDpcbiAgICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5VaW50OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkJ5dGU6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuRml4ZWQ6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVWZpeGVkOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkJvb2xlYW5MaXRlcmFsOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkRlY2ltYWxOdW1iZXI6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuSGV4TnVtYmVyOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkhleExpdGVyYWxGcmFnbWVudDpcbiAgICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQ6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuUGF5YWJsZUtleXdvcmQ6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVHlwZUtleXdvcmQ6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuQ29uc3RydWN0b3JLZXl3b3JkOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlJlY2VpdmVLZXl3b3JkOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLklkZW50aWZpZXI6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuU3RyaW5nTGl0ZXJhbEZyYWdtZW50OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNjkzO1xuICAgICAgICAgICAgICB0aGlzLnNpbXBsZVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fMTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY5NDtcbiAgICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IGltcG9ydF9Ob1ZpYWJsZUFsdEV4Y2VwdGlvbi5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gNjk5O1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5faW5wdXQuTEEoMSkpIHtcbiAgICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5UX181OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzEzOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzIyOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzI0OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzI5OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzMzOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzM1OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzM3OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzQxOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzUzOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzU0OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzU1OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzU2OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzU3OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzU4OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzU5OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzYwOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzYyOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzYzOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzY0OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzY1OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzY2OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzk1OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkludDpcbiAgICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5VaW50OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkJ5dGU6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuRml4ZWQ6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVWZpeGVkOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkJvb2xlYW5MaXRlcmFsOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkRlY2ltYWxOdW1iZXI6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuSGV4TnVtYmVyOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkhleExpdGVyYWxGcmFnbWVudDpcbiAgICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQ6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuUGF5YWJsZUtleXdvcmQ6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVHlwZUtleXdvcmQ6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuQ29uc3RydWN0b3JLZXl3b3JkOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlJlY2VpdmVLZXl3b3JkOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLklkZW50aWZpZXI6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuU3RyaW5nTGl0ZXJhbEZyYWdtZW50OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNjk3O1xuICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25TdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzE6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA2OTg7XG4gICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBpbXBvcnRfTm9WaWFibGVBbHRFeGNlcHRpb24uTm9WaWFibGVBbHRFeGNlcHRpb24odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IDcwMjtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgaWYgKChfbGEgLSA2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSA2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzUgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMTMgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjIgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjQgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjkgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzMgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzUgLSA2KSkgIT09IDAgfHwgKF9sYSAtIDM4ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSAzOCAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zNyAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNDEgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzUzIC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NCAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTUgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU2IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NyAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTggLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU5IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182MCAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjIgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzYzIC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182NCAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjUgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzY2IC0gMzgpKSAhPT0gMCB8fCAoX2xhIC0gOTYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDk2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzk1IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5JbnQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlVpbnQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkJ5dGUgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkZpeGVkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5VZml4ZWQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkJvb2xlYW5MaXRlcmFsIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5EZWNpbWFsTnVtYmVyIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5IZXhOdW1iZXIgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkhleExpdGVyYWxGcmFnbWVudCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuTGVhdmVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5QYXlhYmxlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVHlwZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkNvbnN0cnVjdG9yS2V5d29yZCAtIDk2KSkgIT09IDAgfHwgKF9sYSAtIDEyOCAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gMTI4ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlJlY2VpdmVLZXl3b3JkIC0gMTI4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuSWRlbnRpZmllciAtIDEyOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlN0cmluZ0xpdGVyYWxGcmFnbWVudCAtIDEyOCkpICE9PSAwKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDcwMTtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IDcwNDtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMjMpO1xuICAgICAgICB0aGlzLnN0YXRlID0gNzA1O1xuICAgICAgICB0aGlzLnN0YXRlbWVudCgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgaW5saW5lQXNzZW1ibHlTdGF0ZW1lbnQoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBJbmxpbmVBc3NlbWJseVN0YXRlbWVudENvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDEwNiwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfaW5saW5lQXNzZW1ibHlTdGF0ZW1lbnQpO1xuICAgIGxldCBfbGE7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gNzA3O1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX180OCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA3MDk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIGlmIChfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5TdHJpbmdMaXRlcmFsRnJhZ21lbnQpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNzA4O1xuICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuU3RyaW5nTGl0ZXJhbEZyYWdtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IDcxNTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgaWYgKF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlRfXzIyKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDcxMTtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzIyKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3MTI7XG4gICAgICAgICAgICB0aGlzLmlubGluZUFzc2VtYmx5U3RhdGVtZW50RmxhZygpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDcxMztcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzIzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IDcxNztcbiAgICAgICAgdGhpcy5hc3NlbWJseUJsb2NrKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBpbmxpbmVBc3NlbWJseVN0YXRlbWVudEZsYWcoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBJbmxpbmVBc3NlbWJseVN0YXRlbWVudEZsYWdDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAxMDgsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX2lubGluZUFzc2VtYmx5U3RhdGVtZW50RmxhZyk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gNzE5O1xuICAgICAgICB0aGlzLnN0cmluZ0xpdGVyYWwoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIGRvV2hpbGVTdGF0ZW1lbnQoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBEb1doaWxlU3RhdGVtZW50Q29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMTEwLCBfU29saWRpdHlQYXJzZXIuUlVMRV9kb1doaWxlU3RhdGVtZW50KTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA3MjE7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzQ5KTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDcyMjtcbiAgICAgICAgdGhpcy5zdGF0ZW1lbnQoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDcyMztcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fNDYpO1xuICAgICAgICB0aGlzLnN0YXRlID0gNzI0O1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18yMik7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA3MjU7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDcyNjtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMjMpO1xuICAgICAgICB0aGlzLnN0YXRlID0gNzI3O1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIGNvbnRpbnVlU3RhdGVtZW50KCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgQ29udGludWVTdGF0ZW1lbnRDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAxMTIsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX2NvbnRpbnVlU3RhdGVtZW50KTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA3Mjk7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLkNvbnRpbnVlS2V5d29yZCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA3MzA7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzEpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgYnJlYWtTdGF0ZW1lbnQoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBCcmVha1N0YXRlbWVudENvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDExNCwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfYnJlYWtTdGF0ZW1lbnQpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDczMjtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuQnJlYWtLZXl3b3JkKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDczMztcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICByZXR1cm5TdGF0ZW1lbnQoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBSZXR1cm5TdGF0ZW1lbnRDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAxMTYsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX3JldHVyblN0YXRlbWVudCk7XG4gICAgbGV0IF9sYTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA3MzU7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzUwKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDczNztcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgaWYgKChfbGEgLSA2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSA2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzUgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMTMgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjIgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjQgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjkgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzMgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzUgLSA2KSkgIT09IDAgfHwgKF9sYSAtIDM4ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSAzOCAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zNyAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNDEgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzUzIC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NCAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTUgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU2IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NyAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTggLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU5IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182MCAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjIgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzYzIC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182NCAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjUgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzY2IC0gMzgpKSAhPT0gMCB8fCAoX2xhIC0gOTYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDk2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzk1IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5JbnQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlVpbnQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkJ5dGUgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkZpeGVkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5VZml4ZWQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkJvb2xlYW5MaXRlcmFsIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5EZWNpbWFsTnVtYmVyIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5IZXhOdW1iZXIgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkhleExpdGVyYWxGcmFnbWVudCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuTGVhdmVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5QYXlhYmxlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVHlwZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkNvbnN0cnVjdG9yS2V5d29yZCAtIDk2KSkgIT09IDAgfHwgKF9sYSAtIDEyOCAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gMTI4ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlJlY2VpdmVLZXl3b3JkIC0gMTI4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuSWRlbnRpZmllciAtIDEyOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlN0cmluZ0xpdGVyYWxGcmFnbWVudCAtIDEyOCkpICE9PSAwKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDczNjtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IDczOTtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICB0aHJvd1N0YXRlbWVudCgpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IFRocm93U3RhdGVtZW50Q29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMTE4LCBfU29saWRpdHlQYXJzZXIuUlVMRV90aHJvd1N0YXRlbWVudCk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gNzQxO1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX181MSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA3NDI7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzEpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgZW1pdFN0YXRlbWVudCgpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IEVtaXRTdGF0ZW1lbnRDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAxMjAsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX2VtaXRTdGF0ZW1lbnQpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDc0NDtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fNTIpO1xuICAgICAgICB0aGlzLnN0YXRlID0gNzQ1O1xuICAgICAgICB0aGlzLmZ1bmN0aW9uQ2FsbCgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gNzQ2O1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIHJldmVydFN0YXRlbWVudCgpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IFJldmVydFN0YXRlbWVudENvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDEyMiwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfcmV2ZXJ0U3RhdGVtZW50KTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA3NDg7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzUzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDc0OTtcbiAgICAgICAgdGhpcy5mdW5jdGlvbkNhbGwoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDc1MDtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICB2YXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50KCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudENvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDEyNCwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfdmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudCk7XG4gICAgbGV0IF9sYTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA3NTk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLmludGVycHJldGVyLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwgNzksIHRoaXMuX2N0eCkpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3NTI7XG4gICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzU0KTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDc1MztcbiAgICAgICAgICAgICAgdGhpcy5pZGVudGlmaWVyTGlzdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNzU0O1xuICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlRGVjbGFyYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDc1NTtcbiAgICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMjIpO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNzU2O1xuICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KCk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3NTc7XG4gICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzIzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSA3NjM7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIGlmIChfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX18xMCkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3NjE7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xMCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNzYyO1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gNzY1O1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIHZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgVmFyaWFibGVEZWNsYXJhdGlvbkxpc3RDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAxMjYsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX3ZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KTtcbiAgICBsZXQgX2xhO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDc2ODtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgaWYgKChfbGEgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18xMyB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzI0IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjkpKSAhPT0gMCB8fCAoX2xhIC0gMzYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDM2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzM1IC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zNyAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNDEgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzUzIC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NCAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTUgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU2IC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NyAtIDM2KSkgIT09IDAgfHwgKF9sYSAtIDk2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSA5NiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX185NSAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuSW50IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5VaW50IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5CeXRlIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5GaXhlZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVWZpeGVkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5Db25zdHJ1Y3RvcktleXdvcmQgLSA5NikpICE9PSAwIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlJlY2VpdmVLZXl3b3JkIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLklkZW50aWZpZXIpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNzY3O1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZURlY2xhcmF0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSA3NzY7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIHdoaWxlIChfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX18xNSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDc3MDtcbiAgICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMTUpO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNzcyO1xuICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgICBpZiAoKF9sYSAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzEzIHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjQgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18yOSkpICE9PSAwIHx8IChfbGEgLSAzNiAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gMzYgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzUgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzM3IC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX180MSAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTMgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU0IC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NSAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTYgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU3IC0gMzYpKSAhPT0gMCB8fCAoX2xhIC0gOTYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDk2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzk1IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5JbnQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlVpbnQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkJ5dGUgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkZpeGVkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5VZml4ZWQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkxlYXZlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuUGF5YWJsZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkNvbnN0cnVjdG9yS2V5d29yZCAtIDk2KSkgIT09IDAgfHwgX2xhID09PSBfU29saWRpdHlQYXJzZXIuUmVjZWl2ZUtleXdvcmQgfHwgX2xhID09PSBfU29saWRpdHlQYXJzZXIuSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3NzE7XG4gICAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlRGVjbGFyYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IDc3ODtcbiAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIGlkZW50aWZpZXJMaXN0KCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgSWRlbnRpZmllckxpc3RDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAxMjgsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX2lkZW50aWZpZXJMaXN0KTtcbiAgICBsZXQgX2xhO1xuICAgIHRyeSB7XG4gICAgICBsZXQgX2FsdDtcbiAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gNzc5O1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18yMik7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA3ODY7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgX2FsdCA9IHRoaXMuaW50ZXJwcmV0ZXIuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LCA4NSwgdGhpcy5fY3R4KTtcbiAgICAgICAgd2hpbGUgKF9hbHQgIT09IDIgJiYgX2FsdCAhPT0gaW1wb3J0X0FUTi5BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XG4gICAgICAgICAgaWYgKF9hbHQgPT09IDEpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3ODE7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgICAgIGlmIChfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX18xMyB8fCBfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX18yNCB8fCAoX2xhIC0gMzYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDM2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzM1IC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX180MSAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTMgLSAzNikpICE9PSAwIHx8IChfbGEgLSA5NiAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gOTYgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fOTUgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkxlYXZlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuUGF5YWJsZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkNvbnN0cnVjdG9yS2V5d29yZCAtIDk2KSkgIT09IDAgfHwgX2xhID09PSBfU29saWRpdHlQYXJzZXIuUmVjZWl2ZUtleXdvcmQgfHwgX2xhID09PSBfU29saWRpdHlQYXJzZXIuSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNzgwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDc4MztcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xNSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IDc4ODtcbiAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgX2FsdCA9IHRoaXMuaW50ZXJwcmV0ZXIuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LCA4NSwgdGhpcy5fY3R4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gNzkwO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICBpZiAoX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fMTMgfHwgX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fMjQgfHwgKF9sYSAtIDM2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSAzNiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zNSAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNDEgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzUzIC0gMzYpKSAhPT0gMCB8fCAoX2xhIC0gOTYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDk2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzk1IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5Db25zdHJ1Y3RvcktleXdvcmQgLSA5NikpICE9PSAwIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlJlY2VpdmVLZXl3b3JkIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLklkZW50aWZpZXIpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNzg5O1xuICAgICAgICAgICAgdGhpcy5pZGVudGlmaWVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSA3OTI7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzIzKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIGVsZW1lbnRhcnlUeXBlTmFtZSgpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IEVsZW1lbnRhcnlUeXBlTmFtZUNvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDEzMCwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfZWxlbWVudGFyeVR5cGVOYW1lKTtcbiAgICBsZXQgX2xhO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDc5NDtcbiAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIGlmICghKChfbGEgLSAzNiAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gMzYgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzUgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU0IC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NSAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTYgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU3IC0gMzYpKSAhPT0gMCB8fCAoX2xhIC0gOTggJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDk4ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLkludCAtIDk4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVWludCAtIDk4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQnl0ZSAtIDk4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuRml4ZWQgLSA5OCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlVmaXhlZCAtIDk4KSkgIT09IDApKSB7XG4gICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVySW5saW5lKHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLl9pbnB1dC5MQSgxKSA9PT0gaW1wb3J0X1Rva2VuLlRva2VuLkVPRikge1xuICAgICAgICAgICAgdGhpcy5tYXRjaGVkRU9GID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRNYXRjaCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgZXhwcmVzc2lvbihfcCkge1xuICAgIGlmIChfcCA9PT0gdm9pZCAwKSB7XG4gICAgICBfcCA9IDA7XG4gICAgfVxuICAgIGxldCBfcGFyZW50Y3R4ID0gdGhpcy5fY3R4O1xuICAgIGxldCBfcGFyZW50U3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgRXhwcmVzc2lvbkNvbnRleHQodGhpcy5fY3R4LCBfcGFyZW50U3RhdGUpO1xuICAgIGxldCBfcHJldmN0eCA9IF9sb2NhbGN0eDtcbiAgICBsZXQgX3N0YXJ0U3RhdGUgPSAxMzI7XG4gICAgdGhpcy5lbnRlclJlY3Vyc2lvblJ1bGUoX2xvY2FsY3R4LCAxMzIsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX2V4cHJlc3Npb24sIF9wKTtcbiAgICBsZXQgX2xhO1xuICAgIHRyeSB7XG4gICAgICBsZXQgX2FsdDtcbiAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gODE0O1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5pbnRlcnByZXRlci5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsIDg3LCB0aGlzLl9jdHgpKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNzk3O1xuICAgICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX182MCk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3OTg7XG4gICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3OTk7XG4gICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzIyKTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDgwMDtcbiAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uKDApO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODAxO1xuICAgICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18yMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4MDM7XG4gICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgICBpZiAoIShfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX181OCB8fCBfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX181OSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lucHV0LkxBKDEpID09PSBpbXBvcnRfVG9rZW4uVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZWRFT0YgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4MDQ7XG4gICAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbigxOSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4MDU7XG4gICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgICBpZiAoIShfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX182MiB8fCBfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX182MykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lucHV0LkxBKDEpID09PSBpbXBvcnRfVG9rZW4uVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZWRFT0YgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4MDY7XG4gICAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbigxOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4MDc7XG4gICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgICBpZiAoIShfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX182NCB8fCBfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX182NSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lucHV0LkxBKDEpID09PSBpbXBvcnRfVG9rZW4uVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZWRFT0YgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4MDg7XG4gICAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbigxNyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4MDk7XG4gICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzY2KTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDgxMDtcbiAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uKDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDgxMTtcbiAgICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fNSk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4MTI7XG4gICAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbigxNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4MTM7XG4gICAgICAgICAgICAgIHRoaXMucHJpbWFyeUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N0eC5fc3RvcCA9IHRoaXMuX2lucHV0LnRyeUxUKC0xKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDg5MDtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBfYWx0ID0gdGhpcy5pbnRlcnByZXRlci5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsIDkxLCB0aGlzLl9jdHgpO1xuICAgICAgICB3aGlsZSAoX2FsdCAhPT0gMiAmJiBfYWx0ICE9PSBpbXBvcnRfQVROLkFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcbiAgICAgICAgICBpZiAoX2FsdCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcnNlTGlzdGVuZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXhpdFJ1bGVFdmVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3ByZXZjdHggPSBfbG9jYWxjdHg7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4ODg7XG4gICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmludGVycHJldGVyLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwgOTAsIHRoaXMuX2N0eCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIF9sb2NhbGN0eCA9IG5ldyBFeHByZXNzaW9uQ29udGV4dChfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KF9sb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX2V4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODE2O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxNCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbihcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxNClcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDgxNztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fNjcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODE4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24oMTUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBfbG9jYWxjdHggPSBuZXcgRXhwcmVzc2lvbkNvbnRleHQoX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChfbG9jYWxjdHgsIF9zdGFydFN0YXRlLCBfU29saWRpdHlQYXJzZXIuUlVMRV9leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDgxOTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMTMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24oXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMTMpXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4MjA7XG4gICAgICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX18yIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlRfXzY4IHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlRfXzY5KSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3ZlcklubGluZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5wdXQuTEEoMSkgPT09IGltcG9ydF9Ub2tlbi5Ub2tlbi5FT0YpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlZEVPRiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDgyMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uKDE0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgX2xvY2FsY3R4ID0gbmV3IEV4cHJlc3Npb25Db250ZXh0KF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQoX2xvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4MjI7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEyKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuY3JlYXRlRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKFwidGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEyKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODIzO1xuICAgICAgICAgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fNjIgfHwgX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fNjMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVySW5saW5lKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnB1dC5MQSgxKSA9PT0gaW1wb3J0X1Rva2VuLlRva2VuLkVPRikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVkRU9GID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRNYXRjaCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODI0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24oMTMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBfbG9jYWxjdHggPSBuZXcgRXhwcmVzc2lvbkNvbnRleHQoX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChfbG9jYWxjdHgsIF9zdGFydFN0YXRlLCBfU29saWRpdHlQYXJzZXIuUlVMRV9leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDgyNTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMTEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24oXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMTEpXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4MjY7XG4gICAgICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX183MCB8fCBfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX183MSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lucHV0LkxBKDEpID09PSBpbXBvcnRfVG9rZW4uVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZWRFT0YgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4Mjc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbigxMik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIF9sb2NhbGN0eCA9IG5ldyBFeHByZXNzaW9uQ29udGV4dChfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KF9sb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX2V4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODI4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbihcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxMClcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDgyOTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fNzIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODMwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24oMTEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBfbG9jYWxjdHggPSBuZXcgRXhwcmVzc2lvbkNvbnRleHQoX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChfbG9jYWxjdHgsIF9zdGFydFN0YXRlLCBfU29saWRpdHlQYXJzZXIuUlVMRV9leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDgzMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgOSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbihcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA5KVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODMyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX180KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDgzMztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uKDEwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgX2xvY2FsY3R4ID0gbmV3IEV4cHJlc3Npb25Db250ZXh0KF9wYXJlbnRjdHgsIF9wYXJlbnRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQoX2xvY2FsY3R4LCBfc3RhcnRTdGF0ZSwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4MzQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24oXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgOClcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDgzNTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fNzMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODM2O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24oOSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIF9sb2NhbGN0eCA9IG5ldyBFeHByZXNzaW9uQ29udGV4dChfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KF9sb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX2V4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODM3O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA3KSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuY3JlYXRlRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKFwidGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDcpXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4Mzg7XG4gICAgICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgoX2xhICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzcgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX184IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fOSkpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3ZlcklubGluZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5wdXQuTEEoMSkgPT09IGltcG9ydF9Ub2tlbi5Ub2tlbi5FT0YpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlZEVPRiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDgzOTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uKDgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBfbG9jYWxjdHggPSBuZXcgRXhwcmVzc2lvbkNvbnRleHQoX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChfbG9jYWxjdHgsIF9zdGFydFN0YXRlLCBfU29saWRpdHlQYXJzZXIuUlVMRV9leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg0MDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgNikpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbihcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA2KVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODQxO1xuICAgICAgICAgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fNzQgfHwgX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fNzUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVySW5saW5lKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnB1dC5MQSgxKSA9PT0gaW1wb3J0X1Rva2VuLlRva2VuLkVPRikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVkRU9GID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRNYXRjaCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODQyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24oNyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBfbG9jYWxjdHggPSBuZXcgRXhwcmVzc2lvbkNvbnRleHQoX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChfbG9jYWxjdHgsIF9zdGFydFN0YXRlLCBfU29saWRpdHlQYXJzZXIuUlVMRV9leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg0MztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgNSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbihcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA1KVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODQ0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX183Nik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4NDU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbig2KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIF9sb2NhbGN0eCA9IG5ldyBFeHByZXNzaW9uQ29udGV4dChfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KF9sb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX2V4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODQ2O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA0KSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuY3JlYXRlRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uKFwidGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDQpXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4NDc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODQ4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24oNSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBfbG9jYWxjdHggPSBuZXcgRXhwcmVzc2lvbkNvbnRleHQoX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChfbG9jYWxjdHgsIF9zdGFydFN0YXRlLCBfU29saWRpdHlQYXJzZXIuUlVMRV9leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg0OTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMykpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbihcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAzKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODUwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX183Nyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4NTE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg1MjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fNjEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODUzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24oNCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBfbG9jYWxjdHggPSBuZXcgRXhwcmVzc2lvbkNvbnRleHQoX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChfbG9jYWxjdHgsIF9zdGFydFN0YXRlLCBfU29saWRpdHlQYXJzZXIuUlVMRV9leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg1NTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbihcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAyKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODU2O1xuICAgICAgICAgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fMTAgfHwgKF9sYSAtIDc5ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSA3OSAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX183OCAtIDc5IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNzkgLSA3OSB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzgwIC0gNzkgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX184MSAtIDc5IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fODIgLSA3OSB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzgzIC0gNzkgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX184NCAtIDc5IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fODUgLSA3OSB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzg2IC0gNzkgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX184NyAtIDc5KSkgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVySW5saW5lKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnB1dC5MQSgxKSA9PT0gaW1wb3J0X1Rva2VuLlRva2VuLkVPRikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVkRU9GID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRNYXRjaCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODU3O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24oMyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBfbG9jYWxjdHggPSBuZXcgRXhwcmVzc2lvbkNvbnRleHQoX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChfbG9jYWxjdHgsIF9zdGFydFN0YXRlLCBfU29saWRpdHlQYXJzZXIuUlVMRV9leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg1ODtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMjcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24oXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMjcpXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4NTk7XG4gICAgICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX181OCB8fCBfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX181OSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lucHV0LkxBKDEpID09PSBpbXBvcnRfVG9rZW4uVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZWRFT0YgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBfbG9jYWxjdHggPSBuZXcgRXhwcmVzc2lvbkNvbnRleHQoX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChfbG9jYWxjdHgsIF9zdGFydFN0YXRlLCBfU29saWRpdHlQYXJzZXIuUlVMRV9leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg2MDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMjUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24oXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMjUpXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4NjE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzMzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg2MjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uKDApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODYzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18zNCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBfbG9jYWxjdHggPSBuZXcgRXhwcmVzc2lvbkNvbnRleHQoX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChfbG9jYWxjdHgsIF9zdGFydFN0YXRlLCBfU29saWRpdHlQYXJzZXIuUlVMRV9leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg2NTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMjQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24oXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMjQpXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4NjY7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzMzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg2ODtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChfbGEgLSA2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSA2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzUgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMTMgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjIgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjQgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjkgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzMgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzUgLSA2KSkgIT09IDAgfHwgKF9sYSAtIDM4ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSAzOCAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zNyAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNDEgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzUzIC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NCAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTUgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU2IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NyAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTggLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU5IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182MCAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjIgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzYzIC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182NCAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjUgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzY2IC0gMzgpKSAhPT0gMCB8fCAoX2xhIC0gOTYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDk2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzk1IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5JbnQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlVpbnQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkJ5dGUgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkZpeGVkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5VZml4ZWQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkJvb2xlYW5MaXRlcmFsIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5EZWNpbWFsTnVtYmVyIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5IZXhOdW1iZXIgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkhleExpdGVyYWxGcmFnbWVudCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuTGVhdmVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5QYXlhYmxlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVHlwZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkNvbnN0cnVjdG9yS2V5d29yZCAtIDk2KSkgIT09IDAgfHwgKF9sYSAtIDEyOCAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gMTI4ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlJlY2VpdmVLZXl3b3JkIC0gMTI4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuSWRlbnRpZmllciAtIDEyOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlN0cmluZ0xpdGVyYWxGcmFnbWVudCAtIDEyOCkpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg2NztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg3MDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fNjEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODcyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKF9sYSAtIDYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDYgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNSAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18xMyAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18yMiAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18yNCAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18yOSAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zMyAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zNSAtIDYpKSAhPT0gMCB8fCAoX2xhIC0gMzggJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDM4ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzM3IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX180MSAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTMgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU0IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NSAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTYgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU3IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181OCAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTkgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzYwIC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182MiAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjMgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzY0IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182NSAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjYgLSAzOCkpICE9PSAwIHx8IChfbGEgLSA5NiAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gOTYgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fOTUgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkludCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVWludCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQnl0ZSAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuRml4ZWQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlVmaXhlZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQm9vbGVhbkxpdGVyYWwgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkRlY2ltYWxOdW1iZXIgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkhleE51bWJlciAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuSGV4TGl0ZXJhbEZyYWdtZW50IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UeXBlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQ29uc3RydWN0b3JLZXl3b3JkIC0gOTYpKSAhPT0gMCB8fCAoX2xhIC0gMTI4ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSAxMjggJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuUmVjZWl2ZUtleXdvcmQgLSAxMjggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5JZGVudGlmaWVyIC0gMTI4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuU3RyaW5nTGl0ZXJhbEZyYWdtZW50IC0gMTI4KSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODcxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uKDApO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODc0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18zNCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBfbG9jYWxjdHggPSBuZXcgRXhwcmVzc2lvbkNvbnRleHQoX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChfbG9jYWxjdHgsIF9zdGFydFN0YXRlLCBfU29saWRpdHlQYXJzZXIuUlVMRV9leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg3NTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMjMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24oXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMjMpXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4NzY7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzM2KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg3NztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pZGVudGlmaWVyKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBfbG9jYWxjdHggPSBuZXcgRXhwcmVzc2lvbkNvbnRleHQoX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChfbG9jYWxjdHgsIF9zdGFydFN0YXRlLCBfU29saWRpdHlQYXJzZXIuUlVMRV9leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg3ODtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMjIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24oXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMjIpXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4Nzk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzE0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg4MDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lVmFsdWVMaXN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4ODE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzE2KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIF9sb2NhbGN0eCA9IG5ldyBFeHByZXNzaW9uQ29udGV4dChfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0KF9sb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX2V4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODgzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAyMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbihcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAyMSlcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg4NDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMjIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODg1O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZ1bmN0aW9uQ2FsbEFyZ3VtZW50cygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gODg2O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18yMyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YXRlID0gODkyO1xuICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgICBfYWx0ID0gdGhpcy5pbnRlcnByZXRlci5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsIDkxLCB0aGlzLl9jdHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMudW5yb2xsUmVjdXJzaW9uQ29udGV4dHMoX3BhcmVudGN0eCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgcHJpbWFyeUV4cHJlc3Npb24oKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBQcmltYXJ5RXhwcmVzc2lvbkNvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDEzNCwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfcHJpbWFyeUV4cHJlc3Npb24pO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnN0YXRlID0gOTAyO1xuICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgc3dpdGNoICh0aGlzLmludGVycHJldGVyLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwgOTIsIHRoaXMuX2N0eCkpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4OTM7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5Cb29sZWFuTGl0ZXJhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMik7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg5NDtcbiAgICAgICAgICAgIHRoaXMubnVtYmVyTGl0ZXJhbCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDMpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4OTU7XG4gICAgICAgICAgICB0aGlzLmhleExpdGVyYWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCA0KTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gODk2O1xuICAgICAgICAgICAgdGhpcy5zdHJpbmdMaXRlcmFsKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgNSk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg5NztcbiAgICAgICAgICAgIHRoaXMuaWRlbnRpZmllcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDYpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4OTg7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UeXBlS2V5d29yZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgNyk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg5OTtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCA4KTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gOTAwO1xuICAgICAgICAgICAgdGhpcy50dXBsZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCA5KTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gOTAxO1xuICAgICAgICAgICAgdGhpcy50eXBlTmFtZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBleHByZXNzaW9uTGlzdCgpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IEV4cHJlc3Npb25MaXN0Q29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMTM2LCBfU29saWRpdHlQYXJzZXIuUlVMRV9leHByZXNzaW9uTGlzdCk7XG4gICAgbGV0IF9sYTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA5MDQ7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDkwOTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgd2hpbGUgKF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlRfXzE1KSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTA1O1xuICAgICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xNSk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5MDY7XG4gICAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IDkxMTtcbiAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIG5hbWVWYWx1ZUxpc3QoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBOYW1lVmFsdWVMaXN0Q29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMTM4LCBfU29saWRpdHlQYXJzZXIuUlVMRV9uYW1lVmFsdWVMaXN0KTtcbiAgICBsZXQgX2xhO1xuICAgIHRyeSB7XG4gICAgICBsZXQgX2FsdDtcbiAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gOTEyO1xuICAgICAgICB0aGlzLm5hbWVWYWx1ZSgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gOTE3O1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgIF9hbHQgPSB0aGlzLmludGVycHJldGVyLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwgOTQsIHRoaXMuX2N0eCk7XG4gICAgICAgIHdoaWxlIChfYWx0ICE9PSAyICYmIF9hbHQgIT09IGltcG9ydF9BVE4uQVROLklOVkFMSURfQUxUX05VTUJFUikge1xuICAgICAgICAgIGlmIChfYWx0ID09PSAxKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTEzO1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzE1KTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTE0O1xuICAgICAgICAgICAgICAgIHRoaXMubmFtZVZhbHVlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IDkxOTtcbiAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgX2FsdCA9IHRoaXMuaW50ZXJwcmV0ZXIuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LCA5NCwgdGhpcy5fY3R4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gOTIxO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICBpZiAoX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fMTUpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gOTIwO1xuICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMTUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgbmFtZVZhbHVlKCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgTmFtZVZhbHVlQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMTQwLCBfU29saWRpdHlQYXJzZXIuUlVMRV9uYW1lVmFsdWUpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDkyMztcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA5MjQ7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzYxKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDkyNTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uKDApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgZnVuY3Rpb25DYWxsQXJndW1lbnRzKCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgRnVuY3Rpb25DYWxsQXJndW1lbnRzQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMTQyLCBfU29saWRpdHlQYXJzZXIuUlVMRV9mdW5jdGlvbkNhbGxBcmd1bWVudHMpO1xuICAgIGxldCBfbGE7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc3RhdGUgPSA5MzU7XG4gICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICBzd2l0Y2ggKHRoaXMuX2lucHV0LkxBKDEpKSB7XG4gICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzE0OlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5Mjc7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xNCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gOTI5O1xuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgICAgICBpZiAoX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fMTMgfHwgX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fMjQgfHwgKF9sYSAtIDM2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSAzNiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zNSAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNDEgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzUzIC0gMzYpKSAhPT0gMCB8fCAoX2xhIC0gOTYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDk2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzk1IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5Db25zdHJ1Y3RvcktleXdvcmQgLSA5NikpICE9PSAwIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlJlY2VpdmVLZXl3b3JkIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5Mjg7XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lVmFsdWVMaXN0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5MzE7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xNik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5UX181OlxuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5UX18xMzpcbiAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fMjI6XG4gICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzIzOlxuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5UX18yNDpcbiAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fMjk6XG4gICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzMzOlxuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5UX18zNTpcbiAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fMzc6XG4gICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzQxOlxuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5UX181MzpcbiAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fNTQ6XG4gICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzU1OlxuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5UX181NjpcbiAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fNTc6XG4gICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzU4OlxuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5UX181OTpcbiAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fNjA6XG4gICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzYyOlxuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5UX182MzpcbiAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fNjQ6XG4gICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzY1OlxuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5UX182NjpcbiAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fOTU6XG4gICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkludDpcbiAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVWludDpcbiAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuQnl0ZTpcbiAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuRml4ZWQ6XG4gICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlVmaXhlZDpcbiAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuQm9vbGVhbkxpdGVyYWw6XG4gICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkRlY2ltYWxOdW1iZXI6XG4gICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkhleE51bWJlcjpcbiAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuSGV4TGl0ZXJhbEZyYWdtZW50OlxuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQ6XG4gICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkOlxuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5UeXBlS2V5d29yZDpcbiAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuQ29uc3RydWN0b3JLZXl3b3JkOlxuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5SZWNlaXZlS2V5d29yZDpcbiAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuSWRlbnRpZmllcjpcbiAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuU3RyaW5nTGl0ZXJhbEZyYWdtZW50OlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDIpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5MzM7XG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgICAgIGlmICgoX2xhIC0gNiAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gNiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181IC0gNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzEzIC0gNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzIyIC0gNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzI0IC0gNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzI5IC0gNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzMzIC0gNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzM1IC0gNikpICE9PSAwIHx8IChfbGEgLSAzOCAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gMzggJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzcgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzQxIC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181MyAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTQgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU1IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NiAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTcgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU4IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181OSAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjAgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzYyIC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182MyAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjQgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzY1IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182NiAtIDM4KSkgIT09IDAgfHwgKF9sYSAtIDk2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSA5NiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX185NSAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuSW50IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5VaW50IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5CeXRlIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5GaXhlZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVWZpeGVkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5Cb29sZWFuTGl0ZXJhbCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuRGVjaW1hbE51bWJlciAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuSGV4TnVtYmVyIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5IZXhMaXRlcmFsRnJhZ21lbnQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkxlYXZlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuUGF5YWJsZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlR5cGVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5Db25zdHJ1Y3RvcktleXdvcmQgLSA5NikpICE9PSAwIHx8IChfbGEgLSAxMjggJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDEyOCAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5SZWNlaXZlS2V5d29yZCAtIDEyOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLklkZW50aWZpZXIgLSAxMjggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5TdHJpbmdMaXRlcmFsRnJhZ21lbnQgLSAxMjgpKSAhPT0gMCkge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDkzMjtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25MaXN0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IGltcG9ydF9Ob1ZpYWJsZUFsdEV4Y2VwdGlvbi5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbih0aGlzKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIGZ1bmN0aW9uQ2FsbCgpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IEZ1bmN0aW9uQ2FsbENvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDE0NCwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfZnVuY3Rpb25DYWxsKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA5Mzc7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDkzODtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMjIpO1xuICAgICAgICB0aGlzLnN0YXRlID0gOTM5O1xuICAgICAgICB0aGlzLmZ1bmN0aW9uQ2FsbEFyZ3VtZW50cygpO1xuICAgICAgICB0aGlzLnN0YXRlID0gOTQwO1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18yMyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBhc3NlbWJseUJsb2NrKCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgQXNzZW1ibHlCbG9ja0NvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDE0NiwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfYXNzZW1ibHlCbG9jayk7XG4gICAgbGV0IF9sYTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA5NDI7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzE0KTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDk0NjtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgd2hpbGUgKChfbGEgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18xMyB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzE0IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjIgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18yNCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzI2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjkpKSAhPT0gMCB8fCAoX2xhIC0gMzYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDM2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzM1IC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX180MSAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNDIgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzQ4IC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181MCAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTMgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU3IC0gMzYpKSAhPT0gMCB8fCAoX2xhIC0gODkgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDg5ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzg4IC0gODkgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX185MSAtIDg5IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fOTUgLSA4OSB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkJvb2xlYW5MaXRlcmFsIC0gODkgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5EZWNpbWFsTnVtYmVyIC0gODkgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5IZXhOdW1iZXIgLSA4OSB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkhleExpdGVyYWxGcmFnbWVudCAtIDg5IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQnJlYWtLZXl3b3JkIC0gODkgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5Db250aW51ZUtleXdvcmQgLSA4OSB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkxlYXZlS2V5d29yZCAtIDg5IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuUGF5YWJsZUtleXdvcmQgLSA4OSkpICE9PSAwIHx8IChfbGEgLSAxMjYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDEyNiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5Db25zdHJ1Y3RvcktleXdvcmQgLSAxMjYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5SZWNlaXZlS2V5d29yZCAtIDEyNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLklkZW50aWZpZXIgLSAxMjYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5TdHJpbmdMaXRlcmFsRnJhZ21lbnQgLSAxMjYpKSAhPT0gMCkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk0MztcbiAgICAgICAgICAgICAgdGhpcy5hc3NlbWJseUl0ZW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IDk0ODtcbiAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IDk0OTtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMTYpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgYXNzZW1ibHlJdGVtKCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgQXNzZW1ibHlJdGVtQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMTQ4LCBfU29saWRpdHlQYXJzZXIuUlVMRV9hc3NlbWJseUl0ZW0pO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnN0YXRlID0gOTY5O1xuICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgc3dpdGNoICh0aGlzLmludGVycHJldGVyLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwgMTAwLCB0aGlzLl9jdHgpKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gOTUxO1xuICAgICAgICAgICAgdGhpcy5pZGVudGlmaWVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMik7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk1MjtcbiAgICAgICAgICAgIHRoaXMuYXNzZW1ibHlCbG9jaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDMpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5NTM7XG4gICAgICAgICAgICB0aGlzLmFzc2VtYmx5RXhwcmVzc2lvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDQpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5NTQ7XG4gICAgICAgICAgICB0aGlzLmFzc2VtYmx5TG9jYWxEZWZpbml0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgNSk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk1NTtcbiAgICAgICAgICAgIHRoaXMuYXNzZW1ibHlBc3NpZ25tZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgNik7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk1NjtcbiAgICAgICAgICAgIHRoaXMuYXNzZW1ibHlTdGFja0Fzc2lnbm1lbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCA3KTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gOTU3O1xuICAgICAgICAgICAgdGhpcy5sYWJlbERlZmluaXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCA4KTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gOTU4O1xuICAgICAgICAgICAgdGhpcy5hc3NlbWJseVN3aXRjaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDkpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5NTk7XG4gICAgICAgICAgICB0aGlzLmFzc2VtYmx5RnVuY3Rpb25EZWZpbml0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEwKTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gOTYwO1xuICAgICAgICAgICAgdGhpcy5hc3NlbWJseUZvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxMSk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk2MTtcbiAgICAgICAgICAgIHRoaXMuYXNzZW1ibHlJZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxMik7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk2MjtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLkJyZWFrS2V5d29yZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEzKTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gOTYzO1xuICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuQ29udGludWVLZXl3b3JkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMTQpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5NjQ7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxNSk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk2NTtcbiAgICAgICAgICAgIHRoaXMuc3ViQXNzZW1ibHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMTYpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5NjY7XG4gICAgICAgICAgICB0aGlzLm51bWJlckxpdGVyYWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMTcpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5Njc7XG4gICAgICAgICAgICB0aGlzLnN0cmluZ0xpdGVyYWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMTgpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5Njg7XG4gICAgICAgICAgICB0aGlzLmhleExpdGVyYWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBhc3NlbWJseUV4cHJlc3Npb24oKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBBc3NlbWJseUV4cHJlc3Npb25Db250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAxNTAsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX2Fzc2VtYmx5RXhwcmVzc2lvbik7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc3RhdGUgPSA5NzQ7XG4gICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICBzd2l0Y2ggKHRoaXMuaW50ZXJwcmV0ZXIuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LCAxMDEsIHRoaXMuX2N0eCkpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5NzE7XG4gICAgICAgICAgICB0aGlzLmFzc2VtYmx5Q2FsbCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDIpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5NzI7XG4gICAgICAgICAgICB0aGlzLmFzc2VtYmx5TGl0ZXJhbCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDMpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5NzM7XG4gICAgICAgICAgICB0aGlzLmFzc2VtYmx5TWVtYmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgYXNzZW1ibHlNZW1iZXIoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBBc3NlbWJseU1lbWJlckNvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDE1MiwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfYXNzZW1ibHlNZW1iZXIpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDk3NjtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA5Nzc7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzM2KTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDk3ODtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBhc3NlbWJseUNhbGwoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBBc3NlbWJseUNhbGxDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAxNTQsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX2Fzc2VtYmx5Q2FsbCk7XG4gICAgbGV0IF9sYTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA5ODQ7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLmludGVycHJldGVyLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwgMTAyLCB0aGlzLl9jdHgpKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTgwO1xuICAgICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX181MCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5ODE7XG4gICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzM1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk4MjtcbiAgICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fNTcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTgzO1xuICAgICAgICAgICAgICB0aGlzLmlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSA5OTg7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLmludGVycHJldGVyLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwgMTA1LCB0aGlzLl9jdHgpKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTg2O1xuICAgICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18yMik7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5ODg7XG4gICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgICAgICAgIGlmIChfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX18xMyB8fCBfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX18yNCB8fCAoX2xhIC0gMzYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDM2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzM1IC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX180MSAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTAgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzUzIC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NyAtIDM2KSkgIT09IDAgfHwgKF9sYSAtIDk2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSA5NiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX185NSAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQm9vbGVhbkxpdGVyYWwgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkRlY2ltYWxOdW1iZXIgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkhleE51bWJlciAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuSGV4TGl0ZXJhbEZyYWdtZW50IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5Db25zdHJ1Y3RvcktleXdvcmQgLSA5NikpICE9PSAwIHx8IChfbGEgLSAxMjggJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDEyOCAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5SZWNlaXZlS2V5d29yZCAtIDEyOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLklkZW50aWZpZXIgLSAxMjggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5TdHJpbmdMaXRlcmFsRnJhZ21lbnQgLSAxMjgpKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5ODc7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFzc2VtYmx5RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gOTk0O1xuICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgICB3aGlsZSAoX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fMTUpIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5OTA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzE1KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk5MTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hc3NlbWJseUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk5NjtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk5NztcbiAgICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMjMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIGFzc2VtYmx5TG9jYWxEZWZpbml0aW9uKCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgQXNzZW1ibHlMb2NhbERlZmluaXRpb25Db250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAxNTYsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX2Fzc2VtYmx5TG9jYWxEZWZpbml0aW9uKTtcbiAgICBsZXQgX2xhO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDFlMztcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fODgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gMTAwMTtcbiAgICAgICAgdGhpcy5hc3NlbWJseUlkZW50aWZpZXJPckxpc3QoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMDQ7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIGlmIChfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX184OSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDAyO1xuICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fODkpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMDM7XG4gICAgICAgICAgICB0aGlzLmFzc2VtYmx5RXhwcmVzc2lvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgYXNzZW1ibHlBc3NpZ25tZW50KCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgQXNzZW1ibHlBc3NpZ25tZW50Q29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMTU4LCBfU29saWRpdHlQYXJzZXIuUlVMRV9hc3NlbWJseUFzc2lnbm1lbnQpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMDY7XG4gICAgICAgIHRoaXMuYXNzZW1ibHlJZGVudGlmaWVyT3JMaXN0KCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMDA3O1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX184OSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMDA4O1xuICAgICAgICB0aGlzLmFzc2VtYmx5RXhwcmVzc2lvbigpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgYXNzZW1ibHlJZGVudGlmaWVyT3JMaXN0KCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgQXNzZW1ibHlJZGVudGlmaWVyT3JMaXN0Q29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMTYwLCBfU29saWRpdHlQYXJzZXIuUlVMRV9hc3NlbWJseUlkZW50aWZpZXJPckxpc3QpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnN0YXRlID0gMTAxNztcbiAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgIHN3aXRjaCAodGhpcy5pbnRlcnByZXRlci5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsIDEwNywgdGhpcy5fY3R4KSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMTA7XG4gICAgICAgICAgICB0aGlzLmlkZW50aWZpZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAyKTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTAxMTtcbiAgICAgICAgICAgIHRoaXMuYXNzZW1ibHlNZW1iZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAzKTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTAxMjtcbiAgICAgICAgICAgIHRoaXMuYXNzZW1ibHlJZGVudGlmaWVyTGlzdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDQpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDEzO1xuICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMjIpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMTQ7XG4gICAgICAgICAgICB0aGlzLmFzc2VtYmx5SWRlbnRpZmllckxpc3QoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDE1O1xuICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMjMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIGFzc2VtYmx5SWRlbnRpZmllckxpc3QoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBBc3NlbWJseUlkZW50aWZpZXJMaXN0Q29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMTYyLCBfU29saWRpdHlQYXJzZXIuUlVMRV9hc3NlbWJseUlkZW50aWZpZXJMaXN0KTtcbiAgICBsZXQgX2xhO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMTk7XG4gICAgICAgIHRoaXMuaWRlbnRpZmllcigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gMTAyNDtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgd2hpbGUgKF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlRfXzE1KSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTAyMDtcbiAgICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMTUpO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTAyMTtcbiAgICAgICAgICAgICAgdGhpcy5pZGVudGlmaWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDI2O1xuICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgYXNzZW1ibHlTdGFja0Fzc2lnbm1lbnQoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBBc3NlbWJseVN0YWNrQXNzaWdubWVudENvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDE2NCwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfYXNzZW1ibHlTdGFja0Fzc2lnbm1lbnQpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMjc7XG4gICAgICAgIHRoaXMuYXNzZW1ibHlFeHByZXNzaW9uKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMDI4O1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX185MCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMDI5O1xuICAgICAgICB0aGlzLmlkZW50aWZpZXIoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIGxhYmVsRGVmaW5pdGlvbigpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IExhYmVsRGVmaW5pdGlvbkNvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDE2NiwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfbGFiZWxEZWZpbml0aW9uKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMDMxO1xuICAgICAgICB0aGlzLmlkZW50aWZpZXIoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMzI7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzYxKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIGFzc2VtYmx5U3dpdGNoKCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgQXNzZW1ibHlTd2l0Y2hDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAxNjgsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX2Fzc2VtYmx5U3dpdGNoKTtcbiAgICBsZXQgX2xhO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMzQ7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzkxKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMzU7XG4gICAgICAgIHRoaXMuYXNzZW1ibHlFeHByZXNzaW9uKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMDM5O1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICB3aGlsZSAoX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fOTIgfHwgX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fOTMpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDM2O1xuICAgICAgICAgICAgICB0aGlzLmFzc2VtYmx5Q2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YXRlID0gMTA0MTtcbiAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIGFzc2VtYmx5Q2FzZSgpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IEFzc2VtYmx5Q2FzZUNvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDE3MCwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfYXNzZW1ibHlDYXNlKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5zdGF0ZSA9IDEwNDg7XG4gICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICBzd2l0Y2ggKHRoaXMuX2lucHV0LkxBKDEpKSB7XG4gICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzkyOlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDQyO1xuICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fOTIpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwNDM7XG4gICAgICAgICAgICB0aGlzLmFzc2VtYmx5TGl0ZXJhbCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwNDQ7XG4gICAgICAgICAgICB0aGlzLmFzc2VtYmx5QmxvY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzkzOlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDIpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDQ2O1xuICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fOTMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwNDc7XG4gICAgICAgICAgICB0aGlzLmFzc2VtYmx5QmxvY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IGltcG9ydF9Ob1ZpYWJsZUFsdEV4Y2VwdGlvbi5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbih0aGlzKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIGFzc2VtYmx5RnVuY3Rpb25EZWZpbml0aW9uKCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgQXNzZW1ibHlGdW5jdGlvbkRlZmluaXRpb25Db250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAxNzIsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX2Fzc2VtYmx5RnVuY3Rpb25EZWZpbml0aW9uKTtcbiAgICBsZXQgX2xhO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEwNTA7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzI5KTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEwNTE7XG4gICAgICAgIHRoaXMuaWRlbnRpZmllcigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gMTA1MjtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMjIpO1xuICAgICAgICB0aGlzLnN0YXRlID0gMTA1NDtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgaWYgKF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlRfXzEzIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlRfXzI0IHx8IChfbGEgLSAzNiAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gMzYgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzUgLSAzNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzQxIC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181MyAtIDM2KSkgIT09IDAgfHwgKF9sYSAtIDk2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSA5NiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX185NSAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuTGVhdmVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5QYXlhYmxlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQ29uc3RydWN0b3JLZXl3b3JkIC0gOTYpKSAhPT0gMCB8fCBfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5SZWNlaXZlS2V5d29yZCB8fCBfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5JZGVudGlmaWVyKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwNTM7XG4gICAgICAgICAgICB0aGlzLmFzc2VtYmx5SWRlbnRpZmllckxpc3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEwNTY7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzIzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEwNTg7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgIGlmIChfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX185NCkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDU3O1xuICAgICAgICAgICAgdGhpcy5hc3NlbWJseUZ1bmN0aW9uUmV0dXJucygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gMTA2MDtcbiAgICAgICAgdGhpcy5hc3NlbWJseUJsb2NrKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBhc3NlbWJseUZ1bmN0aW9uUmV0dXJucygpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IEFzc2VtYmx5RnVuY3Rpb25SZXR1cm5zQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMTc0LCBfU29saWRpdHlQYXJzZXIuUlVMRV9hc3NlbWJseUZ1bmN0aW9uUmV0dXJucyk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwNjI7XG4gICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fOTQpO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDYzO1xuICAgICAgICAgIHRoaXMuYXNzZW1ibHlJZGVudGlmaWVyTGlzdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBhc3NlbWJseUZvcigpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IEFzc2VtYmx5Rm9yQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMTc2LCBfU29saWRpdHlQYXJzZXIuUlVMRV9hc3NlbWJseUZvcik7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gMTA2NTtcbiAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMjYpO1xuICAgICAgICB0aGlzLnN0YXRlID0gMTA2ODtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2lucHV0LkxBKDEpKSB7XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fMTQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDY2O1xuICAgICAgICAgICAgICB0aGlzLmFzc2VtYmx5QmxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzEzOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzI0OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzM1OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzQxOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzUwOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzUzOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzU3OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzk1OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkJvb2xlYW5MaXRlcmFsOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkRlY2ltYWxOdW1iZXI6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuSGV4TnVtYmVyOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkhleExpdGVyYWxGcmFnbWVudDpcbiAgICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQ6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuUGF5YWJsZUtleXdvcmQ6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuQ29uc3RydWN0b3JLZXl3b3JkOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlJlY2VpdmVLZXl3b3JkOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLklkZW50aWZpZXI6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuU3RyaW5nTGl0ZXJhbEZyYWdtZW50OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTA2NztcbiAgICAgICAgICAgICAgdGhpcy5hc3NlbWJseUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgaW1wb3J0X05vVmlhYmxlQWx0RXhjZXB0aW9uLk5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMDcwO1xuICAgICAgICB0aGlzLmFzc2VtYmx5RXhwcmVzc2lvbigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gMTA3MztcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2lucHV0LkxBKDEpKSB7XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuVF9fMTQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDcxO1xuICAgICAgICAgICAgICB0aGlzLmFzc2VtYmx5QmxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzEzOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzI0OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzM1OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzQxOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzUwOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzUzOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzU3OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzk1OlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkJvb2xlYW5MaXRlcmFsOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkRlY2ltYWxOdW1iZXI6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuSGV4TnVtYmVyOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkhleExpdGVyYWxGcmFnbWVudDpcbiAgICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQ6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuUGF5YWJsZUtleXdvcmQ6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuQ29uc3RydWN0b3JLZXl3b3JkOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlJlY2VpdmVLZXl3b3JkOlxuICAgICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLklkZW50aWZpZXI6XG4gICAgICAgICAgY2FzZSBfU29saWRpdHlQYXJzZXIuU3RyaW5nTGl0ZXJhbEZyYWdtZW50OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTA3MjtcbiAgICAgICAgICAgICAgdGhpcy5hc3NlbWJseUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgaW1wb3J0X05vVmlhYmxlQWx0RXhjZXB0aW9uLk5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMDc1O1xuICAgICAgICB0aGlzLmFzc2VtYmx5QmxvY2soKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIGFzc2VtYmx5SWYoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBBc3NlbWJseUlmQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMTc4LCBfU29saWRpdHlQYXJzZXIuUlVMRV9hc3NlbWJseUlmKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMDc3O1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX180Mik7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMDc4O1xuICAgICAgICB0aGlzLmFzc2VtYmx5RXhwcmVzc2lvbigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gMTA3OTtcbiAgICAgICAgdGhpcy5hc3NlbWJseUJsb2NrKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBhc3NlbWJseUxpdGVyYWwoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBBc3NlbWJseUxpdGVyYWxDb250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAxODAsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX2Fzc2VtYmx5TGl0ZXJhbCk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc3RhdGUgPSAxMDg2O1xuICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgc3dpdGNoICh0aGlzLl9pbnB1dC5MQSgxKSkge1xuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5TdHJpbmdMaXRlcmFsRnJhZ21lbnQ6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwODE7XG4gICAgICAgICAgICB0aGlzLnN0cmluZ0xpdGVyYWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkRlY2ltYWxOdW1iZXI6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMik7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwODI7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5EZWNpbWFsTnVtYmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkhleE51bWJlcjpcbiAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAzKTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTA4MztcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLkhleE51bWJlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF9Tb2xpZGl0eVBhcnNlci5IZXhMaXRlcmFsRnJhZ21lbnQ6XG4gICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgNCk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwODQ7XG4gICAgICAgICAgICB0aGlzLmhleExpdGVyYWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLkJvb2xlYW5MaXRlcmFsOlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDUpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDg1O1xuICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuQm9vbGVhbkxpdGVyYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgaW1wb3J0X05vVmlhYmxlQWx0RXhjZXB0aW9uLk5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHJlKSB7XG4gICAgICBpZiAocmUgaW5zdGFuY2VvZiBpbXBvcnRfUmVjb2duaXRpb25FeGNlcHRpb24uUmVjb2duaXRpb25FeGNlcHRpb24pIHtcbiAgICAgICAgX2xvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmV4aXRSdWxlKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxjdHg7XG4gIH1cbiAgc3ViQXNzZW1ibHkoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBTdWJBc3NlbWJseUNvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDE4MiwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfc3ViQXNzZW1ibHkpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEwODg7XG4gICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzQ4KTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEwODk7XG4gICAgICAgIHRoaXMuaWRlbnRpZmllcigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gMTA5MDtcbiAgICAgICAgdGhpcy5hc3NlbWJseUJsb2NrKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICB0dXBsZUV4cHJlc3Npb24oKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBUdXBsZUV4cHJlc3Npb25Db250ZXh0KHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5lbnRlclJ1bGUoX2xvY2FsY3R4LCAxODQsIF9Tb2xpZGl0eVBhcnNlci5SVUxFX3R1cGxlRXhwcmVzc2lvbik7XG4gICAgbGV0IF9sYTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5zdGF0ZSA9IDExMTg7XG4gICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICBzd2l0Y2ggKHRoaXMuX2lucHV0LkxBKDEpKSB7XG4gICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzIyOlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDEpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDkyO1xuICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMjIpO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTA5NDtcbiAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgICAgICAgaWYgKChfbGEgLSA2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSA2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzUgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMTMgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjIgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjQgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMjkgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzMgLSA2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzUgLSA2KSkgIT09IDAgfHwgKF9sYSAtIDM4ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSAzOCAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zNyAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNDEgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzUzIC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NCAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTUgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU2IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NyAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTggLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU5IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182MCAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjIgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzYzIC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182NCAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjUgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzY2IC0gMzgpKSAhPT0gMCB8fCAoX2xhIC0gOTYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDk2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzk1IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5JbnQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlVpbnQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkJ5dGUgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkZpeGVkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5VZml4ZWQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkJvb2xlYW5MaXRlcmFsIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5EZWNpbWFsTnVtYmVyIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5IZXhOdW1iZXIgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkhleExpdGVyYWxGcmFnbWVudCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuTGVhdmVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5QYXlhYmxlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVHlwZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkNvbnN0cnVjdG9yS2V5d29yZCAtIDk2KSkgIT09IDAgfHwgKF9sYSAtIDEyOCAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gMTI4ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlJlY2VpdmVLZXl3b3JkIC0gMTI4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuSWRlbnRpZmllciAtIDEyOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlN0cmluZ0xpdGVyYWxGcmFnbWVudCAtIDEyOCkpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwOTM7XG4gICAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTAyO1xuICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgICB3aGlsZSAoX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fMTUpIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDk2O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18xNSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDk4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKF9sYSAtIDYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDYgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNSAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18xMyAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18yMiAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18yNCAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18yOSAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zMyAtIDYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX18zNSAtIDYpKSAhPT0gMCB8fCAoX2xhIC0gMzggJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDM4ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzM3IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX180MSAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTMgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU0IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NSAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTYgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU3IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181OCAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTkgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzYwIC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182MiAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjMgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzY0IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182NSAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjYgLSAzOCkpICE9PSAwIHx8IChfbGEgLSA5NiAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gOTYgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fOTUgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkludCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVWludCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQnl0ZSAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuRml4ZWQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlVmaXhlZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQm9vbGVhbkxpdGVyYWwgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkRlY2ltYWxOdW1iZXIgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkhleE51bWJlciAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuSGV4TGl0ZXJhbEZyYWdtZW50IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UeXBlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuQ29uc3RydWN0b3JLZXl3b3JkIC0gOTYpKSAhPT0gMCB8fCAoX2xhIC0gMTI4ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSAxMjggJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuUmVjZWl2ZUtleXdvcmQgLSAxMjggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5JZGVudGlmaWVyIC0gMTI4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuU3RyaW5nTGl0ZXJhbEZyYWdtZW50IC0gMTI4KSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTA5NztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExMDQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTEwNTtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzIzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX1NvbGlkaXR5UGFyc2VyLlRfXzMzOlxuICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChfbG9jYWxjdHgsIDIpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTA2O1xuICAgICAgICAgICAgdGhpcy5tYXRjaChfU29saWRpdHlQYXJzZXIuVF9fMzMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExMTU7XG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgICAgIGlmICgoX2xhIC0gNiAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gNiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181IC0gNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzEzIC0gNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzIyIC0gNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzI0IC0gNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzI5IC0gNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzMzIC0gNiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzM1IC0gNikpICE9PSAwIHx8IChfbGEgLSAzOCAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gMzggJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fMzcgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzQxIC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181MyAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTQgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU1IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181NiAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTcgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzU4IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX181OSAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjAgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzYyIC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182MyAtIDM4IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNjQgLSAzOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzY1IC0gMzggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX182NiAtIDM4KSkgIT09IDAgfHwgKF9sYSAtIDk2ICYgfjMxKSA9PT0gMCAmJiAoMSA8PCBfbGEgLSA5NiAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX185NSAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuSW50IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5VaW50IC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5CeXRlIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5GaXhlZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVWZpeGVkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5Cb29sZWFuTGl0ZXJhbCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuRGVjaW1hbE51bWJlciAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuSGV4TnVtYmVyIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5IZXhMaXRlcmFsRnJhZ21lbnQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkxlYXZlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuUGF5YWJsZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLlR5cGVLZXl3b3JkIC0gOTYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5Db25zdHJ1Y3RvcktleXdvcmQgLSA5NikpICE9PSAwIHx8IChfbGEgLSAxMjggJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDEyOCAmICgxIDw8IF9Tb2xpZGl0eVBhcnNlci5SZWNlaXZlS2V5d29yZCAtIDEyOCB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLklkZW50aWZpZXIgLSAxMjggfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5TdHJpbmdMaXRlcmFsRnJhZ21lbnQgLSAxMjgpKSAhPT0gMCkge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExMDc7XG4gICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uKDApO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTEyO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fMTUpIHtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTA4O1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzE1KTtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTEwOTtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTE0O1xuICAgICAgICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTExNztcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzM0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IGltcG9ydF9Ob1ZpYWJsZUFsdEV4Y2VwdGlvbi5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbih0aGlzKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIG51bWJlckxpdGVyYWwoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBOdW1iZXJMaXRlcmFsQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMTg2LCBfU29saWRpdHlQYXJzZXIuUlVMRV9udW1iZXJMaXRlcmFsKTtcbiAgICBsZXQgX2xhO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDExMjA7XG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICBpZiAoIShfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5EZWNpbWFsTnVtYmVyIHx8IF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLkhleE51bWJlcikpIHtcbiAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2lucHV0LkxBKDEpID09PSBpbXBvcnRfVG9rZW4uVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoZWRFT0YgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMTIyO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5pbnRlcnByZXRlci5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsIDEyMiwgdGhpcy5fY3R4KSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExMjE7XG4gICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLk51bWJlclVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChyZSkge1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgaW1wb3J0X1JlY29nbml0aW9uRXhjZXB0aW9uLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgIF9sb2NhbGN0eC5leGNlcHRpb24gPSByZTtcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5leGl0UnVsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsY3R4O1xuICB9XG4gIGlkZW50aWZpZXIoKSB7XG4gICAgbGV0IF9sb2NhbGN0eCA9IG5ldyBJZGVudGlmaWVyQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMTg4LCBfU29saWRpdHlQYXJzZXIuUlVMRV9pZGVudGlmaWVyKTtcbiAgICBsZXQgX2xhO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVudGVyT3V0ZXJBbHQoX2xvY2FsY3R4LCAxKTtcbiAgICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDExMjQ7XG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICBpZiAoIShfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX18xMyB8fCBfbGEgPT09IF9Tb2xpZGl0eVBhcnNlci5UX18yNCB8fCAoX2xhIC0gMzYgJiB+MzEpID09PSAwICYmICgxIDw8IF9sYSAtIDM2ICYgKDEgPDwgX1NvbGlkaXR5UGFyc2VyLlRfXzM1IC0gMzYgfCAxIDw8IF9Tb2xpZGl0eVBhcnNlci5UX180MSAtIDM2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fNTMgLSAzNikpICE9PSAwIHx8IChfbGEgLSA5NiAmIH4zMSkgPT09IDAgJiYgKDEgPDwgX2xhIC0gOTYgJiAoMSA8PCBfU29saWRpdHlQYXJzZXIuVF9fOTUgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkxlYXZlS2V5d29yZCAtIDk2IHwgMSA8PCBfU29saWRpdHlQYXJzZXIuUGF5YWJsZUtleXdvcmQgLSA5NiB8IDEgPDwgX1NvbGlkaXR5UGFyc2VyLkNvbnN0cnVjdG9yS2V5d29yZCAtIDk2KSkgIT09IDAgfHwgX2xhID09PSBfU29saWRpdHlQYXJzZXIuUmVjZWl2ZUtleXdvcmQgfHwgX2xhID09PSBfU29saWRpdHlQYXJzZXIuSWRlbnRpZmllcikpIHtcbiAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2lucHV0LkxBKDEpID09PSBpbXBvcnRfVG9rZW4uVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoZWRFT0YgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBoZXhMaXRlcmFsKCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgSGV4TGl0ZXJhbENvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDE5MCwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfaGV4TGl0ZXJhbCk7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBfYWx0O1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMTI3O1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgIF9hbHQgPSAxO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgc3dpdGNoIChfYWx0KSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTEyNjtcbiAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLkhleExpdGVyYWxGcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGltcG9ydF9Ob1ZpYWJsZUFsdEV4Y2VwdGlvbi5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbih0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IDExMjk7XG4gICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgIF9hbHQgPSB0aGlzLmludGVycHJldGVyLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwgMTIzLCB0aGlzLl9jdHgpO1xuICAgICAgICB9IHdoaWxlIChfYWx0ICE9PSAyICYmIF9hbHQgIT09IGltcG9ydF9BVE4uQVROLklOVkFMSURfQUxUX05VTUJFUik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBvdmVycmlkZVNwZWNpZmllcigpIHtcbiAgICBsZXQgX2xvY2FsY3R4ID0gbmV3IE92ZXJyaWRlU3BlY2lmaWVyQ29udGV4dCh0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMuZW50ZXJSdWxlKF9sb2NhbGN0eCwgMTkyLCBfU29saWRpdHlQYXJzZXIuUlVMRV9vdmVycmlkZVNwZWNpZmllcik7XG4gICAgbGV0IF9sYTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMTMxO1xuICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX185Nik7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMTQzO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICBpZiAoX2xhID09PSBfU29saWRpdHlQYXJzZXIuVF9fMjIpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTEzMjtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzIyKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTMzO1xuICAgICAgICAgICAgdGhpcy51c2VyRGVmaW5lZFR5cGVOYW1lKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTEzODtcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcbiAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgd2hpbGUgKF9sYSA9PT0gX1NvbGlkaXR5UGFyc2VyLlRfXzE1KSB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTEzNDtcbiAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlRfXzE1KTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTM1O1xuICAgICAgICAgICAgICAgICAgdGhpcy51c2VyRGVmaW5lZFR5cGVOYW1lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTQwO1xuICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDExNDE7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKF9Tb2xpZGl0eVBhcnNlci5UX18yMyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBzdHJpbmdMaXRlcmFsKCkge1xuICAgIGxldCBfbG9jYWxjdHggPSBuZXcgU3RyaW5nTGl0ZXJhbENvbnRleHQodGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcbiAgICB0aGlzLmVudGVyUnVsZShfbG9jYWxjdHgsIDE5NCwgX1NvbGlkaXR5UGFyc2VyLlJVTEVfc3RyaW5nTGl0ZXJhbCk7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBfYWx0O1xuICAgICAgdGhpcy5lbnRlck91dGVyQWx0KF9sb2NhbGN0eCwgMSk7XG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMTQ2O1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XG4gICAgICAgIF9hbHQgPSAxO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgc3dpdGNoIChfYWx0KSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTE0NTtcbiAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goX1NvbGlkaXR5UGFyc2VyLlN0cmluZ0xpdGVyYWxGcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGltcG9ydF9Ob1ZpYWJsZUFsdEV4Y2VwdGlvbi5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbih0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IDExNDg7XG4gICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xuICAgICAgICAgIF9hbHQgPSB0aGlzLmludGVycHJldGVyLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwgMTI2LCB0aGlzLl9jdHgpO1xuICAgICAgICB9IHdoaWxlIChfYWx0ICE9PSAyICYmIF9hbHQgIT09IGltcG9ydF9BVE4uQVROLklOVkFMSURfQUxUX05VTUJFUik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAocmUpIHtcbiAgICAgIGlmIChyZSBpbnN0YW5jZW9mIGltcG9ydF9SZWNvZ25pdGlvbkV4Y2VwdGlvbi5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xuICAgICAgICBfbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcmU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbGN0eDtcbiAgfVxuICBzZW1wcmVkKF9sb2NhbGN0eCwgcnVsZUluZGV4LCBwcmVkSW5kZXgpIHtcbiAgICBzd2l0Y2ggKHJ1bGVJbmRleCkge1xuICAgICAgY2FzZSAzNjpcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZU5hbWVfc2VtcHJlZChfbG9jYWxjdHgsIHByZWRJbmRleCk7XG4gICAgICBjYXNlIDY2OlxuICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uX3NlbXByZWQoX2xvY2FsY3R4LCBwcmVkSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0eXBlTmFtZV9zZW1wcmVkKF9sb2NhbGN0eCwgcHJlZEluZGV4KSB7XG4gICAgc3dpdGNoIChwcmVkSW5kZXgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZXhwcmVzc2lvbl9zZW1wcmVkKF9sb2NhbGN0eCwgcHJlZEluZGV4KSB7XG4gICAgc3dpdGNoIChwcmVkSW5kZXgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxNCk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMTMpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDEyKTtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAxMSk7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMTApO1xuICAgICAgY2FzZSA2OlxuICAgICAgICByZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDkpO1xuICAgICAgY2FzZSA3OlxuICAgICAgICByZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDgpO1xuICAgICAgY2FzZSA4OlxuICAgICAgICByZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDcpO1xuICAgICAgY2FzZSA5OlxuICAgICAgICByZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDYpO1xuICAgICAgY2FzZSAxMDpcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA1KTtcbiAgICAgIGNhc2UgMTE6XG4gICAgICAgIHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgNCk7XG4gICAgICBjYXNlIDEyOlxuICAgICAgICByZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDMpO1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAyKTtcbiAgICAgIGNhc2UgMTQ6XG4gICAgICAgIHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMjcpO1xuICAgICAgY2FzZSAxNTpcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAyNSk7XG4gICAgICBjYXNlIDE2OlxuICAgICAgICByZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDI0KTtcbiAgICAgIGNhc2UgMTc6XG4gICAgICAgIHJldHVybiB0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMjMpO1xuICAgICAgY2FzZSAxODpcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAyMik7XG4gICAgICBjYXNlIDE5OlxuICAgICAgICByZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDIxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RhdGljIGdldCBfQVROKCkge1xuICAgIGlmICghX1NvbGlkaXR5UGFyc2VyLl9fQVROKSB7XG4gICAgICBfU29saWRpdHlQYXJzZXIuX19BVE4gPSBuZXcgaW1wb3J0X0FUTkRlc2VyaWFsaXplcjIuQVRORGVzZXJpYWxpemVyKCkuZGVzZXJpYWxpemUoVXRpbHMyLnRvQ2hhckFycmF5KF9Tb2xpZGl0eVBhcnNlci5fc2VyaWFsaXplZEFUTikpO1xuICAgIH1cbiAgICByZXR1cm4gX1NvbGlkaXR5UGFyc2VyLl9fQVROO1xuICB9XG59O1xudmFyIFNvbGlkaXR5UGFyc2VyID0gX1NvbGlkaXR5UGFyc2VyO1xuU29saWRpdHlQYXJzZXIuVF9fMCA9IDE7XG5Tb2xpZGl0eVBhcnNlci5UX18xID0gMjtcblNvbGlkaXR5UGFyc2VyLlRfXzIgPSAzO1xuU29saWRpdHlQYXJzZXIuVF9fMyA9IDQ7XG5Tb2xpZGl0eVBhcnNlci5UX180ID0gNTtcblNvbGlkaXR5UGFyc2VyLlRfXzUgPSA2O1xuU29saWRpdHlQYXJzZXIuVF9fNiA9IDc7XG5Tb2xpZGl0eVBhcnNlci5UX183ID0gODtcblNvbGlkaXR5UGFyc2VyLlRfXzggPSA5O1xuU29saWRpdHlQYXJzZXIuVF9fOSA9IDEwO1xuU29saWRpdHlQYXJzZXIuVF9fMTAgPSAxMTtcblNvbGlkaXR5UGFyc2VyLlRfXzExID0gMTI7XG5Tb2xpZGl0eVBhcnNlci5UX18xMiA9IDEzO1xuU29saWRpdHlQYXJzZXIuVF9fMTMgPSAxNDtcblNvbGlkaXR5UGFyc2VyLlRfXzE0ID0gMTU7XG5Tb2xpZGl0eVBhcnNlci5UX18xNSA9IDE2O1xuU29saWRpdHlQYXJzZXIuVF9fMTYgPSAxNztcblNvbGlkaXR5UGFyc2VyLlRfXzE3ID0gMTg7XG5Tb2xpZGl0eVBhcnNlci5UX18xOCA9IDE5O1xuU29saWRpdHlQYXJzZXIuVF9fMTkgPSAyMDtcblNvbGlkaXR5UGFyc2VyLlRfXzIwID0gMjE7XG5Tb2xpZGl0eVBhcnNlci5UX18yMSA9IDIyO1xuU29saWRpdHlQYXJzZXIuVF9fMjIgPSAyMztcblNvbGlkaXR5UGFyc2VyLlRfXzIzID0gMjQ7XG5Tb2xpZGl0eVBhcnNlci5UX18yNCA9IDI1O1xuU29saWRpdHlQYXJzZXIuVF9fMjUgPSAyNjtcblNvbGlkaXR5UGFyc2VyLlRfXzI2ID0gMjc7XG5Tb2xpZGl0eVBhcnNlci5UX18yNyA9IDI4O1xuU29saWRpdHlQYXJzZXIuVF9fMjggPSAyOTtcblNvbGlkaXR5UGFyc2VyLlRfXzI5ID0gMzA7XG5Tb2xpZGl0eVBhcnNlci5UX18zMCA9IDMxO1xuU29saWRpdHlQYXJzZXIuVF9fMzEgPSAzMjtcblNvbGlkaXR5UGFyc2VyLlRfXzMyID0gMzM7XG5Tb2xpZGl0eVBhcnNlci5UX18zMyA9IDM0O1xuU29saWRpdHlQYXJzZXIuVF9fMzQgPSAzNTtcblNvbGlkaXR5UGFyc2VyLlRfXzM1ID0gMzY7XG5Tb2xpZGl0eVBhcnNlci5UX18zNiA9IDM3O1xuU29saWRpdHlQYXJzZXIuVF9fMzcgPSAzODtcblNvbGlkaXR5UGFyc2VyLlRfXzM4ID0gMzk7XG5Tb2xpZGl0eVBhcnNlci5UX18zOSA9IDQwO1xuU29saWRpdHlQYXJzZXIuVF9fNDAgPSA0MTtcblNvbGlkaXR5UGFyc2VyLlRfXzQxID0gNDI7XG5Tb2xpZGl0eVBhcnNlci5UX180MiA9IDQzO1xuU29saWRpdHlQYXJzZXIuVF9fNDMgPSA0NDtcblNvbGlkaXR5UGFyc2VyLlRfXzQ0ID0gNDU7XG5Tb2xpZGl0eVBhcnNlci5UX180NSA9IDQ2O1xuU29saWRpdHlQYXJzZXIuVF9fNDYgPSA0NztcblNvbGlkaXR5UGFyc2VyLlRfXzQ3ID0gNDg7XG5Tb2xpZGl0eVBhcnNlci5UX180OCA9IDQ5O1xuU29saWRpdHlQYXJzZXIuVF9fNDkgPSA1MDtcblNvbGlkaXR5UGFyc2VyLlRfXzUwID0gNTE7XG5Tb2xpZGl0eVBhcnNlci5UX181MSA9IDUyO1xuU29saWRpdHlQYXJzZXIuVF9fNTIgPSA1MztcblNvbGlkaXR5UGFyc2VyLlRfXzUzID0gNTQ7XG5Tb2xpZGl0eVBhcnNlci5UX181NCA9IDU1O1xuU29saWRpdHlQYXJzZXIuVF9fNTUgPSA1NjtcblNvbGlkaXR5UGFyc2VyLlRfXzU2ID0gNTc7XG5Tb2xpZGl0eVBhcnNlci5UX181NyA9IDU4O1xuU29saWRpdHlQYXJzZXIuVF9fNTggPSA1OTtcblNvbGlkaXR5UGFyc2VyLlRfXzU5ID0gNjA7XG5Tb2xpZGl0eVBhcnNlci5UX182MCA9IDYxO1xuU29saWRpdHlQYXJzZXIuVF9fNjEgPSA2MjtcblNvbGlkaXR5UGFyc2VyLlRfXzYyID0gNjM7XG5Tb2xpZGl0eVBhcnNlci5UX182MyA9IDY0O1xuU29saWRpdHlQYXJzZXIuVF9fNjQgPSA2NTtcblNvbGlkaXR5UGFyc2VyLlRfXzY1ID0gNjY7XG5Tb2xpZGl0eVBhcnNlci5UX182NiA9IDY3O1xuU29saWRpdHlQYXJzZXIuVF9fNjcgPSA2ODtcblNvbGlkaXR5UGFyc2VyLlRfXzY4ID0gNjk7XG5Tb2xpZGl0eVBhcnNlci5UX182OSA9IDcwO1xuU29saWRpdHlQYXJzZXIuVF9fNzAgPSA3MTtcblNvbGlkaXR5UGFyc2VyLlRfXzcxID0gNzI7XG5Tb2xpZGl0eVBhcnNlci5UX183MiA9IDczO1xuU29saWRpdHlQYXJzZXIuVF9fNzMgPSA3NDtcblNvbGlkaXR5UGFyc2VyLlRfXzc0ID0gNzU7XG5Tb2xpZGl0eVBhcnNlci5UX183NSA9IDc2O1xuU29saWRpdHlQYXJzZXIuVF9fNzYgPSA3NztcblNvbGlkaXR5UGFyc2VyLlRfXzc3ID0gNzg7XG5Tb2xpZGl0eVBhcnNlci5UX183OCA9IDc5O1xuU29saWRpdHlQYXJzZXIuVF9fNzkgPSA4MDtcblNvbGlkaXR5UGFyc2VyLlRfXzgwID0gODE7XG5Tb2xpZGl0eVBhcnNlci5UX184MSA9IDgyO1xuU29saWRpdHlQYXJzZXIuVF9fODIgPSA4MztcblNvbGlkaXR5UGFyc2VyLlRfXzgzID0gODQ7XG5Tb2xpZGl0eVBhcnNlci5UX184NCA9IDg1O1xuU29saWRpdHlQYXJzZXIuVF9fODUgPSA4NjtcblNvbGlkaXR5UGFyc2VyLlRfXzg2ID0gODc7XG5Tb2xpZGl0eVBhcnNlci5UX184NyA9IDg4O1xuU29saWRpdHlQYXJzZXIuVF9fODggPSA4OTtcblNvbGlkaXR5UGFyc2VyLlRfXzg5ID0gOTA7XG5Tb2xpZGl0eVBhcnNlci5UX185MCA9IDkxO1xuU29saWRpdHlQYXJzZXIuVF9fOTEgPSA5MjtcblNvbGlkaXR5UGFyc2VyLlRfXzkyID0gOTM7XG5Tb2xpZGl0eVBhcnNlci5UX185MyA9IDk0O1xuU29saWRpdHlQYXJzZXIuVF9fOTQgPSA5NTtcblNvbGlkaXR5UGFyc2VyLlRfXzk1ID0gOTY7XG5Tb2xpZGl0eVBhcnNlci5UX185NiA9IDk3O1xuU29saWRpdHlQYXJzZXIuSW50ID0gOTg7XG5Tb2xpZGl0eVBhcnNlci5VaW50ID0gOTk7XG5Tb2xpZGl0eVBhcnNlci5CeXRlID0gMTAwO1xuU29saWRpdHlQYXJzZXIuRml4ZWQgPSAxMDE7XG5Tb2xpZGl0eVBhcnNlci5VZml4ZWQgPSAxMDI7XG5Tb2xpZGl0eVBhcnNlci5Cb29sZWFuTGl0ZXJhbCA9IDEwMztcblNvbGlkaXR5UGFyc2VyLkRlY2ltYWxOdW1iZXIgPSAxMDQ7XG5Tb2xpZGl0eVBhcnNlci5IZXhOdW1iZXIgPSAxMDU7XG5Tb2xpZGl0eVBhcnNlci5OdW1iZXJVbml0ID0gMTA2O1xuU29saWRpdHlQYXJzZXIuSGV4TGl0ZXJhbEZyYWdtZW50ID0gMTA3O1xuU29saWRpdHlQYXJzZXIuUmVzZXJ2ZWRLZXl3b3JkID0gMTA4O1xuU29saWRpdHlQYXJzZXIuQW5vbnltb3VzS2V5d29yZCA9IDEwOTtcblNvbGlkaXR5UGFyc2VyLkJyZWFrS2V5d29yZCA9IDExMDtcblNvbGlkaXR5UGFyc2VyLkNvbnN0YW50S2V5d29yZCA9IDExMTtcblNvbGlkaXR5UGFyc2VyLkltbXV0YWJsZUtleXdvcmQgPSAxMTI7XG5Tb2xpZGl0eVBhcnNlci5Db250aW51ZUtleXdvcmQgPSAxMTM7XG5Tb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQgPSAxMTQ7XG5Tb2xpZGl0eVBhcnNlci5FeHRlcm5hbEtleXdvcmQgPSAxMTU7XG5Tb2xpZGl0eVBhcnNlci5JbmRleGVkS2V5d29yZCA9IDExNjtcblNvbGlkaXR5UGFyc2VyLkludGVybmFsS2V5d29yZCA9IDExNztcblNvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkID0gMTE4O1xuU29saWRpdHlQYXJzZXIuUHJpdmF0ZUtleXdvcmQgPSAxMTk7XG5Tb2xpZGl0eVBhcnNlci5QdWJsaWNLZXl3b3JkID0gMTIwO1xuU29saWRpdHlQYXJzZXIuVmlydHVhbEtleXdvcmQgPSAxMjE7XG5Tb2xpZGl0eVBhcnNlci5QdXJlS2V5d29yZCA9IDEyMjtcblNvbGlkaXR5UGFyc2VyLlR5cGVLZXl3b3JkID0gMTIzO1xuU29saWRpdHlQYXJzZXIuVmlld0tleXdvcmQgPSAxMjQ7XG5Tb2xpZGl0eVBhcnNlci5HbG9iYWxLZXl3b3JkID0gMTI1O1xuU29saWRpdHlQYXJzZXIuQ29uc3RydWN0b3JLZXl3b3JkID0gMTI2O1xuU29saWRpdHlQYXJzZXIuRmFsbGJhY2tLZXl3b3JkID0gMTI3O1xuU29saWRpdHlQYXJzZXIuUmVjZWl2ZUtleXdvcmQgPSAxMjg7XG5Tb2xpZGl0eVBhcnNlci5JZGVudGlmaWVyID0gMTI5O1xuU29saWRpdHlQYXJzZXIuU3RyaW5nTGl0ZXJhbEZyYWdtZW50ID0gMTMwO1xuU29saWRpdHlQYXJzZXIuVmVyc2lvbkxpdGVyYWwgPSAxMzE7XG5Tb2xpZGl0eVBhcnNlci5XUyA9IDEzMjtcblNvbGlkaXR5UGFyc2VyLkNPTU1FTlQgPSAxMzM7XG5Tb2xpZGl0eVBhcnNlci5MSU5FX0NPTU1FTlQgPSAxMzQ7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX3NvdXJjZVVuaXQgPSAwO1xuU29saWRpdHlQYXJzZXIuUlVMRV9wcmFnbWFEaXJlY3RpdmUgPSAxO1xuU29saWRpdHlQYXJzZXIuUlVMRV9wcmFnbWFOYW1lID0gMjtcblNvbGlkaXR5UGFyc2VyLlJVTEVfcHJhZ21hVmFsdWUgPSAzO1xuU29saWRpdHlQYXJzZXIuUlVMRV92ZXJzaW9uID0gNDtcblNvbGlkaXR5UGFyc2VyLlJVTEVfdmVyc2lvbk9wZXJhdG9yID0gNTtcblNvbGlkaXR5UGFyc2VyLlJVTEVfdmVyc2lvbkNvbnN0cmFpbnQgPSA2O1xuU29saWRpdHlQYXJzZXIuUlVMRV9pbXBvcnREZWNsYXJhdGlvbiA9IDc7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX2ltcG9ydERpcmVjdGl2ZSA9IDg7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX2ltcG9ydFBhdGggPSA5O1xuU29saWRpdHlQYXJzZXIuUlVMRV9jb250cmFjdERlZmluaXRpb24gPSAxMDtcblNvbGlkaXR5UGFyc2VyLlJVTEVfaW5oZXJpdGFuY2VTcGVjaWZpZXIgPSAxMTtcblNvbGlkaXR5UGFyc2VyLlJVTEVfY29udHJhY3RQYXJ0ID0gMTI7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX3N0YXRlVmFyaWFibGVEZWNsYXJhdGlvbiA9IDEzO1xuU29saWRpdHlQYXJzZXIuUlVMRV9maWxlTGV2ZWxDb25zdGFudCA9IDE0O1xuU29saWRpdHlQYXJzZXIuUlVMRV9jdXN0b21FcnJvckRlZmluaXRpb24gPSAxNTtcblNvbGlkaXR5UGFyc2VyLlJVTEVfdHlwZURlZmluaXRpb24gPSAxNjtcblNvbGlkaXR5UGFyc2VyLlJVTEVfdXNpbmdGb3JEZWNsYXJhdGlvbiA9IDE3O1xuU29saWRpdHlQYXJzZXIuUlVMRV91c2luZ0Zvck9iamVjdCA9IDE4O1xuU29saWRpdHlQYXJzZXIuUlVMRV9zdHJ1Y3REZWZpbml0aW9uID0gMTk7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX21vZGlmaWVyRGVmaW5pdGlvbiA9IDIwO1xuU29saWRpdHlQYXJzZXIuUlVMRV9tb2RpZmllckludm9jYXRpb24gPSAyMTtcblNvbGlkaXR5UGFyc2VyLlJVTEVfZnVuY3Rpb25EZWZpbml0aW9uID0gMjI7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX2Z1bmN0aW9uRGVzY3JpcHRvciA9IDIzO1xuU29saWRpdHlQYXJzZXIuUlVMRV9yZXR1cm5QYXJhbWV0ZXJzID0gMjQ7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX21vZGlmaWVyTGlzdCA9IDI1O1xuU29saWRpdHlQYXJzZXIuUlVMRV9ldmVudERlZmluaXRpb24gPSAyNjtcblNvbGlkaXR5UGFyc2VyLlJVTEVfZW51bVZhbHVlID0gMjc7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX2VudW1EZWZpbml0aW9uID0gMjg7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX3BhcmFtZXRlckxpc3QgPSAyOTtcblNvbGlkaXR5UGFyc2VyLlJVTEVfcGFyYW1ldGVyID0gMzA7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX2V2ZW50UGFyYW1ldGVyTGlzdCA9IDMxO1xuU29saWRpdHlQYXJzZXIuUlVMRV9ldmVudFBhcmFtZXRlciA9IDMyO1xuU29saWRpdHlQYXJzZXIuUlVMRV9mdW5jdGlvblR5cGVQYXJhbWV0ZXJMaXN0ID0gMzM7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX2Z1bmN0aW9uVHlwZVBhcmFtZXRlciA9IDM0O1xuU29saWRpdHlQYXJzZXIuUlVMRV92YXJpYWJsZURlY2xhcmF0aW9uID0gMzU7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX3R5cGVOYW1lID0gMzY7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX3VzZXJEZWZpbmVkVHlwZU5hbWUgPSAzNztcblNvbGlkaXR5UGFyc2VyLlJVTEVfbWFwcGluZ0tleSA9IDM4O1xuU29saWRpdHlQYXJzZXIuUlVMRV9tYXBwaW5nID0gMzk7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX2Z1bmN0aW9uVHlwZU5hbWUgPSA0MDtcblNvbGlkaXR5UGFyc2VyLlJVTEVfc3RvcmFnZUxvY2F0aW9uID0gNDE7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX3N0YXRlTXV0YWJpbGl0eSA9IDQyO1xuU29saWRpdHlQYXJzZXIuUlVMRV9ibG9jayA9IDQzO1xuU29saWRpdHlQYXJzZXIuUlVMRV9zdGF0ZW1lbnQgPSA0NDtcblNvbGlkaXR5UGFyc2VyLlJVTEVfZXhwcmVzc2lvblN0YXRlbWVudCA9IDQ1O1xuU29saWRpdHlQYXJzZXIuUlVMRV9pZlN0YXRlbWVudCA9IDQ2O1xuU29saWRpdHlQYXJzZXIuUlVMRV90cnlTdGF0ZW1lbnQgPSA0NztcblNvbGlkaXR5UGFyc2VyLlJVTEVfY2F0Y2hDbGF1c2UgPSA0ODtcblNvbGlkaXR5UGFyc2VyLlJVTEVfd2hpbGVTdGF0ZW1lbnQgPSA0OTtcblNvbGlkaXR5UGFyc2VyLlJVTEVfc2ltcGxlU3RhdGVtZW50ID0gNTA7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX3VuY2hlY2tlZFN0YXRlbWVudCA9IDUxO1xuU29saWRpdHlQYXJzZXIuUlVMRV9mb3JTdGF0ZW1lbnQgPSA1MjtcblNvbGlkaXR5UGFyc2VyLlJVTEVfaW5saW5lQXNzZW1ibHlTdGF0ZW1lbnQgPSA1MztcblNvbGlkaXR5UGFyc2VyLlJVTEVfaW5saW5lQXNzZW1ibHlTdGF0ZW1lbnRGbGFnID0gNTQ7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX2RvV2hpbGVTdGF0ZW1lbnQgPSA1NTtcblNvbGlkaXR5UGFyc2VyLlJVTEVfY29udGludWVTdGF0ZW1lbnQgPSA1NjtcblNvbGlkaXR5UGFyc2VyLlJVTEVfYnJlYWtTdGF0ZW1lbnQgPSA1NztcblNvbGlkaXR5UGFyc2VyLlJVTEVfcmV0dXJuU3RhdGVtZW50ID0gNTg7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX3Rocm93U3RhdGVtZW50ID0gNTk7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX2VtaXRTdGF0ZW1lbnQgPSA2MDtcblNvbGlkaXR5UGFyc2VyLlJVTEVfcmV2ZXJ0U3RhdGVtZW50ID0gNjE7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX3ZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnQgPSA2MjtcblNvbGlkaXR5UGFyc2VyLlJVTEVfdmFyaWFibGVEZWNsYXJhdGlvbkxpc3QgPSA2MztcblNvbGlkaXR5UGFyc2VyLlJVTEVfaWRlbnRpZmllckxpc3QgPSA2NDtcblNvbGlkaXR5UGFyc2VyLlJVTEVfZWxlbWVudGFyeVR5cGVOYW1lID0gNjU7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX2V4cHJlc3Npb24gPSA2NjtcblNvbGlkaXR5UGFyc2VyLlJVTEVfcHJpbWFyeUV4cHJlc3Npb24gPSA2NztcblNvbGlkaXR5UGFyc2VyLlJVTEVfZXhwcmVzc2lvbkxpc3QgPSA2ODtcblNvbGlkaXR5UGFyc2VyLlJVTEVfbmFtZVZhbHVlTGlzdCA9IDY5O1xuU29saWRpdHlQYXJzZXIuUlVMRV9uYW1lVmFsdWUgPSA3MDtcblNvbGlkaXR5UGFyc2VyLlJVTEVfZnVuY3Rpb25DYWxsQXJndW1lbnRzID0gNzE7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX2Z1bmN0aW9uQ2FsbCA9IDcyO1xuU29saWRpdHlQYXJzZXIuUlVMRV9hc3NlbWJseUJsb2NrID0gNzM7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX2Fzc2VtYmx5SXRlbSA9IDc0O1xuU29saWRpdHlQYXJzZXIuUlVMRV9hc3NlbWJseUV4cHJlc3Npb24gPSA3NTtcblNvbGlkaXR5UGFyc2VyLlJVTEVfYXNzZW1ibHlNZW1iZXIgPSA3NjtcblNvbGlkaXR5UGFyc2VyLlJVTEVfYXNzZW1ibHlDYWxsID0gNzc7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX2Fzc2VtYmx5TG9jYWxEZWZpbml0aW9uID0gNzg7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX2Fzc2VtYmx5QXNzaWdubWVudCA9IDc5O1xuU29saWRpdHlQYXJzZXIuUlVMRV9hc3NlbWJseUlkZW50aWZpZXJPckxpc3QgPSA4MDtcblNvbGlkaXR5UGFyc2VyLlJVTEVfYXNzZW1ibHlJZGVudGlmaWVyTGlzdCA9IDgxO1xuU29saWRpdHlQYXJzZXIuUlVMRV9hc3NlbWJseVN0YWNrQXNzaWdubWVudCA9IDgyO1xuU29saWRpdHlQYXJzZXIuUlVMRV9sYWJlbERlZmluaXRpb24gPSA4MztcblNvbGlkaXR5UGFyc2VyLlJVTEVfYXNzZW1ibHlTd2l0Y2ggPSA4NDtcblNvbGlkaXR5UGFyc2VyLlJVTEVfYXNzZW1ibHlDYXNlID0gODU7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX2Fzc2VtYmx5RnVuY3Rpb25EZWZpbml0aW9uID0gODY7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX2Fzc2VtYmx5RnVuY3Rpb25SZXR1cm5zID0gODc7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX2Fzc2VtYmx5Rm9yID0gODg7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX2Fzc2VtYmx5SWYgPSA4OTtcblNvbGlkaXR5UGFyc2VyLlJVTEVfYXNzZW1ibHlMaXRlcmFsID0gOTA7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX3N1YkFzc2VtYmx5ID0gOTE7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX3R1cGxlRXhwcmVzc2lvbiA9IDkyO1xuU29saWRpdHlQYXJzZXIuUlVMRV9udW1iZXJMaXRlcmFsID0gOTM7XG5Tb2xpZGl0eVBhcnNlci5SVUxFX2lkZW50aWZpZXIgPSA5NDtcblNvbGlkaXR5UGFyc2VyLlJVTEVfaGV4TGl0ZXJhbCA9IDk1O1xuU29saWRpdHlQYXJzZXIuUlVMRV9vdmVycmlkZVNwZWNpZmllciA9IDk2O1xuU29saWRpdHlQYXJzZXIuUlVMRV9zdHJpbmdMaXRlcmFsID0gOTc7XG5Tb2xpZGl0eVBhcnNlci5ydWxlTmFtZXMgPSBbXG4gIFwic291cmNlVW5pdFwiLFxuICBcInByYWdtYURpcmVjdGl2ZVwiLFxuICBcInByYWdtYU5hbWVcIixcbiAgXCJwcmFnbWFWYWx1ZVwiLFxuICBcInZlcnNpb25cIixcbiAgXCJ2ZXJzaW9uT3BlcmF0b3JcIixcbiAgXCJ2ZXJzaW9uQ29uc3RyYWludFwiLFxuICBcImltcG9ydERlY2xhcmF0aW9uXCIsXG4gIFwiaW1wb3J0RGlyZWN0aXZlXCIsXG4gIFwiaW1wb3J0UGF0aFwiLFxuICBcImNvbnRyYWN0RGVmaW5pdGlvblwiLFxuICBcImluaGVyaXRhbmNlU3BlY2lmaWVyXCIsXG4gIFwiY29udHJhY3RQYXJ0XCIsXG4gIFwic3RhdGVWYXJpYWJsZURlY2xhcmF0aW9uXCIsXG4gIFwiZmlsZUxldmVsQ29uc3RhbnRcIixcbiAgXCJjdXN0b21FcnJvckRlZmluaXRpb25cIixcbiAgXCJ0eXBlRGVmaW5pdGlvblwiLFxuICBcInVzaW5nRm9yRGVjbGFyYXRpb25cIixcbiAgXCJ1c2luZ0Zvck9iamVjdFwiLFxuICBcInN0cnVjdERlZmluaXRpb25cIixcbiAgXCJtb2RpZmllckRlZmluaXRpb25cIixcbiAgXCJtb2RpZmllckludm9jYXRpb25cIixcbiAgXCJmdW5jdGlvbkRlZmluaXRpb25cIixcbiAgXCJmdW5jdGlvbkRlc2NyaXB0b3JcIixcbiAgXCJyZXR1cm5QYXJhbWV0ZXJzXCIsXG4gIFwibW9kaWZpZXJMaXN0XCIsXG4gIFwiZXZlbnREZWZpbml0aW9uXCIsXG4gIFwiZW51bVZhbHVlXCIsXG4gIFwiZW51bURlZmluaXRpb25cIixcbiAgXCJwYXJhbWV0ZXJMaXN0XCIsXG4gIFwicGFyYW1ldGVyXCIsXG4gIFwiZXZlbnRQYXJhbWV0ZXJMaXN0XCIsXG4gIFwiZXZlbnRQYXJhbWV0ZXJcIixcbiAgXCJmdW5jdGlvblR5cGVQYXJhbWV0ZXJMaXN0XCIsXG4gIFwiZnVuY3Rpb25UeXBlUGFyYW1ldGVyXCIsXG4gIFwidmFyaWFibGVEZWNsYXJhdGlvblwiLFxuICBcInR5cGVOYW1lXCIsXG4gIFwidXNlckRlZmluZWRUeXBlTmFtZVwiLFxuICBcIm1hcHBpbmdLZXlcIixcbiAgXCJtYXBwaW5nXCIsXG4gIFwiZnVuY3Rpb25UeXBlTmFtZVwiLFxuICBcInN0b3JhZ2VMb2NhdGlvblwiLFxuICBcInN0YXRlTXV0YWJpbGl0eVwiLFxuICBcImJsb2NrXCIsXG4gIFwic3RhdGVtZW50XCIsXG4gIFwiZXhwcmVzc2lvblN0YXRlbWVudFwiLFxuICBcImlmU3RhdGVtZW50XCIsXG4gIFwidHJ5U3RhdGVtZW50XCIsXG4gIFwiY2F0Y2hDbGF1c2VcIixcbiAgXCJ3aGlsZVN0YXRlbWVudFwiLFxuICBcInNpbXBsZVN0YXRlbWVudFwiLFxuICBcInVuY2hlY2tlZFN0YXRlbWVudFwiLFxuICBcImZvclN0YXRlbWVudFwiLFxuICBcImlubGluZUFzc2VtYmx5U3RhdGVtZW50XCIsXG4gIFwiaW5saW5lQXNzZW1ibHlTdGF0ZW1lbnRGbGFnXCIsXG4gIFwiZG9XaGlsZVN0YXRlbWVudFwiLFxuICBcImNvbnRpbnVlU3RhdGVtZW50XCIsXG4gIFwiYnJlYWtTdGF0ZW1lbnRcIixcbiAgXCJyZXR1cm5TdGF0ZW1lbnRcIixcbiAgXCJ0aHJvd1N0YXRlbWVudFwiLFxuICBcImVtaXRTdGF0ZW1lbnRcIixcbiAgXCJyZXZlcnRTdGF0ZW1lbnRcIixcbiAgXCJ2YXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50XCIsXG4gIFwidmFyaWFibGVEZWNsYXJhdGlvbkxpc3RcIixcbiAgXCJpZGVudGlmaWVyTGlzdFwiLFxuICBcImVsZW1lbnRhcnlUeXBlTmFtZVwiLFxuICBcImV4cHJlc3Npb25cIixcbiAgXCJwcmltYXJ5RXhwcmVzc2lvblwiLFxuICBcImV4cHJlc3Npb25MaXN0XCIsXG4gIFwibmFtZVZhbHVlTGlzdFwiLFxuICBcIm5hbWVWYWx1ZVwiLFxuICBcImZ1bmN0aW9uQ2FsbEFyZ3VtZW50c1wiLFxuICBcImZ1bmN0aW9uQ2FsbFwiLFxuICBcImFzc2VtYmx5QmxvY2tcIixcbiAgXCJhc3NlbWJseUl0ZW1cIixcbiAgXCJhc3NlbWJseUV4cHJlc3Npb25cIixcbiAgXCJhc3NlbWJseU1lbWJlclwiLFxuICBcImFzc2VtYmx5Q2FsbFwiLFxuICBcImFzc2VtYmx5TG9jYWxEZWZpbml0aW9uXCIsXG4gIFwiYXNzZW1ibHlBc3NpZ25tZW50XCIsXG4gIFwiYXNzZW1ibHlJZGVudGlmaWVyT3JMaXN0XCIsXG4gIFwiYXNzZW1ibHlJZGVudGlmaWVyTGlzdFwiLFxuICBcImFzc2VtYmx5U3RhY2tBc3NpZ25tZW50XCIsXG4gIFwibGFiZWxEZWZpbml0aW9uXCIsXG4gIFwiYXNzZW1ibHlTd2l0Y2hcIixcbiAgXCJhc3NlbWJseUNhc2VcIixcbiAgXCJhc3NlbWJseUZ1bmN0aW9uRGVmaW5pdGlvblwiLFxuICBcImFzc2VtYmx5RnVuY3Rpb25SZXR1cm5zXCIsXG4gIFwiYXNzZW1ibHlGb3JcIixcbiAgXCJhc3NlbWJseUlmXCIsXG4gIFwiYXNzZW1ibHlMaXRlcmFsXCIsXG4gIFwic3ViQXNzZW1ibHlcIixcbiAgXCJ0dXBsZUV4cHJlc3Npb25cIixcbiAgXCJudW1iZXJMaXRlcmFsXCIsXG4gIFwiaWRlbnRpZmllclwiLFxuICBcImhleExpdGVyYWxcIixcbiAgXCJvdmVycmlkZVNwZWNpZmllclwiLFxuICBcInN0cmluZ0xpdGVyYWxcIlxuXTtcblNvbGlkaXR5UGFyc2VyLl9MSVRFUkFMX05BTUVTID0gW1xuICB2b2lkIDAsXG4gIFwiJ3ByYWdtYSdcIixcbiAgXCInOydcIixcbiAgXCInKidcIixcbiAgXCInfHwnXCIsXG4gIFwiJ14nXCIsXG4gIFwiJ34nXCIsXG4gIFwiJz49J1wiLFxuICBcIic+J1wiLFxuICBcIic8J1wiLFxuICBcIic8PSdcIixcbiAgXCInPSdcIixcbiAgXCInYXMnXCIsXG4gIFwiJ2ltcG9ydCdcIixcbiAgXCInZnJvbSdcIixcbiAgXCIneydcIixcbiAgXCInLCdcIixcbiAgXCInfSdcIixcbiAgXCInYWJzdHJhY3QnXCIsXG4gIFwiJ2NvbnRyYWN0J1wiLFxuICBcIidpbnRlcmZhY2UnXCIsXG4gIFwiJ2xpYnJhcnknXCIsXG4gIFwiJ2lzJ1wiLFxuICBcIicoJ1wiLFxuICBcIicpJ1wiLFxuICBcIidlcnJvcidcIixcbiAgXCIndXNpbmcnXCIsXG4gIFwiJ2ZvcidcIixcbiAgXCInc3RydWN0J1wiLFxuICBcIidtb2RpZmllcidcIixcbiAgXCInZnVuY3Rpb24nXCIsXG4gIFwiJ3JldHVybnMnXCIsXG4gIFwiJ2V2ZW50J1wiLFxuICBcIidlbnVtJ1wiLFxuICBcIidbJ1wiLFxuICBcIiddJ1wiLFxuICBcIidhZGRyZXNzJ1wiLFxuICBcIicuJ1wiLFxuICBcIidtYXBwaW5nJ1wiLFxuICBcIic9PidcIixcbiAgXCInbWVtb3J5J1wiLFxuICBcIidzdG9yYWdlJ1wiLFxuICBcIidjYWxsZGF0YSdcIixcbiAgXCInaWYnXCIsXG4gIFwiJ2Vsc2UnXCIsXG4gIFwiJ3RyeSdcIixcbiAgXCInY2F0Y2gnXCIsXG4gIFwiJ3doaWxlJ1wiLFxuICBcIid1bmNoZWNrZWQnXCIsXG4gIFwiJ2Fzc2VtYmx5J1wiLFxuICBcIidkbydcIixcbiAgXCIncmV0dXJuJ1wiLFxuICBcIid0aHJvdydcIixcbiAgXCInZW1pdCdcIixcbiAgXCIncmV2ZXJ0J1wiLFxuICBcIid2YXInXCIsXG4gIFwiJ2Jvb2wnXCIsXG4gIFwiJ3N0cmluZydcIixcbiAgXCInYnl0ZSdcIixcbiAgXCInKysnXCIsXG4gIFwiJy0tJ1wiLFxuICBcIiduZXcnXCIsXG4gIFwiJzonXCIsXG4gIFwiJysnXCIsXG4gIFwiJy0nXCIsXG4gIFwiJ2FmdGVyJ1wiLFxuICBcIidkZWxldGUnXCIsXG4gIFwiJyEnXCIsXG4gIFwiJyoqJ1wiLFxuICBcIicvJ1wiLFxuICBcIiclJ1wiLFxuICBcIic8PCdcIixcbiAgXCInPj4nXCIsXG4gIFwiJyYnXCIsXG4gIFwiJ3wnXCIsXG4gIFwiJz09J1wiLFxuICBcIichPSdcIixcbiAgXCInJiYnXCIsXG4gIFwiJz8nXCIsXG4gIFwiJ3w9J1wiLFxuICBcIidePSdcIixcbiAgXCInJj0nXCIsXG4gIFwiJzw8PSdcIixcbiAgXCInPj49J1wiLFxuICBcIicrPSdcIixcbiAgXCInLT0nXCIsXG4gIFwiJyo9J1wiLFxuICBcIicvPSdcIixcbiAgXCInJT0nXCIsXG4gIFwiJ2xldCdcIixcbiAgXCInOj0nXCIsXG4gIFwiJz06J1wiLFxuICBcIidzd2l0Y2gnXCIsXG4gIFwiJ2Nhc2UnXCIsXG4gIFwiJ2RlZmF1bHQnXCIsXG4gIFwiJy0+J1wiLFxuICBcIidjYWxsYmFjaydcIixcbiAgXCInb3ZlcnJpZGUnXCIsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICBcIidhbm9ueW1vdXMnXCIsXG4gIFwiJ2JyZWFrJ1wiLFxuICBcIidjb25zdGFudCdcIixcbiAgXCInaW1tdXRhYmxlJ1wiLFxuICBcIidjb250aW51ZSdcIixcbiAgXCInbGVhdmUnXCIsXG4gIFwiJ2V4dGVybmFsJ1wiLFxuICBcIidpbmRleGVkJ1wiLFxuICBcIidpbnRlcm5hbCdcIixcbiAgXCIncGF5YWJsZSdcIixcbiAgXCIncHJpdmF0ZSdcIixcbiAgXCIncHVibGljJ1wiLFxuICBcIid2aXJ0dWFsJ1wiLFxuICBcIidwdXJlJ1wiLFxuICBcIid0eXBlJ1wiLFxuICBcIid2aWV3J1wiLFxuICBcIidnbG9iYWwnXCIsXG4gIFwiJ2NvbnN0cnVjdG9yJ1wiLFxuICBcIidmYWxsYmFjaydcIixcbiAgXCIncmVjZWl2ZSdcIlxuXTtcblNvbGlkaXR5UGFyc2VyLl9TWU1CT0xJQ19OQU1FUyA9IFtcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIHZvaWQgMCxcbiAgdm9pZCAwLFxuICB2b2lkIDAsXG4gIFwiSW50XCIsXG4gIFwiVWludFwiLFxuICBcIkJ5dGVcIixcbiAgXCJGaXhlZFwiLFxuICBcIlVmaXhlZFwiLFxuICBcIkJvb2xlYW5MaXRlcmFsXCIsXG4gIFwiRGVjaW1hbE51bWJlclwiLFxuICBcIkhleE51bWJlclwiLFxuICBcIk51bWJlclVuaXRcIixcbiAgXCJIZXhMaXRlcmFsRnJhZ21lbnRcIixcbiAgXCJSZXNlcnZlZEtleXdvcmRcIixcbiAgXCJBbm9ueW1vdXNLZXl3b3JkXCIsXG4gIFwiQnJlYWtLZXl3b3JkXCIsXG4gIFwiQ29uc3RhbnRLZXl3b3JkXCIsXG4gIFwiSW1tdXRhYmxlS2V5d29yZFwiLFxuICBcIkNvbnRpbnVlS2V5d29yZFwiLFxuICBcIkxlYXZlS2V5d29yZFwiLFxuICBcIkV4dGVybmFsS2V5d29yZFwiLFxuICBcIkluZGV4ZWRLZXl3b3JkXCIsXG4gIFwiSW50ZXJuYWxLZXl3b3JkXCIsXG4gIFwiUGF5YWJsZUtleXdvcmRcIixcbiAgXCJQcml2YXRlS2V5d29yZFwiLFxuICBcIlB1YmxpY0tleXdvcmRcIixcbiAgXCJWaXJ0dWFsS2V5d29yZFwiLFxuICBcIlB1cmVLZXl3b3JkXCIsXG4gIFwiVHlwZUtleXdvcmRcIixcbiAgXCJWaWV3S2V5d29yZFwiLFxuICBcIkdsb2JhbEtleXdvcmRcIixcbiAgXCJDb25zdHJ1Y3RvcktleXdvcmRcIixcbiAgXCJGYWxsYmFja0tleXdvcmRcIixcbiAgXCJSZWNlaXZlS2V5d29yZFwiLFxuICBcIklkZW50aWZpZXJcIixcbiAgXCJTdHJpbmdMaXRlcmFsRnJhZ21lbnRcIixcbiAgXCJWZXJzaW9uTGl0ZXJhbFwiLFxuICBcIldTXCIsXG4gIFwiQ09NTUVOVFwiLFxuICBcIkxJTkVfQ09NTUVOVFwiXG5dO1xuU29saWRpdHlQYXJzZXIuVk9DQUJVTEFSWSA9IG5ldyBpbXBvcnRfVm9jYWJ1bGFyeUltcGwyLlZvY2FidWxhcnlJbXBsKF9Tb2xpZGl0eVBhcnNlci5fTElURVJBTF9OQU1FUywgX1NvbGlkaXR5UGFyc2VyLl9TWU1CT0xJQ19OQU1FUywgW10pO1xuU29saWRpdHlQYXJzZXIuX3NlcmlhbGl6ZWRBVE5TZWdtZW50cyA9IDM7XG5Tb2xpZGl0eVBhcnNlci5fc2VyaWFsaXplZEFUTlNlZ21lbnQwID0gXCJcdTAwMDNcXHVDOTFEXFx1Q0FCQVxcdTA1OERcXHVBRkJBXFx1NEY1M1xcdTA2MDdcXHVFQThCXFx1QzI0MVx1MDAwM1xceDg4XFx1MDQ4MVx1MDAwNFx1MDAwMlx0XHUwMDAyXHUwMDA0XHUwMDAzXHRcdTAwMDNcdTAwMDRcdTAwMDRcdFx1MDAwNFx1MDAwNFx1MDAwNVx0XHUwMDA1XHUwMDA0XHUwMDA2XHRcdTAwMDZcdTAwMDRcXHgwN1x0XFx4MDdcdTAwMDRcXGJcdFxcYlx1MDAwNFx0XHRcdFx1MDAwNFxcblx0XFxuXHUwMDA0XFx2XHRcXHZcdTAwMDRcXGZcdFxcZlx1MDAwNFxcclx0XFxyXHUwMDA0XHUwMDBlXHRcdTAwMGVcdTAwMDRcdTAwMGZcdFx1MDAwZlx1MDAwNFx1MDAxMFx0XHUwMDEwXHUwMDA0XHUwMDExXHRcdTAwMTFcdTAwMDRcdTAwMTJcdFx1MDAxMlx1MDAwNFx1MDAxM1x0XHUwMDEzXHUwMDA0XHUwMDE0XHRcdTAwMTRcdTAwMDRcdTAwMTVcdFx1MDAxNVx1MDAwNFx1MDAxNlx0XHUwMDE2XHUwMDA0XHUwMDE3XHRcdTAwMTdcdTAwMDRcdTAwMThcdFx1MDAxOFx1MDAwNFx1MDAxOVx0XHUwMDE5XHUwMDA0XHUwMDFhXHRcdTAwMWFcdTAwMDRcdTAwMWJcdFx1MDAxYlx1MDAwNFx1MDAxY1x0XHUwMDFjXHUwMDA0XHUwMDFkXHRcdTAwMWRcdTAwMDRcdTAwMWVcdFx1MDAxZVx1MDAwNFx1MDAxZlx0XHUwMDFmXHUwMDA0IFx0IFx1MDAwNCFcdCFcdTAwMDRcXFwiXHRcXFwiXHUwMDA0I1x0I1x1MDAwNCRcdCRcdTAwMDQlXHQlXHUwMDA0Jlx0Jlx1MDAwNCdcdCdcdTAwMDQoXHQoXHUwMDA0KVx0KVx1MDAwNCpcdCpcdTAwMDQrXHQrXHUwMDA0LFx0LFx1MDAwNC1cdC1cdTAwMDQuXHQuXHUwMDA0L1x0L1x1MDAwNDBcdDBcdTAwMDQxXHQxXHUwMDA0Mlx0Mlx1MDAwNDNcdDNcdTAwMDQ0XHQ0XHUwMDA0NVx0NVx1MDAwNDZcdDZcdTAwMDQ3XHQ3XHUwMDA0OFx0OFx1MDAwNDlcdDlcdTAwMDQ6XHQ6XHUwMDA0O1x0O1x1MDAwNDxcdDxcdTAwMDQ9XHQ9XHUwMDA0Plx0Plx1MDAwND9cdD9cdTAwMDRAXHRAXHUwMDA0QVx0QVx1MDAwNEJcdEJcdTAwMDRDXHRDXHUwMDA0RFx0RFx1MDAwNEVcdEVcdTAwMDRGXHRGXHUwMDA0R1x0R1x1MDAwNEhcdEhcdTAwMDRJXHRJXHUwMDA0Slx0Slx1MDAwNEtcdEtcdTAwMDRMXHRMXHUwMDA0TVx0TVx1MDAwNE5cdE5cdTAwMDRPXHRPXHUwMDA0UFx0UFx1MDAwNFFcdFFcdTAwMDRSXHRSXHUwMDA0U1x0U1x1MDAwNFRcdFRcdTAwMDRVXHRVXHUwMDA0Vlx0Vlx1MDAwNFdcdFdcdTAwMDRYXHRYXHUwMDA0WVx0WVx1MDAwNFpcdFpcdTAwMDRbXHRbXHUwMDA0XFxcXFx0XFxcXFx1MDAwNF1cdF1cdTAwMDReXHReXHUwMDA0X1x0X1x1MDAwNGBcdGBcdTAwMDRhXHRhXHUwMDA0Ylx0Ylx1MDAwNGNcdGNcdTAwMDNcdTAwMDJcdTAwMDNcdTAwMDJcdTAwMDNcdTAwMDJcdTAwMDNcdTAwMDJcdTAwMDNcdTAwMDJcdTAwMDNcdTAwMDJcdTAwMDNcdTAwMDJcdTAwMDNcdTAwMDJcdTAwMDNcdTAwMDJcdTAwMDNcdTAwMDJcXHgwN1x1MDAwMlxceEQxXFxuXHUwMDAyXFxmXHUwMDAyXHUwMDBlXHUwMDAyXFx4RDRcXHZcdTAwMDJcdTAwMDNcdTAwMDJcdTAwMDNcdTAwMDJcdTAwMDNcdTAwMDNcdTAwMDNcdTAwMDNcdTAwMDNcdTAwMDNcdTAwMDNcdTAwMDNcdTAwMDNcdTAwMDNcdTAwMDNcdTAwMDRcdTAwMDNcdTAwMDRcdTAwMDNcdTAwMDVcdTAwMDNcdTAwMDVcdTAwMDNcdTAwMDVcdTAwMDVcdTAwMDVcXHhFMlxcblx1MDAwNVx1MDAwM1x1MDAwNlx1MDAwM1x1MDAwNlx1MDAwNVx1MDAwNlxceEU2XFxuXHUwMDA2XHUwMDAzXHUwMDA2XFx4MDdcdTAwMDZcXHhFOVxcblx1MDAwNlxcZlx1MDAwNlx1MDAwZVx1MDAwNlxceEVDXFx2XHUwMDA2XHUwMDAzXFx4MDdcdTAwMDNcXHgwN1x1MDAwM1xcYlx1MDAwNVxcYlxceEYxXFxuXFxiXHUwMDAzXFxiXHUwMDAzXFxiXHUwMDA1XFxiXFx4RjVcXG5cXGJcdTAwMDNcXGJcdTAwMDVcXGJcXHhGOFxcblxcYlx1MDAwM1x0XHUwMDAzXHRcdTAwMDNcdFx1MDAwNVx0XFx4RkRcXG5cdFx1MDAwM1xcblx1MDAwM1xcblx1MDAwM1xcblx1MDAwM1xcblx1MDAwNVxcblxcdTAxMDNcXG5cXG5cdTAwMDNcXG5cdTAwMDNcXG5cdTAwMDNcXG5cdTAwMDNcXG5cdTAwMDNcXG5cdTAwMDVcXG5cXHUwMTBBXFxuXFxuXHUwMDAzXFxuXHUwMDAzXFxuXHUwMDA1XFxuXFx1MDEwRVxcblxcblx1MDAwM1xcblx1MDAwM1xcblx1MDAwM1xcblx1MDAwM1xcblx1MDAwM1xcblx1MDAwM1xcblx1MDAwM1xcblx1MDAwM1xcblx1MDAwM1xcblxceDA3XFxuXFx1MDExOVxcblxcblxcZlxcblx1MDAwZVxcblxcdTAxMUNcXHZcXG5cdTAwMDNcXG5cdTAwMDNcXG5cdTAwMDNcXG5cdTAwMDNcXG5cdTAwMDNcXG5cdTAwMDVcXG5cXHUwMTIzXFxuXFxuXHUwMDAzXFx2XHUwMDAzXFx2XHUwMDAzXFxmXHUwMDA1XFxmXFx1MDEyOFxcblxcZlx1MDAwM1xcZlx1MDAwM1xcZlx1MDAwM1xcZlx1MDAwM1xcZlx1MDAwM1xcZlx1MDAwM1xcZlxceDA3XFxmXFx1MDEzMFxcblxcZlxcZlxcZlx1MDAwZVxcZlxcdTAxMzNcXHZcXGZcdTAwMDVcXGZcXHUwMTM1XFxuXFxmXHUwMDAzXFxmXHUwMDAzXFxmXFx4MDdcXGZcXHUwMTM5XFxuXFxmXFxmXFxmXHUwMDBlXFxmXFx1MDEzQ1xcdlxcZlx1MDAwM1xcZlx1MDAwM1xcZlx1MDAwM1xcclx1MDAwM1xcclx1MDAwM1xcclx1MDAwNVxcclxcdTAxNDNcXG5cXHJcdTAwMDNcXHJcdTAwMDVcXHJcXHUwMTQ2XFxuXFxyXHUwMDAzXHUwMDBlXHUwMDAzXHUwMDBlXHUwMDAzXHUwMDBlXHUwMDAzXHUwMDBlXHUwMDAzXHUwMDBlXHUwMDAzXHUwMDBlXHUwMDAzXHUwMDBlXHUwMDAzXHUwMDBlXHUwMDAzXHUwMDBlXHUwMDA1XHUwMDBlXFx1MDE1MVxcblx1MDAwZVx1MDAwM1x1MDAwZlx1MDAwM1x1MDAwZlx1MDAwM1x1MDAwZlx1MDAwM1x1MDAwZlx1MDAwM1x1MDAwZlx1MDAwM1x1MDAwZlx1MDAwM1x1MDAwZlxceDA3XHUwMDBmXFx1MDE1QVxcblx1MDAwZlxcZlx1MDAwZlx1MDAwZVx1MDAwZlxcdTAxNURcXHZcdTAwMGZcdTAwMDNcdTAwMGZcdTAwMDNcdTAwMGZcdTAwMDNcdTAwMGZcdTAwMDVcdTAwMGZcXHUwMTYyXFxuXHUwMDBmXHUwMDAzXHUwMDBmXHUwMDAzXHUwMDBmXHUwMDAzXHUwMDEwXHUwMDAzXHUwMDEwXHUwMDAzXHUwMDEwXHUwMDAzXHUwMDEwXHUwMDAzXHUwMDEwXHUwMDAzXHUwMDEwXHUwMDAzXHUwMDEwXHUwMDAzXHUwMDExXHUwMDAzXHUwMDExXHUwMDAzXHUwMDExXHUwMDAzXHUwMDExXHUwMDAzXHUwMDExXHUwMDAzXHUwMDEyXHUwMDAzXHUwMDEyXHUwMDAzXHUwMDEyXHUwMDAzXHUwMDEyXHUwMDAzXHUwMDEyXHUwMDAzXHUwMDEyXHUwMDAzXHUwMDEzXHUwMDAzXHUwMDEzXHUwMDAzXHUwMDEzXHUwMDAzXHUwMDEzXHUwMDAzXHUwMDEzXHUwMDA1XHUwMDEzXFx1MDE3RFxcblx1MDAxM1x1MDAwM1x1MDAxM1x1MDAwNVx1MDAxM1xcdTAxODBcXG5cdTAwMTNcdTAwMDNcdTAwMTNcdTAwMDNcdTAwMTNcdTAwMDNcdTAwMTRcdTAwMDNcdTAwMTRcdTAwMDNcdTAwMTRcdTAwMDNcdTAwMTRcdTAwMDNcdTAwMTRcXHgwN1x1MDAxNFxcdTAxODlcXG5cdTAwMTRcXGZcdTAwMTRcdTAwMGVcdTAwMTRcXHUwMThDXFx2XHUwMDE0XHUwMDAzXHUwMDE0XHUwMDAzXHUwMDE0XHUwMDA1XHUwMDE0XFx1MDE5MFxcblx1MDAxNFx1MDAwM1x1MDAxNVx1MDAwM1x1MDAxNVx1MDAwM1x1MDAxNVx1MDAwM1x1MDAxNVx1MDAwM1x1MDAxNVx1MDAwM1x1MDAxNVx1MDAwM1x1MDAxNVx1MDAwM1x1MDAxNVxceDA3XHUwMDE1XFx1MDE5QVxcblx1MDAxNVxcZlx1MDAxNVx1MDAwZVx1MDAxNVxcdTAxOURcXHZcdTAwMTVcdTAwMDVcdTAwMTVcXHUwMTlGXFxuXHUwMDE1XHUwMDAzXHUwMDE1XHUwMDAzXHUwMDE1XHUwMDAzXHUwMDE2XHUwMDAzXHUwMDE2XHUwMDAzXHUwMDE2XHUwMDA1XHUwMDE2XFx1MDFBNlxcblx1MDAxNlx1MDAwM1x1MDAxNlx1MDAwM1x1MDAxNlxceDA3XHUwMDE2XFx1MDFBQVxcblx1MDAxNlxcZlx1MDAxNlx1MDAwZVx1MDAxNlxcdTAxQURcXHZcdTAwMTZcdTAwMDNcdTAwMTZcdTAwMDNcdTAwMTZcdTAwMDVcdTAwMTZcXHUwMUIxXFxuXHUwMDE2XHUwMDAzXHUwMDE3XHUwMDAzXHUwMDE3XHUwMDAzXHUwMDE3XHUwMDA1XHUwMDE3XFx1MDFCNlxcblx1MDAxN1x1MDAwM1x1MDAxN1x1MDAwNVx1MDAxN1xcdTAxQjlcXG5cdTAwMTdcdTAwMDNcdTAwMThcdTAwMDNcdTAwMThcdTAwMDNcdTAwMThcdTAwMDNcdTAwMThcdTAwMDVcdTAwMThcXHUwMUJGXFxuXHUwMDE4XHUwMDAzXHUwMDE4XHUwMDAzXHUwMDE4XHUwMDA1XHUwMDE4XFx1MDFDM1xcblx1MDAxOFx1MDAwM1x1MDAxOVx1MDAwM1x1MDAxOVx1MDAwNVx1MDAxOVxcdTAxQzdcXG5cdTAwMTlcdTAwMDNcdTAwMTlcdTAwMDNcdTAwMTlcdTAwMDNcdTAwMTlcdTAwMDVcdTAwMTlcXHUwMUNDXFxuXHUwMDE5XHUwMDAzXHUwMDFhXHUwMDAzXHUwMDFhXHUwMDAzXHUwMDFhXHUwMDAzXHUwMDFiXHUwMDAzXHUwMDFiXHUwMDAzXHUwMDFiXHUwMDAzXHUwMDFiXHUwMDAzXHUwMDFiXHUwMDAzXHUwMDFiXHUwMDAzXHUwMDFiXHUwMDAzXHUwMDFiXFx4MDdcdTAwMWJcXHUwMUQ5XFxuXHUwMDFiXFxmXHUwMDFiXHUwMDBlXHUwMDFiXFx1MDFEQ1xcdlx1MDAxYlx1MDAwM1x1MDAxY1x1MDAwM1x1MDAxY1x1MDAwM1x1MDAxY1x1MDAwM1x1MDAxY1x1MDAwNVx1MDAxY1xcdTAxRTJcXG5cdTAwMWNcdTAwMDNcdTAwMWNcdTAwMDNcdTAwMWNcdTAwMDNcdTAwMWRcdTAwMDNcdTAwMWRcdTAwMDNcdTAwMWVcdTAwMDNcdTAwMWVcdTAwMDNcdTAwMWVcdTAwMDNcdTAwMWVcdTAwMDVcdTAwMWVcXHUwMUVDXFxuXHUwMDFlXHUwMDAzXHUwMDFlXHUwMDAzXHUwMDFlXFx4MDdcdTAwMWVcXHUwMUYwXFxuXHUwMDFlXFxmXHUwMDFlXHUwMDBlXHUwMDFlXFx1MDFGM1xcdlx1MDAxZVx1MDAwM1x1MDAxZVx1MDAwM1x1MDAxZVx1MDAwM1x1MDAxZlx1MDAwM1x1MDAxZlx1MDAwM1x1MDAxZlx1MDAwM1x1MDAxZlxceDA3XHUwMDFmXFx1MDFGQlxcblx1MDAxZlxcZlx1MDAxZlx1MDAwZVx1MDAxZlxcdTAxRkVcXHZcdTAwMWZcdTAwMDVcdTAwMWZcXHUwMjAwXFxuXHUwMDFmXHUwMDAzXHUwMDFmXHUwMDAzXHUwMDFmXHUwMDAzIFx1MDAwMyBcdTAwMDUgXFx1MDIwNlxcbiBcdTAwMDMgXHUwMDA1IFxcdTAyMDlcXG4gXHUwMDAzIVx1MDAwMyFcdTAwMDMhXHUwMDAzIVxceDA3IVxcdTAyMEZcXG4hXFxmIVx1MDAwZSFcXHUwMjEyXFx2IVx1MDAwNSFcXHUwMjE0XFxuIVx1MDAwMyFcdTAwMDMhXHUwMDAzXFxcIlx1MDAwM1xcXCJcdTAwMDVcXFwiXFx1MDIxQVxcblxcXCJcdTAwMDNcXFwiXHUwMDA1XFxcIlxcdTAyMURcXG5cXFwiXHUwMDAzI1x1MDAwMyNcdTAwMDMjXHUwMDAzI1xceDA3I1xcdTAyMjNcXG4jXFxmI1x1MDAwZSNcXHUwMjI2XFx2I1x1MDAwNSNcXHUwMjI4XFxuI1x1MDAwMyNcdTAwMDMjXHUwMDAzJFx1MDAwMyRcdTAwMDUkXFx1MDIyRVxcbiRcdTAwMDMlXHUwMDAzJVx1MDAwNSVcXHUwMjMyXFxuJVx1MDAwMyVcdTAwMDMlXHUwMDAzJlx1MDAwMyZcdTAwMDMmXHUwMDAzJlx1MDAwMyZcdTAwMDMmXHUwMDAzJlx1MDAwNSZcXHUwMjNEXFxuJlx1MDAwMyZcdTAwMDMmXHUwMDAzJlx1MDAwNSZcXHUwMjQyXFxuJlx1MDAwMyZcXHgwNyZcXHUwMjQ1XFxuJlxcZiZcdTAwMGUmXFx1MDI0OFxcdiZcdTAwMDMnXHUwMDAzJ1x1MDAwMydcXHgwNydcXHUwMjREXFxuJ1xcZidcdTAwMGUnXFx1MDI1MFxcdidcdTAwMDMoXHUwMDAzKFx1MDAwNShcXHUwMjU0XFxuKFx1MDAwMylcdTAwMDMpXHUwMDAzKVx1MDAwMylcdTAwMDMpXHUwMDAzKVx1MDAwMylcdTAwMDMqXHUwMDAzKlx1MDAwMypcdTAwMDMqXHUwMDAzKlxceDA3KlxcdTAyNjJcXG4qXFxmKlx1MDAwZSpcXHUwMjY1XFx2Klx1MDAwMypcdTAwMDMqXHUwMDA1KlxcdTAyNjlcXG4qXHUwMDAzK1x1MDAwMytcdTAwMDMsXHUwMDAzLFx1MDAwMy1cdTAwMDMtXFx4MDctXFx1MDI3MVxcbi1cXGYtXHUwMDBlLVxcdTAyNzRcXHYtXHUwMDAzLVx1MDAwMy1cdTAwMDMuXHUwMDAzLlx1MDAwMy5cdTAwMDMuXHUwMDAzLlx1MDAwMy5cdTAwMDMuXHUwMDAzLlx1MDAwMy5cdTAwMDMuXHUwMDAzLlx1MDAwMy5cdTAwMDMuXHUwMDAzLlx1MDAwMy5cdTAwMDUuXFx1MDI4N1xcbi5cdTAwMDMvXHUwMDAzL1x1MDAwMy9cdTAwMDMwXHUwMDAzMFx1MDAwMzBcdTAwMDMwXHUwMDAzMFx1MDAwMzBcdTAwMDMwXHUwMDA1MFxcdTAyOTNcXG4wXHUwMDAzMVx1MDAwMzFcdTAwMDMxXHUwMDA1MVxcdTAyOThcXG4xXHUwMDAzMVx1MDAwMzFcdTAwMDYxXFx1MDI5Q1xcbjFcXHIxXHUwMDBlMVxcdTAyOURcdTAwMDMyXHUwMDAzMlx1MDAwNTJcXHUwMkEyXFxuMlx1MDAwMzJcdTAwMDUyXFx1MDJBNVxcbjJcdTAwMDMyXHUwMDAzMlx1MDAwMzNcdTAwMDMzXHUwMDAzM1x1MDAwMzNcdTAwMDMzXHUwMDAzM1x1MDAwMzRcdTAwMDM0XHUwMDA1NFxcdTAyQjFcXG40XHUwMDAzNVx1MDAwMzVcdTAwMDM1XHUwMDAzNlx1MDAwMzZcdTAwMDM2XHUwMDAzNlx1MDAwNTZcXHUwMkJBXFxuNlx1MDAwMzZcdTAwMDM2XHUwMDA1NlxcdTAyQkVcXG42XHUwMDAzNlx1MDAwNTZcXHUwMkMxXFxuNlx1MDAwMzZcdTAwMDM2XHUwMDAzNlx1MDAwMzdcdTAwMDM3XHUwMDA1N1xcdTAyQzhcXG43XHUwMDAzN1x1MDAwMzdcdTAwMDM3XHUwMDAzN1x1MDAwNTdcXHUwMkNFXFxuN1x1MDAwMzdcdTAwMDM3XHUwMDAzOFx1MDAwMzhcdTAwMDM5XHUwMDAzOVx1MDAwMzlcdTAwMDM5XHUwMDAzOVx1MDAwMzlcdTAwMDM5XHUwMDAzOVx1MDAwMzpcdTAwMDM6XHUwMDAzOlx1MDAwMztcdTAwMDM7XHUwMDAzO1x1MDAwMzxcdTAwMDM8XHUwMDA1PFxcdTAyRTRcXG48XHUwMDAzPFx1MDAwMzxcdTAwMDM9XHUwMDAzPVx1MDAwMz1cdTAwMDM+XHUwMDAzPlx1MDAwMz5cdTAwMDM+XHUwMDAzP1x1MDAwMz9cdTAwMDM/XHUwMDAzP1x1MDAwM0BcdTAwMDNAXHUwMDAzQFx1MDAwM0BcdTAwMDNAXHUwMDAzQFx1MDAwM0BcdTAwMDVAXFx1MDJGQVxcbkBcdTAwMDNAXHUwMDAzQFx1MDAwNUBcXHUwMkZFXFxuQFx1MDAwM0BcdTAwMDNAXHUwMDAzQVx1MDAwNUFcXHUwMzAzXFxuQVx1MDAwM0FcdTAwMDNBXHUwMDA1QVxcdTAzMDdcXG5BXFx4MDdBXFx1MDMwOVxcbkFcXGZBXHUwMDBlQVxcdTAzMENcXHZBXHUwMDAzQlx1MDAwM0JcdTAwMDVCXFx1MDMxMFxcbkJcdTAwMDNCXFx4MDdCXFx1MDMxM1xcbkJcXGZCXHUwMDBlQlxcdTAzMTZcXHZCXHUwMDAzQlx1MDAwNUJcXHUwMzE5XFxuQlx1MDAwM0JcdTAwMDNCXHUwMDAzQ1x1MDAwM0NcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDVEXFx1MDMzMVxcbkRcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDA1RFxcdTAzNjdcXG5EXHUwMDAzRFx1MDAwM0RcdTAwMDVEXFx1MDM2QlxcbkRcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFx1MDAwM0RcdTAwMDNEXHUwMDAzRFxceDA3RFxcdTAzN0JcXG5EXFxmRFx1MDAwZURcXHUwMzdFXFx2RFx1MDAwM0VcdTAwMDNFXHUwMDAzRVx1MDAwM0VcdTAwMDNFXHUwMDAzRVx1MDAwM0VcdTAwMDNFXHUwMDAzRVx1MDAwNUVcXHUwMzg5XFxuRVx1MDAwM0ZcdTAwMDNGXHUwMDAzRlxceDA3RlxcdTAzOEVcXG5GXFxmRlx1MDAwZUZcXHUwMzkxXFx2Rlx1MDAwM0dcdTAwMDNHXHUwMDAzR1xceDA3R1xcdTAzOTZcXG5HXFxmR1x1MDAwZUdcXHUwMzk5XFx2R1x1MDAwM0dcdTAwMDVHXFx1MDM5Q1xcbkdcdTAwMDNIXHUwMDAzSFx1MDAwM0hcdTAwMDNIXHUwMDAzSVx1MDAwM0lcdTAwMDVJXFx1MDNBNFxcbklcdTAwMDNJXHUwMDAzSVx1MDAwNUlcXHUwM0E4XFxuSVx1MDAwNUlcXHUwM0FBXFxuSVx1MDAwM0pcdTAwMDNKXHUwMDAzSlx1MDAwM0pcdTAwMDNKXHUwMDAzS1x1MDAwM0tcXHgwN0tcXHUwM0IzXFxuS1xcZktcdTAwMGVLXFx1MDNCNlxcdktcdTAwMDNLXHUwMDAzS1x1MDAwM0xcdTAwMDNMXHUwMDAzTFx1MDAwM0xcdTAwMDNMXHUwMDAzTFx1MDAwM0xcdTAwMDNMXHUwMDAzTFx1MDAwM0xcdTAwMDNMXHUwMDAzTFx1MDAwM0xcdTAwMDNMXHUwMDAzTFx1MDAwM0xcdTAwMDNMXHUwMDAzTFx1MDAwNUxcXHUwM0NDXFxuTFx1MDAwM01cdTAwMDNNXHUwMDAzTVx1MDAwNU1cXHUwM0QxXFxuTVx1MDAwM05cdTAwMDNOXHUwMDAzTlx1MDAwM05cdTAwMDNPXHUwMDAzT1x1MDAwM09cdTAwMDNPXHUwMDA1T1xcdTAzREJcXG5PXHUwMDAzT1x1MDAwM09cdTAwMDVPXFx1MDNERlxcbk9cdTAwMDNPXHUwMDAzT1xceDA3T1xcdTAzRTNcXG5PXFxmT1x1MDAwZU9cXHUwM0U2XFx2T1x1MDAwM09cdTAwMDVPXFx1MDNFOVxcbk9cdTAwMDNQXHUwMDAzUFx1MDAwM1BcdTAwMDNQXHUwMDA1UFxcdTAzRUZcXG5QXHUwMDAzUVx1MDAwM1FcdTAwMDNRXHUwMDAzUVx1MDAwM1JcdTAwMDNSXHUwMDAzUlx1MDAwM1JcdTAwMDNSXHUwMDAzUlx1MDAwM1JcdTAwMDVSXFx1MDNGQ1xcblJcdTAwMDNTXHUwMDAzU1x1MDAwM1NcXHgwN1NcXHUwNDAxXFxuU1xcZlNcdTAwMGVTXFx1MDQwNFxcdlNcdTAwMDNUXHUwMDAzVFx1MDAwM1RcdTAwMDNUXHUwMDAzVVx1MDAwM1VcdTAwMDNVXHUwMDAzVlx1MDAwM1ZcdTAwMDNWXFx4MDdWXFx1MDQxMFxcblZcXGZWXHUwMDBlVlxcdTA0MTNcXHZWXHUwMDAzV1x1MDAwM1dcdTAwMDNXXHUwMDAzV1x1MDAwM1dcdTAwMDNXXHUwMDA1V1xcdTA0MUJcXG5XXHUwMDAzWFx1MDAwM1hcdTAwMDNYXHUwMDAzWFx1MDAwNVhcXHUwNDIxXFxuWFx1MDAwM1hcdTAwMDNYXHUwMDA1WFxcdTA0MjVcXG5YXHUwMDAzWFx1MDAwM1hcdTAwMDNZXHUwMDAzWVx1MDAwM1lcdTAwMDNaXHUwMDAzWlx1MDAwM1pcdTAwMDVaXFx1MDQyRlxcblpcdTAwMDNaXHUwMDAzWlx1MDAwM1pcdTAwMDVaXFx1MDQzNFxcblpcdTAwMDNaXHUwMDAzWlx1MDAwM1tcdTAwMDNbXHUwMDAzW1x1MDAwM1tcdTAwMDNcXFxcXHUwMDAzXFxcXFx1MDAwM1xcXFxcdTAwMDNcXFxcXHUwMDAzXFxcXFx1MDAwNVxcXFxcXHUwNDQxXFxuXFxcXFx1MDAwM11cdTAwMDNdXHUwMDAzXVx1MDAwM11cdTAwMDNeXHUwMDAzXlx1MDAwNV5cXHUwNDQ5XFxuXlx1MDAwM15cdTAwMDNeXHUwMDA1XlxcdTA0NERcXG5eXFx4MDdeXFx1MDQ0Rlxcbl5cXGZeXHUwMDBlXlxcdTA0NTJcXHZeXHUwMDAzXlx1MDAwM15cdTAwMDNeXHUwMDAzXlx1MDAwM15cXHgwN15cXHUwNDU5XFxuXlxcZl5cdTAwMGVeXFx1MDQ1Q1xcdl5cdTAwMDVeXFx1MDQ1RVxcbl5cdTAwMDNeXHUwMDA1XlxcdTA0NjFcXG5eXHUwMDAzX1x1MDAwM19cdTAwMDVfXFx1MDQ2NVxcbl9cdTAwMDNgXHUwMDAzYFx1MDAwM2FcdTAwMDZhXFx1MDQ2QVxcbmFcXHJhXHUwMDBlYVxcdTA0NkJcdTAwMDNiXHUwMDAzYlx1MDAwM2JcdTAwMDNiXHUwMDAzYlxceDA3YlxcdTA0NzNcXG5iXFxmYlx1MDAwZWJcXHUwNDc2XFx2Ylx1MDAwM2JcdTAwMDNiXHUwMDA1YlxcdTA0N0FcXG5iXHUwMDAzY1x1MDAwNmNcXHUwNDdEXFxuY1xccmNcdTAwMGVjXFx1MDQ3RVx1MDAwM2NcdTAwMDJcdTAwMDJcdTAwMDRKXFx4ODZkXHUwMDAyXHUwMDAyXHUwMDA0XHUwMDAyXHUwMDA2XHUwMDAyXFxiXHUwMDAyXFxuXHUwMDAyXFxmXHUwMDAyXHUwMDBlXHUwMDAyXHUwMDEwXHUwMDAyXHUwMDEyXHUwMDAyXHUwMDE0XHUwMDAyXHUwMDE2XHUwMDAyXHUwMDE4XHUwMDAyXHUwMDFhXHUwMDAyXHUwMDFjXHUwMDAyXHUwMDFlXHUwMDAyIFx1MDAwMlxcXCJcdTAwMDIkXHUwMDAyJlx1MDAwMihcdTAwMDIqXHUwMDAyLFx1MDAwMi5cdTAwMDIwXHUwMDAyMlx1MDAwMjRcdTAwMDI2XHUwMDAyOFx1MDAwMjpcdTAwMDI8XHUwMDAyPlx1MDAwMkBcdTAwMDJCXHUwMDAyRFx1MDAwMkZcdTAwMDJIXHUwMDAySlx1MDAwMkxcdTAwMDJOXHUwMDAyUFx1MDAwMlJcdTAwMDJUXHUwMDAyVlx1MDAwMlhcdTAwMDJaXHUwMDAyXFxcXFx1MDAwMl5cdTAwMDJgXHUwMDAyYlx1MDAwMmRcdTAwMDJmXHUwMDAyaFx1MDAwMmpcdTAwMDJsXHUwMDAyblx1MDAwMnBcdTAwMDJyXHUwMDAydFx1MDAwMnZcdTAwMDJ4XHUwMDAyelx1MDAwMnxcdTAwMDJ+XHUwMDAyXFx4ODBcdTAwMDJcXHg4Mlx1MDAwMlxceDg0XHUwMDAyXFx4ODZcdTAwMDJcXHg4OFx1MDAwMlxceDhBXHUwMDAyXFx4OENcdTAwMDJcXHg4RVx1MDAwMlxceDkwXHUwMDAyXFx4OTJcdTAwMDJcXHg5NFx1MDAwMlxceDk2XHUwMDAyXFx4OThcdTAwMDJcXHg5QVx1MDAwMlxceDlDXHUwMDAyXFx4OUVcdTAwMDJcXHhBMFx1MDAwMlxceEEyXHUwMDAyXFx4QTRcdTAwMDJcXHhBNlx1MDAwMlxceEE4XHUwMDAyXFx4QUFcdTAwMDJcXHhBQ1x1MDAwMlxceEFFXHUwMDAyXFx4QjBcdTAwMDJcXHhCMlx1MDAwMlxceEI0XHUwMDAyXFx4QjZcdTAwMDJcXHhCOFx1MDAwMlxceEJBXHUwMDAyXFx4QkNcdTAwMDJcXHhCRVx1MDAwMlxceEMwXHUwMDAyXFx4QzJcdTAwMDJcXHhDNFx1MDAwMlx1MDAwMlx1MDAxMVx1MDAwM1x1MDAwMlxceDA3XFxyXHUwMDAzXHUwMDAyXHUwMDE1XHUwMDE3XHUwMDAzXHUwMDAyKixcdTAwMDZcdTAwMDJxcXh4fHx+flx1MDAwNVx1MDAwMiYmOTxkaFx1MDAwM1x1MDAwMj0+XHUwMDAzXHUwMDAyQUJcdTAwMDNcdTAwMDJDRFx1MDAwNFx1MDAwMlx1MDAwNVx1MDAwNUdIXHUwMDAzXHUwMDAySUpcdTAwMDNcdTAwMDJcdFxcZlx1MDAwM1x1MDAwMk1OXHUwMDA0XHUwMDAyXFxyXFxyUVpcdTAwMDNcdTAwMDJqa1xcZlx1MDAwMlx1MDAxMFx1MDAxMFx1MDAxYlx1MDAxYiYmLCw4OGJidHR4eFxceDgwXFx4ODBcXHg4MlxceDgzXHUwMDAyXFx1MDUwMlx1MDAwMlxceEQyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDA0XFx4RDdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMDZcXHhEQ1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcYlxceEUxXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFxuXFx4RTNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXGZcXHhFRFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAwZVxceEY3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDEwXFx4RjlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMTJcXHUwMTIyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDE0XFx1MDEyNFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAxNlxcdTAxMjdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMThcXHUwMTNGXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXHUwMDFhXFx1MDE1MFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlx1MDAxY1xcdTAxNTJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcdTAwMWVcXHUwMTY1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyIFxcdTAxNkNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXFwiXFx1MDE3MVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMiRcXHUwMTc3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyJlxcdTAxOEZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDIoXFx1MDE5MVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMipcXHUwMUEyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyLFxcdTAxQjJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDIuXFx1MDFCQVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMjBcXHUwMUNCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyMlxcdTAxQ0RcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDI0XFx1MDFEQVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMjZcXHUwMUREXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyOFxcdTAxRTVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDI6XFx1MDFFN1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMjxcXHUwMUY2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyPlxcdTAyMDNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJAXFx1MDIwQVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMkJcXHUwMjE3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyRFxcdTAyMUVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJGXFx1MDIyQlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMkhcXHUwMjJGXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAySlxcdTAyM0NcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJMXFx1MDI0OVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMk5cXHUwMjUzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyUFxcdTAyNTVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJSXFx1MDI1Q1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlRcXHUwMjZBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyVlxcdTAyNkNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJYXFx1MDI2RVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlpcXHUwMjg2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFxcXFxcdTAyODhcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJeXFx1MDI4Qlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMmBcXHUwMjk0XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyYlxcdTAyOUZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJkXFx1MDJBOFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMmZcXHUwMkIwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyaFxcdTAyQjJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJqXFx1MDJCNVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMmxcXHUwMkM1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyblxcdTAyRDFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJwXFx1MDJEM1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMnJcXHUwMkRCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAydFxcdTAyREVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJ2XFx1MDJFMVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMnhcXHUwMkU3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyelxcdTAyRUFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJ8XFx1MDJFRVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMn5cXHUwMkY5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4ODBcXHUwMzAyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4ODJcXHUwMzBEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4ODRcXHUwMzFDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4ODZcXHUwMzMwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4ODhcXHUwMzg4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4OEFcXHUwMzhBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4OENcXHUwMzkyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4OEVcXHUwMzlEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4OTBcXHUwM0E5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4OTJcXHUwM0FCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4OTRcXHUwM0IwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4OTZcXHUwM0NCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4OThcXHUwM0QwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4OUFcXHUwM0QyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4OUNcXHUwM0RBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4OUVcXHUwM0VBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4QTBcXHUwM0YwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4QTJcXHUwM0ZCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4QTRcXHUwM0ZEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4QTZcXHUwNDA1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4QThcXHUwNDA5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4QUFcXHUwNDBDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4QUNcXHUwNDFBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4QUVcXHUwNDFDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4QjBcXHUwNDI4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4QjJcXHUwNDJCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4QjRcXHUwNDM3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4QjZcXHUwNDQwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4QjhcXHUwNDQyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4QkFcXHUwNDYwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4QkNcXHUwNDYyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4QkVcXHUwNDY2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4QzBcXHUwNDY5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4QzJcXHUwNDZEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4QzRcXHUwNDdDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4QzZcXHhEMVx1MDAwNVx1MDAwNFx1MDAwM1x1MDAwMlxceEM3XFx4RDFcdTAwMDVcdTAwMTJcXG5cdTAwMDJcXHhDOFxceEQxXHUwMDA1XHUwMDE2XFxmXHUwMDAyXFx4QzlcXHhEMVx1MDAwNTpcdTAwMWVcdTAwMDJcXHhDQVxceEQxXHUwMDA1KFx1MDAxNVx1MDAwMlxceENCXFx4RDFcdTAwMDUuXHUwMDE4XHUwMDAyXFx4Q0NcXHhEMVx1MDAwNVx1MDAxZVx1MDAxMFx1MDAwMlxceENEXFx4RDFcdTAwMDUgXHUwMDExXHUwMDAyXFx4Q0VcXHhEMVx1MDAwNVxcXCJcdTAwMTJcdTAwMDJcXHhDRlxceEQxXHUwMDA1JFx1MDAxM1x1MDAwMlxceEQwXFx4QzZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhEMFxceEM3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4RDBcXHhDOFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxceEQwXFx4QzlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhEMFxceENBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4RDBcXHhDQlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxceEQwXFx4Q0NcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhEMFxceENEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4RDBcXHhDRVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxceEQwXFx4Q0ZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhEMVxceEQ0XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4RDJcXHhEMFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxceEQyXFx4RDNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhEM1xceEQ1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4RDRcXHhEMlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxceEQ1XFx4RDZcXHgwN1x1MDAwMlx1MDAwMlx1MDAwM1xceEQ2XHUwMDAzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4RDdcXHhEOFxceDA3XHUwMDAzXHUwMDAyXHUwMDAyXFx4RDhcXHhEOVx1MDAwNVx1MDAwNlx1MDAwNFx1MDAwMlxceEQ5XFx4REFcdTAwMDVcXGJcdTAwMDVcdTAwMDJcXHhEQVxceERCXFx4MDdcdTAwMDRcdTAwMDJcdTAwMDJcXHhEQlx1MDAwNVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxceERDXFx4RERcdTAwMDVcXHhCRWBcdTAwMDJcXHhERFxceDA3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4REVcXHhFMlxceDA3XHUwMDA1XHUwMDAyXHUwMDAyXFx4REZcXHhFMlx1MDAwNVxcblx1MDAwNlx1MDAwMlxceEUwXFx4RTJcdTAwMDVcXHg4NkRcdTAwMDJcXHhFMVxceERFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4RTFcXHhERlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxceEUxXFx4RTBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhFMlx0XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4RTNcXHhFQVx1MDAwNVx1MDAwZVxcYlx1MDAwMlxceEU0XFx4RTZcXHgwN1x1MDAwNlx1MDAwMlx1MDAwMlxceEU1XFx4RTRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhFNVxceEU2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4RTZcXHhFN1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxceEU3XFx4RTlcdTAwMDVcdTAwMGVcXGJcdTAwMDJcXHhFOFxceEU1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4RTlcXHhFQ1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxceEVBXFx4RThcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhFQVxceEVCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4RUJcXHZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhFQ1xceEVBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4RURcXHhFRVx0XHUwMDAyXHUwMDAyXHUwMDAyXFx4RUVcXHJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhFRlxceEYxXHUwMDA1XFxmXFx4MDdcdTAwMDJcXHhGMFxceEVGXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4RjBcXHhGMVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxceEYxXFx4RjJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhGMlxceEY4XFx4MDdcXHg4NVx1MDAwMlx1MDAwMlxceEYzXFx4RjVcdTAwMDVcXGZcXHgwN1x1MDAwMlxceEY0XFx4RjNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHhGNFxceEY1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4RjVcXHhGNlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxceEY2XFx4RjhcXHgwN2pcdTAwMDJcdTAwMDJcXHhGN1xceEYwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4RjdcXHhGNFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxceEY4XHUwMDBmXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4RjlcXHhGQ1x1MDAwNVxceEJFYFx1MDAwMlxceEZBXFx4RkJcXHgwN1x1MDAwZVx1MDAwMlx1MDAwMlxceEZCXFx4RkRcdTAwMDVcXHhCRWBcdTAwMDJcXHhGQ1xceEZBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4RkNcXHhGRFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxceEZEXHUwMDExXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx4RkVcXHhGRlxceDA3XHUwMDBmXHUwMDAyXHUwMDAyXFx4RkZcXHUwMTAyXHUwMDA1XHUwMDE0XFx2XHUwMDAyXFx1MDEwMFxcdTAxMDFcXHgwN1x1MDAwZVx1MDAwMlx1MDAwMlxcdTAxMDFcXHUwMTAzXHUwMDA1XFx4QkVgXHUwMDAyXFx1MDEwMlxcdTAxMDBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTAyXFx1MDEwM1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMDNcXHUwMTA0XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDEwNFxcdTAxMDVcXHgwN1x1MDAwNFx1MDAwMlx1MDAwMlxcdTAxMDVcXHUwMTIzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDEwNlxcdTAxMDlcXHgwN1x1MDAwZlx1MDAwMlx1MDAwMlxcdTAxMDdcXHUwMTBBXFx4MDdcdTAwMDVcdTAwMDJcdTAwMDJcXHUwMTA4XFx1MDEwQVx1MDAwNVxceEJFYFx1MDAwMlxcdTAxMDlcXHUwMTA3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDEwOVxcdTAxMDhcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTBBXFx1MDEwRFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMEJcXHUwMTBDXFx4MDdcdTAwMGVcdTAwMDJcdTAwMDJcXHUwMTBDXFx1MDEwRVx1MDAwNVxceEJFYFx1MDAwMlxcdTAxMERcXHUwMTBCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDEwRFxcdTAxMEVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTBFXFx1MDEwRlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMEZcXHUwMTEwXFx4MDdcdTAwMTBcdTAwMDJcdTAwMDJcXHUwMTEwXFx1MDExMVx1MDAwNVx1MDAxNFxcdlx1MDAwMlxcdTAxMTFcXHUwMTEyXFx4MDdcdTAwMDRcdTAwMDJcdTAwMDJcXHUwMTEyXFx1MDEyM1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMTNcXHUwMTE0XFx4MDdcdTAwMGZcdTAwMDJcdTAwMDJcXHUwMTE0XFx1MDExNVxceDA3XHUwMDExXHUwMDAyXHUwMDAyXFx1MDExNVxcdTAxMUFcdTAwMDVcdTAwMTBcdFx1MDAwMlxcdTAxMTZcXHUwMTE3XFx4MDdcdTAwMTJcdTAwMDJcdTAwMDJcXHUwMTE3XFx1MDExOVx1MDAwNVx1MDAxMFx0XHUwMDAyXFx1MDExOFxcdTAxMTZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTE5XFx1MDExQ1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMUFcXHUwMTE4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDExQVxcdTAxMUJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTFCXFx1MDExRFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMUNcXHUwMTFBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDExRFxcdTAxMUVcXHgwN1x1MDAxM1x1MDAwMlx1MDAwMlxcdTAxMUVcXHUwMTFGXFx4MDdcdTAwMTBcdTAwMDJcdTAwMDJcXHUwMTFGXFx1MDEyMFx1MDAwNVx1MDAxNFxcdlx1MDAwMlxcdTAxMjBcXHUwMTIxXFx4MDdcdTAwMDRcdTAwMDJcdTAwMDJcXHUwMTIxXFx1MDEyM1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMjJcXHhGRVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMjJcXHUwMTA2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDEyMlxcdTAxMTNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTIzXHUwMDEzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDEyNFxcdTAxMjVcXHgwN1xceDg0XHUwMDAyXHUwMDAyXFx1MDEyNVx1MDAxNVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMjZcXHUwMTI4XFx4MDdcdTAwMTRcdTAwMDJcdTAwMDJcXHUwMTI3XFx1MDEyNlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMjdcXHUwMTI4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDEyOFxcdTAxMjlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTI5XFx1MDEyQVx0XHUwMDAzXHUwMDAyXHUwMDAyXFx1MDEyQVxcdTAxMzRcdTAwMDVcXHhCRWBcdTAwMDJcXHUwMTJCXFx1MDEyQ1xceDA3XHUwMDE4XHUwMDAyXHUwMDAyXFx1MDEyQ1xcdTAxMzFcdTAwMDVcdTAwMThcXHJcdTAwMDJcXHUwMTJEXFx1MDEyRVxceDA3XHUwMDEyXHUwMDAyXHUwMDAyXFx1MDEyRVxcdTAxMzBcdTAwMDVcdTAwMThcXHJcdTAwMDJcXHUwMTJGXFx1MDEyRFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMzBcXHUwMTMzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDEzMVxcdTAxMkZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTMxXFx1MDEzMlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMzJcXHUwMTM1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDEzM1xcdTAxMzFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTM0XFx1MDEyQlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMzRcXHUwMTM1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDEzNVxcdTAxMzZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTM2XFx1MDEzQVxceDA3XHUwMDExXHUwMDAyXHUwMDAyXFx1MDEzN1xcdTAxMzlcdTAwMDVcdTAwMWFcdTAwMGVcdTAwMDJcXHUwMTM4XFx1MDEzN1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxMzlcXHUwMTNDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDEzQVxcdTAxMzhcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTNBXFx1MDEzQlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxM0JcXHUwMTNEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDEzQ1xcdTAxM0FcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTNEXFx1MDEzRVxceDA3XHUwMDEzXHUwMDAyXHUwMDAyXFx1MDEzRVx1MDAxN1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxM0ZcXHUwMTQ1XHUwMDA1TCdcdTAwMDJcXHUwMTQwXFx1MDE0MlxceDA3XHUwMDE5XHUwMDAyXHUwMDAyXFx1MDE0MVxcdTAxNDNcdTAwMDVcXHg4QUZcdTAwMDJcXHUwMTQyXFx1MDE0MVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxNDJcXHUwMTQzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDE0M1xcdTAxNDRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTQ0XFx1MDE0NlxceDA3XHUwMDFhXHUwMDAyXHUwMDAyXFx1MDE0NVxcdTAxNDBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTQ1XFx1MDE0Nlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxNDZcdTAwMTlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTQ3XFx1MDE1MVx1MDAwNVx1MDAxY1x1MDAwZlx1MDAwMlxcdTAxNDhcXHUwMTUxXHUwMDA1JFx1MDAxM1x1MDAwMlxcdTAxNDlcXHUwMTUxXHUwMDA1KFx1MDAxNVx1MDAwMlxcdTAxNEFcXHUwMTUxXHUwMDA1Klx1MDAxNlx1MDAwMlxcdTAxNEJcXHUwMTUxXHUwMDA1Llx1MDAxOFx1MDAwMlxcdTAxNENcXHUwMTUxXHUwMDA1Nlx1MDAxY1x1MDAwMlxcdTAxNERcXHUwMTUxXHUwMDA1Olx1MDAxZVx1MDAwMlxcdTAxNEVcXHUwMTUxXHUwMDA1IFx1MDAxMVx1MDAwMlxcdTAxNEZcXHUwMTUxXHUwMDA1XFxcIlx1MDAxMlx1MDAwMlxcdTAxNTBcXHUwMTQ3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDE1MFxcdTAxNDhcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTUwXFx1MDE0OVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxNTBcXHUwMTRBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDE1MFxcdTAxNEJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTUwXFx1MDE0Q1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxNTBcXHUwMTREXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDE1MFxcdTAxNEVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTUwXFx1MDE0Rlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxNTFcdTAwMWJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTUyXFx1MDE1Qlx1MDAwNUomXHUwMDAyXFx1MDE1M1xcdTAxNUFcXHgwN3pcdTAwMDJcdTAwMDJcXHUwMTU0XFx1MDE1QVxceDA3d1x1MDAwMlx1MDAwMlxcdTAxNTVcXHUwMTVBXFx4MDd5XHUwMDAyXHUwMDAyXFx1MDE1NlxcdTAxNUFcXHgwN3FcdTAwMDJcdTAwMDJcXHUwMTU3XFx1MDE1QVxceDA3clx1MDAwMlx1MDAwMlxcdTAxNThcXHUwMTVBXHUwMDA1XFx4QzJiXHUwMDAyXFx1MDE1OVxcdTAxNTNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTU5XFx1MDE1NFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxNTlcXHUwMTU1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDE1OVxcdTAxNTZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTU5XFx1MDE1N1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxNTlcXHUwMTU4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDE1QVxcdTAxNURcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTVCXFx1MDE1OVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxNUJcXHUwMTVDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDE1Q1xcdTAxNUVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTVEXFx1MDE1Qlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxNUVcXHUwMTYxXHUwMDA1XFx4QkVgXHUwMDAyXFx1MDE1RlxcdTAxNjBcXHgwN1xcclx1MDAwMlx1MDAwMlxcdTAxNjBcXHUwMTYyXHUwMDA1XFx4ODZEXHUwMDAyXFx1MDE2MVxcdTAxNUZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTYxXFx1MDE2Mlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxNjJcXHUwMTYzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDE2M1xcdTAxNjRcXHgwN1x1MDAwNFx1MDAwMlx1MDAwMlxcdTAxNjRcdTAwMWRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTY1XFx1MDE2Nlx1MDAwNUomXHUwMDAyXFx1MDE2NlxcdTAxNjdcXHgwN3FcdTAwMDJcdTAwMDJcXHUwMTY3XFx1MDE2OFx1MDAwNVxceEJFYFx1MDAwMlxcdTAxNjhcXHUwMTY5XFx4MDdcXHJcdTAwMDJcdTAwMDJcXHUwMTY5XFx1MDE2QVx1MDAwNVxceDg2RFx1MDAwMlxcdTAxNkFcXHUwMTZCXFx4MDdcdTAwMDRcdTAwMDJcdTAwMDJcXHUwMTZCXHUwMDFmXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDE2Q1xcdTAxNkRcXHgwN1x1MDAxYlx1MDAwMlx1MDAwMlxcdTAxNkRcXHUwMTZFXHUwMDA1XFx4QkVgXHUwMDAyXFx1MDE2RVxcdTAxNkZcdTAwMDU8XHUwMDFmXHUwMDAyXFx1MDE2RlxcdTAxNzBcXHgwN1x1MDAwNFx1MDAwMlx1MDAwMlxcdTAxNzAhXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDE3MVxcdTAxNzJcXHgwN31cdTAwMDJcdTAwMDJcXHUwMTcyXFx1MDE3M1x1MDAwNVxceEJFYFx1MDAwMlxcdTAxNzNcXHUwMTc0XFx4MDdcdTAwMThcdTAwMDJcdTAwMDJcXHUwMTc0XFx1MDE3NVx1MDAwNVxceDg0Q1x1MDAwMlxcdTAxNzVcXHUwMTc2XFx4MDdcdTAwMDRcdTAwMDJcdTAwMDJcXHUwMTc2I1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxNzdcXHUwMTc4XFx4MDdcdTAwMWNcdTAwMDJcdTAwMDJcXHUwMTc4XFx1MDE3OVx1MDAwNSZcdTAwMTRcdTAwMDJcXHUwMTc5XFx1MDE3Q1xceDA3XHUwMDFkXHUwMDAyXHUwMDAyXFx1MDE3QVxcdTAxN0RcXHgwN1x1MDAwNVx1MDAwMlx1MDAwMlxcdTAxN0JcXHUwMTdEXHUwMDA1SiZcdTAwMDJcXHUwMTdDXFx1MDE3QVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxN0NcXHUwMTdCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDE3RFxcdTAxN0ZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTdFXFx1MDE4MFxceDA3XFx4N0ZcdTAwMDJcdTAwMDJcXHUwMTdGXFx1MDE3RVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxN0ZcXHUwMTgwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDE4MFxcdTAxODFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTgxXFx1MDE4MlxceDA3XHUwMDA0XHUwMDAyXHUwMDAyXFx1MDE4MiVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTgzXFx1MDE5MFx1MDAwNUwnXHUwMDAyXFx1MDE4NFxcdTAxODVcXHgwN1x1MDAxMVx1MDAwMlx1MDAwMlxcdTAxODVcXHUwMThBXHUwMDA1TCdcdTAwMDJcXHUwMTg2XFx1MDE4N1xceDA3XHUwMDEyXHUwMDAyXHUwMDAyXFx1MDE4N1xcdTAxODlcdTAwMDVMJ1x1MDAwMlxcdTAxODhcXHUwMTg2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDE4OVxcdTAxOENcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMThBXFx1MDE4OFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxOEFcXHUwMThCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDE4QlxcdTAxOERcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMThDXFx1MDE4QVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxOERcXHUwMThFXFx4MDdcdTAwMTNcdTAwMDJcdTAwMDJcXHUwMThFXFx1MDE5MFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxOEZcXHUwMTgzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDE4RlxcdTAxODRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTkwJ1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxOTFcXHUwMTkyXFx4MDdcdTAwMWVcdTAwMDJcdTAwMDJcXHUwMTkyXFx1MDE5M1x1MDAwNVxceEJFYFx1MDAwMlxcdTAxOTNcXHUwMTlFXFx4MDdcdTAwMTFcdTAwMDJcdTAwMDJcXHUwMTk0XFx1MDE5NVx1MDAwNUglXHUwMDAyXFx1MDE5NVxcdTAxOUJcXHgwN1x1MDAwNFx1MDAwMlx1MDAwMlxcdTAxOTZcXHUwMTk3XHUwMDA1SCVcdTAwMDJcXHUwMTk3XFx1MDE5OFxceDA3XHUwMDA0XHUwMDAyXHUwMDAyXFx1MDE5OFxcdTAxOUFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTk5XFx1MDE5Nlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxOUFcXHUwMTlEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDE5QlxcdTAxOTlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTlCXFx1MDE5Q1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxOUNcXHUwMTlGXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDE5RFxcdTAxOUJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMTlFXFx1MDE5NFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxOUVcXHUwMTlGXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDE5RlxcdTAxQTBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUEwXFx1MDFBMVxceDA3XHUwMDEzXHUwMDAyXHUwMDAyXFx1MDFBMSlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUEyXFx1MDFBM1xceDA3XHUwMDFmXHUwMDAyXHUwMDAyXFx1MDFBM1xcdTAxQTVcdTAwMDVcXHhCRWBcdTAwMDJcXHUwMUE0XFx1MDFBNlx1MDAwNTxcdTAwMWZcdTAwMDJcXHUwMUE1XFx1MDFBNFwiO1xuU29saWRpdHlQYXJzZXIuX3NlcmlhbGl6ZWRBVE5TZWdtZW50MSA9IFwiXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFBNVxcdTAxQTZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUE2XFx1MDFBQlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxQTdcXHUwMUFBXFx4MDd7XHUwMDAyXHUwMDAyXFx1MDFBOFxcdTAxQUFcdTAwMDVcXHhDMmJcdTAwMDJcXHUwMUE5XFx1MDFBN1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxQTlcXHUwMUE4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFBQVxcdTAxQURcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUFCXFx1MDFBOVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxQUJcXHUwMUFDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFBQ1xcdTAxQjBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUFEXFx1MDFBQlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxQUVcXHUwMUIxXFx4MDdcdTAwMDRcdTAwMDJcdTAwMDJcXHUwMUFGXFx1MDFCMVx1MDAwNVgtXHUwMDAyXFx1MDFCMFxcdTAxQUVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUIwXFx1MDFBRlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxQjErXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFCMlxcdTAxQjhcdTAwMDVcXHhCRWBcdTAwMDJcXHUwMUIzXFx1MDFCNVxceDA3XHUwMDE5XHUwMDAyXHUwMDAyXFx1MDFCNFxcdTAxQjZcdTAwMDVcXHg4QUZcdTAwMDJcXHUwMUI1XFx1MDFCNFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxQjVcXHUwMUI2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFCNlxcdTAxQjdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUI3XFx1MDFCOVxceDA3XHUwMDFhXHUwMDAyXHUwMDAyXFx1MDFCOFxcdTAxQjNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUI4XFx1MDFCOVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxQjktXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFCQVxcdTAxQkJcdTAwMDUwXHUwMDE5XHUwMDAyXFx1MDFCQlxcdTAxQkNcdTAwMDU8XHUwMDFmXHUwMDAyXFx1MDFCQ1xcdTAxQkVcdTAwMDU0XHUwMDFiXHUwMDAyXFx1MDFCRFxcdTAxQkZcdTAwMDUyXHUwMDFhXHUwMDAyXFx1MDFCRVxcdTAxQkRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUJFXFx1MDFCRlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxQkZcXHUwMUMyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFDMFxcdTAxQzNcXHgwN1x1MDAwNFx1MDAwMlx1MDAwMlxcdTAxQzFcXHUwMUMzXHUwMDA1WC1cdTAwMDJcXHUwMUMyXFx1MDFDMFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxQzJcXHUwMUMxXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFDMy9cdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUM0XFx1MDFDNlxceDA3IFx1MDAwMlx1MDAwMlxcdTAxQzVcXHUwMUM3XHUwMDA1XFx4QkVgXHUwMDAyXFx1MDFDNlxcdTAxQzVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUM2XFx1MDFDN1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxQzdcXHUwMUNDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFDOFxcdTAxQ0NcXHgwN1xceDgwXHUwMDAyXHUwMDAyXFx1MDFDOVxcdTAxQ0NcXHgwN1xceDgxXHUwMDAyXHUwMDAyXFx1MDFDQVxcdTAxQ0NcXHgwN1xceDgyXHUwMDAyXHUwMDAyXFx1MDFDQlxcdTAxQzRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUNCXFx1MDFDOFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxQ0JcXHUwMUM5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFDQlxcdTAxQ0FcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUNDMVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxQ0RcXHUwMUNFXFx4MDchXHUwMDAyXHUwMDAyXFx1MDFDRVxcdTAxQ0ZcdTAwMDU8XHUwMDFmXHUwMDAyXFx1MDFDRjNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUQwXFx1MDFEOVxceDA3dVx1MDAwMlx1MDAwMlxcdTAxRDFcXHUwMUQ5XFx4MDd6XHUwMDAyXHUwMDAyXFx1MDFEMlxcdTAxRDlcXHgwN3dcdTAwMDJcdTAwMDJcXHUwMUQzXFx1MDFEOVxceDA3eVx1MDAwMlx1MDAwMlxcdTAxRDRcXHUwMUQ5XFx4MDd7XHUwMDAyXHUwMDAyXFx1MDFENVxcdTAxRDlcdTAwMDVWLFx1MDAwMlxcdTAxRDZcXHUwMUQ5XHUwMDA1LFx1MDAxN1x1MDAwMlxcdTAxRDdcXHUwMUQ5XHUwMDA1XFx4QzJiXHUwMDAyXFx1MDFEOFxcdTAxRDBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUQ4XFx1MDFEMVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxRDhcXHUwMUQyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFEOFxcdTAxRDNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUQ4XFx1MDFENFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxRDhcXHUwMUQ1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFEOFxcdTAxRDZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUQ4XFx1MDFEN1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxRDlcXHUwMURDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFEQVxcdTAxRDhcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMURBXFx1MDFEQlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxREI1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFEQ1xcdTAxREFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUREXFx1MDFERVxceDA3XFxcIlx1MDAwMlx1MDAwMlxcdTAxREVcXHUwMURGXHUwMDA1XFx4QkVgXHUwMDAyXFx1MDFERlxcdTAxRTFcdTAwMDVAIVx1MDAwMlxcdTAxRTBcXHUwMUUyXFx4MDdvXHUwMDAyXHUwMDAyXFx1MDFFMVxcdTAxRTBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUUxXFx1MDFFMlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxRTJcXHUwMUUzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFFM1xcdTAxRTRcXHgwN1x1MDAwNFx1MDAwMlx1MDAwMlxcdTAxRTQ3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFFNVxcdTAxRTZcdTAwMDVcXHhCRWBcdTAwMDJcXHUwMUU2OVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxRTdcXHUwMUU4XFx4MDcjXHUwMDAyXHUwMDAyXFx1MDFFOFxcdTAxRTlcdTAwMDVcXHhCRWBcdTAwMDJcXHUwMUU5XFx1MDFFQlxceDA3XHUwMDExXHUwMDAyXHUwMDAyXFx1MDFFQVxcdTAxRUNcdTAwMDU4XHUwMDFkXHUwMDAyXFx1MDFFQlxcdTAxRUFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUVCXFx1MDFFQ1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxRUNcXHUwMUYxXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFFRFxcdTAxRUVcXHgwN1x1MDAxMlx1MDAwMlx1MDAwMlxcdTAxRUVcXHUwMUYwXHUwMDA1OFx1MDAxZFx1MDAwMlxcdTAxRUZcXHUwMUVEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFGMFxcdTAxRjNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUYxXFx1MDFFRlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxRjFcXHUwMUYyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFGMlxcdTAxRjRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUYzXFx1MDFGMVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxRjRcXHUwMUY1XFx4MDdcdTAwMTNcdTAwMDJcdTAwMDJcXHUwMUY1O1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxRjZcXHUwMUZGXFx4MDdcdTAwMTlcdTAwMDJcdTAwMDJcXHUwMUY3XFx1MDFGQ1x1MDAwNT4gXHUwMDAyXFx1MDFGOFxcdTAxRjlcXHgwN1x1MDAxMlx1MDAwMlx1MDAwMlxcdTAxRjlcXHUwMUZCXHUwMDA1PiBcdTAwMDJcXHUwMUZBXFx1MDFGOFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxRkJcXHUwMUZFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFGQ1xcdTAxRkFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUZDXFx1MDFGRFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxRkRcXHUwMjAwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDFGRVxcdTAxRkNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMUZGXFx1MDFGN1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAxRkZcXHUwMjAwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDIwMFxcdTAyMDFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjAxXFx1MDIwMlxceDA3XHUwMDFhXHUwMDAyXHUwMDAyXFx1MDIwMj1cdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjAzXFx1MDIwNVx1MDAwNUomXHUwMDAyXFx1MDIwNFxcdTAyMDZcdTAwMDVUK1x1MDAwMlxcdTAyMDVcXHUwMjA0XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDIwNVxcdTAyMDZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjA2XFx1MDIwOFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyMDdcXHUwMjA5XHUwMDA1XFx4QkVgXHUwMDAyXFx1MDIwOFxcdTAyMDdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjA4XFx1MDIwOVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyMDk/XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDIwQVxcdTAyMTNcXHgwN1x1MDAxOVx1MDAwMlx1MDAwMlxcdTAyMEJcXHUwMjEwXHUwMDA1QlxcXCJcdTAwMDJcXHUwMjBDXFx1MDIwRFxceDA3XHUwMDEyXHUwMDAyXHUwMDAyXFx1MDIwRFxcdTAyMEZcdTAwMDVCXFxcIlx1MDAwMlxcdTAyMEVcXHUwMjBDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDIwRlxcdTAyMTJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjEwXFx1MDIwRVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyMTBcXHUwMjExXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDIxMVxcdTAyMTRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjEyXFx1MDIxMFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyMTNcXHUwMjBCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDIxM1xcdTAyMTRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjE0XFx1MDIxNVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyMTVcXHUwMjE2XFx4MDdcdTAwMWFcdTAwMDJcdTAwMDJcXHUwMjE2QVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyMTdcXHUwMjE5XHUwMDA1SiZcdTAwMDJcXHUwMjE4XFx1MDIxQVxceDA3dlx1MDAwMlx1MDAwMlxcdTAyMTlcXHUwMjE4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDIxOVxcdTAyMUFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjFBXFx1MDIxQ1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyMUJcXHUwMjFEXHUwMDA1XFx4QkVgXHUwMDAyXFx1MDIxQ1xcdTAyMUJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjFDXFx1MDIxRFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyMURDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDIxRVxcdTAyMjdcXHgwN1x1MDAxOVx1MDAwMlx1MDAwMlxcdTAyMUZcXHUwMjI0XHUwMDA1RiRcdTAwMDJcXHUwMjIwXFx1MDIyMVxceDA3XHUwMDEyXHUwMDAyXHUwMDAyXFx1MDIyMVxcdTAyMjNcdTAwMDVGJFx1MDAwMlxcdTAyMjJcXHUwMjIwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDIyM1xcdTAyMjZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjI0XFx1MDIyMlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyMjRcXHUwMjI1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDIyNVxcdTAyMjhcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjI2XFx1MDIyNFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyMjdcXHUwMjFGXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDIyN1xcdTAyMjhcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjI4XFx1MDIyOVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyMjlcXHUwMjJBXFx4MDdcdTAwMWFcdTAwMDJcdTAwMDJcXHUwMjJBRVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyMkJcXHUwMjJEXHUwMDA1SiZcdTAwMDJcXHUwMjJDXFx1MDIyRVx1MDAwNVQrXHUwMDAyXFx1MDIyRFxcdTAyMkNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjJEXFx1MDIyRVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyMkVHXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDIyRlxcdTAyMzFcdTAwMDVKJlx1MDAwMlxcdTAyMzBcXHUwMjMyXHUwMDA1VCtcdTAwMDJcXHUwMjMxXFx1MDIzMFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyMzFcXHUwMjMyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDIzMlxcdTAyMzNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjMzXFx1MDIzNFx1MDAwNVxceEJFYFx1MDAwMlxcdTAyMzRJXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDIzNVxcdTAyMzZcXGImXHUwMDAxXHUwMDAyXFx1MDIzNlxcdTAyM0RcdTAwMDVcXHg4NENcdTAwMDJcXHUwMjM3XFx1MDIzRFx1MDAwNUwnXHUwMDAyXFx1MDIzOFxcdTAyM0RcdTAwMDVQKVx1MDAwMlxcdTAyMzlcXHUwMjNEXHUwMDA1UipcdTAwMDJcXHUwMjNBXFx1MDIzQlxceDA3Jlx1MDAwMlx1MDAwMlxcdTAyM0JcXHUwMjNEXFx4MDd4XHUwMDAyXHUwMDAyXFx1MDIzQ1xcdTAyMzVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjNDXFx1MDIzN1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyM0NcXHUwMjM4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDIzQ1xcdTAyMzlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjNDXFx1MDIzQVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyM0RcXHUwMjQ2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDIzRVxcdTAyM0ZcXGZcdTAwMDVcdTAwMDJcdTAwMDJcXHUwMjNGXFx1MDI0MVxceDA3JFx1MDAwMlx1MDAwMlxcdTAyNDBcXHUwMjQyXHUwMDA1XFx4ODZEXHUwMDAyXFx1MDI0MVxcdTAyNDBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjQxXFx1MDI0Mlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyNDJcXHUwMjQzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI0M1xcdTAyNDVcXHgwNyVcdTAwMDJcdTAwMDJcXHUwMjQ0XFx1MDIzRVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyNDVcXHUwMjQ4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI0NlxcdTAyNDRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjQ2XFx1MDI0N1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyNDdLXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI0OFxcdTAyNDZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjQ5XFx1MDI0RVx1MDAwNVxceEJFYFx1MDAwMlxcdTAyNEFcXHUwMjRCXFx4MDcnXHUwMDAyXHUwMDAyXFx1MDI0QlxcdTAyNERcdTAwMDVcXHhCRWBcdTAwMDJcXHUwMjRDXFx1MDI0QVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyNERcXHUwMjUwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI0RVxcdTAyNENcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjRFXFx1MDI0Rlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyNEZNXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI1MFxcdTAyNEVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjUxXFx1MDI1NFx1MDAwNVxceDg0Q1x1MDAwMlxcdTAyNTJcXHUwMjU0XHUwMDA1TCdcdTAwMDJcXHUwMjUzXFx1MDI1MVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyNTNcXHUwMjUyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI1NE9cdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjU1XFx1MDI1NlxceDA3KFx1MDAwMlx1MDAwMlxcdTAyNTZcXHUwMjU3XFx4MDdcdTAwMTlcdTAwMDJcdTAwMDJcXHUwMjU3XFx1MDI1OFx1MDAwNU4oXHUwMDAyXFx1MDI1OFxcdTAyNTlcXHgwNylcdTAwMDJcdTAwMDJcXHUwMjU5XFx1MDI1QVx1MDAwNUomXHUwMDAyXFx1MDI1QVxcdTAyNUJcXHgwN1x1MDAxYVx1MDAwMlx1MDAwMlxcdTAyNUJRXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI1Q1xcdTAyNURcXHgwNyBcdTAwMDJcdTAwMDJcXHUwMjVEXFx1MDI2M1x1MDAwNUQjXHUwMDAyXFx1MDI1RVxcdTAyNjJcXHgwN3dcdTAwMDJcdTAwMDJcXHUwMjVGXFx1MDI2MlxceDA3dVx1MDAwMlx1MDAwMlxcdTAyNjBcXHUwMjYyXHUwMDA1VixcdTAwMDJcXHUwMjYxXFx1MDI1RVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyNjFcXHUwMjVGXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI2MVxcdTAyNjBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjYyXFx1MDI2NVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyNjNcXHUwMjYxXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI2M1xcdTAyNjRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjY0XFx1MDI2OFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyNjVcXHUwMjYzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI2NlxcdTAyNjdcXHgwNyFcdTAwMDJcdTAwMDJcXHUwMjY3XFx1MDI2OVx1MDAwNUQjXHUwMDAyXFx1MDI2OFxcdTAyNjZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjY4XFx1MDI2OVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyNjlTXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI2QVxcdTAyNkJcdFx1MDAwNFx1MDAwMlx1MDAwMlxcdTAyNkJVXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI2Q1xcdTAyNkRcdFx1MDAwNVx1MDAwMlx1MDAwMlxcdTAyNkRXXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI2RVxcdTAyNzJcXHgwN1x1MDAxMVx1MDAwMlx1MDAwMlxcdTAyNkZcXHUwMjcxXHUwMDA1Wi5cdTAwMDJcXHUwMjcwXFx1MDI2Rlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyNzFcXHUwMjc0XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI3MlxcdTAyNzBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjcyXFx1MDI3M1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyNzNcXHUwMjc1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI3NFxcdTAyNzJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjc1XFx1MDI3NlxceDA3XHUwMDEzXHUwMDAyXHUwMDAyXFx1MDI3NllcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjc3XFx1MDI4N1x1MDAwNV4wXHUwMDAyXFx1MDI3OFxcdTAyODdcdTAwMDVgMVx1MDAwMlxcdTAyNzlcXHUwMjg3XHUwMDA1ZDNcdTAwMDJcXHUwMjdBXFx1MDI4N1x1MDAwNWo2XHUwMDAyXFx1MDI3QlxcdTAyODdcdTAwMDVYLVx1MDAwMlxcdTAyN0NcXHUwMjg3XHUwMDA1bDdcdTAwMDJcXHUwMjdEXFx1MDI4N1x1MDAwNXA5XHUwMDAyXFx1MDI3RVxcdTAyODdcdTAwMDVyOlx1MDAwMlxcdTAyN0ZcXHUwMjg3XHUwMDA1dDtcdTAwMDJcXHUwMjgwXFx1MDI4N1x1MDAwNXY8XHUwMDAyXFx1MDI4MVxcdTAyODdcdTAwMDV4PVx1MDAwMlxcdTAyODJcXHUwMjg3XHUwMDA1ej5cdTAwMDJcXHUwMjgzXFx1MDI4N1x1MDAwNWY0XHUwMDAyXFx1MDI4NFxcdTAyODdcdTAwMDVoNVx1MDAwMlxcdTAyODVcXHUwMjg3XHUwMDA1fD9cdTAwMDJcXHUwMjg2XFx1MDI3N1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyODZcXHUwMjc4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI4NlxcdTAyNzlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjg2XFx1MDI3QVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyODZcXHUwMjdCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI4NlxcdTAyN0NcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjg2XFx1MDI3RFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyODZcXHUwMjdFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI4NlxcdTAyN0ZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjg2XFx1MDI4MFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyODZcXHUwMjgxXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI4NlxcdTAyODJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjg2XFx1MDI4M1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyODZcXHUwMjg0XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI4NlxcdTAyODVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjg3W1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyODhcXHUwMjg5XHUwMDA1XFx4ODZEXHUwMDAyXFx1MDI4OVxcdTAyOEFcXHgwN1x1MDAwNFx1MDAwMlx1MDAwMlxcdTAyOEFdXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI4QlxcdTAyOENcXHgwNy1cdTAwMDJcdTAwMDJcXHUwMjhDXFx1MDI4RFxceDA3XHUwMDE5XHUwMDAyXHUwMDAyXFx1MDI4RFxcdTAyOEVcdTAwMDVcXHg4NkRcdTAwMDJcXHUwMjhFXFx1MDI4RlxceDA3XHUwMDFhXHUwMDAyXHUwMDAyXFx1MDI4RlxcdTAyOTJcdTAwMDVaLlx1MDAwMlxcdTAyOTBcXHUwMjkxXFx4MDcuXHUwMDAyXHUwMDAyXFx1MDI5MVxcdTAyOTNcdTAwMDVaLlx1MDAwMlxcdTAyOTJcXHUwMjkwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI5MlxcdTAyOTNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjkzX1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyOTRcXHUwMjk1XFx4MDcvXHUwMDAyXHUwMDAyXFx1MDI5NVxcdTAyOTdcdTAwMDVcXHg4NkRcdTAwMDJcXHUwMjk2XFx1MDI5OFx1MDAwNTJcdTAwMWFcdTAwMDJcXHUwMjk3XFx1MDI5Nlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyOTdcXHUwMjk4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI5OFxcdTAyOTlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjk5XFx1MDI5Qlx1MDAwNVgtXHUwMDAyXFx1MDI5QVxcdTAyOUNcdTAwMDViMlx1MDAwMlxcdTAyOUJcXHUwMjlBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI5Q1xcdTAyOURcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjlEXFx1MDI5Qlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyOURcXHUwMjlFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDI5RWFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMjlGXFx1MDJBNFxceDA3MFx1MDAwMlx1MDAwMlxcdTAyQTBcXHUwMkEyXHUwMDA1XFx4QkVgXHUwMDAyXFx1MDJBMVxcdTAyQTBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMkExXFx1MDJBMlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyQTJcXHUwMkEzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDJBM1xcdTAyQTVcdTAwMDU8XHUwMDFmXHUwMDAyXFx1MDJBNFxcdTAyQTFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMkE0XFx1MDJBNVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyQTVcXHUwMkE2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDJBNlxcdTAyQTdcdTAwMDVYLVx1MDAwMlxcdTAyQTdjXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDJBOFxcdTAyQTlcXHgwNzFcdTAwMDJcdTAwMDJcXHUwMkE5XFx1MDJBQVxceDA3XHUwMDE5XHUwMDAyXHUwMDAyXFx1MDJBQVxcdTAyQUJcdTAwMDVcXHg4NkRcdTAwMDJcXHUwMkFCXFx1MDJBQ1xceDA3XHUwMDFhXHUwMDAyXHUwMDAyXFx1MDJBQ1xcdTAyQURcdTAwMDVaLlx1MDAwMlxcdTAyQURlXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDJBRVxcdTAyQjFcdTAwMDV+QFx1MDAwMlxcdTAyQUZcXHUwMkIxXHUwMDA1XFxcXC9cdTAwMDJcXHUwMkIwXFx1MDJBRVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyQjBcXHUwMkFGXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDJCMWdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMkIyXFx1MDJCM1xceDA3Mlx1MDAwMlx1MDAwMlxcdTAyQjNcXHUwMkI0XHUwMDA1WC1cdTAwMDJcXHUwMkI0aVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyQjVcXHUwMkI2XFx4MDdcdTAwMWRcdTAwMDJcdTAwMDJcXHUwMkI2XFx1MDJCOVxceDA3XHUwMDE5XHUwMDAyXHUwMDAyXFx1MDJCN1xcdTAyQkFcdTAwMDVmNFx1MDAwMlxcdTAyQjhcXHUwMkJBXFx4MDdcdTAwMDRcdTAwMDJcdTAwMDJcXHUwMkI5XFx1MDJCN1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyQjlcXHUwMkI4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDJCQVxcdTAyQkRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMkJCXFx1MDJCRVx1MDAwNVxcXFwvXHUwMDAyXFx1MDJCQ1xcdTAyQkVcXHgwN1x1MDAwNFx1MDAwMlx1MDAwMlxcdTAyQkRcXHUwMkJCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDJCRFxcdTAyQkNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMkJFXFx1MDJDMFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyQkZcXHUwMkMxXHUwMDA1XFx4ODZEXHUwMDAyXFx1MDJDMFxcdTAyQkZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMkMwXFx1MDJDMVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyQzFcXHUwMkMyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDJDMlxcdTAyQzNcXHgwN1x1MDAxYVx1MDAwMlx1MDAwMlxcdTAyQzNcXHUwMkM0XHUwMDA1Wi5cdTAwMDJcXHUwMkM0a1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyQzVcXHUwMkM3XFx4MDczXHUwMDAyXHUwMDAyXFx1MDJDNlxcdTAyQzhcXHgwN1xceDg0XHUwMDAyXHUwMDAyXFx1MDJDN1xcdTAyQzZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMkM3XFx1MDJDOFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyQzhcXHUwMkNEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDJDOVxcdTAyQ0FcXHgwN1x1MDAxOVx1MDAwMlx1MDAwMlxcdTAyQ0FcXHUwMkNCXHUwMDA1bjhcdTAwMDJcXHUwMkNCXFx1MDJDQ1xceDA3XHUwMDFhXHUwMDAyXHUwMDAyXFx1MDJDQ1xcdTAyQ0VcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMkNEXFx1MDJDOVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyQ0RcXHUwMkNFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDJDRVxcdTAyQ0ZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMkNGXFx1MDJEMFx1MDAwNVxceDk0S1x1MDAwMlxcdTAyRDBtXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDJEMVxcdTAyRDJcdTAwMDVcXHhDNGNcdTAwMDJcXHUwMkQyb1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyRDNcXHUwMkQ0XFx4MDc0XHUwMDAyXHUwMDAyXFx1MDJENFxcdTAyRDVcdTAwMDVaLlx1MDAwMlxcdTAyRDVcXHUwMkQ2XFx4MDcxXHUwMDAyXHUwMDAyXFx1MDJENlxcdTAyRDdcXHgwN1x1MDAxOVx1MDAwMlx1MDAwMlxcdTAyRDdcXHUwMkQ4XHUwMDA1XFx4ODZEXHUwMDAyXFx1MDJEOFxcdTAyRDlcXHgwN1x1MDAxYVx1MDAwMlx1MDAwMlxcdTAyRDlcXHUwMkRBXFx4MDdcdTAwMDRcdTAwMDJcdTAwMDJcXHUwMkRBcVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyREJcXHUwMkRDXFx4MDdzXHUwMDAyXHUwMDAyXFx1MDJEQ1xcdTAyRERcXHgwN1x1MDAwNFx1MDAwMlx1MDAwMlxcdTAyRERzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDJERVxcdTAyREZcXHgwN3BcdTAwMDJcdTAwMDJcXHUwMkRGXFx1MDJFMFxceDA3XHUwMDA0XHUwMDAyXHUwMDAyXFx1MDJFMHVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMkUxXFx1MDJFM1xceDA3NVx1MDAwMlx1MDAwMlxcdTAyRTJcXHUwMkU0XHUwMDA1XFx4ODZEXHUwMDAyXFx1MDJFM1xcdTAyRTJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMkUzXFx1MDJFNFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyRTRcXHUwMkU1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDJFNVxcdTAyRTZcXHgwN1x1MDAwNFx1MDAwMlx1MDAwMlxcdTAyRTZ3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDJFN1xcdTAyRThcXHgwNzZcdTAwMDJcdTAwMDJcXHUwMkU4XFx1MDJFOVxceDA3XHUwMDA0XHUwMDAyXHUwMDAyXFx1MDJFOXlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMkVBXFx1MDJFQlxceDA3N1x1MDAwMlx1MDAwMlxcdTAyRUJcXHUwMkVDXHUwMDA1XFx4OTJKXHUwMDAyXFx1MDJFQ1xcdTAyRURcXHgwN1x1MDAwNFx1MDAwMlx1MDAwMlxcdTAyRUR7XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDJFRVxcdTAyRUZcXHgwNzhcdTAwMDJcdTAwMDJcXHUwMkVGXFx1MDJGMFx1MDAwNVxceDkySlx1MDAwMlxcdTAyRjBcXHUwMkYxXFx4MDdcdTAwMDRcdTAwMDJcdTAwMDJcXHUwMkYxfVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyRjJcXHUwMkYzXFx4MDc5XHUwMDAyXHUwMDAyXFx1MDJGM1xcdTAyRkFcdTAwMDVcXHg4MkJcdTAwMDJcXHUwMkY0XFx1MDJGQVx1MDAwNUglXHUwMDAyXFx1MDJGNVxcdTAyRjZcXHgwN1x1MDAxOVx1MDAwMlx1MDAwMlxcdTAyRjZcXHUwMkY3XHUwMDA1XFx4ODBBXHUwMDAyXFx1MDJGN1xcdTAyRjhcXHgwN1x1MDAxYVx1MDAwMlx1MDAwMlxcdTAyRjhcXHUwMkZBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDJGOVxcdTAyRjJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMkY5XFx1MDJGNFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyRjlcXHUwMkY1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDJGQVxcdTAyRkRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMkZCXFx1MDJGQ1xceDA3XFxyXHUwMDAyXHUwMDAyXFx1MDJGQ1xcdTAyRkVcdTAwMDVcXHg4NkRcdTAwMDJcXHUwMkZEXFx1MDJGQlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAyRkRcXHUwMkZFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDJGRVxcdTAyRkZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMkZGXFx1MDMwMFxceDA3XHUwMDA0XHUwMDAyXHUwMDAyXFx1MDMwMFxceDdGXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDMwMVxcdTAzMDNcdTAwMDVIJVx1MDAwMlxcdTAzMDJcXHUwMzAxXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDMwMlxcdTAzMDNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzAzXFx1MDMwQVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzMDRcXHUwMzA2XFx4MDdcdTAwMTJcdTAwMDJcdTAwMDJcXHUwMzA1XFx1MDMwN1x1MDAwNUglXHUwMDAyXFx1MDMwNlxcdTAzMDVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzA2XFx1MDMwN1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzMDdcXHUwMzA5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDMwOFxcdTAzMDRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzA5XFx1MDMwQ1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzMEFcXHUwMzA4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDMwQVxcdTAzMEJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzBCXFx4ODFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzBDXFx1MDMwQVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzMERcXHUwMzE0XFx4MDdcdTAwMTlcdTAwMDJcdTAwMDJcXHUwMzBFXFx1MDMxMFx1MDAwNVxceEJFYFx1MDAwMlxcdTAzMEZcXHUwMzBFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDMwRlxcdTAzMTBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzEwXFx1MDMxMVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzMTFcXHUwMzEzXFx4MDdcdTAwMTJcdTAwMDJcdTAwMDJcXHUwMzEyXFx1MDMwRlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzMTNcXHUwMzE2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDMxNFxcdTAzMTJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzE0XFx1MDMxNVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzMTVcXHUwMzE4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDMxNlxcdTAzMTRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzE3XFx1MDMxOVx1MDAwNVxceEJFYFx1MDAwMlxcdTAzMThcXHUwMzE3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDMxOFxcdTAzMTlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzE5XFx1MDMxQVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzMUFcXHUwMzFCXFx4MDdcdTAwMWFcdTAwMDJcdTAwMDJcXHUwMzFCXFx4ODNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzFDXFx1MDMxRFx0XHUwMDA2XHUwMDAyXHUwMDAyXFx1MDMxRFxceDg1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDMxRVxcdTAzMUZcXGJEXHUwMDAxXHUwMDAyXFx1MDMxRlxcdTAzMjBcXHgwNz9cdTAwMDJcdTAwMDJcXHUwMzIwXFx1MDMzMVx1MDAwNUomXHUwMDAyXFx1MDMyMVxcdTAzMjJcXHgwN1x1MDAxOVx1MDAwMlx1MDAwMlxcdTAzMjJcXHUwMzIzXHUwMDA1XFx4ODZEXHUwMDAyXFx1MDMyM1xcdTAzMjRcXHgwN1x1MDAxYVx1MDAwMlx1MDAwMlxcdTAzMjRcXHUwMzMxXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDMyNVxcdTAzMjZcdFxceDA3XHUwMDAyXHUwMDAyXFx1MDMyNlxcdTAzMzFcdTAwMDVcXHg4NkRcdTAwMTVcXHUwMzI3XFx1MDMyOFx0XFxiXHUwMDAyXHUwMDAyXFx1MDMyOFxcdTAzMzFcdTAwMDVcXHg4NkRcdTAwMTRcXHUwMzI5XFx1MDMyQVx0XHRcdTAwMDJcdTAwMDJcXHUwMzJBXFx1MDMzMVx1MDAwNVxceDg2RFx1MDAxM1xcdTAzMkJcXHUwMzJDXFx4MDdFXHUwMDAyXHUwMDAyXFx1MDMyQ1xcdTAzMzFcdTAwMDVcXHg4NkRcdTAwMTJcXHUwMzJEXFx1MDMyRVxceDA3XFxiXHUwMDAyXHUwMDAyXFx1MDMyRVxcdTAzMzFcdTAwMDVcXHg4NkRcdTAwMTFcXHUwMzJGXFx1MDMzMVx1MDAwNVxceDg4RVx1MDAwMlxcdTAzMzBcXHUwMzFFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDMzMFxcdTAzMjFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzMwXFx1MDMyNVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzMzBcXHUwMzI3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDMzMFxcdTAzMjlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzMwXFx1MDMyQlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzMzBcXHUwMzJEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDMzMFxcdTAzMkZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzMxXFx1MDM3Q1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzMzJcXHUwMzMzXFxmXHUwMDEwXHUwMDAyXHUwMDAyXFx1MDMzM1xcdTAzMzRcXHgwN0ZcdTAwMDJcdTAwMDJcXHUwMzM0XFx1MDM3Qlx1MDAwNVxceDg2RFx1MDAxMVxcdTAzMzVcXHUwMzM2XFxmXHUwMDBmXHUwMDAyXHUwMDAyXFx1MDMzNlxcdTAzMzdcdFxcblx1MDAwMlx1MDAwMlxcdTAzMzdcXHUwMzdCXHUwMDA1XFx4ODZEXHUwMDEwXFx1MDMzOFxcdTAzMzlcXGZcdTAwMGVcdTAwMDJcdTAwMDJcXHUwMzM5XFx1MDMzQVx0XFxiXHUwMDAyXHUwMDAyXFx1MDMzQVxcdTAzN0JcdTAwMDVcXHg4NkRcdTAwMGZcXHUwMzNCXFx1MDMzQ1xcZlxcclx1MDAwMlx1MDAwMlxcdTAzM0NcXHUwMzNEXHRcXHZcdTAwMDJcdTAwMDJcXHUwMzNEXFx1MDM3Qlx1MDAwNVxceDg2RFx1MDAwZVxcdTAzM0VcXHUwMzNGXFxmXFxmXHUwMDAyXHUwMDAyXFx1MDMzRlxcdTAzNDBcXHgwN0tcdTAwMDJcdTAwMDJcXHUwMzQwXFx1MDM3Qlx1MDAwNVxceDg2RFxcclxcdTAzNDFcXHUwMzQyXFxmXFx2XHUwMDAyXHUwMDAyXFx1MDM0MlxcdTAzNDNcXHgwN1xceDA3XHUwMDAyXHUwMDAyXFx1MDM0M1xcdTAzN0JcdTAwMDVcXHg4NkRcXGZcXHUwMzQ0XFx1MDM0NVxcZlxcblx1MDAwMlx1MDAwMlxcdTAzNDVcXHUwMzQ2XFx4MDdMXHUwMDAyXHUwMDAyXFx1MDM0NlxcdTAzN0JcdTAwMDVcXHg4NkRcXHZcXHUwMzQ3XFx1MDM0OFxcZlx0XHUwMDAyXHUwMDAyXFx1MDM0OFxcdTAzNDlcdFxcZlx1MDAwMlx1MDAwMlxcdTAzNDlcXHUwMzdCXHUwMDA1XFx4ODZEXFxuXFx1MDM0QVxcdTAzNEJcXGZcXGJcdTAwMDJcdTAwMDJcXHUwMzRCXFx1MDM0Q1x0XFxyXHUwMDAyXHUwMDAyXFx1MDM0Q1xcdTAzN0JcdTAwMDVcXHg4NkRcdFxcdTAzNERcXHUwMzRFXFxmXFx4MDdcdTAwMDJcdTAwMDJcXHUwMzRFXFx1MDM0RlxceDA3T1x1MDAwMlx1MDAwMlxcdTAzNEZcXHUwMzdCXHUwMDA1XFx4ODZEXFxiXFx1MDM1MFxcdTAzNTFcXGZcdTAwMDZcdTAwMDJcdTAwMDJcXHUwMzUxXFx1MDM1MlxceDA3XHUwMDA2XHUwMDAyXHUwMDAyXFx1MDM1MlxcdTAzN0JcdTAwMDVcXHg4NkRcXHgwN1xcdTAzNTNcXHUwMzU0XFxmXHUwMDA1XHUwMDAyXHUwMDAyXFx1MDM1NFxcdTAzNTVcXHgwN1BcdTAwMDJcdTAwMDJcXHUwMzU1XFx1MDM1Nlx1MDAwNVxceDg2RFx1MDAwMlxcdTAzNTZcXHUwMzU3XFx4MDdAXHUwMDAyXHUwMDAyXFx1MDM1N1xcdTAzNThcdTAwMDVcXHg4NkRcdTAwMDZcXHUwMzU4XFx1MDM3Qlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzNTlcXHUwMzVBXFxmXHUwMDA0XHUwMDAyXHUwMDAyXFx1MDM1QVxcdTAzNUJcdFx1MDAwZVx1MDAwMlx1MDAwMlxcdTAzNUJcXHUwMzdCXHUwMDA1XFx4ODZEXHUwMDA1XFx1MDM1Q1xcdTAzNURcXGZcdTAwMWRcdTAwMDJcdTAwMDJcXHUwMzVEXFx1MDM3Qlx0XFx4MDdcdTAwMDJcdTAwMDJcXHUwMzVFXFx1MDM1RlxcZlx1MDAxYlx1MDAwMlx1MDAwMlxcdTAzNUZcXHUwMzYwXFx4MDckXHUwMDAyXHUwMDAyXFx1MDM2MFxcdTAzNjFcdTAwMDVcXHg4NkRcdTAwMDJcXHUwMzYxXFx1MDM2MlxceDA3JVx1MDAwMlx1MDAwMlxcdTAzNjJcXHUwMzdCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM2M1xcdTAzNjRcXGZcdTAwMWFcdTAwMDJcdTAwMDJcXHUwMzY0XFx1MDM2NlxceDA3JFx1MDAwMlx1MDAwMlxcdTAzNjVcXHUwMzY3XHUwMDA1XFx4ODZEXHUwMDAyXFx1MDM2NlxcdTAzNjVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzY2XFx1MDM2N1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzNjdcXHUwMzY4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM2OFxcdTAzNkFcXHgwN0BcdTAwMDJcdTAwMDJcXHUwMzY5XFx1MDM2Qlx1MDAwNVxceDg2RFx1MDAwMlxcdTAzNkFcXHUwMzY5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM2QVxcdTAzNkJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzZCXFx1MDM2Q1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzNkNcXHUwMzdCXFx4MDclXHUwMDAyXHUwMDAyXFx1MDM2RFxcdTAzNkVcXGZcdTAwMTlcdTAwMDJcdTAwMDJcXHUwMzZFXFx1MDM2RlxceDA3J1x1MDAwMlx1MDAwMlxcdTAzNkZcXHUwMzdCXHUwMDA1XFx4QkVgXHUwMDAyXFx1MDM3MFxcdTAzNzFcXGZcdTAwMThcdTAwMDJcdTAwMDJcXHUwMzcxXFx1MDM3MlxceDA3XHUwMDExXHUwMDAyXHUwMDAyXFx1MDM3MlxcdTAzNzNcdTAwMDVcXHg4Q0dcdTAwMDJcXHUwMzczXFx1MDM3NFxceDA3XHUwMDEzXHUwMDAyXHUwMDAyXFx1MDM3NFxcdTAzN0JcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzc1XFx1MDM3NlxcZlx1MDAxN1x1MDAwMlx1MDAwMlxcdTAzNzZcXHUwMzc3XFx4MDdcdTAwMTlcdTAwMDJcdTAwMDJcXHUwMzc3XFx1MDM3OFx1MDAwNVxceDkwSVx1MDAwMlxcdTAzNzhcXHUwMzc5XFx4MDdcdTAwMWFcdTAwMDJcdTAwMDJcXHUwMzc5XFx1MDM3Qlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzN0FcXHUwMzMyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM3QVxcdTAzMzVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzdBXFx1MDMzOFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzN0FcXHUwMzNCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM3QVxcdTAzM0VcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzdBXFx1MDM0MVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzN0FcXHUwMzQ0XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM3QVxcdTAzNDdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzdBXFx1MDM0QVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzN0FcXHUwMzREXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM3QVxcdTAzNTBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzdBXFx1MDM1M1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzN0FcXHUwMzU5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM3QVxcdTAzNUNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzdBXFx1MDM1RVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzN0FcXHUwMzYzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM3QVxcdTAzNkRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzdBXFx1MDM3MFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzN0FcXHUwMzc1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM3QlxcdTAzN0VcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzdDXFx1MDM3QVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzN0NcXHUwMzdEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM3RFxceDg3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM3RVxcdTAzN0NcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzdGXFx1MDM4OVxceDA3aVx1MDAwMlx1MDAwMlxcdTAzODBcXHUwMzg5XHUwMDA1XFx4QkNfXHUwMDAyXFx1MDM4MVxcdTAzODlcdTAwMDVcXHhDMGFcdTAwMDJcXHUwMzgyXFx1MDM4OVx1MDAwNVxceEM0Y1x1MDAwMlxcdTAzODNcXHUwMzg5XHUwMDA1XFx4QkVgXHUwMDAyXFx1MDM4NFxcdTAzODlcXHgwN31cdTAwMDJcdTAwMDJcXHUwMzg1XFx1MDM4OVxceDA3eFx1MDAwMlx1MDAwMlxcdTAzODZcXHUwMzg5XHUwMDA1XFx4QkFeXHUwMDAyXFx1MDM4N1xcdTAzODlcdTAwMDVKJlx1MDAwMlxcdTAzODhcXHUwMzdGXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM4OFxcdTAzODBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzg4XFx1MDM4MVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzODhcXHUwMzgyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM4OFxcdTAzODNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzg4XFx1MDM4NFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzODhcXHUwMzg1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM4OFxcdTAzODZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzg4XFx1MDM4N1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzODlcXHg4OVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzOEFcXHUwMzhGXHUwMDA1XFx4ODZEXHUwMDAyXFx1MDM4QlxcdTAzOENcXHgwN1x1MDAxMlx1MDAwMlx1MDAwMlxcdTAzOENcXHUwMzhFXHUwMDA1XFx4ODZEXHUwMDAyXFx1MDM4RFxcdTAzOEJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzhFXFx1MDM5MVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzOEZcXHUwMzhEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM4RlxcdTAzOTBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzkwXFx4OEJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzkxXFx1MDM4Rlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzOTJcXHUwMzk3XHUwMDA1XFx4OEVIXHUwMDAyXFx1MDM5M1xcdTAzOTRcXHgwN1x1MDAxMlx1MDAwMlx1MDAwMlxcdTAzOTRcXHUwMzk2XHUwMDA1XFx4OEVIXHUwMDAyXFx1MDM5NVxcdTAzOTNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzk2XFx1MDM5OVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzOTdcXHUwMzk1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM5N1xcdTAzOThcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzk4XFx1MDM5Qlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzOTlcXHUwMzk3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM5QVxcdTAzOUNcXHgwN1x1MDAxMlx1MDAwMlx1MDAwMlxcdTAzOUJcXHUwMzlBXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDM5QlxcdTAzOUNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzlDXFx4OERcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwMzlEXFx1MDM5RVx1MDAwNVxceEJFYFx1MDAwMlxcdTAzOUVcXHUwMzlGXFx4MDdAXHUwMDAyXHUwMDAyXFx1MDM5RlxcdTAzQTBcdTAwMDVcXHg4NkRcdTAwMDJcXHUwM0EwXFx4OEZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwM0ExXFx1MDNBM1xceDA3XHUwMDExXHUwMDAyXHUwMDAyXFx1MDNBMlxcdTAzQTRcdTAwMDVcXHg4Q0dcdTAwMDJcXHUwM0EzXFx1MDNBMlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzQTNcXHUwM0E0XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNBNFxcdTAzQTVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwM0E1XFx1MDNBQVxceDA3XHUwMDEzXHUwMDAyXHUwMDAyXFx1MDNBNlxcdTAzQThcdTAwMDVcXHg4QUZcdTAwMDJcXHUwM0E3XFx1MDNBNlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzQTdcXHUwM0E4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNBOFxcdTAzQUFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwM0E5XFx1MDNBMVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzQTlcXHUwM0E3XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNBQVxceDkxXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNBQlxcdTAzQUNcdTAwMDVcXHg4NkRcdTAwMDJcXHUwM0FDXFx1MDNBRFxceDA3XHUwMDE5XHUwMDAyXHUwMDAyXFx1MDNBRFxcdTAzQUVcdTAwMDVcXHg5MElcdTAwMDJcXHUwM0FFXFx1MDNBRlxceDA3XHUwMDFhXHUwMDAyXHUwMDAyXFx1MDNBRlxceDkzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNCMFxcdTAzQjRcXHgwN1x1MDAxMVx1MDAwMlx1MDAwMlxcdTAzQjFcXHUwM0IzXHUwMDA1XFx4OTZMXHUwMDAyXFx1MDNCMlxcdTAzQjFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwM0IzXFx1MDNCNlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzQjRcXHUwM0IyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNCNFxcdTAzQjVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwM0I1XFx1MDNCN1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzQjZcXHUwM0I0XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNCN1xcdTAzQjhcXHgwN1x1MDAxM1x1MDAwMlx1MDAwMlxcdTAzQjhcXHg5NVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzQjlcXHUwM0NDXHUwMDA1XFx4QkVgXHUwMDAyXFx1MDNCQVxcdTAzQ0NcdTAwMDVcXHg5NEtcdTAwMDJcXHUwM0JCXFx1MDNDQ1x1MDAwNVxceDk4TVx1MDAwMlxcdTAzQkNcXHUwM0NDXHUwMDA1XFx4OUVQXHUwMDAyXFx1MDNCRFxcdTAzQ0NcdTAwMDVcXHhBMFFcdTAwMDJcXHUwM0JFXFx1MDNDQ1x1MDAwNVxceEE2VFx1MDAwMlxcdTAzQkZcXHUwM0NDXHUwMDA1XFx4QThVXHUwMDAyXFx1MDNDMFxcdTAzQ0NcdTAwMDVcXHhBQVZcdTAwMDJcXHUwM0MxXFx1MDNDQ1x1MDAwNVxceEFFWFx1MDAwMlxcdTAzQzJcXHUwM0NDXHUwMDA1XFx4QjJaXHUwMDAyXFx1MDNDM1xcdTAzQ0NcdTAwMDVcXHhCNFtcdTAwMDJcXHUwM0M0XFx1MDNDQ1xceDA3cFx1MDAwMlx1MDAwMlxcdTAzQzVcXHUwM0NDXFx4MDdzXHUwMDAyXHUwMDAyXFx1MDNDNlxcdTAzQ0NcXHgwN3RcdTAwMDJcdTAwMDJcXHUwM0M3XFx1MDNDQ1x1MDAwNVxceEI4XVx1MDAwMlxcdTAzQzhcXHUwM0NDXHUwMDA1XFx4QkNfXHUwMDAyXFx1MDNDOVxcdTAzQ0NcdTAwMDVcXHhDNGNcdTAwMDJcXHUwM0NBXFx1MDNDQ1x1MDAwNVxceEMwYVx1MDAwMlxcdTAzQ0JcXHUwM0I5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNDQlxcdTAzQkFcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwM0NCXFx1MDNCQlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzQ0JcXHUwM0JDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNDQlxcdTAzQkRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwM0NCXFx1MDNCRVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzQ0JcXHUwM0JGXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNDQlxcdTAzQzBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwM0NCXFx1MDNDMVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzQ0JcXHUwM0MyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNDQlxcdTAzQzNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwM0NCXFx1MDNDNFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzQ0JcXHUwM0M1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNDQlxcdTAzQzZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwM0NCXFx1MDNDN1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzQ0JcXHUwM0M4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNDQlxcdTAzQzlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwM0NCXFx1MDNDQVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzQ0NcXHg5N1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzQ0RcXHUwM0QxXHUwMDA1XFx4OUNPXHUwMDAyXFx1MDNDRVxcdTAzRDFcdTAwMDVcXHhCNlxcXFxcdTAwMDJcXHUwM0NGXFx1MDNEMVx1MDAwNVxceDlBTlx1MDAwMlxcdTAzRDBcXHUwM0NEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNEMFxcdTAzQ0VcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwM0QwXFx1MDNDRlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzRDFcXHg5OVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzRDJcXHUwM0QzXHUwMDA1XFx4QkVgXHUwMDAyXFx1MDNEM1xcdTAzRDRcXHgwNydcdTAwMDJcdTAwMDJcXHUwM0Q0XFx1MDNENVx1MDAwNVxceEJFYFx1MDAwMlxcdTAzRDVcXHg5Qlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzRDZcXHUwM0RCXFx4MDc1XHUwMDAyXHUwMDAyXFx1MDNEN1xcdTAzREJcXHgwNyZcdTAwMDJcdTAwMDJcXHUwM0Q4XFx1MDNEQlxceDA3PFx1MDAwMlx1MDAwMlxcdTAzRDlcXHUwM0RCXHUwMDA1XFx4QkVgXHUwMDAyXFx1MDNEQVxcdTAzRDZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwM0RBXFx1MDNEN1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzREFcXHUwM0Q4XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNEQVxcdTAzRDlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwM0RCXFx1MDNFOFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzRENcXHUwM0RFXFx4MDdcdTAwMTlcdTAwMDJcdTAwMDJcXHUwM0REXFx1MDNERlx1MDAwNVxceDk4TVx1MDAwMlxcdTAzREVcXHUwM0REXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNERVxcdTAzREZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwM0RGXFx1MDNFNFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzRTBcXHUwM0UxXFx4MDdcdTAwMTJcdTAwMDJcdTAwMDJcXHUwM0UxXFx1MDNFM1x1MDAwNVxceDk4TVx1MDAwMlxcdTAzRTJcXHUwM0UwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNFM1xcdTAzRTZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwM0U0XFx1MDNFMlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzRTRcXHUwM0U1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNFNVxcdTAzRTdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwM0U2XFx1MDNFNFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzRTdcXHUwM0U5XFx4MDdcdTAwMWFcdTAwMDJcdTAwMDJcXHUwM0U4XFx1MDNEQ1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzRThcXHUwM0U5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNFOVxceDlEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNFQVxcdTAzRUJcXHgwN1tcdTAwMDJcdTAwMDJcXHUwM0VCXFx1MDNFRVx1MDAwNVxceEEyUlx1MDAwMlxcdTAzRUNcXHUwM0VEXFx4MDdcXFxcXHUwMDAyXHUwMDAyXFx1MDNFRFxcdTAzRUZcdTAwMDVcXHg5OE1cdTAwMDJcXHUwM0VFXFx1MDNFQ1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzRUVcXHUwM0VGXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNFRlxceDlGXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNGMFxcdTAzRjFcdTAwMDVcXHhBMlJcdTAwMDJcXHUwM0YxXFx1MDNGMlxceDA3XFxcXFx1MDAwMlx1MDAwMlxcdTAzRjJcXHUwM0YzXHUwMDA1XFx4OThNXHUwMDAyXFx1MDNGM1xceEExXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNGNFxcdTAzRkNcdTAwMDVcXHhCRWBcdTAwMDJcXHUwM0Y1XFx1MDNGQ1x1MDAwNVxceDlBTlx1MDAwMlxcdTAzRjZcXHUwM0ZDXHUwMDA1XFx4QTRTXHUwMDAyXFx1MDNGN1xcdTAzRjhcXHgwN1x1MDAxOVx1MDAwMlx1MDAwMlxcdTAzRjhcXHUwM0Y5XHUwMDA1XFx4QTRTXHUwMDAyXFx1MDNGOVxcdTAzRkFcXHgwN1x1MDAxYVx1MDAwMlx1MDAwMlxcdTAzRkFcXHUwM0ZDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNGQlxcdTAzRjRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwM0ZCXFx1MDNGNVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTAzRkJcXHUwM0Y2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDNGQlxcdTAzRjdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwM0ZDXFx4QTNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwM0ZEXFx1MDQwMlx1MDAwNVxceEJFYFx1MDAwMlxcdTAzRkVcXHUwM0ZGXFx4MDdcdTAwMTJcdTAwMDJcdTAwMDJcXHUwM0ZGXFx1MDQwMVx1MDAwNVxceEJFYFx1MDAwMlxcdTA0MDBcXHUwM0ZFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQwMVxcdTA0MDRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDAyXFx1MDQwMFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0MDJcXHUwNDAzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQwM1xceEE1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQwNFxcdTA0MDJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDA1XFx1MDQwNlx1MDAwNVxceDk4TVx1MDAwMlxcdTA0MDZcXHUwNDA3XFx4MDddXHUwMDAyXHUwMDAyXFx1MDQwN1xcdTA0MDhcdTAwMDVcXHhCRWBcdTAwMDJcXHUwNDA4XFx4QTdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDA5XFx1MDQwQVx1MDAwNVxceEJFYFx1MDAwMlxcdTA0MEFcXHUwNDBCXFx4MDdAXHUwMDAyXHUwMDAyXFx1MDQwQlxceEE5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQwQ1xcdTA0MERcXHgwN15cdTAwMDJcdTAwMDJcXHUwNDBEXFx1MDQxMVx1MDAwNVxceDk4TVx1MDAwMlxcdTA0MEVcXHUwNDEwXHUwMDA1XFx4QUNXXHUwMDAyXFx1MDQwRlxcdTA0MEVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDEwXFx1MDQxM1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0MTFcXHUwNDBGXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQxMVxcdTA0MTJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDEyXFx4QUJcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDEzXFx1MDQxMVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0MTRcXHUwNDE1XFx4MDdfXHUwMDAyXHUwMDAyXFx1MDQxNVxcdTA0MTZcdTAwMDVcXHhCNlxcXFxcdTAwMDJcXHUwNDE2XFx1MDQxN1x1MDAwNVxceDk0S1x1MDAwMlxcdTA0MTdcXHUwNDFCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQxOFxcdTA0MTlcXHgwN2BcdTAwMDJcdTAwMDJcXHUwNDE5XFx1MDQxQlx1MDAwNVxceDk0S1x1MDAwMlxcdTA0MUFcXHUwNDE0XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQxQVxcdTA0MThcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDFCXFx4QURcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDFDXFx1MDQxRFxceDA3IFx1MDAwMlx1MDAwMlxcdTA0MURcXHUwNDFFXHUwMDA1XFx4QkVgXHUwMDAyXFx1MDQxRVxcdTA0MjBcXHgwN1x1MDAxOVx1MDAwMlx1MDAwMlxcdTA0MUZcXHUwNDIxXHUwMDA1XFx4QTRTXHUwMDAyXFx1MDQyMFxcdTA0MUZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDIwXFx1MDQyMVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0MjFcXHUwNDIyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQyMlxcdTA0MjRcXHgwN1x1MDAxYVx1MDAwMlx1MDAwMlxcdTA0MjNcXHUwNDI1XHUwMDA1XFx4QjBZXHUwMDAyXFx1MDQyNFxcdTA0MjNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDI0XFx1MDQyNVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0MjVcXHUwNDI2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQyNlxcdTA0MjdcdTAwMDVcXHg5NEtcdTAwMDJcXHUwNDI3XFx4QUZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDI4XFx1MDQyOVxceDA3YVx1MDAwMlx1MDAwMlxcdTA0MjlcXHUwNDJBXHUwMDA1XFx4QTRTXHUwMDAyXFx1MDQyQVxceEIxXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQyQlxcdTA0MkVcXHgwN1x1MDAxZFx1MDAwMlx1MDAwMlxcdTA0MkNcXHUwNDJGXHUwMDA1XFx4OTRLXHUwMDAyXFx1MDQyRFxcdTA0MkZcdTAwMDVcXHg5OE1cdTAwMDJcXHUwNDJFXFx1MDQyQ1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0MkVcXHUwNDJEXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQyRlxcdTA0MzBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDMwXFx1MDQzM1x1MDAwNVxceDk4TVx1MDAwMlxcdTA0MzFcXHUwNDM0XHUwMDA1XFx4OTRLXHUwMDAyXFx1MDQzMlxcdTA0MzRcdTAwMDVcXHg5OE1cdTAwMDJcXHUwNDMzXFx1MDQzMVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0MzNcXHUwNDMyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQzNFxcdTA0MzVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDM1XFx1MDQzNlx1MDAwNVxceDk0S1x1MDAwMlxcdTA0MzZcXHhCM1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0MzdcXHUwNDM4XFx4MDctXHUwMDAyXHUwMDAyXFx1MDQzOFxcdTA0MzlcdTAwMDVcXHg5OE1cdTAwMDJcXHUwNDM5XFx1MDQzQVx1MDAwNVxceDk0S1x1MDAwMlxcdTA0M0FcXHhCNVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0M0JcXHUwNDQxXHUwMDA1XFx4QzRjXHUwMDAyXFx1MDQzQ1xcdTA0NDFcXHgwN2pcdTAwMDJcdTAwMDJcXHUwNDNEXFx1MDQ0MVxceDA3a1x1MDAwMlx1MDAwMlxcdTA0M0VcXHUwNDQxXHUwMDA1XFx4QzBhXHUwMDAyXFx1MDQzRlxcdTA0NDFcXHgwN2lcdTAwMDJcdTAwMDJcXHUwNDQwXFx1MDQzQlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NDBcXHUwNDNDXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ0MFxcdTA0M0RcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDQwXFx1MDQzRVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NDBcXHUwNDNGXHUwMDAzXHUwMDAyXCI7XG5Tb2xpZGl0eVBhcnNlci5fc2VyaWFsaXplZEFUTlNlZ21lbnQyID0gXCJcdTAwMDJcdTAwMDJcXHUwNDQxXFx4QjdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDQyXFx1MDQ0M1xceDA3M1x1MDAwMlx1MDAwMlxcdTA0NDNcXHUwNDQ0XHUwMDA1XFx4QkVgXHUwMDAyXFx1MDQ0NFxcdTA0NDVcdTAwMDVcXHg5NEtcdTAwMDJcXHUwNDQ1XFx4QjlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDQ2XFx1MDQ0OFxceDA3XHUwMDE5XHUwMDAyXHUwMDAyXFx1MDQ0N1xcdTA0NDlcdTAwMDVcXHg4NkRcdTAwMDJcXHUwNDQ4XFx1MDQ0N1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NDhcXHUwNDQ5XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ0OVxcdTA0NTBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDRBXFx1MDQ0Q1xceDA3XHUwMDEyXHUwMDAyXHUwMDAyXFx1MDQ0QlxcdTA0NERcdTAwMDVcXHg4NkRcdTAwMDJcXHUwNDRDXFx1MDQ0Qlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NENcXHUwNDREXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ0RFxcdTA0NEZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDRFXFx1MDQ0QVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NEZcXHUwNDUyXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ1MFxcdTA0NEVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDUwXFx1MDQ1MVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NTFcXHUwNDUzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ1MlxcdTA0NTBcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDUzXFx1MDQ2MVxceDA3XHUwMDFhXHUwMDAyXHUwMDAyXFx1MDQ1NFxcdTA0NURcXHgwNyRcdTAwMDJcdTAwMDJcXHUwNDU1XFx1MDQ1QVx1MDAwNVxceDg2RFx1MDAwMlxcdTA0NTZcXHUwNDU3XFx4MDdcdTAwMTJcdTAwMDJcdTAwMDJcXHUwNDU3XFx1MDQ1OVx1MDAwNVxceDg2RFx1MDAwMlxcdTA0NThcXHUwNDU2XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ1OVxcdTA0NUNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDVBXFx1MDQ1OFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NUFcXHUwNDVCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ1QlxcdTA0NUVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDVDXFx1MDQ1QVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NURcXHUwNDU1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ1RFxcdTA0NUVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDVFXFx1MDQ1Rlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NUZcXHUwNDYxXFx4MDclXHUwMDAyXHUwMDAyXFx1MDQ2MFxcdTA0NDZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDYwXFx1MDQ1NFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NjFcXHhCQlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NjJcXHUwNDY0XHRcdTAwMGZcdTAwMDJcdTAwMDJcXHUwNDYzXFx1MDQ2NVxceDA3bFx1MDAwMlx1MDAwMlxcdTA0NjRcXHUwNDYzXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ2NFxcdTA0NjVcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDY1XFx4QkRcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDY2XFx1MDQ2N1x0XHUwMDEwXHUwMDAyXHUwMDAyXFx1MDQ2N1xceEJGXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ2OFxcdTA0NkFcXHgwN21cdTAwMDJcdTAwMDJcXHUwNDY5XFx1MDQ2OFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NkFcXHUwNDZCXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ2QlxcdTA0NjlcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDZCXFx1MDQ2Q1x1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NkNcXHhDMVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NkRcXHUwNDc5XFx4MDdjXHUwMDAyXHUwMDAyXFx1MDQ2RVxcdTA0NkZcXHgwN1x1MDAxOVx1MDAwMlx1MDAwMlxcdTA0NkZcXHUwNDc0XHUwMDA1TCdcdTAwMDJcXHUwNDcwXFx1MDQ3MVxceDA3XHUwMDEyXHUwMDAyXHUwMDAyXFx1MDQ3MVxcdTA0NzNcdTAwMDVMJ1x1MDAwMlxcdTA0NzJcXHUwNDcwXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ3M1xcdTA0NzZcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDc0XFx1MDQ3Mlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NzRcXHUwNDc1XHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ3NVxcdTA0NzdcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDc2XFx1MDQ3NFx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NzdcXHUwNDc4XFx4MDdcdTAwMWFcdTAwMDJcdTAwMDJcXHUwNDc4XFx1MDQ3QVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0NzlcXHUwNDZFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ3OVxcdTA0N0FcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDdBXFx4QzNcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDdCXFx1MDQ3RFxceDA3XFx4ODRcdTAwMDJcdTAwMDJcXHUwNDdDXFx1MDQ3Qlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0N0RcXHUwNDdFXHUwMDAzXHUwMDAyXHUwMDAyXHUwMDAyXFx1MDQ3RVxcdTA0N0NcdTAwMDNcdTAwMDJcdTAwMDJcdTAwMDJcXHUwNDdFXFx1MDQ3Rlx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxcdTA0N0ZcXHhDNVx1MDAwM1x1MDAwMlx1MDAwMlx1MDAwMlxceDgxXFx4RDBcXHhEMlxceEUxXFx4RTVcXHhFQVxceEYwXFx4RjRcXHhGN1xceEZDXFx1MDEwMlxcdTAxMDlcXHUwMTBEXFx1MDExQVxcdTAxMjJcXHUwMTI3XFx1MDEzMVxcdTAxMzRcXHUwMTNBXFx1MDE0MlxcdTAxNDVcXHUwMTUwXFx1MDE1OVxcdTAxNUJcXHUwMTYxXFx1MDE3Q1xcdTAxN0ZcXHUwMThBXFx1MDE4RlxcdTAxOUJcXHUwMTlFXFx1MDFBNVxcdTAxQTlcXHUwMUFCXFx1MDFCMFxcdTAxQjVcXHUwMUI4XFx1MDFCRVxcdTAxQzJcXHUwMUM2XFx1MDFDQlxcdTAxRDhcXHUwMURBXFx1MDFFMVxcdTAxRUJcXHUwMUYxXFx1MDFGQ1xcdTAxRkZcXHUwMjA1XFx1MDIwOFxcdTAyMTBcXHUwMjEzXFx1MDIxOVxcdTAyMUNcXHUwMjI0XFx1MDIyN1xcdTAyMkRcXHUwMjMxXFx1MDIzQ1xcdTAyNDFcXHUwMjQ2XFx1MDI0RVxcdTAyNTNcXHUwMjYxXFx1MDI2M1xcdTAyNjhcXHUwMjcyXFx1MDI4NlxcdTAyOTJcXHUwMjk3XFx1MDI5RFxcdTAyQTFcXHUwMkE0XFx1MDJCMFxcdTAyQjlcXHUwMkJEXFx1MDJDMFxcdTAyQzdcXHUwMkNEXFx1MDJFM1xcdTAyRjlcXHUwMkZEXFx1MDMwMlxcdTAzMDZcXHUwMzBBXFx1MDMwRlxcdTAzMTRcXHUwMzE4XFx1MDMzMFxcdTAzNjZcXHUwMzZBXFx1MDM3QVxcdTAzN0NcXHUwMzg4XFx1MDM4RlxcdTAzOTdcXHUwMzlCXFx1MDNBM1xcdTAzQTdcXHUwM0E5XFx1MDNCNFxcdTAzQ0JcXHUwM0QwXFx1MDNEQVxcdTAzREVcXHUwM0U0XFx1MDNFOFxcdTAzRUVcXHUwM0ZCXFx1MDQwMlxcdTA0MTFcXHUwNDFBXFx1MDQyMFxcdTA0MjRcXHUwNDJFXFx1MDQzM1xcdTA0NDBcXHUwNDQ4XFx1MDQ0Q1xcdTA0NTBcXHUwNDVBXFx1MDQ1RFxcdTA0NjBcXHUwNDY0XFx1MDQ2QlxcdTA0NzRcXHUwNDc5XFx1MDQ3RVwiO1xuU29saWRpdHlQYXJzZXIuX3NlcmlhbGl6ZWRBVE4gPSBVdGlsczIuam9pbihbXG4gIF9Tb2xpZGl0eVBhcnNlci5fc2VyaWFsaXplZEFUTlNlZ21lbnQwLFxuICBfU29saWRpdHlQYXJzZXIuX3NlcmlhbGl6ZWRBVE5TZWdtZW50MSxcbiAgX1NvbGlkaXR5UGFyc2VyLl9zZXJpYWxpemVkQVROU2VnbWVudDJcbl0sIFwiXCIpO1xudmFyIFNvdXJjZVVuaXRDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBFT0YoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4oU29saWRpdHlQYXJzZXIuRU9GLCAwKTtcbiAgfVxuICBwcmFnbWFEaXJlY3RpdmUoaSkge1xuICAgIGlmIChpID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0cyhQcmFnbWFEaXJlY3RpdmVDb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoaSwgUHJhZ21hRGlyZWN0aXZlQ29udGV4dCk7XG4gICAgfVxuICB9XG4gIGltcG9ydERpcmVjdGl2ZShpKSB7XG4gICAgaWYgKGkgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHRzKEltcG9ydERpcmVjdGl2ZUNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dChpLCBJbXBvcnREaXJlY3RpdmVDb250ZXh0KTtcbiAgICB9XG4gIH1cbiAgY29udHJhY3REZWZpbml0aW9uKGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dHMoQ29udHJhY3REZWZpbml0aW9uQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIENvbnRyYWN0RGVmaW5pdGlvbkNvbnRleHQpO1xuICAgIH1cbiAgfVxuICBlbnVtRGVmaW5pdGlvbihpKSB7XG4gICAgaWYgKGkgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHRzKEVudW1EZWZpbml0aW9uQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIEVudW1EZWZpbml0aW9uQ29udGV4dCk7XG4gICAgfVxuICB9XG4gIHN0cnVjdERlZmluaXRpb24oaSkge1xuICAgIGlmIChpID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0cyhTdHJ1Y3REZWZpbml0aW9uQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIFN0cnVjdERlZmluaXRpb25Db250ZXh0KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb25EZWZpbml0aW9uKGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dHMoRnVuY3Rpb25EZWZpbml0aW9uQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIEZ1bmN0aW9uRGVmaW5pdGlvbkNvbnRleHQpO1xuICAgIH1cbiAgfVxuICBmaWxlTGV2ZWxDb25zdGFudChpKSB7XG4gICAgaWYgKGkgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHRzKEZpbGVMZXZlbENvbnN0YW50Q29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIEZpbGVMZXZlbENvbnN0YW50Q29udGV4dCk7XG4gICAgfVxuICB9XG4gIGN1c3RvbUVycm9yRGVmaW5pdGlvbihpKSB7XG4gICAgaWYgKGkgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHRzKEN1c3RvbUVycm9yRGVmaW5pdGlvbkNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dChpLCBDdXN0b21FcnJvckRlZmluaXRpb25Db250ZXh0KTtcbiAgICB9XG4gIH1cbiAgdHlwZURlZmluaXRpb24oaSkge1xuICAgIGlmIChpID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0cyhUeXBlRGVmaW5pdGlvbkNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dChpLCBUeXBlRGVmaW5pdGlvbkNvbnRleHQpO1xuICAgIH1cbiAgfVxuICB1c2luZ0ZvckRlY2xhcmF0aW9uKGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dHMoVXNpbmdGb3JEZWNsYXJhdGlvbkNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dChpLCBVc2luZ0ZvckRlY2xhcmF0aW9uQ29udGV4dCk7XG4gICAgfVxuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9zb3VyY2VVbml0O1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlclNvdXJjZVVuaXQpIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyU291cmNlVW5pdCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdFNvdXJjZVVuaXQpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRTb3VyY2VVbml0KHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0U291cmNlVW5pdCkge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTb3VyY2VVbml0KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBQcmFnbWFEaXJlY3RpdmVDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBwcmFnbWFOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KDAsIFByYWdtYU5hbWVDb250ZXh0KTtcbiAgfVxuICBwcmFnbWFWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBQcmFnbWFWYWx1ZUNvbnRleHQpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9wcmFnbWFEaXJlY3RpdmU7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyUHJhZ21hRGlyZWN0aXZlKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlclByYWdtYURpcmVjdGl2ZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdFByYWdtYURpcmVjdGl2ZSkge1xuICAgICAgbGlzdGVuZXIuZXhpdFByYWdtYURpcmVjdGl2ZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdFByYWdtYURpcmVjdGl2ZSkge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQcmFnbWFEaXJlY3RpdmUodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIFByYWdtYU5hbWVDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBpZGVudGlmaWVyKCkge1xuICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KDAsIElkZW50aWZpZXJDb250ZXh0KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfcHJhZ21hTmFtZTtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJQcmFnbWFOYW1lKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlclByYWdtYU5hbWUodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRQcmFnbWFOYW1lKSB7XG4gICAgICBsaXN0ZW5lci5leGl0UHJhZ21hTmFtZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdFByYWdtYU5hbWUpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UHJhZ21hTmFtZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgUHJhZ21hVmFsdWVDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICB2ZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIFZlcnNpb25Db250ZXh0KTtcbiAgfVxuICBleHByZXNzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIEV4cHJlc3Npb25Db250ZXh0KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfcHJhZ21hVmFsdWU7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyUHJhZ21hVmFsdWUpIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyUHJhZ21hVmFsdWUodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRQcmFnbWFWYWx1ZSkge1xuICAgICAgbGlzdGVuZXIuZXhpdFByYWdtYVZhbHVlKHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0UHJhZ21hVmFsdWUpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UHJhZ21hVmFsdWUodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIFZlcnNpb25Db250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICB2ZXJzaW9uQ29uc3RyYWludChpKSB7XG4gICAgaWYgKGkgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHRzKFZlcnNpb25Db25zdHJhaW50Q29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIFZlcnNpb25Db25zdHJhaW50Q29udGV4dCk7XG4gICAgfVxuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV92ZXJzaW9uO1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlclZlcnNpb24pIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyVmVyc2lvbih0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdFZlcnNpb24pIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRWZXJzaW9uKHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0VmVyc2lvbikge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRWZXJzaW9uKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBWZXJzaW9uT3BlcmF0b3JDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfdmVyc2lvbk9wZXJhdG9yO1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlclZlcnNpb25PcGVyYXRvcikge1xuICAgICAgbGlzdGVuZXIuZW50ZXJWZXJzaW9uT3BlcmF0b3IodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRWZXJzaW9uT3BlcmF0b3IpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRWZXJzaW9uT3BlcmF0b3IodGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRWZXJzaW9uT3BlcmF0b3IpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VmVyc2lvbk9wZXJhdG9yKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBWZXJzaW9uQ29uc3RyYWludENvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIFZlcnNpb25MaXRlcmFsKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFRva2VuKFNvbGlkaXR5UGFyc2VyLlZlcnNpb25MaXRlcmFsLCAwKTtcbiAgfVxuICB2ZXJzaW9uT3BlcmF0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgVmVyc2lvbk9wZXJhdG9yQ29udGV4dCk7XG4gIH1cbiAgRGVjaW1hbE51bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTb2xpZGl0eVBhcnNlci5EZWNpbWFsTnVtYmVyLCAwKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfdmVyc2lvbkNvbnN0cmFpbnQ7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyVmVyc2lvbkNvbnN0cmFpbnQpIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyVmVyc2lvbkNvbnN0cmFpbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRWZXJzaW9uQ29uc3RyYWludCkge1xuICAgICAgbGlzdGVuZXIuZXhpdFZlcnNpb25Db25zdHJhaW50KHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0VmVyc2lvbkNvbnN0cmFpbnQpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VmVyc2lvbkNvbnN0cmFpbnQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIEltcG9ydERlY2xhcmF0aW9uQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgaWRlbnRpZmllcihpKSB7XG4gICAgaWYgKGkgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHRzKElkZW50aWZpZXJDb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoaSwgSWRlbnRpZmllckNvbnRleHQpO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfaW1wb3J0RGVjbGFyYXRpb247XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVySW1wb3J0RGVjbGFyYXRpb24pIHtcbiAgICAgIGxpc3RlbmVyLmVudGVySW1wb3J0RGVjbGFyYXRpb24odGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRJbXBvcnREZWNsYXJhdGlvbikge1xuICAgICAgbGlzdGVuZXIuZXhpdEltcG9ydERlY2xhcmF0aW9uKHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0SW1wb3J0RGVjbGFyYXRpb24pIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW1wb3J0RGVjbGFyYXRpb24odGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIEltcG9ydERpcmVjdGl2ZUNvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGltcG9ydFBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgSW1wb3J0UGF0aENvbnRleHQpO1xuICB9XG4gIGlkZW50aWZpZXIoaSkge1xuICAgIGlmIChpID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0cyhJZGVudGlmaWVyQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIElkZW50aWZpZXJDb250ZXh0KTtcbiAgICB9XG4gIH1cbiAgaW1wb3J0RGVjbGFyYXRpb24oaSkge1xuICAgIGlmIChpID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0cyhJbXBvcnREZWNsYXJhdGlvbkNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dChpLCBJbXBvcnREZWNsYXJhdGlvbkNvbnRleHQpO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfaW1wb3J0RGlyZWN0aXZlO1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlckltcG9ydERpcmVjdGl2ZSkge1xuICAgICAgbGlzdGVuZXIuZW50ZXJJbXBvcnREaXJlY3RpdmUodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRJbXBvcnREaXJlY3RpdmUpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRJbXBvcnREaXJlY3RpdmUodGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRJbXBvcnREaXJlY3RpdmUpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW1wb3J0RGlyZWN0aXZlKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBJbXBvcnRQYXRoQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgU3RyaW5nTGl0ZXJhbEZyYWdtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmdldFRva2VuKFNvbGlkaXR5UGFyc2VyLlN0cmluZ0xpdGVyYWxGcmFnbWVudCwgMCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX2ltcG9ydFBhdGg7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVySW1wb3J0UGF0aCkge1xuICAgICAgbGlzdGVuZXIuZW50ZXJJbXBvcnRQYXRoKHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0SW1wb3J0UGF0aCkge1xuICAgICAgbGlzdGVuZXIuZXhpdEltcG9ydFBhdGgodGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRJbXBvcnRQYXRoKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdEltcG9ydFBhdGgodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIENvbnRyYWN0RGVmaW5pdGlvbkNvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGlkZW50aWZpZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgSWRlbnRpZmllckNvbnRleHQpO1xuICB9XG4gIGluaGVyaXRhbmNlU3BlY2lmaWVyKGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dHMoSW5oZXJpdGFuY2VTcGVjaWZpZXJDb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoaSwgSW5oZXJpdGFuY2VTcGVjaWZpZXJDb250ZXh0KTtcbiAgICB9XG4gIH1cbiAgY29udHJhY3RQYXJ0KGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dHMoQ29udHJhY3RQYXJ0Q29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIENvbnRyYWN0UGFydENvbnRleHQpO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfY29udHJhY3REZWZpbml0aW9uO1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlckNvbnRyYWN0RGVmaW5pdGlvbikge1xuICAgICAgbGlzdGVuZXIuZW50ZXJDb250cmFjdERlZmluaXRpb24odGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRDb250cmFjdERlZmluaXRpb24pIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRDb250cmFjdERlZmluaXRpb24odGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRDb250cmFjdERlZmluaXRpb24pIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29udHJhY3REZWZpbml0aW9uKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBJbmhlcml0YW5jZVNwZWNpZmllckNvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIHVzZXJEZWZpbmVkVHlwZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgVXNlckRlZmluZWRUeXBlTmFtZUNvbnRleHQpO1xuICB9XG4gIGV4cHJlc3Npb25MaXN0KCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIEV4cHJlc3Npb25MaXN0Q29udGV4dCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX2luaGVyaXRhbmNlU3BlY2lmaWVyO1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlckluaGVyaXRhbmNlU3BlY2lmaWVyKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlckluaGVyaXRhbmNlU3BlY2lmaWVyKHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0SW5oZXJpdGFuY2VTcGVjaWZpZXIpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRJbmhlcml0YW5jZVNwZWNpZmllcih0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdEluaGVyaXRhbmNlU3BlY2lmaWVyKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdEluaGVyaXRhbmNlU3BlY2lmaWVyKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBDb250cmFjdFBhcnRDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBzdGF0ZVZhcmlhYmxlRGVjbGFyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgU3RhdGVWYXJpYWJsZURlY2xhcmF0aW9uQ29udGV4dCk7XG4gIH1cbiAgdXNpbmdGb3JEZWNsYXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBVc2luZ0ZvckRlY2xhcmF0aW9uQ29udGV4dCk7XG4gIH1cbiAgc3RydWN0RGVmaW5pdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBTdHJ1Y3REZWZpbml0aW9uQ29udGV4dCk7XG4gIH1cbiAgbW9kaWZpZXJEZWZpbml0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIE1vZGlmaWVyRGVmaW5pdGlvbkNvbnRleHQpO1xuICB9XG4gIGZ1bmN0aW9uRGVmaW5pdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBGdW5jdGlvbkRlZmluaXRpb25Db250ZXh0KTtcbiAgfVxuICBldmVudERlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgRXZlbnREZWZpbml0aW9uQ29udGV4dCk7XG4gIH1cbiAgZW51bURlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgRW51bURlZmluaXRpb25Db250ZXh0KTtcbiAgfVxuICBjdXN0b21FcnJvckRlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgQ3VzdG9tRXJyb3JEZWZpbml0aW9uQ29udGV4dCk7XG4gIH1cbiAgdHlwZURlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgVHlwZURlZmluaXRpb25Db250ZXh0KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfY29udHJhY3RQYXJ0O1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlckNvbnRyYWN0UGFydCkge1xuICAgICAgbGlzdGVuZXIuZW50ZXJDb250cmFjdFBhcnQodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRDb250cmFjdFBhcnQpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRDb250cmFjdFBhcnQodGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRDb250cmFjdFBhcnQpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29udHJhY3RQYXJ0KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBTdGF0ZVZhcmlhYmxlRGVjbGFyYXRpb25Db250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICB0eXBlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBUeXBlTmFtZUNvbnRleHQpO1xuICB9XG4gIGlkZW50aWZpZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgSWRlbnRpZmllckNvbnRleHQpO1xuICB9XG4gIFB1YmxpY0tleXdvcmQoaSkge1xuICAgIGlmIChpID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRva2VucyhTb2xpZGl0eVBhcnNlci5QdWJsaWNLZXl3b3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4oU29saWRpdHlQYXJzZXIuUHVibGljS2V5d29yZCwgaSk7XG4gICAgfVxuICB9XG4gIEludGVybmFsS2V5d29yZChpKSB7XG4gICAgaWYgKGkgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5zKFNvbGlkaXR5UGFyc2VyLkludGVybmFsS2V5d29yZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRva2VuKFNvbGlkaXR5UGFyc2VyLkludGVybmFsS2V5d29yZCwgaSk7XG4gICAgfVxuICB9XG4gIFByaXZhdGVLZXl3b3JkKGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbnMoU29saWRpdHlQYXJzZXIuUHJpdmF0ZUtleXdvcmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihTb2xpZGl0eVBhcnNlci5Qcml2YXRlS2V5d29yZCwgaSk7XG4gICAgfVxuICB9XG4gIENvbnN0YW50S2V5d29yZChpKSB7XG4gICAgaWYgKGkgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5zKFNvbGlkaXR5UGFyc2VyLkNvbnN0YW50S2V5d29yZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRva2VuKFNvbGlkaXR5UGFyc2VyLkNvbnN0YW50S2V5d29yZCwgaSk7XG4gICAgfVxuICB9XG4gIEltbXV0YWJsZUtleXdvcmQoaSkge1xuICAgIGlmIChpID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRva2VucyhTb2xpZGl0eVBhcnNlci5JbW11dGFibGVLZXl3b3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4oU29saWRpdHlQYXJzZXIuSW1tdXRhYmxlS2V5d29yZCwgaSk7XG4gICAgfVxuICB9XG4gIG92ZXJyaWRlU3BlY2lmaWVyKGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dHMoT3ZlcnJpZGVTcGVjaWZpZXJDb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoaSwgT3ZlcnJpZGVTcGVjaWZpZXJDb250ZXh0KTtcbiAgICB9XG4gIH1cbiAgZXhwcmVzc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBFeHByZXNzaW9uQ29udGV4dCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX3N0YXRlVmFyaWFibGVEZWNsYXJhdGlvbjtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJTdGF0ZVZhcmlhYmxlRGVjbGFyYXRpb24pIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyU3RhdGVWYXJpYWJsZURlY2xhcmF0aW9uKHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0U3RhdGVWYXJpYWJsZURlY2xhcmF0aW9uKSB7XG4gICAgICBsaXN0ZW5lci5leGl0U3RhdGVWYXJpYWJsZURlY2xhcmF0aW9uKHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0U3RhdGVWYXJpYWJsZURlY2xhcmF0aW9uKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdFN0YXRlVmFyaWFibGVEZWNsYXJhdGlvbih0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgRmlsZUxldmVsQ29uc3RhbnRDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICB0eXBlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBUeXBlTmFtZUNvbnRleHQpO1xuICB9XG4gIENvbnN0YW50S2V5d29yZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihTb2xpZGl0eVBhcnNlci5Db25zdGFudEtleXdvcmQsIDApO1xuICB9XG4gIGlkZW50aWZpZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgSWRlbnRpZmllckNvbnRleHQpO1xuICB9XG4gIGV4cHJlc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgRXhwcmVzc2lvbkNvbnRleHQpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9maWxlTGV2ZWxDb25zdGFudDtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJGaWxlTGV2ZWxDb25zdGFudCkge1xuICAgICAgbGlzdGVuZXIuZW50ZXJGaWxlTGV2ZWxDb25zdGFudCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdEZpbGVMZXZlbENvbnN0YW50KSB7XG4gICAgICBsaXN0ZW5lci5leGl0RmlsZUxldmVsQ29uc3RhbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRGaWxlTGV2ZWxDb25zdGFudCkge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRGaWxlTGV2ZWxDb25zdGFudCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgQ3VzdG9tRXJyb3JEZWZpbml0aW9uQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBJZGVudGlmaWVyQ29udGV4dCk7XG4gIH1cbiAgcGFyYW1ldGVyTGlzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBQYXJhbWV0ZXJMaXN0Q29udGV4dCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX2N1c3RvbUVycm9yRGVmaW5pdGlvbjtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJDdXN0b21FcnJvckRlZmluaXRpb24pIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyQ3VzdG9tRXJyb3JEZWZpbml0aW9uKHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0Q3VzdG9tRXJyb3JEZWZpbml0aW9uKSB7XG4gICAgICBsaXN0ZW5lci5leGl0Q3VzdG9tRXJyb3JEZWZpbml0aW9uKHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0Q3VzdG9tRXJyb3JEZWZpbml0aW9uKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdEN1c3RvbUVycm9yRGVmaW5pdGlvbih0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgVHlwZURlZmluaXRpb25Db250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBUeXBlS2V5d29yZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihTb2xpZGl0eVBhcnNlci5UeXBlS2V5d29yZCwgMCk7XG4gIH1cbiAgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBJZGVudGlmaWVyQ29udGV4dCk7XG4gIH1cbiAgZWxlbWVudGFyeVR5cGVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KDAsIEVsZW1lbnRhcnlUeXBlTmFtZUNvbnRleHQpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV90eXBlRGVmaW5pdGlvbjtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJUeXBlRGVmaW5pdGlvbikge1xuICAgICAgbGlzdGVuZXIuZW50ZXJUeXBlRGVmaW5pdGlvbih0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdFR5cGVEZWZpbml0aW9uKSB7XG4gICAgICBsaXN0ZW5lci5leGl0VHlwZURlZmluaXRpb24odGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRUeXBlRGVmaW5pdGlvbikge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUeXBlRGVmaW5pdGlvbih0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgVXNpbmdGb3JEZWNsYXJhdGlvbkNvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIHVzaW5nRm9yT2JqZWN0KCkge1xuICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KDAsIFVzaW5nRm9yT2JqZWN0Q29udGV4dCk7XG4gIH1cbiAgdHlwZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgVHlwZU5hbWVDb250ZXh0KTtcbiAgfVxuICBHbG9iYWxLZXl3b3JkKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFRva2VuKFNvbGlkaXR5UGFyc2VyLkdsb2JhbEtleXdvcmQsIDApO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV91c2luZ0ZvckRlY2xhcmF0aW9uO1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlclVzaW5nRm9yRGVjbGFyYXRpb24pIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyVXNpbmdGb3JEZWNsYXJhdGlvbih0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdFVzaW5nRm9yRGVjbGFyYXRpb24pIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRVc2luZ0ZvckRlY2xhcmF0aW9uKHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0VXNpbmdGb3JEZWNsYXJhdGlvbikge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRVc2luZ0ZvckRlY2xhcmF0aW9uKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBVc2luZ0Zvck9iamVjdENvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIHVzZXJEZWZpbmVkVHlwZU5hbWUoaSkge1xuICAgIGlmIChpID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0cyhVc2VyRGVmaW5lZFR5cGVOYW1lQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIFVzZXJEZWZpbmVkVHlwZU5hbWVDb250ZXh0KTtcbiAgICB9XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX3VzaW5nRm9yT2JqZWN0O1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlclVzaW5nRm9yT2JqZWN0KSB7XG4gICAgICBsaXN0ZW5lci5lbnRlclVzaW5nRm9yT2JqZWN0KHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0VXNpbmdGb3JPYmplY3QpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRVc2luZ0Zvck9iamVjdCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdFVzaW5nRm9yT2JqZWN0KSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdFVzaW5nRm9yT2JqZWN0KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBTdHJ1Y3REZWZpbml0aW9uQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBJZGVudGlmaWVyQ29udGV4dCk7XG4gIH1cbiAgdmFyaWFibGVEZWNsYXJhdGlvbihpKSB7XG4gICAgaWYgKGkgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHRzKFZhcmlhYmxlRGVjbGFyYXRpb25Db250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoaSwgVmFyaWFibGVEZWNsYXJhdGlvbkNvbnRleHQpO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfc3RydWN0RGVmaW5pdGlvbjtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJTdHJ1Y3REZWZpbml0aW9uKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlclN0cnVjdERlZmluaXRpb24odGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRTdHJ1Y3REZWZpbml0aW9uKSB7XG4gICAgICBsaXN0ZW5lci5leGl0U3RydWN0RGVmaW5pdGlvbih0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdFN0cnVjdERlZmluaXRpb24pIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U3RydWN0RGVmaW5pdGlvbih0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgTW9kaWZpZXJEZWZpbml0aW9uQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBJZGVudGlmaWVyQ29udGV4dCk7XG4gIH1cbiAgYmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgQmxvY2tDb250ZXh0KTtcbiAgfVxuICBwYXJhbWV0ZXJMaXN0KCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIFBhcmFtZXRlckxpc3RDb250ZXh0KTtcbiAgfVxuICBWaXJ0dWFsS2V5d29yZChpKSB7XG4gICAgaWYgKGkgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5zKFNvbGlkaXR5UGFyc2VyLlZpcnR1YWxLZXl3b3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4oU29saWRpdHlQYXJzZXIuVmlydHVhbEtleXdvcmQsIGkpO1xuICAgIH1cbiAgfVxuICBvdmVycmlkZVNwZWNpZmllcihpKSB7XG4gICAgaWYgKGkgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHRzKE92ZXJyaWRlU3BlY2lmaWVyQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIE92ZXJyaWRlU3BlY2lmaWVyQ29udGV4dCk7XG4gICAgfVxuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9tb2RpZmllckRlZmluaXRpb247XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyTW9kaWZpZXJEZWZpbml0aW9uKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlck1vZGlmaWVyRGVmaW5pdGlvbih0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdE1vZGlmaWVyRGVmaW5pdGlvbikge1xuICAgICAgbGlzdGVuZXIuZXhpdE1vZGlmaWVyRGVmaW5pdGlvbih0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdE1vZGlmaWVyRGVmaW5pdGlvbikge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRNb2RpZmllckRlZmluaXRpb24odGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIE1vZGlmaWVySW52b2NhdGlvbkNvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGlkZW50aWZpZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgSWRlbnRpZmllckNvbnRleHQpO1xuICB9XG4gIGV4cHJlc3Npb25MaXN0KCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIEV4cHJlc3Npb25MaXN0Q29udGV4dCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX21vZGlmaWVySW52b2NhdGlvbjtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJNb2RpZmllckludm9jYXRpb24pIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyTW9kaWZpZXJJbnZvY2F0aW9uKHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0TW9kaWZpZXJJbnZvY2F0aW9uKSB7XG4gICAgICBsaXN0ZW5lci5leGl0TW9kaWZpZXJJbnZvY2F0aW9uKHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0TW9kaWZpZXJJbnZvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdE1vZGlmaWVySW52b2NhdGlvbih0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgRnVuY3Rpb25EZWZpbml0aW9uQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgZnVuY3Rpb25EZXNjcmlwdG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KDAsIEZ1bmN0aW9uRGVzY3JpcHRvckNvbnRleHQpO1xuICB9XG4gIHBhcmFtZXRlckxpc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgUGFyYW1ldGVyTGlzdENvbnRleHQpO1xuICB9XG4gIG1vZGlmaWVyTGlzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBNb2RpZmllckxpc3RDb250ZXh0KTtcbiAgfVxuICBibG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBCbG9ja0NvbnRleHQpO1xuICB9XG4gIHJldHVyblBhcmFtZXRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgUmV0dXJuUGFyYW1ldGVyc0NvbnRleHQpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9mdW5jdGlvbkRlZmluaXRpb247XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyRnVuY3Rpb25EZWZpbml0aW9uKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlckZ1bmN0aW9uRGVmaW5pdGlvbih0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdEZ1bmN0aW9uRGVmaW5pdGlvbikge1xuICAgICAgbGlzdGVuZXIuZXhpdEZ1bmN0aW9uRGVmaW5pdGlvbih0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdEZ1bmN0aW9uRGVmaW5pdGlvbikge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRGdW5jdGlvbkRlZmluaXRpb24odGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIEZ1bmN0aW9uRGVzY3JpcHRvckNvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGlkZW50aWZpZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgSWRlbnRpZmllckNvbnRleHQpO1xuICB9XG4gIENvbnN0cnVjdG9yS2V5d29yZCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTb2xpZGl0eVBhcnNlci5Db25zdHJ1Y3RvcktleXdvcmQsIDApO1xuICB9XG4gIEZhbGxiYWNrS2V5d29yZCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTb2xpZGl0eVBhcnNlci5GYWxsYmFja0tleXdvcmQsIDApO1xuICB9XG4gIFJlY2VpdmVLZXl3b3JkKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFRva2VuKFNvbGlkaXR5UGFyc2VyLlJlY2VpdmVLZXl3b3JkLCAwKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfZnVuY3Rpb25EZXNjcmlwdG9yO1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlckZ1bmN0aW9uRGVzY3JpcHRvcikge1xuICAgICAgbGlzdGVuZXIuZW50ZXJGdW5jdGlvbkRlc2NyaXB0b3IodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRGdW5jdGlvbkRlc2NyaXB0b3IpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRGdW5jdGlvbkRlc2NyaXB0b3IodGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRGdW5jdGlvbkRlc2NyaXB0b3IpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RnVuY3Rpb25EZXNjcmlwdG9yKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBSZXR1cm5QYXJhbWV0ZXJzQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgcGFyYW1ldGVyTGlzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBQYXJhbWV0ZXJMaXN0Q29udGV4dCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX3JldHVyblBhcmFtZXRlcnM7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyUmV0dXJuUGFyYW1ldGVycykge1xuICAgICAgbGlzdGVuZXIuZW50ZXJSZXR1cm5QYXJhbWV0ZXJzKHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0UmV0dXJuUGFyYW1ldGVycykge1xuICAgICAgbGlzdGVuZXIuZXhpdFJldHVyblBhcmFtZXRlcnModGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRSZXR1cm5QYXJhbWV0ZXJzKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJldHVyblBhcmFtZXRlcnModGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIE1vZGlmaWVyTGlzdENvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIEV4dGVybmFsS2V5d29yZChpKSB7XG4gICAgaWYgKGkgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5zKFNvbGlkaXR5UGFyc2VyLkV4dGVybmFsS2V5d29yZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRva2VuKFNvbGlkaXR5UGFyc2VyLkV4dGVybmFsS2V5d29yZCwgaSk7XG4gICAgfVxuICB9XG4gIFB1YmxpY0tleXdvcmQoaSkge1xuICAgIGlmIChpID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRva2VucyhTb2xpZGl0eVBhcnNlci5QdWJsaWNLZXl3b3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4oU29saWRpdHlQYXJzZXIuUHVibGljS2V5d29yZCwgaSk7XG4gICAgfVxuICB9XG4gIEludGVybmFsS2V5d29yZChpKSB7XG4gICAgaWYgKGkgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5zKFNvbGlkaXR5UGFyc2VyLkludGVybmFsS2V5d29yZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRva2VuKFNvbGlkaXR5UGFyc2VyLkludGVybmFsS2V5d29yZCwgaSk7XG4gICAgfVxuICB9XG4gIFByaXZhdGVLZXl3b3JkKGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbnMoU29saWRpdHlQYXJzZXIuUHJpdmF0ZUtleXdvcmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihTb2xpZGl0eVBhcnNlci5Qcml2YXRlS2V5d29yZCwgaSk7XG4gICAgfVxuICB9XG4gIFZpcnR1YWxLZXl3b3JkKGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbnMoU29saWRpdHlQYXJzZXIuVmlydHVhbEtleXdvcmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihTb2xpZGl0eVBhcnNlci5WaXJ0dWFsS2V5d29yZCwgaSk7XG4gICAgfVxuICB9XG4gIHN0YXRlTXV0YWJpbGl0eShpKSB7XG4gICAgaWYgKGkgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHRzKFN0YXRlTXV0YWJpbGl0eUNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dChpLCBTdGF0ZU11dGFiaWxpdHlDb250ZXh0KTtcbiAgICB9XG4gIH1cbiAgbW9kaWZpZXJJbnZvY2F0aW9uKGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dHMoTW9kaWZpZXJJbnZvY2F0aW9uQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIE1vZGlmaWVySW52b2NhdGlvbkNvbnRleHQpO1xuICAgIH1cbiAgfVxuICBvdmVycmlkZVNwZWNpZmllcihpKSB7XG4gICAgaWYgKGkgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHRzKE92ZXJyaWRlU3BlY2lmaWVyQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIE92ZXJyaWRlU3BlY2lmaWVyQ29udGV4dCk7XG4gICAgfVxuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9tb2RpZmllckxpc3Q7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyTW9kaWZpZXJMaXN0KSB7XG4gICAgICBsaXN0ZW5lci5lbnRlck1vZGlmaWVyTGlzdCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdE1vZGlmaWVyTGlzdCkge1xuICAgICAgbGlzdGVuZXIuZXhpdE1vZGlmaWVyTGlzdCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdE1vZGlmaWVyTGlzdCkge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRNb2RpZmllckxpc3QodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIEV2ZW50RGVmaW5pdGlvbkNvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGlkZW50aWZpZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgSWRlbnRpZmllckNvbnRleHQpO1xuICB9XG4gIGV2ZW50UGFyYW1ldGVyTGlzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBFdmVudFBhcmFtZXRlckxpc3RDb250ZXh0KTtcbiAgfVxuICBBbm9ueW1vdXNLZXl3b3JkKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFRva2VuKFNvbGlkaXR5UGFyc2VyLkFub255bW91c0tleXdvcmQsIDApO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9ldmVudERlZmluaXRpb247XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyRXZlbnREZWZpbml0aW9uKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlckV2ZW50RGVmaW5pdGlvbih0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdEV2ZW50RGVmaW5pdGlvbikge1xuICAgICAgbGlzdGVuZXIuZXhpdEV2ZW50RGVmaW5pdGlvbih0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdEV2ZW50RGVmaW5pdGlvbikge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFdmVudERlZmluaXRpb24odGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIEVudW1WYWx1ZUNvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGlkZW50aWZpZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgSWRlbnRpZmllckNvbnRleHQpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9lbnVtVmFsdWU7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyRW51bVZhbHVlKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlckVudW1WYWx1ZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdEVudW1WYWx1ZSkge1xuICAgICAgbGlzdGVuZXIuZXhpdEVudW1WYWx1ZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdEVudW1WYWx1ZSkge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFbnVtVmFsdWUodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIEVudW1EZWZpbml0aW9uQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBJZGVudGlmaWVyQ29udGV4dCk7XG4gIH1cbiAgZW51bVZhbHVlKGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dHMoRW51bVZhbHVlQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIEVudW1WYWx1ZUNvbnRleHQpO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfZW51bURlZmluaXRpb247XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyRW51bURlZmluaXRpb24pIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyRW51bURlZmluaXRpb24odGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRFbnVtRGVmaW5pdGlvbikge1xuICAgICAgbGlzdGVuZXIuZXhpdEVudW1EZWZpbml0aW9uKHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0RW51bURlZmluaXRpb24pIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RW51bURlZmluaXRpb24odGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIFBhcmFtZXRlckxpc3RDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBwYXJhbWV0ZXIoaSkge1xuICAgIGlmIChpID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0cyhQYXJhbWV0ZXJDb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoaSwgUGFyYW1ldGVyQ29udGV4dCk7XG4gICAgfVxuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9wYXJhbWV0ZXJMaXN0O1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlclBhcmFtZXRlckxpc3QpIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyUGFyYW1ldGVyTGlzdCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdFBhcmFtZXRlckxpc3QpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRQYXJhbWV0ZXJMaXN0KHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0UGFyYW1ldGVyTGlzdCkge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQYXJhbWV0ZXJMaXN0KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBQYXJhbWV0ZXJDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICB0eXBlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBUeXBlTmFtZUNvbnRleHQpO1xuICB9XG4gIHN0b3JhZ2VMb2NhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBTdG9yYWdlTG9jYXRpb25Db250ZXh0KTtcbiAgfVxuICBpZGVudGlmaWVyKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIElkZW50aWZpZXJDb250ZXh0KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfcGFyYW1ldGVyO1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlclBhcmFtZXRlcikge1xuICAgICAgbGlzdGVuZXIuZW50ZXJQYXJhbWV0ZXIodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRQYXJhbWV0ZXIpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRQYXJhbWV0ZXIodGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRQYXJhbWV0ZXIpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UGFyYW1ldGVyKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBFdmVudFBhcmFtZXRlckxpc3RDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBldmVudFBhcmFtZXRlcihpKSB7XG4gICAgaWYgKGkgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHRzKEV2ZW50UGFyYW1ldGVyQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIEV2ZW50UGFyYW1ldGVyQ29udGV4dCk7XG4gICAgfVxuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9ldmVudFBhcmFtZXRlckxpc3Q7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyRXZlbnRQYXJhbWV0ZXJMaXN0KSB7XG4gICAgICBsaXN0ZW5lci5lbnRlckV2ZW50UGFyYW1ldGVyTGlzdCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdEV2ZW50UGFyYW1ldGVyTGlzdCkge1xuICAgICAgbGlzdGVuZXIuZXhpdEV2ZW50UGFyYW1ldGVyTGlzdCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdEV2ZW50UGFyYW1ldGVyTGlzdCkge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFdmVudFBhcmFtZXRlckxpc3QodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIEV2ZW50UGFyYW1ldGVyQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgdHlwZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgVHlwZU5hbWVDb250ZXh0KTtcbiAgfVxuICBJbmRleGVkS2V5d29yZCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTb2xpZGl0eVBhcnNlci5JbmRleGVkS2V5d29yZCwgMCk7XG4gIH1cbiAgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBJZGVudGlmaWVyQ29udGV4dCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX2V2ZW50UGFyYW1ldGVyO1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlckV2ZW50UGFyYW1ldGVyKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlckV2ZW50UGFyYW1ldGVyKHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0RXZlbnRQYXJhbWV0ZXIpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRFdmVudFBhcmFtZXRlcih0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdEV2ZW50UGFyYW1ldGVyKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV2ZW50UGFyYW1ldGVyKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBGdW5jdGlvblR5cGVQYXJhbWV0ZXJMaXN0Q29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgZnVuY3Rpb25UeXBlUGFyYW1ldGVyKGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dHMoRnVuY3Rpb25UeXBlUGFyYW1ldGVyQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIEZ1bmN0aW9uVHlwZVBhcmFtZXRlckNvbnRleHQpO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfZnVuY3Rpb25UeXBlUGFyYW1ldGVyTGlzdDtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJGdW5jdGlvblR5cGVQYXJhbWV0ZXJMaXN0KSB7XG4gICAgICBsaXN0ZW5lci5lbnRlckZ1bmN0aW9uVHlwZVBhcmFtZXRlckxpc3QodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRGdW5jdGlvblR5cGVQYXJhbWV0ZXJMaXN0KSB7XG4gICAgICBsaXN0ZW5lci5leGl0RnVuY3Rpb25UeXBlUGFyYW1ldGVyTGlzdCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdEZ1bmN0aW9uVHlwZVBhcmFtZXRlckxpc3QpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RnVuY3Rpb25UeXBlUGFyYW1ldGVyTGlzdCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgRnVuY3Rpb25UeXBlUGFyYW1ldGVyQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgdHlwZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgVHlwZU5hbWVDb250ZXh0KTtcbiAgfVxuICBzdG9yYWdlTG9jYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgU3RvcmFnZUxvY2F0aW9uQ29udGV4dCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX2Z1bmN0aW9uVHlwZVBhcmFtZXRlcjtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJGdW5jdGlvblR5cGVQYXJhbWV0ZXIpIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyRnVuY3Rpb25UeXBlUGFyYW1ldGVyKHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0RnVuY3Rpb25UeXBlUGFyYW1ldGVyKSB7XG4gICAgICBsaXN0ZW5lci5leGl0RnVuY3Rpb25UeXBlUGFyYW1ldGVyKHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0RnVuY3Rpb25UeXBlUGFyYW1ldGVyKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdEZ1bmN0aW9uVHlwZVBhcmFtZXRlcih0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgVmFyaWFibGVEZWNsYXJhdGlvbkNvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIHR5cGVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KDAsIFR5cGVOYW1lQ29udGV4dCk7XG4gIH1cbiAgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBJZGVudGlmaWVyQ29udGV4dCk7XG4gIH1cbiAgc3RvcmFnZUxvY2F0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIFN0b3JhZ2VMb2NhdGlvbkNvbnRleHQpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV92YXJpYWJsZURlY2xhcmF0aW9uO1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlclZhcmlhYmxlRGVjbGFyYXRpb24pIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyVmFyaWFibGVEZWNsYXJhdGlvbih0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdFZhcmlhYmxlRGVjbGFyYXRpb24pIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRWYXJpYWJsZURlY2xhcmF0aW9uKHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0VmFyaWFibGVEZWNsYXJhdGlvbikge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRWYXJpYWJsZURlY2xhcmF0aW9uKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBUeXBlTmFtZUNvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGVsZW1lbnRhcnlUeXBlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBFbGVtZW50YXJ5VHlwZU5hbWVDb250ZXh0KTtcbiAgfVxuICB1c2VyRGVmaW5lZFR5cGVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIFVzZXJEZWZpbmVkVHlwZU5hbWVDb250ZXh0KTtcbiAgfVxuICBtYXBwaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIE1hcHBpbmdDb250ZXh0KTtcbiAgfVxuICB0eXBlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBUeXBlTmFtZUNvbnRleHQpO1xuICB9XG4gIGV4cHJlc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgRXhwcmVzc2lvbkNvbnRleHQpO1xuICB9XG4gIGZ1bmN0aW9uVHlwZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgRnVuY3Rpb25UeXBlTmFtZUNvbnRleHQpO1xuICB9XG4gIFBheWFibGVLZXl3b3JkKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFRva2VuKFNvbGlkaXR5UGFyc2VyLlBheWFibGVLZXl3b3JkLCAwKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfdHlwZU5hbWU7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyVHlwZU5hbWUpIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyVHlwZU5hbWUodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRUeXBlTmFtZSkge1xuICAgICAgbGlzdGVuZXIuZXhpdFR5cGVOYW1lKHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0VHlwZU5hbWUpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VHlwZU5hbWUodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIFVzZXJEZWZpbmVkVHlwZU5hbWVDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBpZGVudGlmaWVyKGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dHMoSWRlbnRpZmllckNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dChpLCBJZGVudGlmaWVyQ29udGV4dCk7XG4gICAgfVxuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV91c2VyRGVmaW5lZFR5cGVOYW1lO1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlclVzZXJEZWZpbmVkVHlwZU5hbWUpIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyVXNlckRlZmluZWRUeXBlTmFtZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdFVzZXJEZWZpbmVkVHlwZU5hbWUpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRVc2VyRGVmaW5lZFR5cGVOYW1lKHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0VXNlckRlZmluZWRUeXBlTmFtZSkge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRVc2VyRGVmaW5lZFR5cGVOYW1lKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBNYXBwaW5nS2V5Q29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgZWxlbWVudGFyeVR5cGVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIEVsZW1lbnRhcnlUeXBlTmFtZUNvbnRleHQpO1xuICB9XG4gIHVzZXJEZWZpbmVkVHlwZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgVXNlckRlZmluZWRUeXBlTmFtZUNvbnRleHQpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9tYXBwaW5nS2V5O1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlck1hcHBpbmdLZXkpIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyTWFwcGluZ0tleSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdE1hcHBpbmdLZXkpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRNYXBwaW5nS2V5KHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0TWFwcGluZ0tleSkge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRNYXBwaW5nS2V5KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBNYXBwaW5nQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgbWFwcGluZ0tleSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBNYXBwaW5nS2V5Q29udGV4dCk7XG4gIH1cbiAgdHlwZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgVHlwZU5hbWVDb250ZXh0KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfbWFwcGluZztcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJNYXBwaW5nKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlck1hcHBpbmcodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRNYXBwaW5nKSB7XG4gICAgICBsaXN0ZW5lci5leGl0TWFwcGluZyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdE1hcHBpbmcpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TWFwcGluZyh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgRnVuY3Rpb25UeXBlTmFtZUNvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGZ1bmN0aW9uVHlwZVBhcmFtZXRlckxpc3QoaSkge1xuICAgIGlmIChpID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0cyhGdW5jdGlvblR5cGVQYXJhbWV0ZXJMaXN0Q29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIEZ1bmN0aW9uVHlwZVBhcmFtZXRlckxpc3RDb250ZXh0KTtcbiAgICB9XG4gIH1cbiAgSW50ZXJuYWxLZXl3b3JkKGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbnMoU29saWRpdHlQYXJzZXIuSW50ZXJuYWxLZXl3b3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4oU29saWRpdHlQYXJzZXIuSW50ZXJuYWxLZXl3b3JkLCBpKTtcbiAgICB9XG4gIH1cbiAgRXh0ZXJuYWxLZXl3b3JkKGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbnMoU29saWRpdHlQYXJzZXIuRXh0ZXJuYWxLZXl3b3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4oU29saWRpdHlQYXJzZXIuRXh0ZXJuYWxLZXl3b3JkLCBpKTtcbiAgICB9XG4gIH1cbiAgc3RhdGVNdXRhYmlsaXR5KGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dHMoU3RhdGVNdXRhYmlsaXR5Q29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIFN0YXRlTXV0YWJpbGl0eUNvbnRleHQpO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfZnVuY3Rpb25UeXBlTmFtZTtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJGdW5jdGlvblR5cGVOYW1lKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlckZ1bmN0aW9uVHlwZU5hbWUodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRGdW5jdGlvblR5cGVOYW1lKSB7XG4gICAgICBsaXN0ZW5lci5leGl0RnVuY3Rpb25UeXBlTmFtZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdEZ1bmN0aW9uVHlwZU5hbWUpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RnVuY3Rpb25UeXBlTmFtZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgU3RvcmFnZUxvY2F0aW9uQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX3N0b3JhZ2VMb2NhdGlvbjtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJTdG9yYWdlTG9jYXRpb24pIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyU3RvcmFnZUxvY2F0aW9uKHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0U3RvcmFnZUxvY2F0aW9uKSB7XG4gICAgICBsaXN0ZW5lci5leGl0U3RvcmFnZUxvY2F0aW9uKHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0U3RvcmFnZUxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdFN0b3JhZ2VMb2NhdGlvbih0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgU3RhdGVNdXRhYmlsaXR5Q29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgUHVyZUtleXdvcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU29saWRpdHlQYXJzZXIuUHVyZUtleXdvcmQsIDApO1xuICB9XG4gIENvbnN0YW50S2V5d29yZCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTb2xpZGl0eVBhcnNlci5Db25zdGFudEtleXdvcmQsIDApO1xuICB9XG4gIFZpZXdLZXl3b3JkKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFRva2VuKFNvbGlkaXR5UGFyc2VyLlZpZXdLZXl3b3JkLCAwKTtcbiAgfVxuICBQYXlhYmxlS2V5d29yZCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTb2xpZGl0eVBhcnNlci5QYXlhYmxlS2V5d29yZCwgMCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX3N0YXRlTXV0YWJpbGl0eTtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJTdGF0ZU11dGFiaWxpdHkpIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyU3RhdGVNdXRhYmlsaXR5KHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0U3RhdGVNdXRhYmlsaXR5KSB7XG4gICAgICBsaXN0ZW5lci5leGl0U3RhdGVNdXRhYmlsaXR5KHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0U3RhdGVNdXRhYmlsaXR5KSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdFN0YXRlTXV0YWJpbGl0eSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgQmxvY2tDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBzdGF0ZW1lbnQoaSkge1xuICAgIGlmIChpID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0cyhTdGF0ZW1lbnRDb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoaSwgU3RhdGVtZW50Q29udGV4dCk7XG4gICAgfVxuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9ibG9jaztcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJCbG9jaykge1xuICAgICAgbGlzdGVuZXIuZW50ZXJCbG9jayh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdEJsb2NrKSB7XG4gICAgICBsaXN0ZW5lci5leGl0QmxvY2sodGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRCbG9jaykge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCbG9jayh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgU3RhdGVtZW50Q29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgaWZTdGF0ZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgSWZTdGF0ZW1lbnRDb250ZXh0KTtcbiAgfVxuICB0cnlTdGF0ZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgVHJ5U3RhdGVtZW50Q29udGV4dCk7XG4gIH1cbiAgd2hpbGVTdGF0ZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgV2hpbGVTdGF0ZW1lbnRDb250ZXh0KTtcbiAgfVxuICBmb3JTdGF0ZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgRm9yU3RhdGVtZW50Q29udGV4dCk7XG4gIH1cbiAgYmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgQmxvY2tDb250ZXh0KTtcbiAgfVxuICBpbmxpbmVBc3NlbWJseVN0YXRlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBJbmxpbmVBc3NlbWJseVN0YXRlbWVudENvbnRleHQpO1xuICB9XG4gIGRvV2hpbGVTdGF0ZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgRG9XaGlsZVN0YXRlbWVudENvbnRleHQpO1xuICB9XG4gIGNvbnRpbnVlU3RhdGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIENvbnRpbnVlU3RhdGVtZW50Q29udGV4dCk7XG4gIH1cbiAgYnJlYWtTdGF0ZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgQnJlYWtTdGF0ZW1lbnRDb250ZXh0KTtcbiAgfVxuICByZXR1cm5TdGF0ZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgUmV0dXJuU3RhdGVtZW50Q29udGV4dCk7XG4gIH1cbiAgdGhyb3dTdGF0ZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgVGhyb3dTdGF0ZW1lbnRDb250ZXh0KTtcbiAgfVxuICBlbWl0U3RhdGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIEVtaXRTdGF0ZW1lbnRDb250ZXh0KTtcbiAgfVxuICBzaW1wbGVTdGF0ZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgU2ltcGxlU3RhdGVtZW50Q29udGV4dCk7XG4gIH1cbiAgdW5jaGVja2VkU3RhdGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIFVuY2hlY2tlZFN0YXRlbWVudENvbnRleHQpO1xuICB9XG4gIHJldmVydFN0YXRlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBSZXZlcnRTdGF0ZW1lbnRDb250ZXh0KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfc3RhdGVtZW50O1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlclN0YXRlbWVudCkge1xuICAgICAgbGlzdGVuZXIuZW50ZXJTdGF0ZW1lbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRTdGF0ZW1lbnQpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRTdGF0ZW1lbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRTdGF0ZW1lbnQpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U3RhdGVtZW50KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBFeHByZXNzaW9uU3RhdGVtZW50Q29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgZXhwcmVzc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBFeHByZXNzaW9uQ29udGV4dCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX2V4cHJlc3Npb25TdGF0ZW1lbnQ7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyRXhwcmVzc2lvblN0YXRlbWVudCkge1xuICAgICAgbGlzdGVuZXIuZW50ZXJFeHByZXNzaW9uU3RhdGVtZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0RXhwcmVzc2lvblN0YXRlbWVudCkge1xuICAgICAgbGlzdGVuZXIuZXhpdEV4cHJlc3Npb25TdGF0ZW1lbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRFeHByZXNzaW9uU3RhdGVtZW50KSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4cHJlc3Npb25TdGF0ZW1lbnQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIElmU3RhdGVtZW50Q29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgZXhwcmVzc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBFeHByZXNzaW9uQ29udGV4dCk7XG4gIH1cbiAgc3RhdGVtZW50KGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dHMoU3RhdGVtZW50Q29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIFN0YXRlbWVudENvbnRleHQpO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfaWZTdGF0ZW1lbnQ7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVySWZTdGF0ZW1lbnQpIHtcbiAgICAgIGxpc3RlbmVyLmVudGVySWZTdGF0ZW1lbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRJZlN0YXRlbWVudCkge1xuICAgICAgbGlzdGVuZXIuZXhpdElmU3RhdGVtZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0SWZTdGF0ZW1lbnQpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SWZTdGF0ZW1lbnQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIFRyeVN0YXRlbWVudENvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGV4cHJlc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgRXhwcmVzc2lvbkNvbnRleHQpO1xuICB9XG4gIGJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KDAsIEJsb2NrQ29udGV4dCk7XG4gIH1cbiAgcmV0dXJuUGFyYW1ldGVycygpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBSZXR1cm5QYXJhbWV0ZXJzQ29udGV4dCk7XG4gIH1cbiAgY2F0Y2hDbGF1c2UoaSkge1xuICAgIGlmIChpID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0cyhDYXRjaENsYXVzZUNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dChpLCBDYXRjaENsYXVzZUNvbnRleHQpO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfdHJ5U3RhdGVtZW50O1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlclRyeVN0YXRlbWVudCkge1xuICAgICAgbGlzdGVuZXIuZW50ZXJUcnlTdGF0ZW1lbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRUcnlTdGF0ZW1lbnQpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRUcnlTdGF0ZW1lbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRUcnlTdGF0ZW1lbnQpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VHJ5U3RhdGVtZW50KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBDYXRjaENsYXVzZUNvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KDAsIEJsb2NrQ29udGV4dCk7XG4gIH1cbiAgcGFyYW1ldGVyTGlzdCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBQYXJhbWV0ZXJMaXN0Q29udGV4dCk7XG4gIH1cbiAgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBJZGVudGlmaWVyQ29udGV4dCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX2NhdGNoQ2xhdXNlO1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlckNhdGNoQ2xhdXNlKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlckNhdGNoQ2xhdXNlKHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0Q2F0Y2hDbGF1c2UpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRDYXRjaENsYXVzZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdENhdGNoQ2xhdXNlKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENhdGNoQ2xhdXNlKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBXaGlsZVN0YXRlbWVudENvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGV4cHJlc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgRXhwcmVzc2lvbkNvbnRleHQpO1xuICB9XG4gIHN0YXRlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBTdGF0ZW1lbnRDb250ZXh0KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfd2hpbGVTdGF0ZW1lbnQ7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyV2hpbGVTdGF0ZW1lbnQpIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyV2hpbGVTdGF0ZW1lbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRXaGlsZVN0YXRlbWVudCkge1xuICAgICAgbGlzdGVuZXIuZXhpdFdoaWxlU3RhdGVtZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0V2hpbGVTdGF0ZW1lbnQpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0V2hpbGVTdGF0ZW1lbnQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIFNpbXBsZVN0YXRlbWVudENvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIHZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudENvbnRleHQpO1xuICB9XG4gIGV4cHJlc3Npb25TdGF0ZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgRXhwcmVzc2lvblN0YXRlbWVudENvbnRleHQpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9zaW1wbGVTdGF0ZW1lbnQ7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyU2ltcGxlU3RhdGVtZW50KSB7XG4gICAgICBsaXN0ZW5lci5lbnRlclNpbXBsZVN0YXRlbWVudCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdFNpbXBsZVN0YXRlbWVudCkge1xuICAgICAgbGlzdGVuZXIuZXhpdFNpbXBsZVN0YXRlbWVudCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdFNpbXBsZVN0YXRlbWVudCkge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTaW1wbGVTdGF0ZW1lbnQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIFVuY2hlY2tlZFN0YXRlbWVudENvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KDAsIEJsb2NrQ29udGV4dCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX3VuY2hlY2tlZFN0YXRlbWVudDtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJVbmNoZWNrZWRTdGF0ZW1lbnQpIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyVW5jaGVja2VkU3RhdGVtZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0VW5jaGVja2VkU3RhdGVtZW50KSB7XG4gICAgICBsaXN0ZW5lci5leGl0VW5jaGVja2VkU3RhdGVtZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0VW5jaGVja2VkU3RhdGVtZW50KSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdFVuY2hlY2tlZFN0YXRlbWVudCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgRm9yU3RhdGVtZW50Q29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgc3RhdGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KDAsIFN0YXRlbWVudENvbnRleHQpO1xuICB9XG4gIHNpbXBsZVN0YXRlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBTaW1wbGVTdGF0ZW1lbnRDb250ZXh0KTtcbiAgfVxuICBleHByZXNzaW9uU3RhdGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIEV4cHJlc3Npb25TdGF0ZW1lbnRDb250ZXh0KTtcbiAgfVxuICBleHByZXNzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIEV4cHJlc3Npb25Db250ZXh0KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfZm9yU3RhdGVtZW50O1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlckZvclN0YXRlbWVudCkge1xuICAgICAgbGlzdGVuZXIuZW50ZXJGb3JTdGF0ZW1lbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRGb3JTdGF0ZW1lbnQpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRGb3JTdGF0ZW1lbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRGb3JTdGF0ZW1lbnQpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Rm9yU3RhdGVtZW50KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBJbmxpbmVBc3NlbWJseVN0YXRlbWVudENvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGFzc2VtYmx5QmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgQXNzZW1ibHlCbG9ja0NvbnRleHQpO1xuICB9XG4gIFN0cmluZ0xpdGVyYWxGcmFnbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTb2xpZGl0eVBhcnNlci5TdHJpbmdMaXRlcmFsRnJhZ21lbnQsIDApO1xuICB9XG4gIGlubGluZUFzc2VtYmx5U3RhdGVtZW50RmxhZygpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBJbmxpbmVBc3NlbWJseVN0YXRlbWVudEZsYWdDb250ZXh0KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfaW5saW5lQXNzZW1ibHlTdGF0ZW1lbnQ7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVySW5saW5lQXNzZW1ibHlTdGF0ZW1lbnQpIHtcbiAgICAgIGxpc3RlbmVyLmVudGVySW5saW5lQXNzZW1ibHlTdGF0ZW1lbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRJbmxpbmVBc3NlbWJseVN0YXRlbWVudCkge1xuICAgICAgbGlzdGVuZXIuZXhpdElubGluZUFzc2VtYmx5U3RhdGVtZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0SW5saW5lQXNzZW1ibHlTdGF0ZW1lbnQpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW5saW5lQXNzZW1ibHlTdGF0ZW1lbnQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIElubGluZUFzc2VtYmx5U3RhdGVtZW50RmxhZ0NvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIHN0cmluZ0xpdGVyYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgU3RyaW5nTGl0ZXJhbENvbnRleHQpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9pbmxpbmVBc3NlbWJseVN0YXRlbWVudEZsYWc7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVySW5saW5lQXNzZW1ibHlTdGF0ZW1lbnRGbGFnKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlcklubGluZUFzc2VtYmx5U3RhdGVtZW50RmxhZyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdElubGluZUFzc2VtYmx5U3RhdGVtZW50RmxhZykge1xuICAgICAgbGlzdGVuZXIuZXhpdElubGluZUFzc2VtYmx5U3RhdGVtZW50RmxhZyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdElubGluZUFzc2VtYmx5U3RhdGVtZW50RmxhZykge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbmxpbmVBc3NlbWJseVN0YXRlbWVudEZsYWcodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIERvV2hpbGVTdGF0ZW1lbnRDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBzdGF0ZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgU3RhdGVtZW50Q29udGV4dCk7XG4gIH1cbiAgZXhwcmVzc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBFeHByZXNzaW9uQ29udGV4dCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX2RvV2hpbGVTdGF0ZW1lbnQ7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyRG9XaGlsZVN0YXRlbWVudCkge1xuICAgICAgbGlzdGVuZXIuZW50ZXJEb1doaWxlU3RhdGVtZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0RG9XaGlsZVN0YXRlbWVudCkge1xuICAgICAgbGlzdGVuZXIuZXhpdERvV2hpbGVTdGF0ZW1lbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXREb1doaWxlU3RhdGVtZW50KSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdERvV2hpbGVTdGF0ZW1lbnQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIENvbnRpbnVlU3RhdGVtZW50Q29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgQ29udGludWVLZXl3b3JkKCkge1xuICAgIHJldHVybiB0aGlzLmdldFRva2VuKFNvbGlkaXR5UGFyc2VyLkNvbnRpbnVlS2V5d29yZCwgMCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX2NvbnRpbnVlU3RhdGVtZW50O1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlckNvbnRpbnVlU3RhdGVtZW50KSB7XG4gICAgICBsaXN0ZW5lci5lbnRlckNvbnRpbnVlU3RhdGVtZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0Q29udGludWVTdGF0ZW1lbnQpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRDb250aW51ZVN0YXRlbWVudCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdENvbnRpbnVlU3RhdGVtZW50KSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENvbnRpbnVlU3RhdGVtZW50KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBCcmVha1N0YXRlbWVudENvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIEJyZWFrS2V5d29yZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihTb2xpZGl0eVBhcnNlci5CcmVha0tleXdvcmQsIDApO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9icmVha1N0YXRlbWVudDtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJCcmVha1N0YXRlbWVudCkge1xuICAgICAgbGlzdGVuZXIuZW50ZXJCcmVha1N0YXRlbWVudCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdEJyZWFrU3RhdGVtZW50KSB7XG4gICAgICBsaXN0ZW5lci5leGl0QnJlYWtTdGF0ZW1lbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRCcmVha1N0YXRlbWVudCkge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCcmVha1N0YXRlbWVudCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgUmV0dXJuU3RhdGVtZW50Q29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgZXhwcmVzc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBFeHByZXNzaW9uQ29udGV4dCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX3JldHVyblN0YXRlbWVudDtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJSZXR1cm5TdGF0ZW1lbnQpIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyUmV0dXJuU3RhdGVtZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0UmV0dXJuU3RhdGVtZW50KSB7XG4gICAgICBsaXN0ZW5lci5leGl0UmV0dXJuU3RhdGVtZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0UmV0dXJuU3RhdGVtZW50KSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJldHVyblN0YXRlbWVudCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgVGhyb3dTdGF0ZW1lbnRDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfdGhyb3dTdGF0ZW1lbnQ7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyVGhyb3dTdGF0ZW1lbnQpIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyVGhyb3dTdGF0ZW1lbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRUaHJvd1N0YXRlbWVudCkge1xuICAgICAgbGlzdGVuZXIuZXhpdFRocm93U3RhdGVtZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0VGhyb3dTdGF0ZW1lbnQpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGhyb3dTdGF0ZW1lbnQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIEVtaXRTdGF0ZW1lbnRDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBmdW5jdGlvbkNhbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgRnVuY3Rpb25DYWxsQ29udGV4dCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX2VtaXRTdGF0ZW1lbnQ7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyRW1pdFN0YXRlbWVudCkge1xuICAgICAgbGlzdGVuZXIuZW50ZXJFbWl0U3RhdGVtZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0RW1pdFN0YXRlbWVudCkge1xuICAgICAgbGlzdGVuZXIuZXhpdEVtaXRTdGF0ZW1lbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRFbWl0U3RhdGVtZW50KSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdEVtaXRTdGF0ZW1lbnQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIFJldmVydFN0YXRlbWVudENvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGZ1bmN0aW9uQ2FsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBGdW5jdGlvbkNhbGxDb250ZXh0KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfcmV2ZXJ0U3RhdGVtZW50O1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlclJldmVydFN0YXRlbWVudCkge1xuICAgICAgbGlzdGVuZXIuZW50ZXJSZXZlcnRTdGF0ZW1lbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRSZXZlcnRTdGF0ZW1lbnQpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRSZXZlcnRTdGF0ZW1lbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRSZXZlcnRTdGF0ZW1lbnQpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmV2ZXJ0U3RhdGVtZW50KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50Q29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgaWRlbnRpZmllckxpc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgSWRlbnRpZmllckxpc3RDb250ZXh0KTtcbiAgfVxuICB2YXJpYWJsZURlY2xhcmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIFZhcmlhYmxlRGVjbGFyYXRpb25Db250ZXh0KTtcbiAgfVxuICB2YXJpYWJsZURlY2xhcmF0aW9uTGlzdCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBWYXJpYWJsZURlY2xhcmF0aW9uTGlzdENvbnRleHQpO1xuICB9XG4gIGV4cHJlc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgRXhwcmVzc2lvbkNvbnRleHQpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV92YXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50O1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlclZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnQpIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdFZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnQpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0VmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudCkge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBWYXJpYWJsZURlY2xhcmF0aW9uTGlzdENvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIHZhcmlhYmxlRGVjbGFyYXRpb24oaSkge1xuICAgIGlmIChpID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0cyhWYXJpYWJsZURlY2xhcmF0aW9uQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIFZhcmlhYmxlRGVjbGFyYXRpb25Db250ZXh0KTtcbiAgICB9XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX3ZhcmlhYmxlRGVjbGFyYXRpb25MaXN0O1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlclZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KSB7XG4gICAgICBsaXN0ZW5lci5lbnRlclZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0VmFyaWFibGVEZWNsYXJhdGlvbkxpc3QpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdFZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdFZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBJZGVudGlmaWVyTGlzdENvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGlkZW50aWZpZXIoaSkge1xuICAgIGlmIChpID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0cyhJZGVudGlmaWVyQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIElkZW50aWZpZXJDb250ZXh0KTtcbiAgICB9XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX2lkZW50aWZpZXJMaXN0O1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlcklkZW50aWZpZXJMaXN0KSB7XG4gICAgICBsaXN0ZW5lci5lbnRlcklkZW50aWZpZXJMaXN0KHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0SWRlbnRpZmllckxpc3QpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRJZGVudGlmaWVyTGlzdCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdElkZW50aWZpZXJMaXN0KSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdElkZW50aWZpZXJMaXN0KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBFbGVtZW50YXJ5VHlwZU5hbWVDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBJbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU29saWRpdHlQYXJzZXIuSW50LCAwKTtcbiAgfVxuICBVaW50KCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFRva2VuKFNvbGlkaXR5UGFyc2VyLlVpbnQsIDApO1xuICB9XG4gIEJ5dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU29saWRpdHlQYXJzZXIuQnl0ZSwgMCk7XG4gIH1cbiAgRml4ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU29saWRpdHlQYXJzZXIuRml4ZWQsIDApO1xuICB9XG4gIFVmaXhlZCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTb2xpZGl0eVBhcnNlci5VZml4ZWQsIDApO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9lbGVtZW50YXJ5VHlwZU5hbWU7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyRWxlbWVudGFyeVR5cGVOYW1lKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlckVsZW1lbnRhcnlUeXBlTmFtZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdEVsZW1lbnRhcnlUeXBlTmFtZSkge1xuICAgICAgbGlzdGVuZXIuZXhpdEVsZW1lbnRhcnlUeXBlTmFtZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdEVsZW1lbnRhcnlUeXBlTmFtZSkge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFbGVtZW50YXJ5VHlwZU5hbWUodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIEV4cHJlc3Npb25Db250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBleHByZXNzaW9uKGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dHMoRXhwcmVzc2lvbkNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dChpLCBFeHByZXNzaW9uQ29udGV4dCk7XG4gICAgfVxuICB9XG4gIHR5cGVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIFR5cGVOYW1lQ29udGV4dCk7XG4gIH1cbiAgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBJZGVudGlmaWVyQ29udGV4dCk7XG4gIH1cbiAgbmFtZVZhbHVlTGlzdCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBOYW1lVmFsdWVMaXN0Q29udGV4dCk7XG4gIH1cbiAgZnVuY3Rpb25DYWxsQXJndW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIEZ1bmN0aW9uQ2FsbEFyZ3VtZW50c0NvbnRleHQpO1xuICB9XG4gIHByaW1hcnlFeHByZXNzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIFByaW1hcnlFeHByZXNzaW9uQ29udGV4dCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX2V4cHJlc3Npb247XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyRXhwcmVzc2lvbikge1xuICAgICAgbGlzdGVuZXIuZW50ZXJFeHByZXNzaW9uKHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0RXhwcmVzc2lvbikge1xuICAgICAgbGlzdGVuZXIuZXhpdEV4cHJlc3Npb24odGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRFeHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4cHJlc3Npb24odGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIFByaW1hcnlFeHByZXNzaW9uQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgQm9vbGVhbkxpdGVyYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU29saWRpdHlQYXJzZXIuQm9vbGVhbkxpdGVyYWwsIDApO1xuICB9XG4gIG51bWJlckxpdGVyYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgTnVtYmVyTGl0ZXJhbENvbnRleHQpO1xuICB9XG4gIGhleExpdGVyYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgSGV4TGl0ZXJhbENvbnRleHQpO1xuICB9XG4gIHN0cmluZ0xpdGVyYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgU3RyaW5nTGl0ZXJhbENvbnRleHQpO1xuICB9XG4gIGlkZW50aWZpZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgSWRlbnRpZmllckNvbnRleHQpO1xuICB9XG4gIFR5cGVLZXl3b3JkKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFRva2VuKFNvbGlkaXR5UGFyc2VyLlR5cGVLZXl3b3JkLCAwKTtcbiAgfVxuICBQYXlhYmxlS2V5d29yZCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTb2xpZGl0eVBhcnNlci5QYXlhYmxlS2V5d29yZCwgMCk7XG4gIH1cbiAgdHVwbGVFeHByZXNzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIFR1cGxlRXhwcmVzc2lvbkNvbnRleHQpO1xuICB9XG4gIHR5cGVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIFR5cGVOYW1lQ29udGV4dCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX3ByaW1hcnlFeHByZXNzaW9uO1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlclByaW1hcnlFeHByZXNzaW9uKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlclByaW1hcnlFeHByZXNzaW9uKHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0UHJpbWFyeUV4cHJlc3Npb24pIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRQcmltYXJ5RXhwcmVzc2lvbih0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdFByaW1hcnlFeHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdFByaW1hcnlFeHByZXNzaW9uKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBFeHByZXNzaW9uTGlzdENvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGV4cHJlc3Npb24oaSkge1xuICAgIGlmIChpID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0cyhFeHByZXNzaW9uQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIEV4cHJlc3Npb25Db250ZXh0KTtcbiAgICB9XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX2V4cHJlc3Npb25MaXN0O1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlckV4cHJlc3Npb25MaXN0KSB7XG4gICAgICBsaXN0ZW5lci5lbnRlckV4cHJlc3Npb25MaXN0KHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0RXhwcmVzc2lvbkxpc3QpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRFeHByZXNzaW9uTGlzdCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdEV4cHJlc3Npb25MaXN0KSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4cHJlc3Npb25MaXN0KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBOYW1lVmFsdWVMaXN0Q29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgbmFtZVZhbHVlKGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dHMoTmFtZVZhbHVlQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIE5hbWVWYWx1ZUNvbnRleHQpO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfbmFtZVZhbHVlTGlzdDtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJOYW1lVmFsdWVMaXN0KSB7XG4gICAgICBsaXN0ZW5lci5lbnRlck5hbWVWYWx1ZUxpc3QodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXROYW1lVmFsdWVMaXN0KSB7XG4gICAgICBsaXN0ZW5lci5leGl0TmFtZVZhbHVlTGlzdCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdE5hbWVWYWx1ZUxpc3QpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TmFtZVZhbHVlTGlzdCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgTmFtZVZhbHVlQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBJZGVudGlmaWVyQ29udGV4dCk7XG4gIH1cbiAgZXhwcmVzc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBFeHByZXNzaW9uQ29udGV4dCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX25hbWVWYWx1ZTtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJOYW1lVmFsdWUpIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyTmFtZVZhbHVlKHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0TmFtZVZhbHVlKSB7XG4gICAgICBsaXN0ZW5lci5leGl0TmFtZVZhbHVlKHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0TmFtZVZhbHVlKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdE5hbWVWYWx1ZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgRnVuY3Rpb25DYWxsQXJndW1lbnRzQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgbmFtZVZhbHVlTGlzdCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBOYW1lVmFsdWVMaXN0Q29udGV4dCk7XG4gIH1cbiAgZXhwcmVzc2lvbkxpc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgRXhwcmVzc2lvbkxpc3RDb250ZXh0KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfZnVuY3Rpb25DYWxsQXJndW1lbnRzO1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlckZ1bmN0aW9uQ2FsbEFyZ3VtZW50cykge1xuICAgICAgbGlzdGVuZXIuZW50ZXJGdW5jdGlvbkNhbGxBcmd1bWVudHModGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRGdW5jdGlvbkNhbGxBcmd1bWVudHMpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRGdW5jdGlvbkNhbGxBcmd1bWVudHModGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRGdW5jdGlvbkNhbGxBcmd1bWVudHMpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RnVuY3Rpb25DYWxsQXJndW1lbnRzKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBGdW5jdGlvbkNhbGxDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBleHByZXNzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KDAsIEV4cHJlc3Npb25Db250ZXh0KTtcbiAgfVxuICBmdW5jdGlvbkNhbGxBcmd1bWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgRnVuY3Rpb25DYWxsQXJndW1lbnRzQ29udGV4dCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX2Z1bmN0aW9uQ2FsbDtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJGdW5jdGlvbkNhbGwpIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyRnVuY3Rpb25DYWxsKHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0RnVuY3Rpb25DYWxsKSB7XG4gICAgICBsaXN0ZW5lci5leGl0RnVuY3Rpb25DYWxsKHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0RnVuY3Rpb25DYWxsKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdEZ1bmN0aW9uQ2FsbCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgQXNzZW1ibHlCbG9ja0NvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGFzc2VtYmx5SXRlbShpKSB7XG4gICAgaWYgKGkgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHRzKEFzc2VtYmx5SXRlbUNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dChpLCBBc3NlbWJseUl0ZW1Db250ZXh0KTtcbiAgICB9XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX2Fzc2VtYmx5QmxvY2s7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyQXNzZW1ibHlCbG9jaykge1xuICAgICAgbGlzdGVuZXIuZW50ZXJBc3NlbWJseUJsb2NrKHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0QXNzZW1ibHlCbG9jaykge1xuICAgICAgbGlzdGVuZXIuZXhpdEFzc2VtYmx5QmxvY2sodGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRBc3NlbWJseUJsb2NrKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFzc2VtYmx5QmxvY2sodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIEFzc2VtYmx5SXRlbUNvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGlkZW50aWZpZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgSWRlbnRpZmllckNvbnRleHQpO1xuICB9XG4gIGFzc2VtYmx5QmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgQXNzZW1ibHlCbG9ja0NvbnRleHQpO1xuICB9XG4gIGFzc2VtYmx5RXhwcmVzc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBBc3NlbWJseUV4cHJlc3Npb25Db250ZXh0KTtcbiAgfVxuICBhc3NlbWJseUxvY2FsRGVmaW5pdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBBc3NlbWJseUxvY2FsRGVmaW5pdGlvbkNvbnRleHQpO1xuICB9XG4gIGFzc2VtYmx5QXNzaWdubWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBBc3NlbWJseUFzc2lnbm1lbnRDb250ZXh0KTtcbiAgfVxuICBhc3NlbWJseVN0YWNrQXNzaWdubWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBBc3NlbWJseVN0YWNrQXNzaWdubWVudENvbnRleHQpO1xuICB9XG4gIGxhYmVsRGVmaW5pdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBMYWJlbERlZmluaXRpb25Db250ZXh0KTtcbiAgfVxuICBhc3NlbWJseVN3aXRjaCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBBc3NlbWJseVN3aXRjaENvbnRleHQpO1xuICB9XG4gIGFzc2VtYmx5RnVuY3Rpb25EZWZpbml0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIEFzc2VtYmx5RnVuY3Rpb25EZWZpbml0aW9uQ29udGV4dCk7XG4gIH1cbiAgYXNzZW1ibHlGb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgQXNzZW1ibHlGb3JDb250ZXh0KTtcbiAgfVxuICBhc3NlbWJseUlmKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIEFzc2VtYmx5SWZDb250ZXh0KTtcbiAgfVxuICBCcmVha0tleXdvcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU29saWRpdHlQYXJzZXIuQnJlYWtLZXl3b3JkLCAwKTtcbiAgfVxuICBDb250aW51ZUtleXdvcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU29saWRpdHlQYXJzZXIuQ29udGludWVLZXl3b3JkLCAwKTtcbiAgfVxuICBMZWF2ZUtleXdvcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU29saWRpdHlQYXJzZXIuTGVhdmVLZXl3b3JkLCAwKTtcbiAgfVxuICBzdWJBc3NlbWJseSgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBTdWJBc3NlbWJseUNvbnRleHQpO1xuICB9XG4gIG51bWJlckxpdGVyYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgTnVtYmVyTGl0ZXJhbENvbnRleHQpO1xuICB9XG4gIHN0cmluZ0xpdGVyYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgU3RyaW5nTGl0ZXJhbENvbnRleHQpO1xuICB9XG4gIGhleExpdGVyYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgSGV4TGl0ZXJhbENvbnRleHQpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9hc3NlbWJseUl0ZW07XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyQXNzZW1ibHlJdGVtKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlckFzc2VtYmx5SXRlbSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdEFzc2VtYmx5SXRlbSkge1xuICAgICAgbGlzdGVuZXIuZXhpdEFzc2VtYmx5SXRlbSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdEFzc2VtYmx5SXRlbSkge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBc3NlbWJseUl0ZW0odGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIEFzc2VtYmx5RXhwcmVzc2lvbkNvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGFzc2VtYmx5Q2FsbCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBBc3NlbWJseUNhbGxDb250ZXh0KTtcbiAgfVxuICBhc3NlbWJseUxpdGVyYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgQXNzZW1ibHlMaXRlcmFsQ29udGV4dCk7XG4gIH1cbiAgYXNzZW1ibHlNZW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgQXNzZW1ibHlNZW1iZXJDb250ZXh0KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfYXNzZW1ibHlFeHByZXNzaW9uO1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlckFzc2VtYmx5RXhwcmVzc2lvbikge1xuICAgICAgbGlzdGVuZXIuZW50ZXJBc3NlbWJseUV4cHJlc3Npb24odGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRBc3NlbWJseUV4cHJlc3Npb24pIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRBc3NlbWJseUV4cHJlc3Npb24odGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRBc3NlbWJseUV4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXNzZW1ibHlFeHByZXNzaW9uKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBBc3NlbWJseU1lbWJlckNvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGlkZW50aWZpZXIoaSkge1xuICAgIGlmIChpID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0cyhJZGVudGlmaWVyQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KGksIElkZW50aWZpZXJDb250ZXh0KTtcbiAgICB9XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX2Fzc2VtYmx5TWVtYmVyO1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlckFzc2VtYmx5TWVtYmVyKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlckFzc2VtYmx5TWVtYmVyKHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0QXNzZW1ibHlNZW1iZXIpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRBc3NlbWJseU1lbWJlcih0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdEFzc2VtYmx5TWVtYmVyKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFzc2VtYmx5TWVtYmVyKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBBc3NlbWJseUNhbGxDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBpZGVudGlmaWVyKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIElkZW50aWZpZXJDb250ZXh0KTtcbiAgfVxuICBhc3NlbWJseUV4cHJlc3Npb24oaSkge1xuICAgIGlmIChpID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0cyhBc3NlbWJseUV4cHJlc3Npb25Db250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoaSwgQXNzZW1ibHlFeHByZXNzaW9uQ29udGV4dCk7XG4gICAgfVxuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9hc3NlbWJseUNhbGw7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyQXNzZW1ibHlDYWxsKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlckFzc2VtYmx5Q2FsbCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdEFzc2VtYmx5Q2FsbCkge1xuICAgICAgbGlzdGVuZXIuZXhpdEFzc2VtYmx5Q2FsbCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdEFzc2VtYmx5Q2FsbCkge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBc3NlbWJseUNhbGwodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIEFzc2VtYmx5TG9jYWxEZWZpbml0aW9uQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgYXNzZW1ibHlJZGVudGlmaWVyT3JMaXN0KCkge1xuICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KDAsIEFzc2VtYmx5SWRlbnRpZmllck9yTGlzdENvbnRleHQpO1xuICB9XG4gIGFzc2VtYmx5RXhwcmVzc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBBc3NlbWJseUV4cHJlc3Npb25Db250ZXh0KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfYXNzZW1ibHlMb2NhbERlZmluaXRpb247XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyQXNzZW1ibHlMb2NhbERlZmluaXRpb24pIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyQXNzZW1ibHlMb2NhbERlZmluaXRpb24odGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRBc3NlbWJseUxvY2FsRGVmaW5pdGlvbikge1xuICAgICAgbGlzdGVuZXIuZXhpdEFzc2VtYmx5TG9jYWxEZWZpbml0aW9uKHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0QXNzZW1ibHlMb2NhbERlZmluaXRpb24pIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXNzZW1ibHlMb2NhbERlZmluaXRpb24odGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIEFzc2VtYmx5QXNzaWdubWVudENvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGFzc2VtYmx5SWRlbnRpZmllck9yTGlzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBBc3NlbWJseUlkZW50aWZpZXJPckxpc3RDb250ZXh0KTtcbiAgfVxuICBhc3NlbWJseUV4cHJlc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgQXNzZW1ibHlFeHByZXNzaW9uQ29udGV4dCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX2Fzc2VtYmx5QXNzaWdubWVudDtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJBc3NlbWJseUFzc2lnbm1lbnQpIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyQXNzZW1ibHlBc3NpZ25tZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0QXNzZW1ibHlBc3NpZ25tZW50KSB7XG4gICAgICBsaXN0ZW5lci5leGl0QXNzZW1ibHlBc3NpZ25tZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0QXNzZW1ibHlBc3NpZ25tZW50KSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFzc2VtYmx5QXNzaWdubWVudCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgQXNzZW1ibHlJZGVudGlmaWVyT3JMaXN0Q29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBJZGVudGlmaWVyQ29udGV4dCk7XG4gIH1cbiAgYXNzZW1ibHlNZW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgQXNzZW1ibHlNZW1iZXJDb250ZXh0KTtcbiAgfVxuICBhc3NlbWJseUlkZW50aWZpZXJMaXN0KCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIEFzc2VtYmx5SWRlbnRpZmllckxpc3RDb250ZXh0KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfYXNzZW1ibHlJZGVudGlmaWVyT3JMaXN0O1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlckFzc2VtYmx5SWRlbnRpZmllck9yTGlzdCkge1xuICAgICAgbGlzdGVuZXIuZW50ZXJBc3NlbWJseUlkZW50aWZpZXJPckxpc3QodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRBc3NlbWJseUlkZW50aWZpZXJPckxpc3QpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRBc3NlbWJseUlkZW50aWZpZXJPckxpc3QodGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRBc3NlbWJseUlkZW50aWZpZXJPckxpc3QpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXNzZW1ibHlJZGVudGlmaWVyT3JMaXN0KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBBc3NlbWJseUlkZW50aWZpZXJMaXN0Q29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgaWRlbnRpZmllcihpKSB7XG4gICAgaWYgKGkgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHRzKElkZW50aWZpZXJDb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoaSwgSWRlbnRpZmllckNvbnRleHQpO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfYXNzZW1ibHlJZGVudGlmaWVyTGlzdDtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJBc3NlbWJseUlkZW50aWZpZXJMaXN0KSB7XG4gICAgICBsaXN0ZW5lci5lbnRlckFzc2VtYmx5SWRlbnRpZmllckxpc3QodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRBc3NlbWJseUlkZW50aWZpZXJMaXN0KSB7XG4gICAgICBsaXN0ZW5lci5leGl0QXNzZW1ibHlJZGVudGlmaWVyTGlzdCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdEFzc2VtYmx5SWRlbnRpZmllckxpc3QpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXNzZW1ibHlJZGVudGlmaWVyTGlzdCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgQXNzZW1ibHlTdGFja0Fzc2lnbm1lbnRDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBhc3NlbWJseUV4cHJlc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgQXNzZW1ibHlFeHByZXNzaW9uQ29udGV4dCk7XG4gIH1cbiAgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBJZGVudGlmaWVyQ29udGV4dCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX2Fzc2VtYmx5U3RhY2tBc3NpZ25tZW50O1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlckFzc2VtYmx5U3RhY2tBc3NpZ25tZW50KSB7XG4gICAgICBsaXN0ZW5lci5lbnRlckFzc2VtYmx5U3RhY2tBc3NpZ25tZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0QXNzZW1ibHlTdGFja0Fzc2lnbm1lbnQpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRBc3NlbWJseVN0YWNrQXNzaWdubWVudCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdEFzc2VtYmx5U3RhY2tBc3NpZ25tZW50KSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFzc2VtYmx5U3RhY2tBc3NpZ25tZW50KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBMYWJlbERlZmluaXRpb25Db250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBpZGVudGlmaWVyKCkge1xuICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0KDAsIElkZW50aWZpZXJDb250ZXh0KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfbGFiZWxEZWZpbml0aW9uO1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlckxhYmVsRGVmaW5pdGlvbikge1xuICAgICAgbGlzdGVuZXIuZW50ZXJMYWJlbERlZmluaXRpb24odGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRMYWJlbERlZmluaXRpb24pIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRMYWJlbERlZmluaXRpb24odGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRMYWJlbERlZmluaXRpb24pIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGFiZWxEZWZpbml0aW9uKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBBc3NlbWJseVN3aXRjaENvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGFzc2VtYmx5RXhwcmVzc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBBc3NlbWJseUV4cHJlc3Npb25Db250ZXh0KTtcbiAgfVxuICBhc3NlbWJseUNhc2UoaSkge1xuICAgIGlmIChpID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJ1bGVDb250ZXh0cyhBc3NlbWJseUNhc2VDb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoaSwgQXNzZW1ibHlDYXNlQ29udGV4dCk7XG4gICAgfVxuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9hc3NlbWJseVN3aXRjaDtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJBc3NlbWJseVN3aXRjaCkge1xuICAgICAgbGlzdGVuZXIuZW50ZXJBc3NlbWJseVN3aXRjaCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdEFzc2VtYmx5U3dpdGNoKSB7XG4gICAgICBsaXN0ZW5lci5leGl0QXNzZW1ibHlTd2l0Y2godGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRBc3NlbWJseVN3aXRjaCkge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBc3NlbWJseVN3aXRjaCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgQXNzZW1ibHlDYXNlQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgYXNzZW1ibHlMaXRlcmFsKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFJ1bGVDb250ZXh0KDAsIEFzc2VtYmx5TGl0ZXJhbENvbnRleHQpO1xuICB9XG4gIGFzc2VtYmx5QmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgQXNzZW1ibHlCbG9ja0NvbnRleHQpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9hc3NlbWJseUNhc2U7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyQXNzZW1ibHlDYXNlKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlckFzc2VtYmx5Q2FzZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdEFzc2VtYmx5Q2FzZSkge1xuICAgICAgbGlzdGVuZXIuZXhpdEFzc2VtYmx5Q2FzZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdEFzc2VtYmx5Q2FzZSkge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBc3NlbWJseUNhc2UodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIEFzc2VtYmx5RnVuY3Rpb25EZWZpbml0aW9uQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBJZGVudGlmaWVyQ29udGV4dCk7XG4gIH1cbiAgYXNzZW1ibHlCbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBBc3NlbWJseUJsb2NrQ29udGV4dCk7XG4gIH1cbiAgYXNzZW1ibHlJZGVudGlmaWVyTGlzdCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBBc3NlbWJseUlkZW50aWZpZXJMaXN0Q29udGV4dCk7XG4gIH1cbiAgYXNzZW1ibHlGdW5jdGlvblJldHVybnMoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgQXNzZW1ibHlGdW5jdGlvblJldHVybnNDb250ZXh0KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfYXNzZW1ibHlGdW5jdGlvbkRlZmluaXRpb247XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyQXNzZW1ibHlGdW5jdGlvbkRlZmluaXRpb24pIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyQXNzZW1ibHlGdW5jdGlvbkRlZmluaXRpb24odGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRBc3NlbWJseUZ1bmN0aW9uRGVmaW5pdGlvbikge1xuICAgICAgbGlzdGVuZXIuZXhpdEFzc2VtYmx5RnVuY3Rpb25EZWZpbml0aW9uKHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0QXNzZW1ibHlGdW5jdGlvbkRlZmluaXRpb24pIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXNzZW1ibHlGdW5jdGlvbkRlZmluaXRpb24odGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIEFzc2VtYmx5RnVuY3Rpb25SZXR1cm5zQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgYXNzZW1ibHlJZGVudGlmaWVyTGlzdCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBBc3NlbWJseUlkZW50aWZpZXJMaXN0Q29udGV4dCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX2Fzc2VtYmx5RnVuY3Rpb25SZXR1cm5zO1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlckFzc2VtYmx5RnVuY3Rpb25SZXR1cm5zKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlckFzc2VtYmx5RnVuY3Rpb25SZXR1cm5zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0QXNzZW1ibHlGdW5jdGlvblJldHVybnMpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRBc3NlbWJseUZ1bmN0aW9uUmV0dXJucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdEFzc2VtYmx5RnVuY3Rpb25SZXR1cm5zKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFzc2VtYmx5RnVuY3Rpb25SZXR1cm5zKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBBc3NlbWJseUZvckNvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIGFzc2VtYmx5RXhwcmVzc2lvbihpKSB7XG4gICAgaWYgKGkgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHRzKEFzc2VtYmx5RXhwcmVzc2lvbkNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dChpLCBBc3NlbWJseUV4cHJlc3Npb25Db250ZXh0KTtcbiAgICB9XG4gIH1cbiAgYXNzZW1ibHlCbG9jayhpKSB7XG4gICAgaWYgKGkgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHRzKEFzc2VtYmx5QmxvY2tDb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoaSwgQXNzZW1ibHlCbG9ja0NvbnRleHQpO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfYXNzZW1ibHlGb3I7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyQXNzZW1ibHlGb3IpIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyQXNzZW1ibHlGb3IodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRBc3NlbWJseUZvcikge1xuICAgICAgbGlzdGVuZXIuZXhpdEFzc2VtYmx5Rm9yKHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0QXNzZW1ibHlGb3IpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXNzZW1ibHlGb3IodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIEFzc2VtYmx5SWZDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBhc3NlbWJseUV4cHJlc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UnVsZUNvbnRleHQoMCwgQXNzZW1ibHlFeHByZXNzaW9uQ29udGV4dCk7XG4gIH1cbiAgYXNzZW1ibHlCbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBBc3NlbWJseUJsb2NrQ29udGV4dCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX2Fzc2VtYmx5SWY7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyQXNzZW1ibHlJZikge1xuICAgICAgbGlzdGVuZXIuZW50ZXJBc3NlbWJseUlmKHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0QXNzZW1ibHlJZikge1xuICAgICAgbGlzdGVuZXIuZXhpdEFzc2VtYmx5SWYodGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRBc3NlbWJseUlmKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFzc2VtYmx5SWYodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIEFzc2VtYmx5TGl0ZXJhbENvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIHN0cmluZ0xpdGVyYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0UnVsZUNvbnRleHQoMCwgU3RyaW5nTGl0ZXJhbENvbnRleHQpO1xuICB9XG4gIERlY2ltYWxOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU29saWRpdHlQYXJzZXIuRGVjaW1hbE51bWJlciwgMCk7XG4gIH1cbiAgSGV4TnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFRva2VuKFNvbGlkaXR5UGFyc2VyLkhleE51bWJlciwgMCk7XG4gIH1cbiAgaGV4TGl0ZXJhbCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRSdWxlQ29udGV4dCgwLCBIZXhMaXRlcmFsQ29udGV4dCk7XG4gIH1cbiAgQm9vbGVhbkxpdGVyYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU29saWRpdHlQYXJzZXIuQm9vbGVhbkxpdGVyYWwsIDApO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9hc3NlbWJseUxpdGVyYWw7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyQXNzZW1ibHlMaXRlcmFsKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlckFzc2VtYmx5TGl0ZXJhbCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdEFzc2VtYmx5TGl0ZXJhbCkge1xuICAgICAgbGlzdGVuZXIuZXhpdEFzc2VtYmx5TGl0ZXJhbCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdEFzc2VtYmx5TGl0ZXJhbCkge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBc3NlbWJseUxpdGVyYWwodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIFN1YkFzc2VtYmx5Q29udGV4dCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X1BhcnNlclJ1bGVDb250ZXh0LlBhcnNlclJ1bGVDb250ZXh0IHtcbiAgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBJZGVudGlmaWVyQ29udGV4dCk7XG4gIH1cbiAgYXNzZW1ibHlCbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dCgwLCBBc3NlbWJseUJsb2NrQ29udGV4dCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX3N1YkFzc2VtYmx5O1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlclN1YkFzc2VtYmx5KSB7XG4gICAgICBsaXN0ZW5lci5lbnRlclN1YkFzc2VtYmx5KHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0U3ViQXNzZW1ibHkpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRTdWJBc3NlbWJseSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdFN1YkFzc2VtYmx5KSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdFN1YkFzc2VtYmx5KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciBUdXBsZUV4cHJlc3Npb25Db250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBleHByZXNzaW9uKGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dHMoRXhwcmVzc2lvbkNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dChpLCBFeHByZXNzaW9uQ29udGV4dCk7XG4gICAgfVxuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV90dXBsZUV4cHJlc3Npb247XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyVHVwbGVFeHByZXNzaW9uKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlclR1cGxlRXhwcmVzc2lvbih0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdFR1cGxlRXhwcmVzc2lvbikge1xuICAgICAgbGlzdGVuZXIuZXhpdFR1cGxlRXhwcmVzc2lvbih0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdFR1cGxlRXhwcmVzc2lvbikge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUdXBsZUV4cHJlc3Npb24odGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIE51bWJlckxpdGVyYWxDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBEZWNpbWFsTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFRva2VuKFNvbGlkaXR5UGFyc2VyLkRlY2ltYWxOdW1iZXIsIDApO1xuICB9XG4gIEhleE51bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTb2xpZGl0eVBhcnNlci5IZXhOdW1iZXIsIDApO1xuICB9XG4gIE51bWJlclVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU29saWRpdHlQYXJzZXIuTnVtYmVyVW5pdCwgMCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX251bWJlckxpdGVyYWw7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVyTnVtYmVyTGl0ZXJhbCkge1xuICAgICAgbGlzdGVuZXIuZW50ZXJOdW1iZXJMaXRlcmFsKHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0TnVtYmVyTGl0ZXJhbCkge1xuICAgICAgbGlzdGVuZXIuZXhpdE51bWJlckxpdGVyYWwodGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXROdW1iZXJMaXRlcmFsKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdE51bWJlckxpdGVyYWwodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIElkZW50aWZpZXJDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBSZWNlaXZlS2V5d29yZCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTb2xpZGl0eVBhcnNlci5SZWNlaXZlS2V5d29yZCwgMCk7XG4gIH1cbiAgQ29uc3RydWN0b3JLZXl3b3JkKCkge1xuICAgIHJldHVybiB0aGlzLnRyeUdldFRva2VuKFNvbGlkaXR5UGFyc2VyLkNvbnN0cnVjdG9yS2V5d29yZCwgMCk7XG4gIH1cbiAgUGF5YWJsZUtleXdvcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU29saWRpdHlQYXJzZXIuUGF5YWJsZUtleXdvcmQsIDApO1xuICB9XG4gIExlYXZlS2V5d29yZCgpIHtcbiAgICByZXR1cm4gdGhpcy50cnlHZXRUb2tlbihTb2xpZGl0eVBhcnNlci5MZWF2ZUtleXdvcmQsIDApO1xuICB9XG4gIElkZW50aWZpZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ5R2V0VG9rZW4oU29saWRpdHlQYXJzZXIuSWRlbnRpZmllciwgMCk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG4gICAgc3VwZXIocGFyZW50LCBpbnZva2luZ1N0YXRlKTtcbiAgfVxuICBnZXQgcnVsZUluZGV4KCkge1xuICAgIHJldHVybiBTb2xpZGl0eVBhcnNlci5SVUxFX2lkZW50aWZpZXI7XG4gIH1cbiAgZW50ZXJSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmVudGVySWRlbnRpZmllcikge1xuICAgICAgbGlzdGVuZXIuZW50ZXJJZGVudGlmaWVyKHRoaXMpO1xuICAgIH1cbiAgfVxuICBleGl0UnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5leGl0SWRlbnRpZmllcikge1xuICAgICAgbGlzdGVuZXIuZXhpdElkZW50aWZpZXIodGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRJZGVudGlmaWVyKSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdElkZW50aWZpZXIodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XG4gICAgfVxuICB9XG59O1xudmFyIEhleExpdGVyYWxDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICBIZXhMaXRlcmFsRnJhZ21lbnQoaSkge1xuICAgIGlmIChpID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRva2VucyhTb2xpZGl0eVBhcnNlci5IZXhMaXRlcmFsRnJhZ21lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihTb2xpZGl0eVBhcnNlci5IZXhMaXRlcmFsRnJhZ21lbnQsIGkpO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcbiAgICBzdXBlcihwYXJlbnQsIGludm9raW5nU3RhdGUpO1xuICB9XG4gIGdldCBydWxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIFNvbGlkaXR5UGFyc2VyLlJVTEVfaGV4TGl0ZXJhbDtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJIZXhMaXRlcmFsKSB7XG4gICAgICBsaXN0ZW5lci5lbnRlckhleExpdGVyYWwodGhpcyk7XG4gICAgfVxuICB9XG4gIGV4aXRSdWxlKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLmV4aXRIZXhMaXRlcmFsKSB7XG4gICAgICBsaXN0ZW5lci5leGl0SGV4TGl0ZXJhbCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICBpZiAodmlzaXRvci52aXNpdEhleExpdGVyYWwpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SGV4TGl0ZXJhbCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgT3ZlcnJpZGVTcGVjaWZpZXJDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfUGFyc2VyUnVsZUNvbnRleHQuUGFyc2VyUnVsZUNvbnRleHQge1xuICB1c2VyRGVmaW5lZFR5cGVOYW1lKGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dHMoVXNlckRlZmluZWRUeXBlTmFtZUNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSdWxlQ29udGV4dChpLCBVc2VyRGVmaW5lZFR5cGVOYW1lQ29udGV4dCk7XG4gICAgfVxuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9vdmVycmlkZVNwZWNpZmllcjtcbiAgfVxuICBlbnRlclJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZW50ZXJPdmVycmlkZVNwZWNpZmllcikge1xuICAgICAgbGlzdGVuZXIuZW50ZXJPdmVycmlkZVNwZWNpZmllcih0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdE92ZXJyaWRlU3BlY2lmaWVyKSB7XG4gICAgICBsaXN0ZW5lci5leGl0T3ZlcnJpZGVTcGVjaWZpZXIodGhpcyk7XG4gICAgfVxuICB9XG4gIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgaWYgKHZpc2l0b3IudmlzaXRPdmVycmlkZVNwZWNpZmllcikge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRPdmVycmlkZVNwZWNpZmllcih0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgU3RyaW5nTGl0ZXJhbENvbnRleHQgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9QYXJzZXJSdWxlQ29udGV4dC5QYXJzZXJSdWxlQ29udGV4dCB7XG4gIFN0cmluZ0xpdGVyYWxGcmFnbWVudChpKSB7XG4gICAgaWYgKGkgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5zKFNvbGlkaXR5UGFyc2VyLlN0cmluZ0xpdGVyYWxGcmFnbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRva2VuKFNvbGlkaXR5UGFyc2VyLlN0cmluZ0xpdGVyYWxGcmFnbWVudCwgaSk7XG4gICAgfVxuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xuICAgIHN1cGVyKHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XG4gIH1cbiAgZ2V0IHJ1bGVJbmRleCgpIHtcbiAgICByZXR1cm4gU29saWRpdHlQYXJzZXIuUlVMRV9zdHJpbmdMaXRlcmFsO1xuICB9XG4gIGVudGVyUnVsZShsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5lbnRlclN0cmluZ0xpdGVyYWwpIHtcbiAgICAgIGxpc3RlbmVyLmVudGVyU3RyaW5nTGl0ZXJhbCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZXhpdFJ1bGUobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuZXhpdFN0cmluZ0xpdGVyYWwpIHtcbiAgICAgIGxpc3RlbmVyLmV4aXRTdHJpbmdMaXRlcmFsKHRoaXMpO1xuICAgIH1cbiAgfVxuICBhY2NlcHQodmlzaXRvcikge1xuICAgIGlmICh2aXNpdG9yLnZpc2l0U3RyaW5nTGl0ZXJhbCkge1xuICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTdHJpbmdMaXRlcmFsKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2FzdC10eXBlcy50c1xudmFyIGFzdE5vZGVUeXBlcyA9IFtcbiAgXCJTb3VyY2VVbml0XCIsXG4gIFwiUHJhZ21hRGlyZWN0aXZlXCIsXG4gIFwiSW1wb3J0RGlyZWN0aXZlXCIsXG4gIFwiQ29udHJhY3REZWZpbml0aW9uXCIsXG4gIFwiSW5oZXJpdGFuY2VTcGVjaWZpZXJcIixcbiAgXCJTdGF0ZVZhcmlhYmxlRGVjbGFyYXRpb25cIixcbiAgXCJVc2luZ0ZvckRlY2xhcmF0aW9uXCIsXG4gIFwiU3RydWN0RGVmaW5pdGlvblwiLFxuICBcIk1vZGlmaWVyRGVmaW5pdGlvblwiLFxuICBcIk1vZGlmaWVySW52b2NhdGlvblwiLFxuICBcIkZ1bmN0aW9uRGVmaW5pdGlvblwiLFxuICBcIkV2ZW50RGVmaW5pdGlvblwiLFxuICBcIkN1c3RvbUVycm9yRGVmaW5pdGlvblwiLFxuICBcIlJldmVydFN0YXRlbWVudFwiLFxuICBcIkVudW1WYWx1ZVwiLFxuICBcIkVudW1EZWZpbml0aW9uXCIsXG4gIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLFxuICBcIlVzZXJEZWZpbmVkVHlwZU5hbWVcIixcbiAgXCJNYXBwaW5nXCIsXG4gIFwiQXJyYXlUeXBlTmFtZVwiLFxuICBcIkZ1bmN0aW9uVHlwZU5hbWVcIixcbiAgXCJCbG9ja1wiLFxuICBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcbiAgXCJJZlN0YXRlbWVudFwiLFxuICBcIldoaWxlU3RhdGVtZW50XCIsXG4gIFwiRm9yU3RhdGVtZW50XCIsXG4gIFwiSW5saW5lQXNzZW1ibHlTdGF0ZW1lbnRcIixcbiAgXCJEb1doaWxlU3RhdGVtZW50XCIsXG4gIFwiQ29udGludWVTdGF0ZW1lbnRcIixcbiAgXCJCcmVha1wiLFxuICBcIkNvbnRpbnVlXCIsXG4gIFwiQnJlYWtTdGF0ZW1lbnRcIixcbiAgXCJSZXR1cm5TdGF0ZW1lbnRcIixcbiAgXCJFbWl0U3RhdGVtZW50XCIsXG4gIFwiVGhyb3dTdGF0ZW1lbnRcIixcbiAgXCJWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50XCIsXG4gIFwiRWxlbWVudGFyeVR5cGVOYW1lXCIsXG4gIFwiRnVuY3Rpb25DYWxsXCIsXG4gIFwiQXNzZW1ibHlCbG9ja1wiLFxuICBcIkFzc2VtYmx5Q2FsbFwiLFxuICBcIkFzc2VtYmx5TG9jYWxEZWZpbml0aW9uXCIsXG4gIFwiQXNzZW1ibHlBc3NpZ25tZW50XCIsXG4gIFwiQXNzZW1ibHlTdGFja0Fzc2lnbm1lbnRcIixcbiAgXCJMYWJlbERlZmluaXRpb25cIixcbiAgXCJBc3NlbWJseVN3aXRjaFwiLFxuICBcIkFzc2VtYmx5Q2FzZVwiLFxuICBcIkFzc2VtYmx5RnVuY3Rpb25EZWZpbml0aW9uXCIsXG4gIFwiQXNzZW1ibHlGdW5jdGlvblJldHVybnNcIixcbiAgXCJBc3NlbWJseUZvclwiLFxuICBcIkFzc2VtYmx5SWZcIixcbiAgXCJTdWJBc3NlbWJseVwiLFxuICBcIlR1cGxlRXhwcmVzc2lvblwiLFxuICBcIk5hbWVWYWx1ZUV4cHJlc3Npb25cIixcbiAgXCJCb29sZWFuTGl0ZXJhbFwiLFxuICBcIk51bWJlckxpdGVyYWxcIixcbiAgXCJJZGVudGlmaWVyXCIsXG4gIFwiQmluYXJ5T3BlcmF0aW9uXCIsXG4gIFwiVW5hcnlPcGVyYXRpb25cIixcbiAgXCJOZXdFeHByZXNzaW9uXCIsXG4gIFwiQ29uZGl0aW9uYWxcIixcbiAgXCJTdHJpbmdMaXRlcmFsXCIsXG4gIFwiSGV4TGl0ZXJhbFwiLFxuICBcIkhleE51bWJlclwiLFxuICBcIkRlY2ltYWxOdW1iZXJcIixcbiAgXCJNZW1iZXJBY2Nlc3NcIixcbiAgXCJJbmRleEFjY2Vzc1wiLFxuICBcIkluZGV4UmFuZ2VBY2Nlc3NcIixcbiAgXCJOYW1lVmFsdWVMaXN0XCIsXG4gIFwiVW5jaGVja2VkU3RhdGVtZW50XCIsXG4gIFwiVHJ5U3RhdGVtZW50XCIsXG4gIFwiQ2F0Y2hDbGF1c2VcIixcbiAgXCJGaWxlTGV2ZWxDb25zdGFudFwiLFxuICBcIkFzc2VtYmx5TWVtYmVyQWNjZXNzXCIsXG4gIFwiVHlwZURlZmluaXRpb25cIlxuXTtcbnZhciBiaW5hcnlPcFZhbHVlcyA9IFtcbiAgXCIrXCIsXG4gIFwiLVwiLFxuICBcIipcIixcbiAgXCIvXCIsXG4gIFwiKipcIixcbiAgXCIlXCIsXG4gIFwiPDxcIixcbiAgXCI+PlwiLFxuICBcIiYmXCIsXG4gIFwifHxcIixcbiAgXCIsLFwiLFxuICBcIiZcIixcbiAgXCIsXCIsXG4gIFwiXlwiLFxuICBcIjxcIixcbiAgXCI+XCIsXG4gIFwiPD1cIixcbiAgXCI+PVwiLFxuICBcIj09XCIsXG4gIFwiIT1cIixcbiAgXCI9XCIsXG4gIFwiLD1cIixcbiAgXCJePVwiLFxuICBcIiY9XCIsXG4gIFwiPDw9XCIsXG4gIFwiPj49XCIsXG4gIFwiKz1cIixcbiAgXCItPVwiLFxuICBcIio9XCIsXG4gIFwiLz1cIixcbiAgXCIlPVwiLFxuICBcInxcIixcbiAgXCJ8PVwiXG5dO1xudmFyIHVuYXJ5T3BWYWx1ZXMgPSBbXG4gIFwiLVwiLFxuICBcIitcIixcbiAgXCIrK1wiLFxuICBcIi0tXCIsXG4gIFwiflwiLFxuICBcImFmdGVyXCIsXG4gIFwiZGVsZXRlXCIsXG4gIFwiIVwiXG5dO1xuXG4vLyBzcmMvQVNUQnVpbGRlci50c1xudmFyIGltcG9ydF9BYnN0cmFjdFBhcnNlVHJlZVZpc2l0b3IgPSBfX3RvTW9kdWxlKHJlcXVpcmVfQWJzdHJhY3RQYXJzZVRyZWVWaXNpdG9yKCkpO1xudmFyIGltcG9ydF9FcnJvck5vZGUgPSBfX3RvTW9kdWxlKHJlcXVpcmVfRXJyb3JOb2RlKCkpO1xudmFyIEFTVEJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9BYnN0cmFjdFBhcnNlVHJlZVZpc2l0b3IuQWJzdHJhY3RQYXJzZVRyZWVWaXNpdG9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJlc3VsdCA9IG51bGw7XG4gIH1cbiAgZGVmYXVsdFJlc3VsdCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG5vZGVcIik7XG4gIH1cbiAgYWdncmVnYXRlUmVzdWx0KCkge1xuICAgIHJldHVybiB7dHlwZTogXCJcIn07XG4gIH1cbiAgdmlzaXRTb3VyY2VVbml0KGN0eCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBjaGlsZHJlbiA9ICgoX2EgPSBjdHguY2hpbGRyZW4pICE9IG51bGwgPyBfYSA6IFtdKS5maWx0ZXIoKHgpID0+ICEoeCBpbnN0YW5jZW9mIGltcG9ydF9FcnJvck5vZGUuRXJyb3JOb2RlKSk7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiU291cmNlVW5pdFwiLFxuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLnNsaWNlKDAsIC0xKS5tYXAoKGNoaWxkKSA9PiB0aGlzLnZpc2l0KGNoaWxkKSlcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZpc2l0Q29udHJhY3RQYXJ0KGN0eCkge1xuICAgIHJldHVybiB0aGlzLnZpc2l0KGN0eC5nZXRDaGlsZCgwKSk7XG4gIH1cbiAgdmlzaXRDb250cmFjdERlZmluaXRpb24oY3R4KSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuX3RvVGV4dChjdHguaWRlbnRpZmllcigpKTtcbiAgICBjb25zdCBraW5kID0gdGhpcy5fdG9UZXh0KGN0eC5nZXRDaGlsZCgwKSk7XG4gICAgdGhpcy5fY3VycmVudENvbnRyYWN0ID0gbmFtZTtcbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgdHlwZTogXCJDb250cmFjdERlZmluaXRpb25cIixcbiAgICAgIG5hbWUsXG4gICAgICBiYXNlQ29udHJhY3RzOiBjdHguaW5oZXJpdGFuY2VTcGVjaWZpZXIoKS5tYXAoKHgpID0+IHRoaXMudmlzaXRJbmhlcml0YW5jZVNwZWNpZmllcih4KSksXG4gICAgICBzdWJOb2RlczogY3R4LmNvbnRyYWN0UGFydCgpLm1hcCgoeCkgPT4gdGhpcy52aXNpdCh4KSksXG4gICAgICBraW5kXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICB9XG4gIHZpc2l0U3RhdGVWYXJpYWJsZURlY2xhcmF0aW9uKGN0eCkge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnZpc2l0VHlwZU5hbWUoY3R4LnR5cGVOYW1lKCkpO1xuICAgIGNvbnN0IGlkZW4gPSBjdHguaWRlbnRpZmllcigpO1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLl90b1RleHQoaWRlbik7XG4gICAgbGV0IGV4cHJlc3Npb24gPSBudWxsO1xuICAgIGNvbnN0IGN0eEV4cHJlc3Npb24gPSBjdHguZXhwcmVzc2lvbigpO1xuICAgIGlmIChjdHhFeHByZXNzaW9uKSB7XG4gICAgICBleHByZXNzaW9uID0gdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4RXhwcmVzc2lvbik7XG4gICAgfVxuICAgIGxldCB2aXNpYmlsaXR5ID0gXCJkZWZhdWx0XCI7XG4gICAgaWYgKGN0eC5JbnRlcm5hbEtleXdvcmQoKS5sZW5ndGggPiAwKSB7XG4gICAgICB2aXNpYmlsaXR5ID0gXCJpbnRlcm5hbFwiO1xuICAgIH0gZWxzZSBpZiAoY3R4LlB1YmxpY0tleXdvcmQoKS5sZW5ndGggPiAwKSB7XG4gICAgICB2aXNpYmlsaXR5ID0gXCJwdWJsaWNcIjtcbiAgICB9IGVsc2UgaWYgKGN0eC5Qcml2YXRlS2V5d29yZCgpLmxlbmd0aCA+IDApIHtcbiAgICAgIHZpc2liaWxpdHkgPSBcInByaXZhdGVcIjtcbiAgICB9XG4gICAgbGV0IGlzRGVjbGFyZWRDb25zdCA9IGZhbHNlO1xuICAgIGlmIChjdHguQ29uc3RhbnRLZXl3b3JkKCkubGVuZ3RoID4gMCkge1xuICAgICAgaXNEZWNsYXJlZENvbnN0ID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IG92ZXJyaWRlO1xuICAgIGNvbnN0IG92ZXJyaWRlU3BlY2lmaWVyID0gY3R4Lm92ZXJyaWRlU3BlY2lmaWVyKCk7XG4gICAgaWYgKG92ZXJyaWRlU3BlY2lmaWVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgb3ZlcnJpZGUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdmVycmlkZSA9IG92ZXJyaWRlU3BlY2lmaWVyWzBdLnVzZXJEZWZpbmVkVHlwZU5hbWUoKS5tYXAoKHgpID0+IHRoaXMudmlzaXRVc2VyRGVmaW5lZFR5cGVOYW1lKHgpKTtcbiAgICB9XG4gICAgbGV0IGlzSW1tdXRhYmxlID0gZmFsc2U7XG4gICAgaWYgKGN0eC5JbW11dGFibGVLZXl3b3JkKCkubGVuZ3RoID4gMCkge1xuICAgICAgaXNJbW11dGFibGUgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBkZWNsID0ge1xuICAgICAgdHlwZTogXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXG4gICAgICB0eXBlTmFtZTogdHlwZSxcbiAgICAgIG5hbWUsXG4gICAgICBpZGVudGlmaWVyOiB0aGlzLnZpc2l0SWRlbnRpZmllcihpZGVuKSxcbiAgICAgIGV4cHJlc3Npb24sXG4gICAgICB2aXNpYmlsaXR5LFxuICAgICAgaXNTdGF0ZVZhcjogdHJ1ZSxcbiAgICAgIGlzRGVjbGFyZWRDb25zdCxcbiAgICAgIGlzSW5kZXhlZDogZmFsc2UsXG4gICAgICBpc0ltbXV0YWJsZSxcbiAgICAgIG92ZXJyaWRlLFxuICAgICAgc3RvcmFnZUxvY2F0aW9uOiBudWxsXG4gICAgfTtcbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgdHlwZTogXCJTdGF0ZVZhcmlhYmxlRGVjbGFyYXRpb25cIixcbiAgICAgIHZhcmlhYmxlczogW3RoaXMuX2FkZE1ldGEoZGVjbCwgY3R4KV0sXG4gICAgICBpbml0aWFsVmFsdWU6IGV4cHJlc3Npb25cbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gIH1cbiAgdmlzaXRWYXJpYWJsZURlY2xhcmF0aW9uKGN0eCkge1xuICAgIGxldCBzdG9yYWdlTG9jYXRpb24gPSBudWxsO1xuICAgIGNvbnN0IGN0eFN0b3JhZ2VMb2NhdGlvbiA9IGN0eC5zdG9yYWdlTG9jYXRpb24oKTtcbiAgICBpZiAoY3R4U3RvcmFnZUxvY2F0aW9uKSB7XG4gICAgICBzdG9yYWdlTG9jYXRpb24gPSB0aGlzLl90b1RleHQoY3R4U3RvcmFnZUxvY2F0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgaWRlbnRpZmllckN0eCA9IGN0eC5pZGVudGlmaWVyKCk7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLFxuICAgICAgdHlwZU5hbWU6IHRoaXMudmlzaXRUeXBlTmFtZShjdHgudHlwZU5hbWUoKSksXG4gICAgICBuYW1lOiB0aGlzLl90b1RleHQoaWRlbnRpZmllckN0eCksXG4gICAgICBpZGVudGlmaWVyOiB0aGlzLnZpc2l0SWRlbnRpZmllcihpZGVudGlmaWVyQ3R4KSxcbiAgICAgIHN0b3JhZ2VMb2NhdGlvbixcbiAgICAgIGlzU3RhdGVWYXI6IGZhbHNlLFxuICAgICAgaXNJbmRleGVkOiBmYWxzZSxcbiAgICAgIGV4cHJlc3Npb246IG51bGxcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gIH1cbiAgdmlzaXRWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50KGN0eCkge1xuICAgIGxldCB2YXJpYWJsZXMgPSBbXTtcbiAgICBjb25zdCBjdHhWYXJpYWJsZURlY2xhcmF0aW9uID0gY3R4LnZhcmlhYmxlRGVjbGFyYXRpb24oKTtcbiAgICBjb25zdCBjdHhJZGVudGlmaWVyTGlzdCA9IGN0eC5pZGVudGlmaWVyTGlzdCgpO1xuICAgIGNvbnN0IGN0eFZhcmlhYmxlRGVjbGFyYXRpb25MaXN0ID0gY3R4LnZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KCk7XG4gICAgaWYgKGN0eFZhcmlhYmxlRGVjbGFyYXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgdmFyaWFibGVzID0gW3RoaXMudmlzaXRWYXJpYWJsZURlY2xhcmF0aW9uKGN0eFZhcmlhYmxlRGVjbGFyYXRpb24pXTtcbiAgICB9IGVsc2UgaWYgKGN0eElkZW50aWZpZXJMaXN0ICE9PSB2b2lkIDApIHtcbiAgICAgIHZhcmlhYmxlcyA9IHRoaXMuYnVpbGRJZGVudGlmaWVyTGlzdChjdHhJZGVudGlmaWVyTGlzdCk7XG4gICAgfSBlbHNlIGlmIChjdHhWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCkge1xuICAgICAgdmFyaWFibGVzID0gdGhpcy5idWlsZFZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KGN0eFZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KTtcbiAgICB9XG4gICAgbGV0IGluaXRpYWxWYWx1ZSA9IG51bGw7XG4gICAgY29uc3QgY3R4RXhwcmVzc2lvbiA9IGN0eC5leHByZXNzaW9uKCk7XG4gICAgaWYgKGN0eEV4cHJlc3Npb24pIHtcbiAgICAgIGluaXRpYWxWYWx1ZSA9IHRoaXMudmlzaXRFeHByZXNzaW9uKGN0eEV4cHJlc3Npb24pO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgdHlwZTogXCJWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50XCIsXG4gICAgICB2YXJpYWJsZXMsXG4gICAgICBpbml0aWFsVmFsdWVcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gIH1cbiAgdmlzaXRTdGF0ZW1lbnQoY3R4KSB7XG4gICAgcmV0dXJuIHRoaXMudmlzaXQoY3R4LmdldENoaWxkKDApKTtcbiAgfVxuICB2aXNpdFNpbXBsZVN0YXRlbWVudChjdHgpIHtcbiAgICByZXR1cm4gdGhpcy52aXNpdChjdHguZ2V0Q2hpbGQoMCkpO1xuICB9XG4gIHZpc2l0RXZlbnREZWZpbml0aW9uKGN0eCkge1xuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBjdHguZXZlbnRQYXJhbWV0ZXJMaXN0KCkuZXZlbnRQYXJhbWV0ZXIoKS5tYXAoKHBhcmFtQ3R4KSA9PiB7XG4gICAgICBjb25zdCB0eXBlID0gdGhpcy52aXNpdFR5cGVOYW1lKHBhcmFtQ3R4LnR5cGVOYW1lKCkpO1xuICAgICAgbGV0IG5hbWUgPSBudWxsO1xuICAgICAgY29uc3QgcGFyYW1DdHhJZGVudGlmaWVyID0gcGFyYW1DdHguaWRlbnRpZmllcigpO1xuICAgICAgaWYgKHBhcmFtQ3R4SWRlbnRpZmllcikge1xuICAgICAgICBuYW1lID0gdGhpcy5fdG9UZXh0KHBhcmFtQ3R4SWRlbnRpZmllcik7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlMiA9IHtcbiAgICAgICAgdHlwZTogXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXG4gICAgICAgIHR5cGVOYW1lOiB0eXBlLFxuICAgICAgICBuYW1lLFxuICAgICAgICBpZGVudGlmaWVyOiBwYXJhbUN0eElkZW50aWZpZXIgIT09IHZvaWQgMCA/IHRoaXMudmlzaXRJZGVudGlmaWVyKHBhcmFtQ3R4SWRlbnRpZmllcikgOiBudWxsLFxuICAgICAgICBpc1N0YXRlVmFyOiBmYWxzZSxcbiAgICAgICAgaXNJbmRleGVkOiBwYXJhbUN0eC5JbmRleGVkS2V5d29yZCgpICE9PSB2b2lkIDAsXG4gICAgICAgIHN0b3JhZ2VMb2NhdGlvbjogbnVsbCxcbiAgICAgICAgZXhwcmVzc2lvbjogbnVsbFxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUyLCBwYXJhbUN0eCk7XG4gICAgfSk7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiRXZlbnREZWZpbml0aW9uXCIsXG4gICAgICBuYW1lOiB0aGlzLl90b1RleHQoY3R4LmlkZW50aWZpZXIoKSksXG4gICAgICBwYXJhbWV0ZXJzLFxuICAgICAgaXNBbm9ueW1vdXM6IGN0eC5Bbm9ueW1vdXNLZXl3b3JkKCkgIT09IHZvaWQgMFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdEJsb2NrKGN0eCkge1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIkJsb2NrXCIsXG4gICAgICBzdGF0ZW1lbnRzOiBjdHguc3RhdGVtZW50KCkubWFwKCh4KSA9PiB0aGlzLnZpc2l0U3RhdGVtZW50KHgpKVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdFBhcmFtZXRlcihjdHgpIHtcbiAgICBsZXQgc3RvcmFnZUxvY2F0aW9uID0gbnVsbDtcbiAgICBjb25zdCBjdHhTdG9yYWdlTG9jYXRpb24gPSBjdHguc3RvcmFnZUxvY2F0aW9uKCk7XG4gICAgaWYgKGN0eFN0b3JhZ2VMb2NhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICBzdG9yYWdlTG9jYXRpb24gPSB0aGlzLl90b1RleHQoY3R4U3RvcmFnZUxvY2F0aW9uKTtcbiAgICB9XG4gICAgbGV0IG5hbWUgPSBudWxsO1xuICAgIGNvbnN0IGN0eElkZW50aWZpZXIgPSBjdHguaWRlbnRpZmllcigpO1xuICAgIGlmIChjdHhJZGVudGlmaWVyICE9PSB2b2lkIDApIHtcbiAgICAgIG5hbWUgPSB0aGlzLl90b1RleHQoY3R4SWRlbnRpZmllcik7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIixcbiAgICAgIHR5cGVOYW1lOiB0aGlzLnZpc2l0VHlwZU5hbWUoY3R4LnR5cGVOYW1lKCkpLFxuICAgICAgbmFtZSxcbiAgICAgIGlkZW50aWZpZXI6IGN0eElkZW50aWZpZXIgIT09IHZvaWQgMCA/IHRoaXMudmlzaXRJZGVudGlmaWVyKGN0eElkZW50aWZpZXIpIDogbnVsbCxcbiAgICAgIHN0b3JhZ2VMb2NhdGlvbixcbiAgICAgIGlzU3RhdGVWYXI6IGZhbHNlLFxuICAgICAgaXNJbmRleGVkOiBmYWxzZSxcbiAgICAgIGV4cHJlc3Npb246IG51bGxcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gIH1cbiAgdmlzaXRGdW5jdGlvbkRlZmluaXRpb24oY3R4KSB7XG4gICAgbGV0IGlzQ29uc3RydWN0b3IgPSBmYWxzZTtcbiAgICBsZXQgaXNGYWxsYmFjayA9IGZhbHNlO1xuICAgIGxldCBpc1JlY2VpdmVFdGhlciA9IGZhbHNlO1xuICAgIGxldCBpc1ZpcnR1YWwgPSBmYWxzZTtcbiAgICBsZXQgbmFtZSA9IG51bGw7XG4gICAgbGV0IHBhcmFtZXRlcnMgPSBbXTtcbiAgICBsZXQgcmV0dXJuUGFyYW1ldGVycyA9IG51bGw7XG4gICAgbGV0IHZpc2liaWxpdHkgPSBcImRlZmF1bHRcIjtcbiAgICBsZXQgYmxvY2sgPSBudWxsO1xuICAgIGNvbnN0IGN0eEJsb2NrID0gY3R4LmJsb2NrKCk7XG4gICAgaWYgKGN0eEJsb2NrICE9PSB2b2lkIDApIHtcbiAgICAgIGJsb2NrID0gdGhpcy52aXNpdEJsb2NrKGN0eEJsb2NrKTtcbiAgICB9XG4gICAgY29uc3QgbW9kaWZpZXJzID0gY3R4Lm1vZGlmaWVyTGlzdCgpLm1vZGlmaWVySW52b2NhdGlvbigpLm1hcCgobW9kKSA9PiB0aGlzLnZpc2l0TW9kaWZpZXJJbnZvY2F0aW9uKG1vZCkpO1xuICAgIGxldCBzdGF0ZU11dGFiaWxpdHkgPSBudWxsO1xuICAgIGlmIChjdHgubW9kaWZpZXJMaXN0KCkuc3RhdGVNdXRhYmlsaXR5KCkubGVuZ3RoID4gMCkge1xuICAgICAgc3RhdGVNdXRhYmlsaXR5ID0gdGhpcy5fc3RhdGVNdXRhYmlsaXR5VG9UZXh0KGN0eC5tb2RpZmllckxpc3QoKS5zdGF0ZU11dGFiaWxpdHkoMCkpO1xuICAgIH1cbiAgICBjb25zdCBjdHhSZXR1cm5QYXJhbWV0ZXJzID0gY3R4LnJldHVyblBhcmFtZXRlcnMoKTtcbiAgICBzd2l0Y2ggKHRoaXMuX3RvVGV4dChjdHguZnVuY3Rpb25EZXNjcmlwdG9yKCkuZ2V0Q2hpbGQoMCkpKSB7XG4gICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjpcbiAgICAgICAgcGFyYW1ldGVycyA9IGN0eC5wYXJhbWV0ZXJMaXN0KCkucGFyYW1ldGVyKCkubWFwKCh4KSA9PiB0aGlzLnZpc2l0KHgpKTtcbiAgICAgICAgaWYgKGN0eC5tb2RpZmllckxpc3QoKS5JbnRlcm5hbEtleXdvcmQoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmlzaWJpbGl0eSA9IFwiaW50ZXJuYWxcIjtcbiAgICAgICAgfSBlbHNlIGlmIChjdHgubW9kaWZpZXJMaXN0KCkuUHVibGljS2V5d29yZCgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2aXNpYmlsaXR5ID0gXCJwdWJsaWNcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2aXNpYmlsaXR5ID0gXCJkZWZhdWx0XCI7XG4gICAgICAgIH1cbiAgICAgICAgaXNDb25zdHJ1Y3RvciA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZhbGxiYWNrXCI6XG4gICAgICAgIHBhcmFtZXRlcnMgPSBjdHgucGFyYW1ldGVyTGlzdCgpLnBhcmFtZXRlcigpLm1hcCgoeCkgPT4gdGhpcy52aXNpdCh4KSk7XG4gICAgICAgIHJldHVyblBhcmFtZXRlcnMgPSBjdHhSZXR1cm5QYXJhbWV0ZXJzICE9PSB2b2lkIDAgPyB0aGlzLnZpc2l0UmV0dXJuUGFyYW1ldGVycyhjdHhSZXR1cm5QYXJhbWV0ZXJzKSA6IG51bGw7XG4gICAgICAgIHZpc2liaWxpdHkgPSBcImV4dGVybmFsXCI7XG4gICAgICAgIGlzRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyZWNlaXZlXCI6XG4gICAgICAgIHZpc2liaWxpdHkgPSBcImV4dGVybmFsXCI7XG4gICAgICAgIGlzUmVjZWl2ZUV0aGVyID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZnVuY3Rpb25cIjoge1xuICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gY3R4LmZ1bmN0aW9uRGVzY3JpcHRvcigpLmlkZW50aWZpZXIoKTtcbiAgICAgICAgbmFtZSA9IGlkZW50aWZpZXIgIT09IHZvaWQgMCA/IHRoaXMuX3RvVGV4dChpZGVudGlmaWVyKSA6IFwiXCI7XG4gICAgICAgIHBhcmFtZXRlcnMgPSBjdHgucGFyYW1ldGVyTGlzdCgpLnBhcmFtZXRlcigpLm1hcCgoeCkgPT4gdGhpcy52aXNpdCh4KSk7XG4gICAgICAgIHJldHVyblBhcmFtZXRlcnMgPSBjdHhSZXR1cm5QYXJhbWV0ZXJzICE9PSB2b2lkIDAgPyB0aGlzLnZpc2l0UmV0dXJuUGFyYW1ldGVycyhjdHhSZXR1cm5QYXJhbWV0ZXJzKSA6IG51bGw7XG4gICAgICAgIGlmIChjdHgubW9kaWZpZXJMaXN0KCkuRXh0ZXJuYWxLZXl3b3JkKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZpc2liaWxpdHkgPSBcImV4dGVybmFsXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY3R4Lm1vZGlmaWVyTGlzdCgpLkludGVybmFsS2V5d29yZCgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2aXNpYmlsaXR5ID0gXCJpbnRlcm5hbFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGN0eC5tb2RpZmllckxpc3QoKS5QdWJsaWNLZXl3b3JkKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZpc2liaWxpdHkgPSBcInB1YmxpY1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGN0eC5tb2RpZmllckxpc3QoKS5Qcml2YXRlS2V5d29yZCgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2aXNpYmlsaXR5ID0gXCJwcml2YXRlXCI7XG4gICAgICAgIH1cbiAgICAgICAgaXNDb25zdHJ1Y3RvciA9IG5hbWUgPT09IHRoaXMuX2N1cnJlbnRDb250cmFjdDtcbiAgICAgICAgaXNGYWxsYmFjayA9IG5hbWUgPT09IFwiXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3R4Lm1vZGlmaWVyTGlzdCgpLlZpcnR1YWxLZXl3b3JkKCkubGVuZ3RoID4gMCkge1xuICAgICAgaXNWaXJ0dWFsID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IG92ZXJyaWRlO1xuICAgIGNvbnN0IG92ZXJyaWRlU3BlY2lmaWVyID0gY3R4Lm1vZGlmaWVyTGlzdCgpLm92ZXJyaWRlU3BlY2lmaWVyKCk7XG4gICAgaWYgKG92ZXJyaWRlU3BlY2lmaWVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgb3ZlcnJpZGUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdmVycmlkZSA9IG92ZXJyaWRlU3BlY2lmaWVyWzBdLnVzZXJEZWZpbmVkVHlwZU5hbWUoKS5tYXAoKHgpID0+IHRoaXMudmlzaXRVc2VyRGVmaW5lZFR5cGVOYW1lKHgpKTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiRnVuY3Rpb25EZWZpbml0aW9uXCIsXG4gICAgICBuYW1lLFxuICAgICAgcGFyYW1ldGVycyxcbiAgICAgIHJldHVyblBhcmFtZXRlcnMsXG4gICAgICBib2R5OiBibG9jayxcbiAgICAgIHZpc2liaWxpdHksXG4gICAgICBtb2RpZmllcnMsXG4gICAgICBvdmVycmlkZSxcbiAgICAgIGlzQ29uc3RydWN0b3IsXG4gICAgICBpc1JlY2VpdmVFdGhlcixcbiAgICAgIGlzRmFsbGJhY2ssXG4gICAgICBpc1ZpcnR1YWwsXG4gICAgICBzdGF0ZU11dGFiaWxpdHlcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gIH1cbiAgdmlzaXRFbnVtRGVmaW5pdGlvbihjdHgpIHtcbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgdHlwZTogXCJFbnVtRGVmaW5pdGlvblwiLFxuICAgICAgbmFtZTogdGhpcy5fdG9UZXh0KGN0eC5pZGVudGlmaWVyKCkpLFxuICAgICAgbWVtYmVyczogY3R4LmVudW1WYWx1ZSgpLm1hcCgoeCkgPT4gdGhpcy52aXNpdEVudW1WYWx1ZSh4KSlcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gIH1cbiAgdmlzaXRFbnVtVmFsdWUoY3R4KSB7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiRW51bVZhbHVlXCIsXG4gICAgICBuYW1lOiB0aGlzLl90b1RleHQoY3R4LmlkZW50aWZpZXIoKSlcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gIH1cbiAgdmlzaXRFbGVtZW50YXJ5VHlwZU5hbWUoY3R4KSB7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiRWxlbWVudGFyeVR5cGVOYW1lXCIsXG4gICAgICBuYW1lOiB0aGlzLl90b1RleHQoY3R4KSxcbiAgICAgIHN0YXRlTXV0YWJpbGl0eTogbnVsbFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdElkZW50aWZpZXIoY3R4KSB7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiSWRlbnRpZmllclwiLFxuICAgICAgbmFtZTogdGhpcy5fdG9UZXh0KGN0eClcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gIH1cbiAgdmlzaXRUeXBlTmFtZShjdHgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGN0eC5jaGlsZHJlbiAhPT0gdm9pZCAwICYmIGN0eC5jaGlsZHJlbi5sZW5ndGggPiAyKSB7XG4gICAgICBsZXQgbGVuZ3RoID0gbnVsbDtcbiAgICAgIGlmIChjdHguY2hpbGRyZW4ubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBjdHguZXhwcmVzc2lvbigpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0aW9uIGVycm9yOiBhIHR5cGVOYW1lIHdpdGggNCBjaGlsZHJlbiBzaG91bGQgaGF2ZSBhbiBleHByZXNzaW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCA9IHRoaXMudmlzaXRFeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICAgICAgfVxuICAgICAgY29uc3QgY3R4VHlwZU5hbWUgPSBjdHgudHlwZU5hbWUoKTtcbiAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgIHR5cGU6IFwiQXJyYXlUeXBlTmFtZVwiLFxuICAgICAgICBiYXNlVHlwZU5hbWU6IHRoaXMudmlzaXRUeXBlTmFtZShjdHhUeXBlTmFtZSksXG4gICAgICAgIGxlbmd0aFxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gICAgfVxuICAgIGlmICgoKF9hID0gY3R4LmNoaWxkcmVuKSA9PSBudWxsID8gdm9pZCAwIDogX2EubGVuZ3RoKSA9PT0gMikge1xuICAgICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgdHlwZTogXCJFbGVtZW50YXJ5VHlwZU5hbWVcIixcbiAgICAgICAgbmFtZTogdGhpcy5fdG9UZXh0KGN0eC5nZXRDaGlsZCgwKSksXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogdGhpcy5fdG9UZXh0KGN0eC5nZXRDaGlsZCgxKSlcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICAgIH1cbiAgICBpZiAoY3R4LmVsZW1lbnRhcnlUeXBlTmFtZSgpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLnZpc2l0RWxlbWVudGFyeVR5cGVOYW1lKGN0eC5lbGVtZW50YXJ5VHlwZU5hbWUoKSk7XG4gICAgfVxuICAgIGlmIChjdHgudXNlckRlZmluZWRUeXBlTmFtZSgpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLnZpc2l0VXNlckRlZmluZWRUeXBlTmFtZShjdHgudXNlckRlZmluZWRUeXBlTmFtZSgpKTtcbiAgICB9XG4gICAgaWYgKGN0eC5tYXBwaW5nKCkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlzaXRNYXBwaW5nKGN0eC5tYXBwaW5nKCkpO1xuICAgIH1cbiAgICBpZiAoY3R4LmZ1bmN0aW9uVHlwZU5hbWUoKSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy52aXNpdEZ1bmN0aW9uVHlwZU5hbWUoY3R4LmZ1bmN0aW9uVHlwZU5hbWUoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkFzc2VydGlvbiBlcnJvcjogdW5oYW5kbGVkIHR5cGUgbmFtZSBjYXNlXCIpO1xuICB9XG4gIHZpc2l0VXNlckRlZmluZWRUeXBlTmFtZShjdHgpIHtcbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgdHlwZTogXCJVc2VyRGVmaW5lZFR5cGVOYW1lXCIsXG4gICAgICBuYW1lUGF0aDogdGhpcy5fdG9UZXh0KGN0eClcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gIH1cbiAgdmlzaXRVc2luZ0ZvckRlY2xhcmF0aW9uKGN0eCkge1xuICAgIGxldCB0eXBlTmFtZSA9IG51bGw7XG4gICAgY29uc3QgY3R4VHlwZU5hbWUgPSBjdHgudHlwZU5hbWUoKTtcbiAgICBpZiAoY3R4VHlwZU5hbWUgIT09IHZvaWQgMCkge1xuICAgICAgdHlwZU5hbWUgPSB0aGlzLnZpc2l0VHlwZU5hbWUoY3R4VHlwZU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBpc0dsb2JhbCA9IGN0eC5HbG9iYWxLZXl3b3JkKCkgIT09IHZvaWQgMDtcbiAgICBsZXQgbm9kZTtcbiAgICBjb25zdCB1c2luZ0Zvck9iamVjdCA9IGN0eC51c2luZ0Zvck9iamVjdCgpO1xuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSB0aGlzLl90b1RleHQodXNpbmdGb3JPYmplY3QuZ2V0Q2hpbGQoMCkpO1xuICAgIGlmIChmaXJzdENoaWxkID09PSBcIntcIikge1xuICAgICAgbm9kZSA9IHtcbiAgICAgICAgdHlwZTogXCJVc2luZ0ZvckRlY2xhcmF0aW9uXCIsXG4gICAgICAgIGlzR2xvYmFsLFxuICAgICAgICB0eXBlTmFtZSxcbiAgICAgICAgbGlicmFyeU5hbWU6IG51bGwsXG4gICAgICAgIGZ1bmN0aW9uczogdXNpbmdGb3JPYmplY3QudXNlckRlZmluZWRUeXBlTmFtZSgpLm1hcCgoeCkgPT4gdGhpcy5fdG9UZXh0KHgpKVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IHtcbiAgICAgICAgdHlwZTogXCJVc2luZ0ZvckRlY2xhcmF0aW9uXCIsXG4gICAgICAgIGlzR2xvYmFsLFxuICAgICAgICB0eXBlTmFtZSxcbiAgICAgICAgbGlicmFyeU5hbWU6IHRoaXMuX3RvVGV4dCh1c2luZ0Zvck9iamVjdC51c2VyRGVmaW5lZFR5cGVOYW1lKDApKSxcbiAgICAgICAgZnVuY3Rpb25zOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdFByYWdtYURpcmVjdGl2ZShjdHgpIHtcbiAgICBjb25zdCB2ZXJzaW9uQ29udGV4dCA9IGN0eC5wcmFnbWFWYWx1ZSgpLnZlcnNpb24oKTtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLl90b1RleHQoY3R4LnByYWdtYVZhbHVlKCkpO1xuICAgIGlmICgodmVyc2lvbkNvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHZlcnNpb25Db250ZXh0LmNoaWxkcmVuKSAhPT0gdm9pZCAwKSB7XG4gICAgICB2YWx1ZSA9IHZlcnNpb25Db250ZXh0LmNoaWxkcmVuLm1hcCgoeCkgPT4gdGhpcy5fdG9UZXh0KHgpKS5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiUHJhZ21hRGlyZWN0aXZlXCIsXG4gICAgICBuYW1lOiB0aGlzLl90b1RleHQoY3R4LnByYWdtYU5hbWUoKSksXG4gICAgICB2YWx1ZVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdEluaGVyaXRhbmNlU3BlY2lmaWVyKGN0eCkge1xuICAgIGNvbnN0IGV4cHJMaXN0ID0gY3R4LmV4cHJlc3Npb25MaXN0KCk7XG4gICAgY29uc3QgYXJncyA9IGV4cHJMaXN0ICE9PSB2b2lkIDAgPyBleHByTGlzdC5leHByZXNzaW9uKCkubWFwKCh4KSA9PiB0aGlzLnZpc2l0RXhwcmVzc2lvbih4KSkgOiBbXTtcbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgdHlwZTogXCJJbmhlcml0YW5jZVNwZWNpZmllclwiLFxuICAgICAgYmFzZU5hbWU6IHRoaXMudmlzaXRVc2VyRGVmaW5lZFR5cGVOYW1lKGN0eC51c2VyRGVmaW5lZFR5cGVOYW1lKCkpLFxuICAgICAgYXJndW1lbnRzOiBhcmdzXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICB9XG4gIHZpc2l0TW9kaWZpZXJJbnZvY2F0aW9uKGN0eCkge1xuICAgIGNvbnN0IGV4cHJMaXN0ID0gY3R4LmV4cHJlc3Npb25MaXN0KCk7XG4gICAgbGV0IGFyZ3M7XG4gICAgaWYgKGV4cHJMaXN0ICE9IG51bGwpIHtcbiAgICAgIGFyZ3MgPSBleHByTGlzdC5leHByZXNzaW9uKCkubWFwKCh4KSA9PiB0aGlzLnZpc2l0KHgpKTtcbiAgICB9IGVsc2UgaWYgKGN0eC5jaGlsZHJlbiAhPT0gdm9pZCAwICYmIGN0eC5jaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICBhcmdzID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3MgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgdHlwZTogXCJNb2RpZmllckludm9jYXRpb25cIixcbiAgICAgIG5hbWU6IHRoaXMuX3RvVGV4dChjdHguaWRlbnRpZmllcigpKSxcbiAgICAgIGFyZ3VtZW50czogYXJnc1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdEZ1bmN0aW9uVHlwZU5hbWUoY3R4KSB7XG4gICAgY29uc3QgcGFyYW1ldGVyVHlwZXMgPSBjdHguZnVuY3Rpb25UeXBlUGFyYW1ldGVyTGlzdCgwKS5mdW5jdGlvblR5cGVQYXJhbWV0ZXIoKS5tYXAoKHR5cGVDdHgpID0+IHRoaXMudmlzaXRGdW5jdGlvblR5cGVQYXJhbWV0ZXIodHlwZUN0eCkpO1xuICAgIGxldCByZXR1cm5UeXBlcyA9IFtdO1xuICAgIGlmIChjdHguZnVuY3Rpb25UeXBlUGFyYW1ldGVyTGlzdCgpLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVyblR5cGVzID0gY3R4LmZ1bmN0aW9uVHlwZVBhcmFtZXRlckxpc3QoMSkuZnVuY3Rpb25UeXBlUGFyYW1ldGVyKCkubWFwKCh0eXBlQ3R4KSA9PiB0aGlzLnZpc2l0RnVuY3Rpb25UeXBlUGFyYW1ldGVyKHR5cGVDdHgpKTtcbiAgICB9XG4gICAgbGV0IHZpc2liaWxpdHkgPSBcImRlZmF1bHRcIjtcbiAgICBpZiAoY3R4LkludGVybmFsS2V5d29yZCgpLmxlbmd0aCA+IDApIHtcbiAgICAgIHZpc2liaWxpdHkgPSBcImludGVybmFsXCI7XG4gICAgfSBlbHNlIGlmIChjdHguRXh0ZXJuYWxLZXl3b3JkKCkubGVuZ3RoID4gMCkge1xuICAgICAgdmlzaWJpbGl0eSA9IFwiZXh0ZXJuYWxcIjtcbiAgICB9XG4gICAgbGV0IHN0YXRlTXV0YWJpbGl0eSA9IG51bGw7XG4gICAgaWYgKGN0eC5zdGF0ZU11dGFiaWxpdHkoKS5sZW5ndGggPiAwKSB7XG4gICAgICBzdGF0ZU11dGFiaWxpdHkgPSB0aGlzLl90b1RleHQoY3R4LnN0YXRlTXV0YWJpbGl0eSgwKSk7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIkZ1bmN0aW9uVHlwZU5hbWVcIixcbiAgICAgIHBhcmFtZXRlclR5cGVzLFxuICAgICAgcmV0dXJuVHlwZXMsXG4gICAgICB2aXNpYmlsaXR5LFxuICAgICAgc3RhdGVNdXRhYmlsaXR5XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICB9XG4gIHZpc2l0RnVuY3Rpb25UeXBlUGFyYW1ldGVyKGN0eCkge1xuICAgIGxldCBzdG9yYWdlTG9jYXRpb24gPSBudWxsO1xuICAgIGlmIChjdHguc3RvcmFnZUxvY2F0aW9uKCkpIHtcbiAgICAgIHN0b3JhZ2VMb2NhdGlvbiA9IHRoaXMuX3RvVGV4dChjdHguc3RvcmFnZUxvY2F0aW9uKCkpO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgdHlwZTogXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXG4gICAgICB0eXBlTmFtZTogdGhpcy52aXNpdFR5cGVOYW1lKGN0eC50eXBlTmFtZSgpKSxcbiAgICAgIG5hbWU6IG51bGwsXG4gICAgICBpZGVudGlmaWVyOiBudWxsLFxuICAgICAgc3RvcmFnZUxvY2F0aW9uLFxuICAgICAgaXNTdGF0ZVZhcjogZmFsc2UsXG4gICAgICBpc0luZGV4ZWQ6IGZhbHNlLFxuICAgICAgZXhwcmVzc2lvbjogbnVsbFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdFRocm93U3RhdGVtZW50KGN0eCkge1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIlRocm93U3RhdGVtZW50XCJcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gIH1cbiAgdmlzaXRSZXR1cm5TdGF0ZW1lbnQoY3R4KSB7XG4gICAgbGV0IGV4cHJlc3Npb24gPSBudWxsO1xuICAgIGNvbnN0IGN0eEV4cHJlc3Npb24gPSBjdHguZXhwcmVzc2lvbigpO1xuICAgIGlmIChjdHhFeHByZXNzaW9uKSB7XG4gICAgICBleHByZXNzaW9uID0gdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4RXhwcmVzc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIlJldHVyblN0YXRlbWVudFwiLFxuICAgICAgZXhwcmVzc2lvblxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdEVtaXRTdGF0ZW1lbnQoY3R4KSB7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiRW1pdFN0YXRlbWVudFwiLFxuICAgICAgZXZlbnRDYWxsOiB0aGlzLnZpc2l0RnVuY3Rpb25DYWxsKGN0eC5mdW5jdGlvbkNhbGwoKSlcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gIH1cbiAgdmlzaXRDdXN0b21FcnJvckRlZmluaXRpb24oY3R4KSB7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiQ3VzdG9tRXJyb3JEZWZpbml0aW9uXCIsXG4gICAgICBuYW1lOiB0aGlzLl90b1RleHQoY3R4LmlkZW50aWZpZXIoKSksXG4gICAgICBwYXJhbWV0ZXJzOiB0aGlzLnZpc2l0UGFyYW1ldGVyTGlzdChjdHgucGFyYW1ldGVyTGlzdCgpKVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdFR5cGVEZWZpbml0aW9uKGN0eCkge1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIlR5cGVEZWZpbml0aW9uXCIsXG4gICAgICBuYW1lOiB0aGlzLl90b1RleHQoY3R4LmlkZW50aWZpZXIoKSksXG4gICAgICBkZWZpbml0aW9uOiB0aGlzLnZpc2l0RWxlbWVudGFyeVR5cGVOYW1lKGN0eC5lbGVtZW50YXJ5VHlwZU5hbWUoKSlcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gIH1cbiAgdmlzaXRSZXZlcnRTdGF0ZW1lbnQoY3R4KSB7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiUmV2ZXJ0U3RhdGVtZW50XCIsXG4gICAgICByZXZlcnRDYWxsOiB0aGlzLnZpc2l0RnVuY3Rpb25DYWxsKGN0eC5mdW5jdGlvbkNhbGwoKSlcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gIH1cbiAgdmlzaXRGdW5jdGlvbkNhbGwoY3R4KSB7XG4gICAgbGV0IGFyZ3MgPSBbXTtcbiAgICBjb25zdCBuYW1lcyA9IFtdO1xuICAgIGNvbnN0IGlkZW50aWZpZXJzID0gW107XG4gICAgY29uc3QgY3R4QXJncyA9IGN0eC5mdW5jdGlvbkNhbGxBcmd1bWVudHMoKTtcbiAgICBjb25zdCBjdHhBcmdzRXhwcmVzc2lvbkxpc3QgPSBjdHhBcmdzLmV4cHJlc3Npb25MaXN0KCk7XG4gICAgY29uc3QgY3R4QXJnc05hbWVWYWx1ZUxpc3QgPSBjdHhBcmdzLm5hbWVWYWx1ZUxpc3QoKTtcbiAgICBpZiAoY3R4QXJnc0V4cHJlc3Npb25MaXN0KSB7XG4gICAgICBhcmdzID0gY3R4QXJnc0V4cHJlc3Npb25MaXN0LmV4cHJlc3Npb24oKS5tYXAoKGV4cHJDdHgpID0+IHRoaXMudmlzaXRFeHByZXNzaW9uKGV4cHJDdHgpKTtcbiAgICB9IGVsc2UgaWYgKGN0eEFyZ3NOYW1lVmFsdWVMaXN0KSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWVWYWx1ZSBvZiBjdHhBcmdzTmFtZVZhbHVlTGlzdC5uYW1lVmFsdWUoKSkge1xuICAgICAgICBhcmdzLnB1c2godGhpcy52aXNpdEV4cHJlc3Npb24obmFtZVZhbHVlLmV4cHJlc3Npb24oKSkpO1xuICAgICAgICBuYW1lcy5wdXNoKHRoaXMuX3RvVGV4dChuYW1lVmFsdWUuaWRlbnRpZmllcigpKSk7XG4gICAgICAgIGlkZW50aWZpZXJzLnB1c2godGhpcy52aXNpdElkZW50aWZpZXIobmFtZVZhbHVlLmlkZW50aWZpZXIoKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgdHlwZTogXCJGdW5jdGlvbkNhbGxcIixcbiAgICAgIGV4cHJlc3Npb246IHRoaXMudmlzaXRFeHByZXNzaW9uKGN0eC5leHByZXNzaW9uKCkpLFxuICAgICAgYXJndW1lbnRzOiBhcmdzLFxuICAgICAgbmFtZXMsXG4gICAgICBpZGVudGlmaWVyc1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdFN0cnVjdERlZmluaXRpb24oY3R4KSB7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiU3RydWN0RGVmaW5pdGlvblwiLFxuICAgICAgbmFtZTogdGhpcy5fdG9UZXh0KGN0eC5pZGVudGlmaWVyKCkpLFxuICAgICAgbWVtYmVyczogY3R4LnZhcmlhYmxlRGVjbGFyYXRpb24oKS5tYXAoKHgpID0+IHRoaXMudmlzaXRWYXJpYWJsZURlY2xhcmF0aW9uKHgpKVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdFdoaWxlU3RhdGVtZW50KGN0eCkge1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIldoaWxlU3RhdGVtZW50XCIsXG4gICAgICBjb25kaXRpb246IHRoaXMudmlzaXRFeHByZXNzaW9uKGN0eC5leHByZXNzaW9uKCkpLFxuICAgICAgYm9keTogdGhpcy52aXNpdFN0YXRlbWVudChjdHguc3RhdGVtZW50KCkpXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICB9XG4gIHZpc2l0RG9XaGlsZVN0YXRlbWVudChjdHgpIHtcbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgdHlwZTogXCJEb1doaWxlU3RhdGVtZW50XCIsXG4gICAgICBjb25kaXRpb246IHRoaXMudmlzaXRFeHByZXNzaW9uKGN0eC5leHByZXNzaW9uKCkpLFxuICAgICAgYm9keTogdGhpcy52aXNpdFN0YXRlbWVudChjdHguc3RhdGVtZW50KCkpXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICB9XG4gIHZpc2l0SWZTdGF0ZW1lbnQoY3R4KSB7XG4gICAgY29uc3QgdHJ1ZUJvZHkgPSB0aGlzLnZpc2l0U3RhdGVtZW50KGN0eC5zdGF0ZW1lbnQoMCkpO1xuICAgIGxldCBmYWxzZUJvZHkgPSBudWxsO1xuICAgIGlmIChjdHguc3RhdGVtZW50KCkubGVuZ3RoID4gMSkge1xuICAgICAgZmFsc2VCb2R5ID0gdGhpcy52aXNpdFN0YXRlbWVudChjdHguc3RhdGVtZW50KDEpKTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiSWZTdGF0ZW1lbnRcIixcbiAgICAgIGNvbmRpdGlvbjogdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmV4cHJlc3Npb24oKSksXG4gICAgICB0cnVlQm9keSxcbiAgICAgIGZhbHNlQm9keVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdFRyeVN0YXRlbWVudChjdHgpIHtcbiAgICBsZXQgcmV0dXJuUGFyYW1ldGVycyA9IG51bGw7XG4gICAgY29uc3QgY3R4UmV0dXJuUGFyYW1ldGVycyA9IGN0eC5yZXR1cm5QYXJhbWV0ZXJzKCk7XG4gICAgaWYgKGN0eFJldHVyblBhcmFtZXRlcnMgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuUGFyYW1ldGVycyA9IHRoaXMudmlzaXRSZXR1cm5QYXJhbWV0ZXJzKGN0eFJldHVyblBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBjYXRjaENsYXVzZXMgPSBjdHguY2F0Y2hDbGF1c2UoKS5tYXAoKGV4cHJDdHgpID0+IHRoaXMudmlzaXRDYXRjaENsYXVzZShleHByQ3R4KSk7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiVHJ5U3RhdGVtZW50XCIsXG4gICAgICBleHByZXNzaW9uOiB0aGlzLnZpc2l0RXhwcmVzc2lvbihjdHguZXhwcmVzc2lvbigpKSxcbiAgICAgIHJldHVyblBhcmFtZXRlcnMsXG4gICAgICBib2R5OiB0aGlzLnZpc2l0QmxvY2soY3R4LmJsb2NrKCkpLFxuICAgICAgY2F0Y2hDbGF1c2VzXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICB9XG4gIHZpc2l0Q2F0Y2hDbGF1c2UoY3R4KSB7XG4gICAgbGV0IHBhcmFtZXRlcnMgPSBudWxsO1xuICAgIGlmIChjdHgucGFyYW1ldGVyTGlzdCgpKSB7XG4gICAgICBwYXJhbWV0ZXJzID0gdGhpcy52aXNpdFBhcmFtZXRlckxpc3QoY3R4LnBhcmFtZXRlckxpc3QoKSk7XG4gICAgfVxuICAgIGlmIChjdHguaWRlbnRpZmllcigpICYmIHRoaXMuX3RvVGV4dChjdHguaWRlbnRpZmllcigpKSAhPT0gXCJFcnJvclwiICYmIHRoaXMuX3RvVGV4dChjdHguaWRlbnRpZmllcigpKSAhPT0gXCJQYW5pY1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFwiRXJyb3JcIiBvciBcIlBhbmljXCIgaWRlbnRpZmllciBpbiBjYXRjaCBjbGF1c2UnKTtcbiAgICB9XG4gICAgbGV0IGtpbmQgPSBudWxsO1xuICAgIGNvbnN0IGN0eElkZW50aWZpZXIgPSBjdHguaWRlbnRpZmllcigpO1xuICAgIGlmIChjdHhJZGVudGlmaWVyICE9PSB2b2lkIDApIHtcbiAgICAgIGtpbmQgPSB0aGlzLl90b1RleHQoY3R4SWRlbnRpZmllcik7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIkNhdGNoQ2xhdXNlXCIsXG4gICAgICBpc1JlYXNvblN0cmluZ1R5cGU6IGtpbmQgPT09IFwiRXJyb3JcIixcbiAgICAgIGtpbmQsXG4gICAgICBwYXJhbWV0ZXJzLFxuICAgICAgYm9keTogdGhpcy52aXNpdEJsb2NrKGN0eC5ibG9jaygpKVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdEV4cHJlc3Npb25TdGF0ZW1lbnQoY3R4KSB7XG4gICAgaWYgKCFjdHgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgdHlwZTogXCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXG4gICAgICBleHByZXNzaW9uOiB0aGlzLnZpc2l0RXhwcmVzc2lvbihjdHguZXhwcmVzc2lvbigpKVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdE51bWJlckxpdGVyYWwoY3R4KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG51bWJlciA9IHRoaXMuX3RvVGV4dChjdHguZ2V0Q2hpbGQoMCkpO1xuICAgIGxldCBzdWJkZW5vbWluYXRpb24gPSBudWxsO1xuICAgIGlmICgoKF9hID0gY3R4LmNoaWxkcmVuKSA9PSBudWxsID8gdm9pZCAwIDogX2EubGVuZ3RoKSA9PT0gMikge1xuICAgICAgc3ViZGVub21pbmF0aW9uID0gdGhpcy5fdG9UZXh0KGN0eC5nZXRDaGlsZCgxKSk7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIk51bWJlckxpdGVyYWxcIixcbiAgICAgIG51bWJlcixcbiAgICAgIHN1YmRlbm9taW5hdGlvblxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdE1hcHBpbmdLZXkoY3R4KSB7XG4gICAgaWYgKGN0eC5lbGVtZW50YXJ5VHlwZU5hbWUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMudmlzaXRFbGVtZW50YXJ5VHlwZU5hbWUoY3R4LmVsZW1lbnRhcnlUeXBlTmFtZSgpKTtcbiAgICB9IGVsc2UgaWYgKGN0eC51c2VyRGVmaW5lZFR5cGVOYW1lKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpc2l0VXNlckRlZmluZWRUeXBlTmFtZShjdHgudXNlckRlZmluZWRUeXBlTmFtZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgTWFwcGluZ0tleSB0byBoYXZlIGVpdGhlciBlbGVtZW50YXJ5VHlwZU5hbWUgb3IgdXNlckRlZmluZWRUeXBlTmFtZVwiKTtcbiAgICB9XG4gIH1cbiAgdmlzaXRNYXBwaW5nKGN0eCkge1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIk1hcHBpbmdcIixcbiAgICAgIGtleVR5cGU6IHRoaXMudmlzaXRNYXBwaW5nS2V5KGN0eC5tYXBwaW5nS2V5KCkpLFxuICAgICAgdmFsdWVUeXBlOiB0aGlzLnZpc2l0VHlwZU5hbWUoY3R4LnR5cGVOYW1lKCkpXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICB9XG4gIHZpc2l0TW9kaWZpZXJEZWZpbml0aW9uKGN0eCkge1xuICAgIGxldCBwYXJhbWV0ZXJzID0gbnVsbDtcbiAgICBpZiAoY3R4LnBhcmFtZXRlckxpc3QoKSkge1xuICAgICAgcGFyYW1ldGVycyA9IHRoaXMudmlzaXRQYXJhbWV0ZXJMaXN0KGN0eC5wYXJhbWV0ZXJMaXN0KCkpO1xuICAgIH1cbiAgICBsZXQgaXNWaXJ0dWFsID0gZmFsc2U7XG4gICAgaWYgKGN0eC5WaXJ0dWFsS2V5d29yZCgpLmxlbmd0aCA+IDApIHtcbiAgICAgIGlzVmlydHVhbCA9IHRydWU7XG4gICAgfVxuICAgIGxldCBvdmVycmlkZTtcbiAgICBjb25zdCBvdmVycmlkZVNwZWNpZmllciA9IGN0eC5vdmVycmlkZVNwZWNpZmllcigpO1xuICAgIGlmIChvdmVycmlkZVNwZWNpZmllci5sZW5ndGggPT09IDApIHtcbiAgICAgIG92ZXJyaWRlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3ZlcnJpZGUgPSBvdmVycmlkZVNwZWNpZmllclswXS51c2VyRGVmaW5lZFR5cGVOYW1lKCkubWFwKCh4KSA9PiB0aGlzLnZpc2l0VXNlckRlZmluZWRUeXBlTmFtZSh4KSk7XG4gICAgfVxuICAgIGxldCBib2R5ID0gbnVsbDtcbiAgICBjb25zdCBibG9ja0N0eCA9IGN0eC5ibG9jaygpO1xuICAgIGlmIChibG9ja0N0eCAhPT0gdm9pZCAwKSB7XG4gICAgICBib2R5ID0gdGhpcy52aXNpdEJsb2NrKGJsb2NrQ3R4KTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiTW9kaWZpZXJEZWZpbml0aW9uXCIsXG4gICAgICBuYW1lOiB0aGlzLl90b1RleHQoY3R4LmlkZW50aWZpZXIoKSksXG4gICAgICBwYXJhbWV0ZXJzLFxuICAgICAgYm9keSxcbiAgICAgIGlzVmlydHVhbCxcbiAgICAgIG92ZXJyaWRlXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICB9XG4gIHZpc2l0VW5jaGVja2VkU3RhdGVtZW50KGN0eCkge1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIlVuY2hlY2tlZFN0YXRlbWVudFwiLFxuICAgICAgYmxvY2s6IHRoaXMudmlzaXRCbG9jayhjdHguYmxvY2soKSlcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gIH1cbiAgdmlzaXRFeHByZXNzaW9uKGN0eCkge1xuICAgIGxldCBvcDtcbiAgICBzd2l0Y2ggKGN0eC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMToge1xuICAgICAgICBjb25zdCBwcmltYXJ5RXhwcmVzc2lvbkN0eCA9IGN0eC50cnlHZXRSdWxlQ29udGV4dCgwLCBQcmltYXJ5RXhwcmVzc2lvbkNvbnRleHQpO1xuICAgICAgICBpZiAocHJpbWFyeUV4cHJlc3Npb25DdHggPT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzc2VydGlvbiBlcnJvcjogcHJpbWFyeSBleHByZXNzaW9uIHNob3VsZCBleGlzdCB3aGVuIGNoaWxkcmVuIGxlbmd0aCBpcyAxXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0UHJpbWFyeUV4cHJlc3Npb24ocHJpbWFyeUV4cHJlc3Npb25DdHgpO1xuICAgICAgfVxuICAgICAgY2FzZSAyOlxuICAgICAgICBvcCA9IHRoaXMuX3RvVGV4dChjdHguZ2V0Q2hpbGQoMCkpO1xuICAgICAgICBpZiAob3AgPT09IFwibmV3XCIpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICAgICAgdHlwZTogXCJOZXdFeHByZXNzaW9uXCIsXG4gICAgICAgICAgICB0eXBlTmFtZTogdGhpcy52aXNpdFR5cGVOYW1lKGN0eC50eXBlTmFtZSgpKVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5hcnlPcFZhbHVlcy5pbmNsdWRlcyhvcCkpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICAgICAgdHlwZTogXCJVbmFyeU9wZXJhdGlvblwiLFxuICAgICAgICAgICAgb3BlcmF0b3I6IG9wLFxuICAgICAgICAgICAgc3ViRXhwcmVzc2lvbjogdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmdldFJ1bGVDb250ZXh0KDAsIEV4cHJlc3Npb25Db250ZXh0KSksXG4gICAgICAgICAgICBpc1ByZWZpeDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBvcCA9IHRoaXMuX3RvVGV4dChjdHguZ2V0Q2hpbGQoMSkpO1xuICAgICAgICBpZiAoW1wiKytcIiwgXCItLVwiXS5pbmNsdWRlcyhvcCkpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICAgICAgdHlwZTogXCJVbmFyeU9wZXJhdGlvblwiLFxuICAgICAgICAgICAgb3BlcmF0b3I6IG9wLFxuICAgICAgICAgICAgc3ViRXhwcmVzc2lvbjogdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmdldFJ1bGVDb250ZXh0KDAsIEV4cHJlc3Npb25Db250ZXh0KSksXG4gICAgICAgICAgICBpc1ByZWZpeDogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGlmICh0aGlzLl90b1RleHQoY3R4LmdldENoaWxkKDApKSA9PT0gXCIoXCIgJiYgdGhpcy5fdG9UZXh0KGN0eC5nZXRDaGlsZCgyKSkgPT09IFwiKVwiKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiVHVwbGVFeHByZXNzaW9uXCIsXG4gICAgICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICAgIHRoaXMudmlzaXRFeHByZXNzaW9uKGN0eC5nZXRSdWxlQ29udGV4dCgwLCBFeHByZXNzaW9uQ29udGV4dCkpXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaXNBcnJheTogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgb3AgPSB0aGlzLl90b1RleHQoY3R4LmdldENoaWxkKDEpKTtcbiAgICAgICAgaWYgKG9wID09PSBcIi5cIikge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgICAgICB0eXBlOiBcIk1lbWJlckFjY2Vzc1wiLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmV4cHJlc3Npb24oMCkpLFxuICAgICAgICAgICAgbWVtYmVyTmFtZTogdGhpcy5fdG9UZXh0KGN0eC5pZGVudGlmaWVyKCkpXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Jpbk9wKG9wKSkge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgICAgICB0eXBlOiBcIkJpbmFyeU9wZXJhdGlvblwiLFxuICAgICAgICAgICAgb3BlcmF0b3I6IG9wLFxuICAgICAgICAgICAgbGVmdDogdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmV4cHJlc3Npb24oMCkpLFxuICAgICAgICAgICAgcmlnaHQ6IHRoaXMudmlzaXRFeHByZXNzaW9uKGN0eC5leHByZXNzaW9uKDEpKVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgaWYgKHRoaXMuX3RvVGV4dChjdHguZ2V0Q2hpbGQoMSkpID09PSBcIihcIiAmJiB0aGlzLl90b1RleHQoY3R4LmdldENoaWxkKDMpKSA9PT0gXCIpXCIpIHtcbiAgICAgICAgICBsZXQgYXJncyA9IFtdO1xuICAgICAgICAgIGNvbnN0IG5hbWVzID0gW107XG4gICAgICAgICAgY29uc3QgaWRlbnRpZmllcnMgPSBbXTtcbiAgICAgICAgICBjb25zdCBjdHhBcmdzID0gY3R4LmZ1bmN0aW9uQ2FsbEFyZ3VtZW50cygpO1xuICAgICAgICAgIGlmIChjdHhBcmdzLmV4cHJlc3Npb25MaXN0KCkpIHtcbiAgICAgICAgICAgIGFyZ3MgPSBjdHhBcmdzLmV4cHJlc3Npb25MaXN0KCkuZXhwcmVzc2lvbigpLm1hcCgoZXhwckN0eCkgPT4gdGhpcy52aXNpdEV4cHJlc3Npb24oZXhwckN0eCkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3R4QXJncy5uYW1lVmFsdWVMaXN0KCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZVZhbHVlIG9mIGN0eEFyZ3MubmFtZVZhbHVlTGlzdCgpLm5hbWVWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgIGFyZ3MucHVzaCh0aGlzLnZpc2l0RXhwcmVzc2lvbihuYW1lVmFsdWUuZXhwcmVzc2lvbigpKSk7XG4gICAgICAgICAgICAgIG5hbWVzLnB1c2godGhpcy5fdG9UZXh0KG5hbWVWYWx1ZS5pZGVudGlmaWVyKCkpKTtcbiAgICAgICAgICAgICAgaWRlbnRpZmllcnMucHVzaCh0aGlzLnZpc2l0SWRlbnRpZmllcihuYW1lVmFsdWUuaWRlbnRpZmllcigpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgICAgICB0eXBlOiBcIkZ1bmN0aW9uQ2FsbFwiLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmV4cHJlc3Npb24oMCkpLFxuICAgICAgICAgICAgYXJndW1lbnRzOiBhcmdzLFxuICAgICAgICAgICAgbmFtZXMsXG4gICAgICAgICAgICBpZGVudGlmaWVyc1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdG9UZXh0KGN0eC5nZXRDaGlsZCgxKSkgPT09IFwiW1wiICYmIHRoaXMuX3RvVGV4dChjdHguZ2V0Q2hpbGQoMykpID09PSBcIl1cIikge1xuICAgICAgICAgIGlmIChjdHguZ2V0Q2hpbGQoMikudGV4dCA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUyID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcIkluZGV4UmFuZ2VBY2Nlc3NcIixcbiAgICAgICAgICAgICAgYmFzZTogdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmV4cHJlc3Npb24oMCkpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZTIsIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgICAgICB0eXBlOiBcIkluZGV4QWNjZXNzXCIsXG4gICAgICAgICAgICBiYXNlOiB0aGlzLnZpc2l0RXhwcmVzc2lvbihjdHguZXhwcmVzc2lvbigwKSksXG4gICAgICAgICAgICBpbmRleDogdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmV4cHJlc3Npb24oMSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90b1RleHQoY3R4LmdldENoaWxkKDEpKSA9PT0gXCJ7XCIgJiYgdGhpcy5fdG9UZXh0KGN0eC5nZXRDaGlsZCgzKSkgPT09IFwifVwiKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiTmFtZVZhbHVlRXhwcmVzc2lvblwiLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmV4cHJlc3Npb24oMCkpLFxuICAgICAgICAgICAgYXJndW1lbnRzOiB0aGlzLnZpc2l0TmFtZVZhbHVlTGlzdChjdHgubmFtZVZhbHVlTGlzdCgpKVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgaWYgKHRoaXMuX3RvVGV4dChjdHguZ2V0Q2hpbGQoMSkpID09PSBcIj9cIiAmJiB0aGlzLl90b1RleHQoY3R4LmdldENoaWxkKDMpKSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICAgICAgdHlwZTogXCJDb25kaXRpb25hbFwiLFxuICAgICAgICAgICAgY29uZGl0aW9uOiB0aGlzLnZpc2l0RXhwcmVzc2lvbihjdHguZXhwcmVzc2lvbigwKSksXG4gICAgICAgICAgICB0cnVlRXhwcmVzc2lvbjogdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmV4cHJlc3Npb24oMSkpLFxuICAgICAgICAgICAgZmFsc2VFeHByZXNzaW9uOiB0aGlzLnZpc2l0RXhwcmVzc2lvbihjdHguZXhwcmVzc2lvbigyKSlcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3RvVGV4dChjdHguZ2V0Q2hpbGQoMSkpID09PSBcIltcIiAmJiB0aGlzLl90b1RleHQoY3R4LmdldENoaWxkKDIpKSA9PT0gXCI6XCIgJiYgdGhpcy5fdG9UZXh0KGN0eC5nZXRDaGlsZCg0KSkgPT09IFwiXVwiKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiSW5kZXhSYW5nZUFjY2Vzc1wiLFxuICAgICAgICAgICAgYmFzZTogdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmV4cHJlc3Npb24oMCkpLFxuICAgICAgICAgICAgaW5kZXhFbmQ6IHRoaXMudmlzaXRFeHByZXNzaW9uKGN0eC5leHByZXNzaW9uKDEpKVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl90b1RleHQoY3R4LmdldENoaWxkKDEpKSA9PT0gXCJbXCIgJiYgdGhpcy5fdG9UZXh0KGN0eC5nZXRDaGlsZCgzKSkgPT09IFwiOlwiICYmIHRoaXMuX3RvVGV4dChjdHguZ2V0Q2hpbGQoNCkpID09PSBcIl1cIikge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgICAgICB0eXBlOiBcIkluZGV4UmFuZ2VBY2Nlc3NcIixcbiAgICAgICAgICAgIGJhc2U6IHRoaXMudmlzaXRFeHByZXNzaW9uKGN0eC5leHByZXNzaW9uKDApKSxcbiAgICAgICAgICAgIGluZGV4U3RhcnQ6IHRoaXMudmlzaXRFeHByZXNzaW9uKGN0eC5leHByZXNzaW9uKDEpKVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgaWYgKHRoaXMuX3RvVGV4dChjdHguZ2V0Q2hpbGQoMSkpID09PSBcIltcIiAmJiB0aGlzLl90b1RleHQoY3R4LmdldENoaWxkKDMpKSA9PT0gXCI6XCIgJiYgdGhpcy5fdG9UZXh0KGN0eC5nZXRDaGlsZCg1KSkgPT09IFwiXVwiKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiSW5kZXhSYW5nZUFjY2Vzc1wiLFxuICAgICAgICAgICAgYmFzZTogdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmV4cHJlc3Npb24oMCkpLFxuICAgICAgICAgICAgaW5kZXhTdGFydDogdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmV4cHJlc3Npb24oMSkpLFxuICAgICAgICAgICAgaW5kZXhFbmQ6IHRoaXMudmlzaXRFeHByZXNzaW9uKGN0eC5leHByZXNzaW9uKDIpKVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIGV4cHJlc3Npb25cIik7XG4gIH1cbiAgdmlzaXROYW1lVmFsdWVMaXN0KGN0eCkge1xuICAgIGNvbnN0IG5hbWVzID0gW107XG4gICAgY29uc3QgaWRlbnRpZmllcnMgPSBbXTtcbiAgICBjb25zdCBhcmdzID0gW107XG4gICAgZm9yIChjb25zdCBuYW1lVmFsdWUgb2YgY3R4Lm5hbWVWYWx1ZSgpKSB7XG4gICAgICBuYW1lcy5wdXNoKHRoaXMuX3RvVGV4dChuYW1lVmFsdWUuaWRlbnRpZmllcigpKSk7XG4gICAgICBpZGVudGlmaWVycy5wdXNoKHRoaXMudmlzaXRJZGVudGlmaWVyKG5hbWVWYWx1ZS5pZGVudGlmaWVyKCkpKTtcbiAgICAgIGFyZ3MucHVzaCh0aGlzLnZpc2l0RXhwcmVzc2lvbihuYW1lVmFsdWUuZXhwcmVzc2lvbigpKSk7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIk5hbWVWYWx1ZUxpc3RcIixcbiAgICAgIG5hbWVzLFxuICAgICAgaWRlbnRpZmllcnMsXG4gICAgICBhcmd1bWVudHM6IGFyZ3NcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gIH1cbiAgdmlzaXRGaWxlTGV2ZWxDb25zdGFudChjdHgpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy52aXNpdFR5cGVOYW1lKGN0eC50eXBlTmFtZSgpKTtcbiAgICBjb25zdCBpZGVuID0gY3R4LmlkZW50aWZpZXIoKTtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5fdG9UZXh0KGlkZW4pO1xuICAgIGNvbnN0IGV4cHJlc3Npb24gPSB0aGlzLnZpc2l0RXhwcmVzc2lvbihjdHguZXhwcmVzc2lvbigpKTtcbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgdHlwZTogXCJGaWxlTGV2ZWxDb25zdGFudFwiLFxuICAgICAgdHlwZU5hbWU6IHR5cGUsXG4gICAgICBuYW1lLFxuICAgICAgaW5pdGlhbFZhbHVlOiBleHByZXNzaW9uLFxuICAgICAgaXNEZWNsYXJlZENvbnN0OiB0cnVlLFxuICAgICAgaXNJbW11dGFibGU6IGZhbHNlXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICB9XG4gIHZpc2l0Rm9yU3RhdGVtZW50KGN0eCkge1xuICAgIGxldCBjb25kaXRpb25FeHByZXNzaW9uID0gdGhpcy52aXNpdEV4cHJlc3Npb25TdGF0ZW1lbnQoY3R4LmV4cHJlc3Npb25TdGF0ZW1lbnQoKSk7XG4gICAgaWYgKGNvbmRpdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgIGNvbmRpdGlvbkV4cHJlc3Npb24gPSBjb25kaXRpb25FeHByZXNzaW9uLmV4cHJlc3Npb247XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIkZvclN0YXRlbWVudFwiLFxuICAgICAgaW5pdEV4cHJlc3Npb246IGN0eC5zaW1wbGVTdGF0ZW1lbnQoKSA/IHRoaXMudmlzaXRTaW1wbGVTdGF0ZW1lbnQoY3R4LnNpbXBsZVN0YXRlbWVudCgpKSA6IG51bGwsXG4gICAgICBjb25kaXRpb25FeHByZXNzaW9uLFxuICAgICAgbG9vcEV4cHJlc3Npb246IHtcbiAgICAgICAgdHlwZTogXCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXG4gICAgICAgIGV4cHJlc3Npb246IGN0eC5leHByZXNzaW9uKCkgIT09IHZvaWQgMCA/IHRoaXMudmlzaXRFeHByZXNzaW9uKGN0eC5leHByZXNzaW9uKCkpIDogbnVsbFxuICAgICAgfSxcbiAgICAgIGJvZHk6IHRoaXMudmlzaXRTdGF0ZW1lbnQoY3R4LnN0YXRlbWVudCgpKVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdEhleExpdGVyYWwoY3R4KSB7XG4gICAgY29uc3QgcGFydHMgPSBjdHguSGV4TGl0ZXJhbEZyYWdtZW50KCkubWFwKCh4KSA9PiB0aGlzLl90b1RleHQoeCkpLm1hcCgoeCkgPT4geC5zdWJzdHJpbmcoNCwgeC5sZW5ndGggLSAxKSk7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiSGV4TGl0ZXJhbFwiLFxuICAgICAgdmFsdWU6IHBhcnRzLmpvaW4oXCJcIiksXG4gICAgICBwYXJ0c1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdFByaW1hcnlFeHByZXNzaW9uKGN0eCkge1xuICAgIGlmIChjdHguQm9vbGVhbkxpdGVyYWwoKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgdHlwZTogXCJCb29sZWFuTGl0ZXJhbFwiLFxuICAgICAgICB2YWx1ZTogdGhpcy5fdG9UZXh0KGN0eC5Cb29sZWFuTGl0ZXJhbCgpKSA9PT0gXCJ0cnVlXCJcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICAgIH1cbiAgICBpZiAoY3R4LmhleExpdGVyYWwoKSkge1xuICAgICAgcmV0dXJuIHRoaXMudmlzaXRIZXhMaXRlcmFsKGN0eC5oZXhMaXRlcmFsKCkpO1xuICAgIH1cbiAgICBpZiAoY3R4LnN0cmluZ0xpdGVyYWwoKSkge1xuICAgICAgY29uc3QgZnJhZ21lbnRzID0gY3R4LnN0cmluZ0xpdGVyYWwoKS5TdHJpbmdMaXRlcmFsRnJhZ21lbnQoKS5tYXAoKHN0cmluZ0xpdGVyYWxGcmFnbWVudEN0eCkgPT4ge1xuICAgICAgICBsZXQgdGV4dCA9IHRoaXMuX3RvVGV4dChzdHJpbmdMaXRlcmFsRnJhZ21lbnRDdHgpO1xuICAgICAgICBjb25zdCBpc1VuaWNvZGUgPSB0ZXh0LnNsaWNlKDAsIDcpID09PSBcInVuaWNvZGVcIjtcbiAgICAgICAgaWYgKGlzVW5pY29kZSkge1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpbmdsZVF1b3RlcyA9IHRleHRbMF0gPT09IFwiJ1wiO1xuICAgICAgICBjb25zdCB0ZXh0V2l0aG91dFF1b3RlcyA9IHRleHQuc3Vic3RyaW5nKDEsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc2luZ2xlUXVvdGVzID8gdGV4dFdpdGhvdXRRdW90ZXMucmVwbGFjZShuZXcgUmVnRXhwKFwiXFxcXFxcXFwnXCIsIFwiZ1wiKSwgXCInXCIpIDogdGV4dFdpdGhvdXRRdW90ZXMucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcXFxcXFwiJywgXCJnXCIpLCAnXCInKTtcbiAgICAgICAgcmV0dXJuIHt2YWx1ZSwgaXNVbmljb2RlfTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcGFydHMgPSBmcmFnbWVudHMubWFwKCh4KSA9PiB4LnZhbHVlKTtcbiAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgIHR5cGU6IFwiU3RyaW5nTGl0ZXJhbFwiLFxuICAgICAgICB2YWx1ZTogcGFydHMuam9pbihcIlwiKSxcbiAgICAgICAgcGFydHMsXG4gICAgICAgIGlzVW5pY29kZTogZnJhZ21lbnRzLm1hcCgoeCkgPT4geC5pc1VuaWNvZGUpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgICB9XG4gICAgaWYgKGN0eC5udW1iZXJMaXRlcmFsKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpc2l0TnVtYmVyTGl0ZXJhbChjdHgubnVtYmVyTGl0ZXJhbCgpKTtcbiAgICB9XG4gICAgaWYgKGN0eC5UeXBlS2V5d29yZCgpKSB7XG4gICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICB0eXBlOiBcIklkZW50aWZpZXJcIixcbiAgICAgICAgbmFtZTogXCJ0eXBlXCJcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICAgIH1cbiAgICBpZiAoY3R4LnR5cGVOYW1lKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpc2l0VHlwZU5hbWUoY3R4LnR5cGVOYW1lKCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52aXNpdChjdHguZ2V0Q2hpbGQoMCkpO1xuICB9XG4gIHZpc2l0VHVwbGVFeHByZXNzaW9uKGN0eCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gY3R4LmNoaWxkcmVuLnNsaWNlKDEsIC0xKTtcbiAgICBjb25zdCBjb21wb25lbnRzID0gdGhpcy5fbWFwQ29tbWFzVG9OdWxscyhjaGlsZHJlbikubWFwKChleHByKSA9PiB7XG4gICAgICBpZiAoZXhwciA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnZpc2l0KGV4cHIpO1xuICAgIH0pO1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIlR1cGxlRXhwcmVzc2lvblwiLFxuICAgICAgY29tcG9uZW50cyxcbiAgICAgIGlzQXJyYXk6IHRoaXMuX3RvVGV4dChjdHguZ2V0Q2hpbGQoMCkpID09PSBcIltcIlxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICBidWlsZElkZW50aWZpZXJMaXN0KGN0eCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gY3R4LmNoaWxkcmVuLnNsaWNlKDEsIC0xKTtcbiAgICBjb25zdCBpZGVudGlmaWVycyA9IGN0eC5pZGVudGlmaWVyKCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIHJldHVybiB0aGlzLl9tYXBDb21tYXNUb051bGxzKGNoaWxkcmVuKS5tYXAoKGlkZW5Pck51bGwpID0+IHtcbiAgICAgIGlmICghaWRlbk9yTnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlkZW4gPSBpZGVudGlmaWVyc1tpXTtcbiAgICAgIGkrKztcbiAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgIHR5cGU6IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLFxuICAgICAgICBuYW1lOiB0aGlzLl90b1RleHQoaWRlbiksXG4gICAgICAgIGlkZW50aWZpZXI6IHRoaXMudmlzaXRJZGVudGlmaWVyKGlkZW4pLFxuICAgICAgICBpc1N0YXRlVmFyOiBmYWxzZSxcbiAgICAgICAgaXNJbmRleGVkOiBmYWxzZSxcbiAgICAgICAgdHlwZU5hbWU6IG51bGwsXG4gICAgICAgIHN0b3JhZ2VMb2NhdGlvbjogbnVsbCxcbiAgICAgICAgZXhwcmVzc2lvbjogbnVsbFxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGlkZW4pO1xuICAgIH0pO1xuICB9XG4gIGJ1aWxkVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoY3R4KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHZhcmlhYmxlRGVjbGFyYXRpb25zID0gY3R4LnZhcmlhYmxlRGVjbGFyYXRpb24oKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgcmV0dXJuIHRoaXMuX21hcENvbW1hc1RvTnVsbHMoKF9hID0gY3R4LmNoaWxkcmVuKSAhPSBudWxsID8gX2EgOiBbXSkubWFwKChkZWNsT3JOdWxsKSA9PiB7XG4gICAgICBpZiAoIWRlY2xPck51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBkZWNsID0gdmFyaWFibGVEZWNsYXJhdGlvbnNbaV07XG4gICAgICBpKys7XG4gICAgICBsZXQgc3RvcmFnZUxvY2F0aW9uID0gbnVsbDtcbiAgICAgIGlmIChkZWNsLnN0b3JhZ2VMb2NhdGlvbigpKSB7XG4gICAgICAgIHN0b3JhZ2VMb2NhdGlvbiA9IHRoaXMuX3RvVGV4dChkZWNsLnN0b3JhZ2VMb2NhdGlvbigpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlkZW50aWZpZXJDdHggPSBkZWNsLmlkZW50aWZpZXIoKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXG4gICAgICAgIG5hbWU6IHRoaXMuX3RvVGV4dChpZGVudGlmaWVyQ3R4KSxcbiAgICAgICAgaWRlbnRpZmllcjogdGhpcy52aXNpdElkZW50aWZpZXIoaWRlbnRpZmllckN0eCksXG4gICAgICAgIHR5cGVOYW1lOiB0aGlzLnZpc2l0VHlwZU5hbWUoZGVjbC50eXBlTmFtZSgpKSxcbiAgICAgICAgc3RvcmFnZUxvY2F0aW9uLFxuICAgICAgICBpc1N0YXRlVmFyOiBmYWxzZSxcbiAgICAgICAgaXNJbmRleGVkOiBmYWxzZSxcbiAgICAgICAgZXhwcmVzc2lvbjogbnVsbFxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKHJlc3VsdCwgZGVjbCk7XG4gICAgfSk7XG4gIH1cbiAgdmlzaXRJbXBvcnREaXJlY3RpdmUoY3R4KSB7XG4gICAgY29uc3QgcGF0aFN0cmluZyA9IHRoaXMuX3RvVGV4dChjdHguaW1wb3J0UGF0aCgpKTtcbiAgICBsZXQgdW5pdEFsaWFzID0gbnVsbDtcbiAgICBsZXQgdW5pdEFsaWFzSWRlbnRpZmllciA9IG51bGw7XG4gICAgbGV0IHN5bWJvbEFsaWFzZXMgPSBudWxsO1xuICAgIGxldCBzeW1ib2xBbGlhc2VzSWRlbnRpZmllcnMgPSBudWxsO1xuICAgIGlmIChjdHguaW1wb3J0RGVjbGFyYXRpb24oKS5sZW5ndGggPiAwKSB7XG4gICAgICBzeW1ib2xBbGlhc2VzID0gY3R4LmltcG9ydERlY2xhcmF0aW9uKCkubWFwKChkZWNsKSA9PiB7XG4gICAgICAgIGNvbnN0IHN5bWJvbCA9IHRoaXMuX3RvVGV4dChkZWNsLmlkZW50aWZpZXIoMCkpO1xuICAgICAgICBsZXQgYWxpYXMgPSBudWxsO1xuICAgICAgICBpZiAoZGVjbC5pZGVudGlmaWVyKCkubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGFsaWFzID0gdGhpcy5fdG9UZXh0KGRlY2wuaWRlbnRpZmllcigxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtzeW1ib2wsIGFsaWFzXTtcbiAgICAgIH0pO1xuICAgICAgc3ltYm9sQWxpYXNlc0lkZW50aWZpZXJzID0gY3R4LmltcG9ydERlY2xhcmF0aW9uKCkubWFwKChkZWNsKSA9PiB7XG4gICAgICAgIGNvbnN0IHN5bWJvbElkZW50aWZpZXIgPSB0aGlzLnZpc2l0SWRlbnRpZmllcihkZWNsLmlkZW50aWZpZXIoMCkpO1xuICAgICAgICBsZXQgYWxpYXNJZGVudGlmaWVyID0gbnVsbDtcbiAgICAgICAgaWYgKGRlY2wuaWRlbnRpZmllcigpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBhbGlhc0lkZW50aWZpZXIgPSB0aGlzLnZpc2l0SWRlbnRpZmllcihkZWNsLmlkZW50aWZpZXIoMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc3ltYm9sSWRlbnRpZmllciwgYWxpYXNJZGVudGlmaWVyXTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpZGVudGlmaWVyQ3R4TGlzdCA9IGN0eC5pZGVudGlmaWVyKCk7XG4gICAgICBpZiAoaWRlbnRpZmllckN0eExpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICB9IGVsc2UgaWYgKGlkZW50aWZpZXJDdHhMaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCBhbGlhc0lkZW50aWZpZXJDdHggPSBjdHguaWRlbnRpZmllcigwKTtcbiAgICAgICAgdW5pdEFsaWFzID0gdGhpcy5fdG9UZXh0KGFsaWFzSWRlbnRpZmllckN0eCk7XG4gICAgICAgIHVuaXRBbGlhc0lkZW50aWZpZXIgPSB0aGlzLnZpc2l0SWRlbnRpZmllcihhbGlhc0lkZW50aWZpZXJDdHgpO1xuICAgICAgfSBlbHNlIGlmIChpZGVudGlmaWVyQ3R4TGlzdC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgY29uc3QgYWxpYXNJZGVudGlmaWVyQ3R4ID0gY3R4LmlkZW50aWZpZXIoMSk7XG4gICAgICAgIHVuaXRBbGlhcyA9IHRoaXMuX3RvVGV4dChhbGlhc0lkZW50aWZpZXJDdHgpO1xuICAgICAgICB1bml0QWxpYXNJZGVudGlmaWVyID0gdGhpcy52aXNpdElkZW50aWZpZXIoYWxpYXNJZGVudGlmaWVyQ3R4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzc2VydGlvbiBlcnJvcjogYW4gaW1wb3J0IHNob3VsZCBoYXZlIG9uZSBvciB0d28gaWRlbnRpZmllcnNcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBhdGggPSBwYXRoU3RyaW5nLnN1YnN0cmluZygxLCBwYXRoU3RyaW5nLmxlbmd0aCAtIDEpO1xuICAgIGNvbnN0IHBhdGhMaXRlcmFsID0ge1xuICAgICAgdHlwZTogXCJTdHJpbmdMaXRlcmFsXCIsXG4gICAgICB2YWx1ZTogcGF0aCxcbiAgICAgIHBhcnRzOiBbcGF0aF0sXG4gICAgICBpc1VuaWNvZGU6IFtmYWxzZV1cbiAgICB9O1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIkltcG9ydERpcmVjdGl2ZVwiLFxuICAgICAgcGF0aCxcbiAgICAgIHBhdGhMaXRlcmFsOiB0aGlzLl9hZGRNZXRhKHBhdGhMaXRlcmFsLCBjdHguaW1wb3J0UGF0aCgpKSxcbiAgICAgIHVuaXRBbGlhcyxcbiAgICAgIHVuaXRBbGlhc0lkZW50aWZpZXIsXG4gICAgICBzeW1ib2xBbGlhc2VzLFxuICAgICAgc3ltYm9sQWxpYXNlc0lkZW50aWZpZXJzXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICB9XG4gIGJ1aWxkRXZlbnRQYXJhbWV0ZXJMaXN0KGN0eCkge1xuICAgIHJldHVybiBjdHguZXZlbnRQYXJhbWV0ZXIoKS5tYXAoKHBhcmFtQ3R4KSA9PiB7XG4gICAgICBjb25zdCB0eXBlID0gdGhpcy52aXNpdChwYXJhbUN0eC50eXBlTmFtZSgpKTtcbiAgICAgIGxldCBuYW1lID0gbnVsbDtcbiAgICAgIGlmIChwYXJhbUN0eC5pZGVudGlmaWVyKCkpIHtcbiAgICAgICAgbmFtZSA9IHRoaXMuX3RvVGV4dChwYXJhbUN0eC5pZGVudGlmaWVyKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXG4gICAgICAgIHR5cGVOYW1lOiB0eXBlLFxuICAgICAgICBuYW1lLFxuICAgICAgICBpc1N0YXRlVmFyOiBmYWxzZSxcbiAgICAgICAgaXNJbmRleGVkOiAhIXBhcmFtQ3R4LkluZGV4ZWRLZXl3b3JkKDApXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIHZpc2l0UmV0dXJuUGFyYW1ldGVycyhjdHgpIHtcbiAgICByZXR1cm4gdGhpcy52aXNpdFBhcmFtZXRlckxpc3QoY3R4LnBhcmFtZXRlckxpc3QoKSk7XG4gIH1cbiAgdmlzaXRQYXJhbWV0ZXJMaXN0KGN0eCkge1xuICAgIHJldHVybiBjdHgucGFyYW1ldGVyKCkubWFwKChwYXJhbUN0eCkgPT4gdGhpcy52aXNpdFBhcmFtZXRlcihwYXJhbUN0eCkpO1xuICB9XG4gIHZpc2l0SW5saW5lQXNzZW1ibHlTdGF0ZW1lbnQoY3R4KSB7XG4gICAgbGV0IGxhbmd1YWdlID0gbnVsbDtcbiAgICBpZiAoY3R4LlN0cmluZ0xpdGVyYWxGcmFnbWVudCgpKSB7XG4gICAgICBsYW5ndWFnZSA9IHRoaXMuX3RvVGV4dChjdHguU3RyaW5nTGl0ZXJhbEZyYWdtZW50KCkpO1xuICAgICAgbGFuZ3VhZ2UgPSBsYW5ndWFnZS5zdWJzdHJpbmcoMSwgbGFuZ3VhZ2UubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGNvbnN0IGZsYWdzID0gW107XG4gICAgY29uc3QgZmxhZyA9IGN0eC5pbmxpbmVBc3NlbWJseVN0YXRlbWVudEZsYWcoKTtcbiAgICBpZiAoZmxhZyAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBmbGFnU3RyaW5nID0gdGhpcy5fdG9UZXh0KGZsYWcuc3RyaW5nTGl0ZXJhbCgpKTtcbiAgICAgIGZsYWdzLnB1c2goZmxhZ1N0cmluZy5zbGljZSgxLCBmbGFnU3RyaW5nLmxlbmd0aCAtIDEpKTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiSW5saW5lQXNzZW1ibHlTdGF0ZW1lbnRcIixcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgZmxhZ3MsXG4gICAgICBib2R5OiB0aGlzLnZpc2l0QXNzZW1ibHlCbG9jayhjdHguYXNzZW1ibHlCbG9jaygpKVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdEFzc2VtYmx5QmxvY2soY3R4KSB7XG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IGN0eC5hc3NlbWJseUl0ZW0oKS5tYXAoKGl0ZW0pID0+IHRoaXMudmlzaXRBc3NlbWJseUl0ZW0oaXRlbSkpO1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIkFzc2VtYmx5QmxvY2tcIixcbiAgICAgIG9wZXJhdGlvbnNcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gIH1cbiAgdmlzaXRBc3NlbWJseUl0ZW0oY3R4KSB7XG4gICAgbGV0IHRleHQ7XG4gICAgaWYgKGN0eC5oZXhMaXRlcmFsKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpc2l0SGV4TGl0ZXJhbChjdHguaGV4TGl0ZXJhbCgpKTtcbiAgICB9XG4gICAgaWYgKGN0eC5zdHJpbmdMaXRlcmFsKCkpIHtcbiAgICAgIHRleHQgPSB0aGlzLl90b1RleHQoY3R4LnN0cmluZ0xpdGVyYWwoKSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRleHQuc3Vic3RyaW5nKDEsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICB0eXBlOiBcIlN0cmluZ0xpdGVyYWxcIixcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHBhcnRzOiBbdmFsdWVdLFxuICAgICAgICBpc1VuaWNvZGU6IFtmYWxzZV1cbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICAgIH1cbiAgICBpZiAoY3R4LkJyZWFrS2V5d29yZCgpKSB7XG4gICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICB0eXBlOiBcIkJyZWFrXCJcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICAgIH1cbiAgICBpZiAoY3R4LkNvbnRpbnVlS2V5d29yZCgpKSB7XG4gICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICB0eXBlOiBcIkNvbnRpbnVlXCJcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52aXNpdChjdHguZ2V0Q2hpbGQoMCkpO1xuICB9XG4gIHZpc2l0QXNzZW1ibHlFeHByZXNzaW9uKGN0eCkge1xuICAgIHJldHVybiB0aGlzLnZpc2l0KGN0eC5nZXRDaGlsZCgwKSk7XG4gIH1cbiAgdmlzaXRBc3NlbWJseUNhbGwoY3R4KSB7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gdGhpcy5fdG9UZXh0KGN0eC5nZXRDaGlsZCgwKSk7XG4gICAgY29uc3QgYXJncyA9IGN0eC5hc3NlbWJseUV4cHJlc3Npb24oKS5tYXAoKGFzc2VtYmx5RXhwcikgPT4gdGhpcy52aXNpdEFzc2VtYmx5RXhwcmVzc2lvbihhc3NlbWJseUV4cHIpKTtcbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgdHlwZTogXCJBc3NlbWJseUNhbGxcIixcbiAgICAgIGZ1bmN0aW9uTmFtZSxcbiAgICAgIGFyZ3VtZW50czogYXJnc1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdEFzc2VtYmx5TGl0ZXJhbChjdHgpIHtcbiAgICBsZXQgdGV4dDtcbiAgICBpZiAoY3R4LnN0cmluZ0xpdGVyYWwoKSkge1xuICAgICAgdGV4dCA9IHRoaXMuX3RvVGV4dChjdHgpO1xuICAgICAgY29uc3QgdmFsdWUgPSB0ZXh0LnN1YnN0cmluZygxLCB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgdHlwZTogXCJTdHJpbmdMaXRlcmFsXCIsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBwYXJ0czogW3ZhbHVlXSxcbiAgICAgICAgaXNVbmljb2RlOiBbZmFsc2VdXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgICB9XG4gICAgaWYgKGN0eC5Cb29sZWFuTGl0ZXJhbCgpKSB7XG4gICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICB0eXBlOiBcIkJvb2xlYW5MaXRlcmFsXCIsXG4gICAgICAgIHZhbHVlOiB0aGlzLl90b1RleHQoY3R4LkJvb2xlYW5MaXRlcmFsKCkpID09PSBcInRydWVcIlxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gICAgfVxuICAgIGlmIChjdHguRGVjaW1hbE51bWJlcigpKSB7XG4gICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICB0eXBlOiBcIkRlY2ltYWxOdW1iZXJcIixcbiAgICAgICAgdmFsdWU6IHRoaXMuX3RvVGV4dChjdHgpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgICB9XG4gICAgaWYgKGN0eC5IZXhOdW1iZXIoKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgdHlwZTogXCJIZXhOdW1iZXJcIixcbiAgICAgICAgdmFsdWU6IHRoaXMuX3RvVGV4dChjdHgpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgICB9XG4gICAgaWYgKGN0eC5oZXhMaXRlcmFsKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpc2l0SGV4TGl0ZXJhbChjdHguaGV4TGl0ZXJhbCgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkIG5ldmVyIHJlYWNoIGhlcmVcIik7XG4gIH1cbiAgdmlzaXRBc3NlbWJseVN3aXRjaChjdHgpIHtcbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgdHlwZTogXCJBc3NlbWJseVN3aXRjaFwiLFxuICAgICAgZXhwcmVzc2lvbjogdGhpcy52aXNpdEFzc2VtYmx5RXhwcmVzc2lvbihjdHguYXNzZW1ibHlFeHByZXNzaW9uKCkpLFxuICAgICAgY2FzZXM6IGN0eC5hc3NlbWJseUNhc2UoKS5tYXAoKGMpID0+IHRoaXMudmlzaXRBc3NlbWJseUNhc2UoYykpXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICB9XG4gIHZpc2l0QXNzZW1ibHlDYXNlKGN0eCkge1xuICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3RvVGV4dChjdHguZ2V0Q2hpbGQoMCkpID09PSBcImNhc2VcIikge1xuICAgICAgdmFsdWUgPSB0aGlzLnZpc2l0QXNzZW1ibHlMaXRlcmFsKGN0eC5hc3NlbWJseUxpdGVyYWwoKSk7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIkFzc2VtYmx5Q2FzZVwiLFxuICAgICAgYmxvY2s6IHRoaXMudmlzaXRBc3NlbWJseUJsb2NrKGN0eC5hc3NlbWJseUJsb2NrKCkpLFxuICAgICAgdmFsdWUsXG4gICAgICBkZWZhdWx0OiB2YWx1ZSA9PT0gbnVsbFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdEFzc2VtYmx5TG9jYWxEZWZpbml0aW9uKGN0eCkge1xuICAgIGNvbnN0IGN0eEFzc2VtYmx5SWRlbnRpZmllck9yTGlzdCA9IGN0eC5hc3NlbWJseUlkZW50aWZpZXJPckxpc3QoKTtcbiAgICBsZXQgbmFtZXM7XG4gICAgaWYgKGN0eEFzc2VtYmx5SWRlbnRpZmllck9yTGlzdC5pZGVudGlmaWVyKCkpIHtcbiAgICAgIG5hbWVzID0gW3RoaXMudmlzaXRJZGVudGlmaWVyKGN0eEFzc2VtYmx5SWRlbnRpZmllck9yTGlzdC5pZGVudGlmaWVyKCkpXTtcbiAgICB9IGVsc2UgaWYgKGN0eEFzc2VtYmx5SWRlbnRpZmllck9yTGlzdC5hc3NlbWJseU1lbWJlcigpKSB7XG4gICAgICBuYW1lcyA9IFtcbiAgICAgICAgdGhpcy52aXNpdEFzc2VtYmx5TWVtYmVyKGN0eEFzc2VtYmx5SWRlbnRpZmllck9yTGlzdC5hc3NlbWJseU1lbWJlcigpKVxuICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZXMgPSBjdHhBc3NlbWJseUlkZW50aWZpZXJPckxpc3QuYXNzZW1ibHlJZGVudGlmaWVyTGlzdCgpLmlkZW50aWZpZXIoKS5tYXAoKHgpID0+IHRoaXMudmlzaXRJZGVudGlmaWVyKHgpKTtcbiAgICB9XG4gICAgbGV0IGV4cHJlc3Npb24gPSBudWxsO1xuICAgIGlmIChjdHguYXNzZW1ibHlFeHByZXNzaW9uKCkgIT09IHZvaWQgMCkge1xuICAgICAgZXhwcmVzc2lvbiA9IHRoaXMudmlzaXRBc3NlbWJseUV4cHJlc3Npb24oY3R4LmFzc2VtYmx5RXhwcmVzc2lvbigpKTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiQXNzZW1ibHlMb2NhbERlZmluaXRpb25cIixcbiAgICAgIG5hbWVzLFxuICAgICAgZXhwcmVzc2lvblxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdEFzc2VtYmx5RnVuY3Rpb25EZWZpbml0aW9uKGN0eCkge1xuICAgIGNvbnN0IGN0eEFzc2VtYmx5SWRlbnRpZmllckxpc3QgPSBjdHguYXNzZW1ibHlJZGVudGlmaWVyTGlzdCgpO1xuICAgIGNvbnN0IGFyZ3MgPSBjdHhBc3NlbWJseUlkZW50aWZpZXJMaXN0ICE9PSB2b2lkIDAgPyBjdHhBc3NlbWJseUlkZW50aWZpZXJMaXN0LmlkZW50aWZpZXIoKS5tYXAoKHgpID0+IHRoaXMudmlzaXRJZGVudGlmaWVyKHgpKSA6IFtdO1xuICAgIGNvbnN0IGN0eEFzc2VtYmx5RnVuY3Rpb25SZXR1cm5zID0gY3R4LmFzc2VtYmx5RnVuY3Rpb25SZXR1cm5zKCk7XG4gICAgY29uc3QgcmV0dXJuQXJncyA9IGN0eEFzc2VtYmx5RnVuY3Rpb25SZXR1cm5zID8gY3R4QXNzZW1ibHlGdW5jdGlvblJldHVybnMuYXNzZW1ibHlJZGVudGlmaWVyTGlzdCgpLmlkZW50aWZpZXIoKS5tYXAoKHgpID0+IHRoaXMudmlzaXRJZGVudGlmaWVyKHgpKSA6IFtdO1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIkFzc2VtYmx5RnVuY3Rpb25EZWZpbml0aW9uXCIsXG4gICAgICBuYW1lOiB0aGlzLl90b1RleHQoY3R4LmlkZW50aWZpZXIoKSksXG4gICAgICBhcmd1bWVudHM6IGFyZ3MsXG4gICAgICByZXR1cm5Bcmd1bWVudHM6IHJldHVybkFyZ3MsXG4gICAgICBib2R5OiB0aGlzLnZpc2l0QXNzZW1ibHlCbG9jayhjdHguYXNzZW1ibHlCbG9jaygpKVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdEFzc2VtYmx5QXNzaWdubWVudChjdHgpIHtcbiAgICBjb25zdCBjdHhBc3NlbWJseUlkZW50aWZpZXJPckxpc3QgPSBjdHguYXNzZW1ibHlJZGVudGlmaWVyT3JMaXN0KCk7XG4gICAgbGV0IG5hbWVzO1xuICAgIGlmIChjdHhBc3NlbWJseUlkZW50aWZpZXJPckxpc3QuaWRlbnRpZmllcigpKSB7XG4gICAgICBuYW1lcyA9IFt0aGlzLnZpc2l0SWRlbnRpZmllcihjdHhBc3NlbWJseUlkZW50aWZpZXJPckxpc3QuaWRlbnRpZmllcigpKV07XG4gICAgfSBlbHNlIGlmIChjdHhBc3NlbWJseUlkZW50aWZpZXJPckxpc3QuYXNzZW1ibHlNZW1iZXIoKSkge1xuICAgICAgbmFtZXMgPSBbXG4gICAgICAgIHRoaXMudmlzaXRBc3NlbWJseU1lbWJlcihjdHhBc3NlbWJseUlkZW50aWZpZXJPckxpc3QuYXNzZW1ibHlNZW1iZXIoKSlcbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWVzID0gY3R4QXNzZW1ibHlJZGVudGlmaWVyT3JMaXN0LmFzc2VtYmx5SWRlbnRpZmllckxpc3QoKS5pZGVudGlmaWVyKCkubWFwKCh4KSA9PiB0aGlzLnZpc2l0SWRlbnRpZmllcih4KSk7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIkFzc2VtYmx5QXNzaWdubWVudFwiLFxuICAgICAgbmFtZXMsXG4gICAgICBleHByZXNzaW9uOiB0aGlzLnZpc2l0QXNzZW1ibHlFeHByZXNzaW9uKGN0eC5hc3NlbWJseUV4cHJlc3Npb24oKSlcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gIH1cbiAgdmlzaXRBc3NlbWJseU1lbWJlcihjdHgpIHtcbiAgICBjb25zdCBbYWNjZXNzZWQsIG1lbWJlcl0gPSBjdHguaWRlbnRpZmllcigpO1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIkFzc2VtYmx5TWVtYmVyQWNjZXNzXCIsXG4gICAgICBleHByZXNzaW9uOiB0aGlzLnZpc2l0SWRlbnRpZmllcihhY2Nlc3NlZCksXG4gICAgICBtZW1iZXJOYW1lOiB0aGlzLnZpc2l0SWRlbnRpZmllcihtZW1iZXIpXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICB9XG4gIHZpc2l0TGFiZWxEZWZpbml0aW9uKGN0eCkge1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIkxhYmVsRGVmaW5pdGlvblwiLFxuICAgICAgbmFtZTogdGhpcy5fdG9UZXh0KGN0eC5pZGVudGlmaWVyKCkpXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICB9XG4gIHZpc2l0QXNzZW1ibHlTdGFja0Fzc2lnbm1lbnQoY3R4KSB7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiQXNzZW1ibHlTdGFja0Fzc2lnbm1lbnRcIixcbiAgICAgIG5hbWU6IHRoaXMuX3RvVGV4dChjdHguaWRlbnRpZmllcigpKSxcbiAgICAgIGV4cHJlc3Npb246IHRoaXMudmlzaXRBc3NlbWJseUV4cHJlc3Npb24oY3R4LmFzc2VtYmx5RXhwcmVzc2lvbigpKVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdEFzc2VtYmx5Rm9yKGN0eCkge1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIkFzc2VtYmx5Rm9yXCIsXG4gICAgICBwcmU6IHRoaXMudmlzaXQoY3R4LmdldENoaWxkKDEpKSxcbiAgICAgIGNvbmRpdGlvbjogdGhpcy52aXNpdChjdHguZ2V0Q2hpbGQoMikpLFxuICAgICAgcG9zdDogdGhpcy52aXNpdChjdHguZ2V0Q2hpbGQoMykpLFxuICAgICAgYm9keTogdGhpcy52aXNpdChjdHguZ2V0Q2hpbGQoNCkpXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICB9XG4gIHZpc2l0QXNzZW1ibHlJZihjdHgpIHtcbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgdHlwZTogXCJBc3NlbWJseUlmXCIsXG4gICAgICBjb25kaXRpb246IHRoaXMudmlzaXRBc3NlbWJseUV4cHJlc3Npb24oY3R4LmFzc2VtYmx5RXhwcmVzc2lvbigpKSxcbiAgICAgIGJvZHk6IHRoaXMudmlzaXRBc3NlbWJseUJsb2NrKGN0eC5hc3NlbWJseUJsb2NrKCkpXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fYWRkTWV0YShub2RlLCBjdHgpO1xuICB9XG4gIHZpc2l0Q29udGludWVTdGF0ZW1lbnQoY3R4KSB7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiQ29udGludWVTdGF0ZW1lbnRcIlxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2FkZE1ldGEobm9kZSwgY3R4KTtcbiAgfVxuICB2aXNpdEJyZWFrU3RhdGVtZW50KGN0eCkge1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICB0eXBlOiBcIkJyZWFrU3RhdGVtZW50XCJcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9hZGRNZXRhKG5vZGUsIGN0eCk7XG4gIH1cbiAgX3RvVGV4dChjdHgpIHtcbiAgICBjb25zdCB0ZXh0ID0gY3R4LnRleHQ7XG4gICAgaWYgKHRleHQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0aW9uIGVycm9yOiB0ZXh0IHNob3VsZCBuZXZlciBiZSB1bmRlZmllbmRcIik7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9XG4gIF9zdGF0ZU11dGFiaWxpdHlUb1RleHQoY3R4KSB7XG4gICAgaWYgKGN0eC5QdXJlS2V5d29yZCgpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBcInB1cmVcIjtcbiAgICB9XG4gICAgaWYgKGN0eC5Db25zdGFudEtleXdvcmQoKSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gXCJjb25zdGFudFwiO1xuICAgIH1cbiAgICBpZiAoY3R4LlBheWFibGVLZXl3b3JkKCkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIFwicGF5YWJsZVwiO1xuICAgIH1cbiAgICBpZiAoY3R4LlZpZXdLZXl3b3JkKCkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIFwidmlld1wiO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnRpb24gZXJyb3I6IG5vbi1leGhhdXN0aXZlIHN0YXRlTXV0YWJpbGl0eSBjaGVja1wiKTtcbiAgfVxuICBfbG9jKGN0eCkge1xuICAgIGNvbnN0IHNvdXJjZUxvY2F0aW9uID0ge1xuICAgICAgc3RhcnQ6IHtcbiAgICAgICAgbGluZTogY3R4LnN0YXJ0LmxpbmUsXG4gICAgICAgIGNvbHVtbjogY3R4LnN0YXJ0LmNoYXJQb3NpdGlvbkluTGluZVxuICAgICAgfSxcbiAgICAgIGVuZDoge1xuICAgICAgICBsaW5lOiBjdHguc3RvcCA/IGN0eC5zdG9wLmxpbmUgOiBjdHguc3RhcnQubGluZSxcbiAgICAgICAgY29sdW1uOiBjdHguc3RvcCA/IGN0eC5zdG9wLmNoYXJQb3NpdGlvbkluTGluZSA6IGN0eC5zdGFydC5jaGFyUG9zaXRpb25JbkxpbmVcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBzb3VyY2VMb2NhdGlvbjtcbiAgfVxuICBfcmFuZ2UoY3R4KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gW2N0eC5zdGFydC5zdGFydEluZGV4LCAoX2IgPSAoX2EgPSBjdHguc3RvcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnN0b3BJbmRleCkgIT0gbnVsbCA/IF9iIDogY3R4LnN0YXJ0LnN0YXJ0SW5kZXhdO1xuICB9XG4gIF9hZGRNZXRhKG5vZGUsIGN0eCkge1xuICAgIGNvbnN0IG5vZGVXaXRoTWV0YSA9IHtcbiAgICAgIHR5cGU6IG5vZGUudHlwZVxuICAgIH07XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2MgPT09IHRydWUpIHtcbiAgICAgIG5vZGUubG9jID0gdGhpcy5fbG9jKGN0eCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2UgPT09IHRydWUpIHtcbiAgICAgIG5vZGUucmFuZ2UgPSB0aGlzLl9yYW5nZShjdHgpO1xuICAgIH1cbiAgICByZXR1cm4gX19vYmpTcHJlYWQoX19vYmpTcHJlYWQoe30sIG5vZGVXaXRoTWV0YSksIG5vZGUpO1xuICB9XG4gIF9tYXBDb21tYXNUb051bGxzKGNoaWxkcmVuKSB7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBsZXQgY29tbWEgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgZWwgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChjb21tYSkge1xuICAgICAgICBpZiAodGhpcy5fdG9UZXh0KGVsKSA9PT0gXCIsXCIpIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaChudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaChlbCk7XG4gICAgICAgICAgY29tbWEgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX3RvVGV4dChlbCkgIT09IFwiLFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgY29tbWFcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29tbWEgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tbWEpIHtcbiAgICAgIHZhbHVlcy5wdXNoKG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG59O1xuZnVuY3Rpb24gaXNCaW5PcChvcCkge1xuICByZXR1cm4gYmluYXJ5T3BWYWx1ZXMuaW5jbHVkZXMob3ApO1xufVxuXG4vLyBzcmMvRXJyb3JMaXN0ZW5lci50c1xudmFyIGltcG9ydF9hbnRscjQgPSBfX3RvTW9kdWxlKHJlcXVpcmVfYW50bHI0KCkpO1xudmFyIEVycm9yTGlzdGVuZXIgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9hbnRscjQuZGVmYXVsdC5lcnJvci5FcnJvckxpc3RlbmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgfVxuICBzeW50YXhFcnJvcihyZWNvZ25pemVyLCBvZmZlbmRpbmdTeW1ib2wsIGxpbmUsIGNvbHVtbiwgbWVzc2FnZSkge1xuICAgIHRoaXMuX2Vycm9ycy5wdXNoKHttZXNzYWdlLCBsaW5lLCBjb2x1bW59KTtcbiAgfVxuICBnZXRFcnJvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Vycm9ycztcbiAgfVxuICBoYXNFcnJvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Vycm9ycy5sZW5ndGggPiAwO1xuICB9XG59O1xudmFyIEVycm9yTGlzdGVuZXJfZGVmYXVsdCA9IEVycm9yTGlzdGVuZXI7XG5cbi8vIHNyYy90b2tlbnMudHNcbnZhciBpbXBvcnRfdG9rZW5zX3N0cmluZyA9IF9fdG9Nb2R1bGUocmVxdWlyZV90b2tlbnNfc3RyaW5nKCkpO1xudmFyIHRva2VucyA9IGltcG9ydF90b2tlbnNfc3RyaW5nLmRlZmF1bHQ7XG52YXIgVFlQRV9UT0tFTlMgPSBbXG4gIFwidmFyXCIsXG4gIFwiYm9vbFwiLFxuICBcImFkZHJlc3NcIixcbiAgXCJzdHJpbmdcIixcbiAgXCJJbnRcIixcbiAgXCJVaW50XCIsXG4gIFwiQnl0ZVwiLFxuICBcIkZpeGVkXCIsXG4gIFwiVUZpeGVkXCJcbl07XG5mdW5jdGlvbiByc3BsaXQoc3RyLCB2YWx1ZSkge1xuICBjb25zdCBpbmRleCA9IHN0ci5sYXN0SW5kZXhPZih2YWx1ZSk7XG4gIHJldHVybiBbc3RyLnN1YnN0cmluZygwLCBpbmRleCksIHN0ci5zdWJzdHJpbmcoaW5kZXggKyAxLCBzdHIubGVuZ3RoKV07XG59XG5mdW5jdGlvbiBub3JtYWxpemVUb2tlblR5cGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlLmVuZHNXaXRoKFwiJ1wiKSkge1xuICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHZhbHVlLmxlbmd0aCAtIDEpO1xuICB9XG4gIGlmICh2YWx1ZS5zdGFydHNXaXRoKFwiJ1wiKSkge1xuICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEsIHZhbHVlLmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0VG9rZW5UeXBlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gXCJJZGVudGlmaWVyXCIgfHwgdmFsdWUgPT09IFwiZnJvbVwiKSB7XG4gICAgcmV0dXJuIFwiSWRlbnRpZmllclwiO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSBcIlRydWVMaXRlcmFsXCIgfHwgdmFsdWUgPT09IFwiRmFsc2VMaXRlcmFsXCIpIHtcbiAgICByZXR1cm4gXCJCb29sZWFuXCI7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IFwiVmVyc2lvbkxpdGVyYWxcIikge1xuICAgIHJldHVybiBcIlZlcnNpb25cIjtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gXCJTdHJpbmdMaXRlcmFsXCIpIHtcbiAgICByZXR1cm4gXCJTdHJpbmdcIjtcbiAgfSBlbHNlIGlmIChUWVBFX1RPS0VOUy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gXCJUeXBlXCI7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IFwiTnVtYmVyVW5pdFwiKSB7XG4gICAgcmV0dXJuIFwiU3ViZGVub21pbmF0aW9uXCI7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IFwiRGVjaW1hbE51bWJlclwiKSB7XG4gICAgcmV0dXJuIFwiTnVtZXJpY1wiO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSBcIkhleExpdGVyYWxcIikge1xuICAgIHJldHVybiBcIkhleFwiO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSBcIlJlc2VydmVkS2V5d29yZFwiKSB7XG4gICAgcmV0dXJuIFwiUmVzZXJ2ZWRcIjtcbiAgfSBlbHNlIGlmICgvXlxcVyskLy50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiBcIlB1bmN0dWF0b3JcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJLZXl3b3JkXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRva2VuVHlwZU1hcCgpIHtcbiAgcmV0dXJuIHRva2Vucy5zcGxpdChcIlxcblwiKS5tYXAoKGxpbmUpID0+IHJzcGxpdChsaW5lLCBcIj1cIikpLnJlZHVjZSgoYWN1bSwgW3ZhbHVlLCBrZXldKSA9PiB7XG4gICAgYWN1bVtwYXJzZUludChrZXksIDEwKV0gPSBub3JtYWxpemVUb2tlblR5cGUodmFsdWUpO1xuICAgIHJldHVybiBhY3VtO1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBidWlsZFRva2VuTGlzdCh0b2tlbnNBcmcsIG9wdGlvbnMpIHtcbiAgY29uc3QgdG9rZW5UeXBlcyA9IGdldFRva2VuVHlwZU1hcCgpO1xuICBjb25zdCByZXN1bHQgPSB0b2tlbnNBcmcubWFwKCh0b2tlbikgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgdHlwZSA9IGdldFRva2VuVHlwZSh0b2tlblR5cGVzW3Rva2VuLnR5cGVdKTtcbiAgICBjb25zdCBub2RlID0ge3R5cGUsIHZhbHVlOiB0b2tlbi50ZXh0fTtcbiAgICBpZiAob3B0aW9ucy5yYW5nZSA9PT0gdHJ1ZSkge1xuICAgICAgbm9kZS5yYW5nZSA9IFt0b2tlbi5zdGFydEluZGV4LCB0b2tlbi5zdG9wSW5kZXggKyAxXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubG9jID09PSB0cnVlKSB7XG4gICAgICBub2RlLmxvYyA9IHtcbiAgICAgICAgc3RhcnQ6IHtsaW5lOiB0b2tlbi5saW5lLCBjb2x1bW46IHRva2VuLmNoYXJQb3NpdGlvbkluTGluZX0sXG4gICAgICAgIGVuZDoge2xpbmU6IHRva2VuLmxpbmUsIGNvbHVtbjogdG9rZW4uY2hhclBvc2l0aW9uSW5MaW5lICsgKChfYiA9IChfYSA9IHRva2VuLnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5sZW5ndGgpICE9IG51bGwgPyBfYiA6IDApfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvcGFyc2VyLnRzXG52YXIgUGFyc2VyRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qge21lc3NhZ2UsIGxpbmUsIGNvbHVtbn0gPSBhcmdzLmVycm9yc1swXTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBgJHttZXNzYWdlfSAoJHtsaW5lfToke2NvbHVtbn0pYDtcbiAgICB0aGlzLmVycm9ycyA9IGFyZ3MuZXJyb3JzO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAhPT0gdm9pZCAwKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIHRva2VuaXplKGlucHV0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgaW5wdXRTdHJlYW0gPSBuZXcgaW1wb3J0X2FudGxyNHRzLkFOVExSSW5wdXRTdHJlYW0oaW5wdXQpO1xuICBjb25zdCBsZXhlciA9IG5ldyBTb2xpZGl0eUxleGVyKGlucHV0U3RyZWFtKTtcbiAgcmV0dXJuIGJ1aWxkVG9rZW5MaXN0KGxleGVyLmdldEFsbFRva2VucygpLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgaW5wdXRTdHJlYW0gPSBuZXcgaW1wb3J0X2FudGxyNHRzLkFOVExSSW5wdXRTdHJlYW0oaW5wdXQpO1xuICBjb25zdCBsZXhlciA9IG5ldyBTb2xpZGl0eUxleGVyKGlucHV0U3RyZWFtKTtcbiAgY29uc3QgdG9rZW5TdHJlYW0gPSBuZXcgaW1wb3J0X2FudGxyNHRzLkNvbW1vblRva2VuU3RyZWFtKGxleGVyKTtcbiAgY29uc3QgcGFyc2VyID0gbmV3IFNvbGlkaXR5UGFyc2VyKHRva2VuU3RyZWFtKTtcbiAgY29uc3QgbGlzdGVuZXIgPSBuZXcgRXJyb3JMaXN0ZW5lcl9kZWZhdWx0KCk7XG4gIGxleGVyLnJlbW92ZUVycm9yTGlzdGVuZXJzKCk7XG4gIGxleGVyLmFkZEVycm9yTGlzdGVuZXIobGlzdGVuZXIpO1xuICBwYXJzZXIucmVtb3ZlRXJyb3JMaXN0ZW5lcnMoKTtcbiAgcGFyc2VyLmFkZEVycm9yTGlzdGVuZXIobGlzdGVuZXIpO1xuICBwYXJzZXIuYnVpbGRQYXJzZVRyZWUgPSB0cnVlO1xuICBjb25zdCBzb3VyY2VVbml0ID0gcGFyc2VyLnNvdXJjZVVuaXQoKTtcbiAgY29uc3QgYXN0QnVpbGRlciA9IG5ldyBBU1RCdWlsZGVyKG9wdGlvbnMpO1xuICBhc3RCdWlsZGVyLnZpc2l0KHNvdXJjZVVuaXQpO1xuICBjb25zdCBhc3QgPSBhc3RCdWlsZGVyLnJlc3VsdDtcbiAgaWYgKGFzdCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImFzdCBzaG91bGQgbmV2ZXIgYmUgbnVsbFwiKTtcbiAgfVxuICBsZXQgdG9rZW5MaXN0ID0gW107XG4gIGlmIChvcHRpb25zLnRva2VucyA9PT0gdHJ1ZSkge1xuICAgIHRva2VuTGlzdCA9IGJ1aWxkVG9rZW5MaXN0KHRva2VuU3RyZWFtLmdldFRva2VucygpLCBvcHRpb25zKTtcbiAgfVxuICBpZiAob3B0aW9ucy50b2xlcmFudCAhPT0gdHJ1ZSAmJiBsaXN0ZW5lci5oYXNFcnJvcnMoKSkge1xuICAgIHRocm93IG5ldyBQYXJzZXJFcnJvcih7ZXJyb3JzOiBsaXN0ZW5lci5nZXRFcnJvcnMoKX0pO1xuICB9XG4gIGlmIChvcHRpb25zLnRvbGVyYW50ID09PSB0cnVlICYmIGxpc3RlbmVyLmhhc0Vycm9ycygpKSB7XG4gICAgYXN0LmVycm9ycyA9IGxpc3RlbmVyLmdldEVycm9ycygpO1xuICB9XG4gIGlmIChvcHRpb25zLnRva2VucyA9PT0gdHJ1ZSkge1xuICAgIGFzdC50b2tlbnMgPSB0b2tlbkxpc3Q7XG4gIH1cbiAgcmV0dXJuIGFzdDtcbn1cbmZ1bmN0aW9uIF9pc0FTVE5vZGUobm9kZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09IFwib2JqZWN0XCIgfHwgbm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBub2RlQXNBbnkgPSBub2RlO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGVBc0FueSwgXCJ0eXBlXCIpICYmIHR5cGVvZiBub2RlQXNBbnkudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBhc3ROb2RlVHlwZXMuaW5jbHVkZXMobm9kZUFzQW55LnR5cGUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHZpc2l0KG5vZGUsIHZpc2l0b3IsIG5vZGVQYXJlbnQpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBub2RlLmZvckVhY2goKGNoaWxkKSA9PiB2aXNpdChjaGlsZCwgdmlzaXRvciwgbm9kZVBhcmVudCkpO1xuICB9XG4gIGlmICghX2lzQVNUTm9kZShub2RlKSlcbiAgICByZXR1cm47XG4gIGxldCBjb250ID0gdHJ1ZTtcbiAgaWYgKHZpc2l0b3Jbbm9kZS50eXBlXSAhPT0gdm9pZCAwKSB7XG4gICAgY29udCA9IHZpc2l0b3Jbbm9kZS50eXBlXShub2RlLCBub2RlUGFyZW50KTtcbiAgfVxuICBpZiAoY29udCA9PT0gZmFsc2UpXG4gICAgcmV0dXJuO1xuICBmb3IgKGNvbnN0IHByb3AgaW4gbm9kZSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZSwgcHJvcCkpIHtcbiAgICAgIHZpc2l0KG5vZGVbcHJvcF0sIHZpc2l0b3IsIG5vZGUpO1xuICAgIH1cbiAgfVxuICBjb25zdCBzZWxlY3RvciA9IG5vZGUudHlwZSArIFwiOmV4aXRcIjtcbiAgaWYgKHZpc2l0b3Jbc2VsZWN0b3JdICE9PSB2b2lkIDApIHtcbiAgICB2aXNpdG9yW3NlbGVjdG9yXShub2RlLCBub2RlUGFyZW50KTtcbiAgfVxufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIFBhcnNlckVycm9yLFxuICBwYXJzZSxcbiAgdG9rZW5pemUsXG4gIHZpc2l0XG59KTtcbi8qIVxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNELTMtQ2xhdXNlIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyohIGh0dHBzOi8vbXRocy5iZS9jb2RlcG9pbnRhdCB2MC4yLjAgYnkgQG1hdGhpYXMgKi9cbi8qISBodHRwczovL210aHMuYmUvZnJvbWNvZGVwb2ludCB2MC4yLjEgYnkgQG1hdGhpYXMgKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmNqcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-gas-reporter/node_modules/@solidity-parser/parser/dist/index.cjs.js\n");

/***/ })

};
;