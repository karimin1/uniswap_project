/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/difflib";
exports.ids = ["vendor-chunks/difflib"];
exports.modules = {

/***/ "(ssr)/./node_modules/difflib/index.js":
/*!***************************************!*\
  !*** ./node_modules/difflib/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/difflib */ \"(ssr)/./node_modules/difflib/lib/difflib.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZGlmZmxpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx3R0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL2RpZmZsaWIvaW5kZXguanM/ZjZjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2RpZmZsaWInKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/difflib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/difflib/lib/difflib.js":
/*!*********************************************!*\
  !*** ./node_modules/difflib/lib/difflib.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.3.1\n\n/*\nModule difflib -- helpers for computing deltas between objects.\n\nFunction getCloseMatches(word, possibilities, n=3, cutoff=0.6):\n    Use SequenceMatcher to return list of the best \"good enough\" matches.\n\nFunction contextDiff(a, b):\n    For two lists of strings, return a delta in context diff format.\n\nFunction ndiff(a, b):\n    Return a delta: the difference between `a` and `b` (lists of strings).\n\nFunction restore(delta, which):\n    Return one of the two sequences that generated an ndiff delta.\n\nFunction unifiedDiff(a, b):\n    For two lists of strings, return a delta in unified diff format.\n\nClass SequenceMatcher:\n    A flexible class for comparing pairs of sequences of any type.\n\nClass Differ:\n    For producing human-readable deltas from sequences of lines of text.\n*/\n\n\n(function() {\n  var Differ, Heap, IS_CHARACTER_JUNK, IS_LINE_JUNK, SequenceMatcher, assert, contextDiff, floor, getCloseMatches, max, min, ndiff, restore, unifiedDiff, _any, _arrayCmp, _calculateRatio, _countLeading, _formatRangeContext, _formatRangeUnified, _has,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  floor = Math.floor, max = Math.max, min = Math.min;\n\n  Heap = __webpack_require__(/*! heap */ \"(ssr)/./node_modules/heap/index.js\");\n\n  assert = __webpack_require__(/*! assert */ \"assert\");\n\n  _calculateRatio = function(matches, length) {\n    if (length) {\n      return 2.0 * matches / length;\n    } else {\n      return 1.0;\n    }\n  };\n\n  _arrayCmp = function(a, b) {\n    var i, la, lb, _i, _ref, _ref1;\n    _ref = [a.length, b.length], la = _ref[0], lb = _ref[1];\n    for (i = _i = 0, _ref1 = min(la, lb); 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {\n      if (a[i] < b[i]) {\n        return -1;\n      }\n      if (a[i] > b[i]) {\n        return 1;\n      }\n    }\n    return la - lb;\n  };\n\n  _has = function(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n  };\n\n  _any = function(items) {\n    var item, _i, _len;\n    for (_i = 0, _len = items.length; _i < _len; _i++) {\n      item = items[_i];\n      if (item) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  SequenceMatcher = (function() {\n\n    SequenceMatcher.name = 'SequenceMatcher';\n\n    /*\n      SequenceMatcher is a flexible class for comparing pairs of sequences of\n      any type, so long as the sequence elements are hashable.  The basic\n      algorithm predates, and is a little fancier than, an algorithm\n      published in the late 1980's by Ratcliff and Obershelp under the\n      hyperbolic name \"gestalt pattern matching\".  The basic idea is to find\n      the longest contiguous matching subsequence that contains no \"junk\"\n      elements (R-O doesn't address junk).  The same idea is then applied\n      recursively to the pieces of the sequences to the left and to the right\n      of the matching subsequence.  This does not yield minimal edit\n      sequences, but does tend to yield matches that \"look right\" to people.\n    \n      SequenceMatcher tries to compute a \"human-friendly diff\" between two\n      sequences.  Unlike e.g. UNIX(tm) diff, the fundamental notion is the\n      longest *contiguous* & junk-free matching subsequence.  That's what\n      catches peoples' eyes.  The Windows(tm) windiff has another interesting\n      notion, pairing up elements that appear uniquely in each sequence.\n      That, and the method here, appear to yield more intuitive difference\n      reports than does diff.  This method appears to be the least vulnerable\n      to synching up on blocks of \"junk lines\", though (like blank lines in\n      ordinary text files, or maybe \"<P>\" lines in HTML files).  That may be\n      because this is the only method of the 3 that has a *concept* of\n      \"junk\" <wink>.\n    \n      Example, comparing two strings, and considering blanks to be \"junk\":\n    \n      >>> isjunk = (c) -> c is ' '\n      >>> s = new SequenceMatcher(isjunk,\n                                  'private Thread currentThread;',\n                                  'private volatile Thread currentThread;')\n    \n      .ratio() returns a float in [0, 1], measuring the \"similarity\" of the\n      sequences.  As a rule of thumb, a .ratio() value over 0.6 means the\n      sequences are close matches:\n    \n      >>> s.ratio().toPrecision(3)\n      '0.866'\n    \n      If you're only interested in where the sequences match,\n      .getMatchingBlocks() is handy:\n    \n      >>> for [a, b, size] in s.getMatchingBlocks()\n      ...   console.log(\"a[#{a}] and b[#{b}] match for #{size} elements\");\n      a[0] and b[0] match for 8 elements\n      a[8] and b[17] match for 21 elements\n      a[29] and b[38] match for 0 elements\n    \n      Note that the last tuple returned by .get_matching_blocks() is always a\n      dummy, (len(a), len(b), 0), and this is the only case in which the last\n      tuple element (number of elements matched) is 0.\n    \n      If you want to know how to change the first sequence into the second,\n      use .get_opcodes():\n    \n      >>> for [op, a1, a2, b1, b2] in s.getOpcodes()\n      ...   console.log \"#{op} a[#{a1}:#{a2}] b[#{b1}:#{b2}]\"\n      equal a[0:8] b[0:8]\n      insert a[8:8] b[8:17]\n      equal a[8:29] b[17:38]\n    \n      See the Differ class for a fancy human-friendly file differencer, which\n      uses SequenceMatcher both to compare sequences of lines, and to compare\n      sequences of characters within similar (near-matching) lines.\n    \n      See also function getCloseMatches() in this module, which shows how\n      simple code building on SequenceMatcher can be used to do useful work.\n    \n      Timing:  Basic R-O is cubic time worst case and quadratic time expected\n      case.  SequenceMatcher is quadratic time for the worst case and has\n      expected-case behavior dependent in a complicated way on how many\n      elements the sequences have in common; best case time is linear.\n    \n      Methods:\n    \n      constructor(isjunk=null, a='', b='')\n          Construct a SequenceMatcher.\n    \n      setSeqs(a, b)\n          Set the two sequences to be compared.\n    \n      setSeq1(a)\n          Set the first sequence to be compared.\n    \n      setSeq2(b)\n          Set the second sequence to be compared.\n    \n      findLongestMatch(alo, ahi, blo, bhi)\n          Find longest matching block in a[alo:ahi] and b[blo:bhi].\n    \n      getMatchingBlocks()\n          Return list of triples describing matching subsequences.\n    \n      getOpcodes()\n          Return list of 5-tuples describing how to turn a into b.\n    \n      ratio()\n          Return a measure of the sequences' similarity (float in [0,1]).\n    \n      quickRatio()\n          Return an upper bound on .ratio() relatively quickly.\n    \n      realQuickRatio()\n          Return an upper bound on ratio() very quickly.\n    */\n\n\n    function SequenceMatcher(isjunk, a, b, autojunk) {\n      this.isjunk = isjunk;\n      if (a == null) {\n        a = '';\n      }\n      if (b == null) {\n        b = '';\n      }\n      this.autojunk = autojunk != null ? autojunk : true;\n      /*\n          Construct a SequenceMatcher.\n      \n          Optional arg isjunk is null (the default), or a one-argument\n          function that takes a sequence element and returns true iff the\n          element is junk.  Null is equivalent to passing \"(x) -> 0\", i.e.\n          no elements are considered to be junk.  For example, pass\n              (x) -> x in ' \\t'\n          if you're comparing lines as sequences of characters, and don't\n          want to synch up on blanks or hard tabs.\n      \n          Optional arg a is the first of two sequences to be compared.  By\n          default, an empty string.  The elements of a must be hashable.  See\n          also .setSeqs() and .setSeq1().\n      \n          Optional arg b is the second of two sequences to be compared.  By\n          default, an empty string.  The elements of b must be hashable. See\n          also .setSeqs() and .setSeq2().\n      \n          Optional arg autojunk should be set to false to disable the\n          \"automatic junk heuristic\" that treats popular elements as junk\n          (see module documentation for more information).\n      */\n\n      this.a = this.b = null;\n      this.setSeqs(a, b);\n    }\n\n    SequenceMatcher.prototype.setSeqs = function(a, b) {\n      /* \n      Set the two sequences to be compared. \n      \n      >>> s = new SequenceMatcher()\n      >>> s.setSeqs('abcd', 'bcde')\n      >>> s.ratio()\n      0.75\n      */\n      this.setSeq1(a);\n      return this.setSeq2(b);\n    };\n\n    SequenceMatcher.prototype.setSeq1 = function(a) {\n      /* \n      Set the first sequence to be compared. \n      \n      The second sequence to be compared is not changed.\n      \n      >>> s = new SequenceMatcher(null, 'abcd', 'bcde')\n      >>> s.ratio()\n      0.75\n      >>> s.setSeq1('bcde')\n      >>> s.ratio()\n      1.0\n      \n      SequenceMatcher computes and caches detailed information about the\n      second sequence, so if you want to compare one sequence S against\n      many sequences, use .setSeq2(S) once and call .setSeq1(x)\n      repeatedly for each of the other sequences.\n      \n      See also setSeqs() and setSeq2().\n      */\n      if (a === this.a) {\n        return;\n      }\n      this.a = a;\n      return this.matchingBlocks = this.opcodes = null;\n    };\n\n    SequenceMatcher.prototype.setSeq2 = function(b) {\n      /*\n          Set the second sequence to be compared. \n      \n          The first sequence to be compared is not changed.\n      \n          >>> s = new SequenceMatcher(null, 'abcd', 'bcde')\n          >>> s.ratio()\n          0.75\n          >>> s.setSeq2('abcd')\n          >>> s.ratio()\n          1.0\n      \n          SequenceMatcher computes and caches detailed information about the\n          second sequence, so if you want to compare one sequence S against\n          many sequences, use .setSeq2(S) once and call .setSeq1(x)\n          repeatedly for each of the other sequences.\n      \n          See also setSeqs() and setSeq1().\n      */\n      if (b === this.b) {\n        return;\n      }\n      this.b = b;\n      this.matchingBlocks = this.opcodes = null;\n      this.fullbcount = null;\n      return this._chainB();\n    };\n\n    SequenceMatcher.prototype._chainB = function() {\n      var b, b2j, elt, i, idxs, indices, isjunk, junk, n, ntest, popular, _i, _j, _len, _len1, _ref;\n      b = this.b;\n      this.b2j = b2j = {};\n      for (i = _i = 0, _len = b.length; _i < _len; i = ++_i) {\n        elt = b[i];\n        indices = _has(b2j, elt) ? b2j[elt] : b2j[elt] = [];\n        indices.push(i);\n      }\n      junk = {};\n      isjunk = this.isjunk;\n      if (isjunk) {\n        _ref = Object.keys(b2j);\n        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {\n          elt = _ref[_j];\n          if (isjunk(elt)) {\n            junk[elt] = true;\n            delete b2j[elt];\n          }\n        }\n      }\n      popular = {};\n      n = b.length;\n      if (this.autojunk && n >= 200) {\n        ntest = floor(n / 100) + 1;\n        for (elt in b2j) {\n          idxs = b2j[elt];\n          if (idxs.length > ntest) {\n            popular[elt] = true;\n            delete b2j[elt];\n          }\n        }\n      }\n      this.isbjunk = function(b) {\n        return _has(junk, b);\n      };\n      return this.isbpopular = function(b) {\n        return _has(popular, b);\n      };\n    };\n\n    SequenceMatcher.prototype.findLongestMatch = function(alo, ahi, blo, bhi) {\n      /* \n      Find longest matching block in a[alo...ahi] and b[blo...bhi].  \n      \n      If isjunk is not defined:\n      \n      Return [i,j,k] such that a[i...i+k] is equal to b[j...j+k], where\n          alo <= i <= i+k <= ahi\n          blo <= j <= j+k <= bhi\n      and for all [i',j',k'] meeting those conditions,\n          k >= k'\n          i <= i'\n          and if i == i', j <= j'\n      \n      In other words, of all maximal matching blocks, return one that\n      starts earliest in a, and of all those maximal matching blocks that\n      start earliest in a, return the one that starts earliest in b.\n      \n      >>> isjunk = (x) -> x is ' '\n      >>> s = new SequenceMatcher(isjunk, ' abcd', 'abcd abcd')\n      >>> s.findLongestMatch(0, 5, 0, 9)\n      [1, 0, 4]\n      \n      >>> s = new SequenceMatcher(null, 'ab', 'c')\n      >>> s.findLongestMatch(0, 2, 0, 1)\n      [0, 0, 0]\n      */\n\n      var a, b, b2j, besti, bestj, bestsize, i, isbjunk, j, j2len, k, newj2len, _i, _j, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;\n      _ref = [this.a, this.b, this.b2j, this.isbjunk], a = _ref[0], b = _ref[1], b2j = _ref[2], isbjunk = _ref[3];\n      _ref1 = [alo, blo, 0], besti = _ref1[0], bestj = _ref1[1], bestsize = _ref1[2];\n      j2len = {};\n      for (i = _i = alo; alo <= ahi ? _i < ahi : _i > ahi; i = alo <= ahi ? ++_i : --_i) {\n        newj2len = {};\n        _ref2 = (_has(b2j, a[i]) ? b2j[a[i]] : []);\n        for (_j = 0, _len = _ref2.length; _j < _len; _j++) {\n          j = _ref2[_j];\n          if (j < blo) {\n            continue;\n          }\n          if (j >= bhi) {\n            break;\n          }\n          k = newj2len[j] = (j2len[j - 1] || 0) + 1;\n          if (k > bestsize) {\n            _ref3 = [i - k + 1, j - k + 1, k], besti = _ref3[0], bestj = _ref3[1], bestsize = _ref3[2];\n          }\n        }\n        j2len = newj2len;\n      }\n      while (besti > alo && bestj > blo && !isbjunk(b[bestj - 1]) && a[besti - 1] === b[bestj - 1]) {\n        _ref4 = [besti - 1, bestj - 1, bestsize + 1], besti = _ref4[0], bestj = _ref4[1], bestsize = _ref4[2];\n      }\n      while (besti + bestsize < ahi && bestj + bestsize < bhi && !isbjunk(b[bestj + bestsize]) && a[besti + bestsize] === b[bestj + bestsize]) {\n        bestsize++;\n      }\n      while (besti > alo && bestj > blo && isbjunk(b[bestj - 1]) && a[besti - 1] === b[bestj - 1]) {\n        _ref5 = [besti - 1, bestj - 1, bestsize + 1], besti = _ref5[0], bestj = _ref5[1], bestsize = _ref5[2];\n      }\n      while (besti + bestsize < ahi && bestj + bestsize < bhi && isbjunk(b[bestj + bestsize]) && a[besti + bestsize] === b[bestj + bestsize]) {\n        bestsize++;\n      }\n      return [besti, bestj, bestsize];\n    };\n\n    SequenceMatcher.prototype.getMatchingBlocks = function() {\n      /*\n          Return list of triples describing matching subsequences.\n      \n          Each triple is of the form [i, j, n], and means that\n          a[i...i+n] == b[j...j+n].  The triples are monotonically increasing in\n          i and in j.  it's also guaranteed that if\n          [i, j, n] and [i', j', n'] are adjacent triples in the list, and\n          the second is not the last triple in the list, then i+n != i' or\n          j+n != j'.  IOW, adjacent triples never describe adjacent equal\n          blocks.\n      \n          The last triple is a dummy, [a.length, b.length, 0], and is the only\n          triple with n==0.\n      \n          >>> s = new SequenceMatcher(null, 'abxcd', 'abcd')\n          >>> s.getMatchingBlocks()\n          [[0, 0, 2], [3, 2, 2], [5, 4, 0]]\n      */\n\n      var ahi, alo, bhi, blo, i, i1, i2, j, j1, j2, k, k1, k2, la, lb, matchingBlocks, nonAdjacent, queue, x, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4;\n      if (this.matchingBlocks) {\n        return this.matchingBlocks;\n      }\n      _ref = [this.a.length, this.b.length], la = _ref[0], lb = _ref[1];\n      queue = [[0, la, 0, lb]];\n      matchingBlocks = [];\n      while (queue.length) {\n        _ref1 = queue.pop(), alo = _ref1[0], ahi = _ref1[1], blo = _ref1[2], bhi = _ref1[3];\n        _ref2 = x = this.findLongestMatch(alo, ahi, blo, bhi), i = _ref2[0], j = _ref2[1], k = _ref2[2];\n        if (k) {\n          matchingBlocks.push(x);\n          if (alo < i && blo < j) {\n            queue.push([alo, i, blo, j]);\n          }\n          if (i + k < ahi && j + k < bhi) {\n            queue.push([i + k, ahi, j + k, bhi]);\n          }\n        }\n      }\n      matchingBlocks.sort(_arrayCmp);\n      i1 = j1 = k1 = 0;\n      nonAdjacent = [];\n      for (_i = 0, _len = matchingBlocks.length; _i < _len; _i++) {\n        _ref3 = matchingBlocks[_i], i2 = _ref3[0], j2 = _ref3[1], k2 = _ref3[2];\n        if (i1 + k1 === i2 && j1 + k1 === j2) {\n          k1 += k2;\n        } else {\n          if (k1) {\n            nonAdjacent.push([i1, j1, k1]);\n          }\n          _ref4 = [i2, j2, k2], i1 = _ref4[0], j1 = _ref4[1], k1 = _ref4[2];\n        }\n      }\n      if (k1) {\n        nonAdjacent.push([i1, j1, k1]);\n      }\n      nonAdjacent.push([la, lb, 0]);\n      return this.matchingBlocks = nonAdjacent;\n    };\n\n    SequenceMatcher.prototype.getOpcodes = function() {\n      /* \n      Return list of 5-tuples describing how to turn a into b.\n      \n      Each tuple is of the form [tag, i1, i2, j1, j2].  The first tuple\n      has i1 == j1 == 0, and remaining tuples have i1 == the i2 from the\n      tuple preceding it, and likewise for j1 == the previous j2.\n      \n      The tags are strings, with these meanings:\n      \n      'replace':  a[i1...i2] should be replaced by b[j1...j2]\n      'delete':   a[i1...i2] should be deleted.\n                  Note that j1==j2 in this case.\n      'insert':   b[j1...j2] should be inserted at a[i1...i1].\n                  Note that i1==i2 in this case.\n      'equal':    a[i1...i2] == b[j1...j2]\n      \n      >>> s = new SequenceMatcher(null, 'qabxcd', 'abycdf')\n      >>> s.getOpcodes()\n      [ [ 'delete'  , 0 , 1 , 0 , 0 ] ,\n        [ 'equal'   , 1 , 3 , 0 , 2 ] ,\n        [ 'replace' , 3 , 4 , 2 , 3 ] ,\n        [ 'equal'   , 4 , 6 , 3 , 5 ] ,\n        [ 'insert'  , 6 , 6 , 5 , 6 ] ]\n      */\n\n      var ai, answer, bj, i, j, size, tag, _i, _len, _ref, _ref1, _ref2;\n      if (this.opcodes) {\n        return this.opcodes;\n      }\n      i = j = 0;\n      this.opcodes = answer = [];\n      _ref = this.getMatchingBlocks();\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        _ref1 = _ref[_i], ai = _ref1[0], bj = _ref1[1], size = _ref1[2];\n        tag = '';\n        if (i < ai && j < bj) {\n          tag = 'replace';\n        } else if (i < ai) {\n          tag = 'delete';\n        } else if (j < bj) {\n          tag = 'insert';\n        }\n        if (tag) {\n          answer.push([tag, i, ai, j, bj]);\n        }\n        _ref2 = [ai + size, bj + size], i = _ref2[0], j = _ref2[1];\n        if (size) {\n          answer.push(['equal', ai, i, bj, j]);\n        }\n      }\n      return answer;\n    };\n\n    SequenceMatcher.prototype.getGroupedOpcodes = function(n) {\n      var codes, group, groups, i1, i2, j1, j2, nn, tag, _i, _len, _ref, _ref1, _ref2, _ref3;\n      if (n == null) {\n        n = 3;\n      }\n      /* \n      Isolate change clusters by eliminating ranges with no changes.\n      \n      Return a list groups with upto n lines of context.\n      Each group is in the same format as returned by get_opcodes().\n      \n      >>> a = [1...40].map(String)\n      >>> b = a.slice()\n      >>> b[8...8] = 'i'\n      >>> b[20] += 'x'\n      >>> b[23...28] = []\n      >>> b[30] += 'y'\n      >>> s = new SequenceMatcher(null, a, b)\n      >>> s.getGroupedOpcodes()\n      [ [ [ 'equal'  , 5 , 8  , 5 , 8 ],\n          [ 'insert' , 8 , 8  , 8 , 9 ],\n          [ 'equal'  , 8 , 11 , 9 , 12 ] ],\n        [ [ 'equal'   , 16 , 19 , 17 , 20 ],\n          [ 'replace' , 19 , 20 , 20 , 21 ],\n          [ 'equal'   , 20 , 22 , 21 , 23 ],\n          [ 'delete'  , 22 , 27 , 23 , 23 ],\n          [ 'equal'   , 27 , 30 , 23 , 26 ] ],\n        [ [ 'equal'   , 31 , 34 , 27 , 30 ],\n          [ 'replace' , 34 , 35 , 30 , 31 ],\n          [ 'equal'   , 35 , 38 , 31 , 34 ] ] ]\n      */\n\n      codes = this.getOpcodes();\n      if (!codes.length) {\n        codes = [['equal', 0, 1, 0, 1]];\n      }\n      if (codes[0][0] === 'equal') {\n        _ref = codes[0], tag = _ref[0], i1 = _ref[1], i2 = _ref[2], j1 = _ref[3], j2 = _ref[4];\n        codes[0] = [tag, max(i1, i2 - n), i2, max(j1, j2 - n), j2];\n      }\n      if (codes[codes.length - 1][0] === 'equal') {\n        _ref1 = codes[codes.length - 1], tag = _ref1[0], i1 = _ref1[1], i2 = _ref1[2], j1 = _ref1[3], j2 = _ref1[4];\n        codes[codes.length - 1] = [tag, i1, min(i2, i1 + n), j1, min(j2, j1 + n)];\n      }\n      nn = n + n;\n      groups = [];\n      group = [];\n      for (_i = 0, _len = codes.length; _i < _len; _i++) {\n        _ref2 = codes[_i], tag = _ref2[0], i1 = _ref2[1], i2 = _ref2[2], j1 = _ref2[3], j2 = _ref2[4];\n        if (tag === 'equal' && i2 - i1 > nn) {\n          group.push([tag, i1, min(i2, i1 + n), j1, min(j2, j1 + n)]);\n          groups.push(group);\n          group = [];\n          _ref3 = [max(i1, i2 - n), max(j1, j2 - n)], i1 = _ref3[0], j1 = _ref3[1];\n        }\n        group.push([tag, i1, i2, j1, j2]);\n      }\n      if (group.length && !(group.length === 1 && group[0][0] === 'equal')) {\n        groups.push(group);\n      }\n      return groups;\n    };\n\n    SequenceMatcher.prototype.ratio = function() {\n      /*\n          Return a measure of the sequences' similarity (float in [0,1]).\n      \n          Where T is the total number of elements in both sequences, and\n          M is the number of matches, this is 2.0*M / T.\n          Note that this is 1 if the sequences are identical, and 0 if\n          they have nothing in common.\n      \n          .ratio() is expensive to compute if you haven't already computed\n          .getMatchingBlocks() or .getOpcodes(), in which case you may\n          want to try .quickRatio() or .realQuickRatio() first to get an\n          upper bound.\n          \n          >>> s = new SequenceMatcher(null, 'abcd', 'bcde')\n          >>> s.ratio()\n          0.75\n          >>> s.quickRatio()\n          0.75\n          >>> s.realQuickRatio()\n          1.0\n      */\n\n      var match, matches, _i, _len, _ref;\n      matches = 0;\n      _ref = this.getMatchingBlocks();\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        match = _ref[_i];\n        matches += match[2];\n      }\n      return _calculateRatio(matches, this.a.length + this.b.length);\n    };\n\n    SequenceMatcher.prototype.quickRatio = function() {\n      /*\n          Return an upper bound on ratio() relatively quickly.\n      \n          This isn't defined beyond that it is an upper bound on .ratio(), and\n          is faster to compute.\n      */\n\n      var avail, elt, fullbcount, matches, numb, _i, _j, _len, _len1, _ref, _ref1;\n      if (!this.fullbcount) {\n        this.fullbcount = fullbcount = {};\n        _ref = this.b;\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          elt = _ref[_i];\n          fullbcount[elt] = (fullbcount[elt] || 0) + 1;\n        }\n      }\n      fullbcount = this.fullbcount;\n      avail = {};\n      matches = 0;\n      _ref1 = this.a;\n      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n        elt = _ref1[_j];\n        if (_has(avail, elt)) {\n          numb = avail[elt];\n        } else {\n          numb = fullbcount[elt] || 0;\n        }\n        avail[elt] = numb - 1;\n        if (numb > 0) {\n          matches++;\n        }\n      }\n      return _calculateRatio(matches, this.a.length + this.b.length);\n    };\n\n    SequenceMatcher.prototype.realQuickRatio = function() {\n      /*\n          Return an upper bound on ratio() very quickly.\n      \n          This isn't defined beyond that it is an upper bound on .ratio(), and\n          is faster to compute than either .ratio() or .quickRatio().\n      */\n\n      var la, lb, _ref;\n      _ref = [this.a.length, this.b.length], la = _ref[0], lb = _ref[1];\n      return _calculateRatio(min(la, lb), la + lb);\n    };\n\n    return SequenceMatcher;\n\n  })();\n\n  getCloseMatches = function(word, possibilities, n, cutoff) {\n    var result, s, score, x, _i, _j, _len, _len1, _ref, _results;\n    if (n == null) {\n      n = 3;\n    }\n    if (cutoff == null) {\n      cutoff = 0.6;\n    }\n    /*\n      Use SequenceMatcher to return list of the best \"good enough\" matches.\n    \n      word is a sequence for which close matches are desired (typically a\n      string).\n    \n      possibilities is a list of sequences against which to match word\n      (typically a list of strings).\n    \n      Optional arg n (default 3) is the maximum number of close matches to\n      return.  n must be > 0.\n    \n      Optional arg cutoff (default 0.6) is a float in [0, 1].  Possibilities\n      that don't score at least that similar to word are ignored.\n    \n      The best (no more than n) matches among the possibilities are returned\n      in a list, sorted by similarity score, most similar first.\n    \n      >>> getCloseMatches('appel', ['ape', 'apple', 'peach', 'puppy'])\n      ['apple', 'ape']\n      >>> KEYWORDS = require('coffee-script').RESERVED\n      >>> getCloseMatches('wheel', KEYWORDS)\n      ['when', 'while']\n      >>> getCloseMatches('accost', KEYWORDS)\n      ['const']\n    */\n\n    if (!(n > 0)) {\n      throw new Error(\"n must be > 0: (\" + n + \")\");\n    }\n    if (!((0.0 <= cutoff && cutoff <= 1.0))) {\n      throw new Error(\"cutoff must be in [0.0, 1.0]: (\" + cutoff + \")\");\n    }\n    result = [];\n    s = new SequenceMatcher();\n    s.setSeq2(word);\n    for (_i = 0, _len = possibilities.length; _i < _len; _i++) {\n      x = possibilities[_i];\n      s.setSeq1(x);\n      if (s.realQuickRatio() >= cutoff && s.quickRatio() >= cutoff && s.ratio() >= cutoff) {\n        result.push([s.ratio(), x]);\n      }\n    }\n    result = Heap.nlargest(result, n, _arrayCmp);\n    _results = [];\n    for (_j = 0, _len1 = result.length; _j < _len1; _j++) {\n      _ref = result[_j], score = _ref[0], x = _ref[1];\n      _results.push(x);\n    }\n    return _results;\n  };\n\n  _countLeading = function(line, ch) {\n    /*\n      Return number of `ch` characters at the start of `line`.\n    \n      >>> _countLeading('   abc', ' ')\n      3\n    */\n\n    var i, n, _ref;\n    _ref = [0, line.length], i = _ref[0], n = _ref[1];\n    while (i < n && line[i] === ch) {\n      i++;\n    }\n    return i;\n  };\n\n  Differ = (function() {\n\n    Differ.name = 'Differ';\n\n    /*\n      Differ is a class for comparing sequences of lines of text, and\n      producing human-readable differences or deltas.  Differ uses\n      SequenceMatcher both to compare sequences of lines, and to compare\n      sequences of characters within similar (near-matching) lines.\n    \n      Each line of a Differ delta begins with a two-letter code:\n    \n          '- '    line unique to sequence 1\n          '+ '    line unique to sequence 2\n          '  '    line common to both sequences\n          '? '    line not present in either input sequence\n    \n      Lines beginning with '? ' attempt to guide the eye to intraline\n      differences, and were not present in either input sequence.  These lines\n      can be confusing if the sequences contain tab characters.\n    \n      Note that Differ makes no claim to produce a *minimal* diff.  To the\n      contrary, minimal diffs are often counter-intuitive, because they synch\n      up anywhere possible, sometimes accidental matches 100 pages apart.\n      Restricting synch points to contiguous matches preserves some notion of\n      locality, at the occasional cost of producing a longer diff.\n    \n      Example: Comparing two texts.\n    \n      >>> text1 = ['1. Beautiful is better than ugly.\\n',\n      ...   '2. Explicit is better than implicit.\\n',\n      ...   '3. Simple is better than complex.\\n',\n      ...   '4. Complex is better than complicated.\\n']\n      >>> text1.length\n      4\n      >>> text2 = ['1. Beautiful is better than ugly.\\n',\n      ...   '3.   Simple is better than complex.\\n',\n      ...   '4. Complicated is better than complex.\\n',\n      ...   '5. Flat is better than nested.\\n']\n    \n      Next we instantiate a Differ object:\n    \n      >>> d = new Differ()\n    \n      Note that when instantiating a Differ object we may pass functions to\n      filter out line and character 'junk'.\n    \n      Finally, we compare the two:\n    \n      >>> result = d.compare(text1, text2)\n      [ '  1. Beautiful is better than ugly.\\n',\n        '- 2. Explicit is better than implicit.\\n',\n        '- 3. Simple is better than complex.\\n',\n        '+ 3.   Simple is better than complex.\\n',\n        '?   ++\\n',\n        '- 4. Complex is better than complicated.\\n',\n        '?          ^                     ---- ^\\n',\n        '+ 4. Complicated is better than complex.\\n',\n        '?         ++++ ^                      ^\\n',\n        '+ 5. Flat is better than nested.\\n' ]\n    \n      Methods:\n    \n      constructor(linejunk=null, charjunk=null)\n          Construct a text differencer, with optional filters.\n      compare(a, b)\n          Compare two sequences of lines; generate the resulting delta.\n    */\n\n\n    function Differ(linejunk, charjunk) {\n      this.linejunk = linejunk;\n      this.charjunk = charjunk;\n      /*\n          Construct a text differencer, with optional filters.\n      \n          The two optional keyword parameters are for filter functions:\n      \n          - `linejunk`: A function that should accept a single string argument,\n            and return true iff the string is junk. The module-level function\n            `IS_LINE_JUNK` may be used to filter out lines without visible\n            characters, except for at most one splat ('#').  It is recommended\n            to leave linejunk null. \n      \n          - `charjunk`: A function that should accept a string of length 1. The\n            module-level function `IS_CHARACTER_JUNK` may be used to filter out\n            whitespace characters (a blank or tab; **note**: bad idea to include\n            newline in this!).  Use of IS_CHARACTER_JUNK is recommended.\n      */\n\n    }\n\n    Differ.prototype.compare = function(a, b) {\n      /*\n          Compare two sequences of lines; generate the resulting delta.\n      \n          Each sequence must contain individual single-line strings ending with\n          newlines. Such sequences can be obtained from the `readlines()` method\n          of file-like objects.  The delta generated also consists of newline-\n          terminated strings, ready to be printed as-is via the writeline()\n          method of a file-like object.\n      \n          Example:\n      \n          >>> d = new Differ\n          >>> d.compare(['one\\n', 'two\\n', 'three\\n'],\n          ...           ['ore\\n', 'tree\\n', 'emu\\n'])\n          [ '- one\\n',\n            '?  ^\\n',\n            '+ ore\\n',\n            '?  ^\\n',\n            '- two\\n',\n            '- three\\n',\n            '?  -\\n',\n            '+ tree\\n',\n            '+ emu\\n' ]\n      */\n\n      var ahi, alo, bhi, blo, cruncher, g, line, lines, tag, _i, _j, _len, _len1, _ref, _ref1;\n      cruncher = new SequenceMatcher(this.linejunk, a, b);\n      lines = [];\n      _ref = cruncher.getOpcodes();\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        _ref1 = _ref[_i], tag = _ref1[0], alo = _ref1[1], ahi = _ref1[2], blo = _ref1[3], bhi = _ref1[4];\n        switch (tag) {\n          case 'replace':\n            g = this._fancyReplace(a, alo, ahi, b, blo, bhi);\n            break;\n          case 'delete':\n            g = this._dump('-', a, alo, ahi);\n            break;\n          case 'insert':\n            g = this._dump('+', b, blo, bhi);\n            break;\n          case 'equal':\n            g = this._dump(' ', a, alo, ahi);\n            break;\n          default:\n            throw new Error(\"unknow tag (\" + tag + \")\");\n        }\n        for (_j = 0, _len1 = g.length; _j < _len1; _j++) {\n          line = g[_j];\n          lines.push(line);\n        }\n      }\n      return lines;\n    };\n\n    Differ.prototype._dump = function(tag, x, lo, hi) {\n      /*\n          Generate comparison results for a same-tagged range.\n      */\n\n      var i, _i, _results;\n      _results = [];\n      for (i = _i = lo; lo <= hi ? _i < hi : _i > hi; i = lo <= hi ? ++_i : --_i) {\n        _results.push(\"\" + tag + \" \" + x[i]);\n      }\n      return _results;\n    };\n\n    Differ.prototype._plainReplace = function(a, alo, ahi, b, blo, bhi) {\n      var first, g, line, lines, second, _i, _j, _len, _len1, _ref;\n      assert(alo < ahi && blo < bhi);\n      if (bhi - blo < ahi - alo) {\n        first = this._dump('+', b, blo, bhi);\n        second = this._dump('-', a, alo, ahi);\n      } else {\n        first = this._dump('-', a, alo, ahi);\n        second = this._dump('+', b, blo, bhi);\n      }\n      lines = [];\n      _ref = [first, second];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        g = _ref[_i];\n        for (_j = 0, _len1 = g.length; _j < _len1; _j++) {\n          line = g[_j];\n          lines.push(line);\n        }\n      }\n      return lines;\n    };\n\n    Differ.prototype._fancyReplace = function(a, alo, ahi, b, blo, bhi) {\n      /*\n          When replacing one block of lines with another, search the blocks\n          for *similar* lines; the best-matching pair (if any) is used as a\n          synch point, and intraline difference marking is done on the\n          similar pair. Lots of work, but often worth it.\n      \n          Example:\n          >>> d = new Differ\n          >>> d._fancyReplace(['abcDefghiJkl\\n'], 0, 1,\n          ...                 ['abcdefGhijkl\\n'], 0, 1)\n          [ '- abcDefghiJkl\\n',\n            '?    ^  ^  ^\\n',\n            '+ abcdefGhijkl\\n',\n            '?    ^  ^  ^\\n' ]\n      */\n\n      var aelt, ai, ai1, ai2, atags, belt, bestRatio, besti, bestj, bj, bj1, bj2, btags, cruncher, cutoff, eqi, eqj, i, j, la, lb, line, lines, tag, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _o, _ref, _ref1, _ref10, _ref11, _ref12, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;\n      _ref = [0.74, 0.75], bestRatio = _ref[0], cutoff = _ref[1];\n      cruncher = new SequenceMatcher(this.charjunk);\n      _ref1 = [null, null], eqi = _ref1[0], eqj = _ref1[1];\n      lines = [];\n      for (j = _i = blo; blo <= bhi ? _i < bhi : _i > bhi; j = blo <= bhi ? ++_i : --_i) {\n        bj = b[j];\n        cruncher.setSeq2(bj);\n        for (i = _j = alo; alo <= ahi ? _j < ahi : _j > ahi; i = alo <= ahi ? ++_j : --_j) {\n          ai = a[i];\n          if (ai === bj) {\n            if (eqi === null) {\n              _ref2 = [i, j], eqi = _ref2[0], eqj = _ref2[1];\n            }\n            continue;\n          }\n          cruncher.setSeq1(ai);\n          if (cruncher.realQuickRatio() > bestRatio && cruncher.quickRatio() > bestRatio && cruncher.ratio() > bestRatio) {\n            _ref3 = [cruncher.ratio(), i, j], bestRatio = _ref3[0], besti = _ref3[1], bestj = _ref3[2];\n          }\n        }\n      }\n      if (bestRatio < cutoff) {\n        if (eqi === null) {\n          _ref4 = this._plainReplace(a, alo, ahi, b, blo, bhi);\n          for (_k = 0, _len = _ref4.length; _k < _len; _k++) {\n            line = _ref4[_k];\n            lines.push(line);\n          }\n          return lines;\n        }\n        _ref5 = [eqi, eqj, 1.0], besti = _ref5[0], bestj = _ref5[1], bestRatio = _ref5[2];\n      } else {\n        eqi = null;\n      }\n      _ref6 = this._fancyHelper(a, alo, besti, b, blo, bestj);\n      for (_l = 0, _len1 = _ref6.length; _l < _len1; _l++) {\n        line = _ref6[_l];\n        lines.push(line);\n      }\n      _ref7 = [a[besti], b[bestj]], aelt = _ref7[0], belt = _ref7[1];\n      if (eqi === null) {\n        atags = btags = '';\n        cruncher.setSeqs(aelt, belt);\n        _ref8 = cruncher.getOpcodes();\n        for (_m = 0, _len2 = _ref8.length; _m < _len2; _m++) {\n          _ref9 = _ref8[_m], tag = _ref9[0], ai1 = _ref9[1], ai2 = _ref9[2], bj1 = _ref9[3], bj2 = _ref9[4];\n          _ref10 = [ai2 - ai1, bj2 - bj1], la = _ref10[0], lb = _ref10[1];\n          switch (tag) {\n            case 'replace':\n              atags += Array(la + 1).join('^');\n              btags += Array(lb + 1).join('^');\n              break;\n            case 'delete':\n              atags += Array(la + 1).join('-');\n              break;\n            case 'insert':\n              btags += Array(lb + 1).join('+');\n              break;\n            case 'equal':\n              atags += Array(la + 1).join(' ');\n              btags += Array(lb + 1).join(' ');\n              break;\n            default:\n              throw new Error(\"unknow tag (\" + tag + \")\");\n          }\n        }\n        _ref11 = this._qformat(aelt, belt, atags, btags);\n        for (_n = 0, _len3 = _ref11.length; _n < _len3; _n++) {\n          line = _ref11[_n];\n          lines.push(line);\n        }\n      } else {\n        lines.push('  ' + aelt);\n      }\n      _ref12 = this._fancyHelper(a, besti + 1, ahi, b, bestj + 1, bhi);\n      for (_o = 0, _len4 = _ref12.length; _o < _len4; _o++) {\n        line = _ref12[_o];\n        lines.push(line);\n      }\n      return lines;\n    };\n\n    Differ.prototype._fancyHelper = function(a, alo, ahi, b, blo, bhi) {\n      var g;\n      g = [];\n      if (alo < ahi) {\n        if (blo < bhi) {\n          g = this._fancyReplace(a, alo, ahi, b, blo, bhi);\n        } else {\n          g = this._dump('-', a, alo, ahi);\n        }\n      } else if (blo < bhi) {\n        g = this._dump('+', b, blo, bhi);\n      }\n      return g;\n    };\n\n    Differ.prototype._qformat = function(aline, bline, atags, btags) {\n      /*\n          Format \"?\" output and deal with leading tabs.\n      \n          Example:\n      \n          >>> d = new Differ\n          >>> d._qformat('\\tabcDefghiJkl\\n', '\\tabcdefGhijkl\\n',\n          [ '- \\tabcDefghiJkl\\n',\n            '? \\t ^ ^  ^\\n',\n            '+ \\tabcdefGhijkl\\n',\n            '? \\t ^ ^  ^\\n' ]\n      */\n\n      var common, lines;\n      lines = [];\n      common = min(_countLeading(aline, '\\t'), _countLeading(bline, '\\t'));\n      common = min(common, _countLeading(atags.slice(0, common), ' '));\n      common = min(common, _countLeading(btags.slice(0, common), ' '));\n      atags = atags.slice(common).replace(/\\s+$/, '');\n      btags = btags.slice(common).replace(/\\s+$/, '');\n      lines.push('- ' + aline);\n      if (atags.length) {\n        lines.push(\"? \" + (Array(common + 1).join('\\t')) + atags + \"\\n\");\n      }\n      lines.push('+ ' + bline);\n      if (btags.length) {\n        lines.push(\"? \" + (Array(common + 1).join('\\t')) + btags + \"\\n\");\n      }\n      return lines;\n    };\n\n    return Differ;\n\n  })();\n\n  IS_LINE_JUNK = function(line, pat) {\n    if (pat == null) {\n      pat = /^\\s*#?\\s*$/;\n    }\n    /*\n      Return 1 for ignorable line: iff `line` is blank or contains a single '#'.\n        \n      Examples:\n    \n      >>> IS_LINE_JUNK('\\n')\n      true\n      >>> IS_LINE_JUNK('  #   \\n')\n      true\n      >>> IS_LINE_JUNK('hello\\n')\n      false\n    */\n\n    return pat.test(line);\n  };\n\n  IS_CHARACTER_JUNK = function(ch, ws) {\n    if (ws == null) {\n      ws = ' \\t';\n    }\n    /*\n      Return 1 for ignorable character: iff `ch` is a space or tab.\n    \n      Examples:\n      >>> IS_CHARACTER_JUNK(' ').should.be.true\n      true\n      >>> IS_CHARACTER_JUNK('\\t').should.be.true\n      true\n      >>> IS_CHARACTER_JUNK('\\n').should.be.false\n      false\n      >>> IS_CHARACTER_JUNK('x').should.be.false\n      false\n    */\n\n    return __indexOf.call(ws, ch) >= 0;\n  };\n\n  _formatRangeUnified = function(start, stop) {\n    /*\n      Convert range to the \"ed\" format'\n    */\n\n    var beginning, length;\n    beginning = start + 1;\n    length = stop - start;\n    if (length === 1) {\n      return \"\" + beginning;\n    }\n    if (!length) {\n      beginning--;\n    }\n    return \"\" + beginning + \",\" + length;\n  };\n\n  unifiedDiff = function(a, b, _arg) {\n    var file1Range, file2Range, first, fromdate, fromfile, fromfiledate, group, i1, i2, j1, j2, last, line, lines, lineterm, n, started, tag, todate, tofile, tofiledate, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;\n    _ref = _arg != null ? _arg : {}, fromfile = _ref.fromfile, tofile = _ref.tofile, fromfiledate = _ref.fromfiledate, tofiledate = _ref.tofiledate, n = _ref.n, lineterm = _ref.lineterm;\n    /*\n      Compare two sequences of lines; generate the delta as a unified diff.\n    \n      Unified diffs are a compact way of showing line changes and a few\n      lines of context.  The number of context lines is set by 'n' which\n      defaults to three.\n    \n      By default, the diff control lines (those with ---, +++, or @@) are\n      created with a trailing newline.  \n    \n      For inputs that do not have trailing newlines, set the lineterm\n      argument to \"\" so that the output will be uniformly newline free.\n    \n      The unidiff format normally has a header for filenames and modification\n      times.  Any or all of these may be specified using strings for\n      'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.\n      The modification times are normally expressed in the ISO 8601 format.\n    \n      Example:\n    \n      >>> unifiedDiff('one two three four'.split(' '),\n      ...             'zero one tree four'.split(' '), {\n      ...               fromfile: 'Original'\n      ...               tofile: 'Current',\n      ...               fromfiledate: '2005-01-26 23:30:50',\n      ...               tofiledate: '2010-04-02 10:20:52',\n      ...               lineterm: ''\n      ...             })\n      [ '--- Original\\t2005-01-26 23:30:50',\n        '+++ Current\\t2010-04-02 10:20:52',\n        '@@ -1,4 +1,4 @@',\n        '+zero',\n        ' one',\n        '-two',\n        '-three',\n        '+tree',\n        ' four' ]\n    */\n\n    if (fromfile == null) {\n      fromfile = '';\n    }\n    if (tofile == null) {\n      tofile = '';\n    }\n    if (fromfiledate == null) {\n      fromfiledate = '';\n    }\n    if (tofiledate == null) {\n      tofiledate = '';\n    }\n    if (n == null) {\n      n = 3;\n    }\n    if (lineterm == null) {\n      lineterm = '\\n';\n    }\n    lines = [];\n    started = false;\n    _ref1 = (new SequenceMatcher(null, a, b)).getGroupedOpcodes();\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      group = _ref1[_i];\n      if (!started) {\n        started = true;\n        fromdate = fromfiledate ? \"\\t\" + fromfiledate : '';\n        todate = tofiledate ? \"\\t\" + tofiledate : '';\n        lines.push(\"--- \" + fromfile + fromdate + lineterm);\n        lines.push(\"+++ \" + tofile + todate + lineterm);\n      }\n      _ref2 = [group[0], group[group.length - 1]], first = _ref2[0], last = _ref2[1];\n      file1Range = _formatRangeUnified(first[1], last[2]);\n      file2Range = _formatRangeUnified(first[3], last[4]);\n      lines.push(\"@@ -\" + file1Range + \" +\" + file2Range + \" @@\" + lineterm);\n      for (_j = 0, _len1 = group.length; _j < _len1; _j++) {\n        _ref3 = group[_j], tag = _ref3[0], i1 = _ref3[1], i2 = _ref3[2], j1 = _ref3[3], j2 = _ref3[4];\n        if (tag === 'equal') {\n          _ref4 = a.slice(i1, i2);\n          for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {\n            line = _ref4[_k];\n            lines.push(' ' + line);\n          }\n          continue;\n        }\n        if (tag === 'replace' || tag === 'delete') {\n          _ref5 = a.slice(i1, i2);\n          for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {\n            line = _ref5[_l];\n            lines.push('-' + line);\n          }\n        }\n        if (tag === 'replace' || tag === 'insert') {\n          _ref6 = b.slice(j1, j2);\n          for (_m = 0, _len4 = _ref6.length; _m < _len4; _m++) {\n            line = _ref6[_m];\n            lines.push('+' + line);\n          }\n        }\n      }\n    }\n    return lines;\n  };\n\n  _formatRangeContext = function(start, stop) {\n    /*\n      Convert range to the \"ed\" format'\n    */\n\n    var beginning, length;\n    beginning = start + 1;\n    length = stop - start;\n    if (!length) {\n      beginning--;\n    }\n    if (length <= 1) {\n      return \"\" + beginning;\n    }\n    return \"\" + beginning + \",\" + (beginning + length - 1);\n  };\n\n  contextDiff = function(a, b, _arg) {\n    var file1Range, file2Range, first, fromdate, fromfile, fromfiledate, group, i1, i2, j1, j2, last, line, lines, lineterm, n, prefix, started, tag, todate, tofile, tofiledate, _, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;\n    _ref = _arg != null ? _arg : {}, fromfile = _ref.fromfile, tofile = _ref.tofile, fromfiledate = _ref.fromfiledate, tofiledate = _ref.tofiledate, n = _ref.n, lineterm = _ref.lineterm;\n    /*\n      Compare two sequences of lines; generate the delta as a context diff.\n    \n      Context diffs are a compact way of showing line changes and a few\n      lines of context.  The number of context lines is set by 'n' which\n      defaults to three.\n    \n      By default, the diff control lines (those with *** or ---) are\n      created with a trailing newline.  This is helpful so that inputs\n      created from file.readlines() result in diffs that are suitable for\n      file.writelines() since both the inputs and outputs have trailing\n      newlines.\n    \n      For inputs that do not have trailing newlines, set the lineterm\n      argument to \"\" so that the output will be uniformly newline free.\n    \n      The context diff format normally has a header for filenames and\n      modification times.  Any or all of these may be specified using\n      strings for 'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.\n      The modification times are normally expressed in the ISO 8601 format.\n      If not specified, the strings default to blanks.\n    \n      Example:\n      >>> a = ['one\\n', 'two\\n', 'three\\n', 'four\\n']\n      >>> b = ['zero\\n', 'one\\n', 'tree\\n', 'four\\n']\n      >>> contextDiff(a, b, {fromfile: 'Original', tofile: 'Current'})\n      [ '*** Original\\n',\n        '--- Current\\n',\n        '***************\\n',\n        '*** 1,4 ****\\n',\n        '  one\\n',\n        '! two\\n',\n        '! three\\n',\n        '  four\\n',\n        '--- 1,4 ----\\n',\n        '+ zero\\n',\n        '  one\\n',\n        '! tree\\n',\n        '  four\\n' ]\n    */\n\n    if (fromfile == null) {\n      fromfile = '';\n    }\n    if (tofile == null) {\n      tofile = '';\n    }\n    if (fromfiledate == null) {\n      fromfiledate = '';\n    }\n    if (tofiledate == null) {\n      tofiledate = '';\n    }\n    if (n == null) {\n      n = 3;\n    }\n    if (lineterm == null) {\n      lineterm = '\\n';\n    }\n    prefix = {\n      insert: '+ ',\n      \"delete\": '- ',\n      replace: '! ',\n      equal: '  '\n    };\n    started = false;\n    lines = [];\n    _ref1 = (new SequenceMatcher(null, a, b)).getGroupedOpcodes();\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      group = _ref1[_i];\n      if (!started) {\n        started = true;\n        fromdate = fromfiledate ? \"\\t\" + fromfiledate : '';\n        todate = tofiledate ? \"\\t\" + tofiledate : '';\n        lines.push(\"*** \" + fromfile + fromdate + lineterm);\n        lines.push(\"--- \" + tofile + todate + lineterm);\n        _ref2 = [group[0], group[group.length - 1]], first = _ref2[0], last = _ref2[1];\n        lines.push('***************' + lineterm);\n        file1Range = _formatRangeContext(first[1], last[2]);\n        lines.push(\"*** \" + file1Range + \" ****\" + lineterm);\n        if (_any((function() {\n          var _j, _len1, _ref3, _results;\n          _results = [];\n          for (_j = 0, _len1 = group.length; _j < _len1; _j++) {\n            _ref3 = group[_j], tag = _ref3[0], _ = _ref3[1], _ = _ref3[2], _ = _ref3[3], _ = _ref3[4];\n            _results.push(tag === 'replace' || tag === 'delete');\n          }\n          return _results;\n        })())) {\n          for (_j = 0, _len1 = group.length; _j < _len1; _j++) {\n            _ref3 = group[_j], tag = _ref3[0], i1 = _ref3[1], i2 = _ref3[2], _ = _ref3[3], _ = _ref3[4];\n            if (tag !== 'insert') {\n              _ref4 = a.slice(i1, i2);\n              for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {\n                line = _ref4[_k];\n                lines.push(prefix[tag] + line);\n              }\n            }\n          }\n        }\n        file2Range = _formatRangeContext(first[3], last[4]);\n        lines.push(\"--- \" + file2Range + \" ----\" + lineterm);\n        if (_any((function() {\n          var _l, _len3, _ref5, _results;\n          _results = [];\n          for (_l = 0, _len3 = group.length; _l < _len3; _l++) {\n            _ref5 = group[_l], tag = _ref5[0], _ = _ref5[1], _ = _ref5[2], _ = _ref5[3], _ = _ref5[4];\n            _results.push(tag === 'replace' || tag === 'insert');\n          }\n          return _results;\n        })())) {\n          for (_l = 0, _len3 = group.length; _l < _len3; _l++) {\n            _ref5 = group[_l], tag = _ref5[0], _ = _ref5[1], _ = _ref5[2], j1 = _ref5[3], j2 = _ref5[4];\n            if (tag !== 'delete') {\n              _ref6 = b.slice(j1, j2);\n              for (_m = 0, _len4 = _ref6.length; _m < _len4; _m++) {\n                line = _ref6[_m];\n                lines.push(prefix[tag] + line);\n              }\n            }\n          }\n        }\n      }\n    }\n    return lines;\n  };\n\n  ndiff = function(a, b, linejunk, charjunk) {\n    if (charjunk == null) {\n      charjunk = IS_CHARACTER_JUNK;\n    }\n    /*\n      Compare `a` and `b` (lists of strings); return a `Differ`-style delta.\n    \n      Optional keyword parameters `linejunk` and `charjunk` are for filter\n      functions (or None):\n    \n      - linejunk: A function that should accept a single string argument, and\n        return true iff the string is junk.  The default is null, and is\n        recommended; \n    \n      - charjunk: A function that should accept a string of length 1. The\n        default is module-level function IS_CHARACTER_JUNK, which filters out\n        whitespace characters (a blank or tab; note: bad idea to include newline\n        in this!).\n    \n      Example:\n      >>> a = ['one\\n', 'two\\n', 'three\\n']\n      >>> b = ['ore\\n', 'tree\\n', 'emu\\n']\n      >>> ndiff(a, b)\n      [ '- one\\n',\n        '?  ^\\n',\n        '+ ore\\n',\n        '?  ^\\n',\n        '- two\\n',\n        '- three\\n',\n        '?  -\\n',\n        '+ tree\\n',\n        '+ emu\\n' ]\n    */\n\n    return (new Differ(linejunk, charjunk)).compare(a, b);\n  };\n\n  restore = function(delta, which) {\n    /*\n      Generate one of the two sequences that generated a delta.\n    \n      Given a `delta` produced by `Differ.compare()` or `ndiff()`, extract\n      lines originating from file 1 or 2 (parameter `which`), stripping off line\n      prefixes.\n    \n      Examples:\n      >>> a = ['one\\n', 'two\\n', 'three\\n']\n      >>> b = ['ore\\n', 'tree\\n', 'emu\\n']\n      >>> diff = ndiff(a, b)\n      >>> restore(diff, 1)\n      [ 'one\\n',\n        'two\\n',\n        'three\\n' ]\n      >>> restore(diff, 2)\n      [ 'ore\\n',\n        'tree\\n',\n        'emu\\n' ]\n    */\n\n    var line, lines, prefixes, tag, _i, _len, _ref;\n    tag = {\n      1: '- ',\n      2: '+ '\n    }[which];\n    if (!tag) {\n      throw new Error(\"unknow delta choice (must be 1 or 2): \" + which);\n    }\n    prefixes = ['  ', tag];\n    lines = [];\n    for (_i = 0, _len = delta.length; _i < _len; _i++) {\n      line = delta[_i];\n      if (_ref = line.slice(0, 2), __indexOf.call(prefixes, _ref) >= 0) {\n        lines.push(line.slice(2));\n      }\n    }\n    return lines;\n  };\n\n  exports._arrayCmp = _arrayCmp;\n\n  exports.SequenceMatcher = SequenceMatcher;\n\n  exports.getCloseMatches = getCloseMatches;\n\n  exports._countLeading = _countLeading;\n\n  exports.Differ = Differ;\n\n  exports.IS_LINE_JUNK = IS_LINE_JUNK;\n\n  exports.IS_CHARACTER_JUNK = IS_CHARACTER_JUNK;\n\n  exports._formatRangeUnified = _formatRangeUnified;\n\n  exports.unifiedDiff = unifiedDiff;\n\n  exports._formatRangeContext = _formatRangeContext;\n\n  exports.contextDiff = contextDiff;\n\n  exports.ndiff = ndiff;\n\n  exports.restore = restore;\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZGlmZmxpYi9saWIvZGlmZmxpYi5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLCtDQUErQyxpQ0FBaUMsT0FBTyxPQUFPLCtDQUErQzs7QUFFN0k7O0FBRUEsU0FBUyxtQkFBTyxDQUFDLGdEQUFNOztBQUV2QixXQUFXLG1CQUFPLENBQUMsc0JBQVE7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNDQUFzQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEVBQUUsVUFBVSxFQUFFLGNBQWMsTUFBTTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSSxJQUFJLEdBQUcsR0FBRyxHQUFHLE1BQU0sR0FBRyxHQUFHLEdBQUc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtDQUFrQztBQUMzRDtBQUNBO0FBQ0EsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxXQUFXO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFdBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsV0FBVztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFlBQVk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsOEJBQThCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtDQUFrQztBQUMzRDtBQUNBO0FBQ0EsMkJBQTJCLGtDQUFrQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxXQUFXO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFlBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxXQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3Q0FBd0M7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFlBQVk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxXQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsaUJBQWlCOztBQUVuQixFQUFFLHVCQUF1Qjs7QUFFekIsRUFBRSx1QkFBdUI7O0FBRXpCLEVBQUUscUJBQXFCOztBQUV2QixFQUFFLGNBQWM7O0FBRWhCLEVBQUUsb0JBQW9COztBQUV0QixFQUFFLHlCQUF5Qjs7QUFFM0IsRUFBRSwyQkFBMkI7O0FBRTdCLEVBQUUsbUJBQW1COztBQUVyQixFQUFFLDJCQUEyQjs7QUFFN0IsRUFBRSxtQkFBbUI7O0FBRXJCLEVBQUUsYUFBYTs7QUFFZixFQUFFLGVBQWU7O0FBRWpCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlzd2FwX2Nsb25lLy4vbm9kZV9tb2R1bGVzL2RpZmZsaWIvbGliL2RpZmZsaWIuanM/ZjQ0MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMy4xXG5cbi8qXG5Nb2R1bGUgZGlmZmxpYiAtLSBoZWxwZXJzIGZvciBjb21wdXRpbmcgZGVsdGFzIGJldHdlZW4gb2JqZWN0cy5cblxuRnVuY3Rpb24gZ2V0Q2xvc2VNYXRjaGVzKHdvcmQsIHBvc3NpYmlsaXRpZXMsIG49MywgY3V0b2ZmPTAuNik6XG4gICAgVXNlIFNlcXVlbmNlTWF0Y2hlciB0byByZXR1cm4gbGlzdCBvZiB0aGUgYmVzdCBcImdvb2QgZW5vdWdoXCIgbWF0Y2hlcy5cblxuRnVuY3Rpb24gY29udGV4dERpZmYoYSwgYik6XG4gICAgRm9yIHR3byBsaXN0cyBvZiBzdHJpbmdzLCByZXR1cm4gYSBkZWx0YSBpbiBjb250ZXh0IGRpZmYgZm9ybWF0LlxuXG5GdW5jdGlvbiBuZGlmZihhLCBiKTpcbiAgICBSZXR1cm4gYSBkZWx0YTogdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBgYWAgYW5kIGBiYCAobGlzdHMgb2Ygc3RyaW5ncykuXG5cbkZ1bmN0aW9uIHJlc3RvcmUoZGVsdGEsIHdoaWNoKTpcbiAgICBSZXR1cm4gb25lIG9mIHRoZSB0d28gc2VxdWVuY2VzIHRoYXQgZ2VuZXJhdGVkIGFuIG5kaWZmIGRlbHRhLlxuXG5GdW5jdGlvbiB1bmlmaWVkRGlmZihhLCBiKTpcbiAgICBGb3IgdHdvIGxpc3RzIG9mIHN0cmluZ3MsIHJldHVybiBhIGRlbHRhIGluIHVuaWZpZWQgZGlmZiBmb3JtYXQuXG5cbkNsYXNzIFNlcXVlbmNlTWF0Y2hlcjpcbiAgICBBIGZsZXhpYmxlIGNsYXNzIGZvciBjb21wYXJpbmcgcGFpcnMgb2Ygc2VxdWVuY2VzIG9mIGFueSB0eXBlLlxuXG5DbGFzcyBEaWZmZXI6XG4gICAgRm9yIHByb2R1Y2luZyBodW1hbi1yZWFkYWJsZSBkZWx0YXMgZnJvbSBzZXF1ZW5jZXMgb2YgbGluZXMgb2YgdGV4dC5cbiovXG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgRGlmZmVyLCBIZWFwLCBJU19DSEFSQUNURVJfSlVOSywgSVNfTElORV9KVU5LLCBTZXF1ZW5jZU1hdGNoZXIsIGFzc2VydCwgY29udGV4dERpZmYsIGZsb29yLCBnZXRDbG9zZU1hdGNoZXMsIG1heCwgbWluLCBuZGlmZiwgcmVzdG9yZSwgdW5pZmllZERpZmYsIF9hbnksIF9hcnJheUNtcCwgX2NhbGN1bGF0ZVJhdGlvLCBfY291bnRMZWFkaW5nLCBfZm9ybWF0UmFuZ2VDb250ZXh0LCBfZm9ybWF0UmFuZ2VVbmlmaWVkLCBfaGFzLFxuICAgIF9faW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24oaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7IH0gcmV0dXJuIC0xOyB9O1xuXG4gIGZsb29yID0gTWF0aC5mbG9vciwgbWF4ID0gTWF0aC5tYXgsIG1pbiA9IE1hdGgubWluO1xuXG4gIEhlYXAgPSByZXF1aXJlKCdoZWFwJyk7XG5cbiAgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbiAgX2NhbGN1bGF0ZVJhdGlvID0gZnVuY3Rpb24obWF0Y2hlcywgbGVuZ3RoKSB7XG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgcmV0dXJuIDIuMCAqIG1hdGNoZXMgLyBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAxLjA7XG4gICAgfVxuICB9O1xuXG4gIF9hcnJheUNtcCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgaSwgbGEsIGxiLCBfaSwgX3JlZiwgX3JlZjE7XG4gICAgX3JlZiA9IFthLmxlbmd0aCwgYi5sZW5ndGhdLCBsYSA9IF9yZWZbMF0sIGxiID0gX3JlZlsxXTtcbiAgICBmb3IgKGkgPSBfaSA9IDAsIF9yZWYxID0gbWluKGxhLCBsYik7IDAgPD0gX3JlZjEgPyBfaSA8IF9yZWYxIDogX2kgPiBfcmVmMTsgaSA9IDAgPD0gX3JlZjEgPyArK19pIDogLS1faSkge1xuICAgICAgaWYgKGFbaV0gPCBiW2ldKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChhW2ldID4gYltpXSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxhIC0gbGI7XG4gIH07XG5cbiAgX2hhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH07XG5cbiAgX2FueSA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZW0sIF9pLCBfbGVuO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gaXRlbXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGl0ZW0gPSBpdGVtc1tfaV07XG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIFNlcXVlbmNlTWF0Y2hlciA9IChmdW5jdGlvbigpIHtcblxuICAgIFNlcXVlbmNlTWF0Y2hlci5uYW1lID0gJ1NlcXVlbmNlTWF0Y2hlcic7XG5cbiAgICAvKlxuICAgICAgU2VxdWVuY2VNYXRjaGVyIGlzIGEgZmxleGlibGUgY2xhc3MgZm9yIGNvbXBhcmluZyBwYWlycyBvZiBzZXF1ZW5jZXMgb2ZcbiAgICAgIGFueSB0eXBlLCBzbyBsb25nIGFzIHRoZSBzZXF1ZW5jZSBlbGVtZW50cyBhcmUgaGFzaGFibGUuICBUaGUgYmFzaWNcbiAgICAgIGFsZ29yaXRobSBwcmVkYXRlcywgYW5kIGlzIGEgbGl0dGxlIGZhbmNpZXIgdGhhbiwgYW4gYWxnb3JpdGhtXG4gICAgICBwdWJsaXNoZWQgaW4gdGhlIGxhdGUgMTk4MCdzIGJ5IFJhdGNsaWZmIGFuZCBPYmVyc2hlbHAgdW5kZXIgdGhlXG4gICAgICBoeXBlcmJvbGljIG5hbWUgXCJnZXN0YWx0IHBhdHRlcm4gbWF0Y2hpbmdcIi4gIFRoZSBiYXNpYyBpZGVhIGlzIHRvIGZpbmRcbiAgICAgIHRoZSBsb25nZXN0IGNvbnRpZ3VvdXMgbWF0Y2hpbmcgc3Vic2VxdWVuY2UgdGhhdCBjb250YWlucyBubyBcImp1bmtcIlxuICAgICAgZWxlbWVudHMgKFItTyBkb2Vzbid0IGFkZHJlc3MganVuaykuICBUaGUgc2FtZSBpZGVhIGlzIHRoZW4gYXBwbGllZFxuICAgICAgcmVjdXJzaXZlbHkgdG8gdGhlIHBpZWNlcyBvZiB0aGUgc2VxdWVuY2VzIHRvIHRoZSBsZWZ0IGFuZCB0byB0aGUgcmlnaHRcbiAgICAgIG9mIHRoZSBtYXRjaGluZyBzdWJzZXF1ZW5jZS4gIFRoaXMgZG9lcyBub3QgeWllbGQgbWluaW1hbCBlZGl0XG4gICAgICBzZXF1ZW5jZXMsIGJ1dCBkb2VzIHRlbmQgdG8geWllbGQgbWF0Y2hlcyB0aGF0IFwibG9vayByaWdodFwiIHRvIHBlb3BsZS5cbiAgICBcbiAgICAgIFNlcXVlbmNlTWF0Y2hlciB0cmllcyB0byBjb21wdXRlIGEgXCJodW1hbi1mcmllbmRseSBkaWZmXCIgYmV0d2VlbiB0d29cbiAgICAgIHNlcXVlbmNlcy4gIFVubGlrZSBlLmcuIFVOSVgodG0pIGRpZmYsIHRoZSBmdW5kYW1lbnRhbCBub3Rpb24gaXMgdGhlXG4gICAgICBsb25nZXN0ICpjb250aWd1b3VzKiAmIGp1bmstZnJlZSBtYXRjaGluZyBzdWJzZXF1ZW5jZS4gIFRoYXQncyB3aGF0XG4gICAgICBjYXRjaGVzIHBlb3BsZXMnIGV5ZXMuICBUaGUgV2luZG93cyh0bSkgd2luZGlmZiBoYXMgYW5vdGhlciBpbnRlcmVzdGluZ1xuICAgICAgbm90aW9uLCBwYWlyaW5nIHVwIGVsZW1lbnRzIHRoYXQgYXBwZWFyIHVuaXF1ZWx5IGluIGVhY2ggc2VxdWVuY2UuXG4gICAgICBUaGF0LCBhbmQgdGhlIG1ldGhvZCBoZXJlLCBhcHBlYXIgdG8geWllbGQgbW9yZSBpbnR1aXRpdmUgZGlmZmVyZW5jZVxuICAgICAgcmVwb3J0cyB0aGFuIGRvZXMgZGlmZi4gIFRoaXMgbWV0aG9kIGFwcGVhcnMgdG8gYmUgdGhlIGxlYXN0IHZ1bG5lcmFibGVcbiAgICAgIHRvIHN5bmNoaW5nIHVwIG9uIGJsb2NrcyBvZiBcImp1bmsgbGluZXNcIiwgdGhvdWdoIChsaWtlIGJsYW5rIGxpbmVzIGluXG4gICAgICBvcmRpbmFyeSB0ZXh0IGZpbGVzLCBvciBtYXliZSBcIjxQPlwiIGxpbmVzIGluIEhUTUwgZmlsZXMpLiAgVGhhdCBtYXkgYmVcbiAgICAgIGJlY2F1c2UgdGhpcyBpcyB0aGUgb25seSBtZXRob2Qgb2YgdGhlIDMgdGhhdCBoYXMgYSAqY29uY2VwdCogb2ZcbiAgICAgIFwianVua1wiIDx3aW5rPi5cbiAgICBcbiAgICAgIEV4YW1wbGUsIGNvbXBhcmluZyB0d28gc3RyaW5ncywgYW5kIGNvbnNpZGVyaW5nIGJsYW5rcyB0byBiZSBcImp1bmtcIjpcbiAgICBcbiAgICAgID4+PiBpc2p1bmsgPSAoYykgLT4gYyBpcyAnICdcbiAgICAgID4+PiBzID0gbmV3IFNlcXVlbmNlTWF0Y2hlcihpc2p1bmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ByaXZhdGUgVGhyZWFkIGN1cnJlbnRUaHJlYWQ7JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSB2b2xhdGlsZSBUaHJlYWQgY3VycmVudFRocmVhZDsnKVxuICAgIFxuICAgICAgLnJhdGlvKCkgcmV0dXJucyBhIGZsb2F0IGluIFswLCAxXSwgbWVhc3VyaW5nIHRoZSBcInNpbWlsYXJpdHlcIiBvZiB0aGVcbiAgICAgIHNlcXVlbmNlcy4gIEFzIGEgcnVsZSBvZiB0aHVtYiwgYSAucmF0aW8oKSB2YWx1ZSBvdmVyIDAuNiBtZWFucyB0aGVcbiAgICAgIHNlcXVlbmNlcyBhcmUgY2xvc2UgbWF0Y2hlczpcbiAgICBcbiAgICAgID4+PiBzLnJhdGlvKCkudG9QcmVjaXNpb24oMylcbiAgICAgICcwLjg2NidcbiAgICBcbiAgICAgIElmIHlvdSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gd2hlcmUgdGhlIHNlcXVlbmNlcyBtYXRjaCxcbiAgICAgIC5nZXRNYXRjaGluZ0Jsb2NrcygpIGlzIGhhbmR5OlxuICAgIFxuICAgICAgPj4+IGZvciBbYSwgYiwgc2l6ZV0gaW4gcy5nZXRNYXRjaGluZ0Jsb2NrcygpXG4gICAgICAuLi4gICBjb25zb2xlLmxvZyhcImFbI3thfV0gYW5kIGJbI3tifV0gbWF0Y2ggZm9yICN7c2l6ZX0gZWxlbWVudHNcIik7XG4gICAgICBhWzBdIGFuZCBiWzBdIG1hdGNoIGZvciA4IGVsZW1lbnRzXG4gICAgICBhWzhdIGFuZCBiWzE3XSBtYXRjaCBmb3IgMjEgZWxlbWVudHNcbiAgICAgIGFbMjldIGFuZCBiWzM4XSBtYXRjaCBmb3IgMCBlbGVtZW50c1xuICAgIFxuICAgICAgTm90ZSB0aGF0IHRoZSBsYXN0IHR1cGxlIHJldHVybmVkIGJ5IC5nZXRfbWF0Y2hpbmdfYmxvY2tzKCkgaXMgYWx3YXlzIGFcbiAgICAgIGR1bW15LCAobGVuKGEpLCBsZW4oYiksIDApLCBhbmQgdGhpcyBpcyB0aGUgb25seSBjYXNlIGluIHdoaWNoIHRoZSBsYXN0XG4gICAgICB0dXBsZSBlbGVtZW50IChudW1iZXIgb2YgZWxlbWVudHMgbWF0Y2hlZCkgaXMgMC5cbiAgICBcbiAgICAgIElmIHlvdSB3YW50IHRvIGtub3cgaG93IHRvIGNoYW5nZSB0aGUgZmlyc3Qgc2VxdWVuY2UgaW50byB0aGUgc2Vjb25kLFxuICAgICAgdXNlIC5nZXRfb3Bjb2RlcygpOlxuICAgIFxuICAgICAgPj4+IGZvciBbb3AsIGExLCBhMiwgYjEsIGIyXSBpbiBzLmdldE9wY29kZXMoKVxuICAgICAgLi4uICAgY29uc29sZS5sb2cgXCIje29wfSBhWyN7YTF9OiN7YTJ9XSBiWyN7YjF9OiN7YjJ9XVwiXG4gICAgICBlcXVhbCBhWzA6OF0gYlswOjhdXG4gICAgICBpbnNlcnQgYVs4OjhdIGJbODoxN11cbiAgICAgIGVxdWFsIGFbODoyOV0gYlsxNzozOF1cbiAgICBcbiAgICAgIFNlZSB0aGUgRGlmZmVyIGNsYXNzIGZvciBhIGZhbmN5IGh1bWFuLWZyaWVuZGx5IGZpbGUgZGlmZmVyZW5jZXIsIHdoaWNoXG4gICAgICB1c2VzIFNlcXVlbmNlTWF0Y2hlciBib3RoIHRvIGNvbXBhcmUgc2VxdWVuY2VzIG9mIGxpbmVzLCBhbmQgdG8gY29tcGFyZVxuICAgICAgc2VxdWVuY2VzIG9mIGNoYXJhY3RlcnMgd2l0aGluIHNpbWlsYXIgKG5lYXItbWF0Y2hpbmcpIGxpbmVzLlxuICAgIFxuICAgICAgU2VlIGFsc28gZnVuY3Rpb24gZ2V0Q2xvc2VNYXRjaGVzKCkgaW4gdGhpcyBtb2R1bGUsIHdoaWNoIHNob3dzIGhvd1xuICAgICAgc2ltcGxlIGNvZGUgYnVpbGRpbmcgb24gU2VxdWVuY2VNYXRjaGVyIGNhbiBiZSB1c2VkIHRvIGRvIHVzZWZ1bCB3b3JrLlxuICAgIFxuICAgICAgVGltaW5nOiAgQmFzaWMgUi1PIGlzIGN1YmljIHRpbWUgd29yc3QgY2FzZSBhbmQgcXVhZHJhdGljIHRpbWUgZXhwZWN0ZWRcbiAgICAgIGNhc2UuICBTZXF1ZW5jZU1hdGNoZXIgaXMgcXVhZHJhdGljIHRpbWUgZm9yIHRoZSB3b3JzdCBjYXNlIGFuZCBoYXNcbiAgICAgIGV4cGVjdGVkLWNhc2UgYmVoYXZpb3IgZGVwZW5kZW50IGluIGEgY29tcGxpY2F0ZWQgd2F5IG9uIGhvdyBtYW55XG4gICAgICBlbGVtZW50cyB0aGUgc2VxdWVuY2VzIGhhdmUgaW4gY29tbW9uOyBiZXN0IGNhc2UgdGltZSBpcyBsaW5lYXIuXG4gICAgXG4gICAgICBNZXRob2RzOlxuICAgIFxuICAgICAgY29uc3RydWN0b3IoaXNqdW5rPW51bGwsIGE9JycsIGI9JycpXG4gICAgICAgICAgQ29uc3RydWN0IGEgU2VxdWVuY2VNYXRjaGVyLlxuICAgIFxuICAgICAgc2V0U2VxcyhhLCBiKVxuICAgICAgICAgIFNldCB0aGUgdHdvIHNlcXVlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAgICBcbiAgICAgIHNldFNlcTEoYSlcbiAgICAgICAgICBTZXQgdGhlIGZpcnN0IHNlcXVlbmNlIHRvIGJlIGNvbXBhcmVkLlxuICAgIFxuICAgICAgc2V0U2VxMihiKVxuICAgICAgICAgIFNldCB0aGUgc2Vjb25kIHNlcXVlbmNlIHRvIGJlIGNvbXBhcmVkLlxuICAgIFxuICAgICAgZmluZExvbmdlc3RNYXRjaChhbG8sIGFoaSwgYmxvLCBiaGkpXG4gICAgICAgICAgRmluZCBsb25nZXN0IG1hdGNoaW5nIGJsb2NrIGluIGFbYWxvOmFoaV0gYW5kIGJbYmxvOmJoaV0uXG4gICAgXG4gICAgICBnZXRNYXRjaGluZ0Jsb2NrcygpXG4gICAgICAgICAgUmV0dXJuIGxpc3Qgb2YgdHJpcGxlcyBkZXNjcmliaW5nIG1hdGNoaW5nIHN1YnNlcXVlbmNlcy5cbiAgICBcbiAgICAgIGdldE9wY29kZXMoKVxuICAgICAgICAgIFJldHVybiBsaXN0IG9mIDUtdHVwbGVzIGRlc2NyaWJpbmcgaG93IHRvIHR1cm4gYSBpbnRvIGIuXG4gICAgXG4gICAgICByYXRpbygpXG4gICAgICAgICAgUmV0dXJuIGEgbWVhc3VyZSBvZiB0aGUgc2VxdWVuY2VzJyBzaW1pbGFyaXR5IChmbG9hdCBpbiBbMCwxXSkuXG4gICAgXG4gICAgICBxdWlja1JhdGlvKClcbiAgICAgICAgICBSZXR1cm4gYW4gdXBwZXIgYm91bmQgb24gLnJhdGlvKCkgcmVsYXRpdmVseSBxdWlja2x5LlxuICAgIFxuICAgICAgcmVhbFF1aWNrUmF0aW8oKVxuICAgICAgICAgIFJldHVybiBhbiB1cHBlciBib3VuZCBvbiByYXRpbygpIHZlcnkgcXVpY2tseS5cbiAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBTZXF1ZW5jZU1hdGNoZXIoaXNqdW5rLCBhLCBiLCBhdXRvanVuaykge1xuICAgICAgdGhpcy5pc2p1bmsgPSBpc2p1bms7XG4gICAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICAgIGEgPSAnJztcbiAgICAgIH1cbiAgICAgIGlmIChiID09IG51bGwpIHtcbiAgICAgICAgYiA9ICcnO1xuICAgICAgfVxuICAgICAgdGhpcy5hdXRvanVuayA9IGF1dG9qdW5rICE9IG51bGwgPyBhdXRvanVuayA6IHRydWU7XG4gICAgICAvKlxuICAgICAgICAgIENvbnN0cnVjdCBhIFNlcXVlbmNlTWF0Y2hlci5cbiAgICAgIFxuICAgICAgICAgIE9wdGlvbmFsIGFyZyBpc2p1bmsgaXMgbnVsbCAodGhlIGRlZmF1bHQpLCBvciBhIG9uZS1hcmd1bWVudFxuICAgICAgICAgIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBzZXF1ZW5jZSBlbGVtZW50IGFuZCByZXR1cm5zIHRydWUgaWZmIHRoZVxuICAgICAgICAgIGVsZW1lbnQgaXMganVuay4gIE51bGwgaXMgZXF1aXZhbGVudCB0byBwYXNzaW5nIFwiKHgpIC0+IDBcIiwgaS5lLlxuICAgICAgICAgIG5vIGVsZW1lbnRzIGFyZSBjb25zaWRlcmVkIHRvIGJlIGp1bmsuICBGb3IgZXhhbXBsZSwgcGFzc1xuICAgICAgICAgICAgICAoeCkgLT4geCBpbiAnIFxcdCdcbiAgICAgICAgICBpZiB5b3UncmUgY29tcGFyaW5nIGxpbmVzIGFzIHNlcXVlbmNlcyBvZiBjaGFyYWN0ZXJzLCBhbmQgZG9uJ3RcbiAgICAgICAgICB3YW50IHRvIHN5bmNoIHVwIG9uIGJsYW5rcyBvciBoYXJkIHRhYnMuXG4gICAgICBcbiAgICAgICAgICBPcHRpb25hbCBhcmcgYSBpcyB0aGUgZmlyc3Qgb2YgdHdvIHNlcXVlbmNlcyB0byBiZSBjb21wYXJlZC4gIEJ5XG4gICAgICAgICAgZGVmYXVsdCwgYW4gZW1wdHkgc3RyaW5nLiAgVGhlIGVsZW1lbnRzIG9mIGEgbXVzdCBiZSBoYXNoYWJsZS4gIFNlZVxuICAgICAgICAgIGFsc28gLnNldFNlcXMoKSBhbmQgLnNldFNlcTEoKS5cbiAgICAgIFxuICAgICAgICAgIE9wdGlvbmFsIGFyZyBiIGlzIHRoZSBzZWNvbmQgb2YgdHdvIHNlcXVlbmNlcyB0byBiZSBjb21wYXJlZC4gIEJ5XG4gICAgICAgICAgZGVmYXVsdCwgYW4gZW1wdHkgc3RyaW5nLiAgVGhlIGVsZW1lbnRzIG9mIGIgbXVzdCBiZSBoYXNoYWJsZS4gU2VlXG4gICAgICAgICAgYWxzbyAuc2V0U2VxcygpIGFuZCAuc2V0U2VxMigpLlxuICAgICAgXG4gICAgICAgICAgT3B0aW9uYWwgYXJnIGF1dG9qdW5rIHNob3VsZCBiZSBzZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGVcbiAgICAgICAgICBcImF1dG9tYXRpYyBqdW5rIGhldXJpc3RpY1wiIHRoYXQgdHJlYXRzIHBvcHVsYXIgZWxlbWVudHMgYXMganVua1xuICAgICAgICAgIChzZWUgbW9kdWxlIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24pLlxuICAgICAgKi9cblxuICAgICAgdGhpcy5hID0gdGhpcy5iID0gbnVsbDtcbiAgICAgIHRoaXMuc2V0U2VxcyhhLCBiKTtcbiAgICB9XG5cbiAgICBTZXF1ZW5jZU1hdGNoZXIucHJvdG90eXBlLnNldFNlcXMgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAvKiBcbiAgICAgIFNldCB0aGUgdHdvIHNlcXVlbmNlcyB0byBiZSBjb21wYXJlZC4gXG4gICAgICBcbiAgICAgID4+PiBzID0gbmV3IFNlcXVlbmNlTWF0Y2hlcigpXG4gICAgICA+Pj4gcy5zZXRTZXFzKCdhYmNkJywgJ2JjZGUnKVxuICAgICAgPj4+IHMucmF0aW8oKVxuICAgICAgMC43NVxuICAgICAgKi9cbiAgICAgIHRoaXMuc2V0U2VxMShhKTtcbiAgICAgIHJldHVybiB0aGlzLnNldFNlcTIoYik7XG4gICAgfTtcblxuICAgIFNlcXVlbmNlTWF0Y2hlci5wcm90b3R5cGUuc2V0U2VxMSA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIC8qIFxuICAgICAgU2V0IHRoZSBmaXJzdCBzZXF1ZW5jZSB0byBiZSBjb21wYXJlZC4gXG4gICAgICBcbiAgICAgIFRoZSBzZWNvbmQgc2VxdWVuY2UgdG8gYmUgY29tcGFyZWQgaXMgbm90IGNoYW5nZWQuXG4gICAgICBcbiAgICAgID4+PiBzID0gbmV3IFNlcXVlbmNlTWF0Y2hlcihudWxsLCAnYWJjZCcsICdiY2RlJylcbiAgICAgID4+PiBzLnJhdGlvKClcbiAgICAgIDAuNzVcbiAgICAgID4+PiBzLnNldFNlcTEoJ2JjZGUnKVxuICAgICAgPj4+IHMucmF0aW8oKVxuICAgICAgMS4wXG4gICAgICBcbiAgICAgIFNlcXVlbmNlTWF0Y2hlciBjb21wdXRlcyBhbmQgY2FjaGVzIGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICAgICAgc2Vjb25kIHNlcXVlbmNlLCBzbyBpZiB5b3Ugd2FudCB0byBjb21wYXJlIG9uZSBzZXF1ZW5jZSBTIGFnYWluc3RcbiAgICAgIG1hbnkgc2VxdWVuY2VzLCB1c2UgLnNldFNlcTIoUykgb25jZSBhbmQgY2FsbCAuc2V0U2VxMSh4KVxuICAgICAgcmVwZWF0ZWRseSBmb3IgZWFjaCBvZiB0aGUgb3RoZXIgc2VxdWVuY2VzLlxuICAgICAgXG4gICAgICBTZWUgYWxzbyBzZXRTZXFzKCkgYW5kIHNldFNlcTIoKS5cbiAgICAgICovXG4gICAgICBpZiAoYSA9PT0gdGhpcy5hKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYSA9IGE7XG4gICAgICByZXR1cm4gdGhpcy5tYXRjaGluZ0Jsb2NrcyA9IHRoaXMub3Bjb2RlcyA9IG51bGw7XG4gICAgfTtcblxuICAgIFNlcXVlbmNlTWF0Y2hlci5wcm90b3R5cGUuc2V0U2VxMiA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgIC8qXG4gICAgICAgICAgU2V0IHRoZSBzZWNvbmQgc2VxdWVuY2UgdG8gYmUgY29tcGFyZWQuIFxuICAgICAgXG4gICAgICAgICAgVGhlIGZpcnN0IHNlcXVlbmNlIHRvIGJlIGNvbXBhcmVkIGlzIG5vdCBjaGFuZ2VkLlxuICAgICAgXG4gICAgICAgICAgPj4+IHMgPSBuZXcgU2VxdWVuY2VNYXRjaGVyKG51bGwsICdhYmNkJywgJ2JjZGUnKVxuICAgICAgICAgID4+PiBzLnJhdGlvKClcbiAgICAgICAgICAwLjc1XG4gICAgICAgICAgPj4+IHMuc2V0U2VxMignYWJjZCcpXG4gICAgICAgICAgPj4+IHMucmF0aW8oKVxuICAgICAgICAgIDEuMFxuICAgICAgXG4gICAgICAgICAgU2VxdWVuY2VNYXRjaGVyIGNvbXB1dGVzIGFuZCBjYWNoZXMgZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgdGhlXG4gICAgICAgICAgc2Vjb25kIHNlcXVlbmNlLCBzbyBpZiB5b3Ugd2FudCB0byBjb21wYXJlIG9uZSBzZXF1ZW5jZSBTIGFnYWluc3RcbiAgICAgICAgICBtYW55IHNlcXVlbmNlcywgdXNlIC5zZXRTZXEyKFMpIG9uY2UgYW5kIGNhbGwgLnNldFNlcTEoeClcbiAgICAgICAgICByZXBlYXRlZGx5IGZvciBlYWNoIG9mIHRoZSBvdGhlciBzZXF1ZW5jZXMuXG4gICAgICBcbiAgICAgICAgICBTZWUgYWxzbyBzZXRTZXFzKCkgYW5kIHNldFNlcTEoKS5cbiAgICAgICovXG4gICAgICBpZiAoYiA9PT0gdGhpcy5iKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYiA9IGI7XG4gICAgICB0aGlzLm1hdGNoaW5nQmxvY2tzID0gdGhpcy5vcGNvZGVzID0gbnVsbDtcbiAgICAgIHRoaXMuZnVsbGJjb3VudCA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcy5fY2hhaW5CKCk7XG4gICAgfTtcblxuICAgIFNlcXVlbmNlTWF0Y2hlci5wcm90b3R5cGUuX2NoYWluQiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGIsIGIyaiwgZWx0LCBpLCBpZHhzLCBpbmRpY2VzLCBpc2p1bmssIGp1bmssIG4sIG50ZXN0LCBwb3B1bGFyLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmO1xuICAgICAgYiA9IHRoaXMuYjtcbiAgICAgIHRoaXMuYjJqID0gYjJqID0ge307XG4gICAgICBmb3IgKGkgPSBfaSA9IDAsIF9sZW4gPSBiLmxlbmd0aDsgX2kgPCBfbGVuOyBpID0gKytfaSkge1xuICAgICAgICBlbHQgPSBiW2ldO1xuICAgICAgICBpbmRpY2VzID0gX2hhcyhiMmosIGVsdCkgPyBiMmpbZWx0XSA6IGIyaltlbHRdID0gW107XG4gICAgICAgIGluZGljZXMucHVzaChpKTtcbiAgICAgIH1cbiAgICAgIGp1bmsgPSB7fTtcbiAgICAgIGlzanVuayA9IHRoaXMuaXNqdW5rO1xuICAgICAgaWYgKGlzanVuaykge1xuICAgICAgICBfcmVmID0gT2JqZWN0LmtleXMoYjJqKTtcbiAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZi5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICBlbHQgPSBfcmVmW19qXTtcbiAgICAgICAgICBpZiAoaXNqdW5rKGVsdCkpIHtcbiAgICAgICAgICAgIGp1bmtbZWx0XSA9IHRydWU7XG4gICAgICAgICAgICBkZWxldGUgYjJqW2VsdF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwb3B1bGFyID0ge307XG4gICAgICBuID0gYi5sZW5ndGg7XG4gICAgICBpZiAodGhpcy5hdXRvanVuayAmJiBuID49IDIwMCkge1xuICAgICAgICBudGVzdCA9IGZsb29yKG4gLyAxMDApICsgMTtcbiAgICAgICAgZm9yIChlbHQgaW4gYjJqKSB7XG4gICAgICAgICAgaWR4cyA9IGIyaltlbHRdO1xuICAgICAgICAgIGlmIChpZHhzLmxlbmd0aCA+IG50ZXN0KSB7XG4gICAgICAgICAgICBwb3B1bGFyW2VsdF0gPSB0cnVlO1xuICAgICAgICAgICAgZGVsZXRlIGIyaltlbHRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5pc2JqdW5rID0gZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gX2hhcyhqdW5rLCBiKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5pc2Jwb3B1bGFyID0gZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gX2hhcyhwb3B1bGFyLCBiKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIFNlcXVlbmNlTWF0Y2hlci5wcm90b3R5cGUuZmluZExvbmdlc3RNYXRjaCA9IGZ1bmN0aW9uKGFsbywgYWhpLCBibG8sIGJoaSkge1xuICAgICAgLyogXG4gICAgICBGaW5kIGxvbmdlc3QgbWF0Y2hpbmcgYmxvY2sgaW4gYVthbG8uLi5haGldIGFuZCBiW2Jsby4uLmJoaV0uICBcbiAgICAgIFxuICAgICAgSWYgaXNqdW5rIGlzIG5vdCBkZWZpbmVkOlxuICAgICAgXG4gICAgICBSZXR1cm4gW2ksaixrXSBzdWNoIHRoYXQgYVtpLi4uaStrXSBpcyBlcXVhbCB0byBiW2ouLi5qK2tdLCB3aGVyZVxuICAgICAgICAgIGFsbyA8PSBpIDw9IGkrayA8PSBhaGlcbiAgICAgICAgICBibG8gPD0gaiA8PSBqK2sgPD0gYmhpXG4gICAgICBhbmQgZm9yIGFsbCBbaScsaicsayddIG1lZXRpbmcgdGhvc2UgY29uZGl0aW9ucyxcbiAgICAgICAgICBrID49IGsnXG4gICAgICAgICAgaSA8PSBpJ1xuICAgICAgICAgIGFuZCBpZiBpID09IGknLCBqIDw9IGonXG4gICAgICBcbiAgICAgIEluIG90aGVyIHdvcmRzLCBvZiBhbGwgbWF4aW1hbCBtYXRjaGluZyBibG9ja3MsIHJldHVybiBvbmUgdGhhdFxuICAgICAgc3RhcnRzIGVhcmxpZXN0IGluIGEsIGFuZCBvZiBhbGwgdGhvc2UgbWF4aW1hbCBtYXRjaGluZyBibG9ja3MgdGhhdFxuICAgICAgc3RhcnQgZWFybGllc3QgaW4gYSwgcmV0dXJuIHRoZSBvbmUgdGhhdCBzdGFydHMgZWFybGllc3QgaW4gYi5cbiAgICAgIFxuICAgICAgPj4+IGlzanVuayA9ICh4KSAtPiB4IGlzICcgJ1xuICAgICAgPj4+IHMgPSBuZXcgU2VxdWVuY2VNYXRjaGVyKGlzanVuaywgJyBhYmNkJywgJ2FiY2QgYWJjZCcpXG4gICAgICA+Pj4gcy5maW5kTG9uZ2VzdE1hdGNoKDAsIDUsIDAsIDkpXG4gICAgICBbMSwgMCwgNF1cbiAgICAgIFxuICAgICAgPj4+IHMgPSBuZXcgU2VxdWVuY2VNYXRjaGVyKG51bGwsICdhYicsICdjJylcbiAgICAgID4+PiBzLmZpbmRMb25nZXN0TWF0Y2goMCwgMiwgMCwgMSlcbiAgICAgIFswLCAwLCAwXVxuICAgICAgKi9cblxuICAgICAgdmFyIGEsIGIsIGIyaiwgYmVzdGksIGJlc3RqLCBiZXN0c2l6ZSwgaSwgaXNianVuaywgaiwgajJsZW4sIGssIG5ld2oybGVuLCBfaSwgX2osIF9sZW4sIF9yZWYsIF9yZWYxLCBfcmVmMiwgX3JlZjMsIF9yZWY0LCBfcmVmNTtcbiAgICAgIF9yZWYgPSBbdGhpcy5hLCB0aGlzLmIsIHRoaXMuYjJqLCB0aGlzLmlzYmp1bmtdLCBhID0gX3JlZlswXSwgYiA9IF9yZWZbMV0sIGIyaiA9IF9yZWZbMl0sIGlzYmp1bmsgPSBfcmVmWzNdO1xuICAgICAgX3JlZjEgPSBbYWxvLCBibG8sIDBdLCBiZXN0aSA9IF9yZWYxWzBdLCBiZXN0aiA9IF9yZWYxWzFdLCBiZXN0c2l6ZSA9IF9yZWYxWzJdO1xuICAgICAgajJsZW4gPSB7fTtcbiAgICAgIGZvciAoaSA9IF9pID0gYWxvOyBhbG8gPD0gYWhpID8gX2kgPCBhaGkgOiBfaSA+IGFoaTsgaSA9IGFsbyA8PSBhaGkgPyArK19pIDogLS1faSkge1xuICAgICAgICBuZXdqMmxlbiA9IHt9O1xuICAgICAgICBfcmVmMiA9IChfaGFzKGIyaiwgYVtpXSkgPyBiMmpbYVtpXV0gOiBbXSk7XG4gICAgICAgIGZvciAoX2ogPSAwLCBfbGVuID0gX3JlZjIubGVuZ3RoOyBfaiA8IF9sZW47IF9qKyspIHtcbiAgICAgICAgICBqID0gX3JlZjJbX2pdO1xuICAgICAgICAgIGlmIChqIDwgYmxvKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGogPj0gYmhpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgayA9IG5ld2oybGVuW2pdID0gKGoybGVuW2ogLSAxXSB8fCAwKSArIDE7XG4gICAgICAgICAgaWYgKGsgPiBiZXN0c2l6ZSkge1xuICAgICAgICAgICAgX3JlZjMgPSBbaSAtIGsgKyAxLCBqIC0gayArIDEsIGtdLCBiZXN0aSA9IF9yZWYzWzBdLCBiZXN0aiA9IF9yZWYzWzFdLCBiZXN0c2l6ZSA9IF9yZWYzWzJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBqMmxlbiA9IG5ld2oybGVuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGJlc3RpID4gYWxvICYmIGJlc3RqID4gYmxvICYmICFpc2JqdW5rKGJbYmVzdGogLSAxXSkgJiYgYVtiZXN0aSAtIDFdID09PSBiW2Jlc3RqIC0gMV0pIHtcbiAgICAgICAgX3JlZjQgPSBbYmVzdGkgLSAxLCBiZXN0aiAtIDEsIGJlc3RzaXplICsgMV0sIGJlc3RpID0gX3JlZjRbMF0sIGJlc3RqID0gX3JlZjRbMV0sIGJlc3RzaXplID0gX3JlZjRbMl07XG4gICAgICB9XG4gICAgICB3aGlsZSAoYmVzdGkgKyBiZXN0c2l6ZSA8IGFoaSAmJiBiZXN0aiArIGJlc3RzaXplIDwgYmhpICYmICFpc2JqdW5rKGJbYmVzdGogKyBiZXN0c2l6ZV0pICYmIGFbYmVzdGkgKyBiZXN0c2l6ZV0gPT09IGJbYmVzdGogKyBiZXN0c2l6ZV0pIHtcbiAgICAgICAgYmVzdHNpemUrKztcbiAgICAgIH1cbiAgICAgIHdoaWxlIChiZXN0aSA+IGFsbyAmJiBiZXN0aiA+IGJsbyAmJiBpc2JqdW5rKGJbYmVzdGogLSAxXSkgJiYgYVtiZXN0aSAtIDFdID09PSBiW2Jlc3RqIC0gMV0pIHtcbiAgICAgICAgX3JlZjUgPSBbYmVzdGkgLSAxLCBiZXN0aiAtIDEsIGJlc3RzaXplICsgMV0sIGJlc3RpID0gX3JlZjVbMF0sIGJlc3RqID0gX3JlZjVbMV0sIGJlc3RzaXplID0gX3JlZjVbMl07XG4gICAgICB9XG4gICAgICB3aGlsZSAoYmVzdGkgKyBiZXN0c2l6ZSA8IGFoaSAmJiBiZXN0aiArIGJlc3RzaXplIDwgYmhpICYmIGlzYmp1bmsoYltiZXN0aiArIGJlc3RzaXplXSkgJiYgYVtiZXN0aSArIGJlc3RzaXplXSA9PT0gYltiZXN0aiArIGJlc3RzaXplXSkge1xuICAgICAgICBiZXN0c2l6ZSsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtiZXN0aSwgYmVzdGosIGJlc3RzaXplXTtcbiAgICB9O1xuXG4gICAgU2VxdWVuY2VNYXRjaGVyLnByb3RvdHlwZS5nZXRNYXRjaGluZ0Jsb2NrcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLypcbiAgICAgICAgICBSZXR1cm4gbGlzdCBvZiB0cmlwbGVzIGRlc2NyaWJpbmcgbWF0Y2hpbmcgc3Vic2VxdWVuY2VzLlxuICAgICAgXG4gICAgICAgICAgRWFjaCB0cmlwbGUgaXMgb2YgdGhlIGZvcm0gW2ksIGosIG5dLCBhbmQgbWVhbnMgdGhhdFxuICAgICAgICAgIGFbaS4uLmkrbl0gPT0gYltqLi4uaituXS4gIFRoZSB0cmlwbGVzIGFyZSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgaW5cbiAgICAgICAgICBpIGFuZCBpbiBqLiAgaXQncyBhbHNvIGd1YXJhbnRlZWQgdGhhdCBpZlxuICAgICAgICAgIFtpLCBqLCBuXSBhbmQgW2knLCBqJywgbiddIGFyZSBhZGphY2VudCB0cmlwbGVzIGluIHRoZSBsaXN0LCBhbmRcbiAgICAgICAgICB0aGUgc2Vjb25kIGlzIG5vdCB0aGUgbGFzdCB0cmlwbGUgaW4gdGhlIGxpc3QsIHRoZW4gaStuICE9IGknIG9yXG4gICAgICAgICAgaituICE9IGonLiAgSU9XLCBhZGphY2VudCB0cmlwbGVzIG5ldmVyIGRlc2NyaWJlIGFkamFjZW50IGVxdWFsXG4gICAgICAgICAgYmxvY2tzLlxuICAgICAgXG4gICAgICAgICAgVGhlIGxhc3QgdHJpcGxlIGlzIGEgZHVtbXksIFthLmxlbmd0aCwgYi5sZW5ndGgsIDBdLCBhbmQgaXMgdGhlIG9ubHlcbiAgICAgICAgICB0cmlwbGUgd2l0aCBuPT0wLlxuICAgICAgXG4gICAgICAgICAgPj4+IHMgPSBuZXcgU2VxdWVuY2VNYXRjaGVyKG51bGwsICdhYnhjZCcsICdhYmNkJylcbiAgICAgICAgICA+Pj4gcy5nZXRNYXRjaGluZ0Jsb2NrcygpXG4gICAgICAgICAgW1swLCAwLCAyXSwgWzMsIDIsIDJdLCBbNSwgNCwgMF1dXG4gICAgICAqL1xuXG4gICAgICB2YXIgYWhpLCBhbG8sIGJoaSwgYmxvLCBpLCBpMSwgaTIsIGosIGoxLCBqMiwgaywgazEsIGsyLCBsYSwgbGIsIG1hdGNoaW5nQmxvY2tzLCBub25BZGphY2VudCwgcXVldWUsIHgsIF9pLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3JlZjIsIF9yZWYzLCBfcmVmNDtcbiAgICAgIGlmICh0aGlzLm1hdGNoaW5nQmxvY2tzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoaW5nQmxvY2tzO1xuICAgICAgfVxuICAgICAgX3JlZiA9IFt0aGlzLmEubGVuZ3RoLCB0aGlzLmIubGVuZ3RoXSwgbGEgPSBfcmVmWzBdLCBsYiA9IF9yZWZbMV07XG4gICAgICBxdWV1ZSA9IFtbMCwgbGEsIDAsIGxiXV07XG4gICAgICBtYXRjaGluZ0Jsb2NrcyA9IFtdO1xuICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBfcmVmMSA9IHF1ZXVlLnBvcCgpLCBhbG8gPSBfcmVmMVswXSwgYWhpID0gX3JlZjFbMV0sIGJsbyA9IF9yZWYxWzJdLCBiaGkgPSBfcmVmMVszXTtcbiAgICAgICAgX3JlZjIgPSB4ID0gdGhpcy5maW5kTG9uZ2VzdE1hdGNoKGFsbywgYWhpLCBibG8sIGJoaSksIGkgPSBfcmVmMlswXSwgaiA9IF9yZWYyWzFdLCBrID0gX3JlZjJbMl07XG4gICAgICAgIGlmIChrKSB7XG4gICAgICAgICAgbWF0Y2hpbmdCbG9ja3MucHVzaCh4KTtcbiAgICAgICAgICBpZiAoYWxvIDwgaSAmJiBibG8gPCBqKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKFthbG8sIGksIGJsbywgal0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaSArIGsgPCBhaGkgJiYgaiArIGsgPCBiaGkpIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goW2kgKyBrLCBhaGksIGogKyBrLCBiaGldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1hdGNoaW5nQmxvY2tzLnNvcnQoX2FycmF5Q21wKTtcbiAgICAgIGkxID0gajEgPSBrMSA9IDA7XG4gICAgICBub25BZGphY2VudCA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBtYXRjaGluZ0Jsb2Nrcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBfcmVmMyA9IG1hdGNoaW5nQmxvY2tzW19pXSwgaTIgPSBfcmVmM1swXSwgajIgPSBfcmVmM1sxXSwgazIgPSBfcmVmM1syXTtcbiAgICAgICAgaWYgKGkxICsgazEgPT09IGkyICYmIGoxICsgazEgPT09IGoyKSB7XG4gICAgICAgICAgazEgKz0gazI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGsxKSB7XG4gICAgICAgICAgICBub25BZGphY2VudC5wdXNoKFtpMSwgajEsIGsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9yZWY0ID0gW2kyLCBqMiwgazJdLCBpMSA9IF9yZWY0WzBdLCBqMSA9IF9yZWY0WzFdLCBrMSA9IF9yZWY0WzJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoazEpIHtcbiAgICAgICAgbm9uQWRqYWNlbnQucHVzaChbaTEsIGoxLCBrMV0pO1xuICAgICAgfVxuICAgICAgbm9uQWRqYWNlbnQucHVzaChbbGEsIGxiLCAwXSk7XG4gICAgICByZXR1cm4gdGhpcy5tYXRjaGluZ0Jsb2NrcyA9IG5vbkFkamFjZW50O1xuICAgIH07XG5cbiAgICBTZXF1ZW5jZU1hdGNoZXIucHJvdG90eXBlLmdldE9wY29kZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8qIFxuICAgICAgUmV0dXJuIGxpc3Qgb2YgNS10dXBsZXMgZGVzY3JpYmluZyBob3cgdG8gdHVybiBhIGludG8gYi5cbiAgICAgIFxuICAgICAgRWFjaCB0dXBsZSBpcyBvZiB0aGUgZm9ybSBbdGFnLCBpMSwgaTIsIGoxLCBqMl0uICBUaGUgZmlyc3QgdHVwbGVcbiAgICAgIGhhcyBpMSA9PSBqMSA9PSAwLCBhbmQgcmVtYWluaW5nIHR1cGxlcyBoYXZlIGkxID09IHRoZSBpMiBmcm9tIHRoZVxuICAgICAgdHVwbGUgcHJlY2VkaW5nIGl0LCBhbmQgbGlrZXdpc2UgZm9yIGoxID09IHRoZSBwcmV2aW91cyBqMi5cbiAgICAgIFxuICAgICAgVGhlIHRhZ3MgYXJlIHN0cmluZ3MsIHdpdGggdGhlc2UgbWVhbmluZ3M6XG4gICAgICBcbiAgICAgICdyZXBsYWNlJzogIGFbaTEuLi5pMl0gc2hvdWxkIGJlIHJlcGxhY2VkIGJ5IGJbajEuLi5qMl1cbiAgICAgICdkZWxldGUnOiAgIGFbaTEuLi5pMl0gc2hvdWxkIGJlIGRlbGV0ZWQuXG4gICAgICAgICAgICAgICAgICBOb3RlIHRoYXQgajE9PWoyIGluIHRoaXMgY2FzZS5cbiAgICAgICdpbnNlcnQnOiAgIGJbajEuLi5qMl0gc2hvdWxkIGJlIGluc2VydGVkIGF0IGFbaTEuLi5pMV0uXG4gICAgICAgICAgICAgICAgICBOb3RlIHRoYXQgaTE9PWkyIGluIHRoaXMgY2FzZS5cbiAgICAgICdlcXVhbCc6ICAgIGFbaTEuLi5pMl0gPT0gYltqMS4uLmoyXVxuICAgICAgXG4gICAgICA+Pj4gcyA9IG5ldyBTZXF1ZW5jZU1hdGNoZXIobnVsbCwgJ3FhYnhjZCcsICdhYnljZGYnKVxuICAgICAgPj4+IHMuZ2V0T3Bjb2RlcygpXG4gICAgICBbIFsgJ2RlbGV0ZScgICwgMCAsIDEgLCAwICwgMCBdICxcbiAgICAgICAgWyAnZXF1YWwnICAgLCAxICwgMyAsIDAgLCAyIF0gLFxuICAgICAgICBbICdyZXBsYWNlJyAsIDMgLCA0ICwgMiAsIDMgXSAsXG4gICAgICAgIFsgJ2VxdWFsJyAgICwgNCAsIDYgLCAzICwgNSBdICxcbiAgICAgICAgWyAnaW5zZXJ0JyAgLCA2ICwgNiAsIDUgLCA2IF0gXVxuICAgICAgKi9cblxuICAgICAgdmFyIGFpLCBhbnN3ZXIsIGJqLCBpLCBqLCBzaXplLCB0YWcsIF9pLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3JlZjI7XG4gICAgICBpZiAodGhpcy5vcGNvZGVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wY29kZXM7XG4gICAgICB9XG4gICAgICBpID0gaiA9IDA7XG4gICAgICB0aGlzLm9wY29kZXMgPSBhbnN3ZXIgPSBbXTtcbiAgICAgIF9yZWYgPSB0aGlzLmdldE1hdGNoaW5nQmxvY2tzKCk7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgX3JlZjEgPSBfcmVmW19pXSwgYWkgPSBfcmVmMVswXSwgYmogPSBfcmVmMVsxXSwgc2l6ZSA9IF9yZWYxWzJdO1xuICAgICAgICB0YWcgPSAnJztcbiAgICAgICAgaWYgKGkgPCBhaSAmJiBqIDwgYmopIHtcbiAgICAgICAgICB0YWcgPSAncmVwbGFjZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA8IGFpKSB7XG4gICAgICAgICAgdGFnID0gJ2RlbGV0ZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoaiA8IGJqKSB7XG4gICAgICAgICAgdGFnID0gJ2luc2VydCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgIGFuc3dlci5wdXNoKFt0YWcsIGksIGFpLCBqLCBial0pO1xuICAgICAgICB9XG4gICAgICAgIF9yZWYyID0gW2FpICsgc2l6ZSwgYmogKyBzaXplXSwgaSA9IF9yZWYyWzBdLCBqID0gX3JlZjJbMV07XG4gICAgICAgIGlmIChzaXplKSB7XG4gICAgICAgICAgYW5zd2VyLnB1c2goWydlcXVhbCcsIGFpLCBpLCBiaiwgal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYW5zd2VyO1xuICAgIH07XG5cbiAgICBTZXF1ZW5jZU1hdGNoZXIucHJvdG90eXBlLmdldEdyb3VwZWRPcGNvZGVzID0gZnVuY3Rpb24obikge1xuICAgICAgdmFyIGNvZGVzLCBncm91cCwgZ3JvdXBzLCBpMSwgaTIsIGoxLCBqMiwgbm4sIHRhZywgX2ksIF9sZW4sIF9yZWYsIF9yZWYxLCBfcmVmMiwgX3JlZjM7XG4gICAgICBpZiAobiA9PSBudWxsKSB7XG4gICAgICAgIG4gPSAzO1xuICAgICAgfVxuICAgICAgLyogXG4gICAgICBJc29sYXRlIGNoYW5nZSBjbHVzdGVycyBieSBlbGltaW5hdGluZyByYW5nZXMgd2l0aCBubyBjaGFuZ2VzLlxuICAgICAgXG4gICAgICBSZXR1cm4gYSBsaXN0IGdyb3VwcyB3aXRoIHVwdG8gbiBsaW5lcyBvZiBjb250ZXh0LlxuICAgICAgRWFjaCBncm91cCBpcyBpbiB0aGUgc2FtZSBmb3JtYXQgYXMgcmV0dXJuZWQgYnkgZ2V0X29wY29kZXMoKS5cbiAgICAgIFxuICAgICAgPj4+IGEgPSBbMS4uLjQwXS5tYXAoU3RyaW5nKVxuICAgICAgPj4+IGIgPSBhLnNsaWNlKClcbiAgICAgID4+PiBiWzguLi44XSA9ICdpJ1xuICAgICAgPj4+IGJbMjBdICs9ICd4J1xuICAgICAgPj4+IGJbMjMuLi4yOF0gPSBbXVxuICAgICAgPj4+IGJbMzBdICs9ICd5J1xuICAgICAgPj4+IHMgPSBuZXcgU2VxdWVuY2VNYXRjaGVyKG51bGwsIGEsIGIpXG4gICAgICA+Pj4gcy5nZXRHcm91cGVkT3Bjb2RlcygpXG4gICAgICBbIFsgWyAnZXF1YWwnICAsIDUgLCA4ICAsIDUgLCA4IF0sXG4gICAgICAgICAgWyAnaW5zZXJ0JyAsIDggLCA4ICAsIDggLCA5IF0sXG4gICAgICAgICAgWyAnZXF1YWwnICAsIDggLCAxMSAsIDkgLCAxMiBdIF0sXG4gICAgICAgIFsgWyAnZXF1YWwnICAgLCAxNiAsIDE5ICwgMTcgLCAyMCBdLFxuICAgICAgICAgIFsgJ3JlcGxhY2UnICwgMTkgLCAyMCAsIDIwICwgMjEgXSxcbiAgICAgICAgICBbICdlcXVhbCcgICAsIDIwICwgMjIgLCAyMSAsIDIzIF0sXG4gICAgICAgICAgWyAnZGVsZXRlJyAgLCAyMiAsIDI3ICwgMjMgLCAyMyBdLFxuICAgICAgICAgIFsgJ2VxdWFsJyAgICwgMjcgLCAzMCAsIDIzICwgMjYgXSBdLFxuICAgICAgICBbIFsgJ2VxdWFsJyAgICwgMzEgLCAzNCAsIDI3ICwgMzAgXSxcbiAgICAgICAgICBbICdyZXBsYWNlJyAsIDM0ICwgMzUgLCAzMCAsIDMxIF0sXG4gICAgICAgICAgWyAnZXF1YWwnICAgLCAzNSAsIDM4ICwgMzEgLCAzNCBdIF0gXVxuICAgICAgKi9cblxuICAgICAgY29kZXMgPSB0aGlzLmdldE9wY29kZXMoKTtcbiAgICAgIGlmICghY29kZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvZGVzID0gW1snZXF1YWwnLCAwLCAxLCAwLCAxXV07XG4gICAgICB9XG4gICAgICBpZiAoY29kZXNbMF1bMF0gPT09ICdlcXVhbCcpIHtcbiAgICAgICAgX3JlZiA9IGNvZGVzWzBdLCB0YWcgPSBfcmVmWzBdLCBpMSA9IF9yZWZbMV0sIGkyID0gX3JlZlsyXSwgajEgPSBfcmVmWzNdLCBqMiA9IF9yZWZbNF07XG4gICAgICAgIGNvZGVzWzBdID0gW3RhZywgbWF4KGkxLCBpMiAtIG4pLCBpMiwgbWF4KGoxLCBqMiAtIG4pLCBqMl07XG4gICAgICB9XG4gICAgICBpZiAoY29kZXNbY29kZXMubGVuZ3RoIC0gMV1bMF0gPT09ICdlcXVhbCcpIHtcbiAgICAgICAgX3JlZjEgPSBjb2Rlc1tjb2Rlcy5sZW5ndGggLSAxXSwgdGFnID0gX3JlZjFbMF0sIGkxID0gX3JlZjFbMV0sIGkyID0gX3JlZjFbMl0sIGoxID0gX3JlZjFbM10sIGoyID0gX3JlZjFbNF07XG4gICAgICAgIGNvZGVzW2NvZGVzLmxlbmd0aCAtIDFdID0gW3RhZywgaTEsIG1pbihpMiwgaTEgKyBuKSwgajEsIG1pbihqMiwgajEgKyBuKV07XG4gICAgICB9XG4gICAgICBubiA9IG4gKyBuO1xuICAgICAgZ3JvdXBzID0gW107XG4gICAgICBncm91cCA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBjb2Rlcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBfcmVmMiA9IGNvZGVzW19pXSwgdGFnID0gX3JlZjJbMF0sIGkxID0gX3JlZjJbMV0sIGkyID0gX3JlZjJbMl0sIGoxID0gX3JlZjJbM10sIGoyID0gX3JlZjJbNF07XG4gICAgICAgIGlmICh0YWcgPT09ICdlcXVhbCcgJiYgaTIgLSBpMSA+IG5uKSB7XG4gICAgICAgICAgZ3JvdXAucHVzaChbdGFnLCBpMSwgbWluKGkyLCBpMSArIG4pLCBqMSwgbWluKGoyLCBqMSArIG4pXSk7XG4gICAgICAgICAgZ3JvdXBzLnB1c2goZ3JvdXApO1xuICAgICAgICAgIGdyb3VwID0gW107XG4gICAgICAgICAgX3JlZjMgPSBbbWF4KGkxLCBpMiAtIG4pLCBtYXgoajEsIGoyIC0gbildLCBpMSA9IF9yZWYzWzBdLCBqMSA9IF9yZWYzWzFdO1xuICAgICAgICB9XG4gICAgICAgIGdyb3VwLnB1c2goW3RhZywgaTEsIGkyLCBqMSwgajJdKTtcbiAgICAgIH1cbiAgICAgIGlmIChncm91cC5sZW5ndGggJiYgIShncm91cC5sZW5ndGggPT09IDEgJiYgZ3JvdXBbMF1bMF0gPT09ICdlcXVhbCcpKSB7XG4gICAgICAgIGdyb3Vwcy5wdXNoKGdyb3VwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncm91cHM7XG4gICAgfTtcblxuICAgIFNlcXVlbmNlTWF0Y2hlci5wcm90b3R5cGUucmF0aW8gPSBmdW5jdGlvbigpIHtcbiAgICAgIC8qXG4gICAgICAgICAgUmV0dXJuIGEgbWVhc3VyZSBvZiB0aGUgc2VxdWVuY2VzJyBzaW1pbGFyaXR5IChmbG9hdCBpbiBbMCwxXSkuXG4gICAgICBcbiAgICAgICAgICBXaGVyZSBUIGlzIHRoZSB0b3RhbCBudW1iZXIgb2YgZWxlbWVudHMgaW4gYm90aCBzZXF1ZW5jZXMsIGFuZFxuICAgICAgICAgIE0gaXMgdGhlIG51bWJlciBvZiBtYXRjaGVzLCB0aGlzIGlzIDIuMCpNIC8gVC5cbiAgICAgICAgICBOb3RlIHRoYXQgdGhpcyBpcyAxIGlmIHRoZSBzZXF1ZW5jZXMgYXJlIGlkZW50aWNhbCwgYW5kIDAgaWZcbiAgICAgICAgICB0aGV5IGhhdmUgbm90aGluZyBpbiBjb21tb24uXG4gICAgICBcbiAgICAgICAgICAucmF0aW8oKSBpcyBleHBlbnNpdmUgdG8gY29tcHV0ZSBpZiB5b3UgaGF2ZW4ndCBhbHJlYWR5IGNvbXB1dGVkXG4gICAgICAgICAgLmdldE1hdGNoaW5nQmxvY2tzKCkgb3IgLmdldE9wY29kZXMoKSwgaW4gd2hpY2ggY2FzZSB5b3UgbWF5XG4gICAgICAgICAgd2FudCB0byB0cnkgLnF1aWNrUmF0aW8oKSBvciAucmVhbFF1aWNrUmF0aW8oKSBmaXJzdCB0byBnZXQgYW5cbiAgICAgICAgICB1cHBlciBib3VuZC5cbiAgICAgICAgICBcbiAgICAgICAgICA+Pj4gcyA9IG5ldyBTZXF1ZW5jZU1hdGNoZXIobnVsbCwgJ2FiY2QnLCAnYmNkZScpXG4gICAgICAgICAgPj4+IHMucmF0aW8oKVxuICAgICAgICAgIDAuNzVcbiAgICAgICAgICA+Pj4gcy5xdWlja1JhdGlvKClcbiAgICAgICAgICAwLjc1XG4gICAgICAgICAgPj4+IHMucmVhbFF1aWNrUmF0aW8oKVxuICAgICAgICAgIDEuMFxuICAgICAgKi9cblxuICAgICAgdmFyIG1hdGNoLCBtYXRjaGVzLCBfaSwgX2xlbiwgX3JlZjtcbiAgICAgIG1hdGNoZXMgPSAwO1xuICAgICAgX3JlZiA9IHRoaXMuZ2V0TWF0Y2hpbmdCbG9ja3MoKTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBtYXRjaCA9IF9yZWZbX2ldO1xuICAgICAgICBtYXRjaGVzICs9IG1hdGNoWzJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9jYWxjdWxhdGVSYXRpbyhtYXRjaGVzLCB0aGlzLmEubGVuZ3RoICsgdGhpcy5iLmxlbmd0aCk7XG4gICAgfTtcblxuICAgIFNlcXVlbmNlTWF0Y2hlci5wcm90b3R5cGUucXVpY2tSYXRpbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLypcbiAgICAgICAgICBSZXR1cm4gYW4gdXBwZXIgYm91bmQgb24gcmF0aW8oKSByZWxhdGl2ZWx5IHF1aWNrbHkuXG4gICAgICBcbiAgICAgICAgICBUaGlzIGlzbid0IGRlZmluZWQgYmV5b25kIHRoYXQgaXQgaXMgYW4gdXBwZXIgYm91bmQgb24gLnJhdGlvKCksIGFuZFxuICAgICAgICAgIGlzIGZhc3RlciB0byBjb21wdXRlLlxuICAgICAgKi9cblxuICAgICAgdmFyIGF2YWlsLCBlbHQsIGZ1bGxiY291bnQsIG1hdGNoZXMsIG51bWIsIF9pLCBfaiwgX2xlbiwgX2xlbjEsIF9yZWYsIF9yZWYxO1xuICAgICAgaWYgKCF0aGlzLmZ1bGxiY291bnQpIHtcbiAgICAgICAgdGhpcy5mdWxsYmNvdW50ID0gZnVsbGJjb3VudCA9IHt9O1xuICAgICAgICBfcmVmID0gdGhpcy5iO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBlbHQgPSBfcmVmW19pXTtcbiAgICAgICAgICBmdWxsYmNvdW50W2VsdF0gPSAoZnVsbGJjb3VudFtlbHRdIHx8IDApICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVsbGJjb3VudCA9IHRoaXMuZnVsbGJjb3VudDtcbiAgICAgIGF2YWlsID0ge307XG4gICAgICBtYXRjaGVzID0gMDtcbiAgICAgIF9yZWYxID0gdGhpcy5hO1xuICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjEubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgIGVsdCA9IF9yZWYxW19qXTtcbiAgICAgICAgaWYgKF9oYXMoYXZhaWwsIGVsdCkpIHtcbiAgICAgICAgICBudW1iID0gYXZhaWxbZWx0XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBudW1iID0gZnVsbGJjb3VudFtlbHRdIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgYXZhaWxbZWx0XSA9IG51bWIgLSAxO1xuICAgICAgICBpZiAobnVtYiA+IDApIHtcbiAgICAgICAgICBtYXRjaGVzKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfY2FsY3VsYXRlUmF0aW8obWF0Y2hlcywgdGhpcy5hLmxlbmd0aCArIHRoaXMuYi5sZW5ndGgpO1xuICAgIH07XG5cbiAgICBTZXF1ZW5jZU1hdGNoZXIucHJvdG90eXBlLnJlYWxRdWlja1JhdGlvID0gZnVuY3Rpb24oKSB7XG4gICAgICAvKlxuICAgICAgICAgIFJldHVybiBhbiB1cHBlciBib3VuZCBvbiByYXRpbygpIHZlcnkgcXVpY2tseS5cbiAgICAgIFxuICAgICAgICAgIFRoaXMgaXNuJ3QgZGVmaW5lZCBiZXlvbmQgdGhhdCBpdCBpcyBhbiB1cHBlciBib3VuZCBvbiAucmF0aW8oKSwgYW5kXG4gICAgICAgICAgaXMgZmFzdGVyIHRvIGNvbXB1dGUgdGhhbiBlaXRoZXIgLnJhdGlvKCkgb3IgLnF1aWNrUmF0aW8oKS5cbiAgICAgICovXG5cbiAgICAgIHZhciBsYSwgbGIsIF9yZWY7XG4gICAgICBfcmVmID0gW3RoaXMuYS5sZW5ndGgsIHRoaXMuYi5sZW5ndGhdLCBsYSA9IF9yZWZbMF0sIGxiID0gX3JlZlsxXTtcbiAgICAgIHJldHVybiBfY2FsY3VsYXRlUmF0aW8obWluKGxhLCBsYiksIGxhICsgbGIpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2VxdWVuY2VNYXRjaGVyO1xuXG4gIH0pKCk7XG5cbiAgZ2V0Q2xvc2VNYXRjaGVzID0gZnVuY3Rpb24od29yZCwgcG9zc2liaWxpdGllcywgbiwgY3V0b2ZmKSB7XG4gICAgdmFyIHJlc3VsdCwgcywgc2NvcmUsIHgsIF9pLCBfaiwgX2xlbiwgX2xlbjEsIF9yZWYsIF9yZXN1bHRzO1xuICAgIGlmIChuID09IG51bGwpIHtcbiAgICAgIG4gPSAzO1xuICAgIH1cbiAgICBpZiAoY3V0b2ZmID09IG51bGwpIHtcbiAgICAgIGN1dG9mZiA9IDAuNjtcbiAgICB9XG4gICAgLypcbiAgICAgIFVzZSBTZXF1ZW5jZU1hdGNoZXIgdG8gcmV0dXJuIGxpc3Qgb2YgdGhlIGJlc3QgXCJnb29kIGVub3VnaFwiIG1hdGNoZXMuXG4gICAgXG4gICAgICB3b3JkIGlzIGEgc2VxdWVuY2UgZm9yIHdoaWNoIGNsb3NlIG1hdGNoZXMgYXJlIGRlc2lyZWQgKHR5cGljYWxseSBhXG4gICAgICBzdHJpbmcpLlxuICAgIFxuICAgICAgcG9zc2liaWxpdGllcyBpcyBhIGxpc3Qgb2Ygc2VxdWVuY2VzIGFnYWluc3Qgd2hpY2ggdG8gbWF0Y2ggd29yZFxuICAgICAgKHR5cGljYWxseSBhIGxpc3Qgb2Ygc3RyaW5ncykuXG4gICAgXG4gICAgICBPcHRpb25hbCBhcmcgbiAoZGVmYXVsdCAzKSBpcyB0aGUgbWF4aW11bSBudW1iZXIgb2YgY2xvc2UgbWF0Y2hlcyB0b1xuICAgICAgcmV0dXJuLiAgbiBtdXN0IGJlID4gMC5cbiAgICBcbiAgICAgIE9wdGlvbmFsIGFyZyBjdXRvZmYgKGRlZmF1bHQgMC42KSBpcyBhIGZsb2F0IGluIFswLCAxXS4gIFBvc3NpYmlsaXRpZXNcbiAgICAgIHRoYXQgZG9uJ3Qgc2NvcmUgYXQgbGVhc3QgdGhhdCBzaW1pbGFyIHRvIHdvcmQgYXJlIGlnbm9yZWQuXG4gICAgXG4gICAgICBUaGUgYmVzdCAobm8gbW9yZSB0aGFuIG4pIG1hdGNoZXMgYW1vbmcgdGhlIHBvc3NpYmlsaXRpZXMgYXJlIHJldHVybmVkXG4gICAgICBpbiBhIGxpc3QsIHNvcnRlZCBieSBzaW1pbGFyaXR5IHNjb3JlLCBtb3N0IHNpbWlsYXIgZmlyc3QuXG4gICAgXG4gICAgICA+Pj4gZ2V0Q2xvc2VNYXRjaGVzKCdhcHBlbCcsIFsnYXBlJywgJ2FwcGxlJywgJ3BlYWNoJywgJ3B1cHB5J10pXG4gICAgICBbJ2FwcGxlJywgJ2FwZSddXG4gICAgICA+Pj4gS0VZV09SRFMgPSByZXF1aXJlKCdjb2ZmZWUtc2NyaXB0JykuUkVTRVJWRURcbiAgICAgID4+PiBnZXRDbG9zZU1hdGNoZXMoJ3doZWVsJywgS0VZV09SRFMpXG4gICAgICBbJ3doZW4nLCAnd2hpbGUnXVxuICAgICAgPj4+IGdldENsb3NlTWF0Y2hlcygnYWNjb3N0JywgS0VZV09SRFMpXG4gICAgICBbJ2NvbnN0J11cbiAgICAqL1xuXG4gICAgaWYgKCEobiA+IDApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuIG11c3QgYmUgPiAwOiAoXCIgKyBuICsgXCIpXCIpO1xuICAgIH1cbiAgICBpZiAoISgoMC4wIDw9IGN1dG9mZiAmJiBjdXRvZmYgPD0gMS4wKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImN1dG9mZiBtdXN0IGJlIGluIFswLjAsIDEuMF06IChcIiArIGN1dG9mZiArIFwiKVwiKTtcbiAgICB9XG4gICAgcmVzdWx0ID0gW107XG4gICAgcyA9IG5ldyBTZXF1ZW5jZU1hdGNoZXIoKTtcbiAgICBzLnNldFNlcTIod29yZCk7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBwb3NzaWJpbGl0aWVzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICB4ID0gcG9zc2liaWxpdGllc1tfaV07XG4gICAgICBzLnNldFNlcTEoeCk7XG4gICAgICBpZiAocy5yZWFsUXVpY2tSYXRpbygpID49IGN1dG9mZiAmJiBzLnF1aWNrUmF0aW8oKSA+PSBjdXRvZmYgJiYgcy5yYXRpbygpID49IGN1dG9mZikge1xuICAgICAgICByZXN1bHQucHVzaChbcy5yYXRpbygpLCB4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdCA9IEhlYXAubmxhcmdlc3QocmVzdWx0LCBuLCBfYXJyYXlDbXApO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChfaiA9IDAsIF9sZW4xID0gcmVzdWx0Lmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgX3JlZiA9IHJlc3VsdFtfal0sIHNjb3JlID0gX3JlZlswXSwgeCA9IF9yZWZbMV07XG4gICAgICBfcmVzdWx0cy5wdXNoKHgpO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cbiAgX2NvdW50TGVhZGluZyA9IGZ1bmN0aW9uKGxpbmUsIGNoKSB7XG4gICAgLypcbiAgICAgIFJldHVybiBudW1iZXIgb2YgYGNoYCBjaGFyYWN0ZXJzIGF0IHRoZSBzdGFydCBvZiBgbGluZWAuXG4gICAgXG4gICAgICA+Pj4gX2NvdW50TGVhZGluZygnICAgYWJjJywgJyAnKVxuICAgICAgM1xuICAgICovXG5cbiAgICB2YXIgaSwgbiwgX3JlZjtcbiAgICBfcmVmID0gWzAsIGxpbmUubGVuZ3RoXSwgaSA9IF9yZWZbMF0sIG4gPSBfcmVmWzFdO1xuICAgIHdoaWxlIChpIDwgbiAmJiBsaW5lW2ldID09PSBjaCkge1xuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfTtcblxuICBEaWZmZXIgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICBEaWZmZXIubmFtZSA9ICdEaWZmZXInO1xuXG4gICAgLypcbiAgICAgIERpZmZlciBpcyBhIGNsYXNzIGZvciBjb21wYXJpbmcgc2VxdWVuY2VzIG9mIGxpbmVzIG9mIHRleHQsIGFuZFxuICAgICAgcHJvZHVjaW5nIGh1bWFuLXJlYWRhYmxlIGRpZmZlcmVuY2VzIG9yIGRlbHRhcy4gIERpZmZlciB1c2VzXG4gICAgICBTZXF1ZW5jZU1hdGNoZXIgYm90aCB0byBjb21wYXJlIHNlcXVlbmNlcyBvZiBsaW5lcywgYW5kIHRvIGNvbXBhcmVcbiAgICAgIHNlcXVlbmNlcyBvZiBjaGFyYWN0ZXJzIHdpdGhpbiBzaW1pbGFyIChuZWFyLW1hdGNoaW5nKSBsaW5lcy5cbiAgICBcbiAgICAgIEVhY2ggbGluZSBvZiBhIERpZmZlciBkZWx0YSBiZWdpbnMgd2l0aCBhIHR3by1sZXR0ZXIgY29kZTpcbiAgICBcbiAgICAgICAgICAnLSAnICAgIGxpbmUgdW5pcXVlIHRvIHNlcXVlbmNlIDFcbiAgICAgICAgICAnKyAnICAgIGxpbmUgdW5pcXVlIHRvIHNlcXVlbmNlIDJcbiAgICAgICAgICAnICAnICAgIGxpbmUgY29tbW9uIHRvIGJvdGggc2VxdWVuY2VzXG4gICAgICAgICAgJz8gJyAgICBsaW5lIG5vdCBwcmVzZW50IGluIGVpdGhlciBpbnB1dCBzZXF1ZW5jZVxuICAgIFxuICAgICAgTGluZXMgYmVnaW5uaW5nIHdpdGggJz8gJyBhdHRlbXB0IHRvIGd1aWRlIHRoZSBleWUgdG8gaW50cmFsaW5lXG4gICAgICBkaWZmZXJlbmNlcywgYW5kIHdlcmUgbm90IHByZXNlbnQgaW4gZWl0aGVyIGlucHV0IHNlcXVlbmNlLiAgVGhlc2UgbGluZXNcbiAgICAgIGNhbiBiZSBjb25mdXNpbmcgaWYgdGhlIHNlcXVlbmNlcyBjb250YWluIHRhYiBjaGFyYWN0ZXJzLlxuICAgIFxuICAgICAgTm90ZSB0aGF0IERpZmZlciBtYWtlcyBubyBjbGFpbSB0byBwcm9kdWNlIGEgKm1pbmltYWwqIGRpZmYuICBUbyB0aGVcbiAgICAgIGNvbnRyYXJ5LCBtaW5pbWFsIGRpZmZzIGFyZSBvZnRlbiBjb3VudGVyLWludHVpdGl2ZSwgYmVjYXVzZSB0aGV5IHN5bmNoXG4gICAgICB1cCBhbnl3aGVyZSBwb3NzaWJsZSwgc29tZXRpbWVzIGFjY2lkZW50YWwgbWF0Y2hlcyAxMDAgcGFnZXMgYXBhcnQuXG4gICAgICBSZXN0cmljdGluZyBzeW5jaCBwb2ludHMgdG8gY29udGlndW91cyBtYXRjaGVzIHByZXNlcnZlcyBzb21lIG5vdGlvbiBvZlxuICAgICAgbG9jYWxpdHksIGF0IHRoZSBvY2Nhc2lvbmFsIGNvc3Qgb2YgcHJvZHVjaW5nIGEgbG9uZ2VyIGRpZmYuXG4gICAgXG4gICAgICBFeGFtcGxlOiBDb21wYXJpbmcgdHdvIHRleHRzLlxuICAgIFxuICAgICAgPj4+IHRleHQxID0gWycxLiBCZWF1dGlmdWwgaXMgYmV0dGVyIHRoYW4gdWdseS5cXG4nLFxuICAgICAgLi4uICAgJzIuIEV4cGxpY2l0IGlzIGJldHRlciB0aGFuIGltcGxpY2l0LlxcbicsXG4gICAgICAuLi4gICAnMy4gU2ltcGxlIGlzIGJldHRlciB0aGFuIGNvbXBsZXguXFxuJyxcbiAgICAgIC4uLiAgICc0LiBDb21wbGV4IGlzIGJldHRlciB0aGFuIGNvbXBsaWNhdGVkLlxcbiddXG4gICAgICA+Pj4gdGV4dDEubGVuZ3RoXG4gICAgICA0XG4gICAgICA+Pj4gdGV4dDIgPSBbJzEuIEJlYXV0aWZ1bCBpcyBiZXR0ZXIgdGhhbiB1Z2x5LlxcbicsXG4gICAgICAuLi4gICAnMy4gICBTaW1wbGUgaXMgYmV0dGVyIHRoYW4gY29tcGxleC5cXG4nLFxuICAgICAgLi4uICAgJzQuIENvbXBsaWNhdGVkIGlzIGJldHRlciB0aGFuIGNvbXBsZXguXFxuJyxcbiAgICAgIC4uLiAgICc1LiBGbGF0IGlzIGJldHRlciB0aGFuIG5lc3RlZC5cXG4nXVxuICAgIFxuICAgICAgTmV4dCB3ZSBpbnN0YW50aWF0ZSBhIERpZmZlciBvYmplY3Q6XG4gICAgXG4gICAgICA+Pj4gZCA9IG5ldyBEaWZmZXIoKVxuICAgIFxuICAgICAgTm90ZSB0aGF0IHdoZW4gaW5zdGFudGlhdGluZyBhIERpZmZlciBvYmplY3Qgd2UgbWF5IHBhc3MgZnVuY3Rpb25zIHRvXG4gICAgICBmaWx0ZXIgb3V0IGxpbmUgYW5kIGNoYXJhY3RlciAnanVuaycuXG4gICAgXG4gICAgICBGaW5hbGx5LCB3ZSBjb21wYXJlIHRoZSB0d286XG4gICAgXG4gICAgICA+Pj4gcmVzdWx0ID0gZC5jb21wYXJlKHRleHQxLCB0ZXh0MilcbiAgICAgIFsgJyAgMS4gQmVhdXRpZnVsIGlzIGJldHRlciB0aGFuIHVnbHkuXFxuJyxcbiAgICAgICAgJy0gMi4gRXhwbGljaXQgaXMgYmV0dGVyIHRoYW4gaW1wbGljaXQuXFxuJyxcbiAgICAgICAgJy0gMy4gU2ltcGxlIGlzIGJldHRlciB0aGFuIGNvbXBsZXguXFxuJyxcbiAgICAgICAgJysgMy4gICBTaW1wbGUgaXMgYmV0dGVyIHRoYW4gY29tcGxleC5cXG4nLFxuICAgICAgICAnPyAgICsrXFxuJyxcbiAgICAgICAgJy0gNC4gQ29tcGxleCBpcyBiZXR0ZXIgdGhhbiBjb21wbGljYXRlZC5cXG4nLFxuICAgICAgICAnPyAgICAgICAgICBeICAgICAgICAgICAgICAgICAgICAgLS0tLSBeXFxuJyxcbiAgICAgICAgJysgNC4gQ29tcGxpY2F0ZWQgaXMgYmV0dGVyIHRoYW4gY29tcGxleC5cXG4nLFxuICAgICAgICAnPyAgICAgICAgICsrKysgXiAgICAgICAgICAgICAgICAgICAgICBeXFxuJyxcbiAgICAgICAgJysgNS4gRmxhdCBpcyBiZXR0ZXIgdGhhbiBuZXN0ZWQuXFxuJyBdXG4gICAgXG4gICAgICBNZXRob2RzOlxuICAgIFxuICAgICAgY29uc3RydWN0b3IobGluZWp1bms9bnVsbCwgY2hhcmp1bms9bnVsbClcbiAgICAgICAgICBDb25zdHJ1Y3QgYSB0ZXh0IGRpZmZlcmVuY2VyLCB3aXRoIG9wdGlvbmFsIGZpbHRlcnMuXG4gICAgICBjb21wYXJlKGEsIGIpXG4gICAgICAgICAgQ29tcGFyZSB0d28gc2VxdWVuY2VzIG9mIGxpbmVzOyBnZW5lcmF0ZSB0aGUgcmVzdWx0aW5nIGRlbHRhLlxuICAgICovXG5cblxuICAgIGZ1bmN0aW9uIERpZmZlcihsaW5lanVuaywgY2hhcmp1bmspIHtcbiAgICAgIHRoaXMubGluZWp1bmsgPSBsaW5lanVuaztcbiAgICAgIHRoaXMuY2hhcmp1bmsgPSBjaGFyanVuaztcbiAgICAgIC8qXG4gICAgICAgICAgQ29uc3RydWN0IGEgdGV4dCBkaWZmZXJlbmNlciwgd2l0aCBvcHRpb25hbCBmaWx0ZXJzLlxuICAgICAgXG4gICAgICAgICAgVGhlIHR3byBvcHRpb25hbCBrZXl3b3JkIHBhcmFtZXRlcnMgYXJlIGZvciBmaWx0ZXIgZnVuY3Rpb25zOlxuICAgICAgXG4gICAgICAgICAgLSBgbGluZWp1bmtgOiBBIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGFjY2VwdCBhIHNpbmdsZSBzdHJpbmcgYXJndW1lbnQsXG4gICAgICAgICAgICBhbmQgcmV0dXJuIHRydWUgaWZmIHRoZSBzdHJpbmcgaXMganVuay4gVGhlIG1vZHVsZS1sZXZlbCBmdW5jdGlvblxuICAgICAgICAgICAgYElTX0xJTkVfSlVOS2AgbWF5IGJlIHVzZWQgdG8gZmlsdGVyIG91dCBsaW5lcyB3aXRob3V0IHZpc2libGVcbiAgICAgICAgICAgIGNoYXJhY3RlcnMsIGV4Y2VwdCBmb3IgYXQgbW9zdCBvbmUgc3BsYXQgKCcjJykuICBJdCBpcyByZWNvbW1lbmRlZFxuICAgICAgICAgICAgdG8gbGVhdmUgbGluZWp1bmsgbnVsbC4gXG4gICAgICBcbiAgICAgICAgICAtIGBjaGFyanVua2A6IEEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYWNjZXB0IGEgc3RyaW5nIG9mIGxlbmd0aCAxLiBUaGVcbiAgICAgICAgICAgIG1vZHVsZS1sZXZlbCBmdW5jdGlvbiBgSVNfQ0hBUkFDVEVSX0pVTktgIG1heSBiZSB1c2VkIHRvIGZpbHRlciBvdXRcbiAgICAgICAgICAgIHdoaXRlc3BhY2UgY2hhcmFjdGVycyAoYSBibGFuayBvciB0YWI7ICoqbm90ZSoqOiBiYWQgaWRlYSB0byBpbmNsdWRlXG4gICAgICAgICAgICBuZXdsaW5lIGluIHRoaXMhKS4gIFVzZSBvZiBJU19DSEFSQUNURVJfSlVOSyBpcyByZWNvbW1lbmRlZC5cbiAgICAgICovXG5cbiAgICB9XG5cbiAgICBEaWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAvKlxuICAgICAgICAgIENvbXBhcmUgdHdvIHNlcXVlbmNlcyBvZiBsaW5lczsgZ2VuZXJhdGUgdGhlIHJlc3VsdGluZyBkZWx0YS5cbiAgICAgIFxuICAgICAgICAgIEVhY2ggc2VxdWVuY2UgbXVzdCBjb250YWluIGluZGl2aWR1YWwgc2luZ2xlLWxpbmUgc3RyaW5ncyBlbmRpbmcgd2l0aFxuICAgICAgICAgIG5ld2xpbmVzLiBTdWNoIHNlcXVlbmNlcyBjYW4gYmUgb2J0YWluZWQgZnJvbSB0aGUgYHJlYWRsaW5lcygpYCBtZXRob2RcbiAgICAgICAgICBvZiBmaWxlLWxpa2Ugb2JqZWN0cy4gIFRoZSBkZWx0YSBnZW5lcmF0ZWQgYWxzbyBjb25zaXN0cyBvZiBuZXdsaW5lLVxuICAgICAgICAgIHRlcm1pbmF0ZWQgc3RyaW5ncywgcmVhZHkgdG8gYmUgcHJpbnRlZCBhcy1pcyB2aWEgdGhlIHdyaXRlbGluZSgpXG4gICAgICAgICAgbWV0aG9kIG9mIGEgZmlsZS1saWtlIG9iamVjdC5cbiAgICAgIFxuICAgICAgICAgIEV4YW1wbGU6XG4gICAgICBcbiAgICAgICAgICA+Pj4gZCA9IG5ldyBEaWZmZXJcbiAgICAgICAgICA+Pj4gZC5jb21wYXJlKFsnb25lXFxuJywgJ3R3b1xcbicsICd0aHJlZVxcbiddLFxuICAgICAgICAgIC4uLiAgICAgICAgICAgWydvcmVcXG4nLCAndHJlZVxcbicsICdlbXVcXG4nXSlcbiAgICAgICAgICBbICctIG9uZVxcbicsXG4gICAgICAgICAgICAnPyAgXlxcbicsXG4gICAgICAgICAgICAnKyBvcmVcXG4nLFxuICAgICAgICAgICAgJz8gIF5cXG4nLFxuICAgICAgICAgICAgJy0gdHdvXFxuJyxcbiAgICAgICAgICAgICctIHRocmVlXFxuJyxcbiAgICAgICAgICAgICc/ICAtXFxuJyxcbiAgICAgICAgICAgICcrIHRyZWVcXG4nLFxuICAgICAgICAgICAgJysgZW11XFxuJyBdXG4gICAgICAqL1xuXG4gICAgICB2YXIgYWhpLCBhbG8sIGJoaSwgYmxvLCBjcnVuY2hlciwgZywgbGluZSwgbGluZXMsIHRhZywgX2ksIF9qLCBfbGVuLCBfbGVuMSwgX3JlZiwgX3JlZjE7XG4gICAgICBjcnVuY2hlciA9IG5ldyBTZXF1ZW5jZU1hdGNoZXIodGhpcy5saW5lanVuaywgYSwgYik7XG4gICAgICBsaW5lcyA9IFtdO1xuICAgICAgX3JlZiA9IGNydW5jaGVyLmdldE9wY29kZXMoKTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBfcmVmMSA9IF9yZWZbX2ldLCB0YWcgPSBfcmVmMVswXSwgYWxvID0gX3JlZjFbMV0sIGFoaSA9IF9yZWYxWzJdLCBibG8gPSBfcmVmMVszXSwgYmhpID0gX3JlZjFbNF07XG4gICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgICAgY2FzZSAncmVwbGFjZSc6XG4gICAgICAgICAgICBnID0gdGhpcy5fZmFuY3lSZXBsYWNlKGEsIGFsbywgYWhpLCBiLCBibG8sIGJoaSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgICAgZyA9IHRoaXMuX2R1bXAoJy0nLCBhLCBhbG8sIGFoaSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdpbnNlcnQnOlxuICAgICAgICAgICAgZyA9IHRoaXMuX2R1bXAoJysnLCBiLCBibG8sIGJoaSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdlcXVhbCc6XG4gICAgICAgICAgICBnID0gdGhpcy5fZHVtcCgnICcsIGEsIGFsbywgYWhpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3cgdGFnIChcIiArIHRhZyArIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBnLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgIGxpbmUgPSBnW19qXTtcbiAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZXM7XG4gICAgfTtcblxuICAgIERpZmZlci5wcm90b3R5cGUuX2R1bXAgPSBmdW5jdGlvbih0YWcsIHgsIGxvLCBoaSkge1xuICAgICAgLypcbiAgICAgICAgICBHZW5lcmF0ZSBjb21wYXJpc29uIHJlc3VsdHMgZm9yIGEgc2FtZS10YWdnZWQgcmFuZ2UuXG4gICAgICAqL1xuXG4gICAgICB2YXIgaSwgX2ksIF9yZXN1bHRzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoaSA9IF9pID0gbG87IGxvIDw9IGhpID8gX2kgPCBoaSA6IF9pID4gaGk7IGkgPSBsbyA8PSBoaSA/ICsrX2kgOiAtLV9pKSB7XG4gICAgICAgIF9yZXN1bHRzLnB1c2goXCJcIiArIHRhZyArIFwiIFwiICsgeFtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIERpZmZlci5wcm90b3R5cGUuX3BsYWluUmVwbGFjZSA9IGZ1bmN0aW9uKGEsIGFsbywgYWhpLCBiLCBibG8sIGJoaSkge1xuICAgICAgdmFyIGZpcnN0LCBnLCBsaW5lLCBsaW5lcywgc2Vjb25kLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmO1xuICAgICAgYXNzZXJ0KGFsbyA8IGFoaSAmJiBibG8gPCBiaGkpO1xuICAgICAgaWYgKGJoaSAtIGJsbyA8IGFoaSAtIGFsbykge1xuICAgICAgICBmaXJzdCA9IHRoaXMuX2R1bXAoJysnLCBiLCBibG8sIGJoaSk7XG4gICAgICAgIHNlY29uZCA9IHRoaXMuX2R1bXAoJy0nLCBhLCBhbG8sIGFoaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdCA9IHRoaXMuX2R1bXAoJy0nLCBhLCBhbG8sIGFoaSk7XG4gICAgICAgIHNlY29uZCA9IHRoaXMuX2R1bXAoJysnLCBiLCBibG8sIGJoaSk7XG4gICAgICB9XG4gICAgICBsaW5lcyA9IFtdO1xuICAgICAgX3JlZiA9IFtmaXJzdCwgc2Vjb25kXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBnID0gX3JlZltfaV07XG4gICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IGcubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgbGluZSA9IGdbX2pdO1xuICAgICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lcztcbiAgICB9O1xuXG4gICAgRGlmZmVyLnByb3RvdHlwZS5fZmFuY3lSZXBsYWNlID0gZnVuY3Rpb24oYSwgYWxvLCBhaGksIGIsIGJsbywgYmhpKSB7XG4gICAgICAvKlxuICAgICAgICAgIFdoZW4gcmVwbGFjaW5nIG9uZSBibG9jayBvZiBsaW5lcyB3aXRoIGFub3RoZXIsIHNlYXJjaCB0aGUgYmxvY2tzXG4gICAgICAgICAgZm9yICpzaW1pbGFyKiBsaW5lczsgdGhlIGJlc3QtbWF0Y2hpbmcgcGFpciAoaWYgYW55KSBpcyB1c2VkIGFzIGFcbiAgICAgICAgICBzeW5jaCBwb2ludCwgYW5kIGludHJhbGluZSBkaWZmZXJlbmNlIG1hcmtpbmcgaXMgZG9uZSBvbiB0aGVcbiAgICAgICAgICBzaW1pbGFyIHBhaXIuIExvdHMgb2Ygd29yaywgYnV0IG9mdGVuIHdvcnRoIGl0LlxuICAgICAgXG4gICAgICAgICAgRXhhbXBsZTpcbiAgICAgICAgICA+Pj4gZCA9IG5ldyBEaWZmZXJcbiAgICAgICAgICA+Pj4gZC5fZmFuY3lSZXBsYWNlKFsnYWJjRGVmZ2hpSmtsXFxuJ10sIDAsIDEsXG4gICAgICAgICAgLi4uICAgICAgICAgICAgICAgICBbJ2FiY2RlZkdoaWprbFxcbiddLCAwLCAxKVxuICAgICAgICAgIFsgJy0gYWJjRGVmZ2hpSmtsXFxuJyxcbiAgICAgICAgICAgICc/ICAgIF4gIF4gIF5cXG4nLFxuICAgICAgICAgICAgJysgYWJjZGVmR2hpamtsXFxuJyxcbiAgICAgICAgICAgICc/ICAgIF4gIF4gIF5cXG4nIF1cbiAgICAgICovXG5cbiAgICAgIHZhciBhZWx0LCBhaSwgYWkxLCBhaTIsIGF0YWdzLCBiZWx0LCBiZXN0UmF0aW8sIGJlc3RpLCBiZXN0aiwgYmosIGJqMSwgYmoyLCBidGFncywgY3J1bmNoZXIsIGN1dG9mZiwgZXFpLCBlcWosIGksIGosIGxhLCBsYiwgbGluZSwgbGluZXMsIHRhZywgX2ksIF9qLCBfaywgX2wsIF9sZW4sIF9sZW4xLCBfbGVuMiwgX2xlbjMsIF9sZW40LCBfbSwgX24sIF9vLCBfcmVmLCBfcmVmMSwgX3JlZjEwLCBfcmVmMTEsIF9yZWYxMiwgX3JlZjIsIF9yZWYzLCBfcmVmNCwgX3JlZjUsIF9yZWY2LCBfcmVmNywgX3JlZjgsIF9yZWY5O1xuICAgICAgX3JlZiA9IFswLjc0LCAwLjc1XSwgYmVzdFJhdGlvID0gX3JlZlswXSwgY3V0b2ZmID0gX3JlZlsxXTtcbiAgICAgIGNydW5jaGVyID0gbmV3IFNlcXVlbmNlTWF0Y2hlcih0aGlzLmNoYXJqdW5rKTtcbiAgICAgIF9yZWYxID0gW251bGwsIG51bGxdLCBlcWkgPSBfcmVmMVswXSwgZXFqID0gX3JlZjFbMV07XG4gICAgICBsaW5lcyA9IFtdO1xuICAgICAgZm9yIChqID0gX2kgPSBibG87IGJsbyA8PSBiaGkgPyBfaSA8IGJoaSA6IF9pID4gYmhpOyBqID0gYmxvIDw9IGJoaSA/ICsrX2kgOiAtLV9pKSB7XG4gICAgICAgIGJqID0gYltqXTtcbiAgICAgICAgY3J1bmNoZXIuc2V0U2VxMihiaik7XG4gICAgICAgIGZvciAoaSA9IF9qID0gYWxvOyBhbG8gPD0gYWhpID8gX2ogPCBhaGkgOiBfaiA+IGFoaTsgaSA9IGFsbyA8PSBhaGkgPyArK19qIDogLS1faikge1xuICAgICAgICAgIGFpID0gYVtpXTtcbiAgICAgICAgICBpZiAoYWkgPT09IGJqKSB7XG4gICAgICAgICAgICBpZiAoZXFpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIF9yZWYyID0gW2ksIGpdLCBlcWkgPSBfcmVmMlswXSwgZXFqID0gX3JlZjJbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3J1bmNoZXIuc2V0U2VxMShhaSk7XG4gICAgICAgICAgaWYgKGNydW5jaGVyLnJlYWxRdWlja1JhdGlvKCkgPiBiZXN0UmF0aW8gJiYgY3J1bmNoZXIucXVpY2tSYXRpbygpID4gYmVzdFJhdGlvICYmIGNydW5jaGVyLnJhdGlvKCkgPiBiZXN0UmF0aW8pIHtcbiAgICAgICAgICAgIF9yZWYzID0gW2NydW5jaGVyLnJhdGlvKCksIGksIGpdLCBiZXN0UmF0aW8gPSBfcmVmM1swXSwgYmVzdGkgPSBfcmVmM1sxXSwgYmVzdGogPSBfcmVmM1syXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChiZXN0UmF0aW8gPCBjdXRvZmYpIHtcbiAgICAgICAgaWYgKGVxaSA9PT0gbnVsbCkge1xuICAgICAgICAgIF9yZWY0ID0gdGhpcy5fcGxhaW5SZXBsYWNlKGEsIGFsbywgYWhpLCBiLCBibG8sIGJoaSk7XG4gICAgICAgICAgZm9yIChfayA9IDAsIF9sZW4gPSBfcmVmNC5sZW5ndGg7IF9rIDwgX2xlbjsgX2srKykge1xuICAgICAgICAgICAgbGluZSA9IF9yZWY0W19rXTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsaW5lcztcbiAgICAgICAgfVxuICAgICAgICBfcmVmNSA9IFtlcWksIGVxaiwgMS4wXSwgYmVzdGkgPSBfcmVmNVswXSwgYmVzdGogPSBfcmVmNVsxXSwgYmVzdFJhdGlvID0gX3JlZjVbMl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcWkgPSBudWxsO1xuICAgICAgfVxuICAgICAgX3JlZjYgPSB0aGlzLl9mYW5jeUhlbHBlcihhLCBhbG8sIGJlc3RpLCBiLCBibG8sIGJlc3RqKTtcbiAgICAgIGZvciAoX2wgPSAwLCBfbGVuMSA9IF9yZWY2Lmxlbmd0aDsgX2wgPCBfbGVuMTsgX2wrKykge1xuICAgICAgICBsaW5lID0gX3JlZjZbX2xdO1xuICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgfVxuICAgICAgX3JlZjcgPSBbYVtiZXN0aV0sIGJbYmVzdGpdXSwgYWVsdCA9IF9yZWY3WzBdLCBiZWx0ID0gX3JlZjdbMV07XG4gICAgICBpZiAoZXFpID09PSBudWxsKSB7XG4gICAgICAgIGF0YWdzID0gYnRhZ3MgPSAnJztcbiAgICAgICAgY3J1bmNoZXIuc2V0U2VxcyhhZWx0LCBiZWx0KTtcbiAgICAgICAgX3JlZjggPSBjcnVuY2hlci5nZXRPcGNvZGVzKCk7XG4gICAgICAgIGZvciAoX20gPSAwLCBfbGVuMiA9IF9yZWY4Lmxlbmd0aDsgX20gPCBfbGVuMjsgX20rKykge1xuICAgICAgICAgIF9yZWY5ID0gX3JlZjhbX21dLCB0YWcgPSBfcmVmOVswXSwgYWkxID0gX3JlZjlbMV0sIGFpMiA9IF9yZWY5WzJdLCBiajEgPSBfcmVmOVszXSwgYmoyID0gX3JlZjlbNF07XG4gICAgICAgICAgX3JlZjEwID0gW2FpMiAtIGFpMSwgYmoyIC0gYmoxXSwgbGEgPSBfcmVmMTBbMF0sIGxiID0gX3JlZjEwWzFdO1xuICAgICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgICAgICBjYXNlICdyZXBsYWNlJzpcbiAgICAgICAgICAgICAgYXRhZ3MgKz0gQXJyYXkobGEgKyAxKS5qb2luKCdeJyk7XG4gICAgICAgICAgICAgIGJ0YWdzICs9IEFycmF5KGxiICsgMSkuam9pbignXicpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICAgICAgICAgIGF0YWdzICs9IEFycmF5KGxhICsgMSkuam9pbignLScpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2VydCc6XG4gICAgICAgICAgICAgIGJ0YWdzICs9IEFycmF5KGxiICsgMSkuam9pbignKycpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2VxdWFsJzpcbiAgICAgICAgICAgICAgYXRhZ3MgKz0gQXJyYXkobGEgKyAxKS5qb2luKCcgJyk7XG4gICAgICAgICAgICAgIGJ0YWdzICs9IEFycmF5KGxiICsgMSkuam9pbignICcpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vdyB0YWcgKFwiICsgdGFnICsgXCIpXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfcmVmMTEgPSB0aGlzLl9xZm9ybWF0KGFlbHQsIGJlbHQsIGF0YWdzLCBidGFncyk7XG4gICAgICAgIGZvciAoX24gPSAwLCBfbGVuMyA9IF9yZWYxMS5sZW5ndGg7IF9uIDwgX2xlbjM7IF9uKyspIHtcbiAgICAgICAgICBsaW5lID0gX3JlZjExW19uXTtcbiAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lcy5wdXNoKCcgICcgKyBhZWx0KTtcbiAgICAgIH1cbiAgICAgIF9yZWYxMiA9IHRoaXMuX2ZhbmN5SGVscGVyKGEsIGJlc3RpICsgMSwgYWhpLCBiLCBiZXN0aiArIDEsIGJoaSk7XG4gICAgICBmb3IgKF9vID0gMCwgX2xlbjQgPSBfcmVmMTIubGVuZ3RoOyBfbyA8IF9sZW40OyBfbysrKSB7XG4gICAgICAgIGxpbmUgPSBfcmVmMTJbX29dO1xuICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH07XG5cbiAgICBEaWZmZXIucHJvdG90eXBlLl9mYW5jeUhlbHBlciA9IGZ1bmN0aW9uKGEsIGFsbywgYWhpLCBiLCBibG8sIGJoaSkge1xuICAgICAgdmFyIGc7XG4gICAgICBnID0gW107XG4gICAgICBpZiAoYWxvIDwgYWhpKSB7XG4gICAgICAgIGlmIChibG8gPCBiaGkpIHtcbiAgICAgICAgICBnID0gdGhpcy5fZmFuY3lSZXBsYWNlKGEsIGFsbywgYWhpLCBiLCBibG8sIGJoaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZyA9IHRoaXMuX2R1bXAoJy0nLCBhLCBhbG8sIGFoaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYmxvIDwgYmhpKSB7XG4gICAgICAgIGcgPSB0aGlzLl9kdW1wKCcrJywgYiwgYmxvLCBiaGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGc7XG4gICAgfTtcblxuICAgIERpZmZlci5wcm90b3R5cGUuX3Fmb3JtYXQgPSBmdW5jdGlvbihhbGluZSwgYmxpbmUsIGF0YWdzLCBidGFncykge1xuICAgICAgLypcbiAgICAgICAgICBGb3JtYXQgXCI/XCIgb3V0cHV0IGFuZCBkZWFsIHdpdGggbGVhZGluZyB0YWJzLlxuICAgICAgXG4gICAgICAgICAgRXhhbXBsZTpcbiAgICAgIFxuICAgICAgICAgID4+PiBkID0gbmV3IERpZmZlclxuICAgICAgICAgID4+PiBkLl9xZm9ybWF0KCdcXHRhYmNEZWZnaGlKa2xcXG4nLCAnXFx0YWJjZGVmR2hpamtsXFxuJyxcbiAgICAgICAgICBbICctIFxcdGFiY0RlZmdoaUprbFxcbicsXG4gICAgICAgICAgICAnPyBcXHQgXiBeICBeXFxuJyxcbiAgICAgICAgICAgICcrIFxcdGFiY2RlZkdoaWprbFxcbicsXG4gICAgICAgICAgICAnPyBcXHQgXiBeICBeXFxuJyBdXG4gICAgICAqL1xuXG4gICAgICB2YXIgY29tbW9uLCBsaW5lcztcbiAgICAgIGxpbmVzID0gW107XG4gICAgICBjb21tb24gPSBtaW4oX2NvdW50TGVhZGluZyhhbGluZSwgJ1xcdCcpLCBfY291bnRMZWFkaW5nKGJsaW5lLCAnXFx0JykpO1xuICAgICAgY29tbW9uID0gbWluKGNvbW1vbiwgX2NvdW50TGVhZGluZyhhdGFncy5zbGljZSgwLCBjb21tb24pLCAnICcpKTtcbiAgICAgIGNvbW1vbiA9IG1pbihjb21tb24sIF9jb3VudExlYWRpbmcoYnRhZ3Muc2xpY2UoMCwgY29tbW9uKSwgJyAnKSk7XG4gICAgICBhdGFncyA9IGF0YWdzLnNsaWNlKGNvbW1vbikucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICBidGFncyA9IGJ0YWdzLnNsaWNlKGNvbW1vbikucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICBsaW5lcy5wdXNoKCctICcgKyBhbGluZSk7XG4gICAgICBpZiAoYXRhZ3MubGVuZ3RoKSB7XG4gICAgICAgIGxpbmVzLnB1c2goXCI/IFwiICsgKEFycmF5KGNvbW1vbiArIDEpLmpvaW4oJ1xcdCcpKSArIGF0YWdzICsgXCJcXG5cIik7XG4gICAgICB9XG4gICAgICBsaW5lcy5wdXNoKCcrICcgKyBibGluZSk7XG4gICAgICBpZiAoYnRhZ3MubGVuZ3RoKSB7XG4gICAgICAgIGxpbmVzLnB1c2goXCI/IFwiICsgKEFycmF5KGNvbW1vbiArIDEpLmpvaW4oJ1xcdCcpKSArIGJ0YWdzICsgXCJcXG5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZXM7XG4gICAgfTtcblxuICAgIHJldHVybiBEaWZmZXI7XG5cbiAgfSkoKTtcblxuICBJU19MSU5FX0pVTksgPSBmdW5jdGlvbihsaW5lLCBwYXQpIHtcbiAgICBpZiAocGF0ID09IG51bGwpIHtcbiAgICAgIHBhdCA9IC9eXFxzKiM/XFxzKiQvO1xuICAgIH1cbiAgICAvKlxuICAgICAgUmV0dXJuIDEgZm9yIGlnbm9yYWJsZSBsaW5lOiBpZmYgYGxpbmVgIGlzIGJsYW5rIG9yIGNvbnRhaW5zIGEgc2luZ2xlICcjJy5cbiAgICAgICAgXG4gICAgICBFeGFtcGxlczpcbiAgICBcbiAgICAgID4+PiBJU19MSU5FX0pVTksoJ1xcbicpXG4gICAgICB0cnVlXG4gICAgICA+Pj4gSVNfTElORV9KVU5LKCcgICMgICBcXG4nKVxuICAgICAgdHJ1ZVxuICAgICAgPj4+IElTX0xJTkVfSlVOSygnaGVsbG9cXG4nKVxuICAgICAgZmFsc2VcbiAgICAqL1xuXG4gICAgcmV0dXJuIHBhdC50ZXN0KGxpbmUpO1xuICB9O1xuXG4gIElTX0NIQVJBQ1RFUl9KVU5LID0gZnVuY3Rpb24oY2gsIHdzKSB7XG4gICAgaWYgKHdzID09IG51bGwpIHtcbiAgICAgIHdzID0gJyBcXHQnO1xuICAgIH1cbiAgICAvKlxuICAgICAgUmV0dXJuIDEgZm9yIGlnbm9yYWJsZSBjaGFyYWN0ZXI6IGlmZiBgY2hgIGlzIGEgc3BhY2Ugb3IgdGFiLlxuICAgIFxuICAgICAgRXhhbXBsZXM6XG4gICAgICA+Pj4gSVNfQ0hBUkFDVEVSX0pVTksoJyAnKS5zaG91bGQuYmUudHJ1ZVxuICAgICAgdHJ1ZVxuICAgICAgPj4+IElTX0NIQVJBQ1RFUl9KVU5LKCdcXHQnKS5zaG91bGQuYmUudHJ1ZVxuICAgICAgdHJ1ZVxuICAgICAgPj4+IElTX0NIQVJBQ1RFUl9KVU5LKCdcXG4nKS5zaG91bGQuYmUuZmFsc2VcbiAgICAgIGZhbHNlXG4gICAgICA+Pj4gSVNfQ0hBUkFDVEVSX0pVTksoJ3gnKS5zaG91bGQuYmUuZmFsc2VcbiAgICAgIGZhbHNlXG4gICAgKi9cblxuICAgIHJldHVybiBfX2luZGV4T2YuY2FsbCh3cywgY2gpID49IDA7XG4gIH07XG5cbiAgX2Zvcm1hdFJhbmdlVW5pZmllZCA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wKSB7XG4gICAgLypcbiAgICAgIENvbnZlcnQgcmFuZ2UgdG8gdGhlIFwiZWRcIiBmb3JtYXQnXG4gICAgKi9cblxuICAgIHZhciBiZWdpbm5pbmcsIGxlbmd0aDtcbiAgICBiZWdpbm5pbmcgPSBzdGFydCArIDE7XG4gICAgbGVuZ3RoID0gc3RvcCAtIHN0YXJ0O1xuICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBcIlwiICsgYmVnaW5uaW5nO1xuICAgIH1cbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgYmVnaW5uaW5nLS07XG4gICAgfVxuICAgIHJldHVybiBcIlwiICsgYmVnaW5uaW5nICsgXCIsXCIgKyBsZW5ndGg7XG4gIH07XG5cbiAgdW5pZmllZERpZmYgPSBmdW5jdGlvbihhLCBiLCBfYXJnKSB7XG4gICAgdmFyIGZpbGUxUmFuZ2UsIGZpbGUyUmFuZ2UsIGZpcnN0LCBmcm9tZGF0ZSwgZnJvbWZpbGUsIGZyb21maWxlZGF0ZSwgZ3JvdXAsIGkxLCBpMiwgajEsIGoyLCBsYXN0LCBsaW5lLCBsaW5lcywgbGluZXRlcm0sIG4sIHN0YXJ0ZWQsIHRhZywgdG9kYXRlLCB0b2ZpbGUsIHRvZmlsZWRhdGUsIF9pLCBfaiwgX2ssIF9sLCBfbGVuLCBfbGVuMSwgX2xlbjIsIF9sZW4zLCBfbGVuNCwgX20sIF9yZWYsIF9yZWYxLCBfcmVmMiwgX3JlZjMsIF9yZWY0LCBfcmVmNSwgX3JlZjY7XG4gICAgX3JlZiA9IF9hcmcgIT0gbnVsbCA/IF9hcmcgOiB7fSwgZnJvbWZpbGUgPSBfcmVmLmZyb21maWxlLCB0b2ZpbGUgPSBfcmVmLnRvZmlsZSwgZnJvbWZpbGVkYXRlID0gX3JlZi5mcm9tZmlsZWRhdGUsIHRvZmlsZWRhdGUgPSBfcmVmLnRvZmlsZWRhdGUsIG4gPSBfcmVmLm4sIGxpbmV0ZXJtID0gX3JlZi5saW5ldGVybTtcbiAgICAvKlxuICAgICAgQ29tcGFyZSB0d28gc2VxdWVuY2VzIG9mIGxpbmVzOyBnZW5lcmF0ZSB0aGUgZGVsdGEgYXMgYSB1bmlmaWVkIGRpZmYuXG4gICAgXG4gICAgICBVbmlmaWVkIGRpZmZzIGFyZSBhIGNvbXBhY3Qgd2F5IG9mIHNob3dpbmcgbGluZSBjaGFuZ2VzIGFuZCBhIGZld1xuICAgICAgbGluZXMgb2YgY29udGV4dC4gIFRoZSBudW1iZXIgb2YgY29udGV4dCBsaW5lcyBpcyBzZXQgYnkgJ24nIHdoaWNoXG4gICAgICBkZWZhdWx0cyB0byB0aHJlZS5cbiAgICBcbiAgICAgIEJ5IGRlZmF1bHQsIHRoZSBkaWZmIGNvbnRyb2wgbGluZXMgKHRob3NlIHdpdGggLS0tLCArKyssIG9yIEBAKSBhcmVcbiAgICAgIGNyZWF0ZWQgd2l0aCBhIHRyYWlsaW5nIG5ld2xpbmUuICBcbiAgICBcbiAgICAgIEZvciBpbnB1dHMgdGhhdCBkbyBub3QgaGF2ZSB0cmFpbGluZyBuZXdsaW5lcywgc2V0IHRoZSBsaW5ldGVybVxuICAgICAgYXJndW1lbnQgdG8gXCJcIiBzbyB0aGF0IHRoZSBvdXRwdXQgd2lsbCBiZSB1bmlmb3JtbHkgbmV3bGluZSBmcmVlLlxuICAgIFxuICAgICAgVGhlIHVuaWRpZmYgZm9ybWF0IG5vcm1hbGx5IGhhcyBhIGhlYWRlciBmb3IgZmlsZW5hbWVzIGFuZCBtb2RpZmljYXRpb25cbiAgICAgIHRpbWVzLiAgQW55IG9yIGFsbCBvZiB0aGVzZSBtYXkgYmUgc3BlY2lmaWVkIHVzaW5nIHN0cmluZ3MgZm9yXG4gICAgICAnZnJvbWZpbGUnLCAndG9maWxlJywgJ2Zyb21maWxlZGF0ZScsIGFuZCAndG9maWxlZGF0ZScuXG4gICAgICBUaGUgbW9kaWZpY2F0aW9uIHRpbWVzIGFyZSBub3JtYWxseSBleHByZXNzZWQgaW4gdGhlIElTTyA4NjAxIGZvcm1hdC5cbiAgICBcbiAgICAgIEV4YW1wbGU6XG4gICAgXG4gICAgICA+Pj4gdW5pZmllZERpZmYoJ29uZSB0d28gdGhyZWUgZm91cicuc3BsaXQoJyAnKSxcbiAgICAgIC4uLiAgICAgICAgICAgICAnemVybyBvbmUgdHJlZSBmb3VyJy5zcGxpdCgnICcpLCB7XG4gICAgICAuLi4gICAgICAgICAgICAgICBmcm9tZmlsZTogJ09yaWdpbmFsJ1xuICAgICAgLi4uICAgICAgICAgICAgICAgdG9maWxlOiAnQ3VycmVudCcsXG4gICAgICAuLi4gICAgICAgICAgICAgICBmcm9tZmlsZWRhdGU6ICcyMDA1LTAxLTI2IDIzOjMwOjUwJyxcbiAgICAgIC4uLiAgICAgICAgICAgICAgIHRvZmlsZWRhdGU6ICcyMDEwLTA0LTAyIDEwOjIwOjUyJyxcbiAgICAgIC4uLiAgICAgICAgICAgICAgIGxpbmV0ZXJtOiAnJ1xuICAgICAgLi4uICAgICAgICAgICAgIH0pXG4gICAgICBbICctLS0gT3JpZ2luYWxcXHQyMDA1LTAxLTI2IDIzOjMwOjUwJyxcbiAgICAgICAgJysrKyBDdXJyZW50XFx0MjAxMC0wNC0wMiAxMDoyMDo1MicsXG4gICAgICAgICdAQCAtMSw0ICsxLDQgQEAnLFxuICAgICAgICAnK3plcm8nLFxuICAgICAgICAnIG9uZScsXG4gICAgICAgICctdHdvJyxcbiAgICAgICAgJy10aHJlZScsXG4gICAgICAgICcrdHJlZScsXG4gICAgICAgICcgZm91cicgXVxuICAgICovXG5cbiAgICBpZiAoZnJvbWZpbGUgPT0gbnVsbCkge1xuICAgICAgZnJvbWZpbGUgPSAnJztcbiAgICB9XG4gICAgaWYgKHRvZmlsZSA9PSBudWxsKSB7XG4gICAgICB0b2ZpbGUgPSAnJztcbiAgICB9XG4gICAgaWYgKGZyb21maWxlZGF0ZSA9PSBudWxsKSB7XG4gICAgICBmcm9tZmlsZWRhdGUgPSAnJztcbiAgICB9XG4gICAgaWYgKHRvZmlsZWRhdGUgPT0gbnVsbCkge1xuICAgICAgdG9maWxlZGF0ZSA9ICcnO1xuICAgIH1cbiAgICBpZiAobiA9PSBudWxsKSB7XG4gICAgICBuID0gMztcbiAgICB9XG4gICAgaWYgKGxpbmV0ZXJtID09IG51bGwpIHtcbiAgICAgIGxpbmV0ZXJtID0gJ1xcbic7XG4gICAgfVxuICAgIGxpbmVzID0gW107XG4gICAgc3RhcnRlZCA9IGZhbHNlO1xuICAgIF9yZWYxID0gKG5ldyBTZXF1ZW5jZU1hdGNoZXIobnVsbCwgYSwgYikpLmdldEdyb3VwZWRPcGNvZGVzKCk7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgZ3JvdXAgPSBfcmVmMVtfaV07XG4gICAgICBpZiAoIXN0YXJ0ZWQpIHtcbiAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIGZyb21kYXRlID0gZnJvbWZpbGVkYXRlID8gXCJcXHRcIiArIGZyb21maWxlZGF0ZSA6ICcnO1xuICAgICAgICB0b2RhdGUgPSB0b2ZpbGVkYXRlID8gXCJcXHRcIiArIHRvZmlsZWRhdGUgOiAnJztcbiAgICAgICAgbGluZXMucHVzaChcIi0tLSBcIiArIGZyb21maWxlICsgZnJvbWRhdGUgKyBsaW5ldGVybSk7XG4gICAgICAgIGxpbmVzLnB1c2goXCIrKysgXCIgKyB0b2ZpbGUgKyB0b2RhdGUgKyBsaW5ldGVybSk7XG4gICAgICB9XG4gICAgICBfcmVmMiA9IFtncm91cFswXSwgZ3JvdXBbZ3JvdXAubGVuZ3RoIC0gMV1dLCBmaXJzdCA9IF9yZWYyWzBdLCBsYXN0ID0gX3JlZjJbMV07XG4gICAgICBmaWxlMVJhbmdlID0gX2Zvcm1hdFJhbmdlVW5pZmllZChmaXJzdFsxXSwgbGFzdFsyXSk7XG4gICAgICBmaWxlMlJhbmdlID0gX2Zvcm1hdFJhbmdlVW5pZmllZChmaXJzdFszXSwgbGFzdFs0XSk7XG4gICAgICBsaW5lcy5wdXNoKFwiQEAgLVwiICsgZmlsZTFSYW5nZSArIFwiICtcIiArIGZpbGUyUmFuZ2UgKyBcIiBAQFwiICsgbGluZXRlcm0pO1xuICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gZ3JvdXAubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgIF9yZWYzID0gZ3JvdXBbX2pdLCB0YWcgPSBfcmVmM1swXSwgaTEgPSBfcmVmM1sxXSwgaTIgPSBfcmVmM1syXSwgajEgPSBfcmVmM1szXSwgajIgPSBfcmVmM1s0XTtcbiAgICAgICAgaWYgKHRhZyA9PT0gJ2VxdWFsJykge1xuICAgICAgICAgIF9yZWY0ID0gYS5zbGljZShpMSwgaTIpO1xuICAgICAgICAgIGZvciAoX2sgPSAwLCBfbGVuMiA9IF9yZWY0Lmxlbmd0aDsgX2sgPCBfbGVuMjsgX2srKykge1xuICAgICAgICAgICAgbGluZSA9IF9yZWY0W19rXTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goJyAnICsgbGluZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT09ICdyZXBsYWNlJyB8fCB0YWcgPT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgX3JlZjUgPSBhLnNsaWNlKGkxLCBpMik7XG4gICAgICAgICAgZm9yIChfbCA9IDAsIF9sZW4zID0gX3JlZjUubGVuZ3RoOyBfbCA8IF9sZW4zOyBfbCsrKSB7XG4gICAgICAgICAgICBsaW5lID0gX3JlZjVbX2xdO1xuICAgICAgICAgICAgbGluZXMucHVzaCgnLScgKyBsaW5lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PT0gJ3JlcGxhY2UnIHx8IHRhZyA9PT0gJ2luc2VydCcpIHtcbiAgICAgICAgICBfcmVmNiA9IGIuc2xpY2UoajEsIGoyKTtcbiAgICAgICAgICBmb3IgKF9tID0gMCwgX2xlbjQgPSBfcmVmNi5sZW5ndGg7IF9tIDwgX2xlbjQ7IF9tKyspIHtcbiAgICAgICAgICAgIGxpbmUgPSBfcmVmNltfbV07XG4gICAgICAgICAgICBsaW5lcy5wdXNoKCcrJyArIGxpbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGluZXM7XG4gIH07XG5cbiAgX2Zvcm1hdFJhbmdlQ29udGV4dCA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wKSB7XG4gICAgLypcbiAgICAgIENvbnZlcnQgcmFuZ2UgdG8gdGhlIFwiZWRcIiBmb3JtYXQnXG4gICAgKi9cblxuICAgIHZhciBiZWdpbm5pbmcsIGxlbmd0aDtcbiAgICBiZWdpbm5pbmcgPSBzdGFydCArIDE7XG4gICAgbGVuZ3RoID0gc3RvcCAtIHN0YXJ0O1xuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICBiZWdpbm5pbmctLTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8PSAxKSB7XG4gICAgICByZXR1cm4gXCJcIiArIGJlZ2lubmluZztcbiAgICB9XG4gICAgcmV0dXJuIFwiXCIgKyBiZWdpbm5pbmcgKyBcIixcIiArIChiZWdpbm5pbmcgKyBsZW5ndGggLSAxKTtcbiAgfTtcblxuICBjb250ZXh0RGlmZiA9IGZ1bmN0aW9uKGEsIGIsIF9hcmcpIHtcbiAgICB2YXIgZmlsZTFSYW5nZSwgZmlsZTJSYW5nZSwgZmlyc3QsIGZyb21kYXRlLCBmcm9tZmlsZSwgZnJvbWZpbGVkYXRlLCBncm91cCwgaTEsIGkyLCBqMSwgajIsIGxhc3QsIGxpbmUsIGxpbmVzLCBsaW5ldGVybSwgbiwgcHJlZml4LCBzdGFydGVkLCB0YWcsIHRvZGF0ZSwgdG9maWxlLCB0b2ZpbGVkYXRlLCBfLCBfaSwgX2osIF9rLCBfbCwgX2xlbiwgX2xlbjEsIF9sZW4yLCBfbGVuMywgX2xlbjQsIF9tLCBfcmVmLCBfcmVmMSwgX3JlZjIsIF9yZWYzLCBfcmVmNCwgX3JlZjUsIF9yZWY2O1xuICAgIF9yZWYgPSBfYXJnICE9IG51bGwgPyBfYXJnIDoge30sIGZyb21maWxlID0gX3JlZi5mcm9tZmlsZSwgdG9maWxlID0gX3JlZi50b2ZpbGUsIGZyb21maWxlZGF0ZSA9IF9yZWYuZnJvbWZpbGVkYXRlLCB0b2ZpbGVkYXRlID0gX3JlZi50b2ZpbGVkYXRlLCBuID0gX3JlZi5uLCBsaW5ldGVybSA9IF9yZWYubGluZXRlcm07XG4gICAgLypcbiAgICAgIENvbXBhcmUgdHdvIHNlcXVlbmNlcyBvZiBsaW5lczsgZ2VuZXJhdGUgdGhlIGRlbHRhIGFzIGEgY29udGV4dCBkaWZmLlxuICAgIFxuICAgICAgQ29udGV4dCBkaWZmcyBhcmUgYSBjb21wYWN0IHdheSBvZiBzaG93aW5nIGxpbmUgY2hhbmdlcyBhbmQgYSBmZXdcbiAgICAgIGxpbmVzIG9mIGNvbnRleHQuICBUaGUgbnVtYmVyIG9mIGNvbnRleHQgbGluZXMgaXMgc2V0IGJ5ICduJyB3aGljaFxuICAgICAgZGVmYXVsdHMgdG8gdGhyZWUuXG4gICAgXG4gICAgICBCeSBkZWZhdWx0LCB0aGUgZGlmZiBjb250cm9sIGxpbmVzICh0aG9zZSB3aXRoICoqKiBvciAtLS0pIGFyZVxuICAgICAgY3JlYXRlZCB3aXRoIGEgdHJhaWxpbmcgbmV3bGluZS4gIFRoaXMgaXMgaGVscGZ1bCBzbyB0aGF0IGlucHV0c1xuICAgICAgY3JlYXRlZCBmcm9tIGZpbGUucmVhZGxpbmVzKCkgcmVzdWx0IGluIGRpZmZzIHRoYXQgYXJlIHN1aXRhYmxlIGZvclxuICAgICAgZmlsZS53cml0ZWxpbmVzKCkgc2luY2UgYm90aCB0aGUgaW5wdXRzIGFuZCBvdXRwdXRzIGhhdmUgdHJhaWxpbmdcbiAgICAgIG5ld2xpbmVzLlxuICAgIFxuICAgICAgRm9yIGlucHV0cyB0aGF0IGRvIG5vdCBoYXZlIHRyYWlsaW5nIG5ld2xpbmVzLCBzZXQgdGhlIGxpbmV0ZXJtXG4gICAgICBhcmd1bWVudCB0byBcIlwiIHNvIHRoYXQgdGhlIG91dHB1dCB3aWxsIGJlIHVuaWZvcm1seSBuZXdsaW5lIGZyZWUuXG4gICAgXG4gICAgICBUaGUgY29udGV4dCBkaWZmIGZvcm1hdCBub3JtYWxseSBoYXMgYSBoZWFkZXIgZm9yIGZpbGVuYW1lcyBhbmRcbiAgICAgIG1vZGlmaWNhdGlvbiB0aW1lcy4gIEFueSBvciBhbGwgb2YgdGhlc2UgbWF5IGJlIHNwZWNpZmllZCB1c2luZ1xuICAgICAgc3RyaW5ncyBmb3IgJ2Zyb21maWxlJywgJ3RvZmlsZScsICdmcm9tZmlsZWRhdGUnLCBhbmQgJ3RvZmlsZWRhdGUnLlxuICAgICAgVGhlIG1vZGlmaWNhdGlvbiB0aW1lcyBhcmUgbm9ybWFsbHkgZXhwcmVzc2VkIGluIHRoZSBJU08gODYwMSBmb3JtYXQuXG4gICAgICBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgc3RyaW5ncyBkZWZhdWx0IHRvIGJsYW5rcy5cbiAgICBcbiAgICAgIEV4YW1wbGU6XG4gICAgICA+Pj4gYSA9IFsnb25lXFxuJywgJ3R3b1xcbicsICd0aHJlZVxcbicsICdmb3VyXFxuJ11cbiAgICAgID4+PiBiID0gWyd6ZXJvXFxuJywgJ29uZVxcbicsICd0cmVlXFxuJywgJ2ZvdXJcXG4nXVxuICAgICAgPj4+IGNvbnRleHREaWZmKGEsIGIsIHtmcm9tZmlsZTogJ09yaWdpbmFsJywgdG9maWxlOiAnQ3VycmVudCd9KVxuICAgICAgWyAnKioqIE9yaWdpbmFsXFxuJyxcbiAgICAgICAgJy0tLSBDdXJyZW50XFxuJyxcbiAgICAgICAgJyoqKioqKioqKioqKioqKlxcbicsXG4gICAgICAgICcqKiogMSw0ICoqKipcXG4nLFxuICAgICAgICAnICBvbmVcXG4nLFxuICAgICAgICAnISB0d29cXG4nLFxuICAgICAgICAnISB0aHJlZVxcbicsXG4gICAgICAgICcgIGZvdXJcXG4nLFxuICAgICAgICAnLS0tIDEsNCAtLS0tXFxuJyxcbiAgICAgICAgJysgemVyb1xcbicsXG4gICAgICAgICcgIG9uZVxcbicsXG4gICAgICAgICchIHRyZWVcXG4nLFxuICAgICAgICAnICBmb3VyXFxuJyBdXG4gICAgKi9cblxuICAgIGlmIChmcm9tZmlsZSA9PSBudWxsKSB7XG4gICAgICBmcm9tZmlsZSA9ICcnO1xuICAgIH1cbiAgICBpZiAodG9maWxlID09IG51bGwpIHtcbiAgICAgIHRvZmlsZSA9ICcnO1xuICAgIH1cbiAgICBpZiAoZnJvbWZpbGVkYXRlID09IG51bGwpIHtcbiAgICAgIGZyb21maWxlZGF0ZSA9ICcnO1xuICAgIH1cbiAgICBpZiAodG9maWxlZGF0ZSA9PSBudWxsKSB7XG4gICAgICB0b2ZpbGVkYXRlID0gJyc7XG4gICAgfVxuICAgIGlmIChuID09IG51bGwpIHtcbiAgICAgIG4gPSAzO1xuICAgIH1cbiAgICBpZiAobGluZXRlcm0gPT0gbnVsbCkge1xuICAgICAgbGluZXRlcm0gPSAnXFxuJztcbiAgICB9XG4gICAgcHJlZml4ID0ge1xuICAgICAgaW5zZXJ0OiAnKyAnLFxuICAgICAgXCJkZWxldGVcIjogJy0gJyxcbiAgICAgIHJlcGxhY2U6ICchICcsXG4gICAgICBlcXVhbDogJyAgJ1xuICAgIH07XG4gICAgc3RhcnRlZCA9IGZhbHNlO1xuICAgIGxpbmVzID0gW107XG4gICAgX3JlZjEgPSAobmV3IFNlcXVlbmNlTWF0Y2hlcihudWxsLCBhLCBiKSkuZ2V0R3JvdXBlZE9wY29kZXMoKTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBncm91cCA9IF9yZWYxW19pXTtcbiAgICAgIGlmICghc3RhcnRlZCkge1xuICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgZnJvbWRhdGUgPSBmcm9tZmlsZWRhdGUgPyBcIlxcdFwiICsgZnJvbWZpbGVkYXRlIDogJyc7XG4gICAgICAgIHRvZGF0ZSA9IHRvZmlsZWRhdGUgPyBcIlxcdFwiICsgdG9maWxlZGF0ZSA6ICcnO1xuICAgICAgICBsaW5lcy5wdXNoKFwiKioqIFwiICsgZnJvbWZpbGUgKyBmcm9tZGF0ZSArIGxpbmV0ZXJtKTtcbiAgICAgICAgbGluZXMucHVzaChcIi0tLSBcIiArIHRvZmlsZSArIHRvZGF0ZSArIGxpbmV0ZXJtKTtcbiAgICAgICAgX3JlZjIgPSBbZ3JvdXBbMF0sIGdyb3VwW2dyb3VwLmxlbmd0aCAtIDFdXSwgZmlyc3QgPSBfcmVmMlswXSwgbGFzdCA9IF9yZWYyWzFdO1xuICAgICAgICBsaW5lcy5wdXNoKCcqKioqKioqKioqKioqKionICsgbGluZXRlcm0pO1xuICAgICAgICBmaWxlMVJhbmdlID0gX2Zvcm1hdFJhbmdlQ29udGV4dChmaXJzdFsxXSwgbGFzdFsyXSk7XG4gICAgICAgIGxpbmVzLnB1c2goXCIqKiogXCIgKyBmaWxlMVJhbmdlICsgXCIgKioqKlwiICsgbGluZXRlcm0pO1xuICAgICAgICBpZiAoX2FueSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9qLCBfbGVuMSwgX3JlZjMsIF9yZXN1bHRzO1xuICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gZ3JvdXAubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgICBfcmVmMyA9IGdyb3VwW19qXSwgdGFnID0gX3JlZjNbMF0sIF8gPSBfcmVmM1sxXSwgXyA9IF9yZWYzWzJdLCBfID0gX3JlZjNbM10sIF8gPSBfcmVmM1s0XTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godGFnID09PSAncmVwbGFjZScgfHwgdGFnID09PSAnZGVsZXRlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgfSkoKSkpIHtcbiAgICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBncm91cC5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICAgIF9yZWYzID0gZ3JvdXBbX2pdLCB0YWcgPSBfcmVmM1swXSwgaTEgPSBfcmVmM1sxXSwgaTIgPSBfcmVmM1syXSwgXyA9IF9yZWYzWzNdLCBfID0gX3JlZjNbNF07XG4gICAgICAgICAgICBpZiAodGFnICE9PSAnaW5zZXJ0Jykge1xuICAgICAgICAgICAgICBfcmVmNCA9IGEuc2xpY2UoaTEsIGkyKTtcbiAgICAgICAgICAgICAgZm9yIChfayA9IDAsIF9sZW4yID0gX3JlZjQubGVuZ3RoOyBfayA8IF9sZW4yOyBfaysrKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IF9yZWY0W19rXTtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHByZWZpeFt0YWddICsgbGluZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmlsZTJSYW5nZSA9IF9mb3JtYXRSYW5nZUNvbnRleHQoZmlyc3RbM10sIGxhc3RbNF0pO1xuICAgICAgICBsaW5lcy5wdXNoKFwiLS0tIFwiICsgZmlsZTJSYW5nZSArIFwiIC0tLS1cIiArIGxpbmV0ZXJtKTtcbiAgICAgICAgaWYgKF9hbnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfbCwgX2xlbjMsIF9yZWY1LCBfcmVzdWx0cztcbiAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoX2wgPSAwLCBfbGVuMyA9IGdyb3VwLmxlbmd0aDsgX2wgPCBfbGVuMzsgX2wrKykge1xuICAgICAgICAgICAgX3JlZjUgPSBncm91cFtfbF0sIHRhZyA9IF9yZWY1WzBdLCBfID0gX3JlZjVbMV0sIF8gPSBfcmVmNVsyXSwgXyA9IF9yZWY1WzNdLCBfID0gX3JlZjVbNF07XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHRhZyA9PT0gJ3JlcGxhY2UnIHx8IHRhZyA9PT0gJ2luc2VydCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH0pKCkpKSB7XG4gICAgICAgICAgZm9yIChfbCA9IDAsIF9sZW4zID0gZ3JvdXAubGVuZ3RoOyBfbCA8IF9sZW4zOyBfbCsrKSB7XG4gICAgICAgICAgICBfcmVmNSA9IGdyb3VwW19sXSwgdGFnID0gX3JlZjVbMF0sIF8gPSBfcmVmNVsxXSwgXyA9IF9yZWY1WzJdLCBqMSA9IF9yZWY1WzNdLCBqMiA9IF9yZWY1WzRdO1xuICAgICAgICAgICAgaWYgKHRhZyAhPT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgICAgX3JlZjYgPSBiLnNsaWNlKGoxLCBqMik7XG4gICAgICAgICAgICAgIGZvciAoX20gPSAwLCBfbGVuNCA9IF9yZWY2Lmxlbmd0aDsgX20gPCBfbGVuNDsgX20rKykge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBfcmVmNltfbV07XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChwcmVmaXhbdGFnXSArIGxpbmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbiAgfTtcblxuICBuZGlmZiA9IGZ1bmN0aW9uKGEsIGIsIGxpbmVqdW5rLCBjaGFyanVuaykge1xuICAgIGlmIChjaGFyanVuayA9PSBudWxsKSB7XG4gICAgICBjaGFyanVuayA9IElTX0NIQVJBQ1RFUl9KVU5LO1xuICAgIH1cbiAgICAvKlxuICAgICAgQ29tcGFyZSBgYWAgYW5kIGBiYCAobGlzdHMgb2Ygc3RyaW5ncyk7IHJldHVybiBhIGBEaWZmZXJgLXN0eWxlIGRlbHRhLlxuICAgIFxuICAgICAgT3B0aW9uYWwga2V5d29yZCBwYXJhbWV0ZXJzIGBsaW5lanVua2AgYW5kIGBjaGFyanVua2AgYXJlIGZvciBmaWx0ZXJcbiAgICAgIGZ1bmN0aW9ucyAob3IgTm9uZSk6XG4gICAgXG4gICAgICAtIGxpbmVqdW5rOiBBIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGFjY2VwdCBhIHNpbmdsZSBzdHJpbmcgYXJndW1lbnQsIGFuZFxuICAgICAgICByZXR1cm4gdHJ1ZSBpZmYgdGhlIHN0cmluZyBpcyBqdW5rLiAgVGhlIGRlZmF1bHQgaXMgbnVsbCwgYW5kIGlzXG4gICAgICAgIHJlY29tbWVuZGVkOyBcbiAgICBcbiAgICAgIC0gY2hhcmp1bms6IEEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYWNjZXB0IGEgc3RyaW5nIG9mIGxlbmd0aCAxLiBUaGVcbiAgICAgICAgZGVmYXVsdCBpcyBtb2R1bGUtbGV2ZWwgZnVuY3Rpb24gSVNfQ0hBUkFDVEVSX0pVTkssIHdoaWNoIGZpbHRlcnMgb3V0XG4gICAgICAgIHdoaXRlc3BhY2UgY2hhcmFjdGVycyAoYSBibGFuayBvciB0YWI7IG5vdGU6IGJhZCBpZGVhIHRvIGluY2x1ZGUgbmV3bGluZVxuICAgICAgICBpbiB0aGlzISkuXG4gICAgXG4gICAgICBFeGFtcGxlOlxuICAgICAgPj4+IGEgPSBbJ29uZVxcbicsICd0d29cXG4nLCAndGhyZWVcXG4nXVxuICAgICAgPj4+IGIgPSBbJ29yZVxcbicsICd0cmVlXFxuJywgJ2VtdVxcbiddXG4gICAgICA+Pj4gbmRpZmYoYSwgYilcbiAgICAgIFsgJy0gb25lXFxuJyxcbiAgICAgICAgJz8gIF5cXG4nLFxuICAgICAgICAnKyBvcmVcXG4nLFxuICAgICAgICAnPyAgXlxcbicsXG4gICAgICAgICctIHR3b1xcbicsXG4gICAgICAgICctIHRocmVlXFxuJyxcbiAgICAgICAgJz8gIC1cXG4nLFxuICAgICAgICAnKyB0cmVlXFxuJyxcbiAgICAgICAgJysgZW11XFxuJyBdXG4gICAgKi9cblxuICAgIHJldHVybiAobmV3IERpZmZlcihsaW5lanVuaywgY2hhcmp1bmspKS5jb21wYXJlKGEsIGIpO1xuICB9O1xuXG4gIHJlc3RvcmUgPSBmdW5jdGlvbihkZWx0YSwgd2hpY2gpIHtcbiAgICAvKlxuICAgICAgR2VuZXJhdGUgb25lIG9mIHRoZSB0d28gc2VxdWVuY2VzIHRoYXQgZ2VuZXJhdGVkIGEgZGVsdGEuXG4gICAgXG4gICAgICBHaXZlbiBhIGBkZWx0YWAgcHJvZHVjZWQgYnkgYERpZmZlci5jb21wYXJlKClgIG9yIGBuZGlmZigpYCwgZXh0cmFjdFxuICAgICAgbGluZXMgb3JpZ2luYXRpbmcgZnJvbSBmaWxlIDEgb3IgMiAocGFyYW1ldGVyIGB3aGljaGApLCBzdHJpcHBpbmcgb2ZmIGxpbmVcbiAgICAgIHByZWZpeGVzLlxuICAgIFxuICAgICAgRXhhbXBsZXM6XG4gICAgICA+Pj4gYSA9IFsnb25lXFxuJywgJ3R3b1xcbicsICd0aHJlZVxcbiddXG4gICAgICA+Pj4gYiA9IFsnb3JlXFxuJywgJ3RyZWVcXG4nLCAnZW11XFxuJ11cbiAgICAgID4+PiBkaWZmID0gbmRpZmYoYSwgYilcbiAgICAgID4+PiByZXN0b3JlKGRpZmYsIDEpXG4gICAgICBbICdvbmVcXG4nLFxuICAgICAgICAndHdvXFxuJyxcbiAgICAgICAgJ3RocmVlXFxuJyBdXG4gICAgICA+Pj4gcmVzdG9yZShkaWZmLCAyKVxuICAgICAgWyAnb3JlXFxuJyxcbiAgICAgICAgJ3RyZWVcXG4nLFxuICAgICAgICAnZW11XFxuJyBdXG4gICAgKi9cblxuICAgIHZhciBsaW5lLCBsaW5lcywgcHJlZml4ZXMsIHRhZywgX2ksIF9sZW4sIF9yZWY7XG4gICAgdGFnID0ge1xuICAgICAgMTogJy0gJyxcbiAgICAgIDI6ICcrICdcbiAgICB9W3doaWNoXTtcbiAgICBpZiAoIXRhZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93IGRlbHRhIGNob2ljZSAobXVzdCBiZSAxIG9yIDIpOiBcIiArIHdoaWNoKTtcbiAgICB9XG4gICAgcHJlZml4ZXMgPSBbJyAgJywgdGFnXTtcbiAgICBsaW5lcyA9IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gZGVsdGEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGxpbmUgPSBkZWx0YVtfaV07XG4gICAgICBpZiAoX3JlZiA9IGxpbmUuc2xpY2UoMCwgMiksIF9faW5kZXhPZi5jYWxsKHByZWZpeGVzLCBfcmVmKSA+PSAwKSB7XG4gICAgICAgIGxpbmVzLnB1c2gobGluZS5zbGljZSgyKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbiAgfTtcblxuICBleHBvcnRzLl9hcnJheUNtcCA9IF9hcnJheUNtcDtcblxuICBleHBvcnRzLlNlcXVlbmNlTWF0Y2hlciA9IFNlcXVlbmNlTWF0Y2hlcjtcblxuICBleHBvcnRzLmdldENsb3NlTWF0Y2hlcyA9IGdldENsb3NlTWF0Y2hlcztcblxuICBleHBvcnRzLl9jb3VudExlYWRpbmcgPSBfY291bnRMZWFkaW5nO1xuXG4gIGV4cG9ydHMuRGlmZmVyID0gRGlmZmVyO1xuXG4gIGV4cG9ydHMuSVNfTElORV9KVU5LID0gSVNfTElORV9KVU5LO1xuXG4gIGV4cG9ydHMuSVNfQ0hBUkFDVEVSX0pVTksgPSBJU19DSEFSQUNURVJfSlVOSztcblxuICBleHBvcnRzLl9mb3JtYXRSYW5nZVVuaWZpZWQgPSBfZm9ybWF0UmFuZ2VVbmlmaWVkO1xuXG4gIGV4cG9ydHMudW5pZmllZERpZmYgPSB1bmlmaWVkRGlmZjtcblxuICBleHBvcnRzLl9mb3JtYXRSYW5nZUNvbnRleHQgPSBfZm9ybWF0UmFuZ2VDb250ZXh0O1xuXG4gIGV4cG9ydHMuY29udGV4dERpZmYgPSBjb250ZXh0RGlmZjtcblxuICBleHBvcnRzLm5kaWZmID0gbmRpZmY7XG5cbiAgZXhwb3J0cy5yZXN0b3JlID0gcmVzdG9yZTtcblxufSkuY2FsbCh0aGlzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/difflib/lib/difflib.js\n");

/***/ })

};
;