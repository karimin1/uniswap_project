/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/workerpool";
exports.ids = ["vendor-chunks/workerpool"];
exports.modules = {

/***/ "(ssr)/./node_modules/workerpool/src/Pool.js":
/*!*********************************************!*\
  !*** ./node_modules/workerpool/src/Pool.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Promise = __webpack_require__(/*! ./Promise */ \"(ssr)/./node_modules/workerpool/src/Promise.js\");\nvar WorkerHandler = __webpack_require__(/*! ./WorkerHandler */ \"(ssr)/./node_modules/workerpool/src/WorkerHandler.js\");\nvar environment = __webpack_require__(/*! ./environment */ \"(ssr)/./node_modules/workerpool/src/environment.js\");\nvar DebugPortAllocator = __webpack_require__(/*! ./debug-port-allocator */ \"(ssr)/./node_modules/workerpool/src/debug-port-allocator.js\");\nvar DEBUG_PORT_ALLOCATOR = new DebugPortAllocator();\n/**\n * A pool to manage workers\n * @param {String} [script]   Optional worker script\n * @param {WorkerPoolOptions} [options]  See docs\n * @constructor\n */\nfunction Pool(script, options) {\n  if (typeof script === 'string') {\n    this.script = script || null;\n  }\n  else {\n    this.script = null;\n    options = script;\n  }\n\n  this.workers = [];  // queue with all workers\n  this.tasks = [];    // queue with tasks awaiting execution\n\n  options = options || {};\n\n  this.forkArgs = Object.freeze(options.forkArgs || []);\n  this.forkOpts = Object.freeze(options.forkOpts || {});\n  this.workerOpts = Object.freeze(options.workerOpts || {});\n  this.workerThreadOpts = Object.freeze(options.workerThreadOpts || {})\n  this.debugPortStart = (options.debugPortStart || 43210);\n  this.nodeWorker = options.nodeWorker;\n  this.workerType = options.workerType || options.nodeWorker || 'auto'\n  this.maxQueueSize = options.maxQueueSize || Infinity;\n  this.workerTerminateTimeout = options.workerTerminateTimeout || 1000;\n\n  this.onCreateWorker = options.onCreateWorker || (() => null);\n  this.onTerminateWorker = options.onTerminateWorker || (() => null);\n\n  // configuration\n  if (options && 'maxWorkers' in options) {\n    validateMaxWorkers(options.maxWorkers);\n    this.maxWorkers = options.maxWorkers;\n  }\n  else {\n    this.maxWorkers = Math.max((environment.cpus || 4) - 1, 1);\n  }\n\n  if (options && 'minWorkers' in options) {\n    if(options.minWorkers === 'max') {\n      this.minWorkers = this.maxWorkers;\n    } else {\n      validateMinWorkers(options.minWorkers);\n      this.minWorkers = options.minWorkers;\n      this.maxWorkers = Math.max(this.minWorkers, this.maxWorkers);     // in case minWorkers is higher than maxWorkers\n    }\n    this._ensureMinWorkers();\n  }\n\n  this._boundNext = this._next.bind(this);\n\n\n  if (this.workerType === 'thread') {\n    WorkerHandler.ensureWorkerThreads();\n  }\n}\n\n\n/**\n * Execute a function on a worker.\n *\n * Example usage:\n *\n *   var pool = new Pool()\n *\n *   // call a function available on the worker\n *   pool.exec('fibonacci', [6])\n *\n *   // offload a function\n *   function add(a, b) {\n *     return a + b\n *   };\n *   pool.exec(add, [2, 4])\n *       .then(function (result) {\n *         console.log(result); // outputs 6\n *       })\n *       .catch(function(error) {\n *         console.log(error);\n *       });\n *\n * @param {String | Function} method  Function name or function.\n *                                    If `method` is a string, the corresponding\n *                                    method on the worker will be executed\n *                                    If `method` is a Function, the function\n *                                    will be stringified and executed via the\n *                                    workers built-in function `run(fn, args)`.\n * @param {Array} [params]  Function arguments applied when calling the function\n * @param {ExecOptions} [options]  Options object\n * @return {Promise.<*, Error>} result\n */\nPool.prototype.exec = function (method, params, options) {\n  // validate type of arguments\n  if (params && !Array.isArray(params)) {\n    throw new TypeError('Array expected as argument \"params\"');\n  }\n\n  if (typeof method === 'string') {\n    var resolver = Promise.defer();\n\n    if (this.tasks.length >= this.maxQueueSize) {\n      throw new Error('Max queue size of ' + this.maxQueueSize + ' reached');\n    }\n\n    // add a new task to the queue\n    var tasks = this.tasks;\n    var task = {\n      method:  method,\n      params:  params,\n      resolver: resolver,\n      timeout: null,\n      options: options\n    };\n    tasks.push(task);\n\n    // replace the timeout method of the Promise with our own,\n    // which starts the timer as soon as the task is actually started\n    var originalTimeout = resolver.promise.timeout;\n    resolver.promise.timeout = function timeout (delay) {\n      if (tasks.indexOf(task) !== -1) {\n        // task is still queued -> start the timer later on\n        task.timeout = delay;\n        return resolver.promise;\n      }\n      else {\n        // task is already being executed -> start timer immediately\n        return originalTimeout.call(resolver.promise, delay);\n      }\n    };\n\n    // trigger task execution\n    this._next();\n\n    return resolver.promise;\n  }\n  else if (typeof method === 'function') {\n    // send stringified function and function arguments to worker\n    return this.exec('run', [String(method), params]);\n  }\n  else {\n    throw new TypeError('Function or string expected as argument \"method\"');\n  }\n};\n\n/**\n * Create a proxy for current worker. Returns an object containing all\n * methods available on the worker. The methods always return a promise.\n *\n * @return {Promise.<Object, Error>} proxy\n */\nPool.prototype.proxy = function () {\n  if (arguments.length > 0) {\n    throw new Error('No arguments expected');\n  }\n\n  var pool = this;\n  return this.exec('methods')\n      .then(function (methods) {\n        var proxy = {};\n\n        methods.forEach(function (method) {\n          proxy[method] = function () {\n            return pool.exec(method, Array.prototype.slice.call(arguments));\n          }\n        });\n\n        return proxy;\n      });\n};\n\n/**\n * Creates new array with the results of calling a provided callback function\n * on every element in this array.\n * @param {Array} array\n * @param {function} callback  Function taking two arguments:\n *                             `callback(currentValue, index)`\n * @return {Promise.<Array>} Returns a promise which resolves  with an Array\n *                           containing the results of the callback function\n *                           executed for each of the array elements.\n */\n/* TODO: implement map\nPool.prototype.map = function (array, callback) {\n};\n*/\n\n/**\n * Grab the first task from the queue, find a free worker, and assign the\n * worker to the task.\n * @protected\n */\nPool.prototype._next = function () {\n  if (this.tasks.length > 0) {\n    // there are tasks in the queue\n\n    // find an available worker\n    var worker = this._getWorker();\n    if (worker) {\n      // get the first task from the queue\n      var me = this;\n      var task = this.tasks.shift();\n\n      // check if the task is still pending (and not cancelled -> promise rejected)\n      if (task.resolver.promise.pending) {\n        // send the request to the worker\n        var promise = worker.exec(task.method, task.params, task.resolver, task.options)\n          .then(me._boundNext)\n          .catch(function () {\n            // if the worker crashed and terminated, remove it from the pool\n            if (worker.terminated) {\n              return me._removeWorker(worker);\n            }\n          }).then(function() {\n            me._next(); // trigger next task in the queue\n          });\n\n        // start queued timer now\n        if (typeof task.timeout === 'number') {\n          promise.timeout(task.timeout);\n        }\n      } else {\n        // The task taken was already complete (either rejected or resolved), so just trigger next task in the queue\n        me._next();\n      }\n    }\n  }\n};\n\n/**\n * Get an available worker. If no worker is available and the maximum number\n * of workers isn't yet reached, a new worker will be created and returned.\n * If no worker is available and the maximum number of workers is reached,\n * null will be returned.\n *\n * @return {WorkerHandler | null} worker\n * @private\n */\nPool.prototype._getWorker = function() {\n  // find a non-busy worker\n  var workers = this.workers;\n  for (var i = 0; i < workers.length; i++) {\n    var worker = workers[i];\n    if (worker.busy() === false) {\n      return worker;\n    }\n  }\n\n  if (workers.length < this.maxWorkers) {\n    // create a new worker\n    worker = this._createWorkerHandler();\n    workers.push(worker);\n    return worker;\n  }\n\n  return null;\n};\n\n/**\n * Remove a worker from the pool.\n * Attempts to terminate worker if not already terminated, and ensures the minimum\n * pool size is met.\n * @param {WorkerHandler} worker\n * @return {Promise<WorkerHandler>}\n * @protected\n */\nPool.prototype._removeWorker = function(worker) {\n  var me = this;\n\n  DEBUG_PORT_ALLOCATOR.releasePort(worker.debugPort);\n  // _removeWorker will call this, but we need it to be removed synchronously\n  this._removeWorkerFromList(worker);\n  // If minWorkers set, spin up new workers to replace the crashed ones\n  this._ensureMinWorkers();\n  // terminate the worker (if not already terminated)\n  return new Promise(function(resolve, reject) {\n    worker.terminate(false, function(err) {\n      me.onTerminateWorker({\n        forkArgs: worker.forkArgs,\n        forkOpts: worker.forkOpts,\n        workerThreadOpts: worker.workerThreadOpts,\n        script: worker.script\n      });\n      if (err) {\n        reject(err);\n      } else {\n        resolve(worker);\n      }\n    });\n  });\n};\n\n/**\n * Remove a worker from the pool list.\n * @param {WorkerHandler} worker\n * @protected\n */\nPool.prototype._removeWorkerFromList = function(worker) {\n  // remove from the list with workers\n  var index = this.workers.indexOf(worker);\n  if (index !== -1) {\n    this.workers.splice(index, 1);\n  }\n};\n\n/**\n * Close all active workers. Tasks currently being executed will be finished first.\n * @param {boolean} [force=false]   If false (default), the workers are terminated\n *                                  after finishing all tasks currently in\n *                                  progress. If true, the workers will be\n *                                  terminated immediately.\n * @param {number} [timeout]        If provided and non-zero, worker termination promise will be rejected\n *                                  after timeout if worker process has not been terminated.\n * @return {Promise.<void, Error>}\n */\nPool.prototype.terminate = function (force, timeout) {\n  var me = this;\n\n  // cancel any pending tasks\n  this.tasks.forEach(function (task) {\n    task.resolver.reject(new Error('Pool terminated'));\n  });\n  this.tasks.length = 0;\n\n  var f = function (worker) {\n    DEBUG_PORT_ALLOCATOR.releasePort(worker.debugPort);\n    this._removeWorkerFromList(worker);\n  };\n  var removeWorker = f.bind(this);\n\n  var promises = [];\n  var workers = this.workers.slice();\n  workers.forEach(function (worker) {\n    var termPromise = worker.terminateAndNotify(force, timeout)\n      .then(removeWorker)\n      .always(function() {\n        me.onTerminateWorker({\n          forkArgs: worker.forkArgs,\n          forkOpts: worker.forkOpts,\n          workerThreadOpts: worker.workerThreadOpts,\n          script: worker.script\n        });\n      });\n    promises.push(termPromise);\n  });\n  return Promise.all(promises);\n};\n\n/**\n * Retrieve statistics on tasks and workers.\n * @return {{totalWorkers: number, busyWorkers: number, idleWorkers: number, pendingTasks: number, activeTasks: number}} Returns an object with statistics\n */\nPool.prototype.stats = function () {\n  var totalWorkers = this.workers.length;\n  var busyWorkers = this.workers.filter(function (worker) {\n    return worker.busy();\n  }).length;\n\n  return {\n    totalWorkers:  totalWorkers,\n    busyWorkers:   busyWorkers,\n    idleWorkers:   totalWorkers - busyWorkers,\n\n    pendingTasks:  this.tasks.length,\n    activeTasks:   busyWorkers\n  };\n};\n\n/**\n * Ensures that a minimum of minWorkers is up and running\n * @protected\n */\nPool.prototype._ensureMinWorkers = function() {\n  if (this.minWorkers) {\n    for(var i = this.workers.length; i < this.minWorkers; i++) {\n      this.workers.push(this._createWorkerHandler());\n    }\n  }\n};\n\n/**\n * Helper function to create a new WorkerHandler and pass all options.\n * @return {WorkerHandler}\n * @private\n */\nPool.prototype._createWorkerHandler = function () {\n  const overriddenParams = this.onCreateWorker({\n    forkArgs: this.forkArgs,\n    forkOpts: this.forkOpts,\n    workerOpts: this.workerOpts,\n    workerThreadOpts: this.workerThreadOpts,\n    script: this.script\n  }) || {};\n\n  return new WorkerHandler(overriddenParams.script || this.script, {\n    forkArgs: overriddenParams.forkArgs || this.forkArgs,\n    forkOpts: overriddenParams.forkOpts || this.forkOpts,\n    workerOpts: overriddenParams.workerOpts || this.workerOpts,\n    workerThreadOpts: overriddenParams.workerThreadOpts || this.workerThreadOpts,\n    debugPort: DEBUG_PORT_ALLOCATOR.nextAvailableStartingAt(this.debugPortStart),\n    workerType: this.workerType,\n    workerTerminateTimeout: this.workerTerminateTimeout,\n  });\n}\n\n/**\n * Ensure that the maxWorkers option is an integer >= 1\n * @param {*} maxWorkers\n * @returns {boolean} returns true maxWorkers has a valid value\n */\nfunction validateMaxWorkers(maxWorkers) {\n  if (!isNumber(maxWorkers) || !isInteger(maxWorkers) || maxWorkers < 1) {\n    throw new TypeError('Option maxWorkers must be an integer number >= 1');\n  }\n}\n\n/**\n * Ensure that the minWorkers option is an integer >= 0\n * @param {*} minWorkers\n * @returns {boolean} returns true when minWorkers has a valid value\n */\nfunction validateMinWorkers(minWorkers) {\n  if (!isNumber(minWorkers) || !isInteger(minWorkers) || minWorkers < 0) {\n    throw new TypeError('Option minWorkers must be an integer number >= 0');\n  }\n}\n\n/**\n * Test whether a variable is a number\n * @param {*} value\n * @returns {boolean} returns true when value is a number\n */\nfunction isNumber(value) {\n  return typeof value === 'number';\n}\n\n/**\n * Test whether a number is an integer\n * @param {number} value\n * @returns {boolean} Returns true if value is an integer\n */\nfunction isInteger(value) {\n  return Math.round(value) == value;\n}\n\nmodule.exports = Pool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd29ya2VycG9vbC9zcmMvUG9vbC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsaUVBQVc7QUFDakMsb0JBQW9CLG1CQUFPLENBQUMsNkVBQWlCO0FBQzdDLGtCQUFrQixtQkFBTyxDQUFDLHlFQUFlO0FBQ3pDLHlCQUF5QixtQkFBTyxDQUFDLDJGQUF3QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLHNCQUFzQjs7QUFFdEI7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQsMERBQTBEO0FBQzFELHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxhQUFhO0FBQ3hCLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsd0JBQXdCO0FBQ3hCLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsNEdBQTRHO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxQkFBcUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvd29ya2VycG9vbC9zcmMvUG9vbC5qcz85ZTdhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9Qcm9taXNlJyk7XG52YXIgV29ya2VySGFuZGxlciA9IHJlcXVpcmUoJy4vV29ya2VySGFuZGxlcicpO1xudmFyIGVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9lbnZpcm9ubWVudCcpO1xudmFyIERlYnVnUG9ydEFsbG9jYXRvciA9IHJlcXVpcmUoJy4vZGVidWctcG9ydC1hbGxvY2F0b3InKTtcbnZhciBERUJVR19QT1JUX0FMTE9DQVRPUiA9IG5ldyBEZWJ1Z1BvcnRBbGxvY2F0b3IoKTtcbi8qKlxuICogQSBwb29sIHRvIG1hbmFnZSB3b3JrZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gW3NjcmlwdF0gICBPcHRpb25hbCB3b3JrZXIgc2NyaXB0XG4gKiBAcGFyYW0ge1dvcmtlclBvb2xPcHRpb25zfSBbb3B0aW9uc10gIFNlZSBkb2NzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUG9vbChzY3JpcHQsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBzY3JpcHQgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5zY3JpcHQgPSBzY3JpcHQgfHwgbnVsbDtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gICAgb3B0aW9ucyA9IHNjcmlwdDtcbiAgfVxuXG4gIHRoaXMud29ya2VycyA9IFtdOyAgLy8gcXVldWUgd2l0aCBhbGwgd29ya2Vyc1xuICB0aGlzLnRhc2tzID0gW107ICAgIC8vIHF1ZXVlIHdpdGggdGFza3MgYXdhaXRpbmcgZXhlY3V0aW9uXG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5mb3JrQXJncyA9IE9iamVjdC5mcmVlemUob3B0aW9ucy5mb3JrQXJncyB8fCBbXSk7XG4gIHRoaXMuZm9ya09wdHMgPSBPYmplY3QuZnJlZXplKG9wdGlvbnMuZm9ya09wdHMgfHwge30pO1xuICB0aGlzLndvcmtlck9wdHMgPSBPYmplY3QuZnJlZXplKG9wdGlvbnMud29ya2VyT3B0cyB8fCB7fSk7XG4gIHRoaXMud29ya2VyVGhyZWFkT3B0cyA9IE9iamVjdC5mcmVlemUob3B0aW9ucy53b3JrZXJUaHJlYWRPcHRzIHx8IHt9KVxuICB0aGlzLmRlYnVnUG9ydFN0YXJ0ID0gKG9wdGlvbnMuZGVidWdQb3J0U3RhcnQgfHwgNDMyMTApO1xuICB0aGlzLm5vZGVXb3JrZXIgPSBvcHRpb25zLm5vZGVXb3JrZXI7XG4gIHRoaXMud29ya2VyVHlwZSA9IG9wdGlvbnMud29ya2VyVHlwZSB8fCBvcHRpb25zLm5vZGVXb3JrZXIgfHwgJ2F1dG8nXG4gIHRoaXMubWF4UXVldWVTaXplID0gb3B0aW9ucy5tYXhRdWV1ZVNpemUgfHwgSW5maW5pdHk7XG4gIHRoaXMud29ya2VyVGVybWluYXRlVGltZW91dCA9IG9wdGlvbnMud29ya2VyVGVybWluYXRlVGltZW91dCB8fCAxMDAwO1xuXG4gIHRoaXMub25DcmVhdGVXb3JrZXIgPSBvcHRpb25zLm9uQ3JlYXRlV29ya2VyIHx8ICgoKSA9PiBudWxsKTtcbiAgdGhpcy5vblRlcm1pbmF0ZVdvcmtlciA9IG9wdGlvbnMub25UZXJtaW5hdGVXb3JrZXIgfHwgKCgpID0+IG51bGwpO1xuXG4gIC8vIGNvbmZpZ3VyYXRpb25cbiAgaWYgKG9wdGlvbnMgJiYgJ21heFdvcmtlcnMnIGluIG9wdGlvbnMpIHtcbiAgICB2YWxpZGF0ZU1heFdvcmtlcnMob3B0aW9ucy5tYXhXb3JrZXJzKTtcbiAgICB0aGlzLm1heFdvcmtlcnMgPSBvcHRpb25zLm1heFdvcmtlcnM7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5tYXhXb3JrZXJzID0gTWF0aC5tYXgoKGVudmlyb25tZW50LmNwdXMgfHwgNCkgLSAxLCAxKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zICYmICdtaW5Xb3JrZXJzJyBpbiBvcHRpb25zKSB7XG4gICAgaWYob3B0aW9ucy5taW5Xb3JrZXJzID09PSAnbWF4Jykge1xuICAgICAgdGhpcy5taW5Xb3JrZXJzID0gdGhpcy5tYXhXb3JrZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZU1pbldvcmtlcnMob3B0aW9ucy5taW5Xb3JrZXJzKTtcbiAgICAgIHRoaXMubWluV29ya2VycyA9IG9wdGlvbnMubWluV29ya2VycztcbiAgICAgIHRoaXMubWF4V29ya2VycyA9IE1hdGgubWF4KHRoaXMubWluV29ya2VycywgdGhpcy5tYXhXb3JrZXJzKTsgICAgIC8vIGluIGNhc2UgbWluV29ya2VycyBpcyBoaWdoZXIgdGhhbiBtYXhXb3JrZXJzXG4gICAgfVxuICAgIHRoaXMuX2Vuc3VyZU1pbldvcmtlcnMoKTtcbiAgfVxuXG4gIHRoaXMuX2JvdW5kTmV4dCA9IHRoaXMuX25leHQuYmluZCh0aGlzKTtcblxuXG4gIGlmICh0aGlzLndvcmtlclR5cGUgPT09ICd0aHJlYWQnKSB7XG4gICAgV29ya2VySGFuZGxlci5lbnN1cmVXb3JrZXJUaHJlYWRzKCk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEV4ZWN1dGUgYSBmdW5jdGlvbiBvbiBhIHdvcmtlci5cbiAqXG4gKiBFeGFtcGxlIHVzYWdlOlxuICpcbiAqICAgdmFyIHBvb2wgPSBuZXcgUG9vbCgpXG4gKlxuICogICAvLyBjYWxsIGEgZnVuY3Rpb24gYXZhaWxhYmxlIG9uIHRoZSB3b3JrZXJcbiAqICAgcG9vbC5leGVjKCdmaWJvbmFjY2knLCBbNl0pXG4gKlxuICogICAvLyBvZmZsb2FkIGEgZnVuY3Rpb25cbiAqICAgZnVuY3Rpb24gYWRkKGEsIGIpIHtcbiAqICAgICByZXR1cm4gYSArIGJcbiAqICAgfTtcbiAqICAgcG9vbC5leGVjKGFkZCwgWzIsIDRdKVxuICogICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpOyAvLyBvdXRwdXRzIDZcbiAqICAgICAgIH0pXG4gKiAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICogICAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmcgfCBGdW5jdGlvbn0gbWV0aG9kICBGdW5jdGlvbiBuYW1lIG9yIGZ1bmN0aW9uLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBgbWV0aG9kYCBpcyBhIHN0cmluZywgdGhlIGNvcnJlc3BvbmRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kIG9uIHRoZSB3b3JrZXIgd2lsbCBiZSBleGVjdXRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBgbWV0aG9kYCBpcyBhIEZ1bmN0aW9uLCB0aGUgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBzdHJpbmdpZmllZCBhbmQgZXhlY3V0ZWQgdmlhIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXJzIGJ1aWx0LWluIGZ1bmN0aW9uIGBydW4oZm4sIGFyZ3MpYC5cbiAqIEBwYXJhbSB7QXJyYXl9IFtwYXJhbXNdICBGdW5jdGlvbiBhcmd1bWVudHMgYXBwbGllZCB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0V4ZWNPcHRpb25zfSBbb3B0aW9uc10gIE9wdGlvbnMgb2JqZWN0XG4gKiBAcmV0dXJuIHtQcm9taXNlLjwqLCBFcnJvcj59IHJlc3VsdFxuICovXG5Qb29sLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gIC8vIHZhbGlkYXRlIHR5cGUgb2YgYXJndW1lbnRzXG4gIGlmIChwYXJhbXMgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IGV4cGVjdGVkIGFzIGFyZ3VtZW50IFwicGFyYW1zXCInKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbWV0aG9kID09PSAnc3RyaW5nJykge1xuICAgIHZhciByZXNvbHZlciA9IFByb21pc2UuZGVmZXIoKTtcblxuICAgIGlmICh0aGlzLnRhc2tzLmxlbmd0aCA+PSB0aGlzLm1heFF1ZXVlU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXggcXVldWUgc2l6ZSBvZiAnICsgdGhpcy5tYXhRdWV1ZVNpemUgKyAnIHJlYWNoZWQnKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgYSBuZXcgdGFzayB0byB0aGUgcXVldWVcbiAgICB2YXIgdGFza3MgPSB0aGlzLnRhc2tzO1xuICAgIHZhciB0YXNrID0ge1xuICAgICAgbWV0aG9kOiAgbWV0aG9kLFxuICAgICAgcGFyYW1zOiAgcGFyYW1zLFxuICAgICAgcmVzb2x2ZXI6IHJlc29sdmVyLFxuICAgICAgdGltZW91dDogbnVsbCxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICB9O1xuICAgIHRhc2tzLnB1c2godGFzayk7XG5cbiAgICAvLyByZXBsYWNlIHRoZSB0aW1lb3V0IG1ldGhvZCBvZiB0aGUgUHJvbWlzZSB3aXRoIG91ciBvd24sXG4gICAgLy8gd2hpY2ggc3RhcnRzIHRoZSB0aW1lciBhcyBzb29uIGFzIHRoZSB0YXNrIGlzIGFjdHVhbGx5IHN0YXJ0ZWRcbiAgICB2YXIgb3JpZ2luYWxUaW1lb3V0ID0gcmVzb2x2ZXIucHJvbWlzZS50aW1lb3V0O1xuICAgIHJlc29sdmVyLnByb21pc2UudGltZW91dCA9IGZ1bmN0aW9uIHRpbWVvdXQgKGRlbGF5KSB7XG4gICAgICBpZiAodGFza3MuaW5kZXhPZih0YXNrKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gdGFzayBpcyBzdGlsbCBxdWV1ZWQgLT4gc3RhcnQgdGhlIHRpbWVyIGxhdGVyIG9uXG4gICAgICAgIHRhc2sudGltZW91dCA9IGRlbGF5O1xuICAgICAgICByZXR1cm4gcmVzb2x2ZXIucHJvbWlzZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyB0YXNrIGlzIGFscmVhZHkgYmVpbmcgZXhlY3V0ZWQgLT4gc3RhcnQgdGltZXIgaW1tZWRpYXRlbHlcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsVGltZW91dC5jYWxsKHJlc29sdmVyLnByb21pc2UsIGRlbGF5KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gdHJpZ2dlciB0YXNrIGV4ZWN1dGlvblxuICAgIHRoaXMuX25leHQoKTtcblxuICAgIHJldHVybiByZXNvbHZlci5wcm9taXNlO1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBzZW5kIHN0cmluZ2lmaWVkIGZ1bmN0aW9uIGFuZCBmdW5jdGlvbiBhcmd1bWVudHMgdG8gd29ya2VyXG4gICAgcmV0dXJuIHRoaXMuZXhlYygncnVuJywgW1N0cmluZyhtZXRob2QpLCBwYXJhbXNdKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbiBvciBzdHJpbmcgZXhwZWN0ZWQgYXMgYXJndW1lbnQgXCJtZXRob2RcIicpO1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHByb3h5IGZvciBjdXJyZW50IHdvcmtlci4gUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyBhbGxcbiAqIG1ldGhvZHMgYXZhaWxhYmxlIG9uIHRoZSB3b3JrZXIuIFRoZSBtZXRob2RzIGFsd2F5cyByZXR1cm4gYSBwcm9taXNlLlxuICpcbiAqIEByZXR1cm4ge1Byb21pc2UuPE9iamVjdCwgRXJyb3I+fSBwcm94eVxuICovXG5Qb29sLnByb3RvdHlwZS5wcm94eSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBhcmd1bWVudHMgZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIHZhciBwb29sID0gdGhpcztcbiAgcmV0dXJuIHRoaXMuZXhlYygnbWV0aG9kcycpXG4gICAgICAudGhlbihmdW5jdGlvbiAobWV0aG9kcykge1xuICAgICAgICB2YXIgcHJveHkgPSB7fTtcblxuICAgICAgICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgIHByb3h5W21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9vbC5leGVjKG1ldGhvZCwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcHJveHk7XG4gICAgICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgYXJyYXkgd2l0aCB0aGUgcmVzdWx0cyBvZiBjYWxsaW5nIGEgcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIG9uIGV2ZXJ5IGVsZW1lbnQgaW4gdGhpcyBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgRnVuY3Rpb24gdGFraW5nIHR3byBhcmd1bWVudHM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGNhbGxiYWNrKGN1cnJlbnRWYWx1ZSwgaW5kZXgpYFxuICogQHJldHVybiB7UHJvbWlzZS48QXJyYXk+fSBSZXR1cm5zIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyAgd2l0aCBhbiBBcnJheVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluaW5nIHRoZSByZXN1bHRzIG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlZCBmb3IgZWFjaCBvZiB0aGUgYXJyYXkgZWxlbWVudHMuXG4gKi9cbi8qIFRPRE86IGltcGxlbWVudCBtYXBcblBvb2wucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChhcnJheSwgY2FsbGJhY2spIHtcbn07XG4qL1xuXG4vKipcbiAqIEdyYWIgdGhlIGZpcnN0IHRhc2sgZnJvbSB0aGUgcXVldWUsIGZpbmQgYSBmcmVlIHdvcmtlciwgYW5kIGFzc2lnbiB0aGVcbiAqIHdvcmtlciB0byB0aGUgdGFzay5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUG9vbC5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnRhc2tzLmxlbmd0aCA+IDApIHtcbiAgICAvLyB0aGVyZSBhcmUgdGFza3MgaW4gdGhlIHF1ZXVlXG5cbiAgICAvLyBmaW5kIGFuIGF2YWlsYWJsZSB3b3JrZXJcbiAgICB2YXIgd29ya2VyID0gdGhpcy5fZ2V0V29ya2VyKCk7XG4gICAgaWYgKHdvcmtlcikge1xuICAgICAgLy8gZ2V0IHRoZSBmaXJzdCB0YXNrIGZyb20gdGhlIHF1ZXVlXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdmFyIHRhc2sgPSB0aGlzLnRhc2tzLnNoaWZ0KCk7XG5cbiAgICAgIC8vIGNoZWNrIGlmIHRoZSB0YXNrIGlzIHN0aWxsIHBlbmRpbmcgKGFuZCBub3QgY2FuY2VsbGVkIC0+IHByb21pc2UgcmVqZWN0ZWQpXG4gICAgICBpZiAodGFzay5yZXNvbHZlci5wcm9taXNlLnBlbmRpbmcpIHtcbiAgICAgICAgLy8gc2VuZCB0aGUgcmVxdWVzdCB0byB0aGUgd29ya2VyXG4gICAgICAgIHZhciBwcm9taXNlID0gd29ya2VyLmV4ZWModGFzay5tZXRob2QsIHRhc2sucGFyYW1zLCB0YXNrLnJlc29sdmVyLCB0YXNrLm9wdGlvbnMpXG4gICAgICAgICAgLnRoZW4obWUuX2JvdW5kTmV4dClcbiAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHdvcmtlciBjcmFzaGVkIGFuZCB0ZXJtaW5hdGVkLCByZW1vdmUgaXQgZnJvbSB0aGUgcG9vbFxuICAgICAgICAgICAgaWYgKHdvcmtlci50ZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBtZS5fcmVtb3ZlV29ya2VyKHdvcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG1lLl9uZXh0KCk7IC8vIHRyaWdnZXIgbmV4dCB0YXNrIGluIHRoZSBxdWV1ZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHN0YXJ0IHF1ZXVlZCB0aW1lciBub3dcbiAgICAgICAgaWYgKHR5cGVvZiB0YXNrLnRpbWVvdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcHJvbWlzZS50aW1lb3V0KHRhc2sudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSB0YXNrIHRha2VuIHdhcyBhbHJlYWR5IGNvbXBsZXRlIChlaXRoZXIgcmVqZWN0ZWQgb3IgcmVzb2x2ZWQpLCBzbyBqdXN0IHRyaWdnZXIgbmV4dCB0YXNrIGluIHRoZSBxdWV1ZVxuICAgICAgICBtZS5fbmV4dCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgYW4gYXZhaWxhYmxlIHdvcmtlci4gSWYgbm8gd29ya2VyIGlzIGF2YWlsYWJsZSBhbmQgdGhlIG1heGltdW0gbnVtYmVyXG4gKiBvZiB3b3JrZXJzIGlzbid0IHlldCByZWFjaGVkLCBhIG5ldyB3b3JrZXIgd2lsbCBiZSBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAqIElmIG5vIHdvcmtlciBpcyBhdmFpbGFibGUgYW5kIHRoZSBtYXhpbXVtIG51bWJlciBvZiB3b3JrZXJzIGlzIHJlYWNoZWQsXG4gKiBudWxsIHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogQHJldHVybiB7V29ya2VySGFuZGxlciB8IG51bGx9IHdvcmtlclxuICogQHByaXZhdGVcbiAqL1xuUG9vbC5wcm90b3R5cGUuX2dldFdvcmtlciA9IGZ1bmN0aW9uKCkge1xuICAvLyBmaW5kIGEgbm9uLWJ1c3kgd29ya2VyXG4gIHZhciB3b3JrZXJzID0gdGhpcy53b3JrZXJzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmtlcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgd29ya2VyID0gd29ya2Vyc1tpXTtcbiAgICBpZiAod29ya2VyLmJ1c3koKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB3b3JrZXI7XG4gICAgfVxuICB9XG5cbiAgaWYgKHdvcmtlcnMubGVuZ3RoIDwgdGhpcy5tYXhXb3JrZXJzKSB7XG4gICAgLy8gY3JlYXRlIGEgbmV3IHdvcmtlclxuICAgIHdvcmtlciA9IHRoaXMuX2NyZWF0ZVdvcmtlckhhbmRsZXIoKTtcbiAgICB3b3JrZXJzLnB1c2god29ya2VyKTtcbiAgICByZXR1cm4gd29ya2VyO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIHdvcmtlciBmcm9tIHRoZSBwb29sLlxuICogQXR0ZW1wdHMgdG8gdGVybWluYXRlIHdvcmtlciBpZiBub3QgYWxyZWFkeSB0ZXJtaW5hdGVkLCBhbmQgZW5zdXJlcyB0aGUgbWluaW11bVxuICogcG9vbCBzaXplIGlzIG1ldC5cbiAqIEBwYXJhbSB7V29ya2VySGFuZGxlcn0gd29ya2VyXG4gKiBAcmV0dXJuIHtQcm9taXNlPFdvcmtlckhhbmRsZXI+fVxuICogQHByb3RlY3RlZFxuICovXG5Qb29sLnByb3RvdHlwZS5fcmVtb3ZlV29ya2VyID0gZnVuY3Rpb24od29ya2VyKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgREVCVUdfUE9SVF9BTExPQ0FUT1IucmVsZWFzZVBvcnQod29ya2VyLmRlYnVnUG9ydCk7XG4gIC8vIF9yZW1vdmVXb3JrZXIgd2lsbCBjYWxsIHRoaXMsIGJ1dCB3ZSBuZWVkIGl0IHRvIGJlIHJlbW92ZWQgc3luY2hyb25vdXNseVxuICB0aGlzLl9yZW1vdmVXb3JrZXJGcm9tTGlzdCh3b3JrZXIpO1xuICAvLyBJZiBtaW5Xb3JrZXJzIHNldCwgc3BpbiB1cCBuZXcgd29ya2VycyB0byByZXBsYWNlIHRoZSBjcmFzaGVkIG9uZXNcbiAgdGhpcy5fZW5zdXJlTWluV29ya2VycygpO1xuICAvLyB0ZXJtaW5hdGUgdGhlIHdvcmtlciAoaWYgbm90IGFscmVhZHkgdGVybWluYXRlZClcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHdvcmtlci50ZXJtaW5hdGUoZmFsc2UsIGZ1bmN0aW9uKGVycikge1xuICAgICAgbWUub25UZXJtaW5hdGVXb3JrZXIoe1xuICAgICAgICBmb3JrQXJnczogd29ya2VyLmZvcmtBcmdzLFxuICAgICAgICBmb3JrT3B0czogd29ya2VyLmZvcmtPcHRzLFxuICAgICAgICB3b3JrZXJUaHJlYWRPcHRzOiB3b3JrZXIud29ya2VyVGhyZWFkT3B0cyxcbiAgICAgICAgc2NyaXB0OiB3b3JrZXIuc2NyaXB0XG4gICAgICB9KTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKHdvcmtlcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSB3b3JrZXIgZnJvbSB0aGUgcG9vbCBsaXN0LlxuICogQHBhcmFtIHtXb3JrZXJIYW5kbGVyfSB3b3JrZXJcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUG9vbC5wcm90b3R5cGUuX3JlbW92ZVdvcmtlckZyb21MaXN0ID0gZnVuY3Rpb24od29ya2VyKSB7XG4gIC8vIHJlbW92ZSBmcm9tIHRoZSBsaXN0IHdpdGggd29ya2Vyc1xuICB2YXIgaW5kZXggPSB0aGlzLndvcmtlcnMuaW5kZXhPZih3b3JrZXIpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgdGhpcy53b3JrZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xvc2UgYWxsIGFjdGl2ZSB3b3JrZXJzLiBUYXNrcyBjdXJyZW50bHkgYmVpbmcgZXhlY3V0ZWQgd2lsbCBiZSBmaW5pc2hlZCBmaXJzdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXSAgIElmIGZhbHNlIChkZWZhdWx0KSwgdGhlIHdvcmtlcnMgYXJlIHRlcm1pbmF0ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyIGZpbmlzaGluZyBhbGwgdGFza3MgY3VycmVudGx5IGluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcy4gSWYgdHJ1ZSwgdGhlIHdvcmtlcnMgd2lsbCBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYXRlZCBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dF0gICAgICAgIElmIHByb3ZpZGVkIGFuZCBub24temVybywgd29ya2VyIHRlcm1pbmF0aW9uIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgdGltZW91dCBpZiB3b3JrZXIgcHJvY2VzcyBoYXMgbm90IGJlZW4gdGVybWluYXRlZC5cbiAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQsIEVycm9yPn1cbiAqL1xuUG9vbC5wcm90b3R5cGUudGVybWluYXRlID0gZnVuY3Rpb24gKGZvcmNlLCB0aW1lb3V0KSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgLy8gY2FuY2VsIGFueSBwZW5kaW5nIHRhc2tzXG4gIHRoaXMudGFza3MuZm9yRWFjaChmdW5jdGlvbiAodGFzaykge1xuICAgIHRhc2sucmVzb2x2ZXIucmVqZWN0KG5ldyBFcnJvcignUG9vbCB0ZXJtaW5hdGVkJykpO1xuICB9KTtcbiAgdGhpcy50YXNrcy5sZW5ndGggPSAwO1xuXG4gIHZhciBmID0gZnVuY3Rpb24gKHdvcmtlcikge1xuICAgIERFQlVHX1BPUlRfQUxMT0NBVE9SLnJlbGVhc2VQb3J0KHdvcmtlci5kZWJ1Z1BvcnQpO1xuICAgIHRoaXMuX3JlbW92ZVdvcmtlckZyb21MaXN0KHdvcmtlcik7XG4gIH07XG4gIHZhciByZW1vdmVXb3JrZXIgPSBmLmJpbmQodGhpcyk7XG5cbiAgdmFyIHByb21pc2VzID0gW107XG4gIHZhciB3b3JrZXJzID0gdGhpcy53b3JrZXJzLnNsaWNlKCk7XG4gIHdvcmtlcnMuZm9yRWFjaChmdW5jdGlvbiAod29ya2VyKSB7XG4gICAgdmFyIHRlcm1Qcm9taXNlID0gd29ya2VyLnRlcm1pbmF0ZUFuZE5vdGlmeShmb3JjZSwgdGltZW91dClcbiAgICAgIC50aGVuKHJlbW92ZVdvcmtlcilcbiAgICAgIC5hbHdheXMoZnVuY3Rpb24oKSB7XG4gICAgICAgIG1lLm9uVGVybWluYXRlV29ya2VyKHtcbiAgICAgICAgICBmb3JrQXJnczogd29ya2VyLmZvcmtBcmdzLFxuICAgICAgICAgIGZvcmtPcHRzOiB3b3JrZXIuZm9ya09wdHMsXG4gICAgICAgICAgd29ya2VyVGhyZWFkT3B0czogd29ya2VyLndvcmtlclRocmVhZE9wdHMsXG4gICAgICAgICAgc2NyaXB0OiB3b3JrZXIuc2NyaXB0XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgcHJvbWlzZXMucHVzaCh0ZXJtUHJvbWlzZSk7XG4gIH0pO1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBzdGF0aXN0aWNzIG9uIHRhc2tzIGFuZCB3b3JrZXJzLlxuICogQHJldHVybiB7e3RvdGFsV29ya2VyczogbnVtYmVyLCBidXN5V29ya2VyczogbnVtYmVyLCBpZGxlV29ya2VyczogbnVtYmVyLCBwZW5kaW5nVGFza3M6IG51bWJlciwgYWN0aXZlVGFza3M6IG51bWJlcn19IFJldHVybnMgYW4gb2JqZWN0IHdpdGggc3RhdGlzdGljc1xuICovXG5Qb29sLnByb3RvdHlwZS5zdGF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRvdGFsV29ya2VycyA9IHRoaXMud29ya2Vycy5sZW5ndGg7XG4gIHZhciBidXN5V29ya2VycyA9IHRoaXMud29ya2Vycy5maWx0ZXIoZnVuY3Rpb24gKHdvcmtlcikge1xuICAgIHJldHVybiB3b3JrZXIuYnVzeSgpO1xuICB9KS5sZW5ndGg7XG5cbiAgcmV0dXJuIHtcbiAgICB0b3RhbFdvcmtlcnM6ICB0b3RhbFdvcmtlcnMsXG4gICAgYnVzeVdvcmtlcnM6ICAgYnVzeVdvcmtlcnMsXG4gICAgaWRsZVdvcmtlcnM6ICAgdG90YWxXb3JrZXJzIC0gYnVzeVdvcmtlcnMsXG5cbiAgICBwZW5kaW5nVGFza3M6ICB0aGlzLnRhc2tzLmxlbmd0aCxcbiAgICBhY3RpdmVUYXNrczogICBidXN5V29ya2Vyc1xuICB9O1xufTtcblxuLyoqXG4gKiBFbnN1cmVzIHRoYXQgYSBtaW5pbXVtIG9mIG1pbldvcmtlcnMgaXMgdXAgYW5kIHJ1bm5pbmdcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUG9vbC5wcm90b3R5cGUuX2Vuc3VyZU1pbldvcmtlcnMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMubWluV29ya2Vycykge1xuICAgIGZvcih2YXIgaSA9IHRoaXMud29ya2Vycy5sZW5ndGg7IGkgPCB0aGlzLm1pbldvcmtlcnM7IGkrKykge1xuICAgICAgdGhpcy53b3JrZXJzLnB1c2godGhpcy5fY3JlYXRlV29ya2VySGFuZGxlcigpKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIG5ldyBXb3JrZXJIYW5kbGVyIGFuZCBwYXNzIGFsbCBvcHRpb25zLlxuICogQHJldHVybiB7V29ya2VySGFuZGxlcn1cbiAqIEBwcml2YXRlXG4gKi9cblBvb2wucHJvdG90eXBlLl9jcmVhdGVXb3JrZXJIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBvdmVycmlkZGVuUGFyYW1zID0gdGhpcy5vbkNyZWF0ZVdvcmtlcih7XG4gICAgZm9ya0FyZ3M6IHRoaXMuZm9ya0FyZ3MsXG4gICAgZm9ya09wdHM6IHRoaXMuZm9ya09wdHMsXG4gICAgd29ya2VyT3B0czogdGhpcy53b3JrZXJPcHRzLFxuICAgIHdvcmtlclRocmVhZE9wdHM6IHRoaXMud29ya2VyVGhyZWFkT3B0cyxcbiAgICBzY3JpcHQ6IHRoaXMuc2NyaXB0XG4gIH0pIHx8IHt9O1xuXG4gIHJldHVybiBuZXcgV29ya2VySGFuZGxlcihvdmVycmlkZGVuUGFyYW1zLnNjcmlwdCB8fCB0aGlzLnNjcmlwdCwge1xuICAgIGZvcmtBcmdzOiBvdmVycmlkZGVuUGFyYW1zLmZvcmtBcmdzIHx8IHRoaXMuZm9ya0FyZ3MsXG4gICAgZm9ya09wdHM6IG92ZXJyaWRkZW5QYXJhbXMuZm9ya09wdHMgfHwgdGhpcy5mb3JrT3B0cyxcbiAgICB3b3JrZXJPcHRzOiBvdmVycmlkZGVuUGFyYW1zLndvcmtlck9wdHMgfHwgdGhpcy53b3JrZXJPcHRzLFxuICAgIHdvcmtlclRocmVhZE9wdHM6IG92ZXJyaWRkZW5QYXJhbXMud29ya2VyVGhyZWFkT3B0cyB8fCB0aGlzLndvcmtlclRocmVhZE9wdHMsXG4gICAgZGVidWdQb3J0OiBERUJVR19QT1JUX0FMTE9DQVRPUi5uZXh0QXZhaWxhYmxlU3RhcnRpbmdBdCh0aGlzLmRlYnVnUG9ydFN0YXJ0KSxcbiAgICB3b3JrZXJUeXBlOiB0aGlzLndvcmtlclR5cGUsXG4gICAgd29ya2VyVGVybWluYXRlVGltZW91dDogdGhpcy53b3JrZXJUZXJtaW5hdGVUaW1lb3V0LFxuICB9KTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCB0aGUgbWF4V29ya2VycyBvcHRpb24gaXMgYW4gaW50ZWdlciA+PSAxXG4gKiBAcGFyYW0geyp9IG1heFdvcmtlcnNcbiAqIEByZXR1cm5zIHtib29sZWFufSByZXR1cm5zIHRydWUgbWF4V29ya2VycyBoYXMgYSB2YWxpZCB2YWx1ZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU1heFdvcmtlcnMobWF4V29ya2Vycykge1xuICBpZiAoIWlzTnVtYmVyKG1heFdvcmtlcnMpIHx8ICFpc0ludGVnZXIobWF4V29ya2VycykgfHwgbWF4V29ya2VycyA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPcHRpb24gbWF4V29ya2VycyBtdXN0IGJlIGFuIGludGVnZXIgbnVtYmVyID49IDEnKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IHRoZSBtaW5Xb3JrZXJzIG9wdGlvbiBpcyBhbiBpbnRlZ2VyID49IDBcbiAqIEBwYXJhbSB7Kn0gbWluV29ya2Vyc1xuICogQHJldHVybnMge2Jvb2xlYW59IHJldHVybnMgdHJ1ZSB3aGVuIG1pbldvcmtlcnMgaGFzIGEgdmFsaWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVNaW5Xb3JrZXJzKG1pbldvcmtlcnMpIHtcbiAgaWYgKCFpc051bWJlcihtaW5Xb3JrZXJzKSB8fCAhaXNJbnRlZ2VyKG1pbldvcmtlcnMpIHx8IG1pbldvcmtlcnMgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3B0aW9uIG1pbldvcmtlcnMgbXVzdCBiZSBhbiBpbnRlZ2VyIG51bWJlciA+PSAwJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYSB2YXJpYWJsZSBpcyBhIG51bWJlclxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59IHJldHVybnMgdHJ1ZSB3aGVuIHZhbHVlIGlzIGEgbnVtYmVyXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhIG51bWJlciBpcyBhbiBpbnRlZ2VyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYW4gaW50ZWdlclxuICovXG5mdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUpID09IHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2w7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/workerpool/src/Pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/workerpool/src/Promise.js":
/*!************************************************!*\
  !*** ./node_modules/workerpool/src/Promise.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Promise\n *\n * Inspired by https://gist.github.com/RubaXa/8501359 from RubaXa <trash@rubaxa.org>\n *\n * @param {Function} handler   Called as handler(resolve: Function, reject: Function)\n * @param {Promise} [parent]   Parent promise for propagation of cancel and timeout\n */\nfunction Promise(handler, parent) {\n  var me = this;\n\n  if (!(this instanceof Promise)) {\n    throw new SyntaxError('Constructor must be called with the new operator');\n  }\n\n  if (typeof handler !== 'function') {\n    throw new SyntaxError('Function parameter handler(resolve, reject) missing');\n  }\n\n  var _onSuccess = [];\n  var _onFail = [];\n\n  // status\n  this.resolved = false;\n  this.rejected = false;\n  this.pending = true;\n\n  /**\n   * Process onSuccess and onFail callbacks: add them to the queue.\n   * Once the promise is resolve, the function _promise is replace.\n   * @param {Function} onSuccess\n   * @param {Function} onFail\n   * @private\n   */\n  var _process = function (onSuccess, onFail) {\n    _onSuccess.push(onSuccess);\n    _onFail.push(onFail);\n  };\n\n  /**\n   * Add an onSuccess callback and optionally an onFail callback to the Promise\n   * @param {Function} onSuccess\n   * @param {Function} [onFail]\n   * @returns {Promise} promise\n   */\n  this.then = function (onSuccess, onFail) {\n    return new Promise(function (resolve, reject) {\n      var s = onSuccess ? _then(onSuccess, resolve, reject) : resolve;\n      var f = onFail    ? _then(onFail,    resolve, reject) : reject;\n\n      _process(s, f);\n    }, me);\n  };\n\n  /**\n   * Resolve the promise\n   * @param {*} result\n   * @type {Function}\n   */\n  var _resolve = function (result) {\n    // update status\n    me.resolved = true;\n    me.rejected = false;\n    me.pending = false;\n\n    _onSuccess.forEach(function (fn) {\n      fn(result);\n    });\n\n    _process = function (onSuccess, onFail) {\n      onSuccess(result);\n    };\n\n    _resolve = _reject = function () { };\n\n    return me;\n  };\n\n  /**\n   * Reject the promise\n   * @param {Error} error\n   * @type {Function}\n   */\n  var _reject = function (error) {\n    // update status\n    me.resolved = false;\n    me.rejected = true;\n    me.pending = false;\n\n    _onFail.forEach(function (fn) {\n      fn(error);\n    });\n\n    _process = function (onSuccess, onFail) {\n      onFail(error);\n    };\n\n    _resolve = _reject = function () { }\n\n    return me;\n  };\n\n  /**\n   * Cancel te promise. This will reject the promise with a CancellationError\n   * @returns {Promise} self\n   */\n  this.cancel = function () {\n    if (parent) {\n      parent.cancel();\n    }\n    else {\n      _reject(new CancellationError());\n    }\n\n    return me;\n  };\n\n  /**\n   * Set a timeout for the promise. If the promise is not resolved within\n   * the time, the promise will be cancelled and a TimeoutError is thrown.\n   * If the promise is resolved in time, the timeout is removed.\n   * @param {number} delay     Delay in milliseconds\n   * @returns {Promise} self\n   */\n  this.timeout = function (delay) {\n    if (parent) {\n      parent.timeout(delay);\n    }\n    else {\n      var timer = setTimeout(function () {\n        _reject(new TimeoutError('Promise timed out after ' + delay + ' ms'));\n      }, delay);\n\n      me.always(function () {\n        clearTimeout(timer);\n      });\n    }\n\n    return me;\n  };\n\n  // attach handler passing the resolve and reject functions\n  handler(function (result) {\n    _resolve(result);\n  }, function (error) {\n    _reject(error);\n  });\n}\n\n/**\n * Execute given callback, then call resolve/reject based on the returned result\n * @param {Function} callback\n * @param {Function} resolve\n * @param {Function} reject\n * @returns {Function}\n * @private\n */\nfunction _then(callback, resolve, reject) {\n  return function (result) {\n    try {\n      var res = callback(result);\n      if (res && typeof res.then === 'function' && typeof res['catch'] === 'function') {\n        // method returned a promise\n        res.then(resolve, reject);\n      }\n      else {\n        resolve(res);\n      }\n    }\n    catch (error) {\n      reject(error);\n    }\n  }\n}\n\n/**\n * Add an onFail callback to the Promise\n * @param {Function} onFail\n * @returns {Promise} promise\n */\nPromise.prototype['catch'] = function (onFail) {\n  return this.then(null, onFail);\n};\n\n// TODO: add support for Promise.catch(Error, callback)\n// TODO: add support for Promise.catch(Error, Error, callback)\n\n/**\n * Execute given callback when the promise either resolves or rejects.\n * @param {Function} fn\n * @returns {Promise} promise\n */\nPromise.prototype.always = function (fn) {\n  return this.then(fn, fn);\n};\n\n/**\n * Create a promise which resolves when all provided promises are resolved,\n * and fails when any of the promises resolves.\n * @param {Promise[]} promises\n * @returns {Promise} promise\n */\nPromise.all = function (promises){\n  return new Promise(function (resolve, reject) {\n    var remaining = promises.length,\n        results = [];\n\n    if (remaining) {\n      promises.forEach(function (p, i) {\n        p.then(function (result) {\n          results[i] = result;\n          remaining--;\n          if (remaining == 0) {\n            resolve(results);\n          }\n        }, function (error) {\n          remaining = 0;\n          reject(error);\n        });\n      });\n    }\n    else {\n      resolve(results);\n    }\n  });\n};\n\n/**\n * Create a promise resolver\n * @returns {{promise: Promise, resolve: Function, reject: Function}} resolver\n */\nPromise.defer = function () {\n  var resolver = {};\n\n  resolver.promise = new Promise(function (resolve, reject) {\n    resolver.resolve = resolve;\n    resolver.reject = reject;\n  });\n\n  return resolver;\n};\n\n/**\n * Create a cancellation error\n * @param {String} [message]\n * @extends Error\n */\nfunction CancellationError(message) {\n  this.message = message || 'promise cancelled';\n  this.stack = (new Error()).stack;\n}\n\nCancellationError.prototype = new Error();\nCancellationError.prototype.constructor = Error;\nCancellationError.prototype.name = 'CancellationError';\n\nPromise.CancellationError = CancellationError;\n\n\n/**\n * Create a timeout error\n * @param {String} [message]\n * @extends Error\n */\nfunction TimeoutError(message) {\n  this.message = message || 'timeout exceeded';\n  this.stack = (new Error()).stack;\n}\n\nTimeoutError.prototype = new Error();\nTimeoutError.prototype.constructor = Error;\nTimeoutError.prototype.name = 'TimeoutError';\n\nPromise.TimeoutError = TimeoutError;\n\n\nmodule.exports = Promise;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd29ya2VycG9vbC9zcmMvUHJvbWlzZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxjQUFjLHdEQUF3RDtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvd29ya2VycG9vbC9zcmMvUHJvbWlzZS5qcz9kYjI1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBQcm9taXNlXG4gKlxuICogSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vUnViYVhhLzg1MDEzNTkgZnJvbSBSdWJhWGEgPHRyYXNoQHJ1YmF4YS5vcmc+XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciAgIENhbGxlZCBhcyBoYW5kbGVyKHJlc29sdmU6IEZ1bmN0aW9uLCByZWplY3Q6IEZ1bmN0aW9uKVxuICogQHBhcmFtIHtQcm9taXNlfSBbcGFyZW50XSAgIFBhcmVudCBwcm9taXNlIGZvciBwcm9wYWdhdGlvbiBvZiBjYW5jZWwgYW5kIHRpbWVvdXRcbiAqL1xuZnVuY3Rpb24gUHJvbWlzZShoYW5kbGVyLCBwYXJlbnQpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdGdW5jdGlvbiBwYXJhbWV0ZXIgaGFuZGxlcihyZXNvbHZlLCByZWplY3QpIG1pc3NpbmcnKTtcbiAgfVxuXG4gIHZhciBfb25TdWNjZXNzID0gW107XG4gIHZhciBfb25GYWlsID0gW107XG5cbiAgLy8gc3RhdHVzXG4gIHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWplY3RlZCA9IGZhbHNlO1xuICB0aGlzLnBlbmRpbmcgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBQcm9jZXNzIG9uU3VjY2VzcyBhbmQgb25GYWlsIGNhbGxiYWNrczogYWRkIHRoZW0gdG8gdGhlIHF1ZXVlLlxuICAgKiBPbmNlIHRoZSBwcm9taXNlIGlzIHJlc29sdmUsIHRoZSBmdW5jdGlvbiBfcHJvbWlzZSBpcyByZXBsYWNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblN1Y2Nlc3NcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25GYWlsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YXIgX3Byb2Nlc3MgPSBmdW5jdGlvbiAob25TdWNjZXNzLCBvbkZhaWwpIHtcbiAgICBfb25TdWNjZXNzLnB1c2gob25TdWNjZXNzKTtcbiAgICBfb25GYWlsLnB1c2gob25GYWlsKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGFuIG9uU3VjY2VzcyBjYWxsYmFjayBhbmQgb3B0aW9uYWxseSBhbiBvbkZhaWwgY2FsbGJhY2sgdG8gdGhlIFByb21pc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25TdWNjZXNzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkZhaWxdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlXG4gICAqL1xuICB0aGlzLnRoZW4gPSBmdW5jdGlvbiAob25TdWNjZXNzLCBvbkZhaWwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHMgPSBvblN1Y2Nlc3MgPyBfdGhlbihvblN1Y2Nlc3MsIHJlc29sdmUsIHJlamVjdCkgOiByZXNvbHZlO1xuICAgICAgdmFyIGYgPSBvbkZhaWwgICAgPyBfdGhlbihvbkZhaWwsICAgIHJlc29sdmUsIHJlamVjdCkgOiByZWplY3Q7XG5cbiAgICAgIF9wcm9jZXNzKHMsIGYpO1xuICAgIH0sIG1lKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVzb2x2ZSB0aGUgcHJvbWlzZVxuICAgKiBAcGFyYW0geyp9IHJlc3VsdFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICB2YXIgX3Jlc29sdmUgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgLy8gdXBkYXRlIHN0YXR1c1xuICAgIG1lLnJlc29sdmVkID0gdHJ1ZTtcbiAgICBtZS5yZWplY3RlZCA9IGZhbHNlO1xuICAgIG1lLnBlbmRpbmcgPSBmYWxzZTtcblxuICAgIF9vblN1Y2Nlc3MuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgIGZuKHJlc3VsdCk7XG4gICAgfSk7XG5cbiAgICBfcHJvY2VzcyA9IGZ1bmN0aW9uIChvblN1Y2Nlc3MsIG9uRmFpbCkge1xuICAgICAgb25TdWNjZXNzKHJlc3VsdCk7XG4gICAgfTtcblxuICAgIF9yZXNvbHZlID0gX3JlamVjdCA9IGZ1bmN0aW9uICgpIHsgfTtcblxuICAgIHJldHVybiBtZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVqZWN0IHRoZSBwcm9taXNlXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIHZhciBfcmVqZWN0ID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgLy8gdXBkYXRlIHN0YXR1c1xuICAgIG1lLnJlc29sdmVkID0gZmFsc2U7XG4gICAgbWUucmVqZWN0ZWQgPSB0cnVlO1xuICAgIG1lLnBlbmRpbmcgPSBmYWxzZTtcblxuICAgIF9vbkZhaWwuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgIGZuKGVycm9yKTtcbiAgICB9KTtcblxuICAgIF9wcm9jZXNzID0gZnVuY3Rpb24gKG9uU3VjY2Vzcywgb25GYWlsKSB7XG4gICAgICBvbkZhaWwoZXJyb3IpO1xuICAgIH07XG5cbiAgICBfcmVzb2x2ZSA9IF9yZWplY3QgPSBmdW5jdGlvbiAoKSB7IH1cblxuICAgIHJldHVybiBtZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FuY2VsIHRlIHByb21pc2UuIFRoaXMgd2lsbCByZWplY3QgdGhlIHByb21pc2Ugd2l0aCBhIENhbmNlbGxhdGlvbkVycm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBzZWxmXG4gICAqL1xuICB0aGlzLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnQuY2FuY2VsKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgX3JlamVjdChuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSB0aW1lb3V0IGZvciB0aGUgcHJvbWlzZS4gSWYgdGhlIHByb21pc2UgaXMgbm90IHJlc29sdmVkIHdpdGhpblxuICAgKiB0aGUgdGltZSwgdGhlIHByb21pc2Ugd2lsbCBiZSBjYW5jZWxsZWQgYW5kIGEgVGltZW91dEVycm9yIGlzIHRocm93bi5cbiAgICogSWYgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgaW4gdGltZSwgdGhlIHRpbWVvdXQgaXMgcmVtb3ZlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5ICAgICBEZWxheSBpbiBtaWxsaXNlY29uZHNcbiAgICogQHJldHVybnMge1Byb21pc2V9IHNlbGZcbiAgICovXG4gIHRoaXMudGltZW91dCA9IGZ1bmN0aW9uIChkZWxheSkge1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC50aW1lb3V0KGRlbGF5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3JlamVjdChuZXcgVGltZW91dEVycm9yKCdQcm9taXNlIHRpbWVkIG91dCBhZnRlciAnICsgZGVsYXkgKyAnIG1zJykpO1xuICAgICAgfSwgZGVsYXkpO1xuXG4gICAgICBtZS5hbHdheXMoZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lO1xuICB9O1xuXG4gIC8vIGF0dGFjaCBoYW5kbGVyIHBhc3NpbmcgdGhlIHJlc29sdmUgYW5kIHJlamVjdCBmdW5jdGlvbnNcbiAgaGFuZGxlcihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgX3Jlc29sdmUocmVzdWx0KTtcbiAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgX3JlamVjdChlcnJvcik7XG4gIH0pO1xufVxuXG4vKipcbiAqIEV4ZWN1dGUgZ2l2ZW4gY2FsbGJhY2ssIHRoZW4gY2FsbCByZXNvbHZlL3JlamVjdCBiYXNlZCBvbiB0aGUgcmV0dXJuZWQgcmVzdWx0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0XG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfdGhlbihjYWxsYmFjaywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciByZXMgPSBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHJlc1snY2F0Y2gnXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBtZXRob2QgcmV0dXJuZWQgYSBwcm9taXNlXG4gICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWRkIGFuIG9uRmFpbCBjYWxsYmFjayB0byB0aGUgUHJvbWlzZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gb25GYWlsXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZVxuICovXG5Qcm9taXNlLnByb3RvdHlwZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uIChvbkZhaWwpIHtcbiAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvbkZhaWwpO1xufTtcblxuLy8gVE9ETzogYWRkIHN1cHBvcnQgZm9yIFByb21pc2UuY2F0Y2goRXJyb3IsIGNhbGxiYWNrKVxuLy8gVE9ETzogYWRkIHN1cHBvcnQgZm9yIFByb21pc2UuY2F0Y2goRXJyb3IsIEVycm9yLCBjYWxsYmFjaylcblxuLyoqXG4gKiBFeGVjdXRlIGdpdmVuIGNhbGxiYWNrIHdoZW4gdGhlIHByb21pc2UgZWl0aGVyIHJlc29sdmVzIG9yIHJlamVjdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2VcbiAqL1xuUHJvbWlzZS5wcm90b3R5cGUuYWx3YXlzID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiB0aGlzLnRoZW4oZm4sIGZuKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIGFsbCBwcm92aWRlZCBwcm9taXNlcyBhcmUgcmVzb2x2ZWQsXG4gKiBhbmQgZmFpbHMgd2hlbiBhbnkgb2YgdGhlIHByb21pc2VzIHJlc29sdmVzLlxuICogQHBhcmFtIHtQcm9taXNlW119IHByb21pc2VzXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZVxuICovXG5Qcm9taXNlLmFsbCA9IGZ1bmN0aW9uIChwcm9taXNlcyl7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlbWFpbmluZyA9IHByb21pc2VzLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuXG4gICAgaWYgKHJlbWFpbmluZykge1xuICAgICAgcHJvbWlzZXMuZm9yRWFjaChmdW5jdGlvbiAocCwgaSkge1xuICAgICAgICBwLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdHNbaV0gPSByZXN1bHQ7XG4gICAgICAgICAgcmVtYWluaW5nLS07XG4gICAgICAgICAgaWYgKHJlbWFpbmluZyA9PSAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgcmVtYWluaW5nID0gMDtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJlc29sdmUocmVzdWx0cyk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgcHJvbWlzZSByZXNvbHZlclxuICogQHJldHVybnMge3twcm9taXNlOiBQcm9taXNlLCByZXNvbHZlOiBGdW5jdGlvbiwgcmVqZWN0OiBGdW5jdGlvbn19IHJlc29sdmVyXG4gKi9cblByb21pc2UuZGVmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByZXNvbHZlciA9IHt9O1xuXG4gIHJlc29sdmVyLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVzb2x2ZXIucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgcmVzb2x2ZXIucmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcblxuICByZXR1cm4gcmVzb2x2ZXI7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGNhbmNlbGxhdGlvbiBlcnJvclxuICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXVxuICogQGV4dGVuZHMgRXJyb3JcbiAqL1xuZnVuY3Rpb24gQ2FuY2VsbGF0aW9uRXJyb3IobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdwcm9taXNlIGNhbmNlbGxlZCc7XG4gIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xufVxuXG5DYW5jZWxsYXRpb25FcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbkNhbmNlbGxhdGlvbkVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVycm9yO1xuQ2FuY2VsbGF0aW9uRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnQ2FuY2VsbGF0aW9uRXJyb3InO1xuXG5Qcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yID0gQ2FuY2VsbGF0aW9uRXJyb3I7XG5cblxuLyoqXG4gKiBDcmVhdGUgYSB0aW1lb3V0IGVycm9yXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdXG4gKiBAZXh0ZW5kcyBFcnJvclxuICovXG5mdW5jdGlvbiBUaW1lb3V0RXJyb3IobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICd0aW1lb3V0IGV4Y2VlZGVkJztcbiAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG59XG5cblRpbWVvdXRFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblRpbWVvdXRFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFcnJvcjtcblRpbWVvdXRFcnJvci5wcm90b3R5cGUubmFtZSA9ICdUaW1lb3V0RXJyb3InO1xuXG5Qcm9taXNlLlRpbWVvdXRFcnJvciA9IFRpbWVvdXRFcnJvcjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/workerpool/src/Promise.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/workerpool/src/WorkerHandler.js":
/*!******************************************************!*\
  !*** ./node_modules/workerpool/src/WorkerHandler.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Promise = __webpack_require__(/*! ./Promise */ \"(ssr)/./node_modules/workerpool/src/Promise.js\");\nvar environment = __webpack_require__(/*! ./environment */ \"(ssr)/./node_modules/workerpool/src/environment.js\");\nvar requireFoolWebpack = __webpack_require__(/*! ./requireFoolWebpack */ \"(ssr)/./node_modules/workerpool/src/requireFoolWebpack.js\");\n\n/**\n * Special message sent by parent which causes a child process worker to terminate itself.\n * Not a \"message object\"; this string is the entire message.\n */\nvar TERMINATE_METHOD_ID = '__workerpool-terminate__';\n\nfunction ensureWorkerThreads() {\n  var WorkerThreads = tryRequireWorkerThreads()\n  if (!WorkerThreads) {\n    throw new Error('WorkerPool: workerType = \\'thread\\' is not supported, Node >= 11.7.0 required')\n  }\n\n  return WorkerThreads;\n}\n\n// check whether Worker is supported by the browser\nfunction ensureWebWorker() {\n  // Workaround for a bug in PhantomJS (Or QtWebkit): https://github.com/ariya/phantomjs/issues/14534\n  if (typeof Worker !== 'function' && (typeof Worker !== 'object' || typeof Worker.prototype.constructor !== 'function')) {\n    throw new Error('WorkerPool: Web Workers not supported');\n  }\n}\n\nfunction tryRequireWorkerThreads() {\n  try {\n    return requireFoolWebpack('worker_threads');\n  } catch(error) {\n    if (typeof error === 'object' && error !== null && error.code === 'MODULE_NOT_FOUND') {\n      // no worker_threads available (old version of node.js)\n      return null;\n    } else {\n      throw error;\n    }\n  }\n}\n\n// get the default worker script\nfunction getDefaultWorker() {\n  if (environment.platform === 'browser') {\n    // test whether the browser supports all features that we need\n    if (typeof Blob === 'undefined') {\n      throw new Error('Blob not supported by the browser');\n    }\n    if (!window.URL || typeof window.URL.createObjectURL !== 'function') {\n      throw new Error('URL.createObjectURL not supported by the browser');\n    }\n\n    // use embedded worker.js\n    var blob = new Blob([__webpack_require__(/*! ./generated/embeddedWorker */ \"(ssr)/./node_modules/workerpool/src/generated/embeddedWorker.js\")], {type: 'text/javascript'});\n    return window.URL.createObjectURL(blob);\n  }\n  else {\n    // use external worker.js in current directory\n    return __dirname + '/worker.js';\n  }\n}\n\nfunction setupWorker(script, options) {\n  if (options.workerType === 'web') { // browser only\n    ensureWebWorker();\n    return setupBrowserWorker(script, options.workerOpts, Worker);\n  } else if (options.workerType === 'thread') { // node.js only\n    WorkerThreads = ensureWorkerThreads();\n    return setupWorkerThreadWorker(script, WorkerThreads, options.workerThreadOpts);\n  } else if (options.workerType === 'process' || !options.workerType) { // node.js only\n    return setupProcessWorker(script, resolveForkOptions(options), requireFoolWebpack('child_process'));\n  } else { // options.workerType === 'auto' or undefined\n    if (environment.platform === 'browser') {\n      ensureWebWorker();\n      return setupBrowserWorker(script, options.workerOpts, Worker);\n    }\n    else { // environment.platform === 'node'\n      var WorkerThreads = tryRequireWorkerThreads();\n      if (WorkerThreads) {\n        return setupWorkerThreadWorker(script, WorkerThreads, options.workerThreadOpts);\n      } else {\n        return setupProcessWorker(script, resolveForkOptions(options), requireFoolWebpack('child_process'));\n      }\n    }\n  }\n}\n\nfunction setupBrowserWorker(script, workerOpts, Worker) {\n  // create the web worker\n  var worker = new Worker(script, workerOpts);\n\n  worker.isBrowserWorker = true;\n  // add node.js API to the web worker\n  worker.on = function (event, callback) {\n    this.addEventListener(event, function (message) {\n      callback(message.data);\n    });\n  };\n  worker.send = function (message, transfer) {\n    this.postMessage(message, transfer);\n  };\n  return worker;\n}\n\nfunction setupWorkerThreadWorker(script, WorkerThreads, workerThreadOptions) {\n  var worker = new WorkerThreads.Worker(script, {\n    stdout: false, // automatically pipe worker.STDOUT to process.STDOUT\n    stderr: false,  // automatically pipe worker.STDERR to process.STDERR\n    ...workerThreadOptions\n  });\n  worker.isWorkerThread = true;\n  worker.send = function(message, transfer) {\n    this.postMessage(message, transfer);\n  };\n\n  worker.kill = function() {\n    this.terminate();\n    return true;\n  };\n\n  worker.disconnect = function() {\n    this.terminate();\n  };\n\n  return worker;\n}\n\nfunction setupProcessWorker(script, options, child_process) {\n  // no WorkerThreads, fallback to sub-process based workers\n  var worker = child_process.fork(\n    script,\n    options.forkArgs,\n    options.forkOpts\n  );\n\n  // ignore transfer argument since it is not supported by process\n  var send = worker.send;\n  worker.send = function (message) {\n    return send.call(worker, message);\n  };\n\n  worker.isChildProcess = true;\n  return worker;\n}\n\n// add debug flags to child processes if the node inspector is active\nfunction resolveForkOptions(opts) {\n  opts = opts || {};\n\n  var processExecArgv = process.execArgv.join(' ');\n  var inspectorActive = processExecArgv.indexOf('--inspect') !== -1;\n  var debugBrk = processExecArgv.indexOf('--debug-brk') !== -1;\n\n  var execArgv = [];\n  if (inspectorActive) {\n    execArgv.push('--inspect=' + opts.debugPort);\n\n    if (debugBrk) {\n      execArgv.push('--debug-brk');\n    }\n  }\n\n  process.execArgv.forEach(function(arg) {\n    if (arg.indexOf('--max-old-space-size') > -1) {\n      execArgv.push(arg)\n    }\n  })\n\n  return Object.assign({}, opts, {\n    forkArgs: opts.forkArgs,\n    forkOpts: Object.assign({}, opts.forkOpts, {\n      execArgv: (opts.forkOpts && opts.forkOpts.execArgv || [])\n      .concat(execArgv)\n    })\n  });\n}\n\n/**\n * Converts a serialized error to Error\n * @param {Object} obj Error that has been serialized and parsed to object\n * @return {Error} The equivalent Error.\n */\nfunction objectToError (obj) {\n  var temp = new Error('')\n  var props = Object.keys(obj)\n\n  for (var i = 0; i < props.length; i++) {\n    temp[props[i]] = obj[props[i]]\n  }\n\n  return temp\n}\n\n/**\n * A WorkerHandler controls a single worker. This worker can be a child process\n * on node.js or a WebWorker in a browser environment.\n * @param {String} [script] If no script is provided, a default worker with a\n *                          function run will be created.\n * @param {WorkerPoolOptions} _options See docs\n * @constructor\n */\nfunction WorkerHandler(script, _options) {\n  var me = this;\n  var options = _options || {};\n\n  this.script = script || getDefaultWorker();\n  this.worker = setupWorker(this.script, options);\n  this.debugPort = options.debugPort;\n  this.forkOpts = options.forkOpts;\n  this.forkArgs = options.forkArgs;\n  this.workerOpts = options.workerOpts;\n  this.workerThreadOpts = options.workerThreadOpts\n  this.workerTerminateTimeout = options.workerTerminateTimeout;\n\n  // The ready message is only sent if the worker.add method is called (And the default script is not used)\n  if (!script) {\n    this.worker.ready = true;\n  }\n\n  // queue for requests that are received before the worker is ready\n  this.requestQueue = [];\n  this.worker.on('message', function (response) {\n    if (me.terminated) {\n      return;\n    }\n    if (typeof response === 'string' && response === 'ready') {\n      me.worker.ready = true;\n      dispatchQueuedRequests();\n    } else {\n      // find the task from the processing queue, and run the tasks callback\n      var id = response.id;\n      var task = me.processing[id];\n      if (task !== undefined) {\n        if (response.isEvent) {\n          if (task.options && typeof task.options.on === 'function') {\n            task.options.on(response.payload);\n          }\n        } else {\n          // remove the task from the queue\n          delete me.processing[id];\n\n          // test if we need to terminate\n          if (me.terminating === true) {\n            // complete worker termination if all tasks are finished\n            me.terminate();\n          }\n\n          // resolve the task's promise\n          if (response.error) {\n            task.resolver.reject(objectToError(response.error));\n          }\n          else {\n            task.resolver.resolve(response.result);\n          }\n        }\n      }\n    }\n  });\n\n  // reject all running tasks on worker error\n  function onError(error) {\n    me.terminated = true;\n\n    for (var id in me.processing) {\n      if (me.processing[id] !== undefined) {\n        me.processing[id].resolver.reject(error);\n      }\n    }\n    me.processing = Object.create(null);\n  }\n\n  // send all queued requests to worker\n  function dispatchQueuedRequests()\n  {\n    for(const request of me.requestQueue.splice(0)) {\n      me.worker.send(request.message, request.transfer);\n    }\n  }\n\n  var worker = this.worker;\n  // listen for worker messages error and exit\n  this.worker.on('error', onError);\n  this.worker.on('exit', function (exitCode, signalCode) {\n    var message = 'Workerpool Worker terminated Unexpectedly\\n';\n\n    message += '    exitCode: `' + exitCode + '`\\n';\n    message += '    signalCode: `' + signalCode + '`\\n';\n\n    message += '    workerpool.script: `' +  me.script + '`\\n';\n    message += '    spawnArgs: `' +  worker.spawnargs + '`\\n';\n    message += '    spawnfile: `' + worker.spawnfile + '`\\n'\n\n    message += '    stdout: `' + worker.stdout + '`\\n'\n    message += '    stderr: `' + worker.stderr + '`\\n'\n\n    onError(new Error(message));\n  });\n\n  this.processing = Object.create(null); // queue with tasks currently in progress\n\n  this.terminating = false;\n  this.terminated = false;\n  this.cleaning = false;\n  this.terminationHandler = null;\n  this.lastId = 0;\n}\n\n/**\n * Get a list with methods available on the worker.\n * @return {Promise.<String[], Error>} methods\n */\nWorkerHandler.prototype.methods = function () {\n  return this.exec('methods');\n};\n\n/**\n * Execute a method with given parameters on the worker\n * @param {String} method\n * @param {Array} [params]\n * @param {{resolve: Function, reject: Function}} [resolver]\n * @param {ExecOptions}  [options]\n * @return {Promise.<*, Error>} result\n */\nWorkerHandler.prototype.exec = function(method, params, resolver, options) {\n  if (!resolver) {\n    resolver = Promise.defer();\n  }\n\n  // generate a unique id for the task\n  var id = ++this.lastId;\n\n  // register a new task as being in progress\n  this.processing[id] = {\n    id: id,\n    resolver: resolver,\n    options: options\n  };\n\n  // build a JSON-RPC request\n  var request = {\n    message: {\n      id: id,\n      method: method,\n      params: params\n    },\n    transfer: options && options.transfer\n  };\n\n  if (this.terminated) {\n    resolver.reject(new Error('Worker is terminated'));\n  } else if (this.worker.ready) {\n    // send the request to the worker\n    this.worker.send(request.message, request.transfer);\n  } else {\n    this.requestQueue.push(request);\n  }\n\n  // on cancellation, force the worker to terminate\n  var me = this;\n  return resolver.promise.catch(function (error) {\n    if (error instanceof Promise.CancellationError || error instanceof Promise.TimeoutError) {\n      // remove this task from the queue. It is already rejected (hence this\n      // catch event), and else it will be rejected again when terminating\n      delete me.processing[id];\n\n      // terminate worker\n      return me.terminateAndNotify(true)\n        .then(function() {\n          throw error;\n        }, function(err) {\n          throw err;\n        });\n    } else {\n      throw error;\n    }\n  })\n};\n\n/**\n * Test whether the worker is processing any tasks or cleaning up before termination.\n * @return {boolean} Returns true if the worker is busy\n */\nWorkerHandler.prototype.busy = function () {\n  return this.cleaning || Object.keys(this.processing).length > 0;\n};\n\n/**\n * Terminate the worker.\n * @param {boolean} [force=false]   If false (default), the worker is terminated\n *                                  after finishing all tasks currently in\n *                                  progress. If true, the worker will be\n *                                  terminated immediately.\n * @param {function} [callback=null] If provided, will be called when process terminates.\n */\nWorkerHandler.prototype.terminate = function (force, callback) {\n  var me = this;\n  if (force) {\n    // cancel all tasks in progress\n    for (var id in this.processing) {\n      if (this.processing[id] !== undefined) {\n        this.processing[id].resolver.reject(new Error('Worker terminated'));\n      }\n    }\n    this.processing = Object.create(null);\n  }\n\n  if (typeof callback === 'function') {\n    this.terminationHandler = callback;\n  }\n  if (!this.busy()) {\n    // all tasks are finished. kill the worker\n    var cleanup = function(err) {\n      me.terminated = true;\n      me.cleaning = false;\n      if (me.worker != null && me.worker.removeAllListeners) {\n        // removeAllListeners is only available for child_process\n        me.worker.removeAllListeners('message');\n      }\n      me.worker = null;\n      me.terminating = false;\n      if (me.terminationHandler) {\n        me.terminationHandler(err, me);\n      } else if (err) {\n        throw err;\n      }\n    }\n\n    if (this.worker) {\n      if (typeof this.worker.kill === 'function') {\n        if (this.worker.killed) {\n          cleanup(new Error('worker already killed!'));\n          return;\n        }\n\n        // child process and worker threads\n        var cleanExitTimeout = setTimeout(function() {\n          if (me.worker) {\n            me.worker.kill();\n          }\n        }, this.workerTerminateTimeout);\n\n        this.worker.once('exit', function() {\n          clearTimeout(cleanExitTimeout);\n          if (me.worker) {\n            me.worker.killed = true;\n          }\n          cleanup();\n        });\n\n        if (this.worker.ready) {\n          this.worker.send(TERMINATE_METHOD_ID);\n        } else {\n          this.requestQueue.push({ message: TERMINATE_METHOD_ID });\n        }\n\n        // mark that the worker is cleaning up resources\n        // to prevent new tasks from being executed\n        this.cleaning = true;\n        return;\n      }\n      else if (typeof this.worker.terminate === 'function') {\n        this.worker.terminate(); // web worker\n        this.worker.killed = true;\n      }\n      else {\n        throw new Error('Failed to terminate worker');\n      }\n    }\n    cleanup();\n  }\n  else {\n    // we can't terminate immediately, there are still tasks being executed\n    this.terminating = true;\n  }\n};\n\n/**\n * Terminate the worker, returning a Promise that resolves when the termination has been done.\n * @param {boolean} [force=false]   If false (default), the worker is terminated\n *                                  after finishing all tasks currently in\n *                                  progress. If true, the worker will be\n *                                  terminated immediately.\n * @param {number} [timeout]        If provided and non-zero, worker termination promise will be rejected\n *                                  after timeout if worker process has not been terminated.\n * @return {Promise.<WorkerHandler, Error>}\n */\nWorkerHandler.prototype.terminateAndNotify = function (force, timeout) {\n  var resolver = Promise.defer();\n  if (timeout) {\n    resolver.promise.timeout(timeout);\n  }\n  this.terminate(force, function(err, worker) {\n    if (err) {\n      resolver.reject(err);\n    } else {\n      resolver.resolve(worker);\n    }\n  });\n  return resolver.promise;\n};\n\nmodule.exports = WorkerHandler;\nmodule.exports._tryRequireWorkerThreads = tryRequireWorkerThreads;\nmodule.exports._setupProcessWorker = setupProcessWorker;\nmodule.exports._setupBrowserWorker = setupBrowserWorker;\nmodule.exports._setupWorkerThreadWorker = setupWorkerThreadWorker;\nmodule.exports.ensureWorkerThreads = ensureWorkerThreads;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd29ya2VycG9vbC9zcmMvV29ya2VySGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsaUVBQVc7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMseUVBQWU7QUFDekMseUJBQXlCLG1CQUFPLENBQUMsdUZBQXNCOztBQUV2RDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyxtR0FBNEIsS0FBSyx3QkFBd0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLElBQUksNENBQTRDO0FBQ2hEO0FBQ0E7QUFDQSxJQUFJLG9FQUFvRTtBQUN4RTtBQUNBLElBQUksT0FBTztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCx5QkFBeUI7QUFDekI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUgseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksc0NBQXNDO0FBQ2xELFdBQVcsY0FBYztBQUN6QixZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBVTtBQUNWLG1DQUFtQyw4QkFBOEI7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkMsa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQyx1Q0FBdUM7QUFDdkMsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy93b3JrZXJwb29sL3NyYy9Xb3JrZXJIYW5kbGVyLmpzP2JlNmYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vUHJvbWlzZScpO1xudmFyIGVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9lbnZpcm9ubWVudCcpO1xudmFyIHJlcXVpcmVGb29sV2VicGFjayA9IHJlcXVpcmUoJy4vcmVxdWlyZUZvb2xXZWJwYWNrJyk7XG5cbi8qKlxuICogU3BlY2lhbCBtZXNzYWdlIHNlbnQgYnkgcGFyZW50IHdoaWNoIGNhdXNlcyBhIGNoaWxkIHByb2Nlc3Mgd29ya2VyIHRvIHRlcm1pbmF0ZSBpdHNlbGYuXG4gKiBOb3QgYSBcIm1lc3NhZ2Ugb2JqZWN0XCI7IHRoaXMgc3RyaW5nIGlzIHRoZSBlbnRpcmUgbWVzc2FnZS5cbiAqL1xudmFyIFRFUk1JTkFURV9NRVRIT0RfSUQgPSAnX193b3JrZXJwb29sLXRlcm1pbmF0ZV9fJztcblxuZnVuY3Rpb24gZW5zdXJlV29ya2VyVGhyZWFkcygpIHtcbiAgdmFyIFdvcmtlclRocmVhZHMgPSB0cnlSZXF1aXJlV29ya2VyVGhyZWFkcygpXG4gIGlmICghV29ya2VyVGhyZWFkcykge1xuICAgIHRocm93IG5ldyBFcnJvcignV29ya2VyUG9vbDogd29ya2VyVHlwZSA9IFxcJ3RocmVhZFxcJyBpcyBub3Qgc3VwcG9ydGVkLCBOb2RlID49IDExLjcuMCByZXF1aXJlZCcpXG4gIH1cblxuICByZXR1cm4gV29ya2VyVGhyZWFkcztcbn1cblxuLy8gY2hlY2sgd2hldGhlciBXb3JrZXIgaXMgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyXG5mdW5jdGlvbiBlbnN1cmVXZWJXb3JrZXIoKSB7XG4gIC8vIFdvcmthcm91bmQgZm9yIGEgYnVnIGluIFBoYW50b21KUyAoT3IgUXRXZWJraXQpOiBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xNDUzNFxuICBpZiAodHlwZW9mIFdvcmtlciAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIFdvcmtlciAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIFdvcmtlci5wcm90b3R5cGUuY29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXb3JrZXJQb29sOiBXZWIgV29ya2VycyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5UmVxdWlyZVdvcmtlclRocmVhZHMoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHJlcXVpcmVGb29sV2VicGFjaygnd29ya2VyX3RocmVhZHMnKTtcbiAgfSBjYXRjaChlcnJvcikge1xuICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsICYmIGVycm9yLmNvZGUgPT09ICdNT0RVTEVfTk9UX0ZPVU5EJykge1xuICAgICAgLy8gbm8gd29ya2VyX3RocmVhZHMgYXZhaWxhYmxlIChvbGQgdmVyc2lvbiBvZiBub2RlLmpzKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufVxuXG4vLyBnZXQgdGhlIGRlZmF1bHQgd29ya2VyIHNjcmlwdFxuZnVuY3Rpb24gZ2V0RGVmYXVsdFdvcmtlcigpIHtcbiAgaWYgKGVudmlyb25tZW50LnBsYXRmb3JtID09PSAnYnJvd3NlcicpIHtcbiAgICAvLyB0ZXN0IHdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgYWxsIGZlYXR1cmVzIHRoYXQgd2UgbmVlZFxuICAgIGlmICh0eXBlb2YgQmxvYiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmxvYiBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyJyk7XG4gICAgfVxuICAgIGlmICghd2luZG93LlVSTCB8fCB0eXBlb2Ygd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVVJMLmNyZWF0ZU9iamVjdFVSTCBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyJyk7XG4gICAgfVxuXG4gICAgLy8gdXNlIGVtYmVkZGVkIHdvcmtlci5qc1xuICAgIHZhciBibG9iID0gbmV3IEJsb2IoW3JlcXVpcmUoJy4vZ2VuZXJhdGVkL2VtYmVkZGVkV29ya2VyJyldLCB7dHlwZTogJ3RleHQvamF2YXNjcmlwdCd9KTtcbiAgICByZXR1cm4gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gdXNlIGV4dGVybmFsIHdvcmtlci5qcyBpbiBjdXJyZW50IGRpcmVjdG9yeVxuICAgIHJldHVybiBfX2Rpcm5hbWUgKyAnL3dvcmtlci5qcyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0dXBXb3JrZXIoc2NyaXB0LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLndvcmtlclR5cGUgPT09ICd3ZWInKSB7IC8vIGJyb3dzZXIgb25seVxuICAgIGVuc3VyZVdlYldvcmtlcigpO1xuICAgIHJldHVybiBzZXR1cEJyb3dzZXJXb3JrZXIoc2NyaXB0LCBvcHRpb25zLndvcmtlck9wdHMsIFdvcmtlcik7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy53b3JrZXJUeXBlID09PSAndGhyZWFkJykgeyAvLyBub2RlLmpzIG9ubHlcbiAgICBXb3JrZXJUaHJlYWRzID0gZW5zdXJlV29ya2VyVGhyZWFkcygpO1xuICAgIHJldHVybiBzZXR1cFdvcmtlclRocmVhZFdvcmtlcihzY3JpcHQsIFdvcmtlclRocmVhZHMsIG9wdGlvbnMud29ya2VyVGhyZWFkT3B0cyk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy53b3JrZXJUeXBlID09PSAncHJvY2VzcycgfHwgIW9wdGlvbnMud29ya2VyVHlwZSkgeyAvLyBub2RlLmpzIG9ubHlcbiAgICByZXR1cm4gc2V0dXBQcm9jZXNzV29ya2VyKHNjcmlwdCwgcmVzb2x2ZUZvcmtPcHRpb25zKG9wdGlvbnMpLCByZXF1aXJlRm9vbFdlYnBhY2soJ2NoaWxkX3Byb2Nlc3MnKSk7XG4gIH0gZWxzZSB7IC8vIG9wdGlvbnMud29ya2VyVHlwZSA9PT0gJ2F1dG8nIG9yIHVuZGVmaW5lZFxuICAgIGlmIChlbnZpcm9ubWVudC5wbGF0Zm9ybSA9PT0gJ2Jyb3dzZXInKSB7XG4gICAgICBlbnN1cmVXZWJXb3JrZXIoKTtcbiAgICAgIHJldHVybiBzZXR1cEJyb3dzZXJXb3JrZXIoc2NyaXB0LCBvcHRpb25zLndvcmtlck9wdHMsIFdvcmtlcik7XG4gICAgfVxuICAgIGVsc2UgeyAvLyBlbnZpcm9ubWVudC5wbGF0Zm9ybSA9PT0gJ25vZGUnXG4gICAgICB2YXIgV29ya2VyVGhyZWFkcyA9IHRyeVJlcXVpcmVXb3JrZXJUaHJlYWRzKCk7XG4gICAgICBpZiAoV29ya2VyVGhyZWFkcykge1xuICAgICAgICByZXR1cm4gc2V0dXBXb3JrZXJUaHJlYWRXb3JrZXIoc2NyaXB0LCBXb3JrZXJUaHJlYWRzLCBvcHRpb25zLndvcmtlclRocmVhZE9wdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNldHVwUHJvY2Vzc1dvcmtlcihzY3JpcHQsIHJlc29sdmVGb3JrT3B0aW9ucyhvcHRpb25zKSwgcmVxdWlyZUZvb2xXZWJwYWNrKCdjaGlsZF9wcm9jZXNzJykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXR1cEJyb3dzZXJXb3JrZXIoc2NyaXB0LCB3b3JrZXJPcHRzLCBXb3JrZXIpIHtcbiAgLy8gY3JlYXRlIHRoZSB3ZWIgd29ya2VyXG4gIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKHNjcmlwdCwgd29ya2VyT3B0cyk7XG5cbiAgd29ya2VyLmlzQnJvd3NlcldvcmtlciA9IHRydWU7XG4gIC8vIGFkZCBub2RlLmpzIEFQSSB0byB0aGUgd2ViIHdvcmtlclxuICB3b3JrZXIub24gPSBmdW5jdGlvbiAoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgY2FsbGJhY2sobWVzc2FnZS5kYXRhKTtcbiAgICB9KTtcbiAgfTtcbiAgd29ya2VyLnNlbmQgPSBmdW5jdGlvbiAobWVzc2FnZSwgdHJhbnNmZXIpIHtcbiAgICB0aGlzLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyKTtcbiAgfTtcbiAgcmV0dXJuIHdvcmtlcjtcbn1cblxuZnVuY3Rpb24gc2V0dXBXb3JrZXJUaHJlYWRXb3JrZXIoc2NyaXB0LCBXb3JrZXJUaHJlYWRzLCB3b3JrZXJUaHJlYWRPcHRpb25zKSB7XG4gIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyVGhyZWFkcy5Xb3JrZXIoc2NyaXB0LCB7XG4gICAgc3Rkb3V0OiBmYWxzZSwgLy8gYXV0b21hdGljYWxseSBwaXBlIHdvcmtlci5TVERPVVQgdG8gcHJvY2Vzcy5TVERPVVRcbiAgICBzdGRlcnI6IGZhbHNlLCAgLy8gYXV0b21hdGljYWxseSBwaXBlIHdvcmtlci5TVERFUlIgdG8gcHJvY2Vzcy5TVERFUlJcbiAgICAuLi53b3JrZXJUaHJlYWRPcHRpb25zXG4gIH0pO1xuICB3b3JrZXIuaXNXb3JrZXJUaHJlYWQgPSB0cnVlO1xuICB3b3JrZXIuc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHRyYW5zZmVyKSB7XG4gICAgdGhpcy5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2Zlcik7XG4gIH07XG5cbiAgd29ya2VyLmtpbGwgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRlcm1pbmF0ZSgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHdvcmtlci5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50ZXJtaW5hdGUoKTtcbiAgfTtcblxuICByZXR1cm4gd29ya2VyO1xufVxuXG5mdW5jdGlvbiBzZXR1cFByb2Nlc3NXb3JrZXIoc2NyaXB0LCBvcHRpb25zLCBjaGlsZF9wcm9jZXNzKSB7XG4gIC8vIG5vIFdvcmtlclRocmVhZHMsIGZhbGxiYWNrIHRvIHN1Yi1wcm9jZXNzIGJhc2VkIHdvcmtlcnNcbiAgdmFyIHdvcmtlciA9IGNoaWxkX3Byb2Nlc3MuZm9yayhcbiAgICBzY3JpcHQsXG4gICAgb3B0aW9ucy5mb3JrQXJncyxcbiAgICBvcHRpb25zLmZvcmtPcHRzXG4gICk7XG5cbiAgLy8gaWdub3JlIHRyYW5zZmVyIGFyZ3VtZW50IHNpbmNlIGl0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgcHJvY2Vzc1xuICB2YXIgc2VuZCA9IHdvcmtlci5zZW5kO1xuICB3b3JrZXIuc2VuZCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHNlbmQuY2FsbCh3b3JrZXIsIG1lc3NhZ2UpO1xuICB9O1xuXG4gIHdvcmtlci5pc0NoaWxkUHJvY2VzcyA9IHRydWU7XG4gIHJldHVybiB3b3JrZXI7XG59XG5cbi8vIGFkZCBkZWJ1ZyBmbGFncyB0byBjaGlsZCBwcm9jZXNzZXMgaWYgdGhlIG5vZGUgaW5zcGVjdG9yIGlzIGFjdGl2ZVxuZnVuY3Rpb24gcmVzb2x2ZUZvcmtPcHRpb25zKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdmFyIHByb2Nlc3NFeGVjQXJndiA9IHByb2Nlc3MuZXhlY0FyZ3Yuam9pbignICcpO1xuICB2YXIgaW5zcGVjdG9yQWN0aXZlID0gcHJvY2Vzc0V4ZWNBcmd2LmluZGV4T2YoJy0taW5zcGVjdCcpICE9PSAtMTtcbiAgdmFyIGRlYnVnQnJrID0gcHJvY2Vzc0V4ZWNBcmd2LmluZGV4T2YoJy0tZGVidWctYnJrJykgIT09IC0xO1xuXG4gIHZhciBleGVjQXJndiA9IFtdO1xuICBpZiAoaW5zcGVjdG9yQWN0aXZlKSB7XG4gICAgZXhlY0FyZ3YucHVzaCgnLS1pbnNwZWN0PScgKyBvcHRzLmRlYnVnUG9ydCk7XG5cbiAgICBpZiAoZGVidWdCcmspIHtcbiAgICAgIGV4ZWNBcmd2LnB1c2goJy0tZGVidWctYnJrJyk7XG4gICAgfVxuICB9XG5cbiAgcHJvY2Vzcy5leGVjQXJndi5mb3JFYWNoKGZ1bmN0aW9uKGFyZykge1xuICAgIGlmIChhcmcuaW5kZXhPZignLS1tYXgtb2xkLXNwYWNlLXNpemUnKSA+IC0xKSB7XG4gICAgICBleGVjQXJndi5wdXNoKGFyZylcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdHMsIHtcbiAgICBmb3JrQXJnczogb3B0cy5mb3JrQXJncyxcbiAgICBmb3JrT3B0czogT2JqZWN0LmFzc2lnbih7fSwgb3B0cy5mb3JrT3B0cywge1xuICAgICAgZXhlY0FyZ3Y6IChvcHRzLmZvcmtPcHRzICYmIG9wdHMuZm9ya09wdHMuZXhlY0FyZ3YgfHwgW10pXG4gICAgICAuY29uY2F0KGV4ZWNBcmd2KVxuICAgIH0pXG4gIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgc2VyaWFsaXplZCBlcnJvciB0byBFcnJvclxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBFcnJvciB0aGF0IGhhcyBiZWVuIHNlcmlhbGl6ZWQgYW5kIHBhcnNlZCB0byBvYmplY3RcbiAqIEByZXR1cm4ge0Vycm9yfSBUaGUgZXF1aXZhbGVudCBFcnJvci5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9FcnJvciAob2JqKSB7XG4gIHZhciB0ZW1wID0gbmV3IEVycm9yKCcnKVxuICB2YXIgcHJvcHMgPSBPYmplY3Qua2V5cyhvYmopXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHRlbXBbcHJvcHNbaV1dID0gb2JqW3Byb3BzW2ldXVxuICB9XG5cbiAgcmV0dXJuIHRlbXBcbn1cblxuLyoqXG4gKiBBIFdvcmtlckhhbmRsZXIgY29udHJvbHMgYSBzaW5nbGUgd29ya2VyLiBUaGlzIHdvcmtlciBjYW4gYmUgYSBjaGlsZCBwcm9jZXNzXG4gKiBvbiBub2RlLmpzIG9yIGEgV2ViV29ya2VyIGluIGEgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2NyaXB0XSBJZiBubyBzY3JpcHQgaXMgcHJvdmlkZWQsIGEgZGVmYXVsdCB3b3JrZXIgd2l0aCBhXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcnVuIHdpbGwgYmUgY3JlYXRlZC5cbiAqIEBwYXJhbSB7V29ya2VyUG9vbE9wdGlvbnN9IF9vcHRpb25zIFNlZSBkb2NzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gV29ya2VySGFuZGxlcihzY3JpcHQsIF9vcHRpb25zKSB7XG4gIHZhciBtZSA9IHRoaXM7XG4gIHZhciBvcHRpb25zID0gX29wdGlvbnMgfHwge307XG5cbiAgdGhpcy5zY3JpcHQgPSBzY3JpcHQgfHwgZ2V0RGVmYXVsdFdvcmtlcigpO1xuICB0aGlzLndvcmtlciA9IHNldHVwV29ya2VyKHRoaXMuc2NyaXB0LCBvcHRpb25zKTtcbiAgdGhpcy5kZWJ1Z1BvcnQgPSBvcHRpb25zLmRlYnVnUG9ydDtcbiAgdGhpcy5mb3JrT3B0cyA9IG9wdGlvbnMuZm9ya09wdHM7XG4gIHRoaXMuZm9ya0FyZ3MgPSBvcHRpb25zLmZvcmtBcmdzO1xuICB0aGlzLndvcmtlck9wdHMgPSBvcHRpb25zLndvcmtlck9wdHM7XG4gIHRoaXMud29ya2VyVGhyZWFkT3B0cyA9IG9wdGlvbnMud29ya2VyVGhyZWFkT3B0c1xuICB0aGlzLndvcmtlclRlcm1pbmF0ZVRpbWVvdXQgPSBvcHRpb25zLndvcmtlclRlcm1pbmF0ZVRpbWVvdXQ7XG5cbiAgLy8gVGhlIHJlYWR5IG1lc3NhZ2UgaXMgb25seSBzZW50IGlmIHRoZSB3b3JrZXIuYWRkIG1ldGhvZCBpcyBjYWxsZWQgKEFuZCB0aGUgZGVmYXVsdCBzY3JpcHQgaXMgbm90IHVzZWQpXG4gIGlmICghc2NyaXB0KSB7XG4gICAgdGhpcy53b3JrZXIucmVhZHkgPSB0cnVlO1xuICB9XG5cbiAgLy8gcXVldWUgZm9yIHJlcXVlc3RzIHRoYXQgYXJlIHJlY2VpdmVkIGJlZm9yZSB0aGUgd29ya2VyIGlzIHJlYWR5XG4gIHRoaXMucmVxdWVzdFF1ZXVlID0gW107XG4gIHRoaXMud29ya2VyLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgaWYgKG1lLnRlcm1pbmF0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXNwb25zZSA9PT0gJ3N0cmluZycgJiYgcmVzcG9uc2UgPT09ICdyZWFkeScpIHtcbiAgICAgIG1lLndvcmtlci5yZWFkeSA9IHRydWU7XG4gICAgICBkaXNwYXRjaFF1ZXVlZFJlcXVlc3RzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZpbmQgdGhlIHRhc2sgZnJvbSB0aGUgcHJvY2Vzc2luZyBxdWV1ZSwgYW5kIHJ1biB0aGUgdGFza3MgY2FsbGJhY2tcbiAgICAgIHZhciBpZCA9IHJlc3BvbnNlLmlkO1xuICAgICAgdmFyIHRhc2sgPSBtZS5wcm9jZXNzaW5nW2lkXTtcbiAgICAgIGlmICh0YXNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmlzRXZlbnQpIHtcbiAgICAgICAgICBpZiAodGFzay5vcHRpb25zICYmIHR5cGVvZiB0YXNrLm9wdGlvbnMub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRhc2sub3B0aW9ucy5vbihyZXNwb25zZS5wYXlsb2FkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHRoZSB0YXNrIGZyb20gdGhlIHF1ZXVlXG4gICAgICAgICAgZGVsZXRlIG1lLnByb2Nlc3NpbmdbaWRdO1xuXG4gICAgICAgICAgLy8gdGVzdCBpZiB3ZSBuZWVkIHRvIHRlcm1pbmF0ZVxuICAgICAgICAgIGlmIChtZS50ZXJtaW5hdGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gY29tcGxldGUgd29ya2VyIHRlcm1pbmF0aW9uIGlmIGFsbCB0YXNrcyBhcmUgZmluaXNoZWRcbiAgICAgICAgICAgIG1lLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHJlc29sdmUgdGhlIHRhc2sncyBwcm9taXNlXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICB0YXNrLnJlc29sdmVyLnJlamVjdChvYmplY3RUb0Vycm9yKHJlc3BvbnNlLmVycm9yKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFzay5yZXNvbHZlci5yZXNvbHZlKHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyByZWplY3QgYWxsIHJ1bm5pbmcgdGFza3Mgb24gd29ya2VyIGVycm9yXG4gIGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgICBtZS50ZXJtaW5hdGVkID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIGlkIGluIG1lLnByb2Nlc3NpbmcpIHtcbiAgICAgIGlmIChtZS5wcm9jZXNzaW5nW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1lLnByb2Nlc3NpbmdbaWRdLnJlc29sdmVyLnJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIG1lLnByb2Nlc3NpbmcgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG5cbiAgLy8gc2VuZCBhbGwgcXVldWVkIHJlcXVlc3RzIHRvIHdvcmtlclxuICBmdW5jdGlvbiBkaXNwYXRjaFF1ZXVlZFJlcXVlc3RzKClcbiAge1xuICAgIGZvcihjb25zdCByZXF1ZXN0IG9mIG1lLnJlcXVlc3RRdWV1ZS5zcGxpY2UoMCkpIHtcbiAgICAgIG1lLndvcmtlci5zZW5kKHJlcXVlc3QubWVzc2FnZSwgcmVxdWVzdC50cmFuc2Zlcik7XG4gICAgfVxuICB9XG5cbiAgdmFyIHdvcmtlciA9IHRoaXMud29ya2VyO1xuICAvLyBsaXN0ZW4gZm9yIHdvcmtlciBtZXNzYWdlcyBlcnJvciBhbmQgZXhpdFxuICB0aGlzLndvcmtlci5vbignZXJyb3InLCBvbkVycm9yKTtcbiAgdGhpcy53b3JrZXIub24oJ2V4aXQnLCBmdW5jdGlvbiAoZXhpdENvZGUsIHNpZ25hbENvZGUpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXb3JrZXJwb29sIFdvcmtlciB0ZXJtaW5hdGVkIFVuZXhwZWN0ZWRseVxcbic7XG5cbiAgICBtZXNzYWdlICs9ICcgICAgZXhpdENvZGU6IGAnICsgZXhpdENvZGUgKyAnYFxcbic7XG4gICAgbWVzc2FnZSArPSAnICAgIHNpZ25hbENvZGU6IGAnICsgc2lnbmFsQ29kZSArICdgXFxuJztcblxuICAgIG1lc3NhZ2UgKz0gJyAgICB3b3JrZXJwb29sLnNjcmlwdDogYCcgKyAgbWUuc2NyaXB0ICsgJ2BcXG4nO1xuICAgIG1lc3NhZ2UgKz0gJyAgICBzcGF3bkFyZ3M6IGAnICsgIHdvcmtlci5zcGF3bmFyZ3MgKyAnYFxcbic7XG4gICAgbWVzc2FnZSArPSAnICAgIHNwYXduZmlsZTogYCcgKyB3b3JrZXIuc3Bhd25maWxlICsgJ2BcXG4nXG5cbiAgICBtZXNzYWdlICs9ICcgICAgc3Rkb3V0OiBgJyArIHdvcmtlci5zdGRvdXQgKyAnYFxcbidcbiAgICBtZXNzYWdlICs9ICcgICAgc3RkZXJyOiBgJyArIHdvcmtlci5zdGRlcnIgKyAnYFxcbidcblxuICAgIG9uRXJyb3IobmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgfSk7XG5cbiAgdGhpcy5wcm9jZXNzaW5nID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgLy8gcXVldWUgd2l0aCB0YXNrcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3NcblxuICB0aGlzLnRlcm1pbmF0aW5nID0gZmFsc2U7XG4gIHRoaXMudGVybWluYXRlZCA9IGZhbHNlO1xuICB0aGlzLmNsZWFuaW5nID0gZmFsc2U7XG4gIHRoaXMudGVybWluYXRpb25IYW5kbGVyID0gbnVsbDtcbiAgdGhpcy5sYXN0SWQgPSAwO1xufVxuXG4vKipcbiAqIEdldCBhIGxpc3Qgd2l0aCBtZXRob2RzIGF2YWlsYWJsZSBvbiB0aGUgd29ya2VyLlxuICogQHJldHVybiB7UHJvbWlzZS48U3RyaW5nW10sIEVycm9yPn0gbWV0aG9kc1xuICovXG5Xb3JrZXJIYW5kbGVyLnByb3RvdHlwZS5tZXRob2RzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5leGVjKCdtZXRob2RzJyk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBtZXRob2Qgd2l0aCBnaXZlbiBwYXJhbWV0ZXJzIG9uIHRoZSB3b3JrZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7QXJyYXl9IFtwYXJhbXNdXG4gKiBAcGFyYW0ge3tyZXNvbHZlOiBGdW5jdGlvbiwgcmVqZWN0OiBGdW5jdGlvbn19IFtyZXNvbHZlcl1cbiAqIEBwYXJhbSB7RXhlY09wdGlvbnN9ICBbb3B0aW9uc11cbiAqIEByZXR1cm4ge1Byb21pc2UuPCosIEVycm9yPn0gcmVzdWx0XG4gKi9cbldvcmtlckhhbmRsZXIucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihtZXRob2QsIHBhcmFtcywgcmVzb2x2ZXIsIG9wdGlvbnMpIHtcbiAgaWYgKCFyZXNvbHZlcikge1xuICAgIHJlc29sdmVyID0gUHJvbWlzZS5kZWZlcigpO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGUgYSB1bmlxdWUgaWQgZm9yIHRoZSB0YXNrXG4gIHZhciBpZCA9ICsrdGhpcy5sYXN0SWQ7XG5cbiAgLy8gcmVnaXN0ZXIgYSBuZXcgdGFzayBhcyBiZWluZyBpbiBwcm9ncmVzc1xuICB0aGlzLnByb2Nlc3NpbmdbaWRdID0ge1xuICAgIGlkOiBpZCxcbiAgICByZXNvbHZlcjogcmVzb2x2ZXIsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9O1xuXG4gIC8vIGJ1aWxkIGEgSlNPTi1SUEMgcmVxdWVzdFxuICB2YXIgcmVxdWVzdCA9IHtcbiAgICBtZXNzYWdlOiB7XG4gICAgICBpZDogaWQsXG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgfSxcbiAgICB0cmFuc2Zlcjogb3B0aW9ucyAmJiBvcHRpb25zLnRyYW5zZmVyXG4gIH07XG5cbiAgaWYgKHRoaXMudGVybWluYXRlZCkge1xuICAgIHJlc29sdmVyLnJlamVjdChuZXcgRXJyb3IoJ1dvcmtlciBpcyB0ZXJtaW5hdGVkJykpO1xuICB9IGVsc2UgaWYgKHRoaXMud29ya2VyLnJlYWR5KSB7XG4gICAgLy8gc2VuZCB0aGUgcmVxdWVzdCB0byB0aGUgd29ya2VyXG4gICAgdGhpcy53b3JrZXIuc2VuZChyZXF1ZXN0Lm1lc3NhZ2UsIHJlcXVlc3QudHJhbnNmZXIpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVxdWVzdFF1ZXVlLnB1c2gocmVxdWVzdCk7XG4gIH1cblxuICAvLyBvbiBjYW5jZWxsYXRpb24sIGZvcmNlIHRoZSB3b3JrZXIgdG8gdGVybWluYXRlXG4gIHZhciBtZSA9IHRoaXM7XG4gIHJldHVybiByZXNvbHZlci5wcm9taXNlLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBQcm9taXNlLlRpbWVvdXRFcnJvcikge1xuICAgICAgLy8gcmVtb3ZlIHRoaXMgdGFzayBmcm9tIHRoZSBxdWV1ZS4gSXQgaXMgYWxyZWFkeSByZWplY3RlZCAoaGVuY2UgdGhpc1xuICAgICAgLy8gY2F0Y2ggZXZlbnQpLCBhbmQgZWxzZSBpdCB3aWxsIGJlIHJlamVjdGVkIGFnYWluIHdoZW4gdGVybWluYXRpbmdcbiAgICAgIGRlbGV0ZSBtZS5wcm9jZXNzaW5nW2lkXTtcblxuICAgICAgLy8gdGVybWluYXRlIHdvcmtlclxuICAgICAgcmV0dXJuIG1lLnRlcm1pbmF0ZUFuZE5vdGlmeSh0cnVlKVxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9KVxufTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgdGhlIHdvcmtlciBpcyBwcm9jZXNzaW5nIGFueSB0YXNrcyBvciBjbGVhbmluZyB1cCBiZWZvcmUgdGVybWluYXRpb24uXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHdvcmtlciBpcyBidXN5XG4gKi9cbldvcmtlckhhbmRsZXIucHJvdG90eXBlLmJ1c3kgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsZWFuaW5nIHx8IE9iamVjdC5rZXlzKHRoaXMucHJvY2Vzc2luZykubGVuZ3RoID4gMDtcbn07XG5cbi8qKlxuICogVGVybWluYXRlIHRoZSB3b3JrZXIuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZT1mYWxzZV0gICBJZiBmYWxzZSAoZGVmYXVsdCksIHRoZSB3b3JrZXIgaXMgdGVybWluYXRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgZmluaXNoaW5nIGFsbCB0YXNrcyBjdXJyZW50bHkgaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzLiBJZiB0cnVlLCB0aGUgd29ya2VyIHdpbGwgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2s9bnVsbF0gSWYgcHJvdmlkZWQsIHdpbGwgYmUgY2FsbGVkIHdoZW4gcHJvY2VzcyB0ZXJtaW5hdGVzLlxuICovXG5Xb3JrZXJIYW5kbGVyLnByb3RvdHlwZS50ZXJtaW5hdGUgPSBmdW5jdGlvbiAoZm9yY2UsIGNhbGxiYWNrKSB7XG4gIHZhciBtZSA9IHRoaXM7XG4gIGlmIChmb3JjZSkge1xuICAgIC8vIGNhbmNlbCBhbGwgdGFza3MgaW4gcHJvZ3Jlc3NcbiAgICBmb3IgKHZhciBpZCBpbiB0aGlzLnByb2Nlc3NpbmcpIHtcbiAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmdbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nW2lkXS5yZXNvbHZlci5yZWplY3QobmV3IEVycm9yKCdXb3JrZXIgdGVybWluYXRlZCcpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcm9jZXNzaW5nID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLnRlcm1pbmF0aW9uSGFuZGxlciA9IGNhbGxiYWNrO1xuICB9XG4gIGlmICghdGhpcy5idXN5KCkpIHtcbiAgICAvLyBhbGwgdGFza3MgYXJlIGZpbmlzaGVkLiBraWxsIHRoZSB3b3JrZXJcbiAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgbWUudGVybWluYXRlZCA9IHRydWU7XG4gICAgICBtZS5jbGVhbmluZyA9IGZhbHNlO1xuICAgICAgaWYgKG1lLndvcmtlciAhPSBudWxsICYmIG1lLndvcmtlci5yZW1vdmVBbGxMaXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gcmVtb3ZlQWxsTGlzdGVuZXJzIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBjaGlsZF9wcm9jZXNzXG4gICAgICAgIG1lLndvcmtlci5yZW1vdmVBbGxMaXN0ZW5lcnMoJ21lc3NhZ2UnKTtcbiAgICAgIH1cbiAgICAgIG1lLndvcmtlciA9IG51bGw7XG4gICAgICBtZS50ZXJtaW5hdGluZyA9IGZhbHNlO1xuICAgICAgaWYgKG1lLnRlcm1pbmF0aW9uSGFuZGxlcikge1xuICAgICAgICBtZS50ZXJtaW5hdGlvbkhhbmRsZXIoZXJyLCBtZSk7XG4gICAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud29ya2VyKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMud29ya2VyLmtpbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMud29ya2VyLmtpbGxlZCkge1xuICAgICAgICAgIGNsZWFudXAobmV3IEVycm9yKCd3b3JrZXIgYWxyZWFkeSBraWxsZWQhJykpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoaWxkIHByb2Nlc3MgYW5kIHdvcmtlciB0aHJlYWRzXG4gICAgICAgIHZhciBjbGVhbkV4aXRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAobWUud29ya2VyKSB7XG4gICAgICAgICAgICBtZS53b3JrZXIua2lsbCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy53b3JrZXJUZXJtaW5hdGVUaW1lb3V0KTtcblxuICAgICAgICB0aGlzLndvcmtlci5vbmNlKCdleGl0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGNsZWFuRXhpdFRpbWVvdXQpO1xuICAgICAgICAgIGlmIChtZS53b3JrZXIpIHtcbiAgICAgICAgICAgIG1lLndvcmtlci5raWxsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLndvcmtlci5yZWFkeSkge1xuICAgICAgICAgIHRoaXMud29ya2VyLnNlbmQoVEVSTUlOQVRFX01FVEhPRF9JRCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0UXVldWUucHVzaCh7IG1lc3NhZ2U6IFRFUk1JTkFURV9NRVRIT0RfSUQgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYXJrIHRoYXQgdGhlIHdvcmtlciBpcyBjbGVhbmluZyB1cCByZXNvdXJjZXNcbiAgICAgICAgLy8gdG8gcHJldmVudCBuZXcgdGFza3MgZnJvbSBiZWluZyBleGVjdXRlZFxuICAgICAgICB0aGlzLmNsZWFuaW5nID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMud29ya2VyLnRlcm1pbmF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLndvcmtlci50ZXJtaW5hdGUoKTsgLy8gd2ViIHdvcmtlclxuICAgICAgICB0aGlzLndvcmtlci5raWxsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHRlcm1pbmF0ZSB3b3JrZXInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2xlYW51cCgpO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIHdlIGNhbid0IHRlcm1pbmF0ZSBpbW1lZGlhdGVseSwgdGhlcmUgYXJlIHN0aWxsIHRhc2tzIGJlaW5nIGV4ZWN1dGVkXG4gICAgdGhpcy50ZXJtaW5hdGluZyA9IHRydWU7XG4gIH1cbn07XG5cbi8qKlxuICogVGVybWluYXRlIHRoZSB3b3JrZXIsIHJldHVybmluZyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSB0ZXJtaW5hdGlvbiBoYXMgYmVlbiBkb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbZm9yY2U9ZmFsc2VdICAgSWYgZmFsc2UgKGRlZmF1bHQpLCB0aGUgd29ya2VyIGlzIHRlcm1pbmF0ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyIGZpbmlzaGluZyBhbGwgdGFza3MgY3VycmVudGx5IGluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcy4gSWYgdHJ1ZSwgdGhlIHdvcmtlciB3aWxsIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkIGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0XSAgICAgICAgSWYgcHJvdmlkZWQgYW5kIG5vbi16ZXJvLCB3b3JrZXIgdGVybWluYXRpb24gcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlciB0aW1lb3V0IGlmIHdvcmtlciBwcm9jZXNzIGhhcyBub3QgYmVlbiB0ZXJtaW5hdGVkLlxuICogQHJldHVybiB7UHJvbWlzZS48V29ya2VySGFuZGxlciwgRXJyb3I+fVxuICovXG5Xb3JrZXJIYW5kbGVyLnByb3RvdHlwZS50ZXJtaW5hdGVBbmROb3RpZnkgPSBmdW5jdGlvbiAoZm9yY2UsIHRpbWVvdXQpIHtcbiAgdmFyIHJlc29sdmVyID0gUHJvbWlzZS5kZWZlcigpO1xuICBpZiAodGltZW91dCkge1xuICAgIHJlc29sdmVyLnByb21pc2UudGltZW91dCh0aW1lb3V0KTtcbiAgfVxuICB0aGlzLnRlcm1pbmF0ZShmb3JjZSwgZnVuY3Rpb24oZXJyLCB3b3JrZXIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXNvbHZlci5yZWplY3QoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZXIucmVzb2x2ZSh3b3JrZXIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNvbHZlci5wcm9taXNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXb3JrZXJIYW5kbGVyO1xubW9kdWxlLmV4cG9ydHMuX3RyeVJlcXVpcmVXb3JrZXJUaHJlYWRzID0gdHJ5UmVxdWlyZVdvcmtlclRocmVhZHM7XG5tb2R1bGUuZXhwb3J0cy5fc2V0dXBQcm9jZXNzV29ya2VyID0gc2V0dXBQcm9jZXNzV29ya2VyO1xubW9kdWxlLmV4cG9ydHMuX3NldHVwQnJvd3NlcldvcmtlciA9IHNldHVwQnJvd3Nlcldvcmtlcjtcbm1vZHVsZS5leHBvcnRzLl9zZXR1cFdvcmtlclRocmVhZFdvcmtlciA9IHNldHVwV29ya2VyVGhyZWFkV29ya2VyO1xubW9kdWxlLmV4cG9ydHMuZW5zdXJlV29ya2VyVGhyZWFkcyA9IGVuc3VyZVdvcmtlclRocmVhZHM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/workerpool/src/WorkerHandler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/workerpool/src/debug-port-allocator.js":
/*!*************************************************************!*\
  !*** ./node_modules/workerpool/src/debug-port-allocator.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar MAX_PORTS = 65535;\nmodule.exports = DebugPortAllocator;\nfunction DebugPortAllocator() {\n  this.ports = Object.create(null);\n  this.length = 0;\n}\n\nDebugPortAllocator.prototype.nextAvailableStartingAt = function(starting) {\n  while (this.ports[starting] === true) {\n    starting++;\n  }\n\n  if (starting >= MAX_PORTS) {\n    throw new Error('WorkerPool debug port limit reached: ' + starting + '>= ' + MAX_PORTS );\n  }\n\n  this.ports[starting] = true;\n  this.length++;\n  return starting;\n};\n\nDebugPortAllocator.prototype.releasePort = function(port) {\n  delete this.ports[port];\n  this.length--;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd29ya2VycG9vbC9zcmMvZGVidWctcG9ydC1hbGxvY2F0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvd29ya2VycG9vbC9zcmMvZGVidWctcG9ydC1hbGxvY2F0b3IuanM/MTBiZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBNQVhfUE9SVFMgPSA2NTUzNTtcbm1vZHVsZS5leHBvcnRzID0gRGVidWdQb3J0QWxsb2NhdG9yO1xuZnVuY3Rpb24gRGVidWdQb3J0QWxsb2NhdG9yKCkge1xuICB0aGlzLnBvcnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xufVxuXG5EZWJ1Z1BvcnRBbGxvY2F0b3IucHJvdG90eXBlLm5leHRBdmFpbGFibGVTdGFydGluZ0F0ID0gZnVuY3Rpb24oc3RhcnRpbmcpIHtcbiAgd2hpbGUgKHRoaXMucG9ydHNbc3RhcnRpbmddID09PSB0cnVlKSB7XG4gICAgc3RhcnRpbmcrKztcbiAgfVxuXG4gIGlmIChzdGFydGluZyA+PSBNQVhfUE9SVFMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtlclBvb2wgZGVidWcgcG9ydCBsaW1pdCByZWFjaGVkOiAnICsgc3RhcnRpbmcgKyAnPj0gJyArIE1BWF9QT1JUUyApO1xuICB9XG5cbiAgdGhpcy5wb3J0c1tzdGFydGluZ10gPSB0cnVlO1xuICB0aGlzLmxlbmd0aCsrO1xuICByZXR1cm4gc3RhcnRpbmc7XG59O1xuXG5EZWJ1Z1BvcnRBbGxvY2F0b3IucHJvdG90eXBlLnJlbGVhc2VQb3J0ID0gZnVuY3Rpb24ocG9ydCkge1xuICBkZWxldGUgdGhpcy5wb3J0c1twb3J0XTtcbiAgdGhpcy5sZW5ndGgtLTtcbn07XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/workerpool/src/debug-port-allocator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/workerpool/src/environment.js":
/*!****************************************************!*\
  !*** ./node_modules/workerpool/src/environment.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var requireFoolWebpack = __webpack_require__(/*! ./requireFoolWebpack */ \"(ssr)/./node_modules/workerpool/src/requireFoolWebpack.js\");\n\n// source: https://github.com/flexdinesh/browser-or-node\nvar isNode = function (nodeProcess) {\n  return (\n    typeof nodeProcess !== 'undefined' &&\n    nodeProcess.versions != null &&\n    nodeProcess.versions.node != null\n  );\n}\nmodule.exports.isNode = isNode\n\n// determines the JavaScript platform: browser or node\nmodule.exports.platform = typeof process !== 'undefined' && isNode(process)\n  ? 'node'\n  : 'browser';\n\n// determines whether the code is running in main thread or not\n// note that in node.js we have to check both worker_thread and child_process\nvar worker_threads = tryRequireFoolWebpack('worker_threads');\nmodule.exports.isMainThread = module.exports.platform === 'node'\n  ? ((!worker_threads || worker_threads.isMainThread) && !process.connected)\n  : typeof Window !== 'undefined';\n\n// determines the number of cpus available\nmodule.exports.cpus = module.exports.platform === 'browser'\n  ? self.navigator.hardwareConcurrency\n  : requireFoolWebpack('os').cpus().length;\n\nfunction tryRequireFoolWebpack (module) {\n  try {\n    return requireFoolWebpack(module);\n  } catch(err) {\n    return null\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd29ya2VycG9vbC9zcmMvZW52aXJvbm1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUEseUJBQXlCLG1CQUFPLENBQUMsdUZBQXNCOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvd29ya2VycG9vbC9zcmMvZW52aXJvbm1lbnQuanM/YWNjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVxdWlyZUZvb2xXZWJwYWNrID0gcmVxdWlyZSgnLi9yZXF1aXJlRm9vbFdlYnBhY2snKTtcblxuLy8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vZmxleGRpbmVzaC9icm93c2VyLW9yLW5vZGVcbnZhciBpc05vZGUgPSBmdW5jdGlvbiAobm9kZVByb2Nlc3MpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygbm9kZVByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmXG4gICAgbm9kZVByb2Nlc3MudmVyc2lvbnMgIT0gbnVsbCAmJlxuICAgIG5vZGVQcm9jZXNzLnZlcnNpb25zLm5vZGUgIT0gbnVsbFxuICApO1xufVxubW9kdWxlLmV4cG9ydHMuaXNOb2RlID0gaXNOb2RlXG5cbi8vIGRldGVybWluZXMgdGhlIEphdmFTY3JpcHQgcGxhdGZvcm06IGJyb3dzZXIgb3Igbm9kZVxubW9kdWxlLmV4cG9ydHMucGxhdGZvcm0gPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOb2RlKHByb2Nlc3MpXG4gID8gJ25vZGUnXG4gIDogJ2Jyb3dzZXInO1xuXG4vLyBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvZGUgaXMgcnVubmluZyBpbiBtYWluIHRocmVhZCBvciBub3Rcbi8vIG5vdGUgdGhhdCBpbiBub2RlLmpzIHdlIGhhdmUgdG8gY2hlY2sgYm90aCB3b3JrZXJfdGhyZWFkIGFuZCBjaGlsZF9wcm9jZXNzXG52YXIgd29ya2VyX3RocmVhZHMgPSB0cnlSZXF1aXJlRm9vbFdlYnBhY2soJ3dvcmtlcl90aHJlYWRzJyk7XG5tb2R1bGUuZXhwb3J0cy5pc01haW5UaHJlYWQgPSBtb2R1bGUuZXhwb3J0cy5wbGF0Zm9ybSA9PT0gJ25vZGUnXG4gID8gKCghd29ya2VyX3RocmVhZHMgfHwgd29ya2VyX3RocmVhZHMuaXNNYWluVGhyZWFkKSAmJiAhcHJvY2Vzcy5jb25uZWN0ZWQpXG4gIDogdHlwZW9mIFdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIGRldGVybWluZXMgdGhlIG51bWJlciBvZiBjcHVzIGF2YWlsYWJsZVxubW9kdWxlLmV4cG9ydHMuY3B1cyA9IG1vZHVsZS5leHBvcnRzLnBsYXRmb3JtID09PSAnYnJvd3NlcidcbiAgPyBzZWxmLm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5XG4gIDogcmVxdWlyZUZvb2xXZWJwYWNrKCdvcycpLmNwdXMoKS5sZW5ndGg7XG5cbmZ1bmN0aW9uIHRyeVJlcXVpcmVGb29sV2VicGFjayAobW9kdWxlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHJlcXVpcmVGb29sV2VicGFjayhtb2R1bGUpO1xuICB9IGNhdGNoKGVycikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/workerpool/src/environment.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/workerpool/src/generated/embeddedWorker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/workerpool/src/generated/embeddedWorker.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("/**\n * embeddedWorker.js contains an embedded version of worker.js.\n * This file is automatically generated,\n * changes made in this file will be overwritten.\n */\nmodule.exports = \"!function(){var __webpack_modules__={577:function(e){e.exports=function(e,r){this.message=e,this.transfer=r}}},__webpack_module_cache__={};function __webpack_require__(e){var r=__webpack_module_cache__[e];return void 0!==r||(r=__webpack_module_cache__[e]={exports:{}},__webpack_modules__[e](r,r.exports,__webpack_require__)),r.exports}var __webpack_exports__={};!function(){var exports=__webpack_exports__,__webpack_unused_export__;function _typeof(e){return(_typeof=\\\"function\\\"==typeof Symbol&&\\\"symbol\\\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\\\"function\\\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\\\"symbol\\\":typeof e})(e)}var Transfer=__webpack_require__(577),requireFoolWebpack=eval(\\\"typeof require !== 'undefined' ? require : function (module) { throw new Error('Module \\\\\\\" + module + \\\\\\\" not found.') }\\\"),TERMINATE_METHOD_ID=\\\"__workerpool-terminate__\\\",worker={exit:function(){}},WorkerThreads,parentPort;if(\\\"undefined\\\"!=typeof self&&\\\"function\\\"==typeof postMessage&&\\\"function\\\"==typeof addEventListener)worker.on=function(e,r){addEventListener(e,function(e){r(e.data)})},worker.send=function(e){postMessage(e)};else{if(\\\"undefined\\\"==typeof process)throw new Error(\\\"Script must be executed as a worker\\\");try{WorkerThreads=requireFoolWebpack(\\\"worker_threads\\\")}catch(error){if(\\\"object\\\"!==_typeof(error)||null===error||\\\"MODULE_NOT_FOUND\\\"!==error.code)throw error}WorkerThreads&&null!==WorkerThreads.parentPort?(parentPort=WorkerThreads.parentPort,worker.send=parentPort.postMessage.bind(parentPort),worker.on=parentPort.on.bind(parentPort)):(worker.on=process.on.bind(process),worker.send=function(e){process.send(e)},worker.on(\\\"disconnect\\\",function(){process.exit(1)})),worker.exit=process.exit.bind(process)}function convertError(o){return Object.getOwnPropertyNames(o).reduce(function(e,r){return Object.defineProperty(e,r,{value:o[r],enumerable:!0})},{})}function isPromise(e){return e&&\\\"function\\\"==typeof e.then&&\\\"function\\\"==typeof e.catch}worker.methods={},worker.methods.run=function(e,r){e=new Function(\\\"return (\\\"+e+\\\").apply(null, arguments);\\\");return e.apply(e,r)},worker.methods.methods=function(){return Object.keys(worker.methods)},worker.terminationHandler=void 0,worker.cleanupAndExit=function(e){function r(){worker.exit(e)}if(!worker.terminationHandler)return r();var o=worker.terminationHandler(e);isPromise(o)?o.then(r,r):r()};var currentRequestId=null;worker.on(\\\"message\\\",function(r){if(r===TERMINATE_METHOD_ID)return worker.cleanupAndExit(0);try{var e=worker.methods[r.method];if(!e)throw new Error('Unknown method \\\"'+r.method+'\\\"');currentRequestId=r.id;var o=e.apply(e,r.params);isPromise(o)?o.then(function(e){e instanceof Transfer?worker.send({id:r.id,result:e.message,error:null},e.transfer):worker.send({id:r.id,result:e,error:null}),currentRequestId=null}).catch(function(e){worker.send({id:r.id,result:null,error:convertError(e)}),currentRequestId=null}):(o instanceof Transfer?worker.send({id:r.id,result:o.message,error:null},o.transfer):worker.send({id:r.id,result:o,error:null}),currentRequestId=null)}catch(e){worker.send({id:r.id,result:null,error:convertError(e)})}}),worker.register=function(e,r){if(e)for(var o in e)e.hasOwnProperty(o)&&(worker.methods[o]=e[o]);r&&(worker.terminationHandler=r.onTerminate),worker.send(\\\"ready\\\")},worker.emit=function(e){currentRequestId&&(e instanceof Transfer?worker.send({id:currentRequestId,isEvent:!0,payload:e.message},e.transfer):worker.send({id:currentRequestId,isEvent:!0,payload:e}))},__webpack_unused_export__=worker.register,worker.emit}()}();\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd29ya2VycG9vbC9zcmMvZ2VuZXJhdGVkL2VtYmVkZGVkV29ya2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseUJBQXlCLGdCQUFnQix3QkFBd0IsaUNBQWlDLDZCQUE2QixnQ0FBZ0Msa0NBQWtDLG1EQUFtRCxXQUFXLG9FQUFvRSwyQkFBMkIsWUFBWSwwREFBMEQsb0JBQW9CLDJGQUEyRixnQkFBZ0IsYUFBYSx3R0FBd0csS0FBSywrSEFBK0gsMkRBQTJELDZEQUE2RCxrQkFBa0IsMEJBQTBCLCtIQUErSCwrQkFBK0IsVUFBVSxFQUFFLHlCQUF5QixnQkFBZ0IsS0FBSywwRkFBMEYsSUFBSSxxREFBcUQsYUFBYSw0RkFBNEYsOE9BQThPLGdCQUFnQixxQ0FBcUMsZ0JBQWdCLDBDQUEwQyx5QkFBeUIsMERBQTBELGtDQUFrQyx5QkFBeUIsRUFBRSxHQUFHLEVBQUUsc0JBQXNCLG9FQUFvRSxpQkFBaUIsa0NBQWtDLHlEQUF5RCxJQUFJLG9CQUFvQixtQ0FBbUMsbUNBQW1DLG9FQUFvRSxhQUFhLGVBQWUseUNBQXlDLG1DQUFtQyw4QkFBOEIsMEJBQTBCLGtDQUFrQywyREFBMkQsSUFBSSwrQkFBK0IseURBQXlELHNCQUFzQiwwQkFBMEIsZ0NBQWdDLG1DQUFtQyxvQ0FBb0MsMEJBQTBCLDRCQUE0Qix3QkFBd0Isb0JBQW9CLGFBQWEsMENBQTBDLHdCQUF3QixzQ0FBc0Msb0NBQW9DLDBCQUEwQiw0QkFBNEIseUJBQXlCLFNBQVMsYUFBYSwwQ0FBMEMsR0FBRyxnQ0FBZ0Msa0VBQWtFLG9FQUFvRSx5QkFBeUIsc0RBQXNELGlEQUFpRCwwQkFBMEIseUNBQXlDLEdBQUcsdURBQXVELEdBQUcsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvd29ya2VycG9vbC9zcmMvZ2VuZXJhdGVkL2VtYmVkZGVkV29ya2VyLmpzPzYxYTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBlbWJlZGRlZFdvcmtlci5qcyBjb250YWlucyBhbiBlbWJlZGRlZCB2ZXJzaW9uIG9mIHdvcmtlci5qcy5cbiAqIFRoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCxcbiAqIGNoYW5nZXMgbWFkZSBpbiB0aGlzIGZpbGUgd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBcIiFmdW5jdGlvbigpe3ZhciBfX3dlYnBhY2tfbW9kdWxlc19fPXs1Nzc6ZnVuY3Rpb24oZSl7ZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7dGhpcy5tZXNzYWdlPWUsdGhpcy50cmFuc2Zlcj1yfX19LF9fd2VicGFja19tb2R1bGVfY2FjaGVfXz17fTtmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKGUpe3ZhciByPV9fd2VicGFja19tb2R1bGVfY2FjaGVfX1tlXTtyZXR1cm4gdm9pZCAwIT09cnx8KHI9X193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW2VdPXtleHBvcnRzOnt9fSxfX3dlYnBhY2tfbW9kdWxlc19fW2VdKHIsci5leHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pKSxyLmV4cG9ydHN9dmFyIF9fd2VicGFja19leHBvcnRzX189e307IWZ1bmN0aW9uKCl7dmFyIGV4cG9ydHM9X193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfdW51c2VkX2V4cG9ydF9fO2Z1bmN0aW9uIF90eXBlb2YoZSl7cmV0dXJuKF90eXBlb2Y9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIFN5bWJvbCYmXFxcInN5bWJvbFxcXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XFxcInN5bWJvbFxcXCI6dHlwZW9mIGV9KShlKX12YXIgVHJhbnNmZXI9X193ZWJwYWNrX3JlcXVpcmVfXyg1NzcpLHJlcXVpcmVGb29sV2VicGFjaz1ldmFsKFxcXCJ0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcgPyByZXF1aXJlIDogZnVuY3Rpb24gKG1vZHVsZSkgeyB0aHJvdyBuZXcgRXJyb3IoJ01vZHVsZSBcXFxcXFxcIiArIG1vZHVsZSArIFxcXFxcXFwiIG5vdCBmb3VuZC4nKSB9XFxcIiksVEVSTUlOQVRFX01FVEhPRF9JRD1cXFwiX193b3JrZXJwb29sLXRlcm1pbmF0ZV9fXFxcIix3b3JrZXI9e2V4aXQ6ZnVuY3Rpb24oKXt9fSxXb3JrZXJUaHJlYWRzLHBhcmVudFBvcnQ7aWYoXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBzZWxmJiZcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgcG9zdE1lc3NhZ2UmJlxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBhZGRFdmVudExpc3RlbmVyKXdvcmtlci5vbj1mdW5jdGlvbihlLHIpe2FkZEV2ZW50TGlzdGVuZXIoZSxmdW5jdGlvbihlKXtyKGUuZGF0YSl9KX0sd29ya2VyLnNlbmQ9ZnVuY3Rpb24oZSl7cG9zdE1lc3NhZ2UoZSl9O2Vsc2V7aWYoXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBwcm9jZXNzKXRocm93IG5ldyBFcnJvcihcXFwiU2NyaXB0IG11c3QgYmUgZXhlY3V0ZWQgYXMgYSB3b3JrZXJcXFwiKTt0cnl7V29ya2VyVGhyZWFkcz1yZXF1aXJlRm9vbFdlYnBhY2soXFxcIndvcmtlcl90aHJlYWRzXFxcIil9Y2F0Y2goZXJyb3Ipe2lmKFxcXCJvYmplY3RcXFwiIT09X3R5cGVvZihlcnJvcil8fG51bGw9PT1lcnJvcnx8XFxcIk1PRFVMRV9OT1RfRk9VTkRcXFwiIT09ZXJyb3IuY29kZSl0aHJvdyBlcnJvcn1Xb3JrZXJUaHJlYWRzJiZudWxsIT09V29ya2VyVGhyZWFkcy5wYXJlbnRQb3J0PyhwYXJlbnRQb3J0PVdvcmtlclRocmVhZHMucGFyZW50UG9ydCx3b3JrZXIuc2VuZD1wYXJlbnRQb3J0LnBvc3RNZXNzYWdlLmJpbmQocGFyZW50UG9ydCksd29ya2VyLm9uPXBhcmVudFBvcnQub24uYmluZChwYXJlbnRQb3J0KSk6KHdvcmtlci5vbj1wcm9jZXNzLm9uLmJpbmQocHJvY2Vzcyksd29ya2VyLnNlbmQ9ZnVuY3Rpb24oZSl7cHJvY2Vzcy5zZW5kKGUpfSx3b3JrZXIub24oXFxcImRpc2Nvbm5lY3RcXFwiLGZ1bmN0aW9uKCl7cHJvY2Vzcy5leGl0KDEpfSkpLHdvcmtlci5leGl0PXByb2Nlc3MuZXhpdC5iaW5kKHByb2Nlc3MpfWZ1bmN0aW9uIGNvbnZlcnRFcnJvcihvKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobykucmVkdWNlKGZ1bmN0aW9uKGUscil7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse3ZhbHVlOm9bcl0sZW51bWVyYWJsZTohMH0pfSx7fSl9ZnVuY3Rpb24gaXNQcm9taXNlKGUpe3JldHVybiBlJiZcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZS50aGVuJiZcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZS5jYXRjaH13b3JrZXIubWV0aG9kcz17fSx3b3JrZXIubWV0aG9kcy5ydW49ZnVuY3Rpb24oZSxyKXtlPW5ldyBGdW5jdGlvbihcXFwicmV0dXJuIChcXFwiK2UrXFxcIikuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcXFwiKTtyZXR1cm4gZS5hcHBseShlLHIpfSx3b3JrZXIubWV0aG9kcy5tZXRob2RzPWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5rZXlzKHdvcmtlci5tZXRob2RzKX0sd29ya2VyLnRlcm1pbmF0aW9uSGFuZGxlcj12b2lkIDAsd29ya2VyLmNsZWFudXBBbmRFeGl0PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHIoKXt3b3JrZXIuZXhpdChlKX1pZighd29ya2VyLnRlcm1pbmF0aW9uSGFuZGxlcilyZXR1cm4gcigpO3ZhciBvPXdvcmtlci50ZXJtaW5hdGlvbkhhbmRsZXIoZSk7aXNQcm9taXNlKG8pP28udGhlbihyLHIpOnIoKX07dmFyIGN1cnJlbnRSZXF1ZXN0SWQ9bnVsbDt3b3JrZXIub24oXFxcIm1lc3NhZ2VcXFwiLGZ1bmN0aW9uKHIpe2lmKHI9PT1URVJNSU5BVEVfTUVUSE9EX0lEKXJldHVybiB3b3JrZXIuY2xlYW51cEFuZEV4aXQoMCk7dHJ5e3ZhciBlPXdvcmtlci5tZXRob2RzW3IubWV0aG9kXTtpZighZSl0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbWV0aG9kIFxcXCInK3IubWV0aG9kKydcXFwiJyk7Y3VycmVudFJlcXVlc3RJZD1yLmlkO3ZhciBvPWUuYXBwbHkoZSxyLnBhcmFtcyk7aXNQcm9taXNlKG8pP28udGhlbihmdW5jdGlvbihlKXtlIGluc3RhbmNlb2YgVHJhbnNmZXI/d29ya2VyLnNlbmQoe2lkOnIuaWQscmVzdWx0OmUubWVzc2FnZSxlcnJvcjpudWxsfSxlLnRyYW5zZmVyKTp3b3JrZXIuc2VuZCh7aWQ6ci5pZCxyZXN1bHQ6ZSxlcnJvcjpudWxsfSksY3VycmVudFJlcXVlc3RJZD1udWxsfSkuY2F0Y2goZnVuY3Rpb24oZSl7d29ya2VyLnNlbmQoe2lkOnIuaWQscmVzdWx0Om51bGwsZXJyb3I6Y29udmVydEVycm9yKGUpfSksY3VycmVudFJlcXVlc3RJZD1udWxsfSk6KG8gaW5zdGFuY2VvZiBUcmFuc2Zlcj93b3JrZXIuc2VuZCh7aWQ6ci5pZCxyZXN1bHQ6by5tZXNzYWdlLGVycm9yOm51bGx9LG8udHJhbnNmZXIpOndvcmtlci5zZW5kKHtpZDpyLmlkLHJlc3VsdDpvLGVycm9yOm51bGx9KSxjdXJyZW50UmVxdWVzdElkPW51bGwpfWNhdGNoKGUpe3dvcmtlci5zZW5kKHtpZDpyLmlkLHJlc3VsdDpudWxsLGVycm9yOmNvbnZlcnRFcnJvcihlKX0pfX0pLHdvcmtlci5yZWdpc3Rlcj1mdW5jdGlvbihlLHIpe2lmKGUpZm9yKHZhciBvIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShvKSYmKHdvcmtlci5tZXRob2RzW29dPWVbb10pO3ImJih3b3JrZXIudGVybWluYXRpb25IYW5kbGVyPXIub25UZXJtaW5hdGUpLHdvcmtlci5zZW5kKFxcXCJyZWFkeVxcXCIpfSx3b3JrZXIuZW1pdD1mdW5jdGlvbihlKXtjdXJyZW50UmVxdWVzdElkJiYoZSBpbnN0YW5jZW9mIFRyYW5zZmVyP3dvcmtlci5zZW5kKHtpZDpjdXJyZW50UmVxdWVzdElkLGlzRXZlbnQ6ITAscGF5bG9hZDplLm1lc3NhZ2V9LGUudHJhbnNmZXIpOndvcmtlci5zZW5kKHtpZDpjdXJyZW50UmVxdWVzdElkLGlzRXZlbnQ6ITAscGF5bG9hZDplfSkpfSxfX3dlYnBhY2tfdW51c2VkX2V4cG9ydF9fPXdvcmtlci5yZWdpc3Rlcix3b3JrZXIuZW1pdH0oKX0oKTtcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/workerpool/src/generated/embeddedWorker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/workerpool/src/index.js":
/*!**********************************************!*\
  !*** ./node_modules/workerpool/src/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var environment = __webpack_require__(/*! ./environment */ \"(ssr)/./node_modules/workerpool/src/environment.js\");\n\n/**\n * Create a new worker pool\n * @param {string} [script]\n * @param {WorkerPoolOptions} [options]\n * @returns {Pool} pool\n */\nexports.pool = function pool(script, options) {\n  var Pool = __webpack_require__(/*! ./Pool */ \"(ssr)/./node_modules/workerpool/src/Pool.js\");\n\n  return new Pool(script, options);\n};\n\n/**\n * Create a worker and optionally register a set of methods to the worker.\n * @param {Object} [methods]\n * @param {WorkerRegisterOptions} [options]\n */\nexports.worker = function worker(methods, options) {\n  var worker = __webpack_require__(/*! ./worker */ \"(ssr)/./node_modules/workerpool/src/worker.js\");\n  worker.add(methods, options);\n};\n\n/**\n * Sends an event to the parent worker pool.\n * @param {any} payload \n */\nexports.workerEmit = function workerEmit(payload) {\n  var worker = __webpack_require__(/*! ./worker */ \"(ssr)/./node_modules/workerpool/src/worker.js\");\n  worker.emit(payload);\n};\n\n/**\n * Create a promise.\n * @type {Promise} promise\n */\nexports.Promise = __webpack_require__(/*! ./Promise */ \"(ssr)/./node_modules/workerpool/src/Promise.js\");\n\n/**\n * Create a transfer object.\n * @type {Transfer} transfer\n */\nexports.Transfer = __webpack_require__(/*! ./transfer */ \"(ssr)/./node_modules/workerpool/src/transfer.js\");\n\nexports.platform = environment.platform;\nexports.isMainThread = environment.isMainThread;\nexports.cpus = environment.cpus;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd29ya2VycG9vbC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsa0JBQWtCLG1CQUFPLENBQUMseUVBQWU7O0FBRXpDO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxNQUFNO0FBQ25CO0FBQ0EsWUFBWTtBQUNaLGFBQWEsbUJBQU8sQ0FBQywyREFBUTs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0EsY0FBYztBQUNkLGVBQWUsbUJBQU8sQ0FBQywrREFBVTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQSxrQkFBa0I7QUFDbEIsZUFBZSxtQkFBTyxDQUFDLCtEQUFVO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBLHdHQUFzQzs7QUFFdEM7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBLDJHQUF3Qzs7QUFFeEMsZ0JBQWdCO0FBQ2hCLG9CQUFvQjtBQUNwQixZQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy93b3JrZXJwb29sL3NyYy9pbmRleC5qcz8zZGU3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBlbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vZW52aXJvbm1lbnQnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgd29ya2VyIHBvb2xcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0XVxuICogQHBhcmFtIHtXb3JrZXJQb29sT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7UG9vbH0gcG9vbFxuICovXG5leHBvcnRzLnBvb2wgPSBmdW5jdGlvbiBwb29sKHNjcmlwdCwgb3B0aW9ucykge1xuICB2YXIgUG9vbCA9IHJlcXVpcmUoJy4vUG9vbCcpO1xuXG4gIHJldHVybiBuZXcgUG9vbChzY3JpcHQsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSB3b3JrZXIgYW5kIG9wdGlvbmFsbHkgcmVnaXN0ZXIgYSBzZXQgb2YgbWV0aG9kcyB0byB0aGUgd29ya2VyLlxuICogQHBhcmFtIHtPYmplY3R9IFttZXRob2RzXVxuICogQHBhcmFtIHtXb3JrZXJSZWdpc3Rlck9wdGlvbnN9IFtvcHRpb25zXVxuICovXG5leHBvcnRzLndvcmtlciA9IGZ1bmN0aW9uIHdvcmtlcihtZXRob2RzLCBvcHRpb25zKSB7XG4gIHZhciB3b3JrZXIgPSByZXF1aXJlKCcuL3dvcmtlcicpO1xuICB3b3JrZXIuYWRkKG1ldGhvZHMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhbiBldmVudCB0byB0aGUgcGFyZW50IHdvcmtlciBwb29sLlxuICogQHBhcmFtIHthbnl9IHBheWxvYWQgXG4gKi9cbmV4cG9ydHMud29ya2VyRW1pdCA9IGZ1bmN0aW9uIHdvcmtlckVtaXQocGF5bG9hZCkge1xuICB2YXIgd29ya2VyID0gcmVxdWlyZSgnLi93b3JrZXInKTtcbiAgd29ya2VyLmVtaXQocGF5bG9hZCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHByb21pc2UuXG4gKiBAdHlwZSB7UHJvbWlzZX0gcHJvbWlzZVxuICovXG5leHBvcnRzLlByb21pc2UgPSByZXF1aXJlKCcuL1Byb21pc2UnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSB0cmFuc2ZlciBvYmplY3QuXG4gKiBAdHlwZSB7VHJhbnNmZXJ9IHRyYW5zZmVyXG4gKi9cbmV4cG9ydHMuVHJhbnNmZXIgPSByZXF1aXJlKCcuL3RyYW5zZmVyJyk7XG5cbmV4cG9ydHMucGxhdGZvcm0gPSBlbnZpcm9ubWVudC5wbGF0Zm9ybTtcbmV4cG9ydHMuaXNNYWluVGhyZWFkID0gZW52aXJvbm1lbnQuaXNNYWluVGhyZWFkO1xuZXhwb3J0cy5jcHVzID0gZW52aXJvbm1lbnQuY3B1czsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/workerpool/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/workerpool/src/requireFoolWebpack.js":
/*!***********************************************************!*\
  !*** ./node_modules/workerpool/src/requireFoolWebpack.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("// source of inspiration: https://github.com/sindresorhus/require-fool-webpack\nvar requireFoolWebpack = eval(\n    'typeof require !== \\'undefined\\' ' +\n    '? require ' +\n    ': function (module) { throw new Error(\\'Module \" + module + \" not found.\\') }'\n);\n\nmodule.exports = requireFoolWebpack;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd29ya2VycG9vbC9zcmMvcmVxdWlyZUZvb2xXZWJwYWNrLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVEQUF1RDtBQUNsRjs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvd29ya2VycG9vbC9zcmMvcmVxdWlyZUZvb2xXZWJwYWNrLmpzP2FlMzUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc291cmNlIG9mIGluc3BpcmF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3JlcXVpcmUtZm9vbC13ZWJwYWNrXG52YXIgcmVxdWlyZUZvb2xXZWJwYWNrID0gZXZhbChcbiAgICAndHlwZW9mIHJlcXVpcmUgIT09IFxcJ3VuZGVmaW5lZFxcJyAnICtcbiAgICAnPyByZXF1aXJlICcgK1xuICAgICc6IGZ1bmN0aW9uIChtb2R1bGUpIHsgdGhyb3cgbmV3IEVycm9yKFxcJ01vZHVsZSBcIiArIG1vZHVsZSArIFwiIG5vdCBmb3VuZC5cXCcpIH0nXG4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVGb29sV2VicGFjaztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/workerpool/src/requireFoolWebpack.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/workerpool/src/transfer.js":
/*!*************************************************!*\
  !*** ./node_modules/workerpool/src/transfer.js ***!
  \*************************************************/
/***/ ((module) => {

eval("/**\n * The helper class for transferring data from the worker to the main thread.\n *\n * @param {Object} message The object to deliver to the main thread.\n * @param {Object[]} transfer An array of transferable Objects to transfer ownership of.\n */\nfunction Transfer(message, transfer) {\n  this.message = message;\n  this.transfer = transfer;\n}\n\nmodule.exports = Transfer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd29ya2VycG9vbC9zcmMvdHJhbnNmZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pc3dhcF9jbG9uZS8uL25vZGVfbW9kdWxlcy93b3JrZXJwb29sL3NyYy90cmFuc2Zlci5qcz9lZmQ3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhlIGhlbHBlciBjbGFzcyBmb3IgdHJhbnNmZXJyaW5nIGRhdGEgZnJvbSB0aGUgd29ya2VyIHRvIHRoZSBtYWluIHRocmVhZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWVzc2FnZSBUaGUgb2JqZWN0IHRvIGRlbGl2ZXIgdG8gdGhlIG1haW4gdGhyZWFkLlxuICogQHBhcmFtIHtPYmplY3RbXX0gdHJhbnNmZXIgQW4gYXJyYXkgb2YgdHJhbnNmZXJhYmxlIE9iamVjdHMgdG8gdHJhbnNmZXIgb3duZXJzaGlwIG9mLlxuICovXG5mdW5jdGlvbiBUcmFuc2ZlcihtZXNzYWdlLCB0cmFuc2Zlcikge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnRyYW5zZmVyID0gdHJhbnNmZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/workerpool/src/transfer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/workerpool/src/worker.js":
/*!***********************************************!*\
  !*** ./node_modules/workerpool/src/worker.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * worker must be started as a child process or a web worker.\n * It listens for RPC messages from the parent process.\n */\nvar Transfer = __webpack_require__(/*! ./transfer */ \"(ssr)/./node_modules/workerpool/src/transfer.js\");\n\n// source of inspiration: https://github.com/sindresorhus/require-fool-webpack\nvar requireFoolWebpack = eval(\n    'typeof require !== \\'undefined\\'' +\n    ' ? require' +\n    ' : function (module) { throw new Error(\\'Module \" + module + \" not found.\\') }'\n);\n\n/**\n * Special message sent by parent which causes the worker to terminate itself.\n * Not a \"message object\"; this string is the entire message.\n */\nvar TERMINATE_METHOD_ID = '__workerpool-terminate__';\n\n// var nodeOSPlatform = require('./environment').nodeOSPlatform;\n\n// create a worker API for sending and receiving messages which works both on\n// node.js and in the browser\nvar worker = {\n  exit: function() {}\n};\nif (typeof self !== 'undefined' && typeof postMessage === 'function' && typeof addEventListener === 'function') {\n  // worker in the browser\n  worker.on = function (event, callback) {\n    addEventListener(event, function (message) {\n      callback(message.data);\n    })\n  };\n  worker.send = function (message) {\n    postMessage(message);\n  };\n}\nelse if (typeof process !== 'undefined') {\n  // node.js\n\n  var WorkerThreads;\n  try {\n    WorkerThreads = requireFoolWebpack('worker_threads');\n  } catch(error) {\n    if (typeof error === 'object' && error !== null && error.code === 'MODULE_NOT_FOUND') {\n      // no worker_threads, fallback to sub-process based workers\n    } else {\n      throw error;\n    }\n  }\n\n  if (WorkerThreads &&\n    /* if there is a parentPort, we are in a WorkerThread */\n    WorkerThreads.parentPort !== null) {\n    var parentPort  = WorkerThreads.parentPort;\n    worker.send = parentPort.postMessage.bind(parentPort);\n    worker.on = parentPort.on.bind(parentPort);\n    worker.exit = process.exit.bind(process);\n  } else {\n    worker.on = process.on.bind(process);\n    // ignore transfer argument since it is not supported by process\n    worker.send = function (message) {\n      process.send(message);\n    };\n    // register disconnect handler only for subprocess worker to exit when parent is killed unexpectedly\n    worker.on('disconnect', function () {\n      process.exit(1);\n    });\n    worker.exit = process.exit.bind(process);\n  }\n}\nelse {\n  throw new Error('Script must be executed as a worker');\n}\n\nfunction convertError(error) {\n  return Object.getOwnPropertyNames(error).reduce(function(product, name) {\n    return Object.defineProperty(product, name, {\n\tvalue: error[name],\n\tenumerable: true\n    });\n  }, {});\n}\n\n/**\n * Test whether a value is a Promise via duck typing.\n * @param {*} value\n * @returns {boolean} Returns true when given value is an object\n *                    having functions `then` and `catch`.\n */\nfunction isPromise(value) {\n  return value && (typeof value.then === 'function') && (typeof value.catch === 'function');\n}\n\n// functions available externally\nworker.methods = {};\n\n/**\n * Execute a function with provided arguments\n * @param {String} fn     Stringified function\n * @param {Array} [args]  Function arguments\n * @returns {*}\n */\nworker.methods.run = function run(fn, args) {\n  var f = new Function('return (' + fn + ').apply(null, arguments);');\n  return f.apply(f, args);\n};\n\n/**\n * Get a list with methods available on this worker\n * @return {String[]} methods\n */\nworker.methods.methods = function methods() {\n  return Object.keys(worker.methods);\n};\n\n/**\n * Custom handler for when the worker is terminated.\n */\nworker.terminationHandler = undefined;\n\n/**\n * Cleanup and exit the worker.\n * @param {Number} code \n * @returns \n */\nworker.cleanupAndExit = function(code) {\n  var _exit = function() {\n    worker.exit(code);\n  }\n\n  if(!worker.terminationHandler) {\n    return _exit();\n  }\n\n  var result = worker.terminationHandler(code);\n  if (isPromise(result)) {\n    result.then(_exit, _exit);\n  } else {\n    _exit();\n  }\n}\n\nvar currentRequestId = null;\n\nworker.on('message', function (request) {\n  if (request === TERMINATE_METHOD_ID) {\n    return worker.cleanupAndExit(0);\n  }\n  try {\n    var method = worker.methods[request.method];\n\n    if (method) {\n      currentRequestId = request.id;\n      \n      // execute the function\n      var result = method.apply(method, request.params);\n\n      if (isPromise(result)) {\n        // promise returned, resolve this and then return\n        result\n            .then(function (result) {\n              if (result instanceof Transfer) {\n                worker.send({\n                  id: request.id,\n                  result: result.message,\n                  error: null\n                }, result.transfer);\n              } else {\n                worker.send({\n                  id: request.id,\n                  result: result,\n                  error: null\n                });\n              }\n              currentRequestId = null;\n            })\n            .catch(function (err) {\n              worker.send({\n                id: request.id,\n                result: null,\n                error: convertError(err)\n              });\n              currentRequestId = null;\n            });\n      }\n      else {\n        // immediate result\n        if (result instanceof Transfer) {\n          worker.send({\n            id: request.id,\n            result: result.message,\n            error: null\n          }, result.transfer);\n        } else {\n          worker.send({\n            id: request.id,\n            result: result,\n            error: null\n          });\n        }\n\n        currentRequestId = null;\n      }\n    }\n    else {\n      throw new Error('Unknown method \"' + request.method + '\"');\n    }\n  }\n  catch (err) {\n    worker.send({\n      id: request.id,\n      result: null,\n      error: convertError(err)\n    });\n  }\n});\n\n/**\n * Register methods to the worker\n * @param {Object} [methods]\n * @param {WorkerRegisterOptions} [options]\n */\nworker.register = function (methods, options) {\n\n  if (methods) {\n    for (var name in methods) {\n      if (methods.hasOwnProperty(name)) {\n        worker.methods[name] = methods[name];\n      }\n    }\n  }\n\n  if (options) {\n    worker.terminationHandler = options.onTerminate;\n  }\n\n  worker.send('ready');\n};\n\nworker.emit = function (payload) {\n  if (currentRequestId) {\n    if (payload instanceof Transfer) {\n      worker.send({\n        id: currentRequestId,\n        isEvent: true,\n        payload: payload.message\n      }, payload.transfer);\n      return;\n    }\n\n    worker.send({\n      id: currentRequestId,\n      isEvent: true,\n      payload\n    });\n  }\n};\n\nif (true) {\n  exports.add = worker.register;\n  exports.emit = worker.emit;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd29ya2VycG9vbC9zcmMvd29ya2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLG1FQUFZOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1REFBdUQ7QUFDbkY7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsSUFBSTtBQUNQOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsSUFBSSxJQUE4QjtBQUNsQyxFQUFFLFdBQVc7QUFDYixFQUFFLFlBQVk7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvd29ya2VycG9vbC9zcmMvd29ya2VyLmpzPzBiZWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB3b3JrZXIgbXVzdCBiZSBzdGFydGVkIGFzIGEgY2hpbGQgcHJvY2VzcyBvciBhIHdlYiB3b3JrZXIuXG4gKiBJdCBsaXN0ZW5zIGZvciBSUEMgbWVzc2FnZXMgZnJvbSB0aGUgcGFyZW50IHByb2Nlc3MuXG4gKi9cbnZhciBUcmFuc2ZlciA9IHJlcXVpcmUoJy4vdHJhbnNmZXInKTtcblxuLy8gc291cmNlIG9mIGluc3BpcmF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3JlcXVpcmUtZm9vbC13ZWJwYWNrXG52YXIgcmVxdWlyZUZvb2xXZWJwYWNrID0gZXZhbChcbiAgICAndHlwZW9mIHJlcXVpcmUgIT09IFxcJ3VuZGVmaW5lZFxcJycgK1xuICAgICcgPyByZXF1aXJlJyArXG4gICAgJyA6IGZ1bmN0aW9uIChtb2R1bGUpIHsgdGhyb3cgbmV3IEVycm9yKFxcJ01vZHVsZSBcIiArIG1vZHVsZSArIFwiIG5vdCBmb3VuZC5cXCcpIH0nXG4pO1xuXG4vKipcbiAqIFNwZWNpYWwgbWVzc2FnZSBzZW50IGJ5IHBhcmVudCB3aGljaCBjYXVzZXMgdGhlIHdvcmtlciB0byB0ZXJtaW5hdGUgaXRzZWxmLlxuICogTm90IGEgXCJtZXNzYWdlIG9iamVjdFwiOyB0aGlzIHN0cmluZyBpcyB0aGUgZW50aXJlIG1lc3NhZ2UuXG4gKi9cbnZhciBURVJNSU5BVEVfTUVUSE9EX0lEID0gJ19fd29ya2VycG9vbC10ZXJtaW5hdGVfXyc7XG5cbi8vIHZhciBub2RlT1NQbGF0Zm9ybSA9IHJlcXVpcmUoJy4vZW52aXJvbm1lbnQnKS5ub2RlT1NQbGF0Zm9ybTtcblxuLy8gY3JlYXRlIGEgd29ya2VyIEFQSSBmb3Igc2VuZGluZyBhbmQgcmVjZWl2aW5nIG1lc3NhZ2VzIHdoaWNoIHdvcmtzIGJvdGggb25cbi8vIG5vZGUuanMgYW5kIGluIHRoZSBicm93c2VyXG52YXIgd29ya2VyID0ge1xuICBleGl0OiBmdW5jdGlvbigpIHt9XG59O1xuaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gd29ya2VyIGluIHRoZSBicm93c2VyXG4gIHdvcmtlci5vbiA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgICBhZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgY2FsbGJhY2sobWVzc2FnZS5kYXRhKTtcbiAgICB9KVxuICB9O1xuICB3b3JrZXIuc2VuZCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgcG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gIH07XG59XG5lbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gbm9kZS5qc1xuXG4gIHZhciBXb3JrZXJUaHJlYWRzO1xuICB0cnkge1xuICAgIFdvcmtlclRocmVhZHMgPSByZXF1aXJlRm9vbFdlYnBhY2soJ3dvcmtlcl90aHJlYWRzJyk7XG4gIH0gY2F0Y2goZXJyb3IpIHtcbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiBlcnJvci5jb2RlID09PSAnTU9EVUxFX05PVF9GT1VORCcpIHtcbiAgICAgIC8vIG5vIHdvcmtlcl90aHJlYWRzLCBmYWxsYmFjayB0byBzdWItcHJvY2VzcyBiYXNlZCB3b3JrZXJzXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGlmIChXb3JrZXJUaHJlYWRzICYmXG4gICAgLyogaWYgdGhlcmUgaXMgYSBwYXJlbnRQb3J0LCB3ZSBhcmUgaW4gYSBXb3JrZXJUaHJlYWQgKi9cbiAgICBXb3JrZXJUaHJlYWRzLnBhcmVudFBvcnQgIT09IG51bGwpIHtcbiAgICB2YXIgcGFyZW50UG9ydCAgPSBXb3JrZXJUaHJlYWRzLnBhcmVudFBvcnQ7XG4gICAgd29ya2VyLnNlbmQgPSBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlLmJpbmQocGFyZW50UG9ydCk7XG4gICAgd29ya2VyLm9uID0gcGFyZW50UG9ydC5vbi5iaW5kKHBhcmVudFBvcnQpO1xuICAgIHdvcmtlci5leGl0ID0gcHJvY2Vzcy5leGl0LmJpbmQocHJvY2Vzcyk7XG4gIH0gZWxzZSB7XG4gICAgd29ya2VyLm9uID0gcHJvY2Vzcy5vbi5iaW5kKHByb2Nlc3MpO1xuICAgIC8vIGlnbm9yZSB0cmFuc2ZlciBhcmd1bWVudCBzaW5jZSBpdCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHByb2Nlc3NcbiAgICB3b3JrZXIuc2VuZCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICBwcm9jZXNzLnNlbmQobWVzc2FnZSk7XG4gICAgfTtcbiAgICAvLyByZWdpc3RlciBkaXNjb25uZWN0IGhhbmRsZXIgb25seSBmb3Igc3VicHJvY2VzcyB3b3JrZXIgdG8gZXhpdCB3aGVuIHBhcmVudCBpcyBraWxsZWQgdW5leHBlY3RlZGx5XG4gICAgd29ya2VyLm9uKCdkaXNjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgIH0pO1xuICAgIHdvcmtlci5leGl0ID0gcHJvY2Vzcy5leGl0LmJpbmQocHJvY2Vzcyk7XG4gIH1cbn1cbmVsc2Uge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1NjcmlwdCBtdXN0IGJlIGV4ZWN1dGVkIGFzIGEgd29ya2VyJyk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRFcnJvcihlcnJvcikge1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZXJyb3IpLnJlZHVjZShmdW5jdGlvbihwcm9kdWN0LCBuYW1lKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9kdWN0LCBuYW1lLCB7XG5cdHZhbHVlOiBlcnJvcltuYW1lXSxcblx0ZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9LCB7fSk7XG59XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGEgdmFsdWUgaXMgYSBQcm9taXNlIHZpYSBkdWNrIHR5cGluZy5cbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgd2hlbiBnaXZlbiB2YWx1ZSBpcyBhbiBvYmplY3RcbiAqICAgICAgICAgICAgICAgICAgICBoYXZpbmcgZnVuY3Rpb25zIGB0aGVuYCBhbmQgYGNhdGNoYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmJiAodHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpICYmICh0eXBlb2YgdmFsdWUuY2F0Y2ggPT09ICdmdW5jdGlvbicpO1xufVxuXG4vLyBmdW5jdGlvbnMgYXZhaWxhYmxlIGV4dGVybmFsbHlcbndvcmtlci5tZXRob2RzID0ge307XG5cbi8qKlxuICogRXhlY3V0ZSBhIGZ1bmN0aW9uIHdpdGggcHJvdmlkZWQgYXJndW1lbnRzXG4gKiBAcGFyYW0ge1N0cmluZ30gZm4gICAgIFN0cmluZ2lmaWVkIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJnc10gIEZ1bmN0aW9uIGFyZ3VtZW50c1xuICogQHJldHVybnMgeyp9XG4gKi9cbndvcmtlci5tZXRob2RzLnJ1biA9IGZ1bmN0aW9uIHJ1bihmbiwgYXJncykge1xuICB2YXIgZiA9IG5ldyBGdW5jdGlvbigncmV0dXJuICgnICsgZm4gKyAnKS5hcHBseShudWxsLCBhcmd1bWVudHMpOycpO1xuICByZXR1cm4gZi5hcHBseShmLCBhcmdzKTtcbn07XG5cbi8qKlxuICogR2V0IGEgbGlzdCB3aXRoIG1ldGhvZHMgYXZhaWxhYmxlIG9uIHRoaXMgd29ya2VyXG4gKiBAcmV0dXJuIHtTdHJpbmdbXX0gbWV0aG9kc1xuICovXG53b3JrZXIubWV0aG9kcy5tZXRob2RzID0gZnVuY3Rpb24gbWV0aG9kcygpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHdvcmtlci5tZXRob2RzKTtcbn07XG5cbi8qKlxuICogQ3VzdG9tIGhhbmRsZXIgZm9yIHdoZW4gdGhlIHdvcmtlciBpcyB0ZXJtaW5hdGVkLlxuICovXG53b3JrZXIudGVybWluYXRpb25IYW5kbGVyID0gdW5kZWZpbmVkO1xuXG4vKipcbiAqIENsZWFudXAgYW5kIGV4aXQgdGhlIHdvcmtlci5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFxuICogQHJldHVybnMgXG4gKi9cbndvcmtlci5jbGVhbnVwQW5kRXhpdCA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgdmFyIF9leGl0ID0gZnVuY3Rpb24oKSB7XG4gICAgd29ya2VyLmV4aXQoY29kZSk7XG4gIH1cblxuICBpZighd29ya2VyLnRlcm1pbmF0aW9uSGFuZGxlcikge1xuICAgIHJldHVybiBfZXhpdCgpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHdvcmtlci50ZXJtaW5hdGlvbkhhbmRsZXIoY29kZSk7XG4gIGlmIChpc1Byb21pc2UocmVzdWx0KSkge1xuICAgIHJlc3VsdC50aGVuKF9leGl0LCBfZXhpdCk7XG4gIH0gZWxzZSB7XG4gICAgX2V4aXQoKTtcbiAgfVxufVxuXG52YXIgY3VycmVudFJlcXVlc3RJZCA9IG51bGw7XG5cbndvcmtlci5vbignbWVzc2FnZScsIGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gIGlmIChyZXF1ZXN0ID09PSBURVJNSU5BVEVfTUVUSE9EX0lEKSB7XG4gICAgcmV0dXJuIHdvcmtlci5jbGVhbnVwQW5kRXhpdCgwKTtcbiAgfVxuICB0cnkge1xuICAgIHZhciBtZXRob2QgPSB3b3JrZXIubWV0aG9kc1tyZXF1ZXN0Lm1ldGhvZF07XG5cbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICBjdXJyZW50UmVxdWVzdElkID0gcmVxdWVzdC5pZDtcbiAgICAgIFxuICAgICAgLy8gZXhlY3V0ZSB0aGUgZnVuY3Rpb25cbiAgICAgIHZhciByZXN1bHQgPSBtZXRob2QuYXBwbHkobWV0aG9kLCByZXF1ZXN0LnBhcmFtcyk7XG5cbiAgICAgIGlmIChpc1Byb21pc2UocmVzdWx0KSkge1xuICAgICAgICAvLyBwcm9taXNlIHJldHVybmVkLCByZXNvbHZlIHRoaXMgYW5kIHRoZW4gcmV0dXJuXG4gICAgICAgIHJlc3VsdFxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgVHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgICB3b3JrZXIuc2VuZCh7XG4gICAgICAgICAgICAgICAgICBpZDogcmVxdWVzdC5pZCxcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0Lm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgICAgICAgIH0sIHJlc3VsdC50cmFuc2Zlcik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd29ya2VyLnNlbmQoe1xuICAgICAgICAgICAgICAgICAgaWQ6IHJlcXVlc3QuaWQsXG4gICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudFJlcXVlc3RJZCA9IG51bGw7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgd29ya2VyLnNlbmQoe1xuICAgICAgICAgICAgICAgIGlkOiByZXF1ZXN0LmlkLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogY29udmVydEVycm9yKGVycilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGN1cnJlbnRSZXF1ZXN0SWQgPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gaW1tZWRpYXRlIHJlc3VsdFxuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgVHJhbnNmZXIpIHtcbiAgICAgICAgICB3b3JrZXIuc2VuZCh7XG4gICAgICAgICAgICBpZDogcmVxdWVzdC5pZCxcbiAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0Lm1lc3NhZ2UsXG4gICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgIH0sIHJlc3VsdC50cmFuc2Zlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd29ya2VyLnNlbmQoe1xuICAgICAgICAgICAgaWQ6IHJlcXVlc3QuaWQsXG4gICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50UmVxdWVzdElkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbWV0aG9kIFwiJyArIHJlcXVlc3QubWV0aG9kICsgJ1wiJyk7XG4gICAgfVxuICB9XG4gIGNhdGNoIChlcnIpIHtcbiAgICB3b3JrZXIuc2VuZCh7XG4gICAgICBpZDogcmVxdWVzdC5pZCxcbiAgICAgIHJlc3VsdDogbnVsbCxcbiAgICAgIGVycm9yOiBjb252ZXJ0RXJyb3IoZXJyKVxuICAgIH0pO1xuICB9XG59KTtcblxuLyoqXG4gKiBSZWdpc3RlciBtZXRob2RzIHRvIHRoZSB3b3JrZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbbWV0aG9kc11cbiAqIEBwYXJhbSB7V29ya2VyUmVnaXN0ZXJPcHRpb25zfSBbb3B0aW9uc11cbiAqL1xud29ya2VyLnJlZ2lzdGVyID0gZnVuY3Rpb24gKG1ldGhvZHMsIG9wdGlvbnMpIHtcblxuICBpZiAobWV0aG9kcykge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKG1ldGhvZHMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgd29ya2VyLm1ldGhvZHNbbmFtZV0gPSBtZXRob2RzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgd29ya2VyLnRlcm1pbmF0aW9uSGFuZGxlciA9IG9wdGlvbnMub25UZXJtaW5hdGU7XG4gIH1cblxuICB3b3JrZXIuc2VuZCgncmVhZHknKTtcbn07XG5cbndvcmtlci5lbWl0ID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgaWYgKGN1cnJlbnRSZXF1ZXN0SWQpIHtcbiAgICBpZiAocGF5bG9hZCBpbnN0YW5jZW9mIFRyYW5zZmVyKSB7XG4gICAgICB3b3JrZXIuc2VuZCh7XG4gICAgICAgIGlkOiBjdXJyZW50UmVxdWVzdElkLFxuICAgICAgICBpc0V2ZW50OiB0cnVlLFxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLm1lc3NhZ2VcbiAgICAgIH0sIHBheWxvYWQudHJhbnNmZXIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdvcmtlci5zZW5kKHtcbiAgICAgIGlkOiBjdXJyZW50UmVxdWVzdElkLFxuICAgICAgaXNFdmVudDogdHJ1ZSxcbiAgICAgIHBheWxvYWRcbiAgICB9KTtcbiAgfVxufTtcblxuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICBleHBvcnRzLmFkZCA9IHdvcmtlci5yZWdpc3RlcjtcbiAgZXhwb3J0cy5lbWl0ID0gd29ya2VyLmVtaXQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/workerpool/src/worker.js\n");

/***/ })

};
;