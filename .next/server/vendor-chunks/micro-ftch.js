"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/micro-ftch";
exports.ids = ["vendor-chunks/micro-ftch"];
exports.modules = {

/***/ "(ssr)/./node_modules/micro-ftch/index.js":
/*!******************************************!*\
  !*** ./node_modules/micro-ftch/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InvalidStatusCodeError = exports.InvalidCertError = void 0;\nconst DEFAULT_OPT = Object.freeze({\n    redirect: true,\n    expectStatusCode: 200,\n    headers: {},\n    full: false,\n    keepAlive: true,\n    cors: false,\n    referrer: false,\n    sslAllowSelfSigned: false,\n    _redirectCount: 0,\n});\nclass InvalidCertError extends Error {\n    constructor(msg, fingerprint256) {\n        super(msg);\n        this.fingerprint256 = fingerprint256;\n    }\n}\nexports.InvalidCertError = InvalidCertError;\nclass InvalidStatusCodeError extends Error {\n    constructor(statusCode) {\n        super(`Request Failed. Status Code: ${statusCode}`);\n        this.statusCode = statusCode;\n    }\n}\nexports.InvalidStatusCodeError = InvalidStatusCodeError;\nfunction detectType(b, type) {\n    if (!type || type === 'text' || type === 'json') {\n        try {\n            let text = new TextDecoder('utf8', { fatal: true }).decode(b);\n            if (type === 'text')\n                return text;\n            try {\n                return JSON.parse(text);\n            }\n            catch (err) {\n                if (type === 'json')\n                    throw err;\n                return text;\n            }\n        }\n        catch (err) {\n            if (type === 'text' || type === 'json')\n                throw err;\n        }\n    }\n    return b;\n}\nlet agents = {};\nfunction fetchNode(url, _options) {\n    let options = { ...DEFAULT_OPT, ..._options };\n    const http = __webpack_require__(/*! http */ \"http\");\n    const https = __webpack_require__(/*! https */ \"https\");\n    const zlib = __webpack_require__(/*! zlib */ \"zlib\");\n    const { promisify } = __webpack_require__(/*! util */ \"util\");\n    const { resolve: urlResolve } = __webpack_require__(/*! url */ \"url\");\n    const isSecure = !!/^https/.test(url);\n    let opts = {\n        method: options.method || 'GET',\n        headers: { 'Accept-Encoding': 'gzip, deflate, br' },\n    };\n    const compactFP = (s) => s.replace(/:| /g, '').toLowerCase();\n    if (options.keepAlive) {\n        const agentOpt = {\n            keepAlive: true,\n            keepAliveMsecs: 30 * 1000,\n            maxFreeSockets: 1024,\n            maxCachedSessions: 1024,\n        };\n        const agentKey = [\n            isSecure,\n            isSecure && options.sslPinnedCertificates?.map((i) => compactFP(i)).sort(),\n        ].join();\n        opts.agent =\n            agents[agentKey] || (agents[agentKey] = new (isSecure ? https : http).Agent(agentOpt));\n    }\n    if (options.type === 'json')\n        opts.headers['Content-Type'] = 'application/json';\n    if (options.data) {\n        if (!options.method)\n            opts.method = 'POST';\n        opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;\n    }\n    opts.headers = { ...opts.headers, ...options.headers };\n    if (options.sslAllowSelfSigned)\n        opts.rejectUnauthorized = false;\n    const handleRes = async (res) => {\n        const status = res.statusCode;\n        if (options.redirect && 300 <= status && status < 400 && res.headers['location']) {\n            if (options._redirectCount == 10)\n                throw new Error('Request failed. Too much redirects.');\n            options._redirectCount += 1;\n            return await fetchNode(urlResolve(url, res.headers['location']), options);\n        }\n        if (options.expectStatusCode && status !== options.expectStatusCode) {\n            res.resume();\n            throw new InvalidStatusCodeError(status);\n        }\n        let buf = [];\n        for await (const chunk of res)\n            buf.push(chunk);\n        let bytes = Buffer.concat(buf);\n        const encoding = res.headers['content-encoding'];\n        if (encoding === 'br')\n            bytes = await promisify(zlib.brotliDecompress)(bytes);\n        if (encoding === 'gzip' || encoding === 'deflate')\n            bytes = await promisify(zlib.unzip)(bytes);\n        const body = detectType(bytes, options.type);\n        if (options.full)\n            return { headers: res.headers, status, body };\n        return body;\n    };\n    return new Promise((resolve, reject) => {\n        const handleError = async (err) => {\n            if (err && err.code === 'DEPTH_ZERO_SELF_SIGNED_CERT') {\n                try {\n                    await fetchNode(url, { ...options, sslAllowSelfSigned: true, sslPinnedCertificates: [] });\n                }\n                catch (e) {\n                    if (e && e.fingerprint256) {\n                        err = new InvalidCertError(`Self-signed SSL certificate: ${e.fingerprint256}`, e.fingerprint256);\n                    }\n                }\n            }\n            reject(err);\n        };\n        const req = (isSecure ? https : http).request(url, opts, (res) => {\n            res.on('error', handleError);\n            (async () => {\n                try {\n                    resolve(await handleRes(res));\n                }\n                catch (error) {\n                    reject(error);\n                }\n            })();\n        });\n        req.on('error', handleError);\n        const pinned = options.sslPinnedCertificates?.map((i) => compactFP(i));\n        const mfetchSecureConnect = (socket) => {\n            const fp256 = compactFP(socket.getPeerCertificate()?.fingerprint256 || '');\n            if (!fp256 && socket.isSessionReused())\n                return;\n            if (pinned.includes(fp256))\n                return;\n            req.emit('error', new InvalidCertError(`Invalid SSL certificate: ${fp256} Expected: ${pinned}`, fp256));\n            return req.abort();\n        };\n        if (options.sslPinnedCertificates) {\n            req.on('socket', (socket) => {\n                const hasListeners = socket\n                    .listeners('secureConnect')\n                    .map((i) => (i.name || '').replace('bound ', ''))\n                    .includes('mfetchSecureConnect');\n                if (hasListeners)\n                    return;\n                socket.on('secureConnect', mfetchSecureConnect.bind(null, socket));\n            });\n        }\n        if (options.keepAlive)\n            req.setNoDelay(true);\n        if (opts.body)\n            req.write(opts.body);\n        req.end();\n    });\n}\nconst SAFE_HEADERS = new Set(['Accept', 'Accept-Language', 'Content-Language', 'Content-Type'].map((i) => i.toLowerCase()));\nconst FORBIDDEN_HEADERS = new Set(['Accept-Charset', 'Accept-Encoding', 'Access-Control-Request-Headers', 'Access-Control-Request-Method',\n    'Connection', 'Content-Length', 'Cookie', 'Cookie2', 'Date', 'DNT', 'Expect', 'Host', 'Keep-Alive', 'Origin', 'Referer', 'TE', 'Trailer',\n    'Transfer-Encoding', 'Upgrade', 'Via'].map((i) => i.toLowerCase()));\nasync function fetchBrowser(url, _options) {\n    let options = { ...DEFAULT_OPT, ..._options };\n    const headers = new Headers();\n    if (options.type === 'json')\n        headers.set('Content-Type', 'application/json');\n    let parsed = new URL(url);\n    if (parsed.username) {\n        const auth = btoa(`${parsed.username}:${parsed.password}`);\n        headers.set('Authorization', `Basic ${auth}`);\n        parsed.username = '';\n        parsed.password = '';\n    }\n    url = '' + parsed;\n    for (let k in options.headers) {\n        const name = k.toLowerCase();\n        if (SAFE_HEADERS.has(name) || (options.cors && !FORBIDDEN_HEADERS.has(name)))\n            headers.set(k, options.headers[k]);\n    }\n    let opts = { headers, redirect: options.redirect ? 'follow' : 'manual' };\n    if (!options.referrer)\n        opts.referrerPolicy = 'no-referrer';\n    if (options.cors)\n        opts.mode = 'cors';\n    if (options.data) {\n        if (!options.method)\n            opts.method = 'POST';\n        opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;\n    }\n    const res = await fetch(url, opts);\n    if (options.expectStatusCode && res.status !== options.expectStatusCode)\n        throw new InvalidStatusCodeError(res.status);\n    const body = detectType(new Uint8Array(await res.arrayBuffer()), options.type);\n    if (options.full)\n        return { headers: Object.fromEntries(res.headers.entries()), status: res.status, body };\n    return body;\n}\nconst IS_NODE = !!(typeof process == 'object' &&\n    process.versions &&\n    process.versions.node &&\n    process.versions.v8);\nfunction fetchUrl(url, options) {\n    const fn = IS_NODE ? fetchNode : fetchBrowser;\n    return fn(url, options);\n}\nexports[\"default\"] = fetchUrl;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWljcm8tZnRjaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRyx3QkFBd0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLDhDQUE4QyxXQUFXO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLGlCQUFpQixtQkFBTyxDQUFDLGtCQUFNO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLG9CQUFPO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLGtCQUFNO0FBQy9CLFlBQVksWUFBWSxFQUFFLG1CQUFPLENBQUMsa0JBQU07QUFDeEMsWUFBWSxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLGdCQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3Q0FBd0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUVBQWlFO0FBQzVHO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixpQkFBaUI7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxPQUFPLFlBQVksT0FBTztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0IsR0FBRyxnQkFBZ0I7QUFDaEUsOENBQThDLEtBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXN3YXBfY2xvbmUvLi9ub2RlX21vZHVsZXMvbWljcm8tZnRjaC9pbmRleC5qcz84NjUzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnZhbGlkU3RhdHVzQ29kZUVycm9yID0gZXhwb3J0cy5JbnZhbGlkQ2VydEVycm9yID0gdm9pZCAwO1xuY29uc3QgREVGQVVMVF9PUFQgPSBPYmplY3QuZnJlZXplKHtcbiAgICByZWRpcmVjdDogdHJ1ZSxcbiAgICBleHBlY3RTdGF0dXNDb2RlOiAyMDAsXG4gICAgaGVhZGVyczoge30sXG4gICAgZnVsbDogZmFsc2UsXG4gICAga2VlcEFsaXZlOiB0cnVlLFxuICAgIGNvcnM6IGZhbHNlLFxuICAgIHJlZmVycmVyOiBmYWxzZSxcbiAgICBzc2xBbGxvd1NlbGZTaWduZWQ6IGZhbHNlLFxuICAgIF9yZWRpcmVjdENvdW50OiAwLFxufSk7XG5jbGFzcyBJbnZhbGlkQ2VydEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZywgZmluZ2VycHJpbnQyNTYpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5maW5nZXJwcmludDI1NiA9IGZpbmdlcnByaW50MjU2O1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZENlcnRFcnJvciA9IEludmFsaWRDZXJ0RXJyb3I7XG5jbGFzcyBJbnZhbGlkU3RhdHVzQ29kZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHN0YXR1c0NvZGUpIHtcbiAgICAgICAgc3VwZXIoYFJlcXVlc3QgRmFpbGVkLiBTdGF0dXMgQ29kZTogJHtzdGF0dXNDb2RlfWApO1xuICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZFN0YXR1c0NvZGVFcnJvciA9IEludmFsaWRTdGF0dXNDb2RlRXJyb3I7XG5mdW5jdGlvbiBkZXRlY3RUeXBlKGIsIHR5cGUpIHtcbiAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ3RleHQnIHx8IHR5cGUgPT09ICdqc29uJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnLCB7IGZhdGFsOiB0cnVlIH0pLmRlY29kZShiKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAndGV4dCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnanNvbicpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3RleHQnIHx8IHR5cGUgPT09ICdqc29uJylcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGI7XG59XG5sZXQgYWdlbnRzID0ge307XG5mdW5jdGlvbiBmZXRjaE5vZGUodXJsLCBfb3B0aW9ucykge1xuICAgIGxldCBvcHRpb25zID0geyAuLi5ERUZBVUxUX09QVCwgLi4uX29wdGlvbnMgfTtcbiAgICBjb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuICAgIGNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbiAgICBjb25zdCB6bGliID0gcmVxdWlyZSgnemxpYicpO1xuICAgIGNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCd1dGlsJyk7XG4gICAgY29uc3QgeyByZXNvbHZlOiB1cmxSZXNvbHZlIH0gPSByZXF1aXJlKCd1cmwnKTtcbiAgICBjb25zdCBpc1NlY3VyZSA9ICEhL15odHRwcy8udGVzdCh1cmwpO1xuICAgIGxldCBvcHRzID0ge1xuICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7ICdBY2NlcHQtRW5jb2RpbmcnOiAnZ3ppcCwgZGVmbGF0ZSwgYnInIH0sXG4gICAgfTtcbiAgICBjb25zdCBjb21wYWN0RlAgPSAocykgPT4gcy5yZXBsYWNlKC86fCAvZywgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKG9wdGlvbnMua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbnN0IGFnZW50T3B0ID0ge1xuICAgICAgICAgICAga2VlcEFsaXZlOiB0cnVlLFxuICAgICAgICAgICAga2VlcEFsaXZlTXNlY3M6IDMwICogMTAwMCxcbiAgICAgICAgICAgIG1heEZyZWVTb2NrZXRzOiAxMDI0LFxuICAgICAgICAgICAgbWF4Q2FjaGVkU2Vzc2lvbnM6IDEwMjQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFnZW50S2V5ID0gW1xuICAgICAgICAgICAgaXNTZWN1cmUsXG4gICAgICAgICAgICBpc1NlY3VyZSAmJiBvcHRpb25zLnNzbFBpbm5lZENlcnRpZmljYXRlcz8ubWFwKChpKSA9PiBjb21wYWN0RlAoaSkpLnNvcnQoKSxcbiAgICAgICAgXS5qb2luKCk7XG4gICAgICAgIG9wdHMuYWdlbnQgPVxuICAgICAgICAgICAgYWdlbnRzW2FnZW50S2V5XSB8fCAoYWdlbnRzW2FnZW50S2V5XSA9IG5ldyAoaXNTZWN1cmUgPyBodHRwcyA6IGh0dHApLkFnZW50KGFnZW50T3B0KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnR5cGUgPT09ICdqc29uJylcbiAgICAgICAgb3B0cy5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5tZXRob2QpXG4gICAgICAgICAgICBvcHRzLm1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgb3B0cy5ib2R5ID0gb3B0aW9ucy50eXBlID09PSAnanNvbicgPyBKU09OLnN0cmluZ2lmeShvcHRpb25zLmRhdGEpIDogb3B0aW9ucy5kYXRhO1xuICAgIH1cbiAgICBvcHRzLmhlYWRlcnMgPSB7IC4uLm9wdHMuaGVhZGVycywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgaWYgKG9wdGlvbnMuc3NsQWxsb3dTZWxmU2lnbmVkKVxuICAgICAgICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IGZhbHNlO1xuICAgIGNvbnN0IGhhbmRsZVJlcyA9IGFzeW5jIChyZXMpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzLnN0YXR1c0NvZGU7XG4gICAgICAgIGlmIChvcHRpb25zLnJlZGlyZWN0ICYmIDMwMCA8PSBzdGF0dXMgJiYgc3RhdHVzIDwgNDAwICYmIHJlcy5oZWFkZXJzWydsb2NhdGlvbiddKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5fcmVkaXJlY3RDb3VudCA9PSAxMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3QgZmFpbGVkLiBUb28gbXVjaCByZWRpcmVjdHMuJyk7XG4gICAgICAgICAgICBvcHRpb25zLl9yZWRpcmVjdENvdW50ICs9IDE7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZmV0Y2hOb2RlKHVybFJlc29sdmUodXJsLCByZXMuaGVhZGVyc1snbG9jYXRpb24nXSksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmV4cGVjdFN0YXR1c0NvZGUgJiYgc3RhdHVzICE9PSBvcHRpb25zLmV4cGVjdFN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIHJlcy5yZXN1bWUoKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkU3RhdHVzQ29kZUVycm9yKHN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJ1ZiA9IFtdO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlcylcbiAgICAgICAgICAgIGJ1Zi5wdXNoKGNodW5rKTtcbiAgICAgICAgbGV0IGJ5dGVzID0gQnVmZmVyLmNvbmNhdChidWYpO1xuICAgICAgICBjb25zdCBlbmNvZGluZyA9IHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ107XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2JyJylcbiAgICAgICAgICAgIGJ5dGVzID0gYXdhaXQgcHJvbWlzaWZ5KHpsaWIuYnJvdGxpRGVjb21wcmVzcykoYnl0ZXMpO1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdnemlwJyB8fCBlbmNvZGluZyA9PT0gJ2RlZmxhdGUnKVxuICAgICAgICAgICAgYnl0ZXMgPSBhd2FpdCBwcm9taXNpZnkoemxpYi51bnppcCkoYnl0ZXMpO1xuICAgICAgICBjb25zdCBib2R5ID0gZGV0ZWN0VHlwZShieXRlcywgb3B0aW9ucy50eXBlKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZnVsbClcbiAgICAgICAgICAgIHJldHVybiB7IGhlYWRlcnM6IHJlcy5oZWFkZXJzLCBzdGF0dXMsIGJvZHkgfTtcbiAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVFcnJvciA9IGFzeW5jIChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdERVBUSF9aRVJPX1NFTEZfU0lHTkVEX0NFUlQnKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZmV0Y2hOb2RlKHVybCwgeyAuLi5vcHRpb25zLCBzc2xBbGxvd1NlbGZTaWduZWQ6IHRydWUsIHNzbFBpbm5lZENlcnRpZmljYXRlczogW10gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlICYmIGUuZmluZ2VycHJpbnQyNTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IG5ldyBJbnZhbGlkQ2VydEVycm9yKGBTZWxmLXNpZ25lZCBTU0wgY2VydGlmaWNhdGU6ICR7ZS5maW5nZXJwcmludDI1Nn1gLCBlLmZpbmdlcnByaW50MjU2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXEgPSAoaXNTZWN1cmUgPyBodHRwcyA6IGh0dHApLnJlcXVlc3QodXJsLCBvcHRzLCAocmVzKSA9PiB7XG4gICAgICAgICAgICByZXMub24oJ2Vycm9yJywgaGFuZGxlRXJyb3IpO1xuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGF3YWl0IGhhbmRsZVJlcyhyZXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcS5vbignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgIGNvbnN0IHBpbm5lZCA9IG9wdGlvbnMuc3NsUGlubmVkQ2VydGlmaWNhdGVzPy5tYXAoKGkpID0+IGNvbXBhY3RGUChpKSk7XG4gICAgICAgIGNvbnN0IG1mZXRjaFNlY3VyZUNvbm5lY3QgPSAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcDI1NiA9IGNvbXBhY3RGUChzb2NrZXQuZ2V0UGVlckNlcnRpZmljYXRlKCk/LmZpbmdlcnByaW50MjU2IHx8ICcnKTtcbiAgICAgICAgICAgIGlmICghZnAyNTYgJiYgc29ja2V0LmlzU2Vzc2lvblJldXNlZCgpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChwaW5uZWQuaW5jbHVkZXMoZnAyNTYpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHJlcS5lbWl0KCdlcnJvcicsIG5ldyBJbnZhbGlkQ2VydEVycm9yKGBJbnZhbGlkIFNTTCBjZXJ0aWZpY2F0ZTogJHtmcDI1Nn0gRXhwZWN0ZWQ6ICR7cGlubmVkfWAsIGZwMjU2KSk7XG4gICAgICAgICAgICByZXR1cm4gcmVxLmFib3J0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLnNzbFBpbm5lZENlcnRpZmljYXRlcykge1xuICAgICAgICAgICAgcmVxLm9uKCdzb2NrZXQnLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzTGlzdGVuZXJzID0gc29ja2V0XG4gICAgICAgICAgICAgICAgICAgIC5saXN0ZW5lcnMoJ3NlY3VyZUNvbm5lY3QnKVxuICAgICAgICAgICAgICAgICAgICAubWFwKChpKSA9PiAoaS5uYW1lIHx8ICcnKS5yZXBsYWNlKCdib3VuZCAnLCAnJykpXG4gICAgICAgICAgICAgICAgICAgIC5pbmNsdWRlcygnbWZldGNoU2VjdXJlQ29ubmVjdCcpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNMaXN0ZW5lcnMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBzb2NrZXQub24oJ3NlY3VyZUNvbm5lY3QnLCBtZmV0Y2hTZWN1cmVDb25uZWN0LmJpbmQobnVsbCwgc29ja2V0KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5rZWVwQWxpdmUpXG4gICAgICAgICAgICByZXEuc2V0Tm9EZWxheSh0cnVlKTtcbiAgICAgICAgaWYgKG9wdHMuYm9keSlcbiAgICAgICAgICAgIHJlcS53cml0ZShvcHRzLmJvZHkpO1xuICAgICAgICByZXEuZW5kKCk7XG4gICAgfSk7XG59XG5jb25zdCBTQUZFX0hFQURFUlMgPSBuZXcgU2V0KFsnQWNjZXB0JywgJ0FjY2VwdC1MYW5ndWFnZScsICdDb250ZW50LUxhbmd1YWdlJywgJ0NvbnRlbnQtVHlwZSddLm1hcCgoaSkgPT4gaS50b0xvd2VyQ2FzZSgpKSk7XG5jb25zdCBGT1JCSURERU5fSEVBREVSUyA9IG5ldyBTZXQoWydBY2NlcHQtQ2hhcnNldCcsICdBY2NlcHQtRW5jb2RpbmcnLCAnQWNjZXNzLUNvbnRyb2wtUmVxdWVzdC1IZWFkZXJzJywgJ0FjY2Vzcy1Db250cm9sLVJlcXVlc3QtTWV0aG9kJyxcbiAgICAnQ29ubmVjdGlvbicsICdDb250ZW50LUxlbmd0aCcsICdDb29raWUnLCAnQ29va2llMicsICdEYXRlJywgJ0ROVCcsICdFeHBlY3QnLCAnSG9zdCcsICdLZWVwLUFsaXZlJywgJ09yaWdpbicsICdSZWZlcmVyJywgJ1RFJywgJ1RyYWlsZXInLFxuICAgICdUcmFuc2Zlci1FbmNvZGluZycsICdVcGdyYWRlJywgJ1ZpYSddLm1hcCgoaSkgPT4gaS50b0xvd2VyQ2FzZSgpKSk7XG5hc3luYyBmdW5jdGlvbiBmZXRjaEJyb3dzZXIodXJsLCBfb3B0aW9ucykge1xuICAgIGxldCBvcHRpb25zID0geyAuLi5ERUZBVUxUX09QVCwgLi4uX29wdGlvbnMgfTtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBpZiAob3B0aW9ucy50eXBlID09PSAnanNvbicpXG4gICAgICAgIGhlYWRlcnMuc2V0KCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIGxldCBwYXJzZWQgPSBuZXcgVVJMKHVybCk7XG4gICAgaWYgKHBhcnNlZC51c2VybmFtZSkge1xuICAgICAgICBjb25zdCBhdXRoID0gYnRvYShgJHtwYXJzZWQudXNlcm5hbWV9OiR7cGFyc2VkLnBhc3N3b3JkfWApO1xuICAgICAgICBoZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCYXNpYyAke2F1dGh9YCk7XG4gICAgICAgIHBhcnNlZC51c2VybmFtZSA9ICcnO1xuICAgICAgICBwYXJzZWQucGFzc3dvcmQgPSAnJztcbiAgICB9XG4gICAgdXJsID0gJycgKyBwYXJzZWQ7XG4gICAgZm9yIChsZXQgayBpbiBvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGsudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFNBRkVfSEVBREVSUy5oYXMobmFtZSkgfHwgKG9wdGlvbnMuY29ycyAmJiAhRk9SQklEREVOX0hFQURFUlMuaGFzKG5hbWUpKSlcbiAgICAgICAgICAgIGhlYWRlcnMuc2V0KGssIG9wdGlvbnMuaGVhZGVyc1trXSk7XG4gICAgfVxuICAgIGxldCBvcHRzID0geyBoZWFkZXJzLCByZWRpcmVjdDogb3B0aW9ucy5yZWRpcmVjdCA/ICdmb2xsb3cnIDogJ21hbnVhbCcgfTtcbiAgICBpZiAoIW9wdGlvbnMucmVmZXJyZXIpXG4gICAgICAgIG9wdHMucmVmZXJyZXJQb2xpY3kgPSAnbm8tcmVmZXJyZXInO1xuICAgIGlmIChvcHRpb25zLmNvcnMpXG4gICAgICAgIG9wdHMubW9kZSA9ICdjb3JzJztcbiAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5tZXRob2QpXG4gICAgICAgICAgICBvcHRzLm1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgb3B0cy5ib2R5ID0gb3B0aW9ucy50eXBlID09PSAnanNvbicgPyBKU09OLnN0cmluZ2lmeShvcHRpb25zLmRhdGEpIDogb3B0aW9ucy5kYXRhO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIG9wdHMpO1xuICAgIGlmIChvcHRpb25zLmV4cGVjdFN0YXR1c0NvZGUgJiYgcmVzLnN0YXR1cyAhPT0gb3B0aW9ucy5leHBlY3RTdGF0dXNDb2RlKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN0YXR1c0NvZGVFcnJvcihyZXMuc3RhdHVzKTtcbiAgICBjb25zdCBib2R5ID0gZGV0ZWN0VHlwZShuZXcgVWludDhBcnJheShhd2FpdCByZXMuYXJyYXlCdWZmZXIoKSksIG9wdGlvbnMudHlwZSk7XG4gICAgaWYgKG9wdGlvbnMuZnVsbClcbiAgICAgICAgcmV0dXJuIHsgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKHJlcy5oZWFkZXJzLmVudHJpZXMoKSksIHN0YXR1czogcmVzLnN0YXR1cywgYm9keSB9O1xuICAgIHJldHVybiBib2R5O1xufVxuY29uc3QgSVNfTk9ERSA9ICEhKHR5cGVvZiBwcm9jZXNzID09ICdvYmplY3QnICYmXG4gICAgcHJvY2Vzcy52ZXJzaW9ucyAmJlxuICAgIHByb2Nlc3MudmVyc2lvbnMubm9kZSAmJlxuICAgIHByb2Nlc3MudmVyc2lvbnMudjgpO1xuZnVuY3Rpb24gZmV0Y2hVcmwodXJsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZm4gPSBJU19OT0RFID8gZmV0Y2hOb2RlIDogZmV0Y2hCcm93c2VyO1xuICAgIHJldHVybiBmbih1cmwsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZmV0Y2hVcmw7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/micro-ftch/index.js\n");

/***/ })

};
;